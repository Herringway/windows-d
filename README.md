# The D Windows SDK projection

Bindings of Windows SDK in D language based on metadata files generated by [Win32 Metadata Project](https://github.com/microsoft/win32metadata/)

## Usage

Build the executable as needed and run it to generate source code files containing bindings for the Windows SDK. Latest run result ca be found [here](https://github.com/rumbu13/windows-d/tree/master/meta) 

```
wind --meta .\meta\Windows.Win32.winmd --core .\cfg\core.d --out out --ignore .\cfg\ignore.cfg --replace .\cfg\replace.cfg 
```

## Building

Build and run were tested on Windows, but the generator code is not platform dependent, it should work also on Linux. A dub.json file is provided for convenience, but the application was compiled and tested only in Visual Studio using the corresponding solution file ```wind.sln```. Linux testers are welcome.

## Features

- Code formatting. Lines have a maximum length of 120 characters. You can override this setting by changing the constant ```maxLineWidth = 120```. Function declarations are aligned to the width of the result type having a hard limit set in the constant ```maxReturnTypeAlignment = 8```. Struct members are also aligned to the width of the type having a hard limit that you can set in the constant ```maxFieldAlignment = 20```. Function parameters are also aligned to open paranthesis starting the parameter list.

```
struct CQPAGE
{
    uint         cbStruct;
    uint         dwFlags;
    LPCQPAGEPROC pPageProc;
    HINSTANCE    hInstance;
    int          idPageName;
    int          idPageTemplate;
    DLGPROC      pDlgProc;
    LPARAM       lParam;
}

interface IServerSecurity : IUnknown
{
    HRESULT QueryBlanket(uint* pAuthnSvc, uint* pAuthzSvc, ushort** pServerPrincName, uint* pAuthnLevel, 
                         uint* pImpLevel, void** pPrivs, uint* pCapabilities);
    HRESULT ImpersonateClient();
    HRESULT RevertToSelf();
    BOOL    IsImpersonating();
}

```
- Selective imports. Based on the dependency graph, imports between modules are limited to the types which are really used

```
module windows.componentservices;

public import windows.core;
public import windows.automation : BSTR, IDispatch, SAFEARRAY, VARIANT;
public import windows.com : APTTYPE, EOC_ChangeType, HRESULT, IClassFactory, IMoniker, IUnknown;
public import windows.systemservices : BOOL, HANDLE;
public import windows.winsock : BLOB;
public import windows.windowsprogramming : FILETIME;

```

- Constant grouping. In the metadata files, constants are listed globally, the application tries to find a common pattern and group them accordingly. You can control this behaviour using the constant ```minSetTreshold = 0.4``` representing the proportion of common characters.

```
enum : int
{
    HH_TAB_INDEX        = 0x00000001,
    HH_TAB_SEARCH       = 0x00000002,
    HH_TAB_FAVORITES    = 0x00000003,
    HH_TAB_HISTORY      = 0x00000004,
    HH_TAB_AUTHOR       = 0x00000005,
    HH_TAB_CUSTOM_FIRST = 0x0000000b,
    HH_TAB_CUSTOM_LAST  = 0x00000013,
}

enum : int
{
    HHACT_TAB_INDEX     = 0x00000001,
    HHACT_TAB_SEARCH    = 0x00000002,
    HHACT_TAB_HISTORY   = 0x00000003,
    HHACT_TAB_FAVORITES = 0x00000004,
}

```

## Design choices

- Strongly typed handles. In the metadata, most of the ```HANDLE``` types are strongly typed as trcuts with a single member, forcing the use of that struct as a parameter for various functions. For backward compatibility reasons, these structs are unfolded and converted to plain ```ptrdiff_t``` values. This is needed beacause corresponding constants are integers, you cannot assign or compare these constants to structs.

```
//Original metadata
struct HBITMAP
{
    ptrdiff_t Value;
}

//D code
alias HBITMAP = ptrdiff_t;
```

- GUID decorating. Interfaces and several structs are decorated with GUID attributes. The old IID_ constants from Windows headers are missing, therefore the generator will create them based on the name of decorated item. The template doing this mapping (```GUIDOF```) can be found in the file core.d. Conventionally every COM interface has an associated IID_ guid, any other type has an associated CLSID_ guid.

```
@GUID("8BA5FB08-5195-40E2-AC58-0D989C3A0102")
interface ID3DBlob : IUnknown
{
    void*  GetBufferPointer();
    size_t GetBufferSize();
}

@GUID("7B40792D-05FF-44C4-9058-F440C71F17D4")
struct CTraceRelogger;

const GUID IID_ID3DBlob = GUIDOF!ID3DBlob;
const GUID CLSID_CTraceRelogger = GUIDOF!CTraceRelogger;

```

- Library decorating. All functions are decorated with a ```@DllImport``` attribute stating the corresponding library file where the function can be found. This can help later at generating .lib files or at loading dynamic bindings.

```
@DllImport("d3d12")
HRESULT D3D12EnableExperimentalFeatures(uint NumFeatures, char* pIIDs, char* pConfigurationStructs, 
                                        char* pConfigurationStructSizes);
```

## Similar projects:

- [The C++ Windows SDK projection](https://github.com/microsoft/cppwin32)
- [The C++/WinRT language projection](https://github.com/microsoft/cppwinrt/)
- [Rust for Windows](https://github.com/microsoft/windows-rs)
