// Written in the D programming language.

module windows.http;

public import windows.core;
public import windows.networkdrivers : SOCKADDR_STORAGE_LH;
public import windows.systemservices : BOOL, HANDLE, OVERLAPPED, PSTR, PWSTR,
                                       SECURITY_ATTRIBUTES, ULARGE_INTEGER;
public import windows.wininet : INTERNET_SCHEME;
public import windows.winsock : SOCKADDR;
public import windows.windowsprogramming : FILETIME, SYSTEMTIME;

extern(Windows) @nogc nothrow:


// Enums


///The <b>HTTP_SERVER_PROPERTY</b> enumeration defines the properties that are configured by the HTTP Server API on a
///URL group, server session, or request queue.
alias HTTP_SERVER_PROPERTY = int;
enum : int
{
    ///The authentication property enables server-side authentication for a URL group, or server session using the
    ///Basic, NTLM, Negotiate, and Digest authentication schemes. The HTTP_SERVER_AUTHENTICATION_INFO structure contains
    ///the configuration data for this property.
    HttpServerAuthenticationProperty         = 0x00000000,
    ///The logging property enables logging for a server session or URL group. The HTTP_LOGGING_INFO structure contains
    ///the configuration data for this property.
    HttpServerLoggingProperty                = 0x00000001,
    ///The QOS property enables settings affecting quality of service, such as limiting the maximum number of
    ///outstanding connections served for a URL group at any given time or limiting the response send bandwidth for a
    ///server session or URL group. The HTTP_QOS_SETTING_INFO structure contains the configuration data for this
    ///property.
    HttpServerQosProperty                    = 0x00000002,
    ///The timeouts property configures timeouts for a server session or URL group. The HTTP_TIMEOUT_LIMIT_INFO
    ///structure contains the configuration data for this property.
    HttpServerTimeoutsProperty               = 0x00000003,
    ///The connections property limits the number of requests in the request queue. This is a <b>ULONG</b>.
    HttpServerQueueLengthProperty            = 0x00000004,
    ///The connections property configures the state of a URL group, server session, or request queue. The
    ///HTTP_STATE_INFO structure contains the configuration data for this property for the URL group or server session.
    ///The request queue uses the HTTP_ENABLED_STATE enumeration to configure this property.
    HttpServerStateProperty                  = 0x00000005,
    ///The 503 verbosity property configures the verbosity level of 503 responses generated by the HTTP Server API for a
    ///request queue. The HTTP_503_RESPONSE_VERBOSITY enumeration contains the configuration data for this property.
    HttpServer503VerbosityProperty           = 0x00000006,
    ///The binding property associates a URL group with a request queue. The HTTP_BINDING_INFO structure contains the
    ///configuration data for this property.
    HttpServerBindingProperty                = 0x00000007,
    ///The extended authentication property enables server-side authentication for a URL group, or server session using
    ///the Kerberos authentication scheme. The HTTP_SERVER_AUTHENTICATION_INFO structure contains the configuration data
    ///for this property.
    HttpServerExtendedAuthenticationProperty = 0x00000008,
    ///Listening endpoint property.
    HttpServerListenEndpointProperty         = 0x00000009,
    ///This property implements authorization channel binding. The HTTP_CHANNEL_BIND_INFO structure contains the
    ///authorization details.
    HttpServerChannelBindProperty            = 0x0000000a,
    HttpServerProtectionLevelProperty        = 0x0000000b,
}

///The <b>HTTP_ENABLED_STATE</b> enumeration defines the state of a request queue, server session, or URL Group. This
///enumeration is used in the HTTP_STATE_INFO struct
alias HTTP_ENABLED_STATE = int;
enum : int
{
    ///The HTTP Server API object is enabled.
    HttpEnabledStateActive   = 0x00000000,
    ///The HTTP Server API object is disabled.
    HttpEnabledStateInactive = 0x00000001,
}

///The <b>HTTP_503_RESPONSE_VERBOSITY</b> enumeration defines the verbosity levels for a 503, service unavailable, error
///responses. This structure must be used when setting or querying the HttpServer503ResponseProperty on a request queue.
alias HTTP_503_RESPONSE_VERBOSITY = int;
enum : int
{
    ///A 503 response is not sent; the connection is reset. This is the default HTTP Server API behavior.
    Http503ResponseVerbosityBasic   = 0x00000000,
    ///The HTTP Server API sends a 503 response with a "Service Unavailable" reason phrase. The HTTP Server closes the
    ///TCP connection after sending the response, so the client has to re-connect.
    Http503ResponseVerbosityLimited = 0x00000001,
    ///The HTTP Server API sends a 503 response with a detailed reason phrase. The HTTP Server closes the TCP connection
    ///after sending the response, so the client has to re-connect.
    Http503ResponseVerbosityFull    = 0x00000002,
}

///The <b>HTTP_QOS_SETTING_TYPE</b> enumeration identifies the type of a QOS setting contained in a
///HTTP_QOS_SETTING_INFO structure.
alias HTTP_QOS_SETTING_TYPE = int;
enum : int
{
    ///The setting is a bandwidth limit represented by a HTTP_BANDWIDTH_LIMIT_INFO structure.
    HttpQosSettingTypeBandwidth       = 0x00000000,
    ///The setting is a connection limit represented by a HTTP_CONNECTION_LIMIT_INFO structure.
    HttpQosSettingTypeConnectionLimit = 0x00000001,
    ///A flow rate represented by HTTP_FLOWRATE_INFO. <div class="alert"><b>Note</b> Windows Server 2008 R2 and Windows
    ///7 only.</div> <div> </div>
    HttpQosSettingTypeFlowRate        = 0x00000002,
}

///The <b>HTTP_SERVICE_CONFIG_TIMEOUT_KEY</b> enumeration defines the type of timer that is queried or configured
///through the HTTP_SERVICE_CONFIG_TIMEOUT_SET structure.
alias HTTP_SERVICE_CONFIG_TIMEOUT_KEY = int;
enum : int
{
    ///The maximum time allowed for a connection to remain idle, after which, the connection is timed out and reset.
    IdleConnectionTimeout = 0x00000000,
    ///The maximum time allowed to parse all the request headers, including the request line, after which, the
    ///connection is timed out and reset.
    HeaderWaitTimeout     = 0x00000001,
}

alias HTTP_SERVICE_CONFIG_SETTING_KEY = int;
enum : int
{
    HttpNone        = 0x00000000,
    HttpTlsThrottle = 0x00000001,
}

///The <b>HTTP_SERVICE_BINDING_TYPE</b> enumerated type specifies the string type for service names.
alias HTTP_SERVICE_BINDING_TYPE = int;
enum : int
{
    ///No type.
    HttpServiceBindingTypeNone = 0x00000000,
    ///Unicode.
    HttpServiceBindingTypeW    = 0x00000001,
    HttpServiceBindingTypeA    = 0x00000002,
}

///Server Hardening level.
alias HTTP_AUTHENTICATION_HARDENING_LEVELS = int;
enum : int
{
    ///Server is not hardened and operates without Channel Binding Token (CBT) support.
    HttpAuthenticationHardeningLegacy = 0x00000000,
    ///Server is partially hardened. Clients that support CBT are serviced appropriately. Legacy clients are also
    ///serviced.
    HttpAuthenticationHardeningMedium = 0x00000001,
    HttpAuthenticationHardeningStrict = 0x00000002,
}

///The <b>HTTP_LOGGING_TYPE</b> enumeration defines the type of logging that is performed. This enumeration is used in
///the HTTP_LOGGING_INFO structure.
alias HTTP_LOGGING_TYPE = int;
enum : int
{
    ///The log format is W3C style extended logging. Applications choose the fields that are logged in the <b>Fields</b>
    ///member of the HTTP_LOGGING_INFO structure. When this type of logging is set on a URL Group, logging is similar to
    ///the IIS6 site logging. When set on a server session this format functions as a centralized logging for all of the
    ///URL Groups.
    HttpLoggingTypeW3C  = 0x00000000,
    ///The log format is IIS5/6 style logging. This format has a fixed field definition; applications cannot choose
    ///which fields are logged. This format cannot be chosen when setting the logging property on a server session.
    HttpLoggingTypeIIS  = 0x00000001,
    ///The log format is NCSA style logging. This format has a fixed field definition; applications cannot choose which
    ///fields are logged. This format cannot be chosen when setting the logging property on a server session.
    HttpLoggingTypeNCSA = 0x00000002,
    ///The log format is centralized binary logging. This format has a fixed field definition; applications cannot
    ///choose which fields are logged. This format cannot be chosen when setting the logging property on a URL Group.
    HttpLoggingTypeRaw  = 0x00000003,
}

///The <b>HTTP_LOGGING_ROLLOVER_TYPE</b> enumeration defines the log file rollover types. This enumeration is used in
///the HTTP_LOGGING_INFO structure.
alias HTTP_LOGGING_ROLLOVER_TYPE = int;
enum : int
{
    ///The log files are rolled over when they reach a specified size.
    HttpLoggingRolloverSize    = 0x00000000,
    ///The log files are rolled over every day.
    HttpLoggingRolloverDaily   = 0x00000001,
    ///The log files are rolled over every week.
    HttpLoggingRolloverWeekly  = 0x00000002,
    ///The log files are rolled over every month.
    HttpLoggingRolloverMonthly = 0x00000003,
    ///The log files are rolled over every hour, based on GMT.
    HttpLoggingRolloverHourly  = 0x00000004,
}

alias HTTP_PROTECTION_LEVEL_TYPE = int;
enum : int
{
    HttpProtectionLevelUnrestricted   = 0x00000000,
    HttpProtectionLevelEdgeRestricted = 0x00000001,
    HttpProtectionLevelRestricted     = 0x00000002,
}

alias _HTTP_URI_SCHEME = int;
enum : int
{
    HttpSchemeHttp    = 0x00000000,
    HttpSchemeHttps   = 0x00000001,
    HttpSchemeMaximum = 0x00000002,
}

///The <b>HTTP_VERB</b> enumeration type defines values that are used to specify known, standard HTTP verbs in the
///HTTP_REQUEST structure. The majority of these known verbs are documented in RFC 2616 and RFC 2518, as indicated
///below.
alias HTTP_VERB = int;
enum : int
{
    ///Not relevant for applications; used only in kernel mode.
    HttpVerbUnparsed  = 0x00000000,
    ///Indicates that the application can examine the <b>UnknownVerbLength</b> and <b>pUnknownVerb</b> members of the
    ///HTTP_REQUEST structure to retrieve the HTTP verb for the request. This is the case in an HTTP/1.1 request when a
    ///browser client specifies a custom verb.
    HttpVerbUnknown   = 0x00000001,
    ///Not relevant for applications; used only in kernel mode.
    HttpVerbInvalid   = 0x00000002,
    ///The OPTIONS method requests information about the communication options and requirements associated with a URI.
    ///See page 52 of RFC 2616.
    HttpVerbOPTIONS   = 0x00000003,
    ///The GET method retrieves the information or entity that is identified by the URI of the Request. If that URI
    ///refers to a script or other data-producing process, it is the data produced, not the text of the script, that is
    ///returned in the response. A GET method can be made conditional or partial by including a conditional or Range
    ///header field in the request. A conditional GET requests that the entity be sent only if all conditions specified
    ///in the header are met, and a partial GET requests only part of the entity, as specified in the Range header. Both
    ///of these forms of GET can help avoid unnecessary network traffic. See page 53 of RFC 2616.
    HttpVerbGET       = 0x00000004,
    ///The HEAD method is identical to GET except that the server only returns message-headers in the response, without
    ///a message-body. The headers are the same as would be returned in response to a GET. See page 54 of RFC 2616.
    HttpVerbHEAD      = 0x00000005,
    ///The POST method is used to post a new entity as an addition to a URI. The URI identifies an entity that consumes
    ///the posted data in some fashion. See page 54 of RFC 2616.
    HttpVerbPOST      = 0x00000006,
    ///The PUT method is used to replace an entity identified by a URI. See page 55 of RFC 2616.
    HttpVerbPUT       = 0x00000007,
    ///The DELETE method requests that a specified URI be deleted. See page 56 of RFC 2616.
    HttpVerbDELETE    = 0x00000008,
    ///The TRACE method invokes a remote, application-layer loop-back of the request message. It allows the client to
    ///see what is being received at the other end of the request chain for diagnostic purposes. See page 56 of RFC
    ///2616.
    HttpVerbTRACE     = 0x00000009,
    ///The CONNECT method can be used with a proxy that can dynamically switch to tunneling, as in the case of SSL
    ///tunneling. See page 57 of RFC 2616.
    HttpVerbCONNECT   = 0x0000000a,
    ///The TRACK method is used by Microsoft Cluster Server to implement a non-logged trace.
    HttpVerbTRACK     = 0x0000000b,
    ///The MOVE method requests a WebDAV operation equivalent to a copy (COPY), followed by consistency maintenance
    ///processing, followed by a delete of the source, where all three actions are performed atomically. When applied to
    ///a collection, "Depth" is assumed to be or must be specified as "infinity". See page 42 of RFC 2518.
    HttpVerbMOVE      = 0x0000000c,
    ///The COPY method requests a WebDAV operation that creates a duplicate of the source resource, identified by the
    ///Request URI, in the destination resource, identified by a URI specified in the Destination header. See page 37 of
    ///RFC 2518.
    HttpVerbCOPY      = 0x0000000d,
    ///The PROPFIND method requests a WebDAV operation that retrieves properties defined on the resource identified by
    ///the Request-URI. See page 24 of RFC 2518.
    HttpVerbPROPFIND  = 0x0000000e,
    ///The PROPPATCH method requests a WebDAV operation that sets and/or removes properties defined on the resource
    ///identified by the Request-URI. See page 31 of RFC 2518.
    HttpVerbPROPPATCH = 0x0000000f,
    ///The MKCOL method requests a WebDAV operation that creates a new collection resource at the location specified by
    ///the Request-URI. See page 33 of RFC 2518.
    HttpVerbMKCOL     = 0x00000010,
    ///The LOCK method requests a WebDAV operation that creates a lock as specified by the lockinfo XML element on the
    ///Request-URI. See page 45 of RFC 2518.
    HttpVerbLOCK      = 0x00000011,
    ///The UNLOCK method requests a WebDAV operation that removes a lock, identified by a lock token in the Lock-Token
    ///request header, from the resource identified by the Request-URI, and from all other resources included in the
    ///lock. See page 51 of RFC 2518.
    HttpVerbUNLOCK    = 0x00000012,
    ///The SEARCH method requests a WebDAV operation used by Microsoft Exchange to search folders. See the Internet
    ///Engineering Task Force (IETF) Internet Draft WebDAV SEARCH for more information, and the WebDAV Web site for
    ///possible updates.
    HttpVerbSEARCH    = 0x00000013,
    ///Terminates the enumeration; is not used to define a verb.
    HttpVerbMaximum   = 0x00000014,
}

///The <b>HTTP_HEADER_ID</b> enumeration type lists <i>known headers</i> for HTTP requests and responses, and associates
///an array index with each such header. It is used to size and access the <b>KnownHeaders</b> array members of the
///HTTP_REQUEST_HEADERS and HTTP_RESPONSE_HEADERS structures.
alias HTTP_HEADER_ID = int;
enum : int
{
    ///Used to specify caching behavior along the request or response chain, overriding the default caching algorithm.
    HttpHeaderCacheControl       = 0x00000000,
    ///Allows the sender to specify options that are desired for that particular connection. These are used for a single
    ///connection only and must not be communicated by proxies over further connections.
    HttpHeaderConnection         = 0x00000001,
    ///The Date is a general header field that indicates the time that the request or response was sent.
    HttpHeaderDate               = 0x00000002,
    ///Based on the keepalive XML element (see RFC 2518, section 12.12.1, page 66); a list of URIs included in the
    ///KeepAlive header must be "live" after they are copied (moved) to the destination.
    HttpHeaderKeepAlive          = 0x00000003,
    ///Used to include optional, implementation-specific directives that might apply to any recipient along the
    ///request/response chain.
    HttpHeaderPragma             = 0x00000004,
    ///Indicates that specified header fields are present in the trailer of a message encoded with chunked
    ///transfer-coding.
    HttpHeaderTrailer            = 0x00000005,
    ///Indicates what, if any, transformations have been applied to the message body in transit.
    HttpHeaderTransferEncoding   = 0x00000006,
    ///Allows the client to specify one or more other communication protocols it would prefer to use if the server can
    ///comply.
    HttpHeaderUpgrade            = 0x00000007,
    ///The Via header field indicates the path taken by the request.
    HttpHeaderVia                = 0x00000008,
    ///This is a response header that contains the 3-digit warn code along with the reason phrase.
    HttpHeaderWarning            = 0x00000009,
    ///Lists the set of methods supported by the resource identified by the Request-URI.
    HttpHeaderAllow              = 0x0000000a,
    ///The size of the message body in decimal bytes.
    HttpHeaderContentLength      = 0x0000000b,
    ///The media type of the message body.
    HttpHeaderContentType        = 0x0000000c,
    ///The encoding scheme for the message body.
    HttpHeaderContentEncoding    = 0x0000000d,
    ///Provides the natural language of the intended audience.
    HttpHeaderContentLanguage    = 0x0000000e,
    ///Location of the resource for the entity enclosed in the message when that entity is accessible from a location
    ///separate from the requested resource's URI.
    HttpHeaderContentLocation    = 0x0000000f,
    ///An MD5 digest of the entity-body used to provide end-to-end message integrity check (MIC) of the entity-body.
    HttpHeaderContentMd5         = 0x00000010,
    ///The content range header is sent with a partial entity body to specify where in the full entity body the partial
    ///body should be applied.
    HttpHeaderContentRange       = 0x00000011,
    ///The date and time after which the message content expires.
    HttpHeaderExpires            = 0x00000012,
    ///Indicates the date and time at which the origin server believes the variant was last modified.
    HttpHeaderLastModified       = 0x00000013,
    ///Used with the INVITE, OPTIONS, and REGISTER methods to indicate what media types are acceptable in the response.
    HttpHeaderAccept             = 0x00000014,
    ///Indicates the character sets that are acceptable for the response.
    HttpHeaderAcceptCharset      = 0x00000015,
    ///The content encodings that are acceptable in the response.
    HttpHeaderAcceptEncoding     = 0x00000016,
    ///Used by the client to indicate to the server which language it would prefer to receive reason phrases, session
    ///descriptions, or status responses.
    HttpHeaderAcceptLanguage     = 0x00000017,
    ///The user-agent can authenticate itself with a server by sending the Authorization request header field with the
    ///request. The field contains the credentials for the domain that the user is requesting.
    HttpHeaderAuthorization      = 0x00000018,
    ///The cookie request header contains data used to maintain client state with the server. Cookie data is obtained
    ///from a response sent with <b>HttpHeaderSetCookie</b>.
    HttpHeaderCookie             = 0x00000019,
    ///Indicates the specific server behaviors that are required by the client.
    HttpHeaderExpect             = 0x0000001a,
    ///The From header field specifies the initiator of the SIP request or response message.
    HttpHeaderFrom               = 0x0000001b,
    ///Specifies the Internet host and port number of the requested resource. This is obtained from the original URI
    ///given by the user or referring resource.
    HttpHeaderHost               = 0x0000001c,
    ///The If-Match request header field is used with a method to make it conditional. A client that has one or more
    ///entities previously obtained from the resource can verify that one of those entities is current by including a
    ///list of their associated entity tags in the If-Match header field.
    HttpHeaderIfMatch            = 0x0000001d,
    ///The If-Modified-Since request header field is used with a method to make it conditional. If the requested variant
    ///has not been modified since the time specified in this field, an entity is not returned from the server; instead,
    ///a 304 (not modified) response is returned without any message-body.
    HttpHeaderIfModifiedSince    = 0x0000001e,
    ///The If-None-Match request-header field is used with a method to make it conditional. When a client has obtained
    ///one or more entities from a resource, it can verify that none of those entities is current by including a list of
    ///their associated entity tags in the If-None-Match header field. The purpose of this feature is to allow efficient
    ///updates of cached information with a minimum amount of transaction overhead, and to prevent a method such as PUT
    ///from inadvertently modifying an existing resource when the client believes that the resource does not exist.
    HttpHeaderIfNoneMatch        = 0x0000001f,
    ///If a client has a partial copy of an entity in its cache, and wishes to obtain an up-to-date copy of the entire
    ///entity, it can use the If-Range header. Informally, its meaning is, "if the entity is unchanged, send me the
    ///part(s) I am missing; otherwise, send me the entire new entity."
    HttpHeaderIfRange            = 0x00000020,
    ///The If-Unmodified-Since request-header field is used with a method to make it conditional. If the requested
    ///resource has not been modified since the time specified in this field, the server performs the requested
    ///operation as if the If-Unmodified-Since header were not present, but if the requested resource has been modified,
    ///the server returns a 412 error (Precondition Failed).
    HttpHeaderIfUnmodifiedSince  = 0x00000021,
    ///The maximum number of proxies or gateways that can forward the request.
    HttpHeaderMaxForwards        = 0x00000022,
    ///This header field is used by the client to identify itself with a proxy.
    HttpHeaderProxyAuthorization = 0x00000023,
    ///Allows the client to specify, for the server's benefit, the address (URI) of the resource from which the
    ///Request-URI was obtained.
    HttpHeaderReferer            = 0x00000024,
    ///Allows a client to request a part of an entity instead of the whole.
    HttpHeaderRange              = 0x00000025,
    ///This header field contains the recipient of the SIP request or response message.
    HttpHeaderTe                 = 0x00000026,
    ///Allows the client to specify whether it wants the source representation or programmatic interpretation of the
    ///requested content.
    HttpHeaderTranslate          = 0x00000027,
    ///Indicates what extension transfer-codings the client accepts in the response and whether or not the client
    ///accepts trailer fields in a chunked transfer-coding.
    HttpHeaderUserAgent          = 0x00000028,
    ///Not a value that actually designates a header; instead, it is used to count the enumerated Request headers.
    HttpHeaderRequestMaximum     = 0x00000029,
    ///Allows the server to indicate its acceptance of range requests for a resource.
    HttpHeaderAcceptRanges       = 0x00000014,
    ///Conveys the sender's estimate of the amount of time since the response (or its revalidation) was generated at the
    ///origin server.
    HttpHeaderAge                = 0x00000015,
    ///Provides the current value of the entity tag for the requested variant.
    HttpHeaderEtag               = 0x00000016,
    ///Used to redirect the recipient to a location other than the Request-URI for completion of the request or
    ///identification of a new resource.
    HttpHeaderLocation           = 0x00000017,
    ///The response field that must be included as a part of the 407 response. The field includes the authentication
    ///scheme and parameters that apply to the proxy for this Request-URI.
    HttpHeaderProxyAuthenticate  = 0x00000018,
    ///The length of time that the service is expected to be unavailable to the requesting client.
    HttpHeaderRetryAfter         = 0x00000019,
    ///This is a response header field that contains information about the server that is handling the request.
    HttpHeaderServer             = 0x0000001a,
    ///The <b>set-cookie</b> response header contains data used to maintain client state in future requests sent with
    ///<b>HttpHeaderCookie</b>.
    HttpHeaderSetCookie          = 0x0000001b,
    ///Indicates the set of request header fields that fully determines, while the response is fresh, whether a cache is
    ///permitted to use the response to reply to a subsequent request without revalidation.
    HttpHeaderVary               = 0x0000001c,
    ///The WWW_Authenticate header field contains the authentication schemes and parameters applicable to the
    ///Request-URI.
    HttpHeaderWwwAuthenticate    = 0x0000001d,
    ///Not a value that actually designates a header; instead, it is used to count the enumerated Response headers.
    HttpHeaderResponseMaximum    = 0x0000001e,
    ///Not a value that actually designates a header; instead, it is used to count all the enumerated headers.
    HttpHeaderMaximum            = 0x00000029,
}

///The <b>HTTP_LOG_DATA_TYPE</b> enumeration identifies the type of log data.
alias HTTP_LOG_DATA_TYPE = int;
enum : int
{
    ///The HTTP_LOG_FIELDS_DATA structure is used for logging a request. This structure is passed to an
    ///HttpSendHttpResponse or HttpSendResponseEntityBody call.
    HttpLogDataTypeFields = 0x00000000,
}

///The HTTP_DATA_CHUNK_TYPE enumeration type defines the data source for a data chunk.
alias HTTP_DATA_CHUNK_TYPE = int;
enum : int
{
    ///The data source is a memory data block. The union should be interpreted as a <b>FromMemory</b> structure.
    HttpDataChunkFromMemory          = 0x00000000,
    ///The data source is a file handle data block. The union should be interpreted as a <b>FromFileHandle</b>
    ///structure.
    HttpDataChunkFromFileHandle      = 0x00000001,
    ///The data source is a fragment cache data block. The union should be interpreted as a <b>FromFragmentCache</b>
    ///structure.
    HttpDataChunkFromFragmentCache   = 0x00000002,
    ///The data source is a fragment cache data block. The union should be interpreted as a <b>FromFragmentCacheEx</b>
    ///structure. <b>Windows Server 2003 with SP1 and Windows XP with SP2: </b>This flag is not supported.
    HttpDataChunkFromFragmentCacheEx = 0x00000003,
    HttpDataChunkMaximum             = 0x00000004,
}

///Defines constants that specify a type of property information for a delegate request.
alias HTTP_DELEGATE_REQUEST_PROPERTY_ID = int;
enum : int
{
    ///This property is reserved.
    DelegateRequestReservedProperty = 0x00000000,
}

///The <b>HTTP_AUTH_STATUS</b> enumeration defines the authentication state of a request. This enumeration is used in
///the HTTP_REQUEST_AUTH_INFO structure.
alias HTTP_AUTH_STATUS = int;
enum : int
{
    ///The request was successfully authenticated for the authentication type indicated in the HTTP_REQUEST_AUTH_INFO
    ///structure.
    HttpAuthStatusSuccess          = 0x00000000,
    ///Authentication was configured on the URL group for this request, however, the HTTP Server API did not handle the
    ///authentication. This could be because of one of the following reasons: <ul> <li> The scheme defined in the
    ///HttpHeaderAuthorization header of the request is not supported by the HTTP Server API, or it is not enabled on
    ///the URL Group. If the scheme is not enabled, the <b>AuthType</b> member of HTTP_REQUEST_AUTH_INFO is set to the
    ///appropriate type, otherwise <b>AuthType</b> will have the value HttpRequestAuthTypeNone. </li> <li>The
    ///authorization header is not present, however, authentication is enabled on the URL Group.</li> </ul> The
    ///application should either proceed with its own authentication or respond with the initial 401 challenge
    ///containing the desired set of authentication schemes.
    HttpAuthStatusNotAuthenticated = 0x00000001,
    ///Authentication for the authentication type listed in the HTTP_REQUEST_AUTH_INFO structure failed, possibly due to
    ///one of the following reasons:<ul> <li>The Security Service Provider Interface (SSPI) based authentication scheme
    ///failed to successfully return from a call to AcceptSecurityContext. The error returned AcceptSecurityContext is
    ///indicated in the <b>SecStatus</b> member of the HTTP_REQUEST_AUTH_INFO structure.</li> <li>The finalized client
    ///context is for a Null NTLM session. Null sessions are treated as authentication failures.</li> <li>The call to
    ///<b>LogonUser</b> failed for the Basic authentication.</li> </ul>
    HttpAuthStatusFailure          = 0x00000002,
}

///The <b>HTTP_REQUEST_AUTH_TYPE</b> enumeration defines the authentication types supported by the HTTP Server API. This
///enumeration is used in the HTTP_REQUEST_AUTH_INFO structure.
alias HTTP_REQUEST_AUTH_TYPE = int;
enum : int
{
    ///No authentication is attempted for the request.
    HttpRequestAuthTypeNone      = 0x00000000,
    ///Basic authentication is attempted for the request.
    HttpRequestAuthTypeBasic     = 0x00000001,
    ///Digest authentication is attempted for the request.
    HttpRequestAuthTypeDigest    = 0x00000002,
    ///NTLM authentication is attempted for the request.
    HttpRequestAuthTypeNTLM      = 0x00000003,
    ///Negotiate authentication is attempted for the request.
    HttpRequestAuthTypeNegotiate = 0x00000004,
    ///Kerberos authentication is attempted for the request.
    HttpRequestAuthTypeKerberos  = 0x00000005,
}

alias HTTP_REQUEST_SIZING_TYPE = int;
enum : int
{
    HttpRequestSizingTypeTlsHandshakeLeg1ClientData = 0x00000000,
    HttpRequestSizingTypeTlsHandshakeLeg1ServerData = 0x00000001,
    HttpRequestSizingTypeTlsHandshakeLeg2ClientData = 0x00000002,
    HttpRequestSizingTypeTlsHandshakeLeg2ServerData = 0x00000003,
    HttpRequestSizingTypeHeaders                    = 0x00000004,
    HttpRequestSizingTypeMax                        = 0x00000005,
}

alias HTTP_REQUEST_TIMING_TYPE = int;
enum : int
{
    HttpRequestTimingTypeConnectionStart                = 0x00000000,
    HttpRequestTimingTypeDataStart                      = 0x00000001,
    HttpRequestTimingTypeTlsCertificateLoadStart        = 0x00000002,
    HttpRequestTimingTypeTlsCertificateLoadEnd          = 0x00000003,
    HttpRequestTimingTypeTlsHandshakeLeg1Start          = 0x00000004,
    HttpRequestTimingTypeTlsHandshakeLeg1End            = 0x00000005,
    HttpRequestTimingTypeTlsHandshakeLeg2Start          = 0x00000006,
    HttpRequestTimingTypeTlsHandshakeLeg2End            = 0x00000007,
    HttpRequestTimingTypeTlsAttributesQueryStart        = 0x00000008,
    HttpRequestTimingTypeTlsAttributesQueryEnd          = 0x00000009,
    HttpRequestTimingTypeTlsClientCertQueryStart        = 0x0000000a,
    HttpRequestTimingTypeTlsClientCertQueryEnd          = 0x0000000b,
    HttpRequestTimingTypeHttp2StreamStart               = 0x0000000c,
    HttpRequestTimingTypeHttp2HeaderDecodeStart         = 0x0000000d,
    HttpRequestTimingTypeHttp2HeaderDecodeEnd           = 0x0000000e,
    HttpRequestTimingTypeRequestHeaderParseStart        = 0x0000000f,
    HttpRequestTimingTypeRequestHeaderParseEnd          = 0x00000010,
    HttpRequestTimingTypeRequestRoutingStart            = 0x00000011,
    HttpRequestTimingTypeRequestRoutingEnd              = 0x00000012,
    HttpRequestTimingTypeRequestQueuedForInspection     = 0x00000013,
    HttpRequestTimingTypeRequestDeliveredForInspection  = 0x00000014,
    HttpRequestTimingTypeRequestReturnedAfterInspection = 0x00000015,
    HttpRequestTimingTypeRequestQueuedForDelegation     = 0x00000016,
    HttpRequestTimingTypeRequestDeliveredForDelegation  = 0x00000017,
    HttpRequestTimingTypeRequestReturnedAfterDelegation = 0x00000018,
    HttpRequestTimingTypeRequestQueuedForIO             = 0x00000019,
    HttpRequestTimingTypeRequestDeliveredForIO          = 0x0000001a,
    HttpRequestTimingTypeHttp3StreamStart               = 0x0000001b,
    HttpRequestTimingTypeHttp3HeaderDecodeStart         = 0x0000001c,
    HttpRequestTimingTypeHttp3HeaderDecodeEnd           = 0x0000001d,
    HttpRequestTimingTypeMax                            = 0x0000001e,
}

///The <b>HTTP_REQUEST_INFO_TYPE</b> enumeration defines the type of information contained in the HTTP_REQUEST_INFO
///structure. This enumeration is used in the HTTP_REQUEST_INFO structure.
alias HTTP_REQUEST_INFO_TYPE = int;
enum : int
{
    ///The request information type is authentication. The <b>pInfo</b> member of the HTTP_REQUEST_INFO structure points
    ///to a HTTP_REQUEST_AUTH_INFO structure.
    HttpRequestInfoTypeAuth                 = 0x00000000,
    HttpRequestInfoTypeChannelBind          = 0x00000001,
    HttpRequestInfoTypeSslProtocol          = 0x00000002,
    HttpRequestInfoTypeSslTokenBindingDraft = 0x00000003,
    HttpRequestInfoTypeSslTokenBinding      = 0x00000004,
    HttpRequestInfoTypeRequestTiming        = 0x00000005,
    HttpRequestInfoTypeTcpInfoV0            = 0x00000006,
    HttpRequestInfoTypeRequestSizing        = 0x00000007,
    HttpRequestInfoTypeQuicStats            = 0x00000008,
    HttpRequestInfoTypeTcpInfoV1            = 0x00000009,
}

///The <b>HTTP_RESPONSE_INFO_TYPE</b> enumeration defines the type of information contained in the HTTP_RESPONSE_INFO
///structure. This enumeration is used in the HTTP_RESPONSE_INFO structure.
alias HTTP_RESPONSE_INFO_TYPE = int;
enum : int
{
    ///The response information type is authentication. The <b>pInfo</b> member of the HTTP_RESPONSE_INFO structure
    ///points to a HTTP_MULTIPLE_KNOWN_HEADERS structure.
    HttpResponseInfoTypeMultipleKnownHeaders   = 0x00000000,
    ///Reserved for future use.
    HttpResponseInfoTypeAuthenticationProperty = 0x00000001,
    ///Pointer to an HTTP_QOS_SETTING_INFO structure that contains information about a QOS setting.
    HttpResponseInfoTypeQoSProperty            = 0x00000002,
    ///Pointer to an HTTP_CHANNEL_BIND_INFO structure that contains information on the channel binding token.
    HttpResponseInfoTypeChannelBind            = 0x00000003,
}

///The <b>HTTP_CACHE_POLICY_TYPE</b> enumeration type defines available cache policies. It is used to restrict the
///values of the <b>Policy</b> member of the HTTP_CACHE_POLICY structure, which in turn is used in the
///<i>pCachePolicy</i> parameter of the HttpAddFragmentToCache function to specify how a response fragment is cached.
alias HTTP_CACHE_POLICY_TYPE = int;
enum : int
{
    ///Do not cache this value at all.
    HttpCachePolicyNocache         = 0x00000000,
    ///Cache this value until the user provides a different one.
    HttpCachePolicyUserInvalidates = 0x00000001,
    ///Cache this value for a specified time and then remove it from the cache.
    HttpCachePolicyTimeToLive      = 0x00000002,
    ///Terminates the enumeration; not used to determine policy.
    HttpCachePolicyMaximum         = 0x00000003,
}

///The <b>HTTP_SERVICE_CONFIG_ID</b> enumeration type defines service configuration options.
alias HTTP_SERVICE_CONFIG_ID = int;
enum : int
{
    ///Specifies the IP Listen List used to register IP addresses on which to listen for SSL connections.
    HttpServiceConfigIPListenList           = 0x00000000,
    ///Specifies the SSL certificate store. <div class="alert"><b>Note</b> If SSL is enabled in the HTTP Server API, TLS
    ///1.0 may be used in place of SSL when the client application specifies TLS.</div> <div> </div>
    HttpServiceConfigSSLCertInfo            = 0x00000001,
    ///Specifies the URL reservation store.
    HttpServiceConfigUrlAclInfo             = 0x00000002,
    ///Configures the HTTP Server API wide connection timeouts. <div class="alert"><b>Note</b> Windows Vista and later
    ///versions of Windows</div> <div> </div>
    HttpServiceConfigTimeout                = 0x00000003,
    ///Used in the HttpQueryServiceConfiguration and HttpSetServiceConfiguration functions. <div
    ///class="alert"><b>Note</b> Windows Server 2008 R2 and Windows 7 and later versions of Windows.</div> <div> </div>
    HttpServiceConfigCache                  = 0x00000004,
    ///Specifies the SSL endpoint configuration with <i>Hostname:Port</i> as key. Used in the
    ///HttpDeleteServiceConfiguration, HttpQueryServiceConfiguration, HttpSetServiceConfiguration, and
    ///HttpUpdateServiceConfiguration functions <div class="alert"><b>Note</b> Windows 8 and later versions of
    ///Windows.</div> <div> </div>
    HttpServiceConfigSslSniCertInfo         = 0x00000005,
    ///Specifies that an operation should be performed for the SSL certificate record that specifies that Http.sys
    ///should consult the Centralized Certificate Store (CCS) store to find certificates if the port receives a
    ///Transport Layer Security (TLS) handshake. Used in the HttpDeleteServiceConfiguration,
    ///HttpQueryServiceConfiguration, HttpSetServiceConfiguration, and HttpUpdateServiceConfiguration functions <div
    ///class="alert"><b>Note</b> Windows 8 and later versions of Windows.</div> <div> </div>
    HttpServiceConfigSslCcsCertInfo         = 0x00000006,
    HttpServiceConfigSetting                = 0x00000007,
    HttpServiceConfigSslCertInfoEx          = 0x00000008,
    HttpServiceConfigSslSniCertInfoEx       = 0x00000009,
    HttpServiceConfigSslCcsCertInfoEx       = 0x0000000a,
    HttpServiceConfigSslScopedCcsCertInfo   = 0x0000000b,
    HttpServiceConfigSslScopedCcsCertInfoEx = 0x0000000c,
    ///Terminates the enumeration; is not used to define a service configuration option.
    HttpServiceConfigMax                    = 0x0000000d,
}

///The <b>HTTP_SERVICE_CONFIG_QUERY_TYPE</b> enumeration type defines various types of queries to make. It is used in
///the HTTP_SERVICE_CONFIG_SSL_QUERY, HTTP_SERVICE_CONFIG_SSL_CCS_QUERY, and HTTP_SERVICE_CONFIG_URLACL_QUERY
///structures.
alias HTTP_SERVICE_CONFIG_QUERY_TYPE = int;
enum : int
{
    ///The query returns a single record that matches the specified key value.
    HttpServiceConfigQueryExact = 0x00000000,
    ///The query iterates through the store and returns all records in sequence, using an index value that the calling
    ///process increments between query calls.
    HttpServiceConfigQueryNext  = 0x00000001,
    ///Terminates the enumeration; is not used to define a query type.
    HttpServiceConfigQueryMax   = 0x00000002,
}

alias HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE = int;
enum : int
{
    ExParamTypeHttp2Window         = 0x00000000,
    ExParamTypeHttp2SettingsLimits = 0x00000001,
    ExParamTypeHttpPerformance     = 0x00000002,
    ExParamTypeMax                 = 0x00000003,
}

///Used in the HttpSetServiceConfiguration and HttpQueryServiceConfiguration functions.
alias HTTP_SERVICE_CONFIG_CACHE_KEY = int;
enum : int
{
    ///The maximum cache size for the response.
    MaxCacheResponseSize = 0x00000000,
    ///The chunk size.
    CacheRangeChunkSize  = 0x00000001,
}

alias HTTP_REQUEST_PROPERTY = int;
enum : int
{
    HttpRequestPropertyIsb       = 0x00000000,
    HttpRequestPropertyTcpInfoV0 = 0x00000001,
    HttpRequestPropertyQuicStats = 0x00000002,
    HttpRequestPropertyTcpInfoV1 = 0x00000003,
    HttpRequestPropertySni       = 0x00000004,
}

///The **WINHTTP\_REQUEST\_TIME\_ENTRY** enumeration lists the available types of request timing information.
alias WINHTTP_REQUEST_TIME_ENTRY = int;
enum : int
{
    ///Start of proxy detection.
    WinHttpProxyDetectionStart                      = 0x00000000,
    ///End of proxy detection.
    WinHttpProxyDetectionEnd                        = 0x00000001,
    ///Start of connection acquisition.
    WinHttpConnectionAcquireStart                   = 0x00000002,
    ///End waiting for an available connection.
    WinHttpConnectionAcquireWaitEnd                 = 0x00000003,
    ///End of connection acquisition.
    WinHttpConnectionAcquireEnd                     = 0x00000004,
    ///Start of name resolution.
    WinHttpNameResolutionStart                      = 0x00000005,
    ///End of name resolution.
    WinHttpNameResolutionEnd                        = 0x00000006,
    ///Start of connection establishment.
    WinHttpConnectionEstablishmentStart             = 0x00000007,
    ///End of connection establishment.
    WinHttpConnectionEstablishmentEnd               = 0x00000008,
    ///Start of the first leg of the TLS handshake.
    WinHttpTlsHandshakeClientLeg1Start              = 0x00000009,
    ///End of the first leg of the TLS handshake.
    WinHttpTlsHandshakeClientLeg1End                = 0x0000000a,
    ///Start of the second leg of the TLS handshake.
    WinHttpTlsHandshakeClientLeg2Start              = 0x0000000b,
    ///End of the second leg of the TLS handshake.
    WinHttpTlsHandshakeClientLeg2End                = 0x0000000c,
    ///Start of the third leg of the TLS handshake.
    WinHttpTlsHandshakeClientLeg3Start              = 0x0000000d,
    ///End of the third leg of the TLS handshake.
    WinHttpTlsHandshakeClientLeg3End                = 0x0000000e,
    ///Start waiting for an available stream.
    WinHttpStreamWaitStart                          = 0x0000000f,
    ///End waiting for an available stream.
    WinHttpStreamWaitEnd                            = 0x00000010,
    ///Start sending a request.
    WinHttpSendRequestStart                         = 0x00000011,
    ///Start of request header compression.
    WinHttpSendRequestHeadersCompressionStart       = 0x00000012,
    ///End of request header compression.
    WinHttpSendRequestHeadersCompressionEnd         = 0x00000013,
    ///End sending request headers.
    WinHttpSendRequestHeadersEnd                    = 0x00000014,
    ///End sending a request.
    WinHttpSendRequestEnd                           = 0x00000015,
    ///Start receiving a response.
    WinHttpReceiveResponseStart                     = 0x00000016,
    ///Start of response header decompression.
    WinHttpReceiveResponseHeadersDecompressionStart = 0x00000017,
    ///End of response header decompression.
    WinHttpReceiveResponseHeadersDecompressionEnd   = 0x00000018,
    ///End receiving response headers.
    WinHttpReceiveResponseHeadersEnd                = 0x00000019,
    ///Delta between start and end times for response body decompression.
    WinHttpReceiveResponseBodyDecompressionDelta    = 0x0000001a,
    ///End receiving a response.
    WinHttpReceiveResponseEnd                       = 0x0000001b,
    ///Start establishing a proxy tunnel.
    WinHttpProxyTunnelStart                         = 0x0000001c,
    ///End establishing a proxy tunnel.
    WinHttpProxyTunnelEnd                           = 0x0000001d,
    ///Start of the first leg of the proxy TLS handshake.
    WinHttpProxyTlsHandshakeClientLeg1Start         = 0x0000001e,
    ///End of the first leg of the proxy TLS handshake.
    WinHttpProxyTlsHandshakeClientLeg1End           = 0x0000001f,
    ///Start of the second leg of the proxy TLS handshake.
    WinHttpProxyTlsHandshakeClientLeg2Start         = 0x00000020,
    ///End of the second leg of the proxy TLS handshake.
    WinHttpProxyTlsHandshakeClientLeg2End           = 0x00000021,
    ///Start of the third leg of the proxy TLS handshake.
    WinHttpProxyTlsHandshakeClientLeg3Start         = 0x00000022,
    ///End of the third leg of the proxy TLS handshake.
    WinHttpProxyTlsHandshakeClientLeg3End           = 0x00000023,
    ///Marker for the end of the list of available timings.
    WinHttpRequestTimeLast                          = 0x00000024,
    ///The maximum number of timings available.
    WinHttpRequestTimeMax                           = 0x00000040,
}

///The **WINHTTP\_REQUEST\_STAT\_ENTRY** enumeration lists the available types of request statistics.
alias WINHTTP_REQUEST_STAT_ENTRY = int;
enum : int
{
    ///The number of connection failures during connection establishment.
    WinHttpConnectFailureCount             = 0x00000000,
    ///The number of proxy connection failures during connection establishment.
    WinHttpProxyFailureCount               = 0x00000001,
    ///The size of the client data for the first leg of the TLS handshake.
    WinHttpTlsHandshakeClientLeg1Size      = 0x00000002,
    ///The size of the server data for the first leg of the TLS handshake.
    WinHttpTlsHandshakeServerLeg1Size      = 0x00000003,
    ///The size of the client data for the second leg of the TLS handshake.
    WinHttpTlsHandshakeClientLeg2Size      = 0x00000004,
    ///The size of the server data for the second leg of the TLS handshake.
    WinHttpTlsHandshakeServerLeg2Size      = 0x00000005,
    ///The size of the request headers.
    WinHttpRequestHeadersSize              = 0x00000006,
    ///The compressed size of the request headers.
    WinHttpRequestHeadersCompressedSize    = 0x00000007,
    ///The size of the response headers.
    WinHttpResponseHeadersSize             = 0x00000008,
    ///The compressed size of the response headers.
    WinHttpResponseHeadersCompressedSize   = 0x00000009,
    ///The size of the response body.
    WinHttpResponseBodySize                = 0x0000000a,
    ///The compressed size of the response body.
    WinHttpResponseBodyCompressedSize      = 0x0000000b,
    ///The size of the client data for the first leg of the proxy TLS handshake.
    WinHttpProxyTlsHandshakeClientLeg1Size = 0x0000000c,
    ///The size of the server data for the first leg of the proxy TLS handshake.
    WinHttpProxyTlsHandshakeServerLeg1Size = 0x0000000d,
    ///The size of the client data for the second leg of the proxy TLS handshake.
    WinHttpProxyTlsHandshakeClientLeg2Size = 0x0000000e,
    ///The size of the server data for the second leg of the proxy TLS handshake.
    WinHttpProxyTlsHandshakeServerLeg2Size = 0x0000000f,
    ///Marker for the end of the list of available statistics.
    WinHttpRequestStatLast                 = 0x00000010,
    ///The maximum number of statistics available.
    WinHttpRequestStatMax                  = 0x00000020,
}

///The <b>WINHTTP_WEB_SOCKET_OPERATION</b> enumeration includes the WebSocket operation type.
alias WINHTTP_WEB_SOCKET_OPERATION = int;
enum : int
{
    ///A WinHttpWebSocketSend operation.
    WINHTTP_WEB_SOCKET_SEND_OPERATION     = 0x00000000,
    ///A WinHttpWebSocketReceive operation.
    WINHTTP_WEB_SOCKET_RECEIVE_OPERATION  = 0x00000001,
    ///A WinHttpWebSocketClose operation.
    WINHTTP_WEB_SOCKET_CLOSE_OPERATION    = 0x00000002,
    ///A WinHttpWebSocketShutdown operation.
    WINHTTP_WEB_SOCKET_SHUTDOWN_OPERATION = 0x00000003,
}

///The <b>WINHTTP_WEB_SOCKET_BUFFER_TYPE</b> enumeration includes types of WebSocket buffers.
alias WINHTTP_WEB_SOCKET_BUFFER_TYPE = int;
enum : int
{
    ///Buffer contains either the entire binary message or the last part of it.
    WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE  = 0x00000000,
    ///Buffer contains only part of a binary message.
    WINHTTP_WEB_SOCKET_BINARY_FRAGMENT_BUFFER_TYPE = 0x00000001,
    ///Buffer contains either the entire UTF-8 message or the last part of it.
    WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE    = 0x00000002,
    ///Buffer contains only part of a UTF-8 message.
    WINHTTP_WEB_SOCKET_UTF8_FRAGMENT_BUFFER_TYPE   = 0x00000003,
    WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE           = 0x00000004,
}

///The <b>WINHTTP_WEB_SOCKET_CLOSE_STATUS</b> enumeration includes the status of a WebSocket close operation.
alias WINHTTP_WEB_SOCKET_CLOSE_STATUS = int;
enum : int
{
    ///The connection closed successfully.
    WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS                = 0x000003e8,
    ///The peer is going away and terminating the connection.
    WINHTTP_WEB_SOCKET_ENDPOINT_TERMINATED_CLOSE_STATUS    = 0x000003e9,
    ///A protocol error occurred.
    WINHTTP_WEB_SOCKET_PROTOCOL_ERROR_CLOSE_STATUS         = 0x000003ea,
    ///Invalid data received by the peer.
    WINHTTP_WEB_SOCKET_INVALID_DATA_TYPE_CLOSE_STATUS      = 0x000003eb,
    ///The close message was empty.
    WINHTTP_WEB_SOCKET_EMPTY_CLOSE_STATUS                  = 0x000003ed,
    ///The connection was aborted.
    WINHTTP_WEB_SOCKET_ABORTED_CLOSE_STATUS                = 0x000003ee,
    WINHTTP_WEB_SOCKET_INVALID_PAYLOAD_CLOSE_STATUS        = 0x000003ef,
    ///The message violates an endpoint's policy.
    WINHTTP_WEB_SOCKET_POLICY_VIOLATION_CLOSE_STATUS       = 0x000003f0,
    ///The message sent was too large to process.
    WINHTTP_WEB_SOCKET_MESSAGE_TOO_BIG_CLOSE_STATUS        = 0x000003f1,
    ///A client endpoint expected the server to negotiate one or more extensions, but the server didn't return them in
    ///the response message of the WebSocket handshake.
    WINHTTP_WEB_SOCKET_UNSUPPORTED_EXTENSIONS_CLOSE_STATUS = 0x000003f2,
    ///An unexpected condition prevented the server from fulfilling the request.
    WINHTTP_WEB_SOCKET_SERVER_ERROR_CLOSE_STATUS           = 0x000003f3,
    ///The TLS handshake could not be completed.
    WINHTTP_WEB_SOCKET_SECURE_HANDSHAKE_ERROR_CLOSE_STATUS = 0x000003f7,
}

// Callbacks

///The <b>WINHTTP_STATUS_CALLBACK</b> type represents an application-defined status callback function.
///Params:
///    hInternet = The handle for which the callback function is called.
///    dwContext = A pointer to a <b>DWORD</b> that specifies the application-defined context value associated with the handle in
///                the <i>hInternet</i> parameter. A context value can be assigned to a Session, Connect, or Request handle by
///                calling WinHttpSetOption with the WINHTTP_OPTION_CONTEXT_VALUE option. Alternatively, WinHttpSendRequest can be
///                used to associate a context value with a Request handle.
///    dwInternetStatus = Points to a <b>DWORD</b> that specifies the status code that indicates why the callback function is called. This
///                       can be one of the following values:
///    lpvStatusInformation = A pointer to a buffer that specifies information pertinent to this call to the callback function. The format of
///                           these data depends on the value of the <i>dwInternetStatus</i> argument. For more information, see
///                           <i>dwInternetStatus</i>. If the <i>dwInternetStatus</i> argument is WINHTTP_CALLBACK_STATUS_SECURE_FAILURE, then
///                           <i>lpvStatusInformation</i> points to a DWORD which is a bitwise-OR combination of one or more of the following
///                           values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                           id="WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED"></a><a
///                           id="winhttp_callback_status_flag_cert_rev_failed"></a><dl>
///                           <dt><b>WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED</b></dt> </dl> </td> <td width="60%"> Certification
///                           revocation checking has been enabled, but the revocation check failed to verify whether a certificate has been
///                           revoked. The server used to check for revocation might be unreachable. </td> </tr> <tr> <td width="40%"><a
///                           id="WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CERT"></a><a id="winhttp_callback_status_flag_invalid_cert"></a><dl>
///                           <dt><b>WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CERT</b></dt> </dl> </td> <td width="60%"> SSL certificate is
///                           invalid. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED"></a><a
///                           id="winhttp_callback_status_flag_cert_revoked"></a><dl> <dt><b>WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED</b></dt>
///                           </dl> </td> <td width="60%"> SSL certificate was revoked. </td> </tr> <tr> <td width="40%"><a
///                           id="WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA"></a><a id="winhttp_callback_status_flag_invalid_ca"></a><dl>
///                           <dt><b>WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA</b></dt> </dl> </td> <td width="60%"> The function is unfamiliar
///                           with the Certificate Authority that generated the server's certificate. </td> </tr> <tr> <td width="40%"><a
///                           id="WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID"></a><a
///                           id="winhttp_callback_status_flag_cert_cn_invalid"></a><dl>
///                           <dt><b>WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID</b></dt> </dl> </td> <td width="60%"> SSL certificate common
///                           name (host name field) is incorrect, for example, if you entered www.microsoft.com and the common name on the
///                           certificate says www.msn.com. </td> </tr> <tr> <td width="40%"><a
///                           id="WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID"></a><a
///                           id="winhttp_callback_status_flag_cert_date_invalid"></a><dl>
///                           <dt><b>WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID</b></dt> </dl> </td> <td width="60%"> SSL certificate date
///                           that was received from the server is bad. The certificate is expired. </td> </tr> <tr> <td width="40%"><a
///                           id="WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR"></a><a
///                           id="winhttp_callback_status_flag_security_channel_error"></a><dl>
///                           <dt><b>WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR</b></dt> </dl> </td> <td width="60%"> The application
///                           experienced an internal error loading the SSL libraries. </td> </tr> </table>
///    dwStatusInformationLength = <b>WINHTTP_CALLBACK_STATUS_REDIRECT</b> status callbacks provide a <i>dwStatusInformationLength</i> value that
///                                corresponds to the character count of the <b>LPWSTR</b> pointed to by <i>lpvStatusInformation</i>.
alias WINHTTP_STATUS_CALLBACK = void function(void* hInternet, size_t dwContext, uint dwInternetStatus, 
                                              void* lpvStatusInformation, uint dwStatusInformationLength);
alias LPWINHTTP_STATUS_CALLBACK = void function();

// Structs


///The <b>HTTP_PROPERTY_FLAGS</b> structure is used by the property configuration structures to enable or disable a
///property on a configuration object when setting property configurations. When the configuration structure is used to
///query property configurations, this structure specifies whether the property is present on the configuration object.
struct HTTP_PROPERTY_FLAGS
{
    uint _bitfield46;
}

///The <b>HTTP_STATE_INFO</b> structure is used to enable or disable a Server Session or URL Group. This structure must
///be used when setting or querying the HttpServerStateProperty on a URL Group or Server Session.
struct HTTP_STATE_INFO
{
    ///The HTTP_PROPERTY_FLAGS structure specifying whether the property is present.
    HTTP_PROPERTY_FLAGS Flags;
    ///A member of the HTTP_ENABLED_STATE enumeration specifying the whether the configuration object is enabled or
    ///disabled. This can be used to disable a URL Group or Server Session.
    HTTP_ENABLED_STATE  State;
}

///The <b>HTTP_QOS_SETTING_INFO</b> structurecontains information about a QOS setting.
struct HTTP_QOS_SETTING_INFO
{
    ///An HTTP_QOS_SETTING_TYPE enumeration value that specifies the type of the QOS setting.
    HTTP_QOS_SETTING_TYPE QosType;
    ///A pointer to a structure that contains the setting.
    void* QosSetting;
}

///The <b>HTTP_CONNECTION_LIMIT_INFO</b> structure is used to set or query the limit on the maximum number of
///outstanding connections for a URL Group. This structure must be used when setting or querying the
///HttpServerConnectionsProperty on a URL Group.
struct HTTP_CONNECTION_LIMIT_INFO
{
    ///The HTTP_PROPERTY_FLAGS structure specifying whether the property is present.
    HTTP_PROPERTY_FLAGS Flags;
    ///The number of connections allowed. Setting this value to HTTP_LIMIT_INFINITE allows an unlimited number of
    ///connections.
    uint                MaxConnections;
}

///The <b>HTTP_BANDWIDTH_LIMIT_INFO</b> structure is used to set or query the bandwidth throttling limit. This structure
///must be used when setting or querying the HttpServerBandwidthProperty on a URL Group or server session.
struct HTTP_BANDWIDTH_LIMIT_INFO
{
    ///The HTTP_PROPERTY_FLAGS structure specifying whether the property is present.
    HTTP_PROPERTY_FLAGS Flags;
    ///The maximum allowed bandwidth rate in bytesper second. Setting the value to HTTP_LIMIT_INFINITE allows unlimited
    ///bandwidth rate. The value cannot be smaller than HTTP_MIN_ALLOWED_BANDWIDTH_THROTTLING_RATE.
    uint                MaxBandwidth;
}

///The transfer rate of a response
struct HTTP_FLOWRATE_INFO
{
    ///An HTTP_PROPERTY_FLAGS structure specifying whether the property is present.
    HTTP_PROPERTY_FLAGS Flags;
    ///The maximum bandwidth represented in bytes/second. This is the maximum bandwidth for the response after the burst
    ///content, whose size is specified in <b>BurstSize</b>, has been sent.
    uint                MaxBandwidth;
    ///The peak bandwidth represented in bytes/second. This is the maximum bandwidth at which the burst is delivered.
    uint                MaxPeakBandwidth;
    ///The size of the content, in bytes, to be delivered at <b>MaxPeakBandwidth</b>. Once this content has been
    ///delivered, the response is throttled at <b>MaxBandwidth</b>. If the HTTP Server application sends responses at a
    ///rate slower than <b>MaxBandwidth</b>, the response is subject to burst again at <b>MaxPeakBandwidth</b> to
    ///maximize bandwidth utilization.
    uint                BurstSize;
}

///The <b>HTTP_SERVICE_CONFIG_TIMEOUT_SET</b> structure is used to set the HTTP Server API wide timeout value.
struct HTTP_SERVICE_CONFIG_TIMEOUT_SET
{
    ///A member of the HTTP_SERVICE_CONFIG_TIMEOUT_KEY enumeration identifying the timer that is set.
    HTTP_SERVICE_CONFIG_TIMEOUT_KEY KeyDesc;
    ///The value, in seconds, for the timer. The value must be greater than zero.
    ushort ParamDesc;
}

///The <b>HTTP_TIMEOUT_LIMIT_INFO</b> structure defines the application-specific connection timeout limits. This
///structure must be used when setting or querying the HttpServerTimeoutsProperty on a URL Group, server session, or
///request queue.
struct HTTP_TIMEOUT_LIMIT_INFO
{
    ///The HTTP_PROPERTY_FLAGS structure that specifies whether the property is present.
    HTTP_PROPERTY_FLAGS Flags;
    ///The time, in seconds, allowed for the request entity body to arrive. The HTTP Server API turns on this timer when
    ///the request has an entity body. The timer expiration is initially set to the configured value. When the HTTP
    ///Server API receives additional data indications on the request, it resets the timer to give the connection
    ///another interval.
    ushort              EntityBody;
    ///The time, in seconds, allowed for the HTTP Server API to drain the entity body on a Keep-Alive connection. On a
    ///Keep-Alive connection, after the application has sent a response for a request and before the request entity body
    ///has completely arrived, the HTTP Server API starts draining the remainder of the entity body to reach another
    ///potentially pipelined request from the client. If the time to drain the remaining entity body exceeds the allowed
    ///period the connection is timed out.
    ushort              DrainEntityBody;
    ///The time, in seconds, allowed for the request to remain in the request queue before the application picks it up.
    ushort              RequestQueue;
    ///The time, in seconds, allowed for an idle connection. This timeout is only enforced after the first request on
    ///the connection is routed to the application. For more information, see the Remarks section.
    ushort              IdleConnection;
    ///The time, in seconds, allowed for the HTTP Server API to parse the request header. This timeout is only enforced
    ///after the first request on the connection is routed to the application. For more information, see the Remarks
    ///section.
    ushort              HeaderWait;
    ///The minimum send rate, in bytes-per-second, for the response. The default response send rate is 150
    ///bytes-per-second. To disable this timer, set <b>MinSendRate</b> to <b>MAXULONG</b>.
    uint                MinSendRate;
}

struct HTTP_SERVICE_CONFIG_SETTING_SET
{
    HTTP_SERVICE_CONFIG_SETTING_KEY KeyDesc;
    uint ParamDesc;
}

///Controls whether IP-based URLs should listen on the specific IP address or on a wildcard.
struct HTTP_LISTEN_ENDPOINT_INFO
{
    ///The HTTP_PROPERTY_FLAGS structure that specifies if the property is present.
    HTTP_PROPERTY_FLAGS Flags;
    ///A Boolean value that specifies whether sharing is enabled.
    ubyte               EnableSharing;
}

///The <b>HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS</b> structure contains the information for digest authentication on a
///URL Group. This structure is contained in the HTTP_SERVER_AUTHENTICATION_INFO structure.
struct HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS
{
    ///The length, in bytes, of the <b>DomainName</b> member.
    ushort DomainNameLength;
    ///The domain name used for Digest authentication. If <b>NULL</b>, the client assumes the protection space consists
    ///of all the URIs under the responding server.
    PWSTR  DomainName;
    ///The length, in bytes, of the <b>Realm</b> member.
    ushort RealmLength;
    ///The realm used for Digest authentication. The realm allows the server to be partitioned into a set of protection
    ///spaces, each with its own set of authentication schemes from the authentication database.
    PWSTR  Realm;
}

///The <b>HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS</b> structure contains the information for Basic authentication on a
///URL Group. This structure is contained in the HTTP_SERVER_AUTHENTICATION_INFO structure.
struct HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS
{
    ///The length, in bytes, of the <b>Realm</b> member.
    ushort RealmLength;
    ///The realm used for Basic authentication. The realm allows the server to be partitioned into a set of protection
    ///spaces, each with its own set of authentication schemes from the authentication database.
    PWSTR  Realm;
}

///The <b>HTTP_SERVER_AUTHENTICATION_INFO</b> structure is used to enable server-side authentication on a URL group or
///server session. This structure is also used to query the existing authentication schemes enabled for a URL group or
///server session. This structure must be used when setting or querying the HttpServerAuthenticationProperty on a URL
///group, or server session.
struct HTTP_SERVER_AUTHENTICATION_INFO
{
    ///The HTTP_PROPERTY_FLAGS structure that specifies if the property is present.
    HTTP_PROPERTY_FLAGS Flags;
    ///The supported authentication schemes. This can be one or more of the following: <table> <tr> <th>Authentication
    ///Scheme</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HTTP_AUTH_ENABLE_BASIC"></a><a
    ///id="http_auth_enable_basic"></a><dl> <dt><b>HTTP_AUTH_ENABLE_BASIC</b></dt> </dl> </td> <td width="60%"> Basic
    ///authentication is enabled. </td> </tr> <tr> <td width="40%"><a id="HTTP_AUTH_ENABLE_DIGEST"></a><a
    ///id="http_auth_enable_digest"></a><dl> <dt><b>HTTP_AUTH_ENABLE_DIGEST</b></dt> </dl> </td> <td width="60%"> Digest
    ///authentication is enabled. </td> </tr> <tr> <td width="40%"><a id="HTTP_AUTH_ENABLE_NTLM"></a><a
    ///id="http_auth_enable_ntlm"></a><dl> <dt><b>HTTP_AUTH_ENABLE_NTLM</b></dt> </dl> </td> <td width="60%"> NTLM
    ///authentication is enabled. </td> </tr> <tr> <td width="40%"><a id="_HTTP_AUTH_ENABLE_NEGOTIATE"></a><a
    ///id="_http_auth_enable_negotiate"></a><dl> <dt><b> HTTP_AUTH_ENABLE_NEGOTIATE</b></dt> </dl> </td> <td
    ///width="60%"> Negotiate authentication is enabled. </td> </tr> <tr> <td width="40%"><a
    ///id="HTTP_AUTH_ENABLE_KERBEROS"></a><a id="http_auth_enable_kerberos"></a><dl>
    ///<dt><b>HTTP_AUTH_ENABLE_KERBEROS</b></dt> </dl> </td> <td width="60%"> Kerberos authentication is enabled. </td>
    ///</tr> <tr> <td width="40%"><a id="_HTTP_AUTH_ENABLE_ALL"></a><a id="_http_auth_enable_all"></a><dl> <dt><b>
    ///HTTP_AUTH_ENABLE_ALL</b></dt> </dl> </td> <td width="60%"> All types of authentication are enabled. </td> </tr>
    ///</table>
    uint                AuthSchemes;
    ///A Boolean value that indicates, if <b>True</b>, that the client application receives the server credentials for
    ///mutual authentication with the authenticated request. If <b>False</b>, the client application does not receive
    ///the credentials. Be aware that this option is set for all requests served by the associated request queue.
    ubyte               ReceiveMutualAuth;
    ///A Boolean value that indicates, if <b>True</b>, that the finalized client context is serialized and passed to the
    ///application with the request. If <b>False</b>, the application does not receive the context. This handle can be
    ///used to query context attributes.
    ubyte               ReceiveContextHandle;
    ///A Boolean value that indicates, if <b>True</b>, that the NTLM credentials are not cached. If <b>False</b>, the
    ///default behavior is preserved. By default, HTTP caches the client context for Keep Alive (KA) connections for the
    ///NTLM scheme if the request did not originate from a proxy.
    ubyte               DisableNTLMCredentialCaching;
    ///Optional authentication flags. Can be one or more of the following possible values: <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="HTTP_AUTH_EX_FLAG_ENABLE_KERBEROS_CREDENTIAL_CACHING"></a><a
    ///id="http_auth_ex_flag_enable_kerberos_credential_caching"></a><dl>
    ///<dt><b>HTTP_AUTH_EX_FLAG_ENABLE_KERBEROS_CREDENTIAL_CACHING</b></dt> </dl> </td> <td width="60%"> If set, the
    ///Kerberos authentication credentials are cached. Kerberos or Negotiate authentication must be enabled by
    ///<b>AuthSchemes</b>. </td> </tr> <tr> <td width="40%"><a id="HTTP_AUTH_EX_FLAG_CAPTURE_CREDENTIAL"></a><a
    ///id="http_auth_ex_flag_capture_credential"></a><dl> <dt><b>HTTP_AUTH_EX_FLAG_CAPTURE_CREDENTIAL</b></dt> </dl>
    ///</td> <td width="60%"> If set, the HTTP Server API captures the caller's credentials and uses them for Kerberos
    ///or Negotiate authentication. Kerberos or Negotiate authentication must be enabled by <b>AuthSchemes</b>. </td>
    ///</tr> </table>
    ubyte               ExFlags;
    ///The HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS structure that provides the domain and realm for the digest
    ///challenge.
    HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS DigestParams;
    ///The HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS structure that provides the realm for the basic challenge.
    HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS BasicParams;
}

///The <b>HTTP_SERVICE_BINDING_BASE</b> structure is a placeholder for the HTTP_SERVICE_BINDING_A structure and the
///HTTP_SERVICE_BINDING_W structure.
struct HTTP_SERVICE_BINDING_BASE
{
    ///Pointer to an HTTP_SERVICE_BINDING_TYPE value that indicates whether the data is in ASCII or Unicode.
    HTTP_SERVICE_BINDING_TYPE Type;
}

///The <b>HTTP_SERVICE_BINDING_A</b> structure provides Service Principle Name (SPN) in ASCII.
struct HTTP_SERVICE_BINDING_A
{
    ///An HTTP_SERVICE_BINDING_BASE value, the <b>Type</b> member of which must be set to
    ///<b>HttpServiceBindingTypeA</b>.
    HTTP_SERVICE_BINDING_BASE Base;
    ///A pointer to a buffer that represents the SPN.
    PSTR Buffer;
    uint BufferSize;
}

///The <b>HTTP_SERVICE_BINDING_W</b> structure provides Service Principle Name (SPN) in Unicode.
struct HTTP_SERVICE_BINDING_W
{
    ///An HTTP_SERVICE_BINDING_BASE value, the <b>Type</b> member of which must be set to
    ///<b>HttpServiceBindingTypeW</b>.
    HTTP_SERVICE_BINDING_BASE Base;
    ///A pointer to a buffer that represents the SPN.
    PWSTR Buffer;
    uint  BufferSize;
}

///The <b>HTTP_CHANNEL_BIND_INFO</b> structure is used to set or query channel bind authentication.
struct HTTP_CHANNEL_BIND_INFO
{
    ///An HTTP_AUTHENTICATION_HARDENING_LEVELS value indicating the hardening level levels to be set or queried per
    ///server session or URL group.
    HTTP_AUTHENTICATION_HARDENING_LEVELS Hardening;
    ///A bitwise OR combination of flags that determine the behavior of authentication. The following values are
    ///supported. <table> <tr> <td>Name</td> <td>Value</td> <td>Meaning</td> </tr> <tr> <td>HTTP_CHANNEL_BIND_PROXY</td>
    ///<td>0x1</td> <td>The exact Channel Bind Token (CBT) match is bypassed. CBT is checked not to be equal to
    ///‘unbound’. Service Principle Name (SPN) check is enabled. </td> </tr> <tr>
    ///<td>HTTP_CHANNEL_BIND_PROXY_COHOSTING</td> <td>Ox20</td> <td>This flag is valid only if HTTP_CHANNEL_BIND_PROXY
    ///is also set. With the flag set, the CBT check (comparing with ‘unbound’) is skipped. The flag should be set
    ///if both secure channel traffic passed through proxy and traffic originally sent through insecure channel have to
    ///be authenticated. </td> </tr> <tr> <td>HTTP_CHANNEL_BIND_NO_SERVICE_NAME_CHECK</td> <td>0x2</td> <td>SPN check
    ///always succeeds.</td> </tr> <tr> <td>HTTP_CHANNEL_BIND_DOTLESS_SERVICE</td> <td>0x4</td> <td>Enables dotless
    ///service names. Otherwise configuring CBT properties with dotless service names will fail. </td> </tr> <tr>
    ///<td>HTTP_CHANNEL_BIND_SECURE_CHANNEL_TOKEN</td> <td>0x8</td> <td>Server session, URL group, or response is
    ///configured to retrieve secure channel endpoint binding for each request and pass it to user the mode application.
    ///When set, a pointer to a buffer with the secure channel endpoint binding is stored in an
    ///HTTP_REQUEST_CHANNEL_BIND_STATUS structure. </td> </tr> <tr> <td>HTTP_CHANNEL_BIND_CLIENT_SERVICE</td>
    ///<td>0x10</td> <td>Server session, URL group, or response is configured to retrieve SPN for each request and pass
    ///it to the user mode application. The SPN is stored in the <b>ServiceName</b> field of the
    ///HTTP_REQUEST_CHANNEL_BIND_STATUS structure. The type is always <b>HttpServiceBindingTypeW</b> (Unicode). </td>
    ///</tr> </table>
    uint Flags;
    ///Pointer to a buffer holding an array of 1 or more service names. Each service name is represented by either an
    ///HTTP_SERVICE_BINDING_A structure or an HTTP_SERVICE_BINDING_W structure, dependent upon whether the name is ASCII
    ///or Unicode. Regardless of which structure type is used, the array is cast into a pointer to an
    ///HTTP_SERVICE_BINDING_BASE structure.
    HTTP_SERVICE_BINDING_BASE** ServiceNames;
    ///The number of names in <b>ServiceNames</b>.
    uint NumberOfServiceNames;
}

///The <b>HTTP_REQUEST_CHANNEL_BIND_STATUS</b> structure contains secure channel endpoint binding information.
struct HTTP_REQUEST_CHANNEL_BIND_STATUS
{
    ///A pointer to an HTTP_SERVICE_BINDING_W structure cast to a pointer to an HTTP_SERVICE_BINDING_BASE structure
    ///containing the service name from the client. This is populated if the request's Channel Binding Token (CBT) is
    ///not configured to retrieve service names.
    HTTP_SERVICE_BINDING_BASE* ServiceName;
    ///A pointer to a buffer that contains the secure channel endpoint binding.
    ubyte* ChannelToken;
    ///The length of the <b>ChannelToken</b> buffer in bytes.
    uint   ChannelTokenSize;
    uint   Flags;
}

struct HTTP_REQUEST_TOKEN_BINDING_INFO
{
    ubyte* TokenBinding;
    uint   TokenBindingSize;
    ubyte* EKM;
    uint   EKMSize;
    ubyte  KeyType;
}

///The <b>HTTP_LOGGING_INFO</b> structure is used to enable server side logging on a URL Group or on a server session.
///This structure must be used when setting or querying the HttpServerLoggingProperty on a URL Group or server session.
struct HTTP_LOGGING_INFO
{
    ///The HTTP_PROPERTY_FLAGS structure that specifies whether the property is present.
    HTTP_PROPERTY_FLAGS Flags;
    ///The optional logging flags change the default logging behavior. These can be one or more of the following
    ///HTTP_LOGGING_FLAG values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="HTTP_LOGGING_FLAG_LOCAL_TIME_ROLLOVER"></a><a id="http_logging_flag_local_time_rollover"></a><dl>
    ///<dt><b>HTTP_LOGGING_FLAG_LOCAL_TIME_ROLLOVER</b></dt> </dl> </td> <td width="60%"> Changes the log file rollover
    ///time to local time. By default log file rollovers are based on GMT. </td> </tr> <tr> <td width="40%"><a
    ///id="HTTP_LOGGING_FLAG_USE_UTF8_CONVERSION"></a><a id="http_logging_flag_use_utf8_conversion"></a><dl>
    ///<dt><b>HTTP_LOGGING_FLAG_USE_UTF8_CONVERSION</b></dt> </dl> </td> <td width="60%"> By default, the unicode
    ///logging fields are converted to multibytes using the systems local code page. If this flags is set, the UTF8
    ///conversion is used instead. </td> </tr> <tr> <td width="40%"><a id="HTTP_LOGGING_FLAG_LOG_ERRORS_ONLY"></a><a
    ///id="http_logging_flag_log_errors_only"></a><dl> <dt><b>HTTP_LOGGING_FLAG_LOG_ERRORS_ONLY</b></dt> </dl> </td> <td
    ///width="60%"> The log errors only flag enables logging errors only. By default, both error and success request are
    ///logged. The <b>HTTP_LOGGING_FLAG_LOG_ERRORS_ONLY</b> and <b>HTTP_LOGGING_FLAG_LOG_SUCCESS_ONLY</b> flags are used
    ///to perform selective logging. Only one of these flags can be set at a time; they are mutually exclusive. </td>
    ///</tr> <tr> <td width="40%"><a id="HTTP_LOGGING_FLAG_LOG_SUCCESS_ONLY"></a><a
    ///id="http_logging_flag_log_success_only"></a><dl> <dt><b>HTTP_LOGGING_FLAG_LOG_SUCCESS_ONLY</b></dt> </dl> </td>
    ///<td width="60%"> The log success only flag enables logging successful requests only. By default, both error and
    ///success request are logged. The <b>HTTP_LOGGING_FLAG_LOG_ERRORS_ONLY</b> and
    ///<b>HTTP_LOGGING_FLAG_LOG_SUCCESS_ONLY</b> flags are used to perform selective logging. Only one of these flags
    ///can be set at a time; they are mutually exclusive. </td> </tr> </table>
    uint                LoggingFlags;
    ///The optional software name string used in W3C type logging. This name is not used for other types of logging. If
    ///this parameter is <b>NULL</b>, the HTTP Server API logs a default string.
    const(PWSTR)        SoftwareName;
    ///The length, in bytes, of the software name. The length cannot be greater than <b>MAX_PATH</b>. If the
    ///<b>SoftwareName</b> member is <b>NULL</b>, this length must be zero.
    ushort              SoftwareNameLength;
    ///The length, in bytes, of the directory name. The length cannot be greater than 424 bytes.
    ushort              DirectoryNameLength;
    ///The logging directory under which the log files are created. The directory string must be a fully qualified path
    ///including the drive letter. Applications can use a UNC path to a remote machine to enable UNC logging.
    const(PWSTR)        DirectoryName;
    ///A member of the HTTP_LOGGING_TYPE enumeration specifying one of the following log file formats. <table> <tr>
    ///<th>Format</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HttpLoggingTypeW3C"></a><a
    ///id="httploggingtypew3c"></a><a id="HTTPLOGGINGTYPEW3C"></a><dl> <dt><b>HttpLoggingTypeW3C</b></dt> </dl> </td>
    ///<td width="60%"> The log format is W3C style extended logging. With this format, application can pick a
    ///combination of log fields to be logged. When W3C logging is set on a URL group, logging is similar to the IIS6
    ///site logging. When W3C logging is set on a server session, this logging functions as a centralized logging for
    ///all of the URL Groups. </td> </tr> <tr> <td width="40%"><a id="HttpLoggingTypeIIS"></a><a
    ///id="httploggingtypeiis"></a><a id="HTTPLOGGINGTYPEIIS"></a><dl> <dt><b>HttpLoggingTypeIIS</b></dt> </dl> </td>
    ///<td width="60%"> The log format is IIS6/5 style logging. This format has fixed field definitions; applications
    ///cannot select the fields that are logged. This format cannot be used for logging a server session. </td> </tr>
    ///<tr> <td width="40%"><a id="HttpLoggingTypeNCSA"></a><a id="httploggingtypencsa"></a><a
    ///id="HTTPLOGGINGTYPENCSA"></a><dl> <dt><b>HttpLoggingTypeNCSA</b></dt> </dl> </td> <td width="60%"> The log format
    ///is NCSA style logging. This format has fixed field definitions; applications cannot select the fields that are
    ///logged. This format cannot be used for logging a server session. </td> </tr> <tr> <td width="40%"><a
    ///id="HttpLoggingTypeRaw"></a><a id="httploggingtyperaw"></a><a id="HTTPLOGGINGTYPERAW"></a><dl>
    ///<dt><b>HttpLoggingTypeRaw</b></dt> </dl> </td> <td width="60%"> The log format is centralized binary logging.
    ///This format has fixed field definitions; applications cannot select the fields that are logged. This format
    ///cannot be used for logging a URL Group. </td> </tr> </table>
    HTTP_LOGGING_TYPE   Format;
    ///The fields that are logged when the format is set to W3C. These can be one or more of the HTTP_LOG_FIELD_
    ///Constants values. When the logging format is W3C is , applications must specify the log fields otherwise no
    ///fields are logged.
    uint                Fields;
    ///Reserved. Set to 0 (zero) or <b>NULL</b>.
    void*               pExtFields;
    ///Reserved. Set to 0 (zero) or <b>NULL</b>.
    ushort              NumOfExtFields;
    ///Reserved. Set to 0 (zero) or <b>NULL</b>.
    ushort              MaxRecordSize;
    ///One of the following members of the HTTP_LOGGING_ROLLOVER_TYPE enumeration specifying the criteria for log file
    ///rollover. <table> <tr> <th>Rollover Type</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="HttpLoggingRolloverSize"></a><a id="httploggingrolloversize"></a><a id="HTTPLOGGINGROLLOVERSIZE"></a><dl>
    ///<dt><b>HttpLoggingRolloverSize</b></dt> </dl> </td> <td width="60%"> The log files are rolled over when they
    ///reach or exceed a specified size. </td> </tr> <tr> <td width="40%"><a id="HttpLoggingRolloverDaily"></a><a
    ///id="httploggingrolloverdaily"></a><a id="HTTPLOGGINGROLLOVERDAILY"></a><dl>
    ///<dt><b>HttpLoggingRolloverDaily</b></dt> </dl> </td> <td width="60%"> The log files are rolled over every day.
    ///</td> </tr> <tr> <td width="40%"><a id="HttpLoggingRolloverWeekly"></a><a id="httploggingrolloverweekly"></a><a
    ///id="HTTPLOGGINGROLLOVERWEEKLY"></a><dl> <dt><b>HttpLoggingRolloverWeekly</b></dt> </dl> </td> <td width="60%">
    ///The log files are rolled over every week. </td> </tr> <tr> <td width="40%"><a
    ///id="HttpLoggingRolloverMonthly"></a><a id="httploggingrollovermonthly"></a><a
    ///id="HTTPLOGGINGROLLOVERMONTHLY"></a><dl> <dt><b>HttpLoggingRolloverMonthly</b></dt> </dl> </td> <td width="60%">
    ///The log files are rolled over every month. </td> </tr> <tr> <td width="40%"><a
    ///id="HttpLoggingRolloverHourly"></a><a id="httploggingrolloverhourly"></a><a
    ///id="HTTPLOGGINGROLLOVERHOURLY"></a><dl> <dt><b>HttpLoggingRolloverHourly</b></dt> </dl> </td> <td width="60%">
    ///The log files are rolled over every hour. </td> </tr> </table>
    HTTP_LOGGING_ROLLOVER_TYPE RolloverType;
    ///The maximum size, in bytes, after which the log files is rolled over. A value of <b>HTTP_LIMIT_INFINITE</b>
    ///indicates an unlimited size. The minimum value cannot be smaller than
    ///<b>HTTP_MIN_ALLOWED_LOG_FILE_ROLLOVER_SIZE</b> (1024 * 1024). This field is used only for
    ///<b>HttpLoggingRolloverSize</b> rollover type and should be set to zero for all other types. When rollover type is
    ///<b>HttpLoggingRolloverSize</b>, applications must specify the maximum size for the log file.
    uint                RolloverSize;
    ///The security descriptor that is applied to the log files directory and all sub-directories. If this member is
    ///<b>NULL</b>, either the system default ACL is used or the ACL is inherited from the parent directory.
    void*               pSecurityDescriptor;
}

///The <b>HTTP_BINDING_INFO</b> structure is used to associate a URL Group with a request queue. This structure must be
///used when setting or querying the HttpServerBindingProperty on a URL Group.
struct HTTP_BINDING_INFO
{
    ///The HTTP_PROPERTY_FLAGS structure specifying whether the property is present.
    HTTP_PROPERTY_FLAGS Flags;
    ///The request queue that is associated with the URL group. The structure can be used to remove an existing binding
    ///by setting this parameter to <b>NULL</b>.
    HANDLE              RequestQueueHandle;
}

struct HTTP_PROTECTION_LEVEL_INFO
{
    HTTP_PROPERTY_FLAGS Flags;
    HTTP_PROTECTION_LEVEL_TYPE Level;
}

///The <b>HTTP_BYTE_RANGE</b> structure is used to specify a byte range within a cached response fragment, file, or
///other data block.
struct HTTP_BYTE_RANGE
{
    ///Starting offset of the byte range.
    ULARGE_INTEGER StartingOffset;
    ///Size, in bytes, of the range. If this member is HTTP_BYTE_RANGE_TO_EOF, the range extends from the starting
    ///offset to the end of the file or data block.
    ULARGE_INTEGER Length;
}

///The <b>HTTP_VERSION</b> structure defines a version of the HTTP protocol that a request requires or a response
///provides. This is not to be confused with the version of the HTTP Server API used, which is stored in an
///HTTPAPI_VERSION structure.
struct HTTP_VERSION
{
    ///Major version of the HTTP protocol.
    ushort MajorVersion;
    ///Minor version of the HTTP protocol.
    ushort MinorVersion;
}

///The <b>HTTP_KNOWN_HEADER</b> structure contains the header values for a known header from an HTTP request or HTTP
///response.
struct HTTP_KNOWN_HEADER
{
    ///Size, in bytes, of the 8-bit string pointed to by the <b>pRawValue</b> member, not counting a terminating null
    ///character, if present. If <b>RawValueLength</b> is zero, then the value of the <b>pRawValue</b> element is
    ///meaningless.
    ushort      RawValueLength;
    ///Pointer to the text of this HTTP header. Use <b>RawValueLength</b> to determine where this text ends rather than
    ///relying on the string to have a terminating null. The format of the header text is specified in RFC 2616.
    const(PSTR) pRawValue;
}

///The <b>HTTP_UNKNOWN_HEADER</b> structure contains the name and value for a header in an HTTP request or response
///whose name does not appear in the enumeration.
struct HTTP_UNKNOWN_HEADER
{
    ///The size, in bytes, of the data pointed to by the <b>pName</b> member not counting a terminating null.
    ushort      NameLength;
    ///The size, in bytes, of the data pointed to by the <b>pRawValue</b> member, in bytes.
    ushort      RawValueLength;
    ///A pointer to a string of octets that specifies the header name. Use <b>NameLength</b> to determine the end of the
    ///string, rather than relying on a terminating <b>null</b>.
    const(PSTR) pName;
    ///A pointer to a string of octets that specifies the values for this header. Use <b>RawValueLength</b> to determine
    ///the end of the string, rather than relying on a terminating <b>null</b>.
    const(PSTR) pRawValue;
}

///The <b>HTTP_LOG_DATA</b> structure contains a value that specifies the type of the log data.
struct HTTP_LOG_DATA
{
    ///An HTTP_LOG_DATA_TYPE enumeration value that specifies the type.
    HTTP_LOG_DATA_TYPE Type;
}

///The <b>HTTP_LOG_FIELDS_DATA</b> structure is used to pass the fields that are logged for an HTTP response when WC3
///logging is enabled.
struct HTTP_LOG_FIELDS_DATA
{
    ///Initialize this member to the <b>HttpLogDataTypeFields</b> value of the HTTP_LOG_DATA_TYPE enumeration.
    HTTP_LOG_DATA Base;
    ///The size, in bytes, of the user name member.
    ushort        UserNameLength;
    ///The size, in bytes, of the URI stem member.
    ushort        UriStemLength;
    ///The size, in bytes, of the client IP address member.
    ushort        ClientIpLength;
    ///The size, in bytes, of the server name member.
    ushort        ServerNameLength;
    ushort        ServiceNameLength;
    ///The size, in bytes, of the server IP address member.
    ushort        ServerIpLength;
    ///The size, in bytes, of the HTTP method member.
    ushort        MethodLength;
    ///The size, in bytes, of the URI query member.
    ushort        UriQueryLength;
    ///The size, in bytes, of the host name member.
    ushort        HostLength;
    ///The size, in bytes, of the user agent member.
    ushort        UserAgentLength;
    ///The size, in bytes, of the cookie member.
    ushort        CookieLength;
    ///The size, in bytes, of the referrer member.
    ushort        ReferrerLength;
    ///The name of the user.
    PWSTR         UserName;
    ///The URI stem.
    PWSTR         UriStem;
    ///The IP address of the client.
    PSTR          ClientIp;
    ///The name of the server.
    PSTR          ServerName;
    ///The name of the service.
    PSTR          ServiceName;
    ///The IP address of the server.
    PSTR          ServerIp;
    ///The HTTP method.
    PSTR          Method;
    ///The URI query.
    PSTR          UriQuery;
    ///The host information from the request.
    PSTR          Host;
    ///The user agent name.
    PSTR          UserAgent;
    ///The cookie provided by the application.
    PSTR          Cookie;
    ///The referrer.
    PSTR          Referrer;
    ///The port for the server.
    ushort        ServerPort;
    ///The protocol status.
    ushort        ProtocolStatus;
    ///The win32 status.
    uint          Win32Status;
    ///The method number.
    HTTP_VERB     MethodNum;
    ///The sub status.
    ushort        SubStatus;
}

///The <b>HTTP_DATA_CHUNK</b> structure represents an individual block of data either in memory, in a file, or in the
///HTTP Server API response-fragment cache.
struct HTTP_DATA_CHUNK
{
    ///Type of data store. This member can be one of the values from the <b>HTTP_DATA_CHUNK_TYPE</b> enumeration.
    HTTP_DATA_CHUNK_TYPE DataChunkType;
union
    {
struct FromMemory
        {
            void* pBuffer;
            uint  BufferLength;
        }
struct FromFileHandle
        {
            HTTP_BYTE_RANGE ByteRange;
            HANDLE          FileHandle;
        }
struct FromFragmentCache
        {
            ushort       FragmentNameLength;
            const(PWSTR) pFragmentName;
        }
struct FromFragmentCacheEx
        {
            HTTP_BYTE_RANGE ByteRange;
            const(PWSTR)    pFragmentName;
        }
    }
}

///The <b>HTTP_REQUEST_HEADERS</b> structure contains headers sent with an HTTP request.
struct HTTP_REQUEST_HEADERS
{
    ///A number of unknown headers sent with the HTTP request. This number is the size of the array pointed to by the
    ///<b>pUnknownHeaders</b> member.
    ushort               UnknownHeaderCount;
    ///A pointer to an array of HTTP_UNKNOWN_HEADER structures. This array contains one structure for each of the
    ///unknown headers sent in the HTTP request.
    HTTP_UNKNOWN_HEADER* pUnknownHeaders;
    ///This member is reserved and must be zero.
    ushort               TrailerCount;
    ///This member is reserved and must be <b>NULL</b>.
    HTTP_UNKNOWN_HEADER* pTrailers;
    ///Fixed-size array of HTTP_KNOWN_HEADER structures. The HTTP_HEADER_ID enumeration provides a mapping from header
    ///types to array indexes. If a known header of a given type is included in the HTTP request, the array element at
    ///the index that corresponds to that type specifies the header value. Those elements of the array for which no
    ///corresponding headers are present contain a zero-valued <b>RawValueLength</b> member. Use <b>RawValueLength</b>
    ///to determine the end of the header string pointed to by <b>pRawValue</b>, rather than relying on the string to
    ///have a terminating null.
    HTTP_KNOWN_HEADER[41] KnownHeaders;
}

///The <b>HTTP_RESPONSE_HEADERS</b> structure contains the headers sent with an HTTP response.
struct HTTP_RESPONSE_HEADERS
{
    ///A number of unknown headers sent with the HTTP response and contained in the array pointed to by the
    ///<b>pUnknownHeaders</b> member. This number cannot exceed 9999.
    ushort               UnknownHeaderCount;
    ///A pointer to an array of HTTP_UNKNOWN_HEADER structures that contains one structure for each of the unknown
    ///headers sent in the HTTP response.
    HTTP_UNKNOWN_HEADER* pUnknownHeaders;
    ///This member is reserved and must be zero.
    ushort               TrailerCount;
    ///This member is reserved and must be <b>NULL</b>.
    HTTP_UNKNOWN_HEADER* pTrailers;
    ///Fixed-size array of HTTP_KNOWN_HEADER structures. The HTTP_HEADER_ID enumeration provides a mapping from header
    ///types to array indexes. If a known header of a given type is included in the HTTP response, the array element at
    ///the index that corresponds to that type specifies the header value. Those elements of the array for which no
    ///corresponding headers are present contain a zero-valued <b>RawValueLength</b> member. Use <b>RawValueLength</b>
    ///to determine the end of the header string pointed to by <b>pRawValue</b>, rather than relying on the string to
    ///have a terminating null.
    HTTP_KNOWN_HEADER[30] KnownHeaders;
}

///Describes additional property information when delegating a request.
struct HTTP_DELEGATE_REQUEST_PROPERTY_INFO
{
    ///Type: **[HTTP_DELEGATE_REQUEST_PROPERTY_ID](./ne-http-http_delegate_request_property_id.md)** The type of
    ///property info pointed to by this struct.
    HTTP_DELEGATE_REQUEST_PROPERTY_ID ProperyId;
    ///Type: **[ULONG](/windows/win32/winprog/windows-data-types)** The length in bytes of the value of the
    ///*PropertyInfo* parameter.
    uint  PropertyInfoLength;
    ///Type: **[PVOID](/windows/win32/winprog/windows-data-types)** A pointer to the property information.
    void* PropertyInfo;
}

///The <b>HTTP_TRANSPORT_ADDRESS</b> structure specifies the addresses (local and remote) used for a particular HTTP
///connection.
struct HTTP_TRANSPORT_ADDRESS
{
    ///A pointer to the remote IP address associated with this connection. For more information about how to access this
    ///address, see the Remarks section.
    SOCKADDR* pRemoteAddress;
    ///A pointer to the local IP address associated with this connection. For more information about how to access this
    ///address, see the Remarks section.
    SOCKADDR* pLocalAddress;
}

///The <b>HTTP_COOKED_URL</b> structure contains a validated, canonical, UTF-16 Unicode-encoded URL request string
///together with pointers into it and element lengths. This is the string that the HTTP Server API matches against
///registered UrlPrefix strings in order to route the request appropriately.
struct HTTP_COOKED_URL
{
    ///Size, in bytes, of the data pointed to by the <b>pFullUrl</b> member, not including a terminating null character.
    ushort       FullUrlLength;
    ///Size, in bytes, of the data pointed to by the <b>pHost</b> member.
    ushort       HostLength;
    ///Size, in bytes, of the data pointed to by the <b>pAbsPath</b> member.
    ushort       AbsPathLength;
    ///Size, in bytes, of the data pointed to by the <b>pQueryString</b> member.
    ushort       QueryStringLength;
    ///Pointer to the scheme element at the beginning of the URL (must be either "http://..." or "https://...").
    const(PWSTR) pFullUrl;
    ///Pointer to the first character in the host element, immediately following the double slashes at the end of the
    ///scheme element.
    const(PWSTR) pHost;
    ///Pointer to the third forward slash ("/") in the string. In a UrlPrefix string, this is the slash immediately
    ///preceding the relativeUri element.
    const(PWSTR) pAbsPath;
    ///Pointer to the first question mark (?) in the string, or <b>NULL</b> if there is none.
    const(PWSTR) pQueryString;
}

///The <b>HTTP_SSL_CLIENT_CERT_INFO</b> structure contains data about a Secure Sockets Layer (SSL) client certificate
///that can be used to determine whether the certificate is valid.
struct HTTP_SSL_CLIENT_CERT_INFO
{
    ///Flags that indicate whether the certificate is valid. The possible values for this member are a SSPI Status Code
    ///returned from SSPI or one of the following flags from the <b>dwError</b> member of the CERT_CHAIN_POLICY_STATUS
    ///structure: <a id="CERT_E_EXPIRED"></a> <a id="cert_e_expired"></a>
    uint   CertFlags;
    ///The size, in bytes, of the certificate.
    uint   CertEncodedSize;
    ///A pointer to the actual certificate.
    ubyte* pCertEncoded;
    ///A handle to an access token. If the HTTP_SERVICE_CONFIG_SSL_FLAG_USE_DS_MAPPER flag is set using the
    ///HttpSetServiceConfiguration function, and the client certificate was successfully mapped to an operating-system
    ///user account, then this member contains the handle to a valid access token. When the
    ///<b>HTTP_SSL_CLIENT_CERT_INFO</b> structure is no longer required, release this token explicitly by closing the
    ///handle.
    HANDLE Token;
    ///Reserved.
    ubyte  CertDeniedByMapper;
}

///The <b>HTTP_SSL_INFO</b> structure contains data for a connection that uses Secure Sockets Layer (SSL), obtained
///through the SSL handshake.
struct HTTP_SSL_INFO
{
    ///The size, in bytes, of the public key used to sign the server certificate.
    ushort      ServerCertKeySize;
    ///The size, in bytes, of the cipher key used to encrypt the current session.
    ushort      ConnectionKeySize;
    ///The size, in bytes, of the string pointed to by the <b>pServerCertIssuer</b> member not including the terminating
    ///null character.
    uint        ServerCertIssuerSize;
    ///The size, in bytes, of the string pointed to by the <b>pServerCertSubject</b> member not including the
    ///terminating null character.
    uint        ServerCertSubjectSize;
    ///A pointer to a null-terminated string of octets that specifies the name of the entity that issued the
    ///certificate.
    const(PSTR) pServerCertIssuer;
    ///A pointer to a null-terminated string of octets that specifies the name of the entity to which the certificate
    ///belongs.
    const(PSTR) pServerCertSubject;
    ///A pointer to an HTTP_SSL_CLIENT_CERT_INFO structure that specifies the client certificate.
    HTTP_SSL_CLIENT_CERT_INFO* pClientCertInfo;
    ///If non-zero, indicates that the client certificate is already present locally.
    uint        SslClientCertNegotiated;
}

struct HTTP_SSL_PROTOCOL_INFO
{
    uint Protocol;
    uint CipherType;
    uint CipherStrength;
    uint HashType;
    uint HashStrength;
    uint KeyExchangeType;
    uint KeyExchangeStrength;
}

struct HTTP_REQUEST_SIZING_INFO
{
    ulong    Flags;
    uint     RequestIndex;
    uint     RequestSizingCount;
    ulong[5] RequestSizing;
}

struct HTTP_REQUEST_TIMING_INFO
{
    uint      RequestTimingCount;
    ulong[30] RequestTiming;
}

///The <b>HTTP_REQUEST_INFO</b> structure extends the HTTP_REQUEST structure with additional information about the
///request.
struct HTTP_REQUEST_INFO
{
    ///A member of the HTTP_REQUEST_INFO_TYPE enumeration specifying the type of information contained in this
    ///structure.
    HTTP_REQUEST_INFO_TYPE InfoType;
    ///The length, in bytes, of the <b>pInfo</b> member.
    uint  InfoLength;
    ///A pointer to the HTTP_REQUEST_AUTH_INFO structure when the <b>InfoType</b> member is
    ///<b>HttpRequestInfoTypeAuth</b>; otherwise <b>NULL</b>.
    void* pInfo;
}

///The <b>HTTP_REQUEST_AUTH_INFO</b> structure contains the authentication status of the request with a handle to the
///client token that the receiving process can use to impersonate the authenticated client. This structure is contained
///in the HTTP_REQUEST_INFO structure.
struct HTTP_REQUEST_AUTH_INFO
{
    ///A member of the HTTP_AUTH_STATUS enumeration that indicates the final authentication status of the request. If
    ///the authentication status is not <b>HttpAuthStatusSuccess</b>, applications should disregard members of this
    ///structure except <b>AuthStatus</b>, <b>SecStatus</b>, and <b>AuthType</b>.
    HTTP_AUTH_STATUS AuthStatus;
    ///A SECURITY_STATUS value that indicates the security failure status when the <b>AuthStatus</b> member is
    ///<b>HttpAuthStatusFailure</b>.
    int              SecStatus;
    ///The authentication flags that indicate the following authentication attributes: <table> <tr> <th>Attribute</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="HTTP_REQUEST_AUTH_FLAG_TOKEN_FOR_CACHED_CRED"></a><a
    ///id="http_request_auth_flag_token_for_cached_cred"></a><dl>
    ///<dt><b>HTTP_REQUEST_AUTH_FLAG_TOKEN_FOR_CACHED_CRED</b></dt> </dl> </td> <td width="60%"> The provided token is
    ///for NTLM and is based on a cached credential of a Keep Alive (KA) connection. </td> </tr> </table>
    uint             Flags;
    ///A member of the HTTP_REQUEST_AUTH_TYPE enumeration that indicates the authentication scheme attempted or
    ///established for the request.
    HTTP_REQUEST_AUTH_TYPE AuthType;
    ///A handle to the client token that the receiving process can use to impersonate the authenticated client. The
    ///handle to the token should be closed by calling CloseHandle when it is no longer required. This token is valid
    ///only for the lifetime of the request. Applications can regenerate the initial 401 challenge to reauthenticate
    ///when the token expires.
    HANDLE           AccessToken;
    ///The client context attributes for the access token.
    uint             ContextAttributes;
    ///The length, in bytes, of the <b>PackedContext</b>.
    uint             PackedContextLength;
    ///The type of context in the <b>PackedContext</b> member.
    uint             PackedContextType;
    ///The security context for the authentication type. Applications can query the attributes of the packed context by
    ///calling the SSPI QueryContextAttributes API. However, applications must acquire a credential handle for the
    ///security package for the indicated AuthType. Application should call the SSPI FreeContextBuffer API to free the
    ///serialized context when it is no longer required.
    void*            PackedContext;
    ///The length, in bytes, of the <b>pMutualAuthData</b> member.
    uint             MutualAuthDataLength;
    ///The Base64 encoded mutual authentication data used in the WWW-Authenticate header.
    PSTR             pMutualAuthData;
    ushort           PackageNameLength;
    PWSTR            pPackageName;
}

///Uses the HTTP_REQUEST structure to return data associated with a specific request. Do not use <b>HTTP_REQUEST_V1</b>
///directly in your code; using HTTP_REQUEST instead ensures that the proper version, based on the operating system the
///code is compiled under, is used.
struct HTTP_REQUEST_V1
{
    ///A combination of zero or more of the following flag values may be combined, with OR, as appropriate. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS"></a><a id="http_request_flag_more_entity_body_exists"></a><dl>
    ///<dt><b>HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS</b></dt> </dl> </td> <td width="60%"> There is more entity body
    ///to be read for this request. This applies only to incoming requests that span multiple reads. If this value is
    ///not set, either the whole entity body was copied into the buffer specified by <b>pEntityChunks</b> or the request
    ///did not include an entity body. </td> </tr> <tr> <td width="40%"><a id="HTTP_REQUEST_FLAG_IP_ROUTED"></a><a
    ///id="http_request_ip_routed"></a><dl> <dt><b>HTTP_REQUEST_FLAG_IP_ROUTED</b></dt> </dl> </td> <td width="60%"> The
    ///request was routed based on host and IP binding. The application should reflect the local IP while flushing
    ///kernel cache entries for this request. <b>Windows Server 2003 with SP1 and Windows XP with SP2: </b>This flag is
    ///not supported. </td> </tr> <tr> <td width="40%"><a id="HTTP_REQUEST_FLAG_HTTP2"></a><a
    ///id="http_request_flag_http2"></a><dl> <dt><b>HTTP_REQUEST_FLAG_HTTP2</b></dt> </dl> </td> <td width="60%">
    ///Indicates the request was received over HTTP/2. </td> </tr> </table>
    uint                 Flags;
    ///An identifier for the connection on which the request was received. Use this value when calling
    ///HttpWaitForDisconnect or HttpReceiveClientCertificate.
    ulong                ConnectionId;
    ///A value used to identify the request when calling HttpReceiveRequestEntityBody, HttpSendHttpResponse, and/or
    ///HttpSendResponseEntityBody.
    ulong                RequestId;
    ///The context that is associated with the URL in the <i>pRawUrl</i> parameter. <b>Windows Server 2003 with SP1 and
    ///Windows XP with SP2: </b>
    ulong                UrlContext;
    ///An HTTP_VERSION structure that contains the version of HTTP specified by this request.
    HTTP_VERSION         Version;
    ///An HTTP verb associated with this request. This member can be one of the values from the HTTP_VERB enumeration.
    HTTP_VERB            Verb;
    ///If the <b>Verb</b> member contains a value equal to <b>HttpVerbUnknown</b>, the <b>UnknownVerbLength</b> member
    ///contains the size, in bytes, of the string pointed to by the <b>pUnknownVerb</b> member, not including the
    ///terminating null character. If <b>Verb</b> is not equal to <b>HttpVerbUnknown</b>, <b>UnknownVerbLength</b> is
    ///equal to zero.
    ushort               UnknownVerbLength;
    ///The size, in bytes, of the unprocessed URL string pointed to by the <b>pRawUrl</b> member, not including the
    ///terminating null character.
    ushort               RawUrlLength;
    ///If the <b>Verb</b> member is equal to <b>HttpVerbUnknown</b>, <b>pUnknownVerb</b>, points to a null-terminated
    ///string of octets that contains the HTTP verb for this request; otherwise, the application ignores this parameter.
    const(PSTR)          pUnknownVerb;
    ///A pointer to a string of octets that contains the original, unprocessed URL targeted by this request. Use this
    ///unprocessed URL only for tracking or statistical purposes; the <b>CookedUrl</b> member contains the canonical
    ///form of the URL for general use.
    const(PSTR)          pRawUrl;
    ///An HTTP_COOKED_URL structure that contains a parsed canonical wide-character version of the URL targeted by this
    ///request. This is the version of the URL HTTP Listeners should act upon, rather than the raw URL.
    HTTP_COOKED_URL      CookedUrl;
    ///An HTTP_TRANSPORT_ADDRESS structure that contains the transport addresses for the connection for this request.
    HTTP_TRANSPORT_ADDRESS Address;
    ///An HTTP_REQUEST_HEADERS structure that contains the headers specified in this request.
    HTTP_REQUEST_HEADERS Headers;
    ///The total number of bytes received from the network comprising this request.
    ulong                BytesReceived;
    ///The number of elements in the <b>pEntityChunks</b> array. If no entity body was copied, this value is zero.
    ushort               EntityChunkCount;
    ///A pointer to an array of HTTP_DATA_CHUNK structures that contains the data blocks making up the entity body.
    ///HttpReceiveHttpRequest does not copy the entity body unless called with the HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY
    ///flag set.
    HTTP_DATA_CHUNK*     pEntityChunks;
    ///Raw connection ID for an Secure Sockets Layer (SSL) request.
    ulong                RawConnectionId;
    ///A pointer to an HTTP_SSL_INFO structure that contains Secure Sockets Layer (SSL) information about the connection
    ///on which the request was received.
    HTTP_SSL_INFO*       pSslInfo;
}

///The <b>HTTP_REQUEST_V2</b> structure extends the HTTP_REQUEST_V1 request structure with more information about the
///request. Do not use <b>HTTP_REQUEST_V2</b> directly in your code; use HTTP_REQUEST instead to ensure that the proper
///version, based on the operating system the code is compiled under, is used.
struct HTTP_REQUEST_V2
{
    HTTP_REQUEST_V1    __AnonymousBase_http_L1816_C35;
    ///The number of HTTP_REQUEST_INFO structures in the array pointed to by <b>pRequestInfo</b>.
    ushort             RequestInfoCount;
    ///A pointer to an array of HTTP_REQUEST_INFO structures that contains additional information about the request.
    HTTP_REQUEST_INFO* pRequestInfo;
}

///The <b>HTTP_RESPONSE_V1</b> structure contains data associated with an HTTP response. Do not use
///<b>HTTP_RESPONSE_V1</b> directly in your code; use HTTP_RESPONSE instead to ensure that the proper version, based on
///the operating system the code is compiled under, is used.
struct HTTP_RESPONSE_V1
{
    ///The optional logging flags change the default response behavior. These can be one of any of the
    ///HTTP_RESPONSE_FLAG values.
    uint             Flags;
    ///This member is ignored; the response is always an HTTP/1.1 response.
    HTTP_VERSION     Version;
    ///Numeric status code that characterizes the result of the HTTP request (for example, 200 signifying "OK" or 404
    ///signifying "Not Found"). For more information and a list of these codes, see Section 10 of RFC 2616. If a request
    ///is directed to a URL that is reserved but not registered, indicating that the appropriate application to handle
    ///it is not running, then the HTTP Server API itself returns a response with status code 400, signifying "Bad
    ///Request". This is transparent to the application. A code 400 is preferred here to 503 ("Server not available")
    ///because the latter is interpreted by some smart load balancers as an indication that the server is overloaded.
    ushort           StatusCode;
    ///Size, in bytes, of the string pointed to by the <b>pReason</b> member not including the terminating null. May be
    ///zero.
    ushort           ReasonLength;
    ///A pointer to a human-readable, null-terminated string of printable characters that characterizes the result of
    ///the HTTP request (for example, "OK" or "Not Found").
    const(PSTR)      pReason;
    ///An HTTP_RESPONSE_HEADERS structure that contains the headers used in this response.
    HTTP_RESPONSE_HEADERS Headers;
    ///A number of entity-body data blocks specified in the <b>pEntityChunks</b> array. This number cannot exceed 100.
    ///If the response has no entity body, this member must be zero.
    ushort           EntityChunkCount;
    ///An array of HTTP_DATA_CHUNK structures that together specify all the data blocks that make up the entity body of
    ///the response.
    HTTP_DATA_CHUNK* pEntityChunks;
}

///The <b>HTTP_RESPONSE_INFO</b> structure extends the HTTP_RESPONSE structure with additional information for the
///response.
struct HTTP_RESPONSE_INFO
{
    ///A member of the HTTP_RESPONSE_INFO_TYPE enumeration specifying the type of information contained in this
    ///structure.
    HTTP_RESPONSE_INFO_TYPE Type;
    ///The length, in bytes, of the <b>pInfo</b> member.
    uint  Length;
    ///A pointer to the HTTP_MULTIPLE_KNOWN_HEADERS structure when the <b>InfoType</b> member is
    ///<b>HttpResponseInfoTypeMultipleKnownHeaders</b>; otherwise <b>NULL</b>.
    void* pInfo;
}

///The <b>HTTP_MULTIPLE_KNOWN_HEADERS</b> structure specifies the headers that are included in an HTTP response when
///more than one header is required.
struct HTTP_MULTIPLE_KNOWN_HEADERS
{
    ///A member of the HTTP_HEADER_ID enumeration specifying the response header ID.
    HTTP_HEADER_ID     HeaderId;
    ///The flags corresponding to the response header in the <b>HeaderId</b> member. This member is used only when the
    ///WWW-Authenticate header is present. This can be zero or the following: <table> <tr> <th>Flag</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="HTTP_RESPONSE_INFO_FLAGS_PRESERVE_ORDER"></a><a
    ///id="http_response_info_flags_preserve_order"></a><dl> <dt><b>HTTP_RESPONSE_INFO_FLAGS_PRESERVE_ORDER</b></dt>
    ///</dl> </td> <td width="60%"> The specified order of authentication schemes is preserved on the challenge
    ///response. </td> </tr> </table>
    uint               Flags;
    ///The number of elements in the array specified in the <b>KnownHeaders</b> member.
    ushort             KnownHeaderCount;
    ///A pointer to the first element in the array of HTTP_KNOWN_HEADER structures.
    HTTP_KNOWN_HEADER* KnownHeaders;
}

///The <b>HTTP_RESPONSE_V2</b> structure extends the HTTP version 1.0 response structure with more information for the
///response. Do not use <b>HTTP_RESPONSE_V2</b> directly in your code; use HTTP_RESPONSE instead to ensure that the
///proper version, based on the operating system the code is compiled under, is used.
struct HTTP_RESPONSE_V2
{
    HTTP_RESPONSE_V1    __AnonymousBase_http_L2003_C36;
    ///The number of HTTP_RESPONSE_INFO structures in the array pointed to by <b>pResponseInfo</b>. The count of the
    ///HTTP_RESPONSE_INFO elements in the array pointed to by <b>pResponseInfo</b>.
    ushort              ResponseInfoCount;
    ///A pointer to an array of HTTP_RESPONSE_INFO structures containing more information about the request.
    HTTP_RESPONSE_INFO* pResponseInfo;
}

///The <b>HTTPAPI_VERSION</b> structure defines the version of the HTTP Server API. This is not to be confused with the
///version of the HTTP protocol used, which is stored in an <b>HTTP_VERSION</b> structure.
struct HTTPAPI_VERSION
{
    ///Major version of the HTTP Server API.
    ushort HttpApiMajorVersion;
    ///Minor version of the HTTP Server API.
    ushort HttpApiMinorVersion;
}

///The <b>HTTP_CACHE_POLICY</b> structure is used to define a cache policy associated with a cached response fragment.
struct HTTP_CACHE_POLICY
{
    ///This parameter is one of the following values from the HTTP_CACHE_POLICY_TYPE to control how an associated
    ///response or response fragment is cached. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="HttpCachePolicyNocache"></a><a id="httpcachepolicynocache"></a><a
    ///id="HTTPCACHEPOLICYNOCACHE"></a><dl> <dt><b>HttpCachePolicyNocache</b></dt> </dl> </td> <td width="60%"> Do not
    ///cache the data at all. </td> </tr> <tr> <td width="40%"><a id="HttpCachePolicyUserInvalidates"></a><a
    ///id="httpcachepolicyuserinvalidates"></a><a id="HTTPCACHEPOLICYUSERINVALIDATES"></a><dl>
    ///<dt><b>HttpCachePolicyUserInvalidates</b></dt> </dl> </td> <td width="60%"> Cache the data until the application
    ///explicitly releases it. </td> </tr> <tr> <td width="40%"><a id="HttpCachePolicyTimeToLive"></a><a
    ///id="httpcachepolicytimetolive"></a><a id="HTTPCACHEPOLICYTIMETOLIVE"></a><dl>
    ///<dt><b>HttpCachePolicyTimeToLive</b></dt> </dl> </td> <td width="60%"> Cache the data for a number of seconds
    ///specified by the <b>SecondsToLive</b> member. </td> </tr> </table>
    HTTP_CACHE_POLICY_TYPE Policy;
    ///When the <b>Policy</b> member is equal to HttpCachePolicyTimeToLive, data is cached for <b>SecondsToLive</b>
    ///seconds before it is released. For other values of <b>Policy</b>, <b>SecondsToLive</b> is ignored.
    uint SecondsToLive;
}

///The <b>HTTP_SERVICE_CONFIG_SSL_KEY</b> structure serves as the key by which a given Secure Sockets Layer (SSL)
///certificate record is identified. It appears in the HTTP_SERVICE_CONFIG_SSL_SET and the HTTP_SERVICE_CONFIG_SSL_QUERY
///structures, and is passed as the <i>pConfigInformation</i> parameter to HTTPDeleteServiceConfiguration,
///HttpQueryServiceConfiguration, and HttpSetServiceConfiguration when the <i>ConfigId</i> parameter is set to
///<b>HttpServiceConfigSSLCertInfo</b>.
struct HTTP_SERVICE_CONFIG_SSL_KEY
{
    ///Pointer to a sockaddr structure that contains the Internet Protocol (IP) address with which this SSL certificate
    ///is associated. If the <b>sin_addr</b> field in <b>IpPort</b> is set to 0.0.0.0, the certificate is applicable to
    ///all IPv4 and IPv6 addresses. If the <b>sin6_addr</b> field in <b>IpPort</b> is set to [::], the certificate is
    ///applicable to all IPv6 addresses.
    SOCKADDR* pIpPort;
}

struct HTTP_SERVICE_CONFIG_SSL_KEY_EX
{
    SOCKADDR_STORAGE_LH IpPort;
}

///The <b>HTTP_SERVICE_CONFIG_SSL_SNI_KEY</b> structure serves as the key by which a given Secure Sockets Layer (SSL)
///Server Name Indication (SNI) certificate record is identified in the SSL SNI store. It appears in the
///HTTP_SERVICE_CONFIG_SSL_SNI_SET and the HTTP_SERVICE_CONFIG_SSL_SNI_QUERY structures, and is passed as the
///<i>pConfigInformation</i> parameter to HttpDeleteServiceConfiguration, HttpQueryServiceConfiguration, and
///HttpSetServiceConfiguration when the <i>ConfigId</i> parameter is set to <b>HttpServiceConfigSslSniCertInfo</b>.
struct HTTP_SERVICE_CONFIG_SSL_SNI_KEY
{
    ///A SOCKADDR_STORAGE structure that contains the Internet Protocol version 4 (IPv4) address with which this SSL SNI
    ///certificate is associated. It must be set to the IPv4 wildcard address of type <b>SOCKADDR_IN</b> with
    ///<b>ss_family</b> set to <b>AF_INET</b> and <b>sin_addr</b> filled with zeros. <b>Port</b> can be any valid port.
    SOCKADDR_STORAGE_LH IpPort;
    ///A pointer to a null-terminated Unicode UTF-16 string that represents the hostname.
    PWSTR               Host;
}

///Serves as the key by which identifies the SSL certificate record that specifies that Http.sys should consult the
///Centralized Certificate Store (CCS) store to find certificates if the port receives a Transport Layer Security (TLS)
///handshake.
struct HTTP_SERVICE_CONFIG_SSL_CCS_KEY
{
    ///A SOCKADDR_STORAGE structure that contains the Internet Protocol version 4 (IPv4) address with which this SSL
    ///certificate record is associated. It must be set to the IPv4 wildcard address of type SOCKADDR_IN with the
    ///<b>sin_family</b> member set to AF_INET and the <b>sin_addr</b> member filled with zeros (0.0.0.0). The
    ///<b>sin_port</b> member can be any valid port.
    SOCKADDR_STORAGE_LH LocalAddress;
}

///The <b>HTTP_SERVICE_CONFIG_SSL_PARAM</b> structure defines a record in the SSL configuration store.
struct HTTP_SERVICE_CONFIG_SSL_PARAM
{
    ///The size, in bytes, of the SSL hash.
    uint  SslHashLength;
    ///A pointer to the SSL certificate hash.
    void* pSslHash;
    ///A unique identifier of the application setting this record.
    GUID  AppId;
    ///A pointer to a wide-character string that contains the name of the store from which the server certificate is to
    ///be read. If set to <b>NULL</b>, "MY" is assumed as the default name. The specified certificate store name must be
    ///present in the Local System store location.
    PWSTR pSslCertStoreName;
    ///Determines how client certificates are checked. This member can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td
    ///width="60%"> Enables the client certificate revocation check. </td> </tr> <tr> <td width="40%"><a id="1"></a><dl>
    ///<dt><b>1</b></dt> </dl> </td> <td width="60%"> Client certificate is not to be verified for revocation. </td>
    ///</tr> <tr> <td width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> Only cached
    ///certificate revocation is to be used. </td> </tr> <tr> <td width="40%"><a id="4"></a><dl> <dt><b>4</b></dt> </dl>
    ///</td> <td width="60%"> The <b>DefaultRevocationFreshnessTime</b> setting is enabled. </td> </tr> <tr> <td
    ///width="40%"><a id="0x10000"></a><a id="0X10000"></a><dl> <dt><b>0x10000</b></dt> </dl> </td> <td width="60%"> No
    ///usage check is to be performed. </td> </tr> </table>
    uint  DefaultCertCheckMode;
    ///The number of seconds after which to check for an updated certificate revocation list (CRL). If this value is
    ///zero, the new CRL is updated only when the previous one expires.
    uint  DefaultRevocationFreshnessTime;
    ///The timeout interval, in milliseconds, for an attempt to retrieve a certificate revocation list from the remote
    ///URL.
    uint  DefaultRevocationUrlRetrievalTimeout;
    ///A pointer to an SSL control identifier, which enables an application to restrict the group of certificate issuers
    ///to be trusted. This group must be a subset of the certificate issuers trusted by the machine on which the
    ///application is running.
    PWSTR pDefaultSslCtlIdentifier;
    ///The name of the store where the control identifier pointed to by <b>pDefaultSslCtlIdentifier</b> is stored.
    PWSTR pDefaultSslCtlStoreName;
    ///A combination of zero or more of the following flag values can be combined with OR as appropriate. <table> <tr>
    ///<th>Flags</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="HTTP_SERVICE_CONFIG_SSL_FLAG_NEGOTIATE_CLIENT_CERT"></a><a
    ///id="http_service_config_ssl_flag_negotiate_client_cert"></a><dl>
    ///<dt><b>HTTP_SERVICE_CONFIG_SSL_FLAG_NEGOTIATE_CLIENT_CERT</b></dt> </dl> </td> <td width="60%"> Enables a client
    ///certificate to be cached locally for subsequent use. </td> </tr> <tr> <td width="40%"><a
    ///id="HTTP_SERVICE_CONFIG_SSL_FLAG_NO_RAW_FILTER"></a><a id="http_service_config_ssl_flag_no_raw_filter"></a><dl>
    ///<dt><b>HTTP_SERVICE_CONFIG_SSL_FLAG_NO_RAW_FILTER</b></dt> </dl> </td> <td width="60%"> Prevents SSL requests
    ///from being passed to low-level ISAPI filters. </td> </tr> <tr> <td width="40%"><a
    ///id="HTTP_SERVICE_CONFIG_SSL_FLAG_USE_DS_MAPPER"></a><a id="http_service_config_ssl_flag_use_ds_mapper"></a><dl>
    ///<dt><b>HTTP_SERVICE_CONFIG_SSL_FLAG_USE_DS_MAPPER</b></dt> </dl> </td> <td width="60%"> Client certificates are
    ///mapped where possible to corresponding operating-system user accounts based on the certificate mapping rules
    ///stored in Active Directory. If this flag is set and the mapping is successful, the <b>Token</b> member of the
    ///HTTP_SSL_CLIENT_CERT_INFO structure is a handle to an access token. Release this token explicitly by closing the
    ///handle when the <b>HTTP_SSL_CLIENT_CERT_INFO</b> structure is no longer required. </td> </tr> </table>
    uint  DefaultFlags;
}

struct HTTP2_WINDOW_SIZE_PARAM
{
    uint Http2ReceiveWindowSize;
}

struct HTTP2_SETTINGS_LIMITS_PARAM
{
    uint Http2MaxSettingsPerFrame;
    uint Http2MaxSettingsPerMinute;
}

struct HTTP_PERFORMANCE_PARAM
{
    ulong SendBufferingFlags;
    ubyte EnableAggressiveICW;
    uint  MaxBufferedSendBytes;
    uint  MaxConcurrentClientStreams;
}

struct HTTP_SERVICE_CONFIG_SSL_PARAM_EX
{
    HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE ParamType;
    ulong Flags;
union
    {
        HTTP2_WINDOW_SIZE_PARAM Http2WindowSizeParam;
        HTTP2_SETTINGS_LIMITS_PARAM Http2SettingsLimitsParam;
        HTTP_PERFORMANCE_PARAM HttpPerformanceParam;
    }
}

///The <b>HTTP_SERVICE_CONFIG_SSL_SET</b> structure is used to add a new record to the SSL store or retrieve an existing
///record from it. An instance of the structure is used to pass data in to the HTTPSetServiceConfiguration function
///through the <i>pConfigInformation</i> parameter or to retrieve data from the HTTPQueryServiceConfiguration function
///through the <i>pOutputConfigInformation</i> parameter when the <i>ConfigId</i> parameter of either function is equal
///to <b>HTTPServiceConfigSSLCertInfo</b>.
struct HTTP_SERVICE_CONFIG_SSL_SET
{
    ///An HTTP_SERVICE_CONFIG_SSL_KEY structure that identifies the SSL certificate record.
    HTTP_SERVICE_CONFIG_SSL_KEY KeyDesc;
    ///An HTTP_SERVICE_CONFIG_SSL_PARAM structure that holds the contents of the specified SSL certificate record.
    HTTP_SERVICE_CONFIG_SSL_PARAM ParamDesc;
}

///The <b>HTTP_SERVICE_CONFIG_SSL_SNI_SET</b> structure is used to add a new Secure Sockets Layer (SSL) Server Name
///Indication (SNI) certificate record to the SSL SNI store or retrieve an existing record from it. It is passed to the
///HttpSetServiceConfiguration function through the <i>pConfigInformation</i> parameter or to retrieve data from the
///HttpQueryServiceConfiguration function through the <i>pOutputConfigInformation</i> parameter when the <i>ConfigId</i>
///parameter of either function is set to <b>HttpServiceConfigSslSniCertInfo</b>.
struct HTTP_SERVICE_CONFIG_SSL_SNI_SET
{
    ///An HTTP_SERVICE_CONFIG_SSL_SNI_KEY structure that identifies the SSL SNI certificate record.
    HTTP_SERVICE_CONFIG_SSL_SNI_KEY KeyDesc;
    ///An HTTP_SERVICE_CONFIG_SSL_PARAM structure that holds the contents of the specified SSL SNI certificate record.
    HTTP_SERVICE_CONFIG_SSL_PARAM ParamDesc;
}

///Represents the SSL certificate record that specifies that Http.sys should consult the Centralized Certificate Store
///(CCS) store to find certificates if the port receives a Transport Layer Security (TLS) handshake. Use this structure
///to add, delete, retrieve, or update that SSL certificate.
struct HTTP_SERVICE_CONFIG_SSL_CCS_SET
{
    ///An HTTP_SERVICE_CONFIG_SSL_CCS_KEY structure that identifies the SSL CCS certificate record.
    HTTP_SERVICE_CONFIG_SSL_CCS_KEY KeyDesc;
    ///An HTTP_SERVICE_CONFIG_SSL_PARAM structure that holds the contents of the specified SSL CCS certificate record.
    HTTP_SERVICE_CONFIG_SSL_PARAM ParamDesc;
}

struct HTTP_SERVICE_CONFIG_SSL_SET_EX
{
    HTTP_SERVICE_CONFIG_SSL_KEY_EX KeyDesc;
    HTTP_SERVICE_CONFIG_SSL_PARAM_EX ParamDesc;
}

struct HTTP_SERVICE_CONFIG_SSL_SNI_SET_EX
{
    HTTP_SERVICE_CONFIG_SSL_SNI_KEY KeyDesc;
    HTTP_SERVICE_CONFIG_SSL_PARAM_EX ParamDesc;
}

struct HTTP_SERVICE_CONFIG_SSL_CCS_SET_EX
{
    HTTP_SERVICE_CONFIG_SSL_CCS_KEY KeyDesc;
    HTTP_SERVICE_CONFIG_SSL_PARAM_EX ParamDesc;
}

///The <b>HTTP_SERVICE_CONFIG_SSL_QUERY</b> structure is used to specify a particular record to query in the SSL
///configuration store. It is passed to the HttpQueryServiceConfiguration function using the <i>pInputConfigInfo</i>
///parameter when the <i>ConfigId</i> parameter is set to <b>HttpServiceConfigSSLCertInfo</b>.
struct HTTP_SERVICE_CONFIG_SSL_QUERY
{
    ///One of the following values from the HTTP_SERVICE_CONFIG_QUERY_TYPE enumeration.
    HTTP_SERVICE_CONFIG_QUERY_TYPE QueryDesc;
    ///If the <i>QueryDesc</i> parameter is equal to <b>HttpServiceConfigQueryExact</b>, then <i>KeyDesc</i> should
    ///contain an HTTP_SERVICE_CONFIG_SSL_KEY structure that identifies the SSL certificate record queried. If the
    ///<i>QueryDesc</i> parameter is equal to HTTPServiceConfigQueryNext, then <i>KeyDesc</i> is ignored.
    HTTP_SERVICE_CONFIG_SSL_KEY KeyDesc;
    ///If the <i>QueryDesc</i> parameter is equal to <b>HTTPServiceConfigQueryNext</b>, then <i>dwToken</i> must be
    ///equal to zero on the first call to the HttpQueryServiceConfiguration function, one on the second call, two on the
    ///third call, and so forth until all SSL certificate records are returned, at which point
    ///<b>HttpQueryServiceConfiguration</b> returns ERROR_NO_MORE_ITEMS. If the <i>QueryDesc</i> parameter is equal to
    ///<b>HttpServiceConfigQueryExact</b>, then <i>dwToken</i> is ignored.
    uint dwToken;
}

///The <b>HTTP_SERVICE_CONFIG_SSL_SNI_QUERY</b> structure is used to specify a particular Secure Sockets Layer (SSL)
///Server Name Indication (SNI) certificate record to query in the SSL SNI store. It is passed to the
///HttpQueryServiceConfiguration function using the <i>pInputConfigInfo</i> parameter when the <i>ConfigId</i> parameter
///is set to <b>HttpServiceConfigSslSniCertInfo</b>.
struct HTTP_SERVICE_CONFIG_SSL_SNI_QUERY
{
    ///One of the following values from the HTTP_SERVICE_CONFIG_QUERY_TYPE enumeration. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="HttpServiceConfigQueryExact"></a><a
    ///id="httpserviceconfigqueryexact"></a><a id="HTTPSERVICECONFIGQUERYEXACT"></a><dl>
    ///<dt><b>HttpServiceConfigQueryExact</b></dt> </dl> </td> <td width="60%"> Returns a single SSL SNI certificate
    ///record. </td> </tr> <tr> <td width="40%"><a id="HttpServiceConfigQueryNext"></a><a
    ///id="httpserviceconfigquerynext"></a><a id="HTTPSERVICECONFIGQUERYNEXT"></a><dl>
    ///<dt><b>HttpServiceConfigQueryNext</b></dt> </dl> </td> <td width="60%"> Returns a sequence of SSL SNI certificate
    ///records in a sequence of calls, as controlled by <i>dwToken</i>. </td> </tr> </table>
    HTTP_SERVICE_CONFIG_QUERY_TYPE QueryDesc;
    ///If the <i>QueryDesc</i> parameter is equal to <b>HttpServiceConfigQueryExact</b>, then <i>KeyDesc</i> should
    ///contain an HTTP_SERVICE_CONFIG_SSL_SNI_KEY structure that identifies the SSL SNI certificate record queried. If
    ///the <i>QueryDesc</i> parameter is equal to <b>HTTPServiceConfigQueryNext</b>, then <i>KeyDesc</i> is ignored.
    HTTP_SERVICE_CONFIG_SSL_SNI_KEY KeyDesc;
    ///If the <i>QueryDesc</i> parameter is equal to <b>HTTPServiceConfigQueryNext</b>, then <i>dwToken</i> must be
    ///equal to zero on the first call to the HttpQueryServiceConfiguration function, one on the second call, two on the
    ///third call, and so forth until all SSL certificate records are returned, at which point
    ///<b>HttpQueryServiceConfiguration</b> returns ERROR_NO_MORE_ITEMS. If the <i>QueryDesc</i> parameter is equal to
    ///<b>HttpServiceConfigQueryExact</b>, then <i>dwToken</i> is ignored.
    uint dwToken;
}

///Specifies a Secure Sockets Layer (SSL) configuration to query for an SSL Centralized Certificate Store (CCS) record
///on the port when you call the HttpQueryServiceConfiguration function. The SSL certificate record specifies that
///Http.sys should consult the CCS store to find certificates if the port receives a Transport Layer Security (TLS)
///handshake.
struct HTTP_SERVICE_CONFIG_SSL_CCS_QUERY
{
    ///One of the following values from the HTTP_SERVICE_CONFIG_QUERY_TYPE enumeration that indicates whether the call
    ///to HttpQueryServiceConfiguration is a call to retrieve a single record or part of a sequence of calls to retrieve
    ///a sequence of records. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="HttpServiceConfigQueryExact"></a><a id="httpserviceconfigqueryexact"></a><a
    ///id="HTTPSERVICECONFIGQUERYEXACT"></a><dl> <dt><b>HttpServiceConfigQueryExact</b></dt> </dl> </td> <td
    ///width="60%"> The call to HttpQueryServiceConfiguration is call to retrieve a single SSL CCS certificate record,
    ///which the <b>KeyDesc</b> member specifies. </td> </tr> <tr> <td width="40%"><a
    ///id="HttpServiceConfigQueryNext"></a><a id="httpserviceconfigquerynext"></a><a
    ///id="HTTPSERVICECONFIGQUERYNEXT"></a><dl> <dt><b>HttpServiceConfigQueryNext</b></dt> </dl> </td> <td width="60%">
    ///The call to HttpQueryServiceConfiguration is part of a sequence of calls to retrieve a sequence of SSL CCS
    ///certificate records. The value of the <b>dwToken</b> member controls which record in the sequence that this call
    ///to <b>HttpQueryServiceConfiguration</b> retrieves. </td> </tr> </table>
    HTTP_SERVICE_CONFIG_QUERY_TYPE QueryDesc;
    ///An HTTP_SERVICE_CONFIG_SSL_CCS_KEY structure that identifies the SSL CCS certificate record queried, if the
    ///<b>QueryDesc</b> member is equal to <b>HttpServiceConfigQueryExact</b>. Ignored if <b>QueryDesc</b> is equal to
    ///<b>HTTPServiceConfigQueryNext</b>.
    HTTP_SERVICE_CONFIG_SSL_CCS_KEY KeyDesc;
    ///The position of the record in the sequence of records that this call to HttpQueryServiceConfiguration should
    ///retrieve if the <b>QueryDesc</b> method equals <b>HTTPServiceConfigQueryNext</b>, starting from zero. In other
    ///words, <b>dwToken</b> must be equal to zero on the first call to the <b>HttpQueryServiceConfiguration</b>
    ///function, one on the second call, two on the third call, and so forth. When the sequence of calls has returned
    ///all SSL certificate records, <b>HttpQueryServiceConfiguration</b> returns <b>ERROR_NO_MORE_ITEMS</b>. Ignored if
    ///the <b>QueryDesc</b> is equal to <b>HttpServiceConfigQueryExact</b>.
    uint dwToken;
}

struct HTTP_SERVICE_CONFIG_SSL_QUERY_EX
{
    HTTP_SERVICE_CONFIG_QUERY_TYPE QueryDesc;
    HTTP_SERVICE_CONFIG_SSL_KEY_EX KeyDesc;
    uint dwToken;
    HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE ParamType;
}

struct HTTP_SERVICE_CONFIG_SSL_SNI_QUERY_EX
{
    HTTP_SERVICE_CONFIG_QUERY_TYPE QueryDesc;
    HTTP_SERVICE_CONFIG_SSL_SNI_KEY KeyDesc;
    uint dwToken;
    HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE ParamType;
}

struct HTTP_SERVICE_CONFIG_SSL_CCS_QUERY_EX
{
    HTTP_SERVICE_CONFIG_QUERY_TYPE QueryDesc;
    HTTP_SERVICE_CONFIG_SSL_CCS_KEY KeyDesc;
    uint dwToken;
    HTTP_SSL_SERVICE_CONFIG_EX_PARAM_TYPE ParamType;
}

///The <b>HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM</b> structure is used to specify an IP address to be added to or deleted
///from the list of IP addresses to which the HTTP service binds.
struct HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM
{
    ///The size, in bytes, of the address pointed to by <b>pAddress</b>.
    ushort    AddrLength;
    ///A pointer to an Internet Protocol (IP) address to be added to or deleted from the listen list. To specify an IPv6
    ///address, use a SOCKADDR_IN6 structure, declared in the Ws2tcpip.h header file, and cast its address to a
    ///PSOCKADDR when you use it to set the <b>pAddress</b> member. The <b>sin_family</b> member of the SOCKADDR_IN6
    ///should be set to AF_INET6. If the <b>sin_addr</b> field in SOCKADDR_IN6 structure is set to 0.0.0.0, it means to
    ///bind to all IPv4 addresses. If the <b>sin6_addr</b> field in SOCKADDR_IN6 is set to [::], it means to bind to all
    ///IPv6 addresses.
    SOCKADDR* pAddress;
}

///The <b>HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY</b> structure is used by HttpQueryServiceConfiguration to return a list of
///the Internet Protocol (IP) addresses to which the HTTP service binds.
struct HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY
{
    ///The number of address structures in the <b>AddrList</b> array.
    uint AddrCount;
    ///An array of SOCKADDR_STORAGE structures that contains IP addresses in either IPv4 or IPv6 form. To determine what
    ///form an address in the list has, cast it to a SOCKADDR and examine the <b>sa_family</b> element. If
    ///<b>sa_family</b> is equal to AF_INET, the address is in IPv4 form, or if it is equal to AF_INET6, the address is
    ///in IPv6 form.
    SOCKADDR_STORAGE_LH[1] AddrList;
}

///The <b>HTTP_SERVICE_CONFIG_URLACL_KEY</b> structure is used to specify a particular reservation record in the URL
///namespace reservation store. It is a member of the HTTP_SERVICE_CONFIG_URLACL_SET and
///HTTP_SERVICE_CONFIG_URLACL_QUERY structures.
struct HTTP_SERVICE_CONFIG_URLACL_KEY
{
    ///A pointer to the UrlPrefix string that defines the portion of the URL namespace to which this reservation
    ///pertains.
    PWSTR pUrlPrefix;
}

///The <b>HTTP_SERVICE_CONFIG_URLACL_PARAM</b> structure is used to specify the permissions associated with a particular
///record in the URL namespace reservation store. It is a member of the HTTP_SERVICE_CONFIG_URLACL_SET structure.
struct HTTP_SERVICE_CONFIG_URLACL_PARAM
{
    ///A pointer to a Security Descriptor Definition Language (SDDL) string that contains the permissions associated
    ///with this URL namespace reservation record.
    PWSTR pStringSecurityDescriptor;
}

///The <b>HTTP_SERVICE_CONFIG_URLACL_SET</b> structure is used to add a new record to the URL reservation store or
///retrieve an existing record from it. An instance of the structure is used to pass data in through the
///<i>pConfigInformation</i> parameter of the HTTPSetServiceConfiguration function, or to retrieve data through the
///<i>pOutputConfigInformation</i> parameter of the HTTPQueryServiceConfiguration function when the <i>ConfigId</i>
///parameter of either function is equal to <b>HTTPServiceConfigUrlAclInfo</b>.
struct HTTP_SERVICE_CONFIG_URLACL_SET
{
    ///An HTTP_SERVICE_CONFIG_URLACL_KEY structure that identifies the URL reservation record.
    HTTP_SERVICE_CONFIG_URLACL_KEY KeyDesc;
    ///An HTTP_SERVICE_CONFIG_URLACL_PARAM structure that holds the contents of the specified URL reservation record.
    HTTP_SERVICE_CONFIG_URLACL_PARAM ParamDesc;
}

///The <b>HTTP_SERVICE_CONFIG_URLACL_QUERY</b> structure is used to specify a particular reservation record to query in
///the URL namespace reservation store. It is passed to the HttpQueryServiceConfiguration function using the
///<i>pInputConfigInfo</i> parameter when the <i>ConfigId</i> parameter is equal to <b>HttpServiceConfigUrlAclInfo</b>.
struct HTTP_SERVICE_CONFIG_URLACL_QUERY
{
    ///One of the following values from the HTTP_SERVICE_CONFIG_QUERY_TYPE enumeration.
    HTTP_SERVICE_CONFIG_QUERY_TYPE QueryDesc;
    ///If the <i>QueryDesc</i> parameter is equal to <b>HttpServiceConfigQueryExact</b>, then <i>KeyDesc</i> should
    ///contain an HTTP_SERVICE_CONFIG_URLACL_KEY structure that identifies the reservation record queried. If the
    ///<i>QueryDesc</i> parameter is equal to <b>HttpServiceConfigQueryNext</b>, <i>KeyDesc</i> is ignored.
    HTTP_SERVICE_CONFIG_URLACL_KEY KeyDesc;
    ///If the <i>QueryDesc</i> parameter is equal to <b>HttpServiceConfigQueryNext</b>, then <i>dwToken</i> must be
    ///equal to zero on the first call to the HttpQueryServiceConfiguration function, one on the second call, two on the
    ///third call, and so forth until all reservation records are returned, at which point
    ///<b>HttpQueryServiceConfiguration</b> returns ERROR_NO_MORE_ITEMS. If the <i>QueryDesc</i> parameter is equal to
    ///<b>HttpServiceConfigQueryExact</b>, then <i>dwToken</i> is ignored.
    uint dwToken;
}

///Used in the <i>pConfigInformation</i> parameter of the HttpSetServiceConfiguration function.
struct HTTP_SERVICE_CONFIG_CACHE_SET
{
    ///Cache key.
    HTTP_SERVICE_CONFIG_CACHE_KEY KeyDesc;
    ///Configuration cache parameter.
    uint ParamDesc;
}

struct HTTP_QUERY_REQUEST_QUALIFIER_TCP
{
    ulong Freshness;
}

struct HTTP_QUERY_REQUEST_QUALIFIER_QUIC
{
    ulong Freshness;
}

struct HTTP_REQUEST_PROPERTY_SNI
{
    ushort[256] Hostname;
    uint        Flags;
}

///The <b>WINHTTP_ASYNC_RESULT</b> structure contains the result of a call to an asynchronous function. This structure
///is used with the WINHTTP_STATUS_CALLBACK prototype.
struct WINHTTP_ASYNC_RESULT
{
    ///Return value from an asynchronous Microsoft Windows HTTP Services (WinHTTP) function. This member can be one of
    ///the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="API_RECEIVE_RESPONSE"></a><a id="api_receive_response"></a><dl> <dt><b>API_RECEIVE_RESPONSE</b></dt>
    ///<dt>1</dt> </dl> </td> <td width="60%"> The error occurred during a call to WinHttpReceiveResponse. </td> </tr>
    ///<tr> <td width="40%"><a id="API_QUERY_DATA_AVAILABLE"></a><a id="api_query_data_available"></a><dl>
    ///<dt><b>API_QUERY_DATA_AVAILABLE</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The error occurred during a call
    ///to WinHttpQueryDataAvailable. </td> </tr> <tr> <td width="40%"><a id="API_READ_DATA"></a><a
    ///id="api_read_data"></a><dl> <dt><b>API_READ_DATA</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> The error
    ///occurred during a call to WinHttpReadData. </td> </tr> <tr> <td width="40%"><a id="API_WRITE_DATA"></a><a
    ///id="api_write_data"></a><dl> <dt><b>API_WRITE_DATA</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> The error
    ///occurred during a call to WinHttpWriteData. </td> </tr> <tr> <td width="40%"><a id="API_SEND_REQUEST"></a><a
    ///id="api_send_request"></a><dl> <dt><b>API_SEND_REQUEST</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> The error
    ///occurred during a call to WinHttpSendRequest. </td> </tr> </table>
    size_t dwResult;
    ///Contains the error code if <b>dwResult</b> indicates that the function failed.
    uint   dwError;
}

///The <b>URL_COMPONENTS</b> structure contains the constituent parts of a URL. This structure is used with the
///WinHttpCrackUrl and WinHttpCreateUrl functions.
struct URL_COMPONENTS
{
    ///Size of this structure, in bytes. Used for version checking. The size of this structure must be set to initialize
    ///this structure properly.
    uint            dwStructSize;
    ///Pointer to a string value that contains the scheme name.
    PWSTR           lpszScheme;
    ///Length of the scheme name, in characters.
    uint            dwSchemeLength;
    ///Internet protocol scheme. This member can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="INTERNET_SCHEME_HTTP"></a><a
    ///id="internet_scheme_http"></a><dl> <dt><b>INTERNET_SCHEME_HTTP</b></dt> <dt>1</dt> </dl> </td> <td width="60%">
    ///The Internet scheme is the HTTP protocol. See RFC 2616 for more information. </td> </tr> <tr> <td width="40%"><a
    ///id="INTERNET_SCHEME_HTTPS"></a><a id="internet_scheme_https"></a><dl> <dt><b>INTERNET_SCHEME_HTTPS</b></dt>
    ///<dt>2</dt> </dl> </td> <td width="60%"> The Internet scheme, HTTPS, is an HTTP protocol that uses secure
    ///transaction semantics. </td> </tr> </table>
    INTERNET_SCHEME nScheme;
    ///Pointer to a string value that contains the host name.
    PWSTR           lpszHostName;
    ///Length of the host name, in characters.
    uint            dwHostNameLength;
    ///Port number.
    ushort          nPort;
    ///Pointer to a string that contains the user name.
    PWSTR           lpszUserName;
    ///Length of the user name, in characters.
    uint            dwUserNameLength;
    ///Pointer to a string that contains the password.
    PWSTR           lpszPassword;
    ///Length of the password, in characters.
    uint            dwPasswordLength;
    ///Pointer to a string that contains the URL path.
    PWSTR           lpszUrlPath;
    ///Length of the URL path, in characters.
    uint            dwUrlPathLength;
    ///Pointer to a string value that contains the extra information, for example, ?something or
    PWSTR           lpszExtraInfo;
    ///Unsigned long integer value that contains the length of the extra information, in characters.
    uint            dwExtraInfoLength;
}

///The <b>WINHTTP_PROXY_INFO</b> structure contains the session or default proxy configuration.
struct WINHTTP_PROXY_INFO
{
    ///Unsigned long integer value that contains the access type. This can be one of the following values: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="WINHTTP_ACCESS_TYPE_NO_PROXY"></a><a
    ///id="winhttp_access_type_no_proxy"></a><dl> <dt><b>WINHTTP_ACCESS_TYPE_NO_PROXY</b></dt> </dl> </td> <td
    ///width="60%"> Internet accessed through a direct connection. </td> </tr> <tr> <td width="40%"><a
    ///id="WINHTTP_ACCESS_TYPE_DEFAULT_PROXY"></a><a id="winhttp_access_type_default_proxy"></a><dl>
    ///<dt><b>WINHTTP_ACCESS_TYPE_DEFAULT_PROXY</b></dt> </dl> </td> <td width="60%"> Applies only when setting proxy
    ///information. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_ACCESS_TYPE_NAMED_PROXY"></a><a
    ///id="winhttp_access_type_named_proxy"></a><dl> <dt><b>WINHTTP_ACCESS_TYPE_NAMED_PROXY</b></dt> </dl> </td> <td
    ///width="60%"> Internet accessed using a proxy. </td> </tr> </table>
    uint  dwAccessType;
    ///Pointer to a string value that contains the proxy server list.
    PWSTR lpszProxy;
    ///Pointer to a string value that contains the proxy bypass list.
    PWSTR lpszProxyBypass;
}

///The <b>WINHTTP_AUTOPROXY_OPTIONS</b> structure is used to indicate to the WinHttpGetProxyForURL function whether to
///specify the URL of the Proxy Auto-Configuration (PAC) file or to automatically locate the URL with DHCP or DNS
///queries to the network.
struct WINHTTP_AUTOPROXY_OPTIONS
{
    ///Mechanisms should be used to obtain the PAC file. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <tr>
    ///<td width="40%"><a id="WINHTTP_AUTOPROXY_ALLOW_AUTOCONFIG"></a><a
    ///id="winhttp_autoproxy_allow_autoconfig"></a><dl> <dt><b>WINHTTP_AUTOPROXY_ALLOW_AUTOCONFIG</b></dt> </dl> </td>
    ///<td width="60%"> Enables proxy detection via autoconfig URL. </td> </tr> <tr> <td width="40%"><a
    ///id="WINHTTP_AUTOPROXY_ALLOW_CM"></a><a id="winhttp_autoproxy_allow_cm"></a><dl>
    ///<dt><b>WINHTTP_AUTOPROXY_ALLOW_CM</b></dt> </dl> </td> <td width="60%"> Enables proxy detection via connection
    ///manager. </td> </tr> <td width="40%"><a id="WINHTTP_AUTOPROXY_ALLOW_STATIC"></a><a
    ///id="winhttp_autoproxy_allow_static"></a><dl> <dt><b>WINHTTP_AUTOPROXY_ALLOW_STATIC</b></dt> </dl> </td> <td
    ///width="60%"> Enables proxy detection via static configuration. </td> </tr> <tr> <td width="40%"><a
    ///id="WINHTTP_AUTOPROXY_AUTO_DETECT"></a><a id="winhttp_autoproxy_auto_detect"></a><dl>
    ///<dt><b>WINHTTP_AUTOPROXY_AUTO_DETECT</b></dt> </dl> </td> <td width="60%"> Attempt to automatically discover the
    ///URL of the PAC file using both DHCP and DNS queries to the local network. </td> </tr> <tr> <td width="40%"><a
    ///id="WINHTTP_AUTOPROXY_CONFIG_URL"></a><a id="winhttp_autoproxy_config_url"></a><dl>
    ///<dt><b>WINHTTP_AUTOPROXY_CONFIG_URL</b></dt> </dl> </td> <td width="60%"> Download the PAC file from the URL
    ///specified by <b>lpszAutoConfigUrl</b> in the <b>WINHTTP_AUTOPROXY_OPTIONS</b> structure. </td> </tr> <tr> <td
    ///width="40%"><a id="WINHTTP_AUTOPROXY_HOST_KEEPCASE"></a><a id="winhttp_autoproxy_host_keepcase"></a><dl>
    ///<dt><b>WINHTTP_AUTOPROXY_HOST_KEEPCASE</b></dt> </dl> </td> <td width="60%"> Maintains the case of the hostnames
    ///passed to the PAC script. This is the default behavior. </td> </tr> <tr> <td width="40%"><a
    ///id="WINHTTP_AUTOPROXY_HOST_LOWERCASE"></a><a id="winhttp_autoproxy_host_lowercase"></a><dl>
    ///<dt><b>WINHTTP_AUTOPROXY_HOST_LOWERCASE</b></dt> </dl> </td> <td width="60%"> Converts hostnames to lowercase
    ///before passing them to the PAC script. </td> </tr> <tr> <td width="40%"><a
    ///id="WINHTTP_AUTOPROXY_NO_CACHE_CLIENT"></a><a id="winhttp_autoproxy_no_cache_client"></a><dl>
    ///<dt><b>WINHTTP_AUTOPROXY_NO_CACHE_CLIENT</b></dt> </dl> </td> <td width="60%"> Disables querying a host to proxy
    ///cache of script execution results in the current process. </td> </tr> <tr> <td width="40%"><a
    ///id="WINHTTP_AUTOPROXY_NO_CACHE_SVC"></a><a id="winhttp_autoproxy_no_cache_svc"></a><dl>
    ///<dt><b>WINHTTP_AUTOPROXY_NO_CACHE_SVC</b></dt> </dl> </td> <td width="60%"> Disables querying a host to proxy
    ///cache of script execution results in the autoproxy service. </td> </tr> <tr> <td width="40%"><a
    ///id="WINHTTP_AUTOPROXY_NO_DIRECTACCESS"></a><a id="winhttp_autoproxy_no_directaccess"></a><dl>
    ///<dt><b>WINHTTP_AUTOPROXY_NO_DIRECTACCESS</b></dt> </dl> </td> <td width="60%"> Disables querying Direct Access
    ///proxy settings for this request. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTOPROXY_RUN_INPROCESS"></a><a
    ///id="winhttp_autoproxy_run_inprocess"></a><dl> <dt><b>WINHTTP_AUTOPROXY_RUN_INPROCESS</b></dt> </dl> </td> <td
    ///width="60%"> Executes the Web Proxy Auto-Discovery (WPAD) protocol in-process instead of delegating to an
    ///out-of-process WinHTTP AutoProxy Service, if available. This flag must be combined with one of the other flags.
    ///This option has no effect when passed to WinHttpGetProxyForUrlEx. <div class="alert"><b>Note</b> This flag is
    ///deprecated.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a
    ///id="WINHTTP_AUTOPROXY_RUN_OUTPROCESS_ONLY"></a><a id="winhttp_autoproxy_run_outprocess_only"></a><dl>
    ///<dt><b>WINHTTP_AUTOPROXY_RUN_OUTPROCESS_ONLY</b></dt> </dl> </td> <td width="60%"> By default, WinHTTP is
    ///configured to fall back to auto-discover a proxy in-process. If this fallback behavior is undesirable in the
    ///event that an out-of-process discovery fails, it can be disabled using this flag. This option has no effect when
    ///passed to WinHttpGetProxyForUrlEx. <div class="alert"><b>Note</b> This flag is available on Windows Server 2003
    ///only.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTOPROXY_SORT_RESULTS_"></a><a
    ///id="winhttp_autoproxy_sort_results_"></a><dl> <dt><b>WINHTTP_AUTOPROXY_SORT_RESULTS </b></dt> </dl> </td> <td
    ///width="60%"> Orders the proxy results based on a heuristic placing the fastest proxies first. </td> </tr>
    ///</table>
    uint         dwFlags;
    ///If <b>dwFlags</b> includes the WINHTTP_AUTOPROXY_AUTO_DETECT flag, then <b>dwAutoDetectFlags</b> specifies what
    ///protocols are to be used to locate the PAC file. If both the DHCP and DNS auto detect flags are specified, then
    ///DHCP is used first; if no PAC URL is discovered using DHCP, then DNS is used. If <b>dwFlags</b> does not include
    ///the WINHTTP_AUTOPROXY_AUTO_DETECT flag, then <b>dwAutoDetectFlags</b> must be zero. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTO_DETECT_TYPE_DHCP"></a><a
    ///id="winhttp_auto_detect_type_dhcp"></a><dl> <dt><b>WINHTTP_AUTO_DETECT_TYPE_DHCP</b></dt> </dl> </td> <td
    ///width="60%"> Use DHCP to locate the proxy auto-configuration file. </td> </tr> <tr> <td width="40%"><a
    ///id="WINHTTP_AUTO_DETECT_TYPE_DNS_A"></a><a id="winhttp_auto_detect_type_dns_a"></a><dl>
    ///<dt><b>WINHTTP_AUTO_DETECT_TYPE_DNS_A</b></dt> </dl> </td> <td width="60%"> Use DNS to attempt to locate the
    ///proxy auto-configuration file at a well-known location on the domain of the local computer. </td> </tr> </table>
    uint         dwAutoDetectFlags;
    ///If <b>dwFlags</b> includes the WINHTTP_AUTOPROXY_CONFIG_URL flag, the <b>lpszAutoConfigUrl</b> must point to a
    ///<b>null</b>-terminated Unicode string that contains the URL of the proxy auto-configuration (PAC) file. If
    ///<b>dwFlags</b> does not include the WINHTTP_AUTOPROXY_CONFIG_URL flag, then <b>lpszAutoConfigUrl</b> must be
    ///<b>NULL</b>.
    const(PWSTR) lpszAutoConfigUrl;
    ///Reserved for future use; must be <b>NULL</b>.
    void*        lpvReserved;
    ///Reserved for future use; must be zero.
    uint         dwReserved;
    ///Specifies whether the client's domain credentials should be automatically sent in response to an NTLM or
    ///Negotiate Authentication challenge when WinHTTP requests the PAC file. If this flag is TRUE, credentials should
    ///automatically be sent in response to an authentication challenge. If this flag is FALSE and authentication is
    ///required to download the PAC file, the WinHttpGetProxyForUrl function fails.
    BOOL         fAutoLogonIfChallenged;
}

///The <b>WINHTTP_PROXY_RESULT_ENTRY</b> structure contains a result entry from a call to WinHttpGetProxyResult.
struct WINHTTP_PROXY_RESULT_ENTRY
{
    ///A <b>BOOL</b> that whether a result is from a proxy. It is set to <b>TRUE</b> if the result contains a proxy or
    ///<b>FALSE</b> if the result does not contain a proxy.
    BOOL            fProxy;
    ///A BOOL that indicates if the result is bypassing a proxy (on an intranet). It is set to <b>TRUE</b> if the result
    ///is bypassing a proxy or <b>FALSE</b> if all traffic is direct. This parameter applies only if <i>fProxy</i> is
    ///<b>FALSE</b>.
    BOOL            fBypass;
    ///An INTERNET_SCHEME value that specifies the scheme of the proxy.
    INTERNET_SCHEME ProxyScheme;
    ///A string that contains the hostname of the proxy.
    PWSTR           pwszProxy;
    ///An INTERNET_PORT value that specifies the port of the proxy.
    ushort          ProxyPort;
}

///The <b>WINHTTP_PROXY_RESULT</b> structure contains collection of proxy result entries provided by
///WinHttpGetProxyResult.
struct WINHTTP_PROXY_RESULT
{
    ///The number of entries in the <b>pEntries</b> array.
    uint cEntries;
    ///A pointer to an array of WINHTTP_PROXY_RESULT_ENTRY structures.
    WINHTTP_PROXY_RESULT_ENTRY* pEntries;
}

struct WINHTTP_PROXY_RESULT_EX
{
    uint   cEntries;
    WINHTTP_PROXY_RESULT_ENTRY* pEntries;
    HANDLE hProxyDetectionHandle;
    uint   dwProxyInterfaceAffinity;
}

struct _WinHttpProxyNetworkKey
{
    ubyte[128] pbBuffer;
}

struct WINHTTP_PROXY_SETTINGS
{
    uint     dwStructSize;
    uint     dwFlags;
    uint     dwCurrentSettingsVersion;
    PWSTR    pwszConnectionName;
    PWSTR    pwszProxy;
    PWSTR    pwszProxyBypass;
    PWSTR    pwszAutoconfigUrl;
    PWSTR    pwszAutoconfigSecondaryUrl;
    uint     dwAutoDiscoveryFlags;
    PWSTR    pwszLastKnownGoodAutoConfigUrl;
    uint     dwAutoconfigReloadDelayMins;
    FILETIME ftLastKnownDetectTime;
    uint     dwDetectedInterfaceIpCount;
    uint*    pdwDetectedInterfaceIp;
    uint     cNetworkKeys;
    _WinHttpProxyNetworkKey* pNetworkKeys;
}

///The <b>WINHTTP_CERTIFICATE_INFO</b> structure contains certificate information returned from the server. This
///structure is used by the WinHttpQueryOption function.
struct WINHTTP_CERTIFICATE_INFO
{
    ///A FILETIME structure that contains the date the certificate expires.
    FILETIME ftExpiry;
    ///A FILETIME structure that contains the date the certificate becomes valid.
    FILETIME ftStart;
    ///A pointer to a buffer that contains the name of the organization, site, and server for which the certificate was
    ///issued.
    PWSTR    lpszSubjectInfo;
    ///A pointer to a buffer that contains the name of the organization, site, and server that issued the certificate.
    PWSTR    lpszIssuerInfo;
    ///A pointer to a buffer that contains the name of the protocol used to provide the secure connection. This member
    ///is not current used.
    PWSTR    lpszProtocolName;
    ///A pointer to a buffer that contains the name of the algorithm used to sign the certificate. This member is not
    ///current used.
    PWSTR    lpszSignatureAlgName;
    ///A pointer to a buffer that contains the name of the algorithm used to perform encryption over the secure channel
    ///(SSL/TLS) connection. This member is not current used.
    PWSTR    lpszEncryptionAlgName;
    ///The size, in bytes, of the key.
    uint     dwKeySize;
}

///The <b>WINHTTP_CONNECTION_INFO</b> structure contains the source and destination IP address of the request that
///generated the response.
struct WINHTTP_CONNECTION_INFO
{
align (4):
    ///The size, in bytes, of the <b>WINHTTP_CONNECTION_INFO</b> structure.
    uint                cbSize;
    ///A SOCKADDR_STORAGE structure that contains the local IP address and port of the original request.
    SOCKADDR_STORAGE_LH LocalAddress;
    ///A SOCKADDR_STORAGE structure that contains the remote IP address and port of the original request.
    SOCKADDR_STORAGE_LH RemoteAddress;
}

///The **WINHTTP\_REQUEST\_TIMES** structure contains a variety of timing information for a request.
struct WINHTTP_REQUEST_TIMES
{
align (4):
    ///Unsigned long integer value that contains the number of timings to retrieve. This should generally be set to
    ///**WinHttpRequestTimeLast**.
    uint      cTimes;
    ///Array of unsigned long long integer values that will contain the returned timings, indexed by
    ///[**WINHTTP\_REQUEST\_TIME\_ENTRY**](/windows/desktop/api/winhttp/ne-winhttp-winhttp_request_time_entry). Times
    ///are measured as performance counter values; for more information, see
    ///[QueryPerformanceCounter](/windows/desktop/api/profileapi/nf-profileapi-queryperformancecounter).
    ulong[64] rgullTimes;
}

///The **WINHTTP\_REQUEST\_STATS** structure contains a variety of statistics for a request.
struct WINHTTP_REQUEST_STATS
{
align (4):
    ///Flags containing details on how the request was made. The following flags are available. | Value | Meaning |
    ///|-|-| | WINHTTP_REQUEST_STAT_FLAG_TCP_FAST_OPEN | TCP Fast Open occurred. | |
    ///WINHTTP_REQUEST_STAT_FLAG_TLS_SESSION_RESUMPTION | TLS Session Resumption occurred. | |
    ///WINHTTP_REQUEST_STAT_FLAG_TLS_FALSE_START | TLS False Start occurred. | |
    ///WINHTTP_REQUEST_STAT_FLAG_PROXY_TLS_SESSION_RESUMPTION | TLS Session Resumption occurred for the proxy
    ///connection. | | WINHTTP_REQUEST_STAT_FLAG_PROXY_TLS_FALSE_START | TLS False Start occurred for the proxy
    ///connection. | | WINHTTP_REQUEST_STAT_FLAG_FIRST_REQUEST | This is the first request on the connection. |
    ulong     ullFlags;
    ///The index of the request on the connection. This indicates how many prior requests were sent over the shared
    ///connection.
    uint      ulIndex;
    ///Unsigned long integer value that contains the number of statistics to retrieve. This should generally be set to
    ///**WinHttpRequestStatLast**.
    uint      cStats;
    ///Array of unsigned long long integer values that will contain the returned statistics, indexed by
    ///[**WINHTTP\_REQUEST\_STAT\_ENTRY**](/windows/desktop/api/winhttp/ne-winhttp-winhttp_request_stat_entry).
    ulong[32] rgullStats;
}

struct WINHTTP_EXTENDED_HEADER
{
union
    {
        const(PWSTR) pwszName;
        const(PSTR)  pszName;
    }
union
    {
        const(PWSTR) pwszValue;
        const(PSTR)  pszValue;
    }
}

///The <b>WINHTTP_CREDS</b> structure contains user credential information used for server and proxy authentication.
///<div class="alert"><b>Note</b> This structure has been deprecated. Instead, the use of the WINHTTP_CREDS_EX structure
///is recommended.</div><div> </div>
struct WINHTTP_CREDS
{
    ///Pointer to a buffer that contains username.
    PSTR lpszUserName;
    ///Pointer to a buffer that contains password.
    PSTR lpszPassword;
    ///Pointer to a buffer that contains realm.
    PSTR lpszRealm;
    ///A flag that contains the authentication scheme, as one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_BASIC"></a><a
    ///id="winhttp_auth_scheme_basic"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_BASIC</b></dt> </dl> </td> <td width="60%">
    ///Use basic authentication. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_NTLM"></a><a
    ///id="winhttp_auth_scheme_ntlm"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_NTLM</b></dt> </dl> </td> <td width="60%"> Use
    ///NTLM authentication. </td> </tr> <tr> <td width="40%"><a id="INHTTP_AUTH_SCHEME_DIGEST"></a><a
    ///id="inhttp_auth_scheme_digest"></a><dl> <dt><b>INHTTP_AUTH_SCHEME_DIGEST</b></dt> </dl> </td> <td width="60%">
    ///Use digest authentication. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_NEGOTIATE"></a><a
    ///id="winhttp_auth_scheme_negotiate"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_NEGOTIATE</b></dt> </dl> </td> <td
    ///width="60%"> Select between NTLM and Kerberos authentication. </td> </tr> </table>
    uint dwAuthScheme;
    ///Pointer to a buffer that contains hostname.
    PSTR lpszHostName;
    ///The server connection port.
    uint dwPort;
}

///The <b>WINHTTP_CREDS_EX</b> structure contains user credential information used for server and proxy authentication.
struct WINHTTP_CREDS_EX
{
    ///Pointer to a buffer that contains username.
    PSTR lpszUserName;
    ///Pointer to a buffer that contains password.
    PSTR lpszPassword;
    ///Pointer to a buffer that contains realm.
    PSTR lpszRealm;
    ///A flag that contains the authentication scheme, as one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_BASIC"></a><a
    ///id="winhttp_auth_scheme_basic"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_BASIC</b></dt> </dl> </td> <td width="60%">
    ///Use basic authentication. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_NTLM"></a><a
    ///id="winhttp_auth_scheme_ntlm"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_NTLM</b></dt> </dl> </td> <td width="60%"> Use
    ///NTLM authentication. </td> </tr> <tr> <td width="40%"><a id="INHTTP_AUTH_SCHEME_DIGEST"></a><a
    ///id="inhttp_auth_scheme_digest"></a><dl> <dt><b>INHTTP_AUTH_SCHEME_DIGEST</b></dt> </dl> </td> <td width="60%">
    ///Use digest authentication. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_NEGOTIATE"></a><a
    ///id="winhttp_auth_scheme_negotiate"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_NEGOTIATE</b></dt> </dl> </td> <td
    ///width="60%"> Select between NTLM and Kerberos authentication. </td> </tr> </table>
    uint dwAuthScheme;
    ///Pointer to a buffer that contains hostname.
    PSTR lpszHostName;
    ///The server connection port.
    uint dwPort;
    ///Pointer to a buffer that contains target URL.
    PSTR lpszUrl;
}

///The <b>WINHTTP_CURRENT_USER_IE_PROXY_CONFIG</b> structure contains the Internet Explorer proxy configuration
///information.
struct WINHTTP_CURRENT_USER_IE_PROXY_CONFIG
{
    ///If TRUE, indicates that the Internet Explorer proxy configuration for the current user specifies "automatically
    ///detect settings".
    BOOL  fAutoDetect;
    ///Pointer to a null-terminated Unicode string that contains the auto-configuration URL if the Internet Explorer
    ///proxy configuration for the current user specifies "Use automatic proxy configuration".
    PWSTR lpszAutoConfigUrl;
    ///Pointer to a null-terminated Unicode string that contains the proxy URL if the Internet Explorer proxy
    ///configuration for the current user specifies "use a proxy server".
    PWSTR lpszProxy;
    ///Pointer to a null-terminated Unicode string that contains the optional proxy by-pass server list.
    PWSTR lpszProxyBypass;
}

///The <b>WINHTTP_WEB_SOCKET_ASYNC_RESULT</b> includes the result status of a WebSocket operation.
struct WINHTTP_WEB_SOCKET_ASYNC_RESULT
{
    ///Type: <b>WINHTTP_ASYNC_RESULT</b> The result of a WebSocket operation.
    WINHTTP_ASYNC_RESULT AsyncResult;
    ///Type: <b>WINHTTP_WEB_SOCKET_OPERATION</b> The type of WebSocket operation.
    WINHTTP_WEB_SOCKET_OPERATION Operation;
}

///The <b>WINHTTP_WEB_SOCKET_STATUS</b> enumeration includes the status of a WebSocket operation.
struct WINHTTP_WEB_SOCKET_STATUS
{
    ///Type: <b>DWORD</b> The amount of bytes transferred in the operation.
    uint dwBytesTransferred;
    ///Type: <b>WINHTTP_WEB_SOCKET_BUFFER_TYPE</b> The type of data in the buffer.
    WINHTTP_WEB_SOCKET_BUFFER_TYPE eBufferType;
}

// Functions

///The <b>HttpInitialize</b> function initializes the HTTP Server API driver, starts it, if it has not already been
///started, and allocates data structures for the calling application to support response-queue creation and other
///operations. Call this function before calling any other functions in the HTTP Server API.
///Params:
///    Version = HTTP version. This parameter is an HTTPAPI_VERSION structure. For the current version, declare an instance of the
///              structure and set it to the pre-defined value HTTPAPI_VERSION_1 before passing it to <b>HttpInitialize</b>.
///    Flags = Initialization options, which can include one or both of the following values. <table> <tr> <th>Value</th>
///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HTTP_INITIALIZE_CONFIG"></a><a
///            id="http_initialize_config"></a><dl> <dt><b>HTTP_INITIALIZE_CONFIG</b></dt> </dl> </td> <td width="60%"> Perform
///            initialization for applications that use the HTTP configuration functions, HttpSetServiceConfiguration,
///            HttpQueryServiceConfiguration and HttpDeleteServiceConfiguration. </td> </tr> <tr> <td width="40%"><a
///            id="HTTP_INITIALIZE_SERVER"></a><a id="http_initialize_server"></a><dl> <dt><b>HTTP_INITIALIZE_SERVER</b></dt>
///            </dl> </td> <td width="60%"> Perform initialization for applications that use the HTTP Server API. </td> </tr>
///            </table>
///    pReserved = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the
///    following error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The <i>Flags</i> parameter contains an
///    unsupported value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A
///    system error code defined in WinError.h. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpInitialize(HTTPAPI_VERSION Version, uint Flags, void* pReserved);

///The <b>HttpTerminate</b> function cleans up resources used by the HTTP Server API to process calls by an application.
///An application should call <b>HttpTerminate</b> once for every time it called HttpInitialize, with matching flag
///settings.
///Params:
///    Flags = Termination options. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HTTP_INITIALIZE_CONFIG"></a><a
///            id="http_initialize_config"></a><dl> <dt><b>HTTP_INITIALIZE_CONFIG</b></dt> </dl> </td> <td width="60%"> Release
///            all resources used by applications that modify the HTTP configuration. </td> </tr> <tr> <td width="40%"><a
///            id="HTTP_INITIALIZE_SERVER"></a><a id="http_initialize_server"></a><dl> <dt><b>HTTP_INITIALIZE_SERVER</b></dt>
///            </dl> </td> <td width="60%"> Release all resources used by server applications. </td> </tr> </table>
///    pReserved = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is one of the
///    following error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One or more of the supplied parameters is in
///    an unusable form. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A
///    system error code defined in WinError.h. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpTerminate(uint Flags, void* pReserved);

///The <b>HttpCreateHttpHandle</b> function creates an HTTP request queue for the calling application and returns a
///handle to it. Starting with HTTP Server API Version 2.0, applications should call HttpCreateRequestQueue to create
///the request queue; <b>HttpCreateHttpHandle</b> should not be used.
///Params:
///    RequestQueueHandle = A pointer to a variable that receives a handle to the request queue.
///    Reserved = Reserved. This parameter must be zero.
///Returns:
///    If the function succeeds, the return value is <b>NO_ERROR</b>. If the function fails, the return value is one of
///    the following error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_DLL_INIT_FAILED</b></dt> </dl> </td> <td width="60%"> The calling application did not call
///    HttpInitialize before calling this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Other</b></dt> </dl>
///    </td> <td width="60%"> A system error code defined in WinError.h. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpCreateHttpHandle(HANDLE* RequestQueueHandle, uint Reserved);

///The <b>HttpCreateRequestQueue</b> function creates a new request queue or opens an existing request queue. This
///function replaces the HTTP version 1.0 HttpCreateHttpHandle function.
///Params:
///    Version = An HTTPAPI_VERSION structure indicating the request queue version. For version 2.0, declare an instance of the
///              structure and set it to the predefined value HTTPAPI_VERSION_2 before passing it to
///              <b>HttpCreateRequestQueue</b>. The version must be 2.0; <b>HttpCreateRequestQueue</b> does not support version
///              1.0 request queues.
///    Name = The name of the request queue. The length, in bytes, cannot exceed MAX_PATH. The optional name parameter allows
///           other processes to access the request queue by name.
///    SecurityAttributes = A pointer to the SECURITY_ATTRIBUTES structure that contains the access permissions for the request queue. This
///                         parameter must be <b>NULL</b> when opening an existing request queue.
///    Flags = The flags parameter defines the scope of the request queue. This parameter can be one or more of the followng:
///            <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="HTTP_CREATE_REQUEST_QUEUE_FLAG_CONTROLLER"></a><a id="http_create_request_queue_flag_controller"></a><dl>
///            <dt><b>HTTP_CREATE_REQUEST_QUEUE_FLAG_CONTROLLER</b></dt> </dl> </td> <td width="60%"> The handle to the request
///            queue created using this flag cannot be used to perform I/O operations. This flag can be set only when the
///            request queue handle is created. </td> </tr> <tr> <td width="40%"><a
///            id="HTTP_CREATE_REQUEST_QUEUE_FLAG_OPEN_EXISTING"></a><a
///            id="http_create_request_queue_flag_open_existing"></a><dl>
///            <dt><b>HTTP_CREATE_REQUEST_QUEUE_FLAG_OPEN_EXISTING</b></dt> </dl> </td> <td width="60%"> The
///            <b>HTTP_CREATE_REQUEST_QUEUE_FLAG_OPEN_EXISTING</b> flag allows applications to open an existing request queue by
///            name and retrieve the request queue handle. The <i>pName</i> parameter must contain a valid request queue name;
///            it cannot be <b>NULL</b>. </td> </tr> </table>
///    RequestQueueHandle = A pointer to a variable that receives a handle to the request queue. This parameter must contain a valid pointer;
///                         it cannot be <b>NULL</b>.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b> If the function fails, it returns one of the following error
///    codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_REVISION_MISMATCH</b></dt> </dl> </td> <td width="60%"> The <i>Version</i> parameter contains an
///    invalid version. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> The length, in bytes, of the request queue name cannot exceed MAX_PATH. The
///    <i>pSecurityAttributes</i> parameter must be <b>NULL</b> when opening an existing request queue. The
///    <b>HTTP_CREATE_REQUEST_QUEUE_FLAG_CONTROLLER</b> can only be set when the request queue is created. The
///    <b>HTTP_CREATE_REQUEST_QUEUE_FLAG_OPEN_EXISTING</b> can only be set when the application has permission to open
///    an existing request queue. In this case, the <i>pReqQueueHandle</i> parameter must be a valid pointer, and the
///    <i>pName</i> parameter must contain a valid request queue name; it cannot be <b>NULL</b>. The
///    <i>pReqQueueHandle</i> parameter returned by HttpCreateRequestQueue is <b>NULL</b>. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td> <td width="60%"> The <i>pName</i> parameter
///    conflicts with an existing request queue that contains an identical name. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The calling process does not have a permission
///    to open the request queue. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_DLL_INIT_FAILED</b></dt> </dl>
///    </td> <td width="60%"> The application has not called HttpInitialize prior to calling HttpCreateRequestQueue.
///    </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpCreateRequestQueue(HTTPAPI_VERSION Version, const(PWSTR) Name, SECURITY_ATTRIBUTES* SecurityAttributes, 
                            uint Flags, HANDLE* RequestQueueHandle);

///The <b>HttpCloseRequestQueue</b> function closes the handle to the specified request queue created by
///HttpCreateRequestQueue. The application must close the request queue when it is no longer required.
///Params:
///    RequestQueueHandle = The handle to the request queue that is closed. A request queue is created and its handle returned by a call to
///                         the HttpCreateRequestQueue function.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b>. If the function fails, it returns one of the following
///    error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The application does not have permission to
///    close the request queue. Only the application that created the request queue can close it. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpCloseRequestQueue(HANDLE RequestQueueHandle);

///The <b>HttpSetRequestQueueProperty</b> function sets a new property or modifies an existing property on the request
///queue identified by the specified handle.
///Params:
///    RequestQueueHandle = The handle to the request queue on which the property is set. A request queue is created and its handle returned
///                         by a call to the HttpCreateRequestQueue function.
///    Property = A member of the HTTP_SERVER_PROPERTY enumeration describing the property type that is set. This must be one of
///               the following: <table> <tr> <th>Property</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="HttpServer503VerbosityProperty"></a><a id="httpserver503verbosityproperty"></a><a
///               id="HTTPSERVER503VERBOSITYPROPERTY"></a><dl> <dt><b>HttpServer503VerbosityProperty</b></dt> </dl> </td> <td
///               width="60%"> Modifies or sets the current verbosity level of 503 responses generated for the request queue. </td>
///               </tr> <tr> <td width="40%"><a id="HttpServerQueueLengthProperty"></a><a id="httpserverqueuelengthproperty"></a><a
///               id="HTTPSERVERQUEUELENGTHPROPERTY"></a><dl> <dt><b>HttpServerQueueLengthProperty</b></dt> </dl> </td> <td
///               width="60%"> Modifies or sets the limit on the number of outstanding requests in the request queue. </td> </tr>
///               <tr> <td width="40%"><a id="HttpServerStateProperty"></a><a id="httpserverstateproperty"></a><a
///               id="HTTPSERVERSTATEPROPERTY"></a><dl> <dt><b>HttpServerStateProperty</b></dt> </dl> </td> <td width="60%">
///               Modifies or sets the state of the request queue. The state must be either active or inactive. </td> </tr>
///               </table>
///    PropertyInformation = A pointer to the buffer that contains the property information. <i>pPropertyInformation</i> points to one of the
///                          following property information types based on the property that is set.<table> <tr> <th>Property</th> <th>
///                          Configuration Type</th> </tr> <tr> <td>HttpServerStateProperty</td> <td> HTTP_ENABLED_STATE enumeration</td>
///                          </tr> <tr> <td>HttpServerQueueLengthProperty</td> <td>ULONG</td> </tr> <tr>
///                          <td>HttpServer503VerbosityProperty</td> <td> HTTP_503_RESPONSE_VERBOSITY enumeration</td> </tr> </table>
///    PropertyInformationLength = The length, in bytes, of the buffer pointed to by the <i>pPropertyInformation</i> parameter.
///    Reserved1 = Reserved. Must be zero.
///    Reserved2 = Reserved. Must be <b>NULL</b>.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b>. If the function fails, it returns one of the following
///    error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The <i>Reserved</i> parameter is not zero or
///    the <i>pReserved</i> parameter is not <b>NULL</b>. The property type specified in the <i>Property</i> parameter
///    is not supported for request queues. The <i>pPropertyInformation</i> parameter is <b>NULL</b>. The
///    <i>PropertyInformationLength</i> parameter is zero. The application does not have permission to set properties on
///    the request queue. Only the application that created the request queue can set the properties. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_NOT_SUPPORTED</b></dt> </dl> </td> <td width="60%"> The handle to the request
///    queue is an HTTP version 1.0 handle. Property management is only supported on HTTP version 2.0 or later request
///    queues. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpSetRequestQueueProperty(HANDLE RequestQueueHandle, HTTP_SERVER_PROPERTY Property, 
                                 void* PropertyInformation, uint PropertyInformationLength, uint Reserved1, 
                                 void* Reserved2);

///The <b>HttpQueryRequestQueueProperty</b> function queries a property of the request queue identified by the specified
///handle.
///Params:
///    RequestQueueProperty = The handle to the request queue for which the property setting is returned. A request queue is created and its
///                           handle returned by a call to the HttpCreateRequestQueue function.
///    Property = A member of the HTTP_SERVER_PROPERTY enumeration that describes the property type that is set. This can be one of
///               the following: <table> <tr> <th>Property</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="HttpServer503VerbosityProperty"></a><a id="httpserver503verbosityproperty"></a><a
///               id="HTTPSERVER503VERBOSITYPROPERTY"></a><dl> <dt><b>HttpServer503VerbosityProperty</b></dt> </dl> </td> <td
///               width="60%"> Queries the current verbosity level of 503 responses generated for the requests queue. </td> </tr>
///               <tr> <td width="40%"><a id="HttpServerQueueLengthProperty"></a><a id="httpserverqueuelengthproperty"></a><a
///               id="HTTPSERVERQUEUELENGTHPROPERTY"></a><dl> <dt><b>HttpServerQueueLengthProperty</b></dt> </dl> </td> <td
///               width="60%"> Queries the limit on the number of outstanding requests in the request queue. </td> </tr> <tr> <td
///               width="40%"><a id="HttpServerStateProperty"></a><a id="httpserverstateproperty"></a><a
///               id="HTTPSERVERSTATEPROPERTY"></a><dl> <dt><b>HttpServerStateProperty</b></dt> </dl> </td> <td width="60%">
///               Queries the current state of the request queue. The state must be either active or inactive. </td> </tr> </table>
///    PropertyInformation = A pointer to the buffer that receives the property information. <i>pPropertyInformation</i> points to one of the
///                          following property information values based on the property that is set.<table> <tr> <th>Property</th>
///                          <th>Value</th> </tr> <tr> <td>HttpServerStateProperty</td> <td> HTTP_ENABLED_STATE (enumeration member)</td>
///                          </tr> <tr> <td>HttpServerQueueLengthProperty</td> <td>ULONG</td> </tr> <tr>
///                          <td>HttpServer503VerbosityProperty</td> <td> HTTP_503_RESPONSE_VERBOSITY (enumeration member)</td> </tr> </table>
///    PropertyInformationLength = The length, in bytes, of the buffer pointed to by the <i>pPropertyInformation</i> parameter.
///    Reserved1 = Reserved. Must be zero.
///    ReturnLength = The number, in bytes, returned in the <i>pPropertyInformation</i> buffer if not <b>NULL</b>. If the output buffer
///                   is too small, the call fails with a return value of <b>ERROR_MORE_DATA</b>. The value pointed to by
///                   <i>pReturnLength</i> can be used to determine the minimum length of the buffer required for the call to succeed.
///    Reserved2 = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b>. If the function fails, it returns one of the following
///    error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The <i>Reserved</i> parameter is not zero or
///    the <i>pReserved</i> parameter is not <b>NULL</b>. The property type specified in the <i>Property</i> parameter
///    is not supported on request queues. The <i>pPropertyInformation</i> parameter is <b>NULL</b>. The
///    <i>PropertyInformationLength</i> parameter is zero. The application does not have permission to open the request
///    queue. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The
///    size, in bytes, of the buffer pointed to by the <i>pPropertyInformation</i> parameter is too small to receive the
///    property information. Call the function again with a buffer at least as large as the size pointed to by
///    <i>pReturnLength</i> on exit. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_SUPPORTED</b></dt> </dl>
///    </td> <td width="60%"> The handle to the request queue is an HTTP version 1.0 handle. Property management is only
///    supported for HTTP version 2.0 and later request queues. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpQueryRequestQueueProperty(HANDLE RequestQueueHandle, HTTP_SERVER_PROPERTY Property, 
                                   void* PropertyInformation, uint PropertyInformationLength, uint Reserved1, 
                                   uint* ReturnLength, void* Reserved2);

///The <b>HttpShutdownRequestQueue</b> function stops queuing requests for the specified request queue process.
///Outstanding calls to HttpReceiveHttpRequest are canceled.
///Params:
///    RequestQueueHandle = The handle to the request queue that is shut down. A request queue is created and its handle returned by a call
///                         to the HttpCreateRequestQueue function.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b> If the function fails, it returns one of the following error
///    codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The <i>ReqQueueHandle</i> parameter does not
///    contain a valid request queue. The application does not have permission to shut down the request queue. </td>
///    </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpShutdownRequestQueue(HANDLE RequestQueueHandle);

///The <b>HttpReceiveClientCertificate</b> function is used by a server application to retrieve a client SSL certificate
///or channel binding token (CBT).
///Params:
///    RequestQueueHandle = A handle to the request queue with which the specified SSL client or CBT is associated. A request queue is
///                         created and its handle returned by a call to the HttpCreateRequestQueue function. <b>Windows Server 2003 with SP1
///                         and Windows XP with SP2: </b>The handle to the request queue is created by the HttpCreateHttpHandle function.
///    ConnectionId = A value that identifies the connection to the client. This value is obtained from the <b>ConnectionId</b> element
///                   of an HTTP_REQUEST structure filled in by the HttpReceiveHttpRequest function.
///    Flags = A value that modifies the behavior of the <b>HttpReceiveClientCertificate</b> function <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HTTP_RECEIVE_SECURE_CHANNEL_TOKEN"></a><a
///            id="http_receive_secure_channel_token"></a><dl> <dt><b>HTTP_RECEIVE_SECURE_CHANNEL_TOKEN</b></dt> <dt>0x1</dt>
///            </dl> </td> <td width="60%"> The <i>pSslClientCertInfo</i> parameter will be populated with CBT data. This value
///            is supported on Windows 7, Windows Server 2008 R2, and later. </td> </tr> </table>
///    SslClientCertInfo = If the <i>Flags</i> parameter is 0, then this parameter points to an HTTP_SSL_CLIENT_CERT_INFO structure into
///                        which the function writes the requested client certificate information. The buffer pointed to by the
///                        <i>pSslClientCertInfo</i> should be sufficiently large enough to hold the <b>HTTP_SSL_CLIENT_CERT_INFO</b>
///                        structure plus the value of the <b>CertEncodedSize</b> member of this structure. If the <i>Flags</i> parameter is
///                        <b>HTTP_RECEIVE_SECURE_CHANNEL_TOKEN</b>, then this parameter points to an HTTP_REQUEST_CHANNEL_BIND_STATUS
///                        structure into which the function writes the requested CBT information. The buffer pointed to by the
///                        <i>pSslClientCertInfo</i> should be sufficiently large enough to hold the <b>HTTP_REQUEST_CHANNEL_BIND_STATUS</b>
///                        structure plus the value of the <b>ChannelTokenSize</b> member of this structure.
///    SslClientCertInfoSize = The size, in bytes, of the buffer pointed to by the <i>pSslClientCertInfo</i> parameter.
///    BytesReceived = An optional pointer to a variable that receives the number of bytes to be written to the structure pointed to by
///                    <i>pSslClientCertInfo</i>. If not used, set it to <b>NULL</b>. When making an asynchronous call using
///                    <i>pOverlapped</i>, set <i>pBytesReceived</i> to <b>NULL</b>. Otherwise, when <i>pOverlapped</i> is set to
///                    <b>NULL</b>, <i>pBytesReceived</i> must contain a valid memory address, and not be set to <b>NULL</b>.
///    Overlapped = For asynchronous calls, set <i>pOverlapped</i> to point to an OVERLAPPED structure, or for synchronous calls, set
///                 it to <b>NULL</b>. A synchronous call blocks until the client certificate is retrieved, whereas an asynchronous
///                 call immediately returns <b>ERROR_IO_PENDING</b> and the calling application then uses GetOverlappedResult or I/O
///                 completion ports to determine when the operation is completed. For more information about using OVERLAPPED
///                 structures for synchronization, see the section Synchronization and Overlapped Input and Output.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>NO_ERROR</b></dt> </dl>
///    </td> <td width="60%"> The function succeeded. All the data has been written into the buffer pointed to by the
///    <i>pSslClientCertInfo</i> parameter. The <i>NumberOfBytesTransferred</i> indicates how many bytes were written
///    into the buffer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_IO_PENDING</b></dt> </dl> </td> <td
///    width="60%"> The function is being used asynchronously. The operation has been initiated and will complete later
///    through normal overlapped I/O completion mechanisms. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One or more of the supplied parameters is
///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt> </dl> </td> <td
///    width="60%"> The buffer pointed to by the <i>pSslClientCertInfo</i> parameter is too small to receive the data
///    and no data was written. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td
///    width="60%"> The buffer pointed to by the <i>pSslClientCertInfo</i> parameter is not large enough to receive all
///    the data. Only the basic structure has been written and only partially populated. When the <i>Flags</i> parameter
///    is 0, the HTTP_SSL_CLIENT_CERT_INFOstructure has been written with the <b>CertEncodedSize</b> member populated.
///    The caller should call the function again with a buffer that is at least the size, in bytes, of the
///    <b>HTTP_SSL_CLIENT_CERT_INFO</b> structure plus the value of the <b>CertEncodedSize</b> member. When the
///    <i>Flags</i> parameter is <b>HTTP_RECEIVE_SECURE_CHANNEL_TOKEN</b>, the HTTP_REQUEST_CHANNEL_BIND_STATUS
///    structure has been written with the <b>ChannelTokenSize</b> member populated. The caller should call the function
///    again with a buffer that is at least the size, in bytes, of the <b>HTTP_REQUEST_CHANNEL_BIND_STATUS</b> plus the
///    value of the <b>ChannelTokenSize</b> member. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The function cannot find the client certificate or
///    CBT. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A system error
///    code defined in the <i>WinError.h</i> header file. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpReceiveClientCertificate(HANDLE RequestQueueHandle, ulong ConnectionId, uint Flags, 
                                  HTTP_SSL_CLIENT_CERT_INFO* SslClientCertInfo, uint SslClientCertInfoSize, 
                                  uint* BytesReceived, OVERLAPPED* Overlapped);

///The <b>HttpCreateServerSession</b> function creates a server session for the specified version.
///Params:
///    Version = An HTTPAPI_VERSION structure that indicates the version of the server session. For version 2.0, declare an
///              instance of the structure and set it to the predefined value <b>HTTPAPI_VERSION_2</b> before passing it to
///              <b>HttpCreateServerSession</b>. The version must be 2.0; <b>HttpCreateServerSession</b> does not support version
///              1.0 request queues.
///    ServerSessionId = A pointer to the variable that receives the ID of the server session.
///    Reserved = Reserved. Must be zero.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b>. If the function fails, it returns one of the following
///    error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_REVISION_MISMATCH</b></dt> </dl> </td> <td width="60%"> The version passed is invalid or
///    unsupported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> The <i>pServerSessionId</i> parameter is null or the <i>Reserved</i> is non zero. </td> </tr>
///    </table>
///    
@DllImport("HTTPAPI")
uint HttpCreateServerSession(HTTPAPI_VERSION Version, ulong* ServerSessionId, uint Reserved);

///The <b>HttpCloseServerSession</b> function deletes the server session identified by the server session ID. All
///remaining URL Groups associated with the server session will also be closed.
///Params:
///    ServerSessionId = The ID of the server session that is closed.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b> If the function fails, it can return one of the following
///    error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The Server Session does not exist. The
///    application does not have permission to close the server session. Only the application that created the server
///    session can close the session. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpCloseServerSession(ulong ServerSessionId);

///The <b>HttpQueryServerSessionProperty</b> function queries a server property on the specified server session.
///Params:
///    ServerSessionId = The server session for which the property setting is returned.
///    Property = A member of the HTTP_SERVER_PROPERTY enumeration that describes the property type that is queried. This can be
///               one of the following. <table> <tr> <th>Property</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="HttpServerStateProperty"></a><a id="httpserverstateproperty"></a><a id="HTTPSERVERSTATEPROPERTY"></a><dl>
///               <dt><b>HttpServerStateProperty</b></dt> </dl> </td> <td width="60%"> Queries the current state of the server
///               session. </td> </tr> <tr> <td width="40%"><a id="HttpServerTimeoutsProperty"></a><a
///               id="httpservertimeoutsproperty"></a><a id="HTTPSERVERTIMEOUTSPROPERTY"></a><dl>
///               <dt><b>HttpServerTimeoutsProperty</b></dt> </dl> </td> <td width="60%"> Queries the server session connection
///               timeout limits. </td> </tr> <tr> <td width="40%"><a id="HttpServerQosProperty"></a><a
///               id="httpserverqosproperty"></a><a id="HTTPSERVERQOSPROPERTY"></a><dl> <dt><b>HttpServerQosProperty</b></dt> </dl>
///               </td> <td width="60%"> Queries the bandwidth throttling for the server session. By default, the HTTP Server API
///               does not limit bandwidth. </td> </tr> <tr> <td width="40%"><a id="HttpServerAuthenticationProperty"></a><a
///               id="httpserverauthenticationproperty"></a><a id="HTTPSERVERAUTHENTICATIONPROPERTY"></a><dl>
///               <dt><b>HttpServerAuthenticationProperty</b></dt> </dl> </td> <td width="60%"> Queries kernel mode server-side
///               authentication for the Basic, NTLM, Negotiate, and Digest authentication schemes. </td> </tr> <tr> <td
///               width="40%"><a id="HttpServerChannelBindProperty"></a><a id="httpserverchannelbindproperty"></a><a
///               id="HTTPSERVERCHANNELBINDPROPERTY"></a><dl> <dt><b>HttpServerChannelBindProperty</b></dt> </dl> </td> <td
///               width="60%"> Queries the channel binding token (CBT) properties. </td> </tr> </table>
///    PropertyInformation = A pointer to the buffer that receives the property data. <i>pPropertyInformation</i> points to one of the
///                          following property data structures based on the property that is set.<table> <tr> <th>Property</th>
///                          <th>Structure</th> </tr> <tr> <td>HttpServerStateProperty</td> <td> HTTP_STATE_INFO </td> </tr> <tr>
///                          <td>HttpServerQosProperty</td> <td> HTTP_QOS_SETTING_INFO </td> </tr> <tr> <td>HttpServerTimeoutsProperty</td>
///                          <td> HTTP_TIMEOUT_LIMIT_INFO </td> </tr> <tr> <td>HttpServerAuthenticationProperty</td> <td>
///                          HTTP_SERVER_AUTHENTICATION_INFO </td> </tr> <tr> <td>HttpServerChannelBindProperty</td> <td>
///                          HTTP_CHANNEL_BIND_INFO </td> </tr> </table>
///    PropertyInformationLength = The length, in bytes, of the buffer pointed to by the <i>pPropertyInformation</i> parameter.
///    ReturnLength = The number, in bytes, returned in the <i>pPropertyInformation</i> buffer. If the output buffer is too small, the
///                   call fails with a return value of <b>ERROR_MORE_DATA</b>. The value pointed to by <i>pReturnLength</i> can be
///                   used to determine the minimum length of the buffer required for the call to succeed.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b> If the function fails, it returns one of the following error
///    codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The property type specified in the
///    <i>Property</i> parameter is not supported for server sessions. The <i>ServerSessionId</i> parameter does not
///    contain a valid server session. The <i>pPropertyInformation</i> parameter is <b>NULL</b>. The
///    <i>PropertyInformationLength</i> parameter is zero. The application does not have permission to query the server
///    session properties. Only the application that created the server session can query the properties. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The size, in bytes, of
///    the buffer pointed to by the <i>pPropertyInformation</i> parameter is too small to receive the property data. On
///    exit call the function again with a buffer at least as large as the size pointed to by <i>pReturnLength</i> on
///    exit. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpQueryServerSessionProperty(ulong ServerSessionId, HTTP_SERVER_PROPERTY Property, 
                                    void* PropertyInformation, uint PropertyInformationLength, uint* ReturnLength);

///The <b>HttpSetServerSessionProperty</b> function sets a new server session property or modifies an existing property
///on the specified server session.
///Params:
///    ServerSessionId = The server session for which the property is set.
///    Property = A member of the HTTP_SERVER_PROPERTY enumeration that describes the property type that is set. This can be one of
///               the following. <table> <tr> <th>Property</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="HttpServerStateProperty"></a><a id="httpserverstateproperty"></a><a id="HTTPSERVERSTATEPROPERTY"></a><dl>
///               <dt><b>HttpServerStateProperty</b></dt> </dl> </td> <td width="60%"> Modifies or sets the state of the server
///               session. The state can be either enabled or disabled; the default state is enabled. </td> </tr> <tr> <td
///               width="40%"><a id="HttpServerTimeoutsProperty"></a><a id="httpservertimeoutsproperty"></a><a
///               id="HTTPSERVERTIMEOUTSPROPERTY"></a><dl> <dt><b>HttpServerTimeoutsProperty</b></dt> </dl> </td> <td width="60%">
///               Modifies or sets the server session connection timeout limits. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerQosProperty"></a><a id="httpserverqosproperty"></a><a id="HTTPSERVERQOSPROPERTY"></a><dl>
///               <dt><b>HttpServerQosProperty</b></dt> </dl> </td> <td width="60%"> Modifies or sets the bandwidth throttling for
///               the server session. By default, the HTTP Server API does not limit bandwidth. <div class="alert"><b>Note</b> This
///               value maps to the generic HTTP_QOS_SETTING_INFO structure with <b>QosType</b> set to
///               <b>HttpQosSettingTypeBandwidth</b>. </div> <div> </div> </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerLoggingProperty"></a><a id="httpserverloggingproperty"></a><a
///               id="HTTPSERVERLOGGINGPROPERTY"></a><dl> <dt><b>HttpServerLoggingProperty</b></dt> </dl> </td> <td width="60%">
///               Enables or disables logging for the server session. This property sets only centralized W3C and centralized
///               binary logging. By default, logging is not enabled. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerAuthenticationProperty"></a><a id="httpserverauthenticationproperty"></a><a
///               id="HTTPSERVERAUTHENTICATIONPROPERTY"></a><dl> <dt><b>HttpServerAuthenticationProperty</b></dt> </dl> </td> <td
///               width="60%"> Enables kernel mode server side authentication for the Basic, NTLM, Negotiate, and Digest
///               authentication schemes. </td> </tr> <tr> <td width="40%"><a id="HttpServerExtendedAuthenticationProperty"></a><a
///               id="httpserverextendedauthenticationproperty"></a><a id="HTTPSERVEREXTENDEDAUTHENTICATIONPROPERTY"></a><dl>
///               <dt><b>HttpServerExtendedAuthenticationProperty</b></dt> </dl> </td> <td width="60%"> Enables kernel mode server
///               side authentication for the Kerberos authentication scheme. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerChannelBindProperty_"></a><a id="httpserverchannelbindproperty_"></a><a
///               id="HTTPSERVERCHANNELBINDPROPERTY_"></a><dl> <dt><b>HttpServerChannelBindProperty </b></dt> </dl> </td> <td
///               width="60%"> Enables server side authentication that uses a channel binding token (CBT). </td> </tr> </table>
///    PropertyInformation = A pointer to the buffer that contains the property data. <i>pPropertyInformation</i> points to a property data
///                          structure, listed in the following table, based on the property that is set.<table> <tr> <th>Property</th>
///                          <th>Structure</th> </tr> <tr> <td>HttpServerStateProperty</td> <td> HTTP_STATE_INFO </td> </tr> <tr>
///                          <td>HttpServerLoggingProperty</td> <td> HTTP_LOGGING_INFO </td> </tr> <tr> <td>HttpServerQosProperty</td> <td>
///                          HTTP_QOS_SETTING_INFO </td> </tr> <tr> <td>HttpServerTimeoutsProperty</td> <td> HTTP_TIMEOUT_LIMIT_INFO </td>
///                          </tr> <tr> <td>HttpServerAuthenticationProperty</td> <td> HTTP_SERVER_AUTHENTICATION_INFO </td> </tr> <tr>
///                          <td>HttpServerExtendedAuthenticationProperty</td> <td> HTTP_SERVER_AUTHENTICATION_INFO </td> </tr> <tr>
///                          <td>HttpServerChannelBindProperty</td> <td> HTTP_CHANNEL_BIND_INFO </td> </tr> </table>
///    PropertyInformationLength = The length, in bytes, of the buffer pointed to by the <i>pPropertyInformation</i> parameter.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b> If the function fails, it returns one of the following error
///    codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The property type specified in the
///    <i>Property</i> parameter is not supported for server sessions. The <i>pPropertyInformation</i> parameter is
///    <b>NULL</b>. The <i>PropertyInformationLength</i> parameter is zero. The <i>ServerSessionId</i> parameter does
///    not contain a valid server session. The application does not have permission to set the server session
///    properties. Only the application that created the server session can set the properties. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpSetServerSessionProperty(ulong ServerSessionId, HTTP_SERVER_PROPERTY Property, void* PropertyInformation, 
                                  uint PropertyInformationLength);

///The <b>HttpAddUrl</b> function registers a given URL so that requests that match it are routed to a specified HTTP
///Server API request queue. An application can register multiple URLs to a single request queue using repeated calls to
///<b>HttpAddUrl</b>. For more information about how HTTP Server API matches request URLs to registered URLs, see
///UrlPrefix Strings. Starting with HTTP Server API Version 2.0, applications should call HttpAddUrlToUrlGroup to
///register a URL; <b>HttpAddUrl</b> should not be used.
///Params:
///    RequestQueueHandle = The handle to the request queue to which requests for the specified URL are to be routed. A request queue is
///                         created and its handle returned by a call to the HttpCreateRequestQueue function. <b>Windows Server 2003 with SP1
///                         and Windows XP with SP2: </b>The handle to the request queue is created by the HttpCreateHttpHandle function.
///    FullyQualifiedUrl = A pointer to a Unicode string that contains a properly formed UrlPrefix string that identifies the URL to be
///                        registered.
///    Reserved = Reserved; must be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is <b>NO_ERROR</b>. If the function fails, the return value is one of
///    the following error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The calling application does not have permission
///    to register the URL. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_DLL_INIT_FAILED</b></dt> </dl> </td> <td
///    width="60%"> The calling application did not call HttpInitialize before calling this function. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One of the parameters
///    are invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td> <td
///    width="60%"> The specified UrlPrefix conflicts with an existing registration. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient resources to complete the
///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A system
///    error code defined in WinError.h. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpAddUrl(HANDLE RequestQueueHandle, const(PWSTR) FullyQualifiedUrl, void* Reserved);

///The <b>HttpRemoveUrl</b> function causes the system to stop routing requests that match a specified UrlPrefix string
///to a specified request queue. Starting with HTTP Server API Version 2.0, applications should call
///HttpRemoveUrlFromUrlGroup to register a URL; <b>HttpRemoveUrl</b> should not be used.
///Params:
///    RequestQueueHandle = The handle to the request queue from which the URL registration is to be removed. A request queue is created and
///                         its handle returned by a call to the HttpCreateRequestQueue function. <b>Windows Server 2003 with SP1 and Windows
///                         XP with SP2: </b>The handle to the request queue is created by the HttpCreateHttpHandle function.
///    FullyQualifiedUrl = A pointer to a UrlPrefix string registered to the specified request queue. This string must be identical to the
///                        one passed to HttpAddUrl to register the UrlPrefix; even a nomenclature change in an IPv6 address is not
///                        accepted.
///Returns:
///    If the function succeeds, the return value is <b>NO_ERROR</b>. If the function fails, the return value is one of
///    the following error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The calling application does not have permission
///    to remove the URL. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> One or more of the supplied parameters is in an unusable form. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient resources to complete the
///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td
///    width="60%"> The specified UrlPrefix could not be found in the registration database. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A system error code defined in WinError.h.
///    </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpRemoveUrl(HANDLE RequestQueueHandle, const(PWSTR) FullyQualifiedUrl);

///The <b>HttpCreateUrlGroup</b> function creates a URL Group under the specified server session.
///Params:
///    ServerSessionId = The identifier of the server session under which the URL Group is created.
///    pUrlGroupId = A pointer to the variable that receives the ID of the URL Group.
///    Reserved = Reserved. Must be zero.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b> If the function fails, it returns one of the following error
///    codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The <i>ServerSessionId</i> parameter
///    indicates a non-existing Server Session. The <i>pUrlGroupId</i> parameter is null. The <i>Reserved</i> parameter
///    is non-zero. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpCreateUrlGroup(ulong ServerSessionId, ulong* pUrlGroupId, uint Reserved);

///The <b>HttpCloseUrlGroup</b> function closes the URL Group identified by the URL Group ID. This call also removes all
///of the URLs that are associated with the URL Group.
///Params:
///    UrlGroupId = The ID of the URL Group that is deleted.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b>. If the function fails, it returns one of the following
///    error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The ID of the URL Group does not exist. The
///    application does not have permission to close the URL Group. Only the application that created the URL Group can
///    close the group. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpCloseUrlGroup(ulong UrlGroupId);

///The <b>HttpAddUrlToUrlGroup</b> function adds the specified URL to the URL Group identified by the URL Group ID. This
///function replaces the HTTP version 1.0 HttpAddUrl function.
///Params:
///    UrlGroupId = The group ID for the URL group to which requests for the specified URL are routed. The URL group is created by
///                 the HttpCreateUrlGroup function.
///    pFullyQualifiedUrl = A pointer to a Unicode string that contains a properly formed UrlPrefix String that identifies the URL to be
///                         registered.
///    UrlContext = The context that is associated with the URL registered in this call. The URL context is returned in the
///                 HTTP_REQUEST structure with every request received on the URL specified in the <i>pFullyQualifiedUrl</i>
///                 parameter.
///    Reserved = Reserved. Must be zero.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b> If the function fails, it returns one of the following error
///    codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The <i>UrlGroupId</i> does not exist. The
///    <i>Reserved</i> parameter is not zero. The application does not have permission to add URLs to the Group. Only
///    the application that created the URL Group can add URLs. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The calling process does not have permission to
///    register the URL. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td> <td
///    width="60%"> The specified URL conflicts with an existing registration. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpAddUrlToUrlGroup(ulong UrlGroupId, const(PWSTR) pFullyQualifiedUrl, ulong UrlContext, uint Reserved);

///The <b>HttpRemoveUrlFromUrlGroup</b> function removes the specified URL from the group identified by the URL Group
///ID. This function removes one, or all, of the URLs from the group. This function replaces the HTTP version 1.0
///HttpRemoveUrl function.
///Params:
///    UrlGroupId = The ID of the URL group from which the URL specified in <i>pFullyQualifiedUrl</i> is removed.
///    pFullyQualifiedUrl = A pointer to a Unicode string that contains a properly formed UrlPrefix String that identifies the URL to be
///                         removed. When <b>HTTP_URL_FLAG_REMOVE_ALL</b> is passed in the <i>Flags</i> parameter, all of the existing URL
///                         registrations for the URL Group identified in <i>UrlGroupId</i> are removed from the group. In this case,
///                         <i>pFullyQualifiedUrl</i> must be <b>NULL</b>.
///    Flags = The URL flags qualifying the URL that is removed. This can be one of the following flags: <table> <tr> <th>URL
///            Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HTTP_URL_FLAG_REMOVE_ALL"></a><a
///            id="http_url_flag_remove_all"></a><dl> <dt><b>HTTP_URL_FLAG_REMOVE_ALL</b></dt> </dl> </td> <td width="60%">
///            Removes all of the URLs currently registered with the URL Group. </td> </tr> </table>
///Returns:
///    If the function succeeds, it returns NO_ERROR. If the function fails, it returns one of the following error
///    codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The URL Group does not exist. The Flags
///    parameter contains an invalid combination of flags. The HTTP_URL_FLAG_REMOVE_ALL flag was set and the
///    <i>pFullyQualifiedUrl</i> parameter was not set to <b>NULL</b>. The application does not have permission to
///    remove URLs from the Group. Only the application that created the URL Group can remove URLs. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The calling process does not
///    have permission to deregister the URL. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified URL is not registered with the
///    URL Group. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpRemoveUrlFromUrlGroup(ulong UrlGroupId, const(PWSTR) pFullyQualifiedUrl, uint Flags);

///The <b>HttpSetUrlGroupProperty</b> function sets a new property or modifies an existing property on the specified URL
///Group.
///Params:
///    UrlGroupId = The ID of the URL Group for which the property is set.
///    Property = A member of the HTTP_SERVER_PROPERTY enumeration that describes the property type that is modified or set. This
///               can be one of the following: <table> <tr> <th>Property</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="HttpServerAuthenticationProperty"></a><a id="httpserverauthenticationproperty"></a><a
///               id="HTTPSERVERAUTHENTICATIONPROPERTY"></a><dl> <dt><b>HttpServerAuthenticationProperty</b></dt> </dl> </td> <td
///               width="60%"> Enables server-side authentication for the URL Group using the Basic, NTLM, Negotiate, and Digest
///               authentication schemes. </td> </tr> <tr> <td width="40%"><a id="HttpServerExtendedAuthenticationProperty"></a><a
///               id="httpserverextendedauthenticationproperty"></a><a id="HTTPSERVEREXTENDEDAUTHENTICATIONPROPERTY"></a><dl>
///               <dt><b>HttpServerExtendedAuthenticationProperty</b></dt> </dl> </td> <td width="60%"> Enables server-side
///               authentication for the URL Group using the Kerberos authentication scheme. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerQosProperty"></a><a id="httpserverqosproperty"></a><a id="HTTPSERVERQOSPROPERTY"></a><dl>
///               <dt><b>HttpServerQosProperty</b></dt> </dl> </td> <td width="60%"> This value maps to the generic
///               HTTP_QOS_SETTING_INFO structure with <b>QosType</b> set to either <b>HttpQosSettingTypeBandwidth</b> or
///               <b>HttpQosSettingTypeConnectionLimit</b>. If <b>HttpQosSettingTypeBandwidth</b>, modifies or sets the bandwidth
///               throttling for the URL Group. If <b>HttpQosSettingTypeConnectionLimit</b>, modifies or sets the maximum number of
///               outstanding connections served for a URL Group at any time. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerBindingProperty"></a><a id="httpserverbindingproperty"></a><a
///               id="HTTPSERVERBINDINGPROPERTY"></a><dl> <dt><b>HttpServerBindingProperty</b></dt> </dl> </td> <td width="60%">
///               Modifies or sets the URL Group association with a request queue. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerLoggingProperty"></a><a id="httpserverloggingproperty"></a><a
///               id="HTTPSERVERLOGGINGPROPERTY"></a><dl> <dt><b>HttpServerLoggingProperty</b></dt> </dl> </td> <td width="60%">
///               Modifies or sets logging for the URL Group. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerStateProperty"></a><a id="httpserverstateproperty"></a><a id="HTTPSERVERSTATEPROPERTY"></a><dl>
///               <dt><b>HttpServerStateProperty</b></dt> </dl> </td> <td width="60%"> Modifies or sets the state of the URL Group.
///               The state can be either enabled or disabled. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerTimeoutsProperty"></a><a id="httpservertimeoutsproperty"></a><a
///               id="HTTPSERVERTIMEOUTSPROPERTY"></a><dl> <dt><b>HttpServerTimeoutsProperty</b></dt> </dl> </td> <td width="60%">
///               Modifies or sets the connection timeout limits for the URL Group. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerChannelBindProperty_"></a><a id="httpserverchannelbindproperty_"></a><a
///               id="HTTPSERVERCHANNELBINDPROPERTY_"></a><dl> <dt><b>HttpServerChannelBindProperty </b></dt> </dl> </td> <td
///               width="60%"> Enables server side authentication that uses a channel binding token (CBT). </td> </tr> </table>
///    PropertyInformation = A pointer to the buffer that contains the property information. <i>pPropertyInformation</i> points to one of the
///                          following property information structures based on the property that is set.<table> <tr> <th>Property</th>
///                          <th>Structure</th> </tr> <tr> <td>HttpServerAuthenticatonProperty</td> <td> HTTP_SERVER_AUTHENTICATION_INFO </td>
///                          </tr> <tr> <td>HttpServerExtendedAuthenticationProperty</td> <td> HTTP_SERVER_AUTHENTICATION_INFO </td> </tr>
///                          <tr> <td>HttpServerQosProperty</td> <td> HTTP_QOS_SETTING_INFO </td> </tr> <tr>
///                          <td>HttpServerBindingProperty</td> <td> HTTP_BINDING_INFO </td> </tr> <tr> <td>HttpServerLoggingProperty</td>
///                          <td> HTTP_LOGGING_INFO </td> </tr> <tr> <td>HttpServerStateProperty</td> <td> HTTP_STATE_INFO </td> </tr> <tr>
///                          <td>HttpServerTimeoutsProperty</td> <td> HTTP_TIMEOUT_LIMIT_INFO </td> </tr> <tr>
///                          <td>HttpServerChannelBindProperty</td> <td> HTTP_CHANNEL_BIND_INFO </td> </tr> </table>
///    PropertyInformationLength = The length, in bytes, of the buffer pointed to by the <i>pPropertyInformation</i> parameter.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b>. If the function fails, it returns one of the following
///    error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The property type specified in the
///    <i>Property</i> parameter is not supported for URL Groups. The <i>pPropertyInformation</i> parameter is
///    <b>NULL</b>. The <i>PropertyInformationLength</i> parameter is zero. The <i>UrlGroupId</i> parameter does not
///    contain a valid server session. The application does not have permission to set the URL Group properties. Only
///    the application that created the URL Group can set the properties. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpSetUrlGroupProperty(ulong UrlGroupId, HTTP_SERVER_PROPERTY Property, void* PropertyInformation, 
                             uint PropertyInformationLength);

///The <b>HttpQueryUrlGroupProperty</b> function queries a property on the specified URL Group.
///Params:
///    UrlGroupId = The ID of the URL Group for which the property setting is returned.
///    Property = A member of the HTTP_SERVER_PROPERTY enumeration that describes the property type that is queried. This can be
///               one of the following: <table> <tr> <th>Property</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="HttpServerAuthenticationProperty"></a><a id="httpserverauthenticationproperty"></a><a
///               id="HTTPSERVERAUTHENTICATIONPROPERTY"></a><dl> <dt><b>HttpServerAuthenticationProperty</b></dt> </dl> </td> <td
///               width="60%"> Queries the enabled server-side authentication schemes. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerTimeoutsProperty"></a><a id="httpservertimeoutsproperty"></a><a
///               id="HTTPSERVERTIMEOUTSPROPERTY"></a><dl> <dt><b>HttpServerTimeoutsProperty</b></dt> </dl> </td> <td width="60%">
///               Queries the URL Group connection timeout limits. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerStateProperty"></a><a id="httpserverstateproperty"></a><a id="HTTPSERVERSTATEPROPERTY"></a><dl>
///               <dt><b>HttpServerStateProperty</b></dt> </dl> </td> <td width="60%"> Queries the current state of the URL Group.
///               The state can be either enabled or disabled. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerQosProperty"></a><a id="httpserverqosproperty"></a><a id="HTTPSERVERQOSPROPERTY"></a><dl>
///               <dt><b>HttpServerQosProperty</b></dt> </dl> </td> <td width="60%"> This value maps to the generic
///               HTTP_QOS_SETTING_INFO structure with <b>QosType</b> set to either <b>HttpQosSettingTypeBandwidth</b> or
///               <b>HttpQosSettingTypeConnectionLimit</b>. If <b>HttpQosSettingTypeBandwidth</b>, queries the bandwidth throttling
///               for the URL Group. If <b>HttpQosSettingTypeConnectionLimit</b>, queries the maximum number of outstanding
///               connections served for a URL group at any time. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServerChannelBindProperty"></a><a id="httpserverchannelbindproperty"></a><a
///               id="HTTPSERVERCHANNELBINDPROPERTY"></a><dl> <dt><b>HttpServerChannelBindProperty</b></dt> </dl> </td> <td
///               width="60%"> Queries the channel binding token (CBT) properties. </td> </tr> </table>
///    PropertyInformation = A pointer to the buffer that receives the property information. <i>pPropertyInformation</i> points to one of the
///                          following property information structures based on the property that is queried.<table> <tr> <th>Property</th>
///                          <th>Structure</th> </tr> <tr> <td>HttpServerStateProperty</td> <td> HTTP_STATE_INFO </td> </tr> <tr>
///                          <td>HttpServerAuthenticationProperty</td> <td> HTTP_SERVER_AUTHENTICATION_INFO </td> </tr> <tr>
///                          <td>HttpServerQosProperty</td> <td> HTTP_QOS_SETTING_INFO </td> </tr> <tr> <td>HttpServerTimeoutsProperty</td>
///                          <td> HTTP_TIMEOUT_LIMIT_INFO </td> </tr> <tr> <td>HttpServerChannelBindProperty</td> <td> HTTP_CHANNEL_BIND_INFO
///                          </td> </tr> </table>
///    PropertyInformationLength = The length, in bytes, of the buffer pointed to by the <i>pPropertyInformation</i> parameter.
///    ReturnLength = The size, in bytes, returned in the <i>pPropertyInformation</i> buffer. If the output buffer is too small, the
///                   call fails with a return value of <b>ERROR_MORE_DATA</b>. The value pointed to by <i>pReturnLength</i> can be
///                   used to determine the minimum length of the buffer required for the call to succeed.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b>. If the function fails, it returns one of the following
///    error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The property type specified in the
///    <i>Property</i> parameter is not supported for URL Groups. The <i>UrlGroupId</i> parameter does not identify a
///    valid server URL Group. The <i>pPropertyInformation</i> parameter is <b>NULL</b>. The
///    <i>PropertyInformationLength</i> parameter is zero. The application does not have permission to query the URL
///    Group properties. Only the application that created the URL Group can query the properties. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The size, in bytes, of the buffer
///    pointed to by the <i>pPropertyInformation</i> parameter is too small to receive the property information. Call
///    the function again with a buffer at least as large as the size pointed to by <i>pReturnLength</i> on exit. </td>
///    </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpQueryUrlGroupProperty(ulong UrlGroupId, HTTP_SERVER_PROPERTY Property, void* PropertyInformation, 
                               uint PropertyInformationLength, uint* ReturnLength);

///The <b>HttpPrepareUrl</b> function parses, analyzes, and normalizes a non-normalized Unicode or punycode URL so it is
///safe and valid to use in other HTTP functions.
///Params:
///    Reserved = Reserved. Must be <b>NULL</b>.
///    Flags = Reserved. Must be zero.
///    Url = A pointer to a string that represents the non-normalized Unicode or punycode URL to prepare.
///    PreparedUrl = On successful output, a pointer to a string that represents the normalized URL. <div class="alert"><b>Note</b>
///                  Free <i>PreparedUrl</i> using HeapFree.</div> <div> </div>
@DllImport("HTTPAPI")
uint HttpPrepareUrl(void* Reserved, uint Flags, const(PWSTR) Url, PWSTR* PreparedUrl);

///The <b>HttpReceiveHttpRequest</b> function retrieves the next available HTTP request from the specified request queue
///either synchronously or asynchronously.
///Params:
///    RequestQueueHandle = A handle to the request queue from which to retrieve the next available request. A request queue is created and
///                         its handle returned by a call to the HttpCreateRequestQueue function. <b>Windows Server 2003 with SP1 and Windows
///                         XP with SP2: </b>The handle to the request queue is created by the HttpCreateHttpHandle function.
///    RequestId = On the first call to retrieve a request, this parameter should be <b>HTTP_NULL_ID</b>. Then, if more than one
///                call is required to retrieve the entire request, <b>HttpReceiveHttpRequest</b> or HttpReceiveRequestEntityBody
///                can be called with <i>RequestID</i> set to the value returned in the <b>RequestId</b> member of the HTTP_REQUEST
///                structure pointed to by <i>pRequestBuffer</i>.
///    Flags = A parameter that can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///            width="40%"><a id="0__zero_"></a><a id="0__ZERO_"></a><dl> <dt><b>0 (zero)</b></dt> </dl> </td> <td width="60%">
///            Only the request headers are retrieved; the entity body is not copied. </td> </tr> <tr> <td width="40%"><a
///            id="HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY"></a><a id="http_receive_request_flag_copy_body"></a><dl>
///            <dt><b>HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY</b></dt> </dl> </td> <td width="60%"> The available entity body is
///            copied along with the request headers. The <b>pEntityChunks</b> member of the HTTP_REQUEST structure points to
///            the entity body. </td> </tr> <tr> <td width="40%"><a id="HTTP_RECEIVE_REQUEST_FLAG_FLUSH_BODY"></a><a
///            id="http_receive_request_flag_flush_body"></a><dl> <dt><b>HTTP_RECEIVE_REQUEST_FLAG_FLUSH_BODY</b></dt> </dl>
///            </td> <td width="60%"> All of the entity bodies are copied along with the request headers. The
///            <b>pEntityChunks</b> member of the HTTP_REQUEST structure points to the entity body. </td> </tr> </table>
///    RequestBuffer = A pointer to a buffer into which the function copies an HTTP_REQUEST structure and entity body for the HTTP
///                    request. <b>HTTP_REQUEST.RequestId</b> contains the identifier for this HTTP request, which the application can
///                    use in subsequent calls HttpReceiveRequestEntityBody, HttpSendHttpResponse, or HttpSendResponseEntityBody.
///    RequestBufferLength = Size, in bytes, of the <i>pRequestBuffer</i> buffer.
///    BytesReturned = Optional. A pointer to a variable that receives the size, in bytes, of the entity body, or of the remaining part
///                    of the entity body. When making an asynchronous call using <i>pOverlapped</i>, set <i>pBytesReceived</i> to
///                    <b>NULL</b>. Otherwise, when <i>pOverlapped</i> is set to <b>NULL</b>, <i>pBytesReceived</i> must contain a valid
///                    memory address, and not be set to <b>NULL</b>.
///    Overlapped = For asynchronous calls, set <i>pOverlapped</i> to point to an OVERLAPPED structure; for synchronous calls, set it
///                 to <b>NULL</b>. A synchronous call blocks until a request has arrived in the specified queue and some or all of
///                 it has been retrieved, whereas an asynchronous call immediately returns <b>ERROR_IO_PENDING</b> and the calling
///                 application then uses GetOverlappedResult or I/O completion ports to determine when the operation is completed.
///                 For more information about using OVERLAPPED structures for synchronization, see Synchronization and Overlapped
///                 Input and Output.
///Returns:
///    If the function succeeds, the return value is <b>NO_ERROR</b>. If the function is being used asynchronously, a
///    return value of <b>ERROR_IO_PENDING</b> indicates that the next request is not yet ready and will be retrieved
///    later through normal overlapped I/O completion mechanisms. If the function fails, the return value is one of the
///    following error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One or more of the supplied parameters is in
///    an unusable form. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOACCESS</b></dt> </dl> </td> <td
///    width="60%"> One or more of the supplied parameters points to an invalid or unaligned memory buffer. The
///    <i>pRequestBuffer</i> parameter must point to a valid memory buffer with a memory alignment equal or greater to
///    the memory alignment requirement for an <b>HTTP_REQUEST</b> structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The value of <i>RequestBufferLength</i> is greater
///    than or equal to the size of the request header received, but is not as large as the combined size of the request
///    structure and entity body. The buffer size required to read the remaining part of the entity body is returned in
///    the <i>pBytesReceived</i> parameter if this is non-<b>NULL</b> and if the call is synchronous. Call the function
///    again with a large enough buffer to retrieve all data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_HANDLE_EOF</b></dt> </dl> </td> <td width="60%"> The specified request has already been completely
///    retrieved; in this case, the value pointed to by <i>pBytesReceived</i> is not meaningful, and
///    <i>pRequestBuffer</i> should not be examined. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Other</b></dt> </dl>
///    </td> <td width="60%"> A system error code defined in WinError.h. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpReceiveHttpRequest(HANDLE RequestQueueHandle, ulong RequestId, uint Flags, HTTP_REQUEST_V2* RequestBuffer, 
                            uint RequestBufferLength, uint* BytesReturned, OVERLAPPED* Overlapped);

///The <b>HttpReceiveRequestEntityBody</b> function receives additional entity body data for a specified HTTP request.
///Params:
///    RequestQueueHandle = The handle to the request queue from which to retrieve the specified entity body data. A request queue is created
///                         and its handle returned by a call to the HttpCreateRequestQueue function. <b>Windows Server 2003 with SP1 and
///                         Windows XP with SP2: </b>The handle to the request queue is created by the HttpCreateHttpHandle function.
///    RequestId = The identifier of the HTTP request that contains the retrieved entity body. This value is returned in the
///                <b>RequestId</b> member of the HTTP_REQUEST structure by a call to the HttpReceiveHttpRequest function. This
///                value cannot be <b>HTTP_NULL_ID</b>.
///    Flags = This parameter can be the following flag value. <b>Windows Server 2003 with SP1 and Windows XP with SP2: </b>This
///            parameter is reserved and must be zero. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///            width="40%"><a id="HTTP_RECEIVE_REQUEST_ENTITY_BODY_FLAG_FILL_BUFFER"></a><a
///            id="http_receive_request_entity_body_flag_fill_buffer"></a><dl>
///            <dt><b>HTTP_RECEIVE_REQUEST_ENTITY_BODY_FLAG_FILL_BUFFER</b></dt> </dl> </td> <td width="60%"> Specifies that the
///            buffer will be filled with one or more entity bodies, unless there are no remaining entity bodies to copy. </td>
///            </tr> </table>
///    EntityBuffer = A pointer to a buffer that receives entity-body data.
///    EntityBufferLength = The size, in bytes, of the buffer pointed to by the <i>pBuffer</i> parameter.
///    BytesReturned = Optional. A pointer to a variables that receives the size, in bytes, of the entity body data returned in the
///                    <i>pBuffer</i> buffer. When making an asynchronous call using <i>pOverlapped</i>, set <i>pBytesReceived</i> to
///                    <b>NULL</b>. Otherwise, when <i>pOverlapped</i> is set to <b>NULL</b>, <i>pBytesReceived</i> must contain a valid
///                    memory address, and not be set to <b>NULL</b>.
///    Overlapped = For asynchronous calls, set <i>pOverlapped</i> to point to an OVERLAPPED structure; for synchronous calls, set it
///                 to <b>NULL</b>. A synchronous call blocks until the entity-body data has been retrieved, whereas an asynchronous
///                 call immediately returns <b>ERROR_IO_PENDING</b> and the calling application then uses GetOverlappedResult or I/O
///                 completion ports to determine when the operation is completed. For more information about using OVERLAPPED
///                 structures for synchronization, see Synchronization and Overlapped Input and Output.
///Returns:
///    If the function succeeds, the return value is <b>NO_ERROR</b>. If the function is used asynchronously, a return
///    value of <b>ERROR_IO_PENDING</b> indicates that the next request is not yet ready and is retrieved later through
///    normal overlapped I/O completion mechanisms. If the function fails, the return value is one of the following
///    error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One or more of the supplied parameters are
///    in an unusable form. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_HANDLE_EOF</b></dt> </dl> </td> <td
///    width="60%"> The specified entity body has already been completely retrieved; in this case, the value pointed to
///    by <i>pBytesReceived</i> is not meaningful, and <i>pBuffer</i> should not be examined. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_DLL_INIT_FAILED</b></dt> </dl> </td> <td width="60%"> The calling application did
///    not call HttpInitialize before calling this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A system error code defined in WinError.h. </td> </tr>
///    </table>
///    
@DllImport("HTTPAPI")
uint HttpReceiveRequestEntityBody(HANDLE RequestQueueHandle, ulong RequestId, uint Flags, void* EntityBuffer, 
                                  uint EntityBufferLength, uint* BytesReturned, OVERLAPPED* Overlapped);

///The <b>HttpSendHttpResponse</b> function sends an HTTP response to the specified HTTP request.
///Params:
///    RequestQueueHandle = A handle to the request queue from which the specified request was retrieved. A request queue is created and its
///                         handle returned by a call to the HttpCreateRequestQueue function. <b>Windows Server 2003 with SP1 and Windows XP
///                         with SP2: </b>The handle to the request queue is created by the HttpCreateHttpHandle function.
///    RequestId = An identifier of the HTTP request to which this response corresponds. This value is returned in the
///                <b>RequestId</b> member of the HTTP_REQUEST structure by a call to the HttpReceiveHttpRequest function. This
///                value cannot be <b>HTTP_NULL_ID</b>.
///    Flags = This parameter can be a combination of some of the following flag values. Those that are mutually exclusive are
///            marked accordingly. <table> <tr> <th>Flags</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="HTTP_SEND_RESPONSE_FLAG_DISCONNECT"></a><a id="http_send_response_flag_disconnect"></a><dl>
///            <dt><b>HTTP_SEND_RESPONSE_FLAG_DISCONNECT</b></dt> </dl> </td> <td width="60%"> The network connection should be
///            disconnected after sending this response, overriding any persistent connection features associated with the
///            version of HTTP in use.<div class="alert"><b>Caution</b> Combining <b>HTTP_SEND_RESPONSE_FLAG_DISCONNECT</b> and
///            <b>HTTP_SEND_RESPONSE_FLAG_MORE_DATA</b> in a single call to the <b>HttpSendHttpResponse</b> function produces
///            undefined results.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a
///            id="HTTP_SEND_RESPONSE_FLAG_MORE_DATA"></a><a id="http_send_response_flag_more_data"></a><dl>
///            <dt><b>HTTP_SEND_RESPONSE_FLAG_MORE_DATA</b></dt> </dl> </td> <td width="60%"> Additional entity body data for
///            this response is sent by the application through one or more subsequent calls to HttpSendResponseEntityBody. The
///            last call sending entity-body data then sets this flag to zero. <div class="alert"><b>Caution</b> Combining
///            <b>HTTP_SEND_RESPONSE_FLAG_DISCONNECT</b> and <b>HTTP_SEND_RESPONSE_FLAG_MORE_DATA</b> in a single call to the
///            <b>HttpSendHttpResponse</b> function produces undefined results.</div> <div> </div> </td> </tr> <tr> <td
///            width="40%"><a id="HTTP_SEND_RESPONSE_FLAG_BUFFER_DATA"></a><a id="http_send_response_flag_buffer_data"></a><dl>
///            <dt><b>HTTP_SEND_RESPONSE_FLAG_BUFFER_DATA</b></dt> </dl> </td> <td width="60%"> This flag enables buffering of
///            data in the kernel on a per-response basis. It should be used by an application doing synchronous I/O or by an
///            application doing asynchronous I/O with no more than one outstanding send at a time. Applications that use
///            asynchronous I/O and that may have more than one send outstanding at a time should not use this flag. When this
///            flag is set, it should also be used consistently in calls to the HttpSendResponseEntityBody function. <b>Windows
///            Server 2003: </b>This flag is not supported. This flag is new for Windows Server 2003 with SP1. </td> </tr> <tr>
///            <td width="40%"><a id="HTTP_SEND_RESPONSE_FLAG_ENABLE_NAGLING"></a><a
///            id="http_send_response_flag_enable_nagling"></a><dl> <dt><b>HTTP_SEND_RESPONSE_FLAG_ENABLE_NAGLING</b></dt> </dl>
///            </td> <td width="60%"> Enables the TCP nagling algorithm for this send only. <b>Windows Server 2003 with SP1 and
///            Windows XP with SP2: </b>This flag is not supported. </td> </tr> <tr> <td width="40%"><a
///            id="HTTP_SEND_RESPONSE_FLAG_PROCESS_RANGES"></a><a id="http_send_response_flag_process_ranges"></a><dl>
///            <dt><b>HTTP_SEND_RESPONSE_FLAG_PROCESS_RANGES</b></dt> </dl> </td> <td width="60%"> Specifies that for a range
///            request, the full response content is passed and the caller wants the HTTP API to process ranges appropriately.
///            <div class="alert"><b>Note</b> This flag is only supported for responses to HTTP <i>GET</i> requests and offers a
///            limited subset of functionality. Applications that require full range processing should perform it in user mode
///            and not rely on HTTP.sys. It's usage is discouraged.</div> <div> </div> Windows Server 2008 R2 and Windows 7 or
///            later. <b>Note</b> This flag is supported. </td> </tr> <tr> <td width="40%"><a
///            id="HTTP_SEND_RESPONSE_FLAG_OPAQUE"></a><a id="http_send_response_flag_opaque"></a><dl>
///            <dt><b>HTTP_SEND_RESPONSE_FLAG_OPAQUE</b></dt> </dl> </td> <td width="60%"> Specifies that the request/response
///            is not HTTP compliant and all subsequent bytes should be treated as entity-body. Applications specify this flag
///            when it is accepting a Web Socket upgrade request and informing HTTP.sys to treat the connection data as opaque
///            data. This flag is only allowed when the <b>StatusCode</b> member of <i>pHttpResponse</i> is <b>101</b>,
///            switching protocols. <b>HttpSendHttpResponse</b> returns <b>ERROR_INVALID_PARAMETER</b> for all other HTTP
///            response types if this flag is used. <b>Windows 8 and later: </b>This flag is supported. </td> </tr> </table>
///    HttpResponse = A pointer to an HTTP_RESPONSE structure that defines the HTTP response.
///    CachePolicy = A pointer to the HTTP_CACHE_POLICY structure used to cache the response. <b>Windows Server 2003 with SP1 and
///                  Windows XP with SP2: </b>This parameter is reserved and must be <b>NULL</b>.
///    BytesSent = Optional. A pointer to a variable that receives the number, in bytes, sent if the function operates
///                synchronously. When making an asynchronous call using <i>pOverlapped</i>, set <i>pBytesSent</i> to <b>NULL</b>.
///                Otherwise, when <i>pOverlapped</i> is set to <b>NULL</b>, <i>pBytesSent</i> must contain a valid memory address
///                and not be set to <b>NULL</b>.
///    Reserved1 = This parameter is reserved and must be <b>NULL</b>.
///    Reserved2 = This parameter is reserved and must be zero.
///    Overlapped = For asynchronous calls, set <i>pOverlapped</i> to point to an OVERLAPPED structure; for synchronous calls, set to
///                 <b>NULL</b>. A synchronous call blocks until all response data specified in the <i>pHttpResponse</i> parameter is
///                 sent, whereas an asynchronous call immediately returns <b>ERROR_IO_PENDING</b> and the calling application then
///                 uses GetOverlappedResult or I/O completion ports to determine when the operation is completed. For more
///                 information about using OVERLAPPED structures for synchronization, see Synchronization and Overlapped Input and
///                 Output.
///    LogData = A pointer to the HTTP_LOG_DATA structure used to log the response. Pass a pointer to the HTTP_LOG_FIELDS_DATA
///              structure and cast it to <b>PHTTP_LOG_DATA</b>. Be aware that even when logging is enabled on a URL Group, or
///              server session, the response will not be logged unless the application supplies the log fields data structure.
///              <b>Windows Server 2003 and Windows XP with SP2: </b>This parameter is reserved and must be <b>NULL</b>.
///              <b>Windows Vista and Windows Server 2008: </b>This parameter is new for Windows Vista, and Windows Server 2008
///Returns:
///    If the function succeeds, the function returns <b>NO_ERROR</b>. If the function is used asynchronously, a return
///    value of <b>ERROR_IO_PENDING</b> indicates that the next request is not yet ready and is retrieved later through
///    normal overlapped I/O completion mechanisms. If the function fails, it returns one of the following error codes.
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One or more of the supplied parameters is in
///    an unusable form. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A
///    system error code defined in WinError.h. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpSendHttpResponse(HANDLE RequestQueueHandle, ulong RequestId, uint Flags, HTTP_RESPONSE_V2* HttpResponse, 
                          HTTP_CACHE_POLICY* CachePolicy, uint* BytesSent, void* Reserved1, uint Reserved2, 
                          OVERLAPPED* Overlapped, HTTP_LOG_DATA* LogData);

///The <b>HttpSendResponseEntityBody</b> function sends entity-body data associated with an HTTP response.
///Params:
///    RequestQueueHandle = A handle to the request queue from which the specified request was retrieved. A request queue is created and its
///                         handle returned by a call to the HttpCreateRequestQueue function. <b>Windows Server 2003 with SP1 and Windows XP
///                         with SP2: </b>The handle to the request queue is created by the HttpCreateHttpHandle function.
///    RequestId = An identifier of the HTTP request to which this response corresponds. This value is returned in the
///                <b>RequestId</b> member of the HTTP_REQUEST structure by a call to the HttpReceiveHttpRequest function. It cannot
///                be <b>HTTP_NULL_ID</b>.
///    Flags = A parameter that can include one of the following mutually exclusive flag values. <table> <tr> <th>Flags</th>
///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HTTP_SEND_RESPONSE_FLAG_DISCONNECT"></a><a
///            id="http_send_response_flag_disconnect"></a><dl> <dt><b>HTTP_SEND_RESPONSE_FLAG_DISCONNECT</b></dt> </dl> </td>
///            <td width="60%"> The network connection should be disconnected after sending this response, overriding any
///            persistent connection features associated with the version of HTTP in use. Applications should use this flag to
///            indicate the end of the entity in cases where neither content length nor chunked encoding is used. </td> </tr>
///            <tr> <td width="40%"><a id="HTTP_SEND_RESPONSE_FLAG_MORE_DATA"></a><a
///            id="http_send_response_flag_more_data"></a><dl> <dt><b>HTTP_SEND_RESPONSE_FLAG_MORE_DATA</b></dt> </dl> </td> <td
///            width="60%"> Additional entity body data for this response is sent by the application through one or more
///            subsequent calls to <b>HttpSendResponseEntityBody</b>. The last call then sets this flag to zero. </td> </tr>
///            <tr> <td width="40%"><a id="HTTP_SEND_RESPONSE_FLAG_BUFFER_DATA"></a><a
///            id="http_send_response_flag_buffer_data"></a><dl> <dt><b>HTTP_SEND_RESPONSE_FLAG_BUFFER_DATA</b></dt> </dl> </td>
///            <td width="60%"> This flag enables buffering of data in the kernel on a per-response basis. It should be used by
///            an application doing synchronous I/O, or by a an application doing asynchronous I/O with no more than one send
///            outstanding at a time. Applications using asynchronous I/O which may have more than one send outstanding at a
///            time should not use this flag. When this flag is set, it should be used consistently in calls to the
///            HttpSendHttpResponse function as well. <b>Windows Server 2003: </b>This flag is not supported. This flag is new
///            for Windows Server 2003 with SP1. </td> </tr> <tr> <td width="40%"><a
///            id="HTTP_SEND_RESPONSE_FLAG_ENABLE_NAGLING"></a><a id="http_send_response_flag_enable_nagling"></a><dl>
///            <dt><b>HTTP_SEND_RESPONSE_FLAG_ENABLE_NAGLING</b></dt> </dl> </td> <td width="60%"> Enables the TCP nagling
///            algorithm for this send only. <b>Windows Vista and later: </b>This flag is not supported. </td> </tr> <tr> <td
///            width="40%"><a id="HTTP_SEND_RESPONSE_FLAG_PROCESS_RANGES"></a><a
///            id="http_send_response_flag_process_ranges"></a><dl> <dt><b>HTTP_SEND_RESPONSE_FLAG_PROCESS_RANGES</b></dt> </dl>
///            </td> <td width="60%"> Specifies that for a range request, the full response content is passed and the caller
///            wants the HTTP API to process ranges appropriately. <div class="alert"><b>Note</b> This flag is only supported
///            for responses to HTTP <i>GET</i> requests and offers a limited subset of functionality. Applications that require
///            full range processing should perform it in user mode and not rely on HTTP.sys. It's usage is discouraged.</div>
///            <div> </div> Windows Server 2008 R2 and Windows 7 or later. <b>Note</b> This flag is supported. </td> </tr> <tr>
///            <td width="40%"><a id="HTTP_SEND_RESPONSE_FLAG_OPAQUE"></a><a id="http_send_response_flag_opaque"></a><dl>
///            <dt><b>HTTP_SEND_RESPONSE_FLAG_OPAQUE</b></dt> </dl> </td> <td width="60%"> Specifies that the request/response
///            is not HTTP compliant and all subsequent bytes should be treated as entity-body. Applications specify this flag
///            when it is accepting a Web Socket upgrade request and informing HTTP.sys to treat the connection data as opaque
///            data. This flag is only allowed when the <b>StatusCode</b> member of <i>pHttpResponse</i> is <b>101</b>,
///            switching protocols. <b>HttpSendResponseEntityBody</b> returns <b>ERROR_INVALID_PARAMETER</b> for all other HTTP
///            response types if this flag is used. <b>Windows 8 and later: </b>This flag is supported. </td> </tr> </table>
///            <div class="alert"><b>Caution</b> Combining both flags in a single call to the HttpSendHttpResponse function
///            produces undefined results.</div> <div> </div>
///    EntityChunkCount = A number of structures in the array pointed to by <i>pEntityChunks</i>. This count cannot exceed 9999.
///    EntityChunks = A pointer to an array of HTTP_DATA_CHUNK structures to be sent as entity-body data.
///    BytesSent = Optional. A pointer to a variable that receives the number, in bytes, sent if the function operates
///                synchronously. When making an asynchronous call using <i>pOverlapped</i>, set <i>pBytesSent</i> to <b>NULL</b>.
///                Otherwise, when <i>pOverlapped</i> is set to <b>NULL</b>, <i>pBytesSent</i> must contain a valid memory address,
///                and not be set to <b>NULL</b>.
///    Reserved1 = This parameter is reserved and must be <b>NULL</b>.
///    Reserved2 = This parameter is reserved and must be zero.
///    Overlapped = For asynchronous calls, set <i>pOverlapped</i> to point to an OVERLAPPED structure; for synchronous calls, set it
///                 to <b>NULL</b>. A synchronous call blocks until all response data specified in the <i>pEntityChunks</i> parameter
///                 is sent, whereas an asynchronous call immediately returns <b>ERROR_IO_PENDING</b> and the calling application
///                 then uses GetOverlappedResult or I/O completion ports to determine when the operation is completed. For more
///                 information about using OVERLAPPED structures for synchronization, see Synchronization and Overlapped Input and
///                 Output.
///    LogData = A pointer to the HTTP_LOG_DATA structure used to log the response. Pass a pointer to the HTTP_LOG_FIELDS_DATA
///              structure and cast it to <b>PHTTP_LOG_DATA</b>. Be aware that even when logging is enabled on a URL Group, or
///              server session, the response will not be logged unless the application supplies the log fields data structure.
///              <b>Windows Server 2003 and Windows XP with SP2: </b>This parameter is reserved and must be <b>NULL</b>.
///              <b>Windows Vista and Windows Server 2008: </b>This parameter is new for Windows Vista, and Windows Server 2008
///Returns:
///    If the function succeeds, the return value is <b>NO_ERROR</b>. If the function is used asynchronously, a return
///    value of <b>ERROR_IO_PENDING</b> indicates that the next request is not yet ready and is retrieved later through
///    normal overlapped I/O completion mechanisms. If the function fails, the return value is one of the following
///    error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One or more of the supplied parameters is in
///    an unusable form. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_COMMAND</b></dt> </dl> </td> <td
///    width="60%"> There is a call pending to HttpSendHttpResponse or HttpSendResponseEntityBody having the same
///    <b>RequestId</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A
///    system error code defined in WinError.h. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpSendResponseEntityBody(HANDLE RequestQueueHandle, ulong RequestId, uint Flags, ushort EntityChunkCount, 
                                HTTP_DATA_CHUNK* EntityChunks, uint* BytesSent, void* Reserved1, uint Reserved2, 
                                OVERLAPPED* Overlapped, HTTP_LOG_DATA* LogData);

///Declares a resource-to-subresource relationship to use for an HTTP server push. HTTP.sys then performs an HTTP 2.0
///server push for the given resource, if the underlying protocol, connection, client, and policies allow the push
///operation.
///Params:
///    RequestQueueHandle = The handle to an HTTP.sys request queue that the HttpCreateRequestQueue function returned.
///    RequestId = The opaque identifier of the request that is declaring the push operation. The request must be from the specified
///                queue handle.
///    Verb = The HTTP verb to use for the push operation. The HTTP.sys push operation only supports <b>HttpVerbGET</b> and
///           <b>HttpVerbHEAD</b>.
///    Path = The path portion of the URL for the resource being pushed.
///    Query = The query portion of the URL for the resource being pushed. This string should not include the leading question
///            mark (?).
///    Headers = The request headers for the push operation. You should not provide a Host header, because HTTP.sys automatically
///              generates the correct Host information. HTTP.sys does not support cross-origin push operations, so HTTP.sys
///              enforces and generates Host information that matches the original client-initiated request. The push request is
///              not allowed to have an entity body, so you cannot include a non-zero Content-Length header or any
///              Transfer-Encoding header.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b>. If the function fails, it returns a system error code
///    defined in WinError.h.
///    
@DllImport("HTTPAPI")
uint HttpDeclarePush(HANDLE RequestQueueHandle, ulong RequestId, HTTP_VERB Verb, const(PWSTR) Path, 
                     const(PSTR) Query, HTTP_REQUEST_HEADERS* Headers);

///The <b>HttpWaitForDisconnect</b> function notifies the application when the connection to an HTTP client is broken
///for any reason.
///Params:
///    RequestQueueHandle = A handle to the request queue that handles requests from the specified connection. A request queue is created and
///                         its handle returned by a call to the HttpCreateRequestQueue function. <b>Windows Server 2003 with SP1 and Windows
///                         XP with SP2: </b>The handle to the request queue is created by the HttpCreateHttpHandle function.
///    ConnectionId = Identifier for the connection to the client computer. This value is returned in the <b>ConnectionID</b> member of
///                   the HTTP_REQUEST structure by a call to the HttpReceiveHttpRequest function.
///    Overlapped = For asynchronous calls, set <i>pOverlapped</i> to point to an OVERLAPPED structure; for synchronous calls, set it
///                 to <b>NULL</b>. A synchronous call blocks until the connection is broken, whereas an asynchronous call
///                 immediately returns ERROR_IO_PENDING and the calling application then uses GetOverlappedResult or I/O completion
///                 ports to determine when the operation is completed. For information about using OVERLAPPED structures for
///                 synchronization, see Synchronization and Overlapped Input and Output.
///Returns:
///    If the function succeeds, the return value is NO_ERROR. If the function is used asynchronously, a return value of
///    ERROR_IO_PENDING indicates that the next request is not yet ready and is retrieved later through normal
///    overlapped I/O completion mechanisms. If the function fails, the return value is one of the following error
///    codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One or more of the supplied parameters is in
///    an unusable form. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A
///    system error code defined in WinError.h. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpWaitForDisconnect(HANDLE RequestQueueHandle, ulong ConnectionId, OVERLAPPED* Overlapped);

///This function is an extension to HttpWaitForDisconnect.<div class="alert"><b>Note</b> Calling this API directly in
///your code is not recommended. Call HttpWaitForDisconnect instead.</div> <div> </div>
///Params:
///    RequestQueueHandle = 
///    ConnectionId = 
///    Reserved = 
///    Overlapped = 
@DllImport("HTTPAPI")
uint HttpWaitForDisconnectEx(HANDLE RequestQueueHandle, ulong ConnectionId, uint Reserved, OVERLAPPED* Overlapped);

///The <b>HttpCancelHttpRequest</b> function cancels a specified request.
///Params:
///    RequestQueueHandle = A handle to the request queue from which the request came.
///    RequestId = The ID of the request to be canceled.
///    Overlapped = For asynchronous calls, set <i>pOverlapped</i> to point to an OVERLAPPED structure; for synchronous calls, set it
///                 to <b>NULL</b>.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b>.
///    
@DllImport("HTTPAPI")
uint HttpCancelHttpRequest(HANDLE RequestQueueHandle, ulong RequestId, OVERLAPPED* Overlapped);

///The <b>HttpWaitForDemandStart</b> function waits for the arrival of a new request that can be served by a new request
///queue process.
///Params:
///    RequestQueueHandle = A handle to the request queue on which demand start is registered. A request queue is created and its handle
///                         returned by a call to the HttpCreateRequestQueue function.
///    Overlapped = For asynchronous calls, set <i>pOverlapped</i> to point to an OVERLAPPED structure; for synchronous calls, set it
///                 to <b>NULL</b>. A synchronous call blocks until a request has arrived in the specified queue, whereas an
///                 asynchronous call immediately returns <b>ERROR_IO_PENDING</b> and the calling application then uses
///                 GetOverlappedResult or I/O completion ports to determine when the operation is completed. For more information
///                 about using OVERLAPPED structures for synchronization, see Synchronization and Overlapped Input and Output.
///Returns:
///    If the function succeeds, it returns <b>NO_ERROR</b>. If the function fails, it returns one of the following
///    error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The <i>ReqQueueHandle</i> parameter does not
///    contain a valid request queue. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_ID_AUTHORITY</b></dt>
///    </dl> </td> <td width="60%"> The calling process is not the controller process for this request queue. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The calling
///    process has already initiated a shutdown on the request queue or has closed the request queue handle. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td> <td width="60%"> A demand start
///    registration already exists for the request queue. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpWaitForDemandStart(HANDLE RequestQueueHandle, OVERLAPPED* Overlapped);

///The <b>HttpFlushResponseCache</b> function removes from the HTTP Server API cache associated with a given request
///queue all response fragments that have a name whose site portion matches a specified UrlPrefix. The application must
///previously have called HttpAddUrl, or HttpAddUrlToUrlGroup to add this UrlPrefix or a valid prefix of it to the
///request queue in question, and then called HttpAddFragmentToCache to cache the associated response fragment or
///fragments.
///Params:
///    RequestQueueHandle = Handle to the request queue with which this cache is associated. A request queue is created and its handle
///                         returned by a call to the HttpCreateRequestQueue function. <b>Windows Server 2003 with SP1 and Windows XP with
///                         SP2: </b>The handle to the request queue is created by the HttpCreateHttpHandle function.
///    UrlPrefix = Pointer to a UrlPrefix string to match against the site portion of fragment names. The application must
///                previously have called HttpAddUrl to add this UrlPrefix or a valid prefix of it to the request queue in question,
///                and then called HttpAddFragmentToCache to cache the associated response fragment.
///    Flags = This parameter can contain the following flag:
///    Overlapped = For asynchronous calls, set <i>pOverlapped</i> to point to an OVERLAPPED structure, or for synchronous calls, set
///                 it to <b>NULL</b>. A synchronous call blocks until the cache operation is complete, whereas an asynchronous call
///                 immediately returns ERROR_IO_PENDING and the calling application then uses GetOverlappedResult or I/O completion
///                 ports to determine when the operation is completed. For more information about using OVERLAPPED structures for
///                 synchronization, see Synchronization and Overlapped Input and Output.
///Returns:
///    If the function succeeds, the return value is NO_ERROR. If the function is used asynchronously, a return value of
///    ERROR_IO_PENDING indicates that the cache request is queued and completes later through normal overlapped I/O
///    completion mechanisms. If the function fails, the return value is one of the following error codes. <table> <tr>
///    <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl>
///    </td> <td width="60%"> One of the parameters are invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A system error code defined in WinError.h. </td> </tr>
///    </table>
///    
@DllImport("HTTPAPI")
uint HttpFlushResponseCache(HANDLE RequestQueueHandle, const(PWSTR) UrlPrefix, uint Flags, OVERLAPPED* Overlapped);

///The <b>HttpAddFragmentToCache</b> function caches a data fragment with a specified name by which it can be retrieved,
///or updates data cached under a specified name. Such cached data fragments can be used repeatedly to construct dynamic
///responses without the expense of disk reads. For example, a response composed of text and three images could be
///assembled dynamically from four or more cached fragments at the time a request is processed.
///Params:
///    RequestQueueHandle = Handle to the request queue with which this cache is associated. A request queue is created and its handle
///                         returned by a call to the HttpCreateRequestQueue function. <b>Windows Server 2003 with SP1 and Windows XP with
///                         SP2: </b>The handle to the request queue is created by the HttpCreateHttpHandle function.
///    UrlPrefix = Pointer to a UrlPrefix string that the application uses in subsequent calls to HttpSendHttpResponse to identify
///                this cache entry. The application must have called <b>HttpAddUrl</b> previously with the same handle as in the
///                <i>ReqQueueHandle</i> parameter, and with either this identical UrlPrefix string or a valid prefix of it. Like
///                any UrlPrefix, this string must take the form "scheme://host:port/relativeURI"; for example,
///                http://www.mysite.com:80/image1.gif.
///    DataChunk = Pointer to an HTTP_DATA_CHUNK structure that specifies an entity body data block to cache under the name pointed
///                to by <i>pUrlPrefix</i>.
///    CachePolicy = Pointer to an HTTP_CACHE_POLICY structure that specifies how this data fragment should be cached.
///    Overlapped = For asynchronous calls, set <i>pOverlapped</i> to point to an OVERLAPPED structure, or for synchronous calls, set
///                 it to <b>NULL</b>. A synchronous call blocks the calling thread until the cache operation is complete, whereas an
///                 asynchronous call immediately returns ERROR_IO_PENDING and the calling application then uses GetOverlappedResult
///                 or I/O completion ports to determine when the operation is completed. For more information about using OVERLAPPED
///                 structures for synchronization, see Synchronization and Overlapped Input and Output.
///Returns:
///    If the function succeeds, the return value is NO_ERROR. If the function is used asynchronously, a return value of
///    ERROR_IO_PENDING indicates that the cache request is queued and will complete later through normal overlapped I/O
///    completion mechanisms. If the function fails, the return value is one of the following error codes. <table> <tr>
///    <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl>
///    </td> <td width="60%"> One or more of the supplied parameters is in an unusable form. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A system error code defined in WinError.h.
///    </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpAddFragmentToCache(HANDLE RequestQueueHandle, const(PWSTR) UrlPrefix, HTTP_DATA_CHUNK* DataChunk, 
                            HTTP_CACHE_POLICY* CachePolicy, OVERLAPPED* Overlapped);

///The <b>HttpReadFragmentFromCache</b> function retrieves a response fragment having a specified name from the HTTP
///Server API cache.
///Params:
///    RequestQueueHandle = Handle to the request queue with which the specified response fragment is associated. A request queue is created
///                         and its handle returned by a call to the HttpCreateRequestQueue function. <b>Windows Server 2003 with SP1 and
///                         Windows XP with SP2: </b>The handle to the request queue is created by the HttpCreateHttpHandle function.
///    UrlPrefix = Pointer to a UrlPrefix string that contains the name of the fragment to be retrieved. This must match a UrlPrefix
///                string used in a previous successful call to HttpAddFragmentToCache.
///    ByteRange = Optional pointer to an HTTP_BYTE_RANGE structure that indicates a starting offset in the specified fragment and
///                byte-count to be returned. <b>NULL</b> if not used, in which case the entire fragment is returned.
///    Buffer = Pointer to a buffer into which the function copies the requested fragment.
///    BufferLength = Size, in bytes, of the <i>pBuffer</i> buffer.
///    BytesRead = Optional pointer to a variable that receives the number of bytes to be written into the output buffer. If
///                <i>BufferLength</i> is less than this number, the call fails with a return of ERROR_INSUFFICIENT_BUFFER, and the
///                value pointed to by <i>pBytesRead</i> can be used to determine the minimum length of buffer required for the call
///                to succeed. When making an asynchronous call using <i>pOverlapped</i>, set <i>pBytesRead</i> to <b>NULL</b>.
///                Otherwise, when <i>pOverlapped</i> is set to <b>NULL</b>, <i>pBytesRead</i> must contain a valid memory address,
///                and not be set to <b>NULL</b>.
///    Overlapped = For asynchronous calls, set <i>pOverlapped</i> to point to an OVERLAPPED structure, or for synchronous calls, set
///                 it to <b>NULL</b>. A synchronous call blocks until the cache operation is complete, whereas an asynchronous call
///                 immediately returns ERROR_IO_PENDING and the calling application then uses GetOverlappedResult or I/O completion
///                 ports to determine when the operation is completed. For more information about using OVERLAPPED structures for
///                 synchronization, see Synchronization and Overlapped Input and Output.
///Returns:
///    If the function succeeds, the return value is NO_ERROR. If the function is used asynchronously, a return value of
///    ERROR_IO_PENDING indicates that the cache request is queued and completes later through normal overlapped I/O
///    completion mechanisms. If the function fails, the return value is one of the following error codes. <table> <tr>
///    <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl>
///    </td> <td width="60%"> One or more of the supplied parameters is in an unusable form. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The buffer pointed to by
///    <i>pBuffer</i> is too small to receive all the requested data; the size of buffer required is pointed to by
///    <i>pBytesRead</i> unless it was <b>NULL</b> or the call was asynchronous. In the case of an asynchronous call,
///    the value pointed to by the <i>lpNumberOfBytesTransferred</i> parameter of the GetOverLappedResult function is
///    set to the buffer size required. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td
///    width="60%"> A system error code defined in WinError.h. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpReadFragmentFromCache(HANDLE RequestQueueHandle, const(PWSTR) UrlPrefix, HTTP_BYTE_RANGE* ByteRange, 
                               void* Buffer, uint BufferLength, uint* BytesRead, OVERLAPPED* Overlapped);

///The <b>HttpSetServiceConfiguration</b> function creates and sets a configuration record for the HTTP Server API
///configuration store. The call fails if the specified record already exists. To change a given configuration record,
///delete it and then recreate it with a different value.
///Params:
///    ServiceHandle = Reserved. Must be zero.
///    ConfigId = Type of configuration record to be set. This parameter can be one of the following values from the
///               HTTP_SERVICE_CONFIG_ID enumeration. <table> <tr> <th><i>ConfigId</i> value</th> <th>Meaning</th> </tr> <tr> <td
///               width="40%"><a id="HttpServiceConfigIPListenList"></a><a id="httpserviceconfigiplistenlist"></a><a
///               id="HTTPSERVICECONFIGIPLISTENLIST"></a><dl> <dt><b>HttpServiceConfigIPListenList</b></dt> </dl> </td> <td
///               width="60%"> Sets a record in the IP Listen List. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigSSLCertInfo"></a><a id="httpserviceconfigsslcertinfo"></a><a
///               id="HTTPSERVICECONFIGSSLCERTINFO"></a><dl> <dt><b>HttpServiceConfigSSLCertInfo</b></dt> </dl> </td> <td
///               width="60%"> Sets a specified SSL certificate record. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigUrlAclInfo"></a><a id="httpserviceconfigurlaclinfo"></a><a
///               id="HTTPSERVICECONFIGURLACLINFO"></a><dl> <dt><b>HttpServiceConfigUrlAclInfo</b></dt> </dl> </td> <td
///               width="60%"> Sets a URL reservation record. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigTimeout"></a><a id="httpserviceconfigtimeout"></a><a id="HTTPSERVICECONFIGTIMEOUT"></a><dl>
///               <dt><b>HttpServiceConfigTimeout</b></dt> </dl> </td> <td width="60%"> Sets a specified HTTP Server API wide
///               connection time-out. <b>Windows Vista and later: </b>This enumeration value is supported. </td> </tr> <tr> <td
///               width="40%"><a id="HttpServiceConfigSslSniCertInfo"></a><a id="httpserviceconfigsslsnicertinfo"></a><a
///               id="HTTPSERVICECONFIGSSLSNICERTINFO"></a><dl> <dt><b>HttpServiceConfigSslSniCertInfo</b></dt> </dl> </td> <td
///               width="60%"> Sets a specified SSL Server Name Indication (SNI) certificate record. <b>Windows 8 and later:
///               </b>This enumeration value is supported. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigSslCcsCertInfo"></a><a id="httpserviceconfigsslccscertinfo"></a><a
///               id="HTTPSERVICECONFIGSSLCCSCERTINFO"></a><dl> <dt><b><b>HttpServiceConfigSslCcsCertInfo</b></b></dt> </dl> </td>
///               <td width="60%"> Sets the SSL certificate record that specifies that Http.sys should consult the Centralized
///               Certificate Store (CCS) store to find certificates if the port receives a Transport Layer Security (TLS)
///               handshake. The port is specified by the <b>KeyDesc</b> member of the HTTP_SERVICE_CONFIG_SSL_CCS_SET structure
///               that you pass to the <i>pConfigInformation</i> parameter. <b>Windows 8 and later: </b>This enumeration value is
///               supported. </td> </tr> </table>
///    pConfigInformation = A pointer to a buffer that contains the appropriate data to specify the type of record to be set. <table> <tr>
///                         <th><i>ConfigId</i> value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                         id="HttpServiceConfigIPListenList"></a><a id="httpserviceconfigiplistenlist"></a><a
///                         id="HTTPSERVICECONFIGIPLISTENLIST"></a><dl> <dt><b>HttpServiceConfigIPListenList</b></dt> </dl> </td> <td
///                         width="60%"> HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM structure. </td> </tr> <tr> <td width="40%"><a
///                         id="HttpServiceConfigSSLCertInfo"></a><a id="httpserviceconfigsslcertinfo"></a><a
///                         id="HTTPSERVICECONFIGSSLCERTINFO"></a><dl> <dt><b>HttpServiceConfigSSLCertInfo</b></dt> </dl> </td> <td
///                         width="60%"> HTTP_SERVICE_CONFIG_SSL_SET structure. </td> </tr> <tr> <td width="40%"><a
///                         id="HttpServiceConfigUrlAclInfo"></a><a id="httpserviceconfigurlaclinfo"></a><a
///                         id="HTTPSERVICECONFIGURLACLINFO"></a><dl> <dt><b>HttpServiceConfigUrlAclInfo</b></dt> </dl> </td> <td
///                         width="60%"> HTTP_SERVICE_CONFIG_URLACL_SET structure. </td> </tr> <tr> <td width="40%"><a
///                         id="HttpServiceConfigTimeout"></a><a id="httpserviceconfigtimeout"></a><a id="HTTPSERVICECONFIGTIMEOUT"></a><dl>
///                         <dt><b>HttpServiceConfigTimeout</b></dt> </dl> </td> <td width="60%"> HTTP_SERVICE_CONFIG_TIMEOUT_SET structure.
///                         <b>Windows Vista and later: </b>This structure is supported. </td> </tr> <tr> <td width="40%"><a
///                         id="HttpServiceConfigSslSniCertInfo"></a><a id="httpserviceconfigsslsnicertinfo"></a><a
///                         id="HTTPSERVICECONFIGSSLSNICERTINFO"></a><dl> <dt><b>HttpServiceConfigSslSniCertInfo</b></dt> </dl> </td> <td
///                         width="60%"> HTTP_SERVICE_CONFIG_SSL_SNI_SET structure. The hostname will be "*" when the SSL central certificate
///                         store is queried and wildcard bindings are used, and a host name for regular SNI. <b>Windows 8 and later:
///                         </b>This structure is supported. </td> </tr> <tr> <td width="40%"><a id="HttpServiceConfigSslCcsCertInfo"></a><a
///                         id="httpserviceconfigsslccscertinfo"></a><a id="HTTPSERVICECONFIGSSLCCSCERTINFO"></a><dl>
///                         <dt><b><b>HttpServiceConfigSslCcsCertInfo</b></b></dt> </dl> </td> <td width="60%">
///                         HTTP_SERVICE_CONFIG_SSL_CCS_SET structure. <b>Windows 8 and later: </b>This structure is supported. </td> </tr>
///                         </table>
///    ConfigInformationLength = Size, in bytes, of the <i>pConfigInformation</i> buffer.
///    pOverlapped = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is <b>NO_ERROR</b>. If the function fails, the return value is one of
///    the following error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td> <td width="60%"> The specified record already exists, and must
///    be deleted in order for its value to be re-set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt> </dl> </td> <td width="60%"> The buffer size specified in the
///    <i>ConfigInformationLength</i> parameter is insufficient. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The <i>ServiceHandle</i> parameter is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One
///    or more of the supplied parameters is in an unusable form. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_SUCH_LOGON_SESSION</b></dt> </dl> </td> <td width="60%"> The SSL Certificate used is invalid.
///    This can occur only if the <i>HttpServiceConfigSSLCertInfo</i> parameter is used. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A system error code defined in WinError.h.
///    </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpSetServiceConfiguration(HANDLE ServiceHandle, HTTP_SERVICE_CONFIG_ID ConfigId, void* pConfigInformation, 
                                 uint ConfigInformationLength, OVERLAPPED* pOverlapped);

///Updates atomically a service configuration parameter that specifies a Transport Layer Security (TLS) certificate in a
///configuration record within the HTTP Server API configuration store.
///Params:
///    Handle = Reserved and must be <b>NULL</b>.
///    ConfigId = The type of configuration record to update. This parameter can be one of the following values from the
///               HTTP_SERVICE_CONFIG_ID enumeration. <table> <tr> <th><i>ConfigId</i> value</th> <th>Meaning</th> </tr> <tr> <td
///               width="40%"><a id="HttpServiceConfigSSLCertInfo"></a><a id="httpserviceconfigsslcertinfo"></a><a
///               id="HTTPSERVICECONFIGSSLCERTINFO"></a><dl> <dt><b>HttpServiceConfigSSLCertInfo</b></dt> </dl> </td> <td
///               width="60%"> Updates a specified SSL certificate record. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigSslSniCertInfo"></a><a id="httpserviceconfigsslsnicertinfo"></a><a
///               id="HTTPSERVICECONFIGSSLSNICERTINFO"></a><dl> <dt><b>HttpServiceConfigSslSniCertInfo</b></dt> </dl> </td> <td
///               width="60%"> Updates a specified SSL Server Name Indication (SNI) certificate record. </td> </tr> <tr> <td
///               width="40%"><a id="HttpServiceConfigSslCcsCertInfo"></a><a id="httpserviceconfigsslccscertinfo"></a><a
///               id="HTTPSERVICECONFIGSSLCCSCERTINFO"></a><dl> <dt><b>HttpServiceConfigSslCcsCertInfo</b></dt> </dl> </td> <td
///               width="60%"> Updates the SSL certificate record that specifies that Http.sys should consult the Centralized
///               Certificate Store (CCS) store to find certificates if the port receives a TLS handshake. The port is specified by
///               the <b>KeyDesc</b> member of the HTTP_SERVICE_CONFIG_SSL_CCS_SET structure that you pass to the
///               <i>pConfigInfo</i> parameter. </td> </tr> </table>
///    ConfigInfo = A pointer to a buffer that contains the appropriate data to specify the type of record to update. The following
///                 table shows the type of data the buffer contains for the different possible values of the <i>ConfigId</i>
///                 parameter. <table> <tr> <th><i>ConfigId</i> value</th> <th>Type of data in the <i>pConfigInfo</i> buffer</th>
///                 </tr> <tr> <td width="40%"><a id="HttpServiceConfigSSLCertInfo"></a><a id="httpserviceconfigsslcertinfo"></a><a
///                 id="HTTPSERVICECONFIGSSLCERTINFO"></a><dl> <dt><b>HttpServiceConfigSSLCertInfo</b></dt> </dl> </td> <td
///                 width="60%"> HTTP_SERVICE_CONFIG_SSL_SET structure. </td> </tr> <tr> <td width="40%"><a
///                 id="HttpServiceConfigSslSniCertInfo"></a><a id="httpserviceconfigsslsnicertinfo"></a><a
///                 id="HTTPSERVICECONFIGSSLSNICERTINFO"></a><dl> <dt><b>HttpServiceConfigSslSniCertInfo</b></dt> </dl> </td> <td
///                 width="60%"> HTTP_SERVICE_CONFIG_SSL_SNI_SET structure. The hostname will be "*" when the SSL central certificate
///                 store is queried and wildcard bindings are used, and a host name for regular SNI. </td> </tr> <tr> <td
///                 width="40%"><a id="HttpServiceConfigSslCcsCertInfo"></a><a id="httpserviceconfigsslccscertinfo"></a><a
///                 id="HTTPSERVICECONFIGSSLCCSCERTINFO"></a><dl> <dt><b><b>HttpServiceConfigSslCcsCertInfo</b></b></dt> </dl> </td>
///                 <td width="60%"> HTTP_SERVICE_CONFIG_SSL_CCS_SET structure. This structure is used to add the CCS store on the
///                 specified port, as well as to delete, retrieve, or update an existing SSL CCS record. </td> </tr> </table>
///    ConfigInfoLength = The size, in bytes, of the <i>ConfigInfo</i> buffer.
///    Overlapped = Reserved and must be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. If the function fails, the return value is
///    one of the following error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified record does not exist. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt> </dl> </td> <td width="60%"> The
///    buffer size specified in the <i>ConfigInfoLength</i> parameter is insufficient. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The <i>ServiceHandle</i> parameter is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> One or more of the supplied parameters is in an unusable form. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NO_SUCH_LOGON_SESSION</b></dt> </dl> </td> <td width="60%"> The SSL Certificate used is
///    invalid. This can occur only if the <i>HttpServiceConfigSSLCertInfo</i> parameter is used. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A system error code defined in WinError.h.
///    </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpUpdateServiceConfiguration(HANDLE Handle, HTTP_SERVICE_CONFIG_ID ConfigId, void* ConfigInfo, 
                                    uint ConfigInfoLength, OVERLAPPED* Overlapped);

///The <b>HttpDeleteServiceConfiguration</b> function deletes specified data, such as IP addresses or SSL Certificates,
///from the HTTP Server API configuration store, one record at a time.
///Params:
///    ServiceHandle = This parameter is reserved and must be zero.
///    ConfigId = Type of configuration. This parameter is one of the values in the HTTP_SERVICE_CONFIG_ID enumeration. <table>
///               <tr> <th><i>ConfigId</i> value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigIPListenList"></a><a id="httpserviceconfigiplistenlist"></a><a
///               id="HTTPSERVICECONFIGIPLISTENLIST"></a><dl> <dt><b>HttpServiceConfigIPListenList</b></dt> </dl> </td> <td
///               width="60%"> Deletes a specified IP address from the IP Listen List. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigSSLCertInfo"></a><a id="httpserviceconfigsslcertinfo"></a><a
///               id="HTTPSERVICECONFIGSSLCERTINFO"></a><dl> <dt><b>HttpServiceConfigSSLCertInfo</b></dt> </dl> </td> <td
///               width="60%"> Deletes a specified SSL certificate record. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigUrlAclInfo"></a><a id="httpserviceconfigurlaclinfo"></a><a
///               id="HTTPSERVICECONFIGURLACLINFO"></a><dl> <dt><b>HttpServiceConfigUrlAclInfo</b></dt> </dl> </td> <td
///               width="60%"> Deletes a specified URL reservation record. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigTimeout"></a><a id="httpserviceconfigtimeout"></a><a id="HTTPSERVICECONFIGTIMEOUT"></a><dl>
///               <dt><b>HttpServiceConfigTimeout</b></dt> </dl> </td> <td width="60%"> Deletes a specified connection timeout.
///               <b>Windows Vista and later: </b>This enumeration is supported. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigSslSniCertInfo"></a><a id="httpserviceconfigsslsnicertinfo"></a><a
///               id="HTTPSERVICECONFIGSSLSNICERTINFO"></a><dl> <dt><b>HttpServiceConfigSslSniCertInfo</b></dt> </dl> </td> <td
///               width="60%"> Deletes a specified SSL Server Name Indication (SNI) certificate record. <b>Windows 8 and later:
///               </b>This enumeration value is supported. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigSslCcsCertInfo"></a><a id="httpserviceconfigsslccscertinfo"></a><a
///               id="HTTPSERVICECONFIGSSLCCSCERTINFO"></a><dl> <dt><b>HttpServiceConfigSslCcsCertInfo</b></dt> </dl> </td> <td
///               width="60%"> Deletes the SSL certificate record that specifies that Http.sys should consult the Centralized
///               Certificate Store (CCS) store to find certificates if the port receives a Transport Layer Security (TLS)
///               handshake. The port is specified by the <b>KeyDesc</b> member of the HTTP_SERVICE_CONFIG_SSL_CCS_SET structure
///               that you pass to the <i>pConfigInformation</i> parameter. <b>Windows 8 and later: </b>This enumeration value is
///               supported. </td> </tr> </table>
///    pConfigInformation = Pointer to a buffer that contains data required for the type of configuration specified in the <i>ConfigId</i>
///                         parameter. <table> <tr> <th><i>ConfigId</i> value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                         id="HttpServiceConfigIPListenList"></a><a id="httpserviceconfigiplistenlist"></a><a
///                         id="HTTPSERVICECONFIGIPLISTENLIST"></a><dl> <dt><b>HttpServiceConfigIPListenList</b></dt> </dl> </td> <td
///                         width="60%"> HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM structure. </td> </tr> <tr> <td width="40%"><a
///                         id="HttpServiceConfigSSLCertInfo"></a><a id="httpserviceconfigsslcertinfo"></a><a
///                         id="HTTPSERVICECONFIGSSLCERTINFO"></a><dl> <dt><b>HttpServiceConfigSSLCertInfo</b></dt> </dl> </td> <td
///                         width="60%"> HTTP_SERVICE_CONFIG_SSL_SET structure. </td> </tr> <tr> <td width="40%"><a
///                         id="HttpServiceConfigUrlAclInfo"></a><a id="httpserviceconfigurlaclinfo"></a><a
///                         id="HTTPSERVICECONFIGURLACLINFO"></a><dl> <dt><b>HttpServiceConfigUrlAclInfo</b></dt> </dl> </td> <td
///                         width="60%"> HTTP_SERVICE_CONFIG_URLACL_SET structure. </td> </tr> <tr> <td width="40%"><a
///                         id="HttpServiceConfigTimeouts"></a><a id="httpserviceconfigtimeouts"></a><a
///                         id="HTTPSERVICECONFIGTIMEOUTS"></a><dl> <dt><b>HttpServiceConfigTimeouts</b></dt> </dl> </td> <td width="60%">
///                         HTTP_SERVICE_CONFIG_TIMEOUT_KEY structure. <b>Windows Vista and later: </b>This structure is supported. </td>
///                         </tr> <tr> <td width="40%"><a id="HttpServiceConfigSslSniCertInfo"></a><a
///                         id="httpserviceconfigsslsnicertinfo"></a><a id="HTTPSERVICECONFIGSSLSNICERTINFO"></a><dl>
///                         <dt><b>HttpServiceConfigSslSniCertInfo</b></dt> </dl> </td> <td width="60%"> HTTP_SERVICE_CONFIG_SSL_SNI_SET
///                         structure. The hostname will be "*" when the SSL central certificate store is queried and wildcard bindings are
///                         used, and a host name for regular SNI. <b>Windows 8 and later: </b>This structure is supported. </td> </tr> <tr>
///                         <td width="40%"><a id="HttpServiceConfigSslCcsCertInfo"></a><a id="httpserviceconfigsslccscertinfo"></a><a
///                         id="HTTPSERVICECONFIGSSLCCSCERTINFO"></a><dl> <dt><b><b>HttpServiceConfigSslCcsCertInfo</b></b></dt> </dl> </td>
///                         <td width="60%"> HTTP_SERVICE_CONFIG_SSL_CCS_SET structure. <b>Windows 8 and later: </b>This structure is
///                         supported. </td> </tr> </table>
///    ConfigInformationLength = Size, in bytes, of the <i>pConfigInformation</i> buffer.
///    pOverlapped = Reserved for future asynchronous operation. This parameter must be set to <b>NULL</b>.
///Returns:
///    If the function succeeds, the function returns NO_ERROR. If the function fails, it returns one of the following
///    error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One of the parameters are invalid. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A system error code defined
///    in WinError.h. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpDeleteServiceConfiguration(HANDLE ServiceHandle, HTTP_SERVICE_CONFIG_ID ConfigId, 
                                    void* pConfigInformation, uint ConfigInformationLength, OVERLAPPED* pOverlapped);

///The <b>HttpQueryServiceConfiguration</b> function retrieves one or more HTTP Server API configuration records.
///Params:
///    ServiceHandle = Reserved. Must be zero.
///    ConfigId = The configuration record query type. This parameter is one of the following values from the
///               HTTP_SERVICE_CONFIG_ID enumeration. <table> <tr> <th><i>ConfigId</i> value</th> <th>Meaning</th> </tr> <tr> <td
///               width="40%"><a id="HttpServiceConfigIPListenList"></a><a id="httpserviceconfigiplistenlist"></a><a
///               id="HTTPSERVICECONFIGIPLISTENLIST"></a><dl> <dt><b>HttpServiceConfigIPListenList</b></dt> </dl> </td> <td
///               width="60%"> Queries the IP Listen List. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigSSLCertInfo"></a><a id="httpserviceconfigsslcertinfo"></a><a
///               id="HTTPSERVICECONFIGSSLCERTINFO"></a><dl> <dt><b>HttpServiceConfigSSLCertInfo</b></dt> </dl> </td> <td
///               width="60%"> Queries the SSL store for a specific certificate record. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigUrlAclInfo"></a><a id="httpserviceconfigurlaclinfo"></a><a
///               id="HTTPSERVICECONFIGURLACLINFO"></a><dl> <dt><b>HttpServiceConfigUrlAclInfo</b></dt> </dl> </td> <td
///               width="60%"> Queries URL reservation information. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigTimeout"></a><a id="httpserviceconfigtimeout"></a><a id="HTTPSERVICECONFIGTIMEOUT"></a><dl>
///               <dt><b>HttpServiceConfigTimeout</b></dt> </dl> </td> <td width="60%"> Queries HTTP Server API wide connection
///               timeouts. <b>Windows Vista and later: </b>This enumeration is supported. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigSslSniCertInfo"></a><a id="httpserviceconfigsslsnicertinfo"></a><a
///               id="HTTPSERVICECONFIGSSLSNICERTINFO"></a><dl> <dt><b>HttpServiceConfigSslSniCertInfo</b></dt> </dl> </td> <td
///               width="60%"> Queries the SSL Server Name Indication (SNI) store for a specific certificate record. <b>Windows 8
///               and later: </b>This enumeration value is supported. </td> </tr> <tr> <td width="40%"><a
///               id="HttpServiceConfigSslCcsCertInfo"></a><a id="httpserviceconfigsslccscertinfo"></a><a
///               id="HTTPSERVICECONFIGSSLCCSCERTINFO"></a><dl> <dt><b>HttpServiceConfigSslCcsCertInfo</b></dt> </dl> </td> <td
///               width="60%"> Queries the SSL configuration for an SSL Centralized Certificate Store (CCS) record on the port. The
///               port is specified by the <b>KeyDesc</b> member of the HTTP_SERVICE_CONFIG_SSL_CCS_QUERY structure that you pass
///               to the <i>pInputConfigInfo</i> parameter. <b>Windows 8 and later: </b>This enumeration value is supported. </td>
///               </tr> </table>
///    pInput = A pointer to a structure whose contents further define the query and of the type that correlates with
///             <i>ConfigId</i> in the following table. <table> <tr> <th><i>ConfigId</i> value</th> <th>Meaning</th> </tr> <tr>
///             <td width="40%"><a id="HttpServiceConfigIPListenList"></a><a id="httpserviceconfigiplistenlist"></a><a
///             id="HTTPSERVICECONFIGIPLISTENLIST"></a><dl> <dt><b>HttpServiceConfigIPListenList</b></dt> </dl> </td> <td
///             width="60%"> No input data; set to <b>NULL</b>. </td> </tr> <tr> <td width="40%"><a
///             id="HttpServiceConfigSSLCertInfo"></a><a id="httpserviceconfigsslcertinfo"></a><a
///             id="HTTPSERVICECONFIGSSLCERTINFO"></a><dl> <dt><b>HttpServiceConfigSSLCertInfo</b></dt> </dl> </td> <td
///             width="60%"> HTTP_SERVICE_CONFIG_SSL_QUERY structure. </td> </tr> <tr> <td width="40%"><a
///             id="HttpServiceConfigUrlAclInfo"></a><a id="httpserviceconfigurlaclinfo"></a><a
///             id="HTTPSERVICECONFIGURLACLINFO"></a><dl> <dt><b>HttpServiceConfigUrlAclInfo</b></dt> </dl> </td> <td
///             width="60%"> HTTP_SERVICE_CONFIG_URLACL_QUERY structure. </td> </tr> <tr> <td width="40%"><a
///             id="HttpServiceConfigTimeout"></a><a id="httpserviceconfigtimeout"></a><a id="HTTPSERVICECONFIGTIMEOUT"></a><dl>
///             <dt><b>HttpServiceConfigTimeout</b></dt> </dl> </td> <td width="60%"> HTTP_SERVICE_CONFIG_TIMEOUT_KEY structure.
///             <b>Windows Vista and later: </b>This structure is supported. </td> </tr> <tr> <td width="40%"><a
///             id="HttpServiceConfigSslSniCertInfo"></a><a id="httpserviceconfigsslsnicertinfo"></a><a
///             id="HTTPSERVICECONFIGSSLSNICERTINFO"></a><dl> <dt><b>HttpServiceConfigSslSniCertInfo</b></dt> </dl> </td> <td
///             width="60%"> HTTP_SERVICE_CONFIG_SSL_SNI_QUERY structure. <b>Windows 8 and later: </b>This structure is
///             supported. </td> </tr> <tr> <td width="40%"><a id="HttpServiceConfigSslCcsCertInfo"></a><a
///             id="httpserviceconfigsslccscertinfo"></a><a id="HTTPSERVICECONFIGSSLCCSCERTINFO"></a><dl>
///             <dt><b>HttpServiceConfigSslCcsCertInfo</b></dt> </dl> </td> <td width="60%"> HTTP_SERVICE_CONFIG_SSL_CCS_QUERY
///             structure. <b>Windows 8 and later: </b>This structure is supported. </td> </tr> </table> For more information,
///             see the appropriate query structures.
///    InputLength = Size, in bytes, of the <i>pInputConfigInfo</i> buffer.
///    pOutput = A pointer to a buffer in which the query results are returned. The type of this buffer correlates with
///              <i>ConfigId</i>. <table> <tr> <th><i>ConfigId</i> value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="HttpServiceConfigIPListenList"></a><a id="httpserviceconfigiplistenlist"></a><a
///              id="HTTPSERVICECONFIGIPLISTENLIST"></a><dl> <dt><b>HttpServiceConfigIPListenList</b></dt> </dl> </td> <td
///              width="60%"> HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY structure. </td> </tr> <tr> <td width="40%"><a
///              id="HttpServiceConfigSSLCertInfo"></a><a id="httpserviceconfigsslcertinfo"></a><a
///              id="HTTPSERVICECONFIGSSLCERTINFO"></a><dl> <dt><b>HttpServiceConfigSSLCertInfo</b></dt> </dl> </td> <td
///              width="60%"> HTTP_SERVICE_CONFIG_SSL_SET structure. </td> </tr> <tr> <td width="40%"><a
///              id="HttpServiceConfigUrlAclInfo"></a><a id="httpserviceconfigurlaclinfo"></a><a
///              id="HTTPSERVICECONFIGURLACLINFO"></a><dl> <dt><b>HttpServiceConfigUrlAclInfo</b></dt> </dl> </td> <td
///              width="60%"> HTTP_SERVICE_CONFIG_URLACL_SET structure. </td> </tr> <tr> <td width="40%"><a
///              id="HttpServiceConfigTimeout"></a><a id="httpserviceconfigtimeout"></a><a id="HTTPSERVICECONFIGTIMEOUT"></a><dl>
///              <dt><b>HttpServiceConfigTimeout</b></dt> </dl> </td> <td width="60%"> HTTP_SERVICE_CONFIG_TIMEOUT_PARAM data
///              type. <b>Windows Vista and later: </b>This structure is supported. </td> </tr> <tr> <td width="40%"><a
///              id="HttpServiceConfigSslSniCertInfo"></a><a id="httpserviceconfigsslsnicertinfo"></a><a
///              id="HTTPSERVICECONFIGSSLSNICERTINFO"></a><dl> <dt><b>HttpServiceConfigSslSniCertInfo</b></dt> </dl> </td> <td
///              width="60%"> HTTP_SERVICE_CONFIG_SSL_SNI_SET structure. <b>Windows 8 and later: </b>This structure is supported.
///              </td> </tr> <tr> <td width="40%"><a id="HttpServiceConfigSslCcsCertInfo"></a><a
///              id="httpserviceconfigsslccscertinfo"></a><a id="HTTPSERVICECONFIGSSLCCSCERTINFO"></a><dl>
///              <dt><b>HttpServiceConfigSslCcsCertInfo</b></dt> </dl> </td> <td width="60%"> HTTP_SERVICE_CONFIG_SSL_CCS_SET
///              structure. <b>Windows 8 and later: </b>This structure is supported. </td> </tr> </table>
///    OutputLength = Size, in bytes, of the <i>pOutputConfigInfo</i> buffer.
///    pReturnLength = A pointer to a variable that receives the number of bytes to be written in the output buffer. If the output
///                    buffer is too small, the call fails with a return value of <b>ERROR_INSUFFICIENT_BUFFER</b>. The value pointed to
///                    by <i>pReturnLength</i> can be used to determine the minimum length the buffer requires for the call to succeed.
///    pOverlapped = Reserved for asynchronous operation and must be set to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is <b>NO_ERROR</b>. If the function fails, the return value is one of
///    the following error codes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One of the parameters are invalid. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt> </dl> </td> <td width="60%"> The
///    buffer pointed to by <i>pOutputConfigInfo</i> is too small to receive the output data. Call the function again
///    with a buffer at least as large as the size pointed to by <i>pReturnLength</i> on exit. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> This error code is only returned
///    when <i>ConfigId</i> is set to <b>HttpServiceConfigTimeout</b>. The buffer pointed to by <i>pOutputConfigInfo</i>
///    is too small to receive the output data. Call the function again with a buffer at least as large as the size
///    pointed to by <i>pReturnLength</i> on exit. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> There are no more items to return that meet the
///    specified criteria. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> A
///    system error code defined in WinError.h. </td> </tr> </table>
///    
@DllImport("HTTPAPI")
uint HttpQueryServiceConfiguration(HANDLE ServiceHandle, HTTP_SERVICE_CONFIG_ID ConfigId, void* pInput, 
                                   uint InputLength, void* pOutput, uint OutputLength, uint* pReturnLength, 
                                   OVERLAPPED* pOverlapped);

@DllImport("HTTPAPI")
uint HttpGetExtension(HTTPAPI_VERSION Version, uint Extension, void* Buffer, uint BufferSize);

///The <b>WinHttpSetStatusCallback</b> function sets up a callback function that WinHTTP can call as progress is made
///during an operation.
///Params:
///    hInternet = HINTERNET handle for which the callback is to be set.
///    lpfnInternetCallback = Pointer to the callback function to call when progress is made. Set this to <b>NULL</b> to remove the existing
///                           callback function. For more information about the callback function, see WINHTTP_STATUS_CALLBACK.
///    dwNotificationFlags = Unsigned long integer value that specifies flags to indicate which events activate the callback function. The
///                          possible values are as follows. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                          id="WINHTTP_CALLBACK_FLAG_ALL_COMPLETIONS"></a><a id="winhttp_callback_flag_all_completions"></a><dl>
///                          <dt><b>WINHTTP_CALLBACK_FLAG_ALL_COMPLETIONS</b></dt> </dl> </td> <td width="60%"> Activates upon any completion
///                          notification. This flag specifies that all notifications required for read or write operations are used. See
///                          WINHTTP_STATUS_CALLBACK for a list of completions. </td> </tr> <tr> <td width="40%"><a
///                          id="WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS"></a><a id="winhttp_callback_flag_all_notifications"></a><dl>
///                          <dt><b>WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS</b></dt> </dl> </td> <td width="60%"> Activates upon any status
///                          change notification including completions. See WINHTTP_STATUS_CALLBACK for a list of notifications. </td> </tr>
///                          <tr> <td width="40%"><a id="WINHTTP_CALLBACK_FLAG_RESOLVE_NAME"></a><a
///                          id="winhttp_callback_flag_resolve_name"></a><dl> <dt><b>WINHTTP_CALLBACK_FLAG_RESOLVE_NAME</b></dt> </dl> </td>
///                          <td width="60%"> Activates upon beginning and completing name resolution. </td> </tr> <tr> <td width="40%"><a
///                          id="WINHTTP_CALLBACK_FLAG_CONNECT_TO_SERVER"></a><a id="winhttp_callback_flag_connect_to_server"></a><dl>
///                          <dt><b>WINHTTP_CALLBACK_FLAG_CONNECT_TO_SERVER</b></dt> </dl> </td> <td width="60%"> Activates upon beginning and
///                          completing connection to the server. </td> </tr> <tr> <td width="40%"><a
///                          id="WINHTTP_CALLBACK_FLAG_DETECTING_PROXY"></a><a id="winhttp_callback_flag_detecting_proxy"></a><dl>
///                          <dt><b>WINHTTP_CALLBACK_FLAG_DETECTING_PROXY</b></dt> </dl> </td> <td width="60%"> Activates when detecting the
///                          proxy server. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_CALLBACK_FLAG_DATA_AVAILABLE"></a><a
///                          id="winhttp_callback_flag_data_available"></a><dl> <dt><b>WINHTTP_CALLBACK_FLAG_DATA_AVAILABLE</b></dt> </dl>
///                          </td> <td width="60%"> Activates when completing a query for data. </td> </tr> <tr> <td width="40%"><a
///                          id="WINHTTP_CALLBACK_FLAG_HEADERS_AVAILABLE"></a><a id="winhttp_callback_flag_headers_available"></a><dl>
///                          <dt><b>WINHTTP_CALLBACK_FLAG_HEADERS_AVAILABLE</b></dt> </dl> </td> <td width="60%"> Activates when the response
///                          headers are available for retrieval. </td> </tr> <tr> <td width="40%"><a
///                          id="WINHTTP_CALLBACK_FLAG_READ_COMPLETE"></a><a id="winhttp_callback_flag_read_complete"></a><dl>
///                          <dt><b>WINHTTP_CALLBACK_FLAG_READ_COMPLETE</b></dt> </dl> </td> <td width="60%"> Activates upon completion of a
///                          data-read operation. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_CALLBACK_FLAG_REQUEST_ERROR"></a><a
///                          id="winhttp_callback_flag_request_error"></a><dl> <dt><b>WINHTTP_CALLBACK_FLAG_REQUEST_ERROR</b></dt> </dl> </td>
///                          <td width="60%"> Activates when an asynchronous error occurs. </td> </tr> <tr> <td width="40%"><a
///                          id="WINHTTP_CALLBACK_FLAG_SEND_REQUEST"></a><a id="winhttp_callback_flag_send_request"></a><dl>
///                          <dt><b>WINHTTP_CALLBACK_FLAG_SEND_REQUEST</b></dt> </dl> </td> <td width="60%"> Activates upon beginning and
///                          completing the sending of a request header with WinHttpSendRequest. </td> </tr> <tr> <td width="40%"><a
///                          id="WINHTTP_CALLBACK_FLAG_SENDREQUEST_COMPLETE"></a><a id="winhttp_callback_flag_sendrequest_complete"></a><dl>
///                          <dt><b>WINHTTP_CALLBACK_FLAG_SENDREQUEST_COMPLETE</b></dt> </dl> </td> <td width="60%"> Activates when a request
///                          header has been sent with WinHttpSendRequest. </td> </tr> <tr> <td width="40%"><a
///                          id="WINHTTP_CALLBACK_FLAG_WRITE_COMPLETE"></a><a id="winhttp_callback_flag_write_complete"></a><dl>
///                          <dt><b>WINHTTP_CALLBACK_FLAG_WRITE_COMPLETE</b></dt> </dl> </td> <td width="60%"> Activates upon completion of a
///                          data-post operation. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_CALLBACK_FLAG_RECEIVE_RESPONSE"></a><a
///                          id="winhttp_callback_flag_receive_response"></a><dl> <dt><b>WINHTTP_CALLBACK_FLAG_RECEIVE_RESPONSE</b></dt> </dl>
///                          </td> <td width="60%"> Activates upon beginning and completing the receipt of a resource from the HTTP server.
///                          </td> </tr> <tr> <td width="40%"><a id="WINHTTP_CALLBACK_FLAG_CLOSE_CONNECTION"></a><a
///                          id="winhttp_callback_flag_close_connection"></a><dl> <dt><b>WINHTTP_CALLBACK_FLAG_CLOSE_CONNECTION</b></dt> </dl>
///                          </td> <td width="60%"> Activates when beginning and completing the closing of an HTTP connection. </td> </tr>
///                          <tr> <td width="40%"><a id="WINHTTP_CALLBACK_FLAG_HANDLES"></a><a id="winhttp_callback_flag_handles"></a><dl>
///                          <dt><b>WINHTTP_CALLBACK_FLAG_HANDLES</b></dt> </dl> </td> <td width="60%"> Activates when an HINTERNET handle is
///                          created or closed. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_CALLBACK_FLAG_REDIRECT"></a><a
///                          id="winhttp_callback_flag_redirect"></a><dl> <dt><b>WINHTTP_CALLBACK_FLAG_REDIRECT</b></dt> </dl> </td> <td
///                          width="60%"> Activates when the request is redirected. </td> </tr> <tr> <td width="40%"><a
///                          id="WINHTTP_CALLBACK_FLAG_INTERMEDIATE_RESPONSE"></a><a id="winhttp_callback_flag_intermediate_response"></a><dl>
///                          <dt><b>WINHTTP_CALLBACK_FLAG_INTERMEDIATE_RESPONSE</b></dt> </dl> </td> <td width="60%"> Activates when receiving
///                          an intermediate (100 level) status code message from the server. </td> </tr> <tr> <td width="40%"><a
///                          id="WINHTTP_CALLBACK_FLAG_SECURE_FAILURE"></a><a id="winhttp_callback_flag_secure_failure"></a><dl>
///                          <dt><b>WINHTTP_CALLBACK_FLAG_SECURE_FAILURE</b></dt> </dl> </td> <td width="60%"> Activates upon a secure
///                          connection failure. </td> </tr> </table>
///    dwReserved = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    If successful, returns a pointer to the previously defined status callback function or <b>NULL</b> if there was
///    no previously defined status callback function. Returns <b>WINHTTP_INVALID_STATUS_CALLBACK</b> if the callback
///    function could not be installed. For extended error information, call GetLastError. Among the error codes
///    returned are the following. <table> <tr> <th>Error Code</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td width="60%"> The type of handle supplied
///    is incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has occurred. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough
///    memory was available to complete the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
WINHTTP_STATUS_CALLBACK WinHttpSetStatusCallback(void* hInternet, WINHTTP_STATUS_CALLBACK lpfnInternetCallback, 
                                                 uint dwNotificationFlags, size_t dwReserved);

///The <b>WinHttpTimeFromSystemTime</b> function formats a date and time according to the HTTP version 1.0
///specification.
///Params:
///    pst = A pointer to a SYSTEMTIME structure that contains the date and time to format.
///    pwszTime = A pointer to a string buffer that receives the formatted date and time. The buffer should equal to the size, in
///               bytes, of WINHTTP_TIME_FORMAT_BUFSIZE.
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. To get extended error information, call
///    GetLastError. Error codes include the following. <table> <tr> <th>Error Code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error
///    has occurred. </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpTimeFromSystemTime(const(SYSTEMTIME)* pst, PWSTR pwszTime);

///The <b>WinHttpTimeToSystemTime</b> function takes an HTTP time/date string and converts it to a SYSTEMTIME structure.
///Params:
///    pwszTime = Pointer to a null-terminated date/time string to convert. This value must use the format defined in section 3.3
///               of the RFC2616.
///    pst = Pointer to the SYSTEMTIME structure that receives the converted time.
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call GetLastError.
///    Among the error codes returned is: <table> <tr> <th>Error Code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has
///    occurred. </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpTimeToSystemTime(const(PWSTR) pwszTime, SYSTEMTIME* pst);

///The <b>WinHttpCrackUrl</b> function separates a URL into its component parts such as host name and path.
///Params:
///    pwszUrl = Pointer to a string that contains the canonical URL to separate. <b>WinHttpCrackUrl</b> does not check this URL
///              for validity or correct format before attempting to crack it.
///    dwUrlLength = The length of the <i>pwszUrl</i> string, in characters. If <i>dwUrlLength</i> is set to zero,
///                  <b>WinHttpCrackUrl</b> assumes that the <i>pwszUrl</i> string is <b>null</b> terminated and determines the length
///                  of the <i>pwszUrl</i> string based on that assumption.
///    dwFlags = The flags that control the operation. This parameter can be a combination of one or more of the following flags
///              (values can be bitwise OR'd together). Or, the parameter can be 0, which performs no special operations. <table>
///              <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ICU_DECODE"></a><a
///              id="icu_decode"></a><dl> <dt><b>ICU_DECODE</b></dt> </dl> </td> <td width="60%"> Converts characters that are
///              "escape encoded" (%xx) to their non-escaped form. This does not decode other encodings, such as UTF-8. This
///              feature can be used only if the user provides buffers in the URL_COMPONENTS structure to copy the components
///              into. </td> </tr> <tr> <td width="40%"><a id="ICU_ESCAPE"></a><a id="icu_escape"></a><dl>
///              <dt><b>ICU_ESCAPE</b></dt> </dl> </td> <td width="60%"> Escapes certain characters to their escape sequences
///              (%xx). Characters to be escaped are non-ASCII characters or those ASCII characters that must be escaped to be
///              represented in an HTTP request. This feature can be used only if the user provides buffers in the URL_COMPONENTS
///              structure to copy the components into. </td> </tr> <tr> <td width="40%"><a id="ICU_REJECT_USERPWD"></a><a
///              id="icu_reject_userpwd"></a><dl> <dt><b>ICU_REJECT_USERPWD</b></dt> </dl> </td> <td width="60%"> Rejects URLs as
///              input that contain embedded credentials (either a username, a password, or both). If the function fails because
///              of an invalid URL, then subsequent calls to GetLastError return <b>ERROR_WINHTTP_INVALID_URL</b>. </td> </tr>
///              </table>
///    lpUrlComponents = Pointer to a URL_COMPONENTS structure that receives the URL components.
///Returns:
///    Returns <b>TRUE</b> if the function succeeds, or <b>FALSE</b> otherwise. To get extended error information, call
///    GetLastError. Among the error codes returned are the following. <table> <tr> <th>Error Codes</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td>
///    <td width="60%"> An internal error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INVALID_URL</b></dt> </dl> </td> <td width="60%"> The URL is invalid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b></dt> </dl> </td> <td width="60%"> The URL scheme
///    could not be recognized, or is not supported. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory was available to complete
///    the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpCrackUrl(const(PWSTR) pwszUrl, uint dwUrlLength, uint dwFlags, URL_COMPONENTS* lpUrlComponents);

///The <b>WinHttpCreateUrl</b> function creates a URL from component parts such as the host name and path.
///Params:
///    lpUrlComponents = Pointer to a URL_COMPONENTS structure that contains the components from which to create the URL.
///    dwFlags = Flags that control the operation of this function. This parameter can be one of the following values. <table>
///              <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ICU_ESCAPE"></a><a
///              id="icu_escape"></a><dl> <dt><b>ICU_ESCAPE</b></dt> </dl> </td> <td width="60%"> Converts all unsafe characters
///              to their corresponding escape sequences in the path string pointed to by the <b>lpszUrlPath</b> member and in
///              <b>lpszExtraInfo</b> the extra-information string pointed to by the member of the URL_COMPONENTS structure
///              pointed to by the <i>lpUrlComponents</i> parameter. </td> </tr> <tr> <td width="40%"><a
///              id="ICU_REJECT_USERPWD"></a><a id="icu_reject_userpwd"></a><dl> <dt><b>ICU_REJECT_USERPWD</b></dt> </dl> </td>
///              <td width="60%"> Rejects URLs as input that contains either a username, or a password, or both. If the function
///              fails because of an invalid URL, subsequent calls to GetLastError will return ERROR_WINHTTP_INVALID_URL. </td>
///              </tr> </table>
///    pwszUrl = Pointer to a character buffer that receives the URL as a wide character (Unicode) string.
///    pdwUrlLength = Pointer to a variable of type unsigned long integer that receives the length of the <i>pwszUrl</i> buffer in wide
///                   (Unicode) characters. When the function returns, this parameter receives the length of the URL string wide in
///                   characters, minus 1 for the terminating character. If GetLastError returns ERROR_INSUFFICIENT_BUFFER, this
///                   parameter receives the number of wide characters required to hold the created URL.
///Returns:
///    Returns <b>TRUE</b> if the function succeeds, or <b>FALSE</b> otherwise. To get extended error data, call
///    GetLastError. Among the error codes returned are the following. <table> <tr> <th>Error Code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td>
///    <td width="60%"> An internal error occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory available to complete
///    the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpCreateUrl(URL_COMPONENTS* lpUrlComponents, uint dwFlags, PWSTR pwszUrl, uint* pdwUrlLength);

///The <b>WinHttpCheckPlatform</b> function determines whether the current platform is supported by this version of
///Microsoft Windows HTTP Services (WinHTTP).
///Returns:
///    The return value is <b>TRUE</b> if the platform is supported by Microsoft Windows HTTP Services (WinHTTP), or
///    <b>FALSE</b> otherwise.
///    
@DllImport("WINHTTP")
BOOL WinHttpCheckPlatform();

///The <b>WinHttpGetDefaultProxyConfiguration</b> function retrieves the default WinHTTP proxy configuration from the
///registry.
///Params:
///    pProxyInfo = A pointer to a variable of type WINHTTP_PROXY_INFO that receives the default proxy configuration.
///Returns:
///    Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To retrieve a specific error message, call
///    GetLastError. Error codes returned include the following. <table> <tr> <th>Error Code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An
///    internal error has occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl>
///    </td> <td width="60%"> Not enough memory was available to complete the requested operation. (Windows error code)
///    </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpGetDefaultProxyConfiguration(WINHTTP_PROXY_INFO* pProxyInfo);

///> [!IMPORTANT] > Use of **WinHttpSetDefaultProxyConfiguration** is deprecated on Windows 8.1 and newer. Most proxy
///configurations are not supported by **WinHttpSetDefaultProxyConfiguration**, nor does it support proxy
///authentication. Instead, use **WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY** with [WinHttpOpen](./nf-winhttp-winhttpopen.md).
///The <b>WinHttpSetDefaultProxyConfiguration</b> function sets the default WinHTTP proxy configuration in the registry.
///Params:
///    pProxyInfo = A pointer to a variable of type WINHTTP_PROXY_INFO that specifies the default proxy configuration.
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call GetLastError.
///    Among the error codes returned are the following. <table> <tr> <th>Error Code</th> <th>Description</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal
///    error has occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td>
///    <td width="60%"> Not enough memory was available to complete the requested operation. (Windows error code) </td>
///    </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpSetDefaultProxyConfiguration(WINHTTP_PROXY_INFO* pProxyInfo);

///The <b>WinHttpOpen</b> function initializes, for an application, the use of WinHTTP functions and returns a
///WinHTTP-session handle.
///Params:
///    pszAgentW = A pointer to a string variable that contains the name of the application or entity calling the WinHTTP functions.
///                This name is used as the user agent in the HTTP protocol.
///    dwAccessType = Type of access required. This can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///                   </tr> <tr> <td width="40%"><a id="WINHTTP_ACCESS_TYPE_NO_PROXY"></a><a id="winhttp_access_type_no_proxy"></a><dl>
///                   <dt><b>WINHTTP_ACCESS_TYPE_NO_PROXY</b></dt> </dl> </td> <td width="60%"> Resolves all host names directly
///                   without a proxy. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_ACCESS_TYPE_DEFAULT_PROXY"></a><a
///                   id="winhttp_access_type_default_proxy"></a><dl> <dt><b>WINHTTP_ACCESS_TYPE_DEFAULT_PROXY</b></dt> </dl> </td> <td
///                   width="60%"> <div class="alert"><b>Important</b> Use of this option is deprecated on Windows 8.1 and newer. Use
///                   WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY instead.</div> <div> </div> Retrieves the static proxy or direct
///                   configuration from the registry. <b>WINHTTP_ACCESS_TYPE_DEFAULT_PROXY</b> does not inherit browser proxy
///                   settings. The WinHTTP proxy configuration is set by one of these mechanisms.<ul> <li>The proxycfg.exe utility on
///                   Windows XP and Windows Server 2003 or earlier.</li> <li>The <a
///                   href="/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc731131(v=ws.10)
///    pszProxyW = A pointer to a string variable that contains the name of the proxy server to use when proxy access is specified
///                by setting <i>dwAccessType</i> to <b>WINHTTP_ACCESS_TYPE_NAMED_PROXY</b>. The WinHTTP functions recognize only
///                CERN type proxies for HTTP. If <i>dwAccessType</i> is not set to <b>WINHTTP_ACCESS_TYPE_NAMED_PROXY</b>, this
///                parameter must be set to <b>WINHTTP_NO_PROXY_NAME</b>.
///    pszProxyBypassW = A pointer to a string variable that contains an optional semicolon delimited list of host names or IP addresses,
///                      or both, that should not be routed through the proxy when <i>dwAccessType</i> is set to
///                      <b>WINHTTP_ACCESS_TYPE_NAMED_PROXY</b>. The list can contain wildcard characters. Do not use an empty string,
///                      because the <b>WinHttpOpen</b> function uses it as the proxy bypass list. If this parameter specifies the
///                      "&lt;local&gt;" macro in the list as the only entry, this function bypasses any host name that does not contain a
///                      period. If <i>dwAccessType</i> is not set to <b>WINHTTP_ACCESS_TYPE_NAMED_PROXY</b>, this parameter must be set
///                      to <b>WINHTTP_NO_PROXY_BYPASS</b>.
///    dwFlags = Unsigned long integer value that contains the flags that indicate various options affecting the behavior of this
///              function. This parameter can have the following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///              <td width="40%"><a id="WINHTTP_FLAG_ASYNC"></a><a id="winhttp_flag_async"></a><dl>
///              <dt><b>WINHTTP_FLAG_ASYNC</b></dt> </dl> </td> <td width="60%"> Use the WinHTTP functions asynchronously. By
///              default, all WinHTTP functions that use the returned HINTERNET handle are performed synchronously. When this flag
///              is set, the caller needs to specify a callback function through WinHttpSetStatusCallback. </td> </tr> </table>
///Returns:
///    Returns a valid session handle if successful, or <b>NULL</b> otherwise. To retrieve extended error information,
///    call GetLastError. Among the error codes returned are the following. <table> <tr> <th>Error Code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td>
///    <td width="60%"> An internal error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory was available to complete
///    the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
void* WinHttpOpen(const(PWSTR) pszAgentW, uint dwAccessType, const(PWSTR) pszProxyW, const(PWSTR) pszProxyBypassW, 
                  uint dwFlags);

///The **WinHttpCloseHandle** function closes a single **HINTERNET** handle (see [HINTERNET Handles in
///WinHTTP](/windows/win32/winhttp/hinternet-handles-in-winhttp)).
///Params:
///    hInternet = A valid **HINTERNET** handle (see [HINTERNET Handles in
///                WinHTTP](/windows/win32/winhttp/hinternet-handles-in-winhttp)) to be closed.
///Returns:
///    **TRUE** if the handle is successfully closed, otherwise **FALSE**. To get extended error information, call
///    GetLastError. Among the error codes returned are the following. <table> <tr> <th>Error Codes</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_SHUTDOWN</b></dt> </dl> </td> <td
///    width="60%"> The WinHTTP function support is being shut down or unloaded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has occurred. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough
///    memory was available to complete the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpCloseHandle(void* hInternet);

///The <b>WinHttpConnect</b> function specifies the initial target server of an HTTP request and returns an HINTERNET
///connection handle to an HTTP session for that initial target.
///Params:
///    hSession = Valid HINTERNET WinHTTP session handle returned by a previous call to WinHttpOpen.
///    pswzServerName = Pointer to a <b>null</b>-terminated string that contains the host name of an HTTP server. Alternately, the string
///                     can contain the IP address of the site in ASCII, for example, 10.0.1.45. Note that WinHttp does not accept
///                     international host names without converting them first to Punycode. For more information, see Handling
///                     Internationalized Domain Names (IDNs).
///    nServerPort = Unsigned integer that specifies the TCP/IP port on the server to which a connection is made. This parameter can
///                  be any valid TCP/IP port number, or one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///                  </tr> <tr> <td width="40%"><a id="INTERNET_DEFAULT_HTTP_PORT"></a><a id="internet_default_http_port"></a><dl>
///                  <dt><b>INTERNET_DEFAULT_HTTP_PORT</b></dt> </dl> </td> <td width="60%"> Uses the default port for HTTP servers
///                  (port 80). </td> </tr> <tr> <td width="40%"><a id="INTERNET_DEFAULT_HTTPS_PORT"></a><a
///                  id="internet_default_https_port"></a><dl> <dt><b>INTERNET_DEFAULT_HTTPS_PORT</b></dt> </dl> </td> <td
///                  width="60%"> Uses the default port for HTTPS servers (port 443). Selecting this port does not automatically
///                  establish a secure connection. You must still specify the use of secure transaction semantics by using the
///                  WINHTTP_FLAG_SECURE flag with WinHttpOpenRequest. </td> </tr> <tr> <td width="40%"><a
///                  id="INTERNET_DEFAULT_PORT"></a><a id="internet_default_port"></a><dl> <dt><b>INTERNET_DEFAULT_PORT</b></dt> </dl>
///                  </td> <td width="60%"> Uses port 80 for HTTP and port 443 for Secure Hypertext Transfer Protocol (HTTPS). </td>
///                  </tr> </table>
///    dwReserved = This parameter is reserved and must be 0.
///Returns:
///    Returns a valid connection handle to the HTTP session if the connection is successful, or <b>NULL</b> otherwise.
///    To retrieve extended error information, call GetLastError. Among the error codes returned are the following.
///    <table> <tr> <th>Error Codes</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td width="60%"> The type of handle supplied is
///    incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt>
///    </dl> </td> <td width="60%"> An internal error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INVALID_URL</b></dt> </dl> </td> <td width="60%"> The URL is invalid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_WINHTTP_OPERATION_CANCELLED</b></dt> </dl> </td> <td width="60%"> The operation
///    was canceled, usually because the handle on which the request was operating was closed before the operation
///    completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b></dt> </dl> </td>
///    <td width="60%"> The URL scheme could not be recognized, or is not supported. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_WINHTTP_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The WinHTTP function support is being
///    shut down or unloaded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td>
///    <td width="60%"> Not enough memory was available to complete the requested operation. (Windows error code) </td>
///    </tr> </table>
///    
@DllImport("WINHTTP")
void* WinHttpConnect(void* hSession, const(PWSTR) pswzServerName, ushort nServerPort, uint dwReserved);

///The <b>WinHttpReadData</b> function reads data from a handle opened by the WinHttpOpenRequest function.
///Params:
///    hRequest = Valid HINTERNET handle returned from a previous call to WinHttpOpenRequest. WinHttpReceiveResponse or
///               WinHttpQueryDataAvailable must have been called for this handle and must have completed before
///               <b>WinHttpReadData</b> is called. Although calling <b>WinHttpReadData</b> immediately after completion of
///               <b>WinHttpReceiveResponse</b> avoids the expense of a buffer copy, doing so requires that the application use a
///               fixed-length buffer for reading.
///    lpBuffer = Pointer to a buffer that receives the data read. Make sure that this buffer remains valid until
///               <b>WinHttpReadData</b> has completed.
///    dwNumberOfBytesToRead = Unsigned long integer value that contains the number of bytes to read.
///    lpdwNumberOfBytesRead = Pointer to an unsigned long integer variable that receives the number of bytes read. <b>WinHttpReadData</b> sets
///                            this value to zero before doing any work or error checking. When using WinHTTP asynchronously, always set this
///                            parameter to <b>NULL</b> and retrieve the information in the callback function; not doing so can cause a memory
///                            fault.
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call GetLastError.
///    The following table identifies the error codes that are returned. <table> <tr> <th>Error Code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_CONNECTION_ERROR</b></dt> </dl> </td>
///    <td width="60%"> The connection with the server has been reset or terminated, or an incompatible SSL protocol was
///    encountered. For example, WinHTTP 5.1 does not support SSL2 unless the client specifically enables it. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b></dt> </dl> </td> <td
///    width="60%"> The requested operation cannot be carried out because the handle supplied is not in the correct
///    state. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td
///    width="60%"> The type of handle supplied is incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has occurred. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_OPERATION_CANCELLED</b></dt> </dl> </td> <td width="60%">
///    The operation was canceled, usually because the handle on which the request was operating was closed before the
///    operation completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_RESPONSE_DRAIN_OVERFLOW</b></dt>
///    </dl> </td> <td width="60%"> Returned when an incoming response exceeds an internal WinHTTP size limit. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The request
///    has timed out. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td
///    width="60%"> Not enough memory was available to complete the requested operation. (Windows error code) </td>
///    </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpReadData(void* hRequest, void* lpBuffer, uint dwNumberOfBytesToRead, uint* lpdwNumberOfBytesRead);

///The <b>WinHttpWriteData</b> function writes request data to an HTTP server.
///Params:
///    hRequest = Valid HINTERNET handle returned by WinHttpOpenRequest. Wait until WinHttpSendRequest has completed before calling
///               this function.
///    lpBuffer = Pointer to a buffer that contains the data to be sent to the server. Be sure that this buffer remains valid until
///               after <b>WinHttpWriteData</b> completes.
///    dwNumberOfBytesToWrite = Unsigned long integer value that contains the number of bytes to be written to the file.
///    lpdwNumberOfBytesWritten = Pointer to an unsigned long integer variable that receives the number of bytes written to the buffer. The
///                               <b>WinHttpWriteData</b> function sets this value to zero before doing any work or error checking. When using
///                               WinHTTP asynchronously, this parameter must be set to <b>NULL</b> and retrieve the information in the callback
///                               function. Not doing so can cause a memory fault.
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call GetLastError.
///    Among the error codes returned are: <table> <tr> <th>Error Code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_WINHTTP_CONNECTION_ERROR</b></dt> </dl> </td> <td width="60%"> The connection with
///    the server has been reset or terminated, or an incompatible SSL protocol was encountered. For example, WinHTTP
///    version 5.1 does not support SSL2 unless the client specifically enables it. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b></dt> </dl> </td> <td width="60%"> The requested operation
///    cannot be carried out because the handle supplied is not in the correct state. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td width="60%"> The type of handle supplied
///    is incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has occurred. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_OPERATION_CANCELLED</b></dt> </dl> </td> <td width="60%">
///    The operation was canceled, usually because the handle on which the request was operating was closed before the
///    operation completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_TIMEOUT</b></dt> </dl> </td> <td
///    width="60%"> The request has timed out. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory was available to complete
///    the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpWriteData(void* hRequest, const(void)* lpBuffer, uint dwNumberOfBytesToWrite, 
                      uint* lpdwNumberOfBytesWritten);

///The <b>WinHttpQueryDataAvailable</b> function returns the amount of data, in bytes, available to be read with
///WinHttpReadData.
///Params:
///    hRequest = A valid HINTERNET handle returned by WinHttpOpenRequest. WinHttpReceiveResponse must have been called for this
///               handle and have completed before <b>WinHttpQueryDataAvailable</b> is called.
///    lpdwNumberOfBytesAvailable = A pointer to an unsigned long integer variable that receives the number of available bytes. When WinHTTP is used
///                                 in asynchronous mode, always set this parameter to <b>NULL</b> and retrieve data in the callback function; not
///                                 doing so can cause a memory fault.
///Returns:
///    Returns <b>TRUE</b> if the function succeeds, or <b>FALSE</b> otherwise. To get extended error data, call
///    GetLastError. Among the error codes returned are the following. <table> <tr> <th>Error Code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_CONNECTION_ERROR</b></dt> </dl> </td>
///    <td width="60%"> The connection with the server has been reset or terminated, or an incompatible SSL protocol was
///    encountered. For example, WinHTTP version 5.1 does not support SSL2 unless the client specifically enables it.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b></dt> </dl> </td> <td
///    width="60%"> The requested operation cannot complete because the handle supplied is not in the correct state.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td
///    width="60%"> The type of handle supplied is incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has occurred. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_OPERATION_CANCELLED</b></dt> </dl> </td> <td width="60%">
///    The operation was canceled, usually because the handle on which the request was operating was closed before the
///    operation completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_TIMEOUT</b></dt> </dl> </td> <td
///    width="60%"> The request has timed out. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory was available to complete
///    the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpQueryDataAvailable(void* hRequest, uint* lpdwNumberOfBytesAvailable);

///The <b>WinHttpQueryOption</b> function queries an Internet option on the specified handle.
///Params:
///    hInternet = An <b>HINTERNET</b> handle on which to query information. Note that this can be either a Session handle or a
///                Request handle, depending on what option is being queried; see the Option Flags topic to determine which handle
///                is appropriate to use in querying a particular option.
///    dwOption = An unsigned long integer value that contains the Internet option to query. This can be one of the Option Flags
///               values.
///    lpBuffer = A pointer to a buffer that receives the option setting. Strings returned by the <b>WinHttpQueryOption</b>
///               function are globally allocated, so the calling application must globally free the string when it finishes using
///               it. Setting this parameter to <b>NULL</b> causes this function to return <b>FALSE</b>. Calling GetLastError then
///               returns ERROR_INSUFFICIENT_BUFFER and <i>lpdwBufferLength</i> contains the number of bytes required to hold the
///               requested information.
///    lpdwBufferLength = A pointer to an unsigned long integer variable that contains the length of <i>lpBuffer</i>, in bytes. When the
///                       function returns, the variable receives the length of the data placed into <i>lpBuffer</i>. If GetLastError
///                       returns ERROR_INSUFFICIENT_BUFFER, this parameter receives the number of bytes required to hold the requested
///                       information.
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. To get a specific error message, call GetLastError.
///    Among the error codes returned are the following: <table> <tr> <th>Error Code</th> <th>Description</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b></dt> </dl> </td> <td width="60%"> The
///    requested operation cannot be carried out because the handle supplied is not in the correct state. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td width="60%"> The
///    type of handle supplied is incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has occurred. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INVALID_OPTION</b></dt> </dl> </td> <td width="60%"> An
///    invalid option value was specified. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory was available to complete
///    the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpQueryOption(void* hInternet, uint dwOption, void* lpBuffer, uint* lpdwBufferLength);

///The <b>WinHttpSetOption</b> function sets an Internet option.
///Params:
///    hInternet = The HINTERNET handle on which to set data. Be aware that this can be either a Session handle or a Request handle,
///                depending on what option is being set. For more information about how to determine which handle is appropriate to
///                use in setting a particular option, see the Option Flags.
///    dwOption = An unsigned long integer value that contains the Internet option to set. This can be one of the Option Flags
///               values.
///    lpBuffer = A pointer to a buffer that contains the option setting.
///    dwBufferLength = Unsigned long integer value that contains the length of the <i>lpBuffer</i> buffer. The length of the buffer is
///                     specified in characters for the following options; for all other options, the length is specified in bytes.
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call GetLastError.
///    Among the error codes returned are the following: <table> <tr> <th>Error Code</th> <th>Description</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b></dt> </dl> </td> <td width="60%"> The
///    requested operation cannot be carried out because the handle supplied is not in the correct state. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td width="60%"> The
///    type of handle supplied is incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has occurred. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INVALID_OPTION</b></dt> </dl> </td> <td width="60%"> A
///    request to WinHttpQueryOption or WinHttpSetOption specified an invalid option value. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> A parameter is not valid.
///    This value will be returned if <b>WINHTTP_OPTION_WEB_SOCKET_KEEPALIVE_INTERVAL</b> is set to a value lower than
///    15000. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_OPTION_NOT_SETTABLE</b></dt> </dl> </td> <td
///    width="60%"> The requested option cannot be set, only queried. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> A parameter is not valid. This value will be
///    returned if <b>WINHTTP_OPTION_WEB_SOCKET_KEEPALIVE_INTERVAL</b> is set to a value lower than 15000. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory
///    was available to complete the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpSetOption(void* hInternet, uint dwOption, void* lpBuffer, uint dwBufferLength);

///The <b>WinHttpSetTimeouts</b> function sets time-outs involved with HTTP transactions.
///Params:
///    hInternet = The HINTERNET handle returned by WinHttpOpen or WinHttpOpenRequest.
///    nResolveTimeout = A value of type integer that specifies the time-out value, in milliseconds, to use for name resolution. If
///                      resolution takes longer than this time-out value, the action is canceled. The initial value is zero, meaning no
///                      time-out (infinite). <b>Windows Vista and Windows XP: </b>If DNS timeout is specified using
///                      NAME_RESOLUTION_TIMEOUT, there is an overhead of one thread per request.
///    nConnectTimeout = A value of type integer that specifies the time-out value, in milliseconds, to use for server connection
///                      requests. If a connection request takes longer than this time-out value, the request is canceled. The initial
///                      value is 60,000 (60 seconds). TCP/IP can time out while setting up the socket during the three leg SYN/ACK
///                      exchange, regardless of the value of this parameter.
///    nSendTimeout = A value of type integer that specifies the time-out value, in milliseconds, to use for sending requests. If
///                   sending a request takes longer than this time-out value, the send is canceled. The initial value is 30,000 (30
///                   seconds).
///    nReceiveTimeout = A value of type integer that specifies the time-out value, in milliseconds, to receive a response to a request.
///                      If a response takes longer than this time-out value, the request is canceled. The initial value is 30,000 (30
///                      seconds).
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call GetLastError.
///    Among the error codes returned are the following. <table> <tr> <th>Error Code</th> <th>Description</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b></dt> </dl> </td> <td width="60%"> The
///    requested operation cannot be carried out because the handle supplied is not in the correct state. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td width="60%"> The
///    type of handle supplied is incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has occurred. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough
///    memory was available to complete the requested operation. (Windows error code) </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One or more of the timeout parameters
///    has a negative value other than -1. </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpSetTimeouts(void* hInternet, int nResolveTimeout, int nConnectTimeout, int nSendTimeout, 
                        int nReceiveTimeout);

///The <b>WinHttpOpenRequest</b> function creates an HTTP request handle.
///Params:
///    hConnect = HINTERNET connection handle to an HTTP session returned by WinHttpConnect.
///    pwszVerb = Pointer to a string that contains the HTTP verb to use in the request. If this parameter is <b>NULL</b>, the
///               function uses GET as the <i>HTTP verb</i>. <b>Note</b> This string should be all uppercase. Many servers treat
///               HTTP verbs as case-sensitive, and the Internet Engineering Task Force (IETF) Requests for Comments (RFCs) spell
///               these verbs using uppercase characters only.
///    pwszObjectName = Pointer to a string that contains the name of the target resource of the specified HTTP verb. This is generally a
///                     file name, an executable module, or a search specifier.
///    pwszVersion = Pointer to a string that contains the HTTP version. If this parameter is <b>NULL</b>, the function uses HTTP/1.1.
///    pwszReferrer = Pointer to a string that specifies the URL of the document from which the URL in the request
///                   <i>pwszObjectName</i> was obtained. If this parameter is set to <b>WINHTTP_NO_REFERER</b>, no referring document
///                   is specified.
///    ppwszAcceptTypes = Pointer to a <b>null</b>-terminated array of string pointers that specifies media types accepted by the client.
///                       If this parameter is set to <b>WINHTTP_DEFAULT_ACCEPT_TYPES</b>, no types are accepted by the client. Typically,
///                       servers handle a lack of accepted types as indication that the client accepts only documents of type "text/*";
///                       that is, only text documents—no pictures or other binary files. For a list of valid media types, see Media
///                       Types defined by IANA at http://www.iana.org/assignments/media-types/.
///    dwFlags = Unsigned long integer value that contains the Internet flag values. This can be one or more of the following
///              values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="WINHTTP_FLAG_BYPASS_PROXY_CACHE"></a><a id="winhttp_flag_bypass_proxy_cache"></a><dl>
///              <dt><b>WINHTTP_FLAG_BYPASS_PROXY_CACHE</b></dt> </dl> </td> <td width="60%"> This flag provides the same behavior
///              as <b>WINHTTP_FLAG_REFRESH</b>. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_FLAG_ESCAPE_DISABLE"></a><a
///              id="winhttp_flag_escape_disable"></a><dl> <dt><b>WINHTTP_FLAG_ESCAPE_DISABLE</b></dt> </dl> </td> <td
///              width="60%"> Unsafe characters in the URL passed in for <i>pwszObjectName</i> are not converted to escape
///              sequences. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_FLAG_ESCAPE_DISABLE_QUERY"></a><a
///              id="winhttp_flag_escape_disable_query"></a><dl> <dt><b>WINHTTP_FLAG_ESCAPE_DISABLE_QUERY</b></dt> </dl> </td> <td
///              width="60%"> Unsafe characters in the query component of the URL passed in for <i>pwszObjectName</i> are not
///              converted to escape sequences. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_FLAG_ESCAPE_PERCENT"></a><a
///              id="winhttp_flag_escape_percent"></a><dl> <dt><b>WINHTTP_FLAG_ESCAPE_PERCENT</b></dt> </dl> </td> <td
///              width="60%"> The string passed in for <i>pwszObjectName</i> is converted from an <b>LPCWSTR</b> to an
///              <b>LPSTR</b>. All unsafe characters are converted to an escape sequence including the percent symbol. By default,
///              all unsafe characters except the percent symbol are converted to an escape sequence. </td> </tr> <tr> <td
///              width="40%"><a id="WINHTTP_FLAG_NULL_CODEPAGE"></a><a id="winhttp_flag_null_codepage"></a><dl>
///              <dt><b>WINHTTP_FLAG_NULL_CODEPAGE</b></dt> </dl> </td> <td width="60%"> The string passed in for
///              <i>pwszObjectName</i> is assumed to consist of valid ANSI characters represented by <b>WCHAR</b>. No check are
///              done for unsafe characters. <b>Windows 7: </b>This option is obsolete. </td> </tr> <tr> <td width="40%"><a
///              id="WINHTTP_FLAG_REFRESH"></a><a id="winhttp_flag_refresh"></a><dl> <dt><b>WINHTTP_FLAG_REFRESH</b></dt> </dl>
///              </td> <td width="60%"> Indicates that the request should be forwarded to the originating server rather than
///              sending a cached version of a resource from a proxy server. When this flag is used, a "Pragma: no-cache" header
///              is added to the request handle. When creating an HTTP/1.1 request header, a "Cache-Control: no-cache" is also
///              added. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_FLAG_SECURE"></a><a id="winhttp_flag_secure"></a><dl>
///              <dt><b>WINHTTP_FLAG_SECURE</b></dt> </dl> </td> <td width="60%"> Uses secure transaction semantics. This
///              translates to using Secure Sockets Layer (SSL)/Transport Layer Security (TLS). </td> </tr> </table>
///Returns:
///    Returns a valid HTTP request handle if successful, or <b>NULL</b> if not. For extended error information, call
///    GetLastError. Among the error codes returned are the following. <table> <tr> <th>Error Code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl>
///    </td> <td width="60%"> The type of handle supplied is incorrect for this operation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has
///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INVALID_URL</b></dt> </dl> </td> <td
///    width="60%"> The URL is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_OPERATION_CANCELLED</b></dt> </dl> </td> <td width="60%"> The operation was canceled,
///    usually because the handle on which the request was operating was closed before the operation completed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b></dt> </dl> </td> <td width="60%">
///    The URL specified a scheme other than "http:" or "https:". </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory was available to complete
///    the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
void* WinHttpOpenRequest(void* hConnect, const(PWSTR) pwszVerb, const(PWSTR) pwszObjectName, 
                         const(PWSTR) pwszVersion, const(PWSTR) pwszReferrer, PWSTR* ppwszAcceptTypes, uint dwFlags);

///The <b>WinHttpAddRequestHeaders</b> function adds one or more HTTP request headers to the HTTP request handle.
///Params:
///    hRequest = A HINTERNET handle returned by a call to the WinHttpOpenRequest function.
///    lpszHeaders = A pointer to a string variable that contains the headers to append to the request. Each header except the last
///                  must be terminated by a carriage return/line feed (CR/LF).
///    dwHeadersLength = An unsigned long integer value that contains the length, in characters, of <i>pwszHeaders</i>. If this parameter
///                      is -1L, the function assumes that <i>pwszHeaders</i> is zero-terminated (ASCIIZ), and the length is computed.
///    dwModifiers = An unsigned long integer value that contains the flags used to modify the semantics of this function. Can be one
///                  or more of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="WINHTTP_ADDREQ_FLAG_ADD"></a><a id="winhttp_addreq_flag_add"></a><dl> <dt><b>WINHTTP_ADDREQ_FLAG_ADD</b></dt>
///                  </dl> </td> <td width="60%"> Adds the header if it does not exist. Used with <b>WINHTTP_ADDREQ_FLAG_REPLACE</b>.
///                  </td> </tr> <tr> <td width="40%"><a id="WINHTTP_ADDREQ_FLAG_ADD_IF_NEW"></a><a
///                  id="winhttp_addreq_flag_add_if_new"></a><dl> <dt><b>WINHTTP_ADDREQ_FLAG_ADD_IF_NEW</b></dt> </dl> </td> <td
///                  width="60%"> Adds the header only if it does not already exist; otherwise, an error is returned. </td> </tr> <tr>
///                  <td width="40%"><a id="WINHTTP_ADDREQ_FLAG_COALESCE"></a><a id="winhttp_addreq_flag_coalesce"></a><dl>
///                  <dt><b>WINHTTP_ADDREQ_FLAG_COALESCE</b></dt> </dl> </td> <td width="60%"> Merges headers of the same name. </td>
///                  </tr> <tr> <td width="40%"><a id="WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA"></a><a
///                  id="winhttp_addreq_flag_coalesce_with_comma"></a><dl> <dt><b>WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA</b></dt>
///                  </dl> </td> <td width="60%"> Merges headers of the same name using a comma. For example, adding "Accept: text/*"
///                  followed by "Accept: audio/*" with this flag results in a single header "Accept: text/*, audio/*". This causes
///                  the first header found to be merged. The calling application must to ensure a cohesive scheme with respect to
///                  merged and separate headers. </td> </tr> <tr> <td width="40%"><a
///                  id="WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON"></a><a id="winhttp_addreq_flag_coalesce_with_semicolon"></a><dl>
///                  <dt><b>WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON</b></dt> </dl> </td> <td width="60%"> Merges headers of the
///                  same name using a semicolon. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_ADDREQ_FLAG_REPLACE"></a><a
///                  id="winhttp_addreq_flag_replace"></a><dl> <dt><b>WINHTTP_ADDREQ_FLAG_REPLACE</b></dt> </dl> </td> <td
///                  width="60%"> Replaces or removes a header. If the header value is empty and the header is found, it is removed.
///                  If the value is not empty, it is replaced. </td> </tr> </table>
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call GetLastError.
///    Among the error codes returned are the following. <table> <tr> <th>Error Code</th> <th>Description</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b></dt> </dl> </td> <td width="60%"> The
///    requested operation cannot be performed because the handle supplied is not in the correct state. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td width="60%"> The type
///    of handle supplied is incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has occurred. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough
///    memory was available to complete the requested operation. </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpAddRequestHeaders(void* hRequest, const(PWSTR) lpszHeaders, uint dwHeadersLength, uint dwModifiers);

@DllImport("WINHTTP")
uint WinHttpAddRequestHeadersEx(void* hRequest, uint dwModifiers, ulong ullFlags, ulong ullExtra, uint cHeaders, 
                                WINHTTP_EXTENDED_HEADER* pHeaders);

///The <b>WinHttpSendRequest</b> function sends the specified request to the HTTP server.
///Params:
///    hRequest = An HINTERNET handle returned by WinHttpOpenRequest.
///    lpszHeaders = A pointer to a string that contains the additional headers to append to the request. This parameter can be
///                  <b>WINHTTP_NO_ADDITIONAL_HEADERS</b> if there are no additional headers to append.
///    dwHeadersLength = An unsigned long integer value that contains the length, in characters, of the additional headers. If this
///                      parameter is <b>-1L</b> and <i>pwszHeaders</i> is not <b>NULL</b>, this function assumes that <i>pwszHeaders</i>
///                      is <b>null</b>-terminated, and the length is calculated.
///    lpOptional = A pointer to a buffer that contains any optional data to send immediately after the request headers. This
///                 parameter is generally used for POST and PUT operations. The optional data can be the resource or data posted to
///                 the server. This parameter can be <b>WINHTTP_NO_REQUEST_DATA</b> if there is no optional data to send. If the
///                 <i>dwOptionalLength</i> parameter is 0, this parameter is ignored and set to <b>NULL</b>. This buffer must remain
///                 available until the request handle is closed or the call to WinHttpReceiveResponse has completed.
///    dwOptionalLength = An unsigned long integer value that contains the length, in bytes, of the optional data. This parameter can be
///                       zero if there is no optional data to send. This parameter must contain a valid length when the <i>lpOptional</i>
///                       parameter is not <b>NULL</b>. Otherwise, <i>lpOptional</i> is ignored and set to <b>NULL</b>.
///    dwTotalLength = An unsigned long integer value that contains the length, in bytes, of the total data sent. This parameter
///                    specifies the Content-Length header of the request. If the value of this parameter is greater than the length
///                    specified by <i>dwOptionalLength</i>, then WinHttpWriteData can be used to send additional data.
///                    <i>dwTotalLength</i> must not change between calls to <b>WinHttpSendRequest</b> for the same request. If
///                    <i>dwTotalLength</i> needs to be changed, the caller should create a new request.
///    dwContext = A pointer to a pointer-sized variable that contains an application-defined value that is passed, with the request
///                handle, to any callback functions.
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call GetLastError.
///    Error codes are listed in the following table. <table> <tr> <th>Error Code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_CANNOT_CONNECT</b></dt> </dl> </td> <td width="60%"> Returned if
///    connection to the server failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED</b></dt> </dl> </td> <td width="60%"> The secure HTTP server
///    requires a client certificate. The application retrieves the list of certificate issuers by calling
///    WinHttpQueryOption with the <b>WINHTTP_OPTION_CLIENT_CERT_ISSUER_LIST</b> option. If the server requests the
///    client certificate, but does not require it, the application can alternately call WinHttpSetOption with the
///    <b>WINHTTP_OPTION_CLIENT_CERT_CONTEXT</b> option. In this case, the application specifies the
///    WINHTTP_NO_CLIENT_CERT_CONTEXT macro in the <i>lpBuffer</i> parameter of <b>WinHttpSetOption</b>. For more
///    information, see the <b>WINHTTP_OPTION_CLIENT_CERT_CONTEXT</b> option.<b>Windows Server 2003 with SP1, Windows XP
///    with SP2 and Windows 2000: </b>This error is not supported. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_CONNECTION_ERROR</b></dt> </dl> </td> <td width="60%"> The connection with the server has
///    been reset or terminated, or an incompatible SSL protocol was encountered. For example, WinHTTP version 5.1 does
///    not support SSL2 unless the client specifically enables it. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b></dt> </dl> </td> <td width="60%"> The requested operation cannot
///    be carried out because the handle supplied is not in the correct state. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td width="60%"> The type of handle supplied is
///    incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt>
///    </dl> </td> <td width="60%"> An internal error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INVALID_URL</b></dt> </dl> </td> <td width="60%"> The URL is invalid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_WINHTTP_LOGIN_FAILURE</b></dt> </dl> </td> <td width="60%"> The login attempt
///    failed. When this error is encountered, the request handle should be closed with WinHttpCloseHandle. A new
///    request handle must be created before retrying the function that originally produced this error. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_NAME_NOT_RESOLVED</b></dt> </dl> </td> <td width="60%"> The server
///    name cannot be resolved. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_OPERATION_CANCELLED</b></dt>
///    </dl> </td> <td width="60%"> The operation was canceled, usually because the handle on which the request was
///    operating was closed before the operation completed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_RESPONSE_DRAIN_OVERFLOW</b></dt> </dl> </td> <td width="60%"> Returned when an incoming
///    response exceeds an internal WinHTTP size limit. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_SECURE_FAILURE</b></dt> </dl> </td> <td width="60%"> One or more errors were found in the
///    Secure Sockets Layer (SSL) certificate sent by the server. To determine what type of error was encountered,
///    verify through a WINHTTP_CALLBACK_STATUS_SECURE_FAILURE notification in a status callback function. For more
///    information, see WINHTTP_STATUS_CALLBACK. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The WinHTTP function support is shut down or
///    unloaded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_TIMEOUT</b></dt> </dl> </td> <td
///    width="60%"> The request timed out. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b></dt> </dl> </td> <td width="60%"> The URL specified a scheme other
///    than "http:" or "https:". </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl>
///    </td> <td width="60%"> Not enough memory was available to complete the requested operation. (Windows error code)
///    <b>Windows Server 2003, Windows XP and Windows 2000: </b>The TCP reservation range set with the
///    <b>WINHTTP_OPTION_PORT_RESERVATION</b> option is not large enough to send this request. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The content length
///    specified in the <i>dwTotalLength</i> parameter does not match the length specified in the Content-Length header.
///    The <i>lpOptional</i> parameter must be <b>NULL</b> and the <i>dwOptionalLength</i> parameter must be zero when
///    the Transfer-Encoding header is present. The Content-Length header cannot be present when the Transfer-Encoding
///    header is present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b> ERROR_WINHTTP_RESEND_REQUEST</b></dt> </dl>
///    </td> <td width="60%"> The application must call WinHttpSendRequest again due to a redirect or authentication
///    challenge. <b>Windows Server 2003 with SP1, Windows XP with SP2 and Windows 2000: </b>This error is not
///    supported. </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpSendRequest(void* hRequest, const(PWSTR) lpszHeaders, uint dwHeadersLength, void* lpOptional, 
                        uint dwOptionalLength, uint dwTotalLength, size_t dwContext);

///The <b>WinHttpSetCredentials</b> function passes the required authorization credentials to the server.
///Params:
///    hRequest = Valid HINTERNET handle returned by WinHttpOpenRequest.
///    AuthTargets = An unsigned integer that specifies a flag that contains the authentication target. Can be one of the values in
///                  the following table. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="WINHTTP_AUTH_TARGET_SERVER"></a><a id="winhttp_auth_target_server"></a><dl>
///                  <dt><b>WINHTTP_AUTH_TARGET_SERVER</b></dt> </dl> </td> <td width="60%"> Credentials are passed to a server. </td>
///                  </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_TARGET_PROXY"></a><a id="winhttp_auth_target_proxy"></a><dl>
///                  <dt><b>WINHTTP_AUTH_TARGET_PROXY</b></dt> </dl> </td> <td width="60%"> Credentials are passed to a proxy. </td>
///                  </tr> </table>
///    AuthScheme = An unsigned integer that specifies a flag that contains the authentication scheme. Must be one of the supported
///                 authentication schemes returned from WinHttpQueryAuthSchemes. The following table identifies the possible values.
///                 <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_BASIC"></a><a
///                 id="winhttp_auth_scheme_basic"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_BASIC</b></dt> </dl> </td> <td width="60%">
///                 Use basic authentication. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_NTLM"></a><a
///                 id="winhttp_auth_scheme_ntlm"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_NTLM</b></dt> </dl> </td> <td width="60%"> Use
///                 NTLM authentication. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_PASSPORT"></a><a
///                 id="winhttp_auth_scheme_passport"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_PASSPORT</b></dt> </dl> </td> <td
///                 width="60%"> Use passport authentication. </td> </tr> <tr> <td width="40%"><a
///                 id="WINHTTP_AUTH_SCHEME_DIGEST"></a><a id="winhttp_auth_scheme_digest"></a><dl>
///                 <dt><b>WINHTTP_AUTH_SCHEME_DIGEST</b></dt> </dl> </td> <td width="60%"> Use digest authentication. </td> </tr>
///                 <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_NEGOTIATE"></a><a id="winhttp_auth_scheme_negotiate"></a><dl>
///                 <dt><b>WINHTTP_AUTH_SCHEME_NEGOTIATE</b></dt> </dl> </td> <td width="60%"> Selects between NTLM and Kerberos
///                 authentication. </td> </tr> </table>
///    pwszUserName = Pointer to a string that contains a valid user name.
///    pwszPassword = Pointer to a string that contains a valid password. The password can be blank.
///    pAuthParams = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call GetLastError.
///    The following table identifies the error codes returned. <table> <tr> <th>Error Code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b></dt> </dl> </td> <td
///    width="60%"> The requested operation cannot be carried out because the handle supplied is not in the correct
///    state. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td
///    width="60%"> The type of handle supplied is incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has occurred. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough
///    memory was available to complete the requested operation (Windows error code). </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpSetCredentials(void* hRequest, uint AuthTargets, uint AuthScheme, const(PWSTR) pwszUserName, 
                           const(PWSTR) pwszPassword, void* pAuthParams);

///The <b>WinHttpQueryAuthSchemes</b> function returns the authorization schemes that are supported by the server.
///Params:
///    hRequest = Valid HINTERNET handle returned by WinHttpOpenRequest
///    lpdwSupportedSchemes = An unsigned integer that specifies a flag that contains the supported authentication schemes. This parameter can
///                           return one or more flags that are identified in the following table. <table> <tr> <th>Value</th> <th>Meaning</th>
///                           </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_BASIC"></a><a id="winhttp_auth_scheme_basic"></a><dl>
///                           <dt><b>WINHTTP_AUTH_SCHEME_BASIC</b></dt> </dl> </td> <td width="60%"> Indicates basic authentication is
///                           available. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_NTLM"></a><a
///                           id="winhttp_auth_scheme_ntlm"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_NTLM</b></dt> </dl> </td> <td width="60%">
///                           Indicates NTLM authentication is available. </td> </tr> <tr> <td width="40%"><a
///                           id="WINHTTP_AUTH_SCHEME_PASSPORT"></a><a id="winhttp_auth_scheme_passport"></a><dl>
///                           <dt><b>WINHTTP_AUTH_SCHEME_PASSPORT</b></dt> </dl> </td> <td width="60%"> Indicates passport authentication is
///                           available. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_DIGEST"></a><a
///                           id="winhttp_auth_scheme_digest"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_DIGEST</b></dt> </dl> </td> <td width="60%">
///                           Indicates digest authentication is available. </td> </tr> <tr> <td width="40%"><a
///                           id="WINHTTP_AUTH_SCHEME_NEGOTIATE"></a><a id="winhttp_auth_scheme_negotiate"></a><dl>
///                           <dt><b>WINHTTP_AUTH_SCHEME_NEGOTIATE</b></dt> </dl> </td> <td width="60%"> Selects between NTLM and Kerberos
///                           authentication. </td> </tr> </table>
///    lpdwFirstScheme = An unsigned integer that specifies a flag that contains the first authentication scheme listed by the server.
///                      This parameter can return one or more flags that are identified in the following table. <table> <tr>
///                      <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_BASIC"></a><a
///                      id="winhttp_auth_scheme_basic"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_BASIC</b></dt> </dl> </td> <td width="60%">
///                      Indicates basic authentication is first. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_NTLM"></a><a
///                      id="winhttp_auth_scheme_ntlm"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_NTLM</b></dt> </dl> </td> <td width="60%">
///                      Indicates NTLM authentication is first. </td> </tr> <tr> <td width="40%"><a
///                      id="WINHTTP_AUTH_SCHEME_PASSPORT"></a><a id="winhttp_auth_scheme_passport"></a><dl>
///                      <dt><b>WINHTTP_AUTH_SCHEME_PASSPORT</b></dt> </dl> </td> <td width="60%"> Indicates passport authentication is
///                      first. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTH_SCHEME_DIGEST"></a><a
///                      id="winhttp_auth_scheme_digest"></a><dl> <dt><b>WINHTTP_AUTH_SCHEME_DIGEST</b></dt> </dl> </td> <td width="60%">
///                      Indicates digest authentication is first. </td> </tr> <tr> <td width="40%"><a
///                      id="WINHTTP_AUTH_SCHEME_NEGOTIATE"></a><a id="winhttp_auth_scheme_negotiate"></a><dl>
///                      <dt><b>WINHTTP_AUTH_SCHEME_NEGOTIATE</b></dt> </dl> </td> <td width="60%"> Selects between NTLM and Kerberos
///                      authentication. </td> </tr> </table>
///    pdwAuthTarget = An unsigned integer that specifies a flag that contains the authentication target. This parameter can return one
///                    or more flags that are identified in the following table. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                    <td width="40%"><a id="WINHTTP_AUTH_TARGET_SERVER"></a><a id="winhttp_auth_target_server"></a><dl>
///                    <dt><b>WINHTTP_AUTH_TARGET_SERVER</b></dt> </dl> </td> <td width="60%"> Authentication target is a server.
///                    Indicates that a 401 status code has been received. </td> </tr> <tr> <td width="40%"><a
///                    id="WINHTTP_AUTH_TARGET_PROXY"></a><a id="winhttp_auth_target_proxy"></a><dl>
///                    <dt><b>WINHTTP_AUTH_TARGET_PROXY</b></dt> </dl> </td> <td width="60%"> Authentication target is a proxy.
///                    Indicates that a 407 status code has been received. </td> </tr> </table>
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> if unsuccessful. To get extended error information, call
///    GetLastError. The following table identifies the error codes that are returned. <table> <tr> <th>Error Code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl>
///    </td> <td width="60%"> The type of handle supplied is incorrect for this operation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has
///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td
///    width="60%"> Not enough memory was available to complete the requested operation. (Windows error code) </td>
///    </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpQueryAuthSchemes(void* hRequest, uint* lpdwSupportedSchemes, uint* lpdwFirstScheme, 
                             uint* pdwAuthTarget);

///The <b>WinHttpReceiveResponse</b> function waits to receive the response to an HTTP request initiated by
///WinHttpSendRequest. When <b>WinHttpReceiveResponse</b> completes successfully, the status code and response headers
///have been received and are available for the application to inspect using WinHttpQueryHeaders. An application must
///call <b>WinHttpReceiveResponse</b> before it can use WinHttpQueryDataAvailable and WinHttpReadData to access the
///response entity body (if any).
///Params:
///    hRequest = HINTERNET handle returned by WinHttpOpenRequest and sent by WinHttpSendRequest. Wait until
///               <b>WinHttpSendRequest</b> has completed for this handle before calling <b>WinHttpReceiveResponse</b>.
///    lpReserved = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call GetLastError.
///    Among the error codes returned are the following. <table> <tr> <th>Error Code</th> <th>Description</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_CANNOT_CONNECT</b></dt> </dl> </td> <td width="60%"> Returned if
///    connection to the server failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_CHUNKED_ENCODING_HEADER_SIZE_OVERFLOW</b></dt> </dl> </td> <td width="60%"> Returned when an
///    overflow condition is encountered in the course of parsing chunked encoding. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED</b></dt> </dl> </td> <td width="60%"> Returned when the server
///    requests client authentication. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_CONNECTION_ERROR</b></dt> </dl> </td> <td width="60%"> The connection with the server has
///    been reset or terminated, or an incompatible SSL protocol was encountered. For example, WinHTTP version 5.1 does
///    not support SSL2 unless the client specifically enables it. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_HEADER_COUNT_EXCEEDED</b></dt> </dl> </td> <td width="60%"> Returned when a larger number of
///    headers were present in a response than WinHTTP could receive. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_HEADER_SIZE_OVERFLOW</b></dt> </dl> </td> <td width="60%"> Returned by
///    WinHttpReceiveResponse when the size of headers received exceeds the limit for the request handle. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b></dt> </dl> </td> <td width="60%"> The
///    requested operation cannot be carried out because the handle supplied is not in the correct state. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td width="60%"> The
///    type of handle supplied is incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error has occurred. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INVALID_SERVER_RESPONSE</b></dt> </dl> </td> <td
///    width="60%"> The server response could not be parsed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INVALID_URL</b></dt> </dl> </td> <td width="60%"> The URL is invalid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_WINHTTP_LOGIN_FAILURE</b></dt> </dl> </td> <td width="60%"> The login attempt
///    failed. When this error is encountered, the request handle should be closed with WinHttpCloseHandle. A new
///    request handle must be created before retrying the function that originally produced this error. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_NAME_NOT_RESOLVED</b></dt> </dl> </td> <td width="60%"> The server
///    name could not be resolved. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_OPERATION_CANCELLED</b></dt> </dl> </td> <td width="60%"> The operation was canceled,
///    usually because the handle on which the request was operating was closed before the operation completed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_REDIRECT_FAILED</b></dt> </dl> </td> <td width="60%"> The
///    redirection failed because either the scheme changed or all attempts made to redirect failed (default is five
///    attempts). </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_RESEND_REQUEST</b></dt> </dl> </td> <td
///    width="60%"> The WinHTTP function failed. The desired function can be retried on the same request handle. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_RESPONSE_DRAIN_OVERFLOW</b></dt> </dl> </td> <td
///    width="60%"> Returned when an incoming response exceeds an internal WinHTTP size limit. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_WINHTTP_SECURE_FAILURE</b></dt> </dl> </td> <td width="60%"> One or more errors
///    were found in the Secure Sockets Layer (SSL) certificate sent by the server. To determine what type of error was
///    encountered, check for a WINHTTP_CALLBACK_STATUS_SECURE_FAILURE notification in a status callback function. For
///    more information, see WINHTTP_STATUS_CALLBACK. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The request has timed out. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b></dt> </dl> </td> <td width="60%"> The URL
///    specified a scheme other than "http:" or "https:". </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory was available to complete
///    the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpReceiveResponse(void* hRequest, void* lpReserved);

///The <b>WinHttpQueryHeaders</b> function retrieves header information associated with an HTTP request.
///Params:
///    hRequest = HINTERNET request handle returned by WinHttpOpenRequest. WinHttpReceiveResponse must have been called for this
///               handle and have completed before <b>WinHttpQueryHeaders</b> is called.
///    dwInfoLevel = Value of type <b>DWORD</b> that specifies a combination of attribute and modifier flags listed on the Query Info
///                  Flags page. These attribute and modifier flags indicate that the information is being requested and how it is to
///                  be formatted.
///    pwszName = Pointer to a string that contains the header name. If the flag in <i>dwInfoLevel</i> is not
///               <b>WINHTTP_QUERY_CUSTOM</b>, set this parameter to WINHTTP_HEADER_NAME_BY_INDEX.
///    lpBuffer = Pointer to the buffer that receives the information. Setting this parameter to WINHTTP_NO_OUTPUT_BUFFER causes
///               this function to return <b>FALSE</b>. Calling GetLastError then returns <b>ERROR_INSUFFICIENT_BUFFER</b> and
///               <i>lpdwBufferLength</i> contains the number of bytes required to hold the requested information.
///    lpdwBufferLength = Pointer to a value of type <b>DWORD</b> that specifies the length of the data buffer, in bytes. When the function
///                       returns, this parameter contains the pointer to a value that specifies the length of the information written to
///                       the buffer. When the function returns strings, the following rules apply. <ul> <li>If the function succeeds,
///                       <i>lpdwBufferLength</i> specifies the length of the string, in bytes, minus 2 for the terminating null. </li>
///                       <li>If the function fails and <b>ERROR_INSUFFICIENT_BUFFER</b> is returned, <i>lpdwBufferLength</i> specifies the
///                       number of bytes that the application must allocate to receive the string. </li> </ul>
///    lpdwIndex = Pointer to a zero-based header index used to enumerate multiple headers with the same name. When calling the
///                function, this parameter is the index of the specified header to return. When the function returns, this
///                parameter is the index of the next header. If the next index cannot be found,
///                <b>ERROR_WINHTTP_HEADER_NOT_FOUND</b> is returned. Set this parameter to WINHTTP_NO_HEADER_INDEX to specify that
///                only the first occurrence of a header should be returned.
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. To get extended error information, call
///    GetLastError. Among the error codes returned are the following. <table> <tr> <th>Error Code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_HEADER_NOT_FOUND</b></dt> </dl> </td>
///    <td width="60%"> The requested header could not be located. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_STATE</b></dt> </dl> </td> <td width="60%"> The requested operation cannot
///    be carried out because the handle supplied is not in the correct state. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td width="60%"> The type of handle supplied is
///    incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt>
///    </dl> </td> <td width="60%"> An internal error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory was available to complete
///    the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpQueryHeaders(void* hRequest, uint dwInfoLevel, const(PWSTR) pwszName, void* lpBuffer, 
                         uint* lpdwBufferLength, uint* lpdwIndex);

///The <b>WinHttpDetectAutoProxyConfigUrl</b> function finds the URL for the Proxy Auto-Configuration (PAC) file. This
///function reports the URL of the PAC file, but it does not download the file.
///Params:
///    dwAutoDetectFlags = A data type that specifies what protocols to use to locate the PAC file. If both the DHCP and DNS auto detect
///                        flags are set, DHCP is used first; if no PAC URL is discovered using DHCP, then DNS is used. <table> <tr>
///                        <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="WINHTTP_AUTO_DETECT_TYPE_DHCP"></a><a
///                        id="winhttp_auto_detect_type_dhcp"></a><dl> <dt><b>WINHTTP_AUTO_DETECT_TYPE_DHCP</b></dt> </dl> </td> <td
///                        width="60%"> Use DHCP to locate the proxy auto-configuration file. </td> </tr> <tr> <td width="40%"><a
///                        id="WINHTTP_AUTO_DETECT_TYPE_DNS_A"></a><a id="winhttp_auto_detect_type_dns_a"></a><dl>
///                        <dt><b>WINHTTP_AUTO_DETECT_TYPE_DNS_A</b></dt> </dl> </td> <td width="60%"> Use DNS to attempt to locate the
///                        proxy auto-configuration file at a well-known location on the domain of the local computer. </td> </tr> </table>
///    ppwstrAutoConfigUrl = A data type that returns a pointer to a null-terminated Unicode string that contains the configuration URL that
///                          receives the proxy data. You must free the string pointed to by <i>ppwszAutoConfigUrl</i> using the GlobalFree
///                          function.
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call GetLastError.
///    Among the error codes returned are the following. <table> <tr> <th>Error Code</th> <th>Description</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_AUTODETECTION_FAILED</b></dt> </dl> </td> <td width="60%">
///    Returned if WinHTTP was unable to discover the URL of the Proxy Auto-Configuration (PAC) file. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error
///    has occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td
///    width="60%"> Not enough memory was available to complete the requested operation. (Windows error code) </td>
///    </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpDetectAutoProxyConfigUrl(uint dwAutoDetectFlags, PWSTR* ppwstrAutoConfigUrl);

///The <b>WinHttpGetProxyForUrl</b> function retrieves the proxy data for the specified URL.
///Params:
///    hSession = The WinHTTP session handle returned by the WinHttpOpen function.
///    lpcwszUrl = A pointer to a null-terminated Unicode string that contains the URL of the HTTP request that the application is
///                preparing to send.
///    pAutoProxyOptions = A pointer to a WINHTTP_AUTOPROXY_OPTIONS structure that specifies the auto-proxy options to use.
///    pProxyInfo = A pointer to a WINHTTP_PROXY_INFO structure that receives the proxy setting. This structure is then applied to
///                 the request handle using the WINHTTP_OPTION_PROXY option. Free the <b>lpszProxy</b> and <b>lpszProxyBypass</b>
///                 strings contained in this structure (if they are non-NULL) using the GlobalFree function.
///Returns:
///    If the function succeeds, the function returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>. For
///    extended error data, call GetLastError. Possible error codes include the folllowing. <table> <tr> <th>Error
///    Code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR</b></dt> </dl> </td> <td width="60%"> Returned by
///    WinHttpGetProxyForUrl when a proxy for the specified URL cannot be located. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT</b></dt> </dl> </td> <td width="60%"> An error occurred executing
///    the script code in the Proxy Auto-Configuration (PAC) file. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td width="60%"> The type of handle supplied is
///    incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt>
///    </dl> </td> <td width="60%"> An internal error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INVALID_URL</b></dt> </dl> </td> <td width="60%"> The URL is invalid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_WINHTTP_LOGIN_FAILURE</b></dt> </dl> </td> <td width="60%"> The login attempt
///    failed. When this error is encountered, close the request handle with WinHttpCloseHandle. A new request handle
///    must be created before retrying the function that originally produced this error. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_WINHTTP_OPERATION_CANCELLED</b></dt> </dl> </td> <td width="60%"> The operation
///    was canceled, usually because the handle on which the request was operating was closed before the operation
///    completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT</b></dt> </dl>
///    </td> <td width="60%"> The PAC file could not be downloaded. For example, the server referenced by the PAC URL
///    may not have been reachable, or the server returned a 404 NOT FOUND response. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b></dt> </dl> </td> <td width="60%"> The URL of the PAC file
///    specified a scheme other than "http:" or "https:". </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory was available to complete
///    the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpGetProxyForUrl(void* hSession, const(PWSTR) lpcwszUrl, WINHTTP_AUTOPROXY_OPTIONS* pAutoProxyOptions, 
                           WINHTTP_PROXY_INFO* pProxyInfo);

///The <b>WinHttpCreateProxyResolver</b> function creates a handle for use by WinHttpGetProxyForUrlEx.
///Params:
///    hSession = Valid HINTERNET WinHTTP session handle returned by a previous call to WinHttpOpen. The session handle must be
///               opened using <b>WINHTTP_FLAG_ASYNC</b>.
///    phResolver = A pointer to a new handle for use by WinHttpGetProxyForUrlEx. When finished or cancelling an outstanding
///                 operation, close this handle with WinHttpCloseHandle.
@DllImport("WINHTTP")
uint WinHttpCreateProxyResolver(void* hSession, void** phResolver);

///The <b>WinHttpGetProxyForUrlEx</b> function retrieves the proxy data for the specified URL.
///Params:
///    hResolver = The WinHTTP resolver handle returned by the WinHttpCreateProxyResolver function.
///    pcwszUrl = A pointer to a null-terminated Unicode string that contains a URL for which proxy information will be determined.
///    pAutoProxyOptions = A pointer to a WINHTTP_AUTOPROXY_OPTIONS structure that specifies the auto-proxy options to use.
///    pContext = Context data that will be passed to the completion callback function.
///Returns:
///    A status code indicating the result of the operation. <table> <tr> <th>The following codes may be returned.</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_IO_PENDING</b></dt> </dl> </td> <td
///    width="60%"> The operation is continuing asynchronously. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR</b></dt> </dl> </td> <td width="60%"> Returned by
///    WinHttpGetProxyForUrlEx when a proxy for the specified URL cannot be located. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT</b></dt> </dl> </td> <td width="60%"> An error occurred executing
///    the script code in the Proxy Auto-Configuration (PAC) file. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE_TYPE</b></dt> </dl> </td> <td width="60%"> The type of handle supplied is
///    incorrect for this operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INVALID_URL</b></dt>
///    </dl> </td> <td width="60%"> The URL is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_OPERATION_CANCELLED</b></dt> </dl> </td> <td width="60%"> The operation was canceled,
///    usually because the handle on which the request was operating was closed before the operation completed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT</b></dt> </dl> </td> <td
///    width="60%"> The PAC file could not be downloaded. For example, the server referenced by the PAC URL may not have
///    been reachable, or the server returned a 404 NOT FOUND response. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_UNRECOGNIZED_SCHEME</b></dt> </dl> </td> <td width="60%"> The URL of the PAC file specified
///    a scheme other than "http:" or "https:". </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory was available to complete
///    the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
uint WinHttpGetProxyForUrlEx(void* hResolver, const(PWSTR) pcwszUrl, WINHTTP_AUTOPROXY_OPTIONS* pAutoProxyOptions, 
                             size_t pContext);

@DllImport("WINHTTP")
uint WinHttpGetProxyForUrlEx2(void* hResolver, const(PWSTR) pcwszUrl, WINHTTP_AUTOPROXY_OPTIONS* pAutoProxyOptions, 
                              uint cbInterfaceSelectionContext, ubyte* pInterfaceSelectionContext, size_t pContext);

///The <b>WinHttpGetProxyResult</b> function retrieves the results of a call to WinHttpGetProxyForUrlEx.
///Params:
///    hResolver = The resolver handle used to issue a previously completed call to WinHttpGetProxyForUrlEx.
///    pProxyResult = A pointer to a WINHTTP_PROXY_RESULT structure that contains the results of a previous call to
///                   WinHttpGetProxyForUrlEx. The results must be freed by calling WinHttpFreeProxyResult.
@DllImport("WINHTTP")
uint WinHttpGetProxyResult(void* hResolver, WINHTTP_PROXY_RESULT* pProxyResult);

@DllImport("WINHTTP")
uint WinHttpGetProxyResultEx(void* hResolver, WINHTTP_PROXY_RESULT_EX* pProxyResultEx);

///The <b>WinHttpFreeProxyResult</b> function frees the data retrieved from a previous call to WinHttpGetProxyResult.
///Params:
///    pProxyResult = A pointer to a WINHTTP_PROXY_RESULT structure retrieved from a previous call to WinHttpGetProxyResult.
///Returns:
///    This function does not return a value.
///    
@DllImport("WINHTTP")
void WinHttpFreeProxyResult(WINHTTP_PROXY_RESULT* pProxyResult);

@DllImport("WINHTTP")
void WinHttpFreeProxyResultEx(WINHTTP_PROXY_RESULT_EX* pProxyResultEx);

///The <b>WinHttpResetAutoProxy</b> function resets the auto-proxy.
///Params:
///    hSession = A valid HINTERNET WinHTTP session handle returned by a previous call to the WinHttpOpen function.
///    dwFlags = A set of flags that affects the reset operation. The following flags are supported as defined in the
///              <i>Winhttp.h</i> header file. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="WINHTTP_RESET_STATE"></a><a id="winhttp_reset_state"></a><dl> <dt><b>WINHTTP_RESET_STATE</b></dt>
///              <dt>0x00000001</dt> </dl> </td> <td width="60%"> Forces a flush and retry of non-persistent proxy information on
///              the current network. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_RESET_SWPAD_CURRENT_NETWORK"></a><a
///              id="winhttp_reset_swpad_current_network"></a><dl> <dt><b>WINHTTP_RESET_SWPAD_CURRENT_NETWORK</b></dt>
///              <dt>0x00000002</dt> </dl> </td> <td width="60%"> Flush the PAD information for the current network. </td> </tr>
///              <tr> <td width="40%"><a id="WINHTTP_RESET_SWPAD_ALL"></a><a id="winhttp_reset_swpad_all"></a><dl>
///              <dt><b>WINHTTP_RESET_SWPAD_ALL</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Flush the PAD
///              information for all networks. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_RESET_SCRIPT_CACHE"></a><a
///              id="winhttp_reset_script_cache"></a><dl> <dt><b>WINHTTP_RESET_SCRIPT_CACHE</b></dt> <dt>0x00000008</dt> </dl>
///              </td> <td width="60%"> Flush the persistent HTTP cache of proxy scripts. </td> </tr> <tr> <td width="40%"><a
///              id="WINHTTP_RESET_ALL"></a><a id="winhttp_reset_all"></a><dl> <dt><b>WINHTTP_RESET_ALL</b></dt>
///              <dt>0x0000FFFF</dt> </dl> </td> <td width="60%"> Forces a flush and retry of all proxy information on the current
///              network. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_RESET_NOTIFY_NETWORK_CHANGED"></a><a
///              id="winhttp_reset_notify_network_changed"></a><dl> <dt><b>WINHTTP_RESET_NOTIFY_NETWORK_CHANGED</b></dt>
///              <dt>0x00010000</dt> </dl> </td> <td width="60%"> Flush the current proxy information and notify that the network
///              changed. </td> </tr> <tr> <td width="40%"><a id="WINHTTP_RESET_OUT_OF_PROC"></a><a
///              id="winhttp_reset_out_of_proc"></a><dl> <dt><b>WINHTTP_RESET_OUT_OF_PROC</b></dt> <dt>0x00020000</dt> </dl> </td>
///              <td width="60%"> Act on the autoproxy service instead of the current process. <div class="alert"><b>Note</b> This
///              flag is required.</div> <div> </div> Applications that use the WinHttpGetProxyForUrl function to purge in-process
///              caching should close the <i>hInternet</i> handle and open a new handle for future calls. </td> </tr> </table>
///Returns:
///    A code indicating the success or failure of the operation. <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The operation was
///    successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td
///    width="60%"> The <i>hSession</i> parameter is not a valid handle. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_WINHTTP_INCORRECT_HANDLE TYPE</b></dt> </dl> </td> <td width="60%"> The <i>hSession</i> parameter is
///    not the product of a call to WinHttpOpen. </td> </tr> </table>
///    
@DllImport("WINHTTP")
uint WinHttpResetAutoProxy(void* hSession, uint dwFlags);

///The <b>WinHttpGetIEProxyConfigForCurrentUser</b> function retrieves the Internet Explorer proxy configuration for the
///current user.
///Params:
///    pProxyConfig = A pointer, on input, to a WINHTTP_CURRENT_USER_IE_PROXY_CONFIG structure. On output, the structure contains the
///                   Internet Explorer proxy settings for the current active network connection (for example, LAN, dial-up, or VPN
///                   connection).
///Returns:
///    Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. For extended error information, call GetLastError.
///    Among the error codes returned are the following. <table> <tr> <th>Error Code</th> <th>Description</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> No Internet Explorer
///    proxy settings can be found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WINHTTP_INTERNAL_ERROR</b></dt>
///    </dl> </td> <td width="60%"> An internal error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory was available to complete
///    the requested operation. (Windows error code) </td> </tr> </table>
///    
@DllImport("WINHTTP")
BOOL WinHttpGetIEProxyConfigForCurrentUser(WINHTTP_CURRENT_USER_IE_PROXY_CONFIG* pProxyConfig);

@DllImport("WINHTTP")
uint WinHttpWriteProxySettings(void* hSession, BOOL fForceUpdate, WINHTTP_PROXY_SETTINGS* pWinHttpProxySettings);

@DllImport("WINHTTP")
uint WinHttpReadProxySettings(void* hSession, const(PWSTR) pcwszConnectionName, BOOL fFallBackToDefaultSettings, 
                              BOOL fSetAutoDiscoverForDefaultSettings, uint* pdwSettingsVersion, 
                              BOOL* pfDefaultSettingsAreReturned, WINHTTP_PROXY_SETTINGS* pWinHttpProxySettings);

@DllImport("WINHTTP")
void WinHttpFreeProxySettings(WINHTTP_PROXY_SETTINGS* pWinHttpProxySettings);

@DllImport("WINHTTP")
uint WinHttpGetProxySettingsVersion(void* hSession, uint* pdwProxySettingsVersion);

@DllImport("WINHTTP")
uint WinHttpSetProxySettingsPerUser(BOOL fProxySettingsPerUser);

///The <b>WinHttpWebSocketCompleteUpgrade</b> function completes a WebSocket handshake started by WinHttpSendRequest.
///Params:
///    hRequest = Type: <b>HINTERNET</b> HTTP request handle used to send a WebSocket handshake.
///    pContext = Type: <b>DWORD_PTR</b> Context to be associated with the new handle.
///Returns:
///    Type: <b>HINTERNET</b> A new WebSocket handle. If NULL, call GetLastError to determine the cause of failure.
///    
@DllImport("WINHTTP")
void* WinHttpWebSocketCompleteUpgrade(void* hRequest, size_t pContext);

///The <b>WinHttpWebSocketSend</b> function sends data over a WebSocket connection.
///Params:
///    hWebSocket = Type: <b>HINTERNET</b> Handle to a websocket.
///    eBufferType = Type: <b>WINHTTP_WEB_SOCKET_BUFFER_TYPE</b> Type of buffer.<div class="alert"><b>Note</b> Do not specify
///                  <b>WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE</b>. Use WinHttpWebSocketClose or WinHttpWebSocketShutdown to close the
///                  connection.</div> <div> </div>
///    pvBuffer = Type: <b>PVOID</b> Pointer to a buffer containing the data to send. Can be <b>NULL</b> only if
///               <i>dwBufferLength</i> is 0.
///    dwBufferLength = Type: <b>DWORD</b> Length of <i>pvBuffer</i>.
///Returns:
///    Type: <b>DWORD</b> <b>NO_ERROR</b> on success. Otherwise an error code. <table> <tr> <th></th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_OPERATION</b></dt> </dl> </td> <td
///    width="60%"> A close or send is pending, or the send channel has already been closed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> A parameter is invalid.
///    </td> </tr> </table>
///    
@DllImport("WINHTTP")
uint WinHttpWebSocketSend(void* hWebSocket, WINHTTP_WEB_SOCKET_BUFFER_TYPE eBufferType, void* pvBuffer, 
                          uint dwBufferLength);

///The <b>WinHttpWebSocketReceive</b> function receives data from a WebSocket connection.
///Params:
///    hWebSocket = Type: <b>HINTERNET</b> Handle to a WebSocket.
///    pvBuffer = Type: <b>PVOID</b> Pointer to a buffer to receive the data.
///    dwBufferLength = Type: <b>DWORD</b> Length of <i>pvBuffer</i>, in bytes.
///    pdwBytesRead = Type: <b>DWORD*</b> Pointer to a <b>DWORD</b> that receives the number of bytes read from the connection at the
///                   end of the operation. This is set only if <b>WinHttpWebSocketReceive</b> returns <b>NO_ERROR</b> and the handle
///                   was opened in synchronous mode.
///    peBufferType = Type: <b>WINHTTP_WEB_SOCKET_BUFFER_TYPE*</b> The type of a returned buffer. This is only set if
///                   <b>WinHttpWebSocketReceive</b> returns <b>NO_ERROR</b> and the handle was opened in synchronous mode.
@DllImport("WINHTTP")
uint WinHttpWebSocketReceive(void* hWebSocket, void* pvBuffer, uint dwBufferLength, uint* pdwBytesRead, 
                             WINHTTP_WEB_SOCKET_BUFFER_TYPE* peBufferType);

///The <b>WinHttpWebSocketShutdown</b> function sends a close frame to a WebSocket server to close the send channel, but
///leaves the receive channel open.
///Params:
///    hWebSocket = Type: <b>HINTERNET</b> Handle to a WebSocket.<div class="alert"><b>Note</b> <b>WinHttpWebSocketShutdown</b> does
///                 not close this handle. To close the handle, call WinHttpCloseHandle on <i>hWebSocket</i> once it is no longer
///                 needed.</div> <div> </div>
///    usStatus = Type: <b>USHORT</b> A close status code. See WINHTTP_WEB_SOCKET_CLOSE_STATUS for possible values.
///    pvReason = Type: <b>PVOID</b> A detailed reason for the close.
///    dwReasonLength = Type: <b>DWORD</b> The length of <i>pvReason</i>, in bytes. If <i>pvReason</i> is NULL, this must be 0. This
///                     value must be within the range of 0 to 123.
///Returns:
///    Type: <b>DWORD</b> With the following exception, all error codes indicate that the underlying TCP connection has
///    been aborted. <table> <tr> <th></th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_IO_PENDING</b></dt> </dl> </td> <td width="60%"> The operation will complete asynchronously. </td>
///    </tr> </table>
///    
@DllImport("WINHTTP")
uint WinHttpWebSocketShutdown(void* hWebSocket, ushort usStatus, void* pvReason, uint dwReasonLength);

///The <b>WinHttpWebSocketClose</b> function closes a WebSocket connection.
///Params:
///    hWebSocket = Type: <b>HINTERNET</b> Handle to a WebSocket.<div class="alert"><b>Note</b> <b>WinHttpWebSocketClose</b> does not
///                 close this handle. To close the handle, call WinHttpCloseHandle on <i>hWebSocket</i> once it is no longer
///                 needed.</div> <div> </div>
///    usStatus = Type: <b>USHORT</b> A close status code. See WINHTTP_WEB_SOCKET_CLOSE_STATUS for possible values.
///    pvReason = Type: <b>PVOID</b> A detailed reason for the close.
///    dwReasonLength = Type: <b>DWORD</b> The length of <i>pvReason</i>, in bytes. If <i>pvReason</i> is NULL, this must be 0. This
///                     value must be within the range of 0 to 123.
///Returns:
///    Type: <b>DWORD</b> With the following exception, all error codes indicate that the underlying TCP connection has
///    been aborted. <table> <tr> <th></th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_OPERATION</b></dt> </dl> </td> <td width="60%"> A close or send is pending. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> A parameter is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_SERVER_RESPONSE</b></dt> </dl> </td> <td
///    width="60%"> Invalid data was received from the server. </td> </tr> </table>
///    
@DllImport("WINHTTP")
uint WinHttpWebSocketClose(void* hWebSocket, ushort usStatus, void* pvReason, uint dwReasonLength);

///The <b>WinHttpWebSocketQueryCloseStatus</b> function retrieves the close status sent by a server.
///Params:
///    hWebSocket = Type: <b>HINTERNET</b> Handle to a WebSocket
///    pusStatus = Type: <b>USHORT*</b> A pointer to a close status code that will be filled upon return. See
///                WINHTTP_WEB_SOCKET_CLOSE_STATUS for possible values.
///    pvReason = Type: <b>PVOID</b> A pointer to a buffer that will receive a close reason on return.
///    dwReasonLength = Type: <b>DWORD</b> The length of the <i>pvReason</i> buffer, in bytes.
///    pdwReasonLengthConsumed = Type: <b>DWORD*</b> The number of bytes consumed. If <i>pvReason</i> is <b>NULL</b> and <i>dwReasonLength</i> is
///                              0, <i>pdwReasonLengthConsumed</i> will contain the size of the buffer that needs to be allocated by the calling
///                              application.
///Returns:
///    Type: <b>DWORD</b> <b>NO_ERROR</b> on success. Otherwise an error code. <table> <tr> <th></th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt> </dl> </td> <td
///    width="60%"> There is not enough space in <i>pvReason</i> to write the whole close reason. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_OPERATION</b></dt> </dl> </td> <td width="60%"> No close frame has been
///    received yet. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> A parameter is invalid. </td> </tr> </table>
///    
@DllImport("WINHTTP")
uint WinHttpWebSocketQueryCloseStatus(void* hWebSocket, ushort* pusStatus, void* pvReason, uint dwReasonLength, 
                                      uint* pdwReasonLengthConsumed);


