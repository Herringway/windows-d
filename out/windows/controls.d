// Written in the D programming language.

module windows.controls;

public import windows.core;
public import windows.automation : BSTR, IDispatch, VARIANT;
public import windows.com : DVTARGETDEVICE, HRESULT, IDataObject, IDropTarget,
                            IOleClientSite, IOleInPlaceFrame, IOleInPlaceUIWindow,
                            IOleObject, IUnknown, OIFI;
public import windows.direct2d : ID2D1RenderTarget;
public import windows.displaydevices : POINT, RECT, RECTL, SIZE;
public import windows.gdi : BLENDFUNCTION, HBITMAP, HBRUSH, HCURSOR, HDC, HICON,
                            HMONITOR, HPALETTE, HPEN, HRGN, RGBQUAD,
                            TEXTMETRICW;
public import windows.intl : HIMC__;
public import windows.menusandresources : HMENU, POINTER_INPUT_TYPE;
public import windows.pointerinput : POINTER_PEN_INFO, POINTER_TOUCH_INFO;
public import windows.shell : LOGFONTW;
public import windows.structuredstorage : IStorage, IStream;
public import windows.systemservices : BOOL, HANDLE, HINSTANCE, LRESULT, PSTR, PWSTR;
public import windows.windowsaccessibility : IRawElementProviderSimple, IRawElementProviderWindowlessSite,
                                             UiaRect;
public import windows.windowsandmessaging : DLGPROC, DLGTEMPLATE, HWND, LPARAM, WINDOWPOS,
                                            WPARAM;
public import windows.windowsprogramming : HKEY, SYSTEMTIME;

extern(Windows) @nogc nothrow:


// Enums


///Identifies the visual feedback behaviors available to CreateSyntheticPointerDevice.
alias POINTER_FEEDBACK_MODE = int;
enum : int
{
    ///Visual feedback might be suppressed by the user's pen (Settings -&gt; Devices -&gt; Pen &amp; Windows Ink) and
    ///touch (Settings -&gt; Ease of Access -&gt; Cursor &amp; pointer size) settings.
    POINTER_FEEDBACK_DEFAULT  = 0x00000001,
    ///Visual feedback overrides the user's pen and touch settings.
    POINTER_FEEDBACK_INDIRECT = 0x00000002,
    POINTER_FEEDBACK_NONE     = 0x00000003,
}

///Specifies the visual feedback associated with an event.
alias FEEDBACK_TYPE = int;
enum : int
{
    ///Feedback for a touch contact event.
    FEEDBACK_TOUCH_CONTACTVISUALIZATION = 0x00000001,
    ///Feedback for a pen barrel-button event.
    FEEDBACK_PEN_BARRELVISUALIZATION    = 0x00000002,
    ///Feedback for a pen tap event.
    FEEDBACK_PEN_TAP                    = 0x00000003,
    ///Feedback for a pen double-tap event.
    FEEDBACK_PEN_DOUBLETAP              = 0x00000004,
    ///Feedback for a pen press-and-hold event.
    FEEDBACK_PEN_PRESSANDHOLD           = 0x00000005,
    ///Feedback for a pen right-tap event.
    FEEDBACK_PEN_RIGHTTAP               = 0x00000006,
    ///Feedback for a touch tap event.
    FEEDBACK_TOUCH_TAP                  = 0x00000007,
    ///Feedback for a touch double-tap event.
    FEEDBACK_TOUCH_DOUBLETAP            = 0x00000008,
    ///Feedback for a touch press-and-hold event.
    FEEDBACK_TOUCH_PRESSANDHOLD         = 0x00000009,
    ///Feedback for a touch right-tap event.
    FEEDBACK_TOUCH_RIGHTTAP             = 0x0000000a,
    ///Feedback for a press-and-tap gesture.
    FEEDBACK_GESTURE_PRESSANDTAP        = 0x0000000b,
    ///Do not use.
    FEEDBACK_MAX                        = 0xffffffff,
}

///Identifies the pointer device types.
alias POINTER_DEVICE_TYPE = int;
enum : int
{
    ///Direct pen digitizer (integrated into display).
    POINTER_DEVICE_TYPE_INTEGRATED_PEN = 0x00000001,
    ///Indirect pen digitizer (not integrated into display).
    POINTER_DEVICE_TYPE_EXTERNAL_PEN   = 0x00000002,
    ///Touch digitizer.
    POINTER_DEVICE_TYPE_TOUCH          = 0x00000003,
    ///Touchpad digitizer (Windows 8.1 and later).
    POINTER_DEVICE_TYPE_TOUCH_PAD      = 0x00000004,
    ///Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this
    ///enumeration to compile to a size other than 32 bits. You should not use this value.
    POINTER_DEVICE_TYPE_MAX            = 0xffffffff,
}

///Identifies the pointer device cursor types.
alias POINTER_DEVICE_CURSOR_TYPE = int;
enum : int
{
    ///Unidentified cursor.
    POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = 0x00000000,
    ///Pen tip.
    POINTER_DEVICE_CURSOR_TYPE_TIP     = 0x00000001,
    ///Pen eraser.
    POINTER_DEVICE_CURSOR_TYPE_ERASER  = 0x00000002,
    ///Forces this enumeration to compile to 32 bits in size. Without this value, some compilers would allow this
    ///enumeration to compile to a size other than 32 bits. You should not use this value.
    POINTER_DEVICE_CURSOR_TYPE_MAX     = 0xffffffff,
}

///The type of device that sent the input message.
alias INPUT_MESSAGE_DEVICE_TYPE = int;
enum : int
{
    ///The device type isn't identified.
    IMDT_UNAVAILABLE = 0x00000000,
    ///Keyboard input.
    IMDT_KEYBOARD    = 0x00000001,
    ///Mouse input.
    IMDT_MOUSE       = 0x00000002,
    ///Touch input.
    IMDT_TOUCH       = 0x00000004,
    ///Pen or stylus input.
    IMDT_PEN         = 0x00000008,
    ///Touchpad input (Windows 8.1 and later).
    IMDT_TOUCHPAD    = 0x00000010,
}

///The ID of the input message source.
alias INPUT_MESSAGE_ORIGIN_ID = int;
enum : int
{
    ///The source isn't identified.
    IMO_UNAVAILABLE = 0x00000000,
    ///The input message is from a hardware device or has been injected into the message queue by an application that
    ///has the <b>UIAccess</b> attribute set to TRUE in its manifest file. For more information about the
    ///<b>UIAccess</b> attribute and application manifests, see UAC References.
    IMO_HARDWARE    = 0x00000001,
    ///The input message has been injected (through the SendInput function) by an application that doesn't have the
    ///<b>UIAccess</b> attribute set to TRUE in its manifest file.
    IMO_INJECTED    = 0x00000002,
    ///The system has injected the input message.
    IMO_SYSTEM      = 0x00000004,
}

alias TVITEMPART = int;
enum : int
{
    TVGIPR_BUTTON = 0x00000001,
}

///<p class="CCE_Message">[Some information relates to pre-released product which may be substantially modified before
///it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information
///provided here.] Indicates the end of line character used by an edit control.
alias EC_ENDOFLINE = int;
enum : int
{
    ///End of line character specified in content.
    EC_ENDOFLINE_DETECTFROMCONTENT = 0x00000000,
    ///End of line character is CRLF.
    EC_ENDOFLINE_CRLF              = 0x00000001,
    ///End of line character is CR.
    EC_ENDOFLINE_CR                = 0x00000002,
    ///End of line character is LF.
    EC_ENDOFLINE_LF                = 0x00000003,
}

alias EC_SEARCHWEB_ENTRYPOINT = int;
enum : int
{
    EC_SEARCHWEB_ENTRYPOINT_EXTERNAL    = 0x00000000,
    EC_SEARCHWEB_ENTRYPOINT_CONTEXTMENU = 0x00000001,
}

alias _TASKDIALOG_FLAGS = int;
enum : int
{
    TDF_ENABLE_HYPERLINKS           = 0x00000001,
    TDF_USE_HICON_MAIN              = 0x00000002,
    TDF_USE_HICON_FOOTER            = 0x00000004,
    TDF_ALLOW_DIALOG_CANCELLATION   = 0x00000008,
    TDF_USE_COMMAND_LINKS           = 0x00000010,
    TDF_USE_COMMAND_LINKS_NO_ICON   = 0x00000020,
    TDF_EXPAND_FOOTER_AREA          = 0x00000040,
    TDF_EXPANDED_BY_DEFAULT         = 0x00000080,
    TDF_VERIFICATION_FLAG_CHECKED   = 0x00000100,
    TDF_SHOW_PROGRESS_BAR           = 0x00000200,
    TDF_SHOW_MARQUEE_PROGRESS_BAR   = 0x00000400,
    TDF_CALLBACK_TIMER              = 0x00000800,
    TDF_POSITION_RELATIVE_TO_WINDOW = 0x00001000,
    TDF_RTL_LAYOUT                  = 0x00002000,
    TDF_NO_DEFAULT_RADIO_BUTTON     = 0x00004000,
    TDF_CAN_BE_MINIMIZED            = 0x00008000,
    TDF_NO_SET_FOREGROUND           = 0x00010000,
    TDF_SIZE_TO_CONTENT             = 0x01000000,
}

alias TASKDIALOG_MESSAGES = int;
enum : int
{
    TDM_NAVIGATE_PAGE                       = 0x00000465,
    TDM_CLICK_BUTTON                        = 0x00000466,
    TDM_SET_MARQUEE_PROGRESS_BAR            = 0x00000467,
    TDM_SET_PROGRESS_BAR_STATE              = 0x00000468,
    TDM_SET_PROGRESS_BAR_RANGE              = 0x00000469,
    TDM_SET_PROGRESS_BAR_POS                = 0x0000046a,
    TDM_SET_PROGRESS_BAR_MARQUEE            = 0x0000046b,
    TDM_SET_ELEMENT_TEXT                    = 0x0000046c,
    TDM_CLICK_RADIO_BUTTON                  = 0x0000046e,
    TDM_ENABLE_BUTTON                       = 0x0000046f,
    TDM_ENABLE_RADIO_BUTTON                 = 0x00000470,
    TDM_CLICK_VERIFICATION                  = 0x00000471,
    TDM_UPDATE_ELEMENT_TEXT                 = 0x00000472,
    TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE = 0x00000473,
    TDM_UPDATE_ICON                         = 0x00000474,
}

alias TASKDIALOG_NOTIFICATIONS = int;
enum : int
{
    TDN_CREATED                = 0x00000000,
    TDN_NAVIGATED              = 0x00000001,
    TDN_BUTTON_CLICKED         = 0x00000002,
    TDN_HYPERLINK_CLICKED      = 0x00000003,
    TDN_TIMER                  = 0x00000004,
    TDN_DESTROYED              = 0x00000005,
    TDN_RADIO_BUTTON_CLICKED   = 0x00000006,
    TDN_DIALOG_CONSTRUCTED     = 0x00000007,
    TDN_VERIFICATION_CLICKED   = 0x00000008,
    TDN_HELP                   = 0x00000009,
    TDN_EXPANDO_BUTTON_CLICKED = 0x0000000a,
}

alias TASKDIALOG_ELEMENTS = int;
enum : int
{
    TDE_CONTENT              = 0x00000000,
    TDE_EXPANDED_INFORMATION = 0x00000001,
    TDE_FOOTER               = 0x00000002,
    TDE_MAIN_INSTRUCTION     = 0x00000003,
}

alias TASKDIALOG_ICON_ELEMENTS = int;
enum : int
{
    TDIE_ICON_MAIN   = 0x00000000,
    TDIE_ICON_FOOTER = 0x00000001,
}

alias _TASKDIALOG_COMMON_BUTTON_FLAGS = int;
enum : int
{
    TDCBF_OK_BUTTON     = 0x00000001,
    TDCBF_YES_BUTTON    = 0x00000002,
    TDCBF_NO_BUTTON     = 0x00000004,
    TDCBF_CANCEL_BUTTON = 0x00000008,
    TDCBF_RETRY_BUTTON  = 0x00000010,
    TDCBF_CLOSE_BUTTON  = 0x00000020,
}

alias _LI_METRIC = int;
enum : int
{
    LIM_SMALL = 0x00000000,
    LIM_LARGE = 0x00000001,
}

///Indicates the text mode of a rich edit control. The EM_SETTEXTMODE and EM_GETTEXTMODE messages use this enumeration
///type.
alias TEXTMODE = int;
enum : int
{
    ///Indicates plain-text mode, in which the control is similar to a standard edit control. For more information about
    ///plain-text mode, see the Remarks section of EM_SETTEXTMODE.
    TM_PLAINTEXT       = 0x00000001,
    ///Indicates rich-text mode, in which the control has the standard rich edit functionality. Rich-text mode is the
    ///default setting.
    TM_RICHTEXT        = 0x00000002,
    ///The control allows the user to undo only the last action in the undo queue.
    TM_SINGLELEVELUNDO = 0x00000004,
    ///The control supports multiple undo actions. This is the default setting. Use the EM_SETUNDOLIMIT message to set
    ///the maximum number of undo actions.
    TM_MULTILEVELUNDO  = 0x00000008,
    ///The control only allows the English keyboard and a keyboard corresponding to the default character set. For
    ///example, you could have Greek and English. Note that this prevents Unicode text from entering the control. For
    ///example, use this value if a Rich Edit control must be restricted to ANSI text.
    TM_SINGLECODEPAGE  = 0x00000010,
    ///The control allows multiple code pages and Unicode text into the control. This is the default setting.
    TM_MULTICODEPAGE   = 0x00000020,
}

///Contains values that indicate types of rich edit control actions that can be undone or redone. The EM_GETREDONAME and
///EM_GETUNDONAME messages use this enumeration type to return a value.
alias UNDONAMEID = int;
enum : int
{
    ///The type of undo action is unknown.
    UID_UNKNOWN   = 0x00000000,
    ///Typing operation.
    UID_TYPING    = 0x00000001,
    ///Delete operation.
    UID_DELETE    = 0x00000002,
    ///Drag-and-drop operation.
    UID_DRAGDROP  = 0x00000003,
    ///Cut operation.
    UID_CUT       = 0x00000004,
    ///Paste operation.
    UID_PASTE     = 0x00000005,
    ///Automatic table insertion; for example, typing +---+---+&lt;Enter&gt; to insert a table row.
    UID_AUTOTABLE = 0x00000006,
}

///Contains values used to specify how to do hyphenation in a rich edit control. The HyphenateProc callback function
///uses this enumeration type.
alias KHYPH = int;
enum : int
{
    ///No hyphenation is allowed.
    khyphNil          = 0x00000000,
    ///Do not change any characters during hyphenation.
    khyphNormal       = 0x00000001,
    ///Add a letter before the hyphenation mark.
    khyphAddBefore    = 0x00000002,
    ///Change the letter before the hyphenation mark.
    khyphChangeBefore = 0x00000003,
    ///Delete the letter before the hyphenation mark.
    khyphDeleteBefore = 0x00000004,
    ///Change the letter after the hyphenation mark.
    khyphChangeAfter  = 0x00000005,
    ///The two letters before the hyphenation mark are replaced by one character; see the <b>chHyph</b> member of
    ///HYPHRESULT.
    khyphDelAndChange = 0x00000006,
}

///Defines values that are used with the Text Object Model (TOM) API.
alias tomConstants = int;
enum : int
{
    ///A tomBool value that indicates false.
    tomFalse                           = 0x00000000,
    ///A tomBool value that indicates true.
    tomTrue                            = 0xffffffff,
    ///A tomBool value that indicates a no-input, no-change value that works with <b>long</b>, <b>float</b>, and
    ///COLORREF parameters. For strings, <b>tomUndefined</b> (or NINCH) is represented by the null string. For Set
    ///operations, using <b>tomUndefined</b> does not change the target property. For Get operations,
    ///<b>tomUndefined</b> means that the characters in the range have different values (it gives the grayed check box
    ///in property dialog boxes).
    tomUndefined                       = 0xff676981,
    ///A tomBool value that toggles the state of a property.
    tomToggle                          = 0xff676982,
    ///Allow the rich edit control to select the appropriate color.
    tomAutoColor                       = 0xff676983,
    ///Set to the document default format for objects that are attached to a range, or to the basic TOM engine default
    ///for objects that are not attached to a range.
    tomDefault                         = 0xff676984,
    ///Suspend an operation.
    tomSuspend                         = 0xff676985,
    ///Resume an operation.
    tomResume                          = 0xff676986,
    ///Apply the current properties to the attached range.
    tomApplyNow                        = 0x00000000,
    ///Allow setting property definitions, but don’t apply them to a range yet.
    tomApplyLater                      = 0x00000001,
    ///Update the current font with the attached range properties.
    tomTrackParms                      = 0x00000002,
    ///Don’t update the current font with the attached range properties.
    tomCacheParms                      = 0x00000003,
    ///Apply temporary formatting.
    tomApplyTmp                        = 0x00000004,
    ///Do not apply smart fonts.
    tomDisableSmartFont                = 0x00000008,
    ///Do apply smart fonts.
    tomEnableSmartFont                 = 0x00000009,
    ///Use points for floating-point measurements.
    tomUsePoints                       = 0x0000000a,
    ///Use twips for floating-point measurements.
    tomUseTwips                        = 0x0000000b,
    ///Move backward toward the start of a story.
    tomBackward                        = 0xc0000001,
    ///Move foreward toward the end of a story.
    tomForward                         = 0x3fffffff,
    ///Collapse the selection or range to an insertion point and then move the insertion point.
    tomMove                            = 0x00000000,
    ///Extend a selection or range by moving one of the endpoints.
    tomExtend                          = 0x00000001,
    ///There is no selection and no insertion point.
    tomNoSelection                     = 0x00000000,
    ///The selection insertion point.
    tomSelectionIP                     = 0x00000001,
    ///The selection is a single, nondegenerate text range.
    tomSelectionNormal                 = 0x00000002,
    ///A frame is selected.
    tomSelectionFrame                  = 0x00000003,
    ///One or more table columns is selected.
    tomSelectionColumn                 = 0x00000004,
    ///One or more table rows is selected.
    tomSelectionRow                    = 0x00000005,
    ///A block is selected.
    tomSelectionBlock                  = 0x00000006,
    ///The selection is a picture.
    tomSelectionInlineShape            = 0x00000007,
    ///A shape is selected.
    tomSelectionShape                  = 0x00000008,
    ///The starting position of the selection is active.
    tomSelStartActive                  = 0x00000001,
    ///For degenerate selections, the ambiguous character position corresponding to both the beginning of a line and the
    ///end of the preceding line should have the caret displayed at the end of the preceding line.
    tomSelAtEOL                        = 0x00000002,
    ///Insert/overtype mode is set to overtype.
    tomSelOvertype                     = 0x00000004,
    ///Selection is active.
    tomSelActive                       = 0x00000008,
    ///Typing and pasting replaces the selection.
    tomSelReplace                      = 0x00000010,
    ///The end of a text range.
    tomEnd                             = 0x00000000,
    ///The start of range.
    tomStart                           = 0x00000020,
    ///Collapse to the end position of a range or selection.
    tomCollapseEnd                     = 0x00000000,
    ///Collapse to the start position of a range or selection.
    tomCollapseStart                   = 0x00000001,
    ///Use client coordinates instead of screen coordinates.
    tomClientCoord                     = 0x00000100,
    ///Allow points outside of the client area.
    tomAllowOffClient                  = 0x00000200,
    ///Transform coordinates using a world transform (XFORM) supplied by the host application.
    tomTransform                       = 0x00000400,
    ///Get a point inside an inline object argument; for example, inside the numerator of a fraction.
    tomObjectArg                       = 0x00000800,
    ///The end of the specified unit.
    tomAtEnd                           = 0x00001000,
    ///No underlining.
    tomNone                            = 0x00000000,
    ///Single underline.
    tomSingle                          = 0x00000001,
    ///Underline words only.
    tomWords                           = 0x00000002,
    ///Double underline.
    tomDouble                          = 0x00000003,
    ///Dotted underline.
    tomDotted                          = 0x00000004,
    ///Dash underline.
    tomDash                            = 0x00000005,
    ///Dash dot underline.
    tomDashDot                         = 0x00000006,
    ///Dash dot dot underline.
    tomDashDotDot                      = 0x00000007,
    ///Wave underline.
    tomWave                            = 0x00000008,
    ///Thick underline.
    tomThick                           = 0x00000009,
    ///Hair underline.
    tomHair                            = 0x0000000a,
    ///Double wave underline.
    tomDoubleWave                      = 0x0000000b,
    ///Heavy wave underline.
    tomHeavyWave                       = 0x0000000c,
    ///Long dash underline.
    tomLongDash                        = 0x0000000d,
    ///Thick dash underline.
    tomThickDash                       = 0x0000000e,
    ///Thick dash dot underline.
    tomThickDashDot                    = 0x0000000f,
    ///Thick dash dot dot underline.
    tomThickDashDotDot                 = 0x00000010,
    ///Thick dotted underline.
    tomThickDotted                     = 0x00000011,
    ///Thick long dash underline.
    tomThickLongDash                   = 0x00000012,
    ///Single space. The line-spacing value is ignored.
    tomLineSpaceSingle                 = 0x00000000,
    ///One-and-a-half line spacing. The line-spacing value is ignored.
    tomLineSpace1pt5                   = 0x00000001,
    ///Double line spacing. The line-spacing value is ignored.
    tomLineSpaceDouble                 = 0x00000002,
    ///The line-spacing value specifies the spacing from one line to the next. However, if the value is less than single
    ///spacing, text is single-spaced.
    tomLineSpaceAtLeast                = 0x00000003,
    ///The line-spacing value specifies the exact spacing from one line to the next, even if the value is less than
    ///single spacing.
    tomLineSpaceExactly                = 0x00000004,
    ///The line-spacing value specifies the line spacing, in lines.
    tomLineSpaceMultiple               = 0x00000005,
    ///The line-spacing value specifies the line spacing by percent of line height.
    tomLineSpacePercent                = 0x00000006,
    ///Text aligns with the left margin.
    tomAlignLeft                       = 0x00000000,
    ///Text is centered between the margins.
    tomAlignCenter                     = 0x00000001,
    ///Text aligns with the right margin.
    tomAlignRight                      = 0x00000002,
    ///Text starts at the left margin and, if the line extends beyond the right margin, all the spaces in the line are
    ///adjusted to be even.
    tomAlignJustify                    = 0x00000003,
    ///The decimal point is set at the tab position. This is useful for aligning a column of decimal numbers.
    tomAlignDecimal                    = 0x00000003,
    ///A vertical bar is positioned at the tab position. Text is not affected. Alignment bars on nearby lines at the
    ///same position form a continuous vertical line.
    tomAlignBar                        = 0x00000004,
    ///Position at a default tab stop.
    tomDefaultTab                      = 0x00000005,
    ///Same as <b>tomAlignJustify</b>.
    tomAlignInterWord                  = 0x00000003,
    ///Same as <b>tomAlignInterLetter</b>, but uses East Asian metrics.
    tomAlignNewspaper                  = 0x00000004,
    ///The first and last characters of each line (except the last line) are aligned to the left and right margins, and
    ///lines are filled by adding or subtracting the same amount from each character.
    tomAlignInterLetter                = 0x00000005,
    ///Same as <b>tomAlignInterLetter</b>, but uses East Asian metrics, and scales the spacing by the width of
    ///characters.
    tomAlignScaled                     = 0x00000006,
    ///Use spaces to fill the spaces taken by a tab character.
    tomSpaces                          = 0x00000000,
    ///Use dots to fill the spaces taken by a tab character.
    tomDots                            = 0x00000001,
    ///Use dashes to fill the spaces taken by a tab character.
    tomDashes                          = 0x00000002,
    ///Use solid lines to fill the spaces taken by a tab character.
    tomLines                           = 0x00000003,
    ///Use thick solid lines to fill the spaces taken by a tab character.
    tomThickLines                      = 0x00000004,
    ///Use equal signs to fill the spaces taken by a tab character.
    tomEquals                          = 0x00000005,
    ///The tab preceding the specified location.
    tomTabBack                         = 0xfffffffd,
    ///The next tab following the specified location.
    tomTabNext                         = 0xfffffffe,
    ///The tab at the specified location.
    tomTabHere                         = 0xffffffff,
    ///Not a list paragraph.
    tomListNone                        = 0x00000000,
    ///List uses bullets (0x2022); other bullets are given by &gt; 32.
    tomListBullet                      = 0x00000001,
    ///List is numbered with Arabic numerals (0, 1, 2, ...).
    tomListNumberAsArabic              = 0x00000002,
    ///List is ordered with lowercase letters (a, b, c, ...).
    tomListNumberAsLCLetter            = 0x00000003,
    ///List is ordered with uppercase Arabic letters (A, B, C, ...).
    tomListNumberAsUCLetter            = 0x00000004,
    ///List is ordered with lowercase Roman letters (i, ii, iii, ...).
    tomListNumberAsLCRoman             = 0x00000005,
    ///List is ordered with uppercase Roman letters (I, II, III, ...).
    tomListNumberAsUCRoman             = 0x00000006,
    ///The value returned by ITextPara::GetListStart is treated as the first code in a Unicode sequence.
    tomListNumberAsSequence            = 0x00000007,
    ///List is ordered with Unicode circled numbers <img alt="Unicode numbers in a circle."
    ///src="images/unicodecirclednumbers.png"/>
    tomListNumberedCircle              = 0x00000008,
    ///List is ordered with Wingdings black circled digits <img alt="Circled black digits."
    ///src="images/wingdingblackcircleddigits.png"/>
    tomListNumberedBlackCircleWingding = 0x00000009,
    ///List is ordered with Wingdings white circled digits: <img alt="White digits in a black circle."
    ///src="images/wingdingwhitecircleddigits.png"/>
    tomListNumberedWhiteCircleWingding = 0x0000000a,
    ///Full-width ASCII (０, １, ２, ３, …).
    tomListNumberedArabicWide          = 0x0000000b,
    ///Chinese with 十 only in items 10 through 99 (一, 二, 三, 四…).
    tomListNumberedChS                 = 0x0000000c,
    ///Chinese with 十 only in items 10 through 19.
    tomListNumberedChT                 = 0x0000000d,
    ///Chinese with a full-width period, no 十.
    tomListNumberedJpnChS              = 0x0000000e,
    ///Chinese with no 十.
    tomListNumberedJpnKor              = 0x0000000f,
    ///Arabic alphabetic ( أ ,ب ,ت ,ث ,…).
    tomListNumberedArabic1             = 0x00000010,
    ///Arabic abjadi ( أ ,ب ,ج ,د ,…).
    tomListNumberedArabic2             = 0x00000011,
    ///Hebrew alphabet (א, ב, ג, ד, …).
    tomListNumberedHebrew              = 0x00000012,
    ///Thai alphabetic (ก, ข,ค, ง, …).
    tomListNumberedThaiAlpha           = 0x00000013,
    ///Thai numbers (๑, ๒,๓, ๔…).
    tomListNumberedThaiNum             = 0x00000014,
    ///Hindi vowels (अ, आ, इ, ई, …).
    tomListNumberedHindiAlpha          = 0x00000015,
    ///Hindi consonants (क, ख, ग, घ, …).
    tomListNumberedHindiAlpha1         = 0x00000016,
    ///Hindi numbers (१, २, ३, ४, …).
    tomListNumberedHindiNum            = 0x00000017,
    ///Encloses the number in parentheses, as in: (1).
    tomListParentheses                 = 0x00010000,
    ///Follows the number with a period.
    tomListPeriod                      = 0x00020000,
    ///Uses the number alone.
    tomListPlain                       = 0x00030000,
    ///Uses no numbers.
    tomListNoNumber                    = 0x00040000,
    ///Follows the number with a hyphen (-).
    tomListMinus                       = 0x00080000,
    ///Suppress the numbering style for list items.
    tomIgnoreNumberStyle               = 0x01000000,
    ///The normal paragraph style.
    tomParaStyleNormal                 = 0xffffffff,
    ///The style for level 1 paragraph headings.
    tomParaStyleHeading1               = 0xfffffffe,
    ///The style for level 2 paragraph headings.
    tomParaStyleHeading2               = 0xfffffffd,
    ///The style for level 3 paragraph headings.
    tomParaStyleHeading3               = 0xfffffffc,
    ///The style for level 4 paragraph headings.
    tomParaStyleHeading4               = 0xfffffffb,
    ///The style for level 5 paragraph headings.
    tomParaStyleHeading5               = 0xfffffffa,
    ///The style for level 6 paragraph headings.
    tomParaStyleHeading6               = 0xfffffff9,
    ///The style for level 7 paragraph headings.
    tomParaStyleHeading7               = 0xfffffff8,
    ///The style for level 8 paragraph headings.
    tomParaStyleHeading8               = 0xfffffff7,
    ///The style for level 9 paragraph headings.
    tomParaStyleHeading9               = 0xfffffff6,
    ///The unit is a single character.
    tomCharacter                       = 0x00000001,
    ///The unit is a word.
    tomWord                            = 0x00000002,
    ///The unit is a sentence.
    tomSentence                        = 0x00000003,
    ///The unit is a paragraph.
    tomParagraph                       = 0x00000004,
    ///The unit is a line.
    tomLine                            = 0x00000005,
    ///The unit is a story; that is, a contiguous range of text that represent a part of a document, such as the main
    ///text of the document, headers and footers, footnotes, annotations, and so on.
    tomStory                           = 0x00000006,
    ///The unit is a screenful.
    tomScreen                          = 0x00000007,
    ///The unit is a section.
    tomSection                         = 0x00000008,
    ///The unit is a table column.
    tomTableColumn                     = 0x00000009,
    ///The unit is a text column.
    tomColumn                          = 0x00000009,
    ///The unit is a table row
    tomRow                             = 0x0000000a,
    ///The unit is a window.
    tomWindow                          = 0x0000000b,
    ///The unit is a spreadsheet cell.
    tomCell                            = 0x0000000c,
    ///The unit is a run of constant character formatting.
    tomCharFormat                      = 0x0000000d,
    ///The unit is a run of constant paragraph formatting.
    tomParaFormat                      = 0x0000000e,
    ///The unit is a table.
    tomTable                           = 0x0000000f,
    ///The unit is an embedded object.
    tomObject                          = 0x00000010,
    ///The unit is a page.
    tomPage                            = 0x00000011,
    ///The unit is a hard paragraph.
    tomHardParagraph                   = 0x00000012,
    ///The unit is a cluster of characters.
    tomCluster                         = 0x00000013,
    ///The unit is an inline object.
    tomInlineObject                    = 0x00000014,
    ///The unit is an inline object argument.
    tomInlineObjectArg                 = 0x00000015,
    ///The unit is a leaf-level line.
    tomLeafLine                        = 0x00000016,
    ///A layout column.
    tomLayoutColumn                    = 0x00000017,
    ///The identifier of the current process.
    tomProcessId                       = 0x40000001,
    ///Match on whole words when doing a text search.
    tomMatchWord                       = 0x00000002,
    ///A case-sensitive a text search.
    tomMatchCase                       = 0x00000004,
    ///Match regular expressions when doing a text search.
    tomMatchPattern                    = 0x00000008,
    ///No special type.
    tomUnknownStory                    = 0x00000000,
    ///The main story always exists for a rich edit control.
    tomMainTextStory                   = 0x00000001,
    ///The story used for footnotes.
    tomFootnotesStory                  = 0x00000002,
    ///The story used for endnotes.
    tomEndnotesStory                   = 0x00000003,
    ///The story used for comments.
    tomCommentsStory                   = 0x00000004,
    ///The story used for a text box.
    tomTextFrameStory                  = 0x00000005,
    ///The story containing headers for even pages.
    tomEvenPagesHeaderStory            = 0x00000006,
    ///The story containing headers for odd pages.
    tomPrimaryHeaderStory              = 0x00000007,
    ///The story containing footers for even pages.
    tomEvenPagesFooterStory            = 0x00000008,
    ///The story containing footers for odd pages.
    tomPrimaryFooterStory              = 0x00000009,
    ///The story containing the header for the first page.
    tomFirstPageHeaderStory            = 0x0000000a,
    ///The story containing the footer for the first page.
    tomFirstPageFooterStory            = 0x0000000b,
    ///The scratch story.
    tomScratchStory                    = 0x0000007f,
    ///The story used for a Find dialog.
    tomFindStory                       = 0x00000080,
    ///The story used for a Replace dialog.
    tomReplaceStory                    = 0x00000081,
    ///Story is inactive.
    tomStoryInactive                   = 0x00000000,
    ///Story has display, but no UI.
    tomStoryActiveDisplay              = 0x00000001,
    ///Story is UI active; that is, it receives keyboard and mouse input.
    tomStoryActiveUI                   = 0x00000002,
    ///Story has display and UI activity.
    tomStoryActiveDisplayUI            = 0x00000003,
    ///Do not apply text animation.
    tomNoAnimation                     = 0x00000000,
    ///Text is bordered by marquee lights that blink between the colors red, yellow, green, and blue.
    tomLasVegasLights                  = 0x00000001,
    ///Text has a black background that blinks on and off.
    tomBlinkingBackground              = 0x00000002,
    ///Text is overlaid with multicolored stars that blink on and off at regular intervals
    tomSparkleText                     = 0x00000003,
    ///Text is surrounded by a black dashed-line border. The border is animated so that the individual dashes appear to
    ///move clockwise around the text.
    tomMarchingBlackAnts               = 0x00000004,
    ///Text is surrounded by a red dashed-line border that is animated to appear to move clockwise around the text.
    tomMarchingRedAnts                 = 0x00000005,
    ///Text is alternately blurred and unblurred at regular intervals, to give the appearance of shimmering.
    tomShimmer                         = 0x00000006,
    ///Text appears gradually from the top down.
    tomWipeDown                        = 0x00000007,
    ///Text appears gradually from the bottom up.
    tomWipeRight                       = 0x00000008,
    ///Defines the maximum animation flag value.
    tomAnimationMax                    = 0x00000008,
    ///Set text to lowercase.
    tomLowerCase                       = 0x00000000,
    ///Set text to uppercase.
    tomUpperCase                       = 0x00000001,
    ///Capitalize the first letter of each word.
    tomTitleCase                       = 0x00000002,
    ///Capitalize the first letter of each sentence.
    tomSentenceCase                    = 0x00000004,
    ///Toggle the case of each letter.
    tomToggleCase                      = 0x00000005,
    ///Read only.
    tomReadOnly                        = 0x00000100,
    ///Other programs cannot read.
    tomShareDenyRead                   = 0x00000200,
    ///Other programs cannot write.
    tomShareDenyWrite                  = 0x00000400,
    ///Replace the selection with a file.
    tomPasteFile                       = 0x00001000,
    ///Create a new file. Fail if the file already exists.
    tomCreateNew                       = 0x00000010,
    ///Create a new file. Destroy the existing file if it exists.
    tomCreateAlways                    = 0x00000020,
    ///Open an existing file. Fail if the file does not exist.
    tomOpenExisting                    = 0x00000030,
    ///Open an existing file. Create a new file if the file does not exist.
    tomOpenAlways                      = 0x00000040,
    ///Open an existing file, but truncate it to zero length.
    tomTruncateExisting                = 0x00000050,
    ///Open as RTF.
    tomRTF                             = 0x00000001,
    ///Open as text ANSI or Unicode.
    tomText                            = 0x00000002,
    ///Open as HTML.
    tomHTML                            = 0x00000003,
    ///Open as Word document.
    tomWordDocument                    = 0x00000004,
    ///Boldface.
    tomBold                            = 0x80000001,
    ///Italic.
    tomItalic                          = 0x80000002,
    ///Underline.
    tomUnderline                       = 0x80000004,
    ///Strikeout.
    tomStrikeout                       = 0x80000008,
    ///Protected.
    tomProtected                       = 0x80000010,
    ///Hyperlink.
    tomLink                            = 0x80000020,
    ///Small caps.
    tomSmallCaps                       = 0x80000040,
    ///All caps.
    tomAllCaps                         = 0x80000080,
    ///Hidden.
    tomHidden                          = 0x80000100,
    ///Outline.
    tomOutline                         = 0x80000200,
    ///Shadow.
    tomShadow                          = 0x80000400,
    ///Emboss.
    tomEmboss                          = 0x80000800,
    ///Imprint.
    tomImprint                         = 0x80001000,
    ///Disabled.
    tomDisabled                        = 0x80002000,
    ///Revised.
    tomRevised                         = 0x80004000,
    ///Subscript character format.
    tomSubscriptCF                     = 0x80010000,
    ///Superscript character format.
    tomSuperscriptCF                   = 0x80020000,
    ///Font bound (uses font binding).
    tomFontBound                       = 0x80100000,
    ///The link is protected (friendly name link).
    tomLinkProtected                   = 0x80800000,
    ///The start delimiter of an inline object.
    tomInlineObjectStart               = 0x81000000,
    ///The characters are less common members of a script. A font that supports a script should check if it has glyphs
    ///for such characters.
    tomExtendedChar                    = 0x82000000,
    ///Use system back color.
    tomAutoBackColor                   = 0x84000000,
    ///Don't build up operator.
    tomMathZoneNoBuildUp               = 0x88000000,
    ///Math zone.
    tomMathZone                        = 0x90000000,
    ///Math zone ordinary text.
    tomMathZoneOrdinary                = 0xa0000000,
    ///Use system text color.
    tomAutoTextColor                   = 0xc0000000,
    ///Display math zone.
    tomMathZoneDisplay                 = 0x00040000,
    ///Right-to-left paragraph
    tomParaEffectRTL                   = 0x00000001,
    ///Keep the paragraph together.
    tomParaEffectKeep                  = 0x00000002,
    ///Keep with next the paragraph.
    tomParaEffectKeepNext              = 0x00000004,
    ///Put a page break before this paragraph.
    tomParaEffectPageBreakBefore       = 0x00000008,
    ///No line number for this paragraph.
    tomParaEffectNoLineNumber          = 0x00000010,
    ///No widow control.
    tomParaEffectNoWidowControl        = 0x00000020,
    ///Don't hyphenate this paragraph.
    tomParaEffectDoNotHyphen           = 0x00000040,
    ///Side by side.
    tomParaEffectSideBySide            = 0x00000080,
    ///Heading contents are collapsed (in outline view).
    tomParaEffectCollapsed             = 0x00000100,
    ///Outline view nested level.
    tomParaEffectOutlineLevel          = 0x00000200,
    ///Paragraph has boxed effect (is not displayed).
    tomParaEffectBox                   = 0x00000400,
    ///At or inside table delimiter.
    tomParaEffectTableRowDelimiter     = 0x00001000,
    ///Inside or at the start of a table.
    tomParaEffectTable                 = 0x00004000,
    ///Use East Asian character-pair-width modification.
    tomModWidthPairs                   = 0x00000001,
    ///Use East Asian space-width modification.
    tomModWidthSpace                   = 0x00000002,
    ///Use East Asian auto spacing between alphabetics.
    tomAutoSpaceAlpha                  = 0x00000004,
    ///Use East Asian auto spacing for digits.
    tomAutoSpaceNumeric                = 0x00000008,
    ///Use East Asian automatic spacing for parentheses or brackets.
    tomAutoSpaceParens                 = 0x00000010,
    ///Embedded font (CLIP_EMBEDDED).
    tomEmbeddedFont                    = 0x00000020,
    ///Double strikeout.
    tomDoublestrike                    = 0x00000040,
    ///Run has overlapping text.
    tomOverlapping                     = 0x00000080,
    ///Normal caret.
    tomNormalCaret                     = 0x00000000,
    ///The Korean block caret.
    tomKoreanBlockCaret                = 0x00000001,
    ///NULL caret (caret suppressed).
    tomNullCaret                       = 0x00000002,
    ///Add left/top insets to the client rectangle, and subtract right/bottom insets from the client rectangle.
    tomIncludeInset                    = 0x00000001,
    ///Use the Unicode bidirectional (bidi) algorithm.
    tomUnicodeBiDi                     = 0x00000001,
    ///Check math-zone character formatting.
    tomMathCFCheck                     = 0x00000004,
    ///Don't include text as part of a hyperlink.
    tomUnlink                          = 0x00000008,
    ///Don't insert as hidden text.
    tomUnhide                          = 0x00000010,
    ///Obey the current text limit instead of increasing the text to fit.
    tomCheckTextLimit                  = 0x00000020,
    ///Ignore the font that is active at a particular character position.
    tomIgnoreCurrentFont               = 0x00000000,
    ///Match the current character repertoire.
    tomMatchCharRep                    = 0x00000001,
    ///Match the current font signature.
    tomMatchFontSignature              = 0x00000002,
    ///Use the current font if its character repertoire is <b>tomAnsi</b>.
    tomMatchAscii                      = 0x00000004,
    ///Gets the height.
    tomGetHeightOnly                   = 0x00000008,
    ///Match a math font.
    tomMatchMathFont                   = 0x00000010,
    ///Set the character repertoire based on the specified character set.
    tomCharset                         = 0x80000000,
    ///Set the character repertoire based on the specified LCID.
    tomCharRepFromLcid                 = 0x40000000,
    ///Latin 1
    tomAnsi                            = 0x00000000,
    ///From Latin 1 and 2
    tomEastEurope                      = 0x00000001,
    ///Cyrillic
    tomCyrillic                        = 0x00000002,
    ///Greek
    tomGreek                           = 0x00000003,
    ///Turkish (Latin 1 + dotless i, ...)
    tomTurkish                         = 0x00000004,
    ///Hebrew
    tomHebrew                          = 0x00000005,
    ///Arabic
    tomArabic                          = 0x00000006,
    ///From Latin 1 and 2
    tomBaltic                          = 0x00000007,
    ///Latin 1 with some combining marks
    tomVietnamese                      = 0x00000008,
    ///Default character repertoire
    tomDefaultCharRep                  = 0x00000009,
    ///Symbol character set (not Unicode)
    tomSymbol                          = 0x0000000a,
    ///Thai
    tomThai                            = 0x0000000b,
    ///Japanese
    tomShiftJIS                        = 0x0000000c,
    ///Simplified Chinese
    tomGB2312                          = 0x0000000d,
    ///Hangul
    tomHangul                          = 0x0000000e,
    ///Traditional Chinese
    tomBIG5                            = 0x0000000f,
    ///PC437 character set (DOS)
    tomPC437                           = 0x00000010,
    ///OEM character set (original PC)
    tomOEM                             = 0x00000011,
    ///Main Macintosh character repertoire
    tomMac                             = 0x00000012,
    ///Armenian
    tomArmenian                        = 0x00000013,
    ///Syriac
    tomSyriac                          = 0x00000014,
    ///Thaana
    tomThaana                          = 0x00000015,
    ///Devanagari
    tomDevanagari                      = 0x00000016,
    ///Bangla (formerly Bengali)
    tomBengali                         = 0x00000017,
    ///Gurmukhi
    tomGurmukhi                        = 0x00000018,
    ///Gujarati
    tomGujarati                        = 0x00000019,
    ///Odia (formerly Oriya)
    tomOriya                           = 0x0000001a,
    ///Tamil
    tomTamil                           = 0x0000001b,
    ///Telugu
    tomTelugu                          = 0x0000001c,
    ///Kannada
    tomKannada                         = 0x0000001d,
    ///Malayalam
    tomMalayalam                       = 0x0000001e,
    ///Sinhala
    tomSinhala                         = 0x0000001f,
    ///Lao
    tomLao                             = 0x00000020,
    ///Tibetan
    tomTibetan                         = 0x00000021,
    ///Myanmar
    tomMyanmar                         = 0x00000022,
    ///Georgian
    tomGeorgian                        = 0x00000023,
    ///Jamo
    tomJamo                            = 0x00000024,
    ///Ethiopic
    tomEthiopic                        = 0x00000025,
    ///Cherokee
    tomCherokee                        = 0x00000026,
    ///Aboriginal
    tomAboriginal                      = 0x00000027,
    ///Ogham
    tomOgham                           = 0x00000028,
    ///Runic
    tomRunic                           = 0x00000029,
    ///Khmer
    tomKhmer                           = 0x0000002a,
    ///Mongolian
    tomMongolian                       = 0x0000002b,
    ///Braille
    tomBraille                         = 0x0000002c,
    ///Yi
    tomYi                              = 0x0000002d,
    ///Limbu
    tomLimbu                           = 0x0000002e,
    ///TaiLe
    tomTaiLe                           = 0x0000002f,
    ///TaiLue
    tomNewTaiLue                       = 0x00000030,
    ///Syloti Nagri
    tomSylotiNagri                     = 0x00000031,
    ///Kharoshthi
    tomKharoshthi                      = 0x00000032,
    ///Kayah Li
    tomKayahli                         = 0x00000033,
    ///Unicode symbol
    tomUsymbol                         = 0x00000034,
    ///Emoji
    tomEmoji                           = 0x00000035,
    ///Glagolitic
    tomGlagolitic                      = 0x00000036,
    ///Lisu
    tomLisu                            = 0x00000037,
    ///Vai
    tomVai                             = 0x00000038,
    ///N'Ko
    tomNKo                             = 0x00000039,
    ///Osmanya
    tomOsmanya                         = 0x0000003a,
    ///Phags-pa
    tomPhagsPa                         = 0x0000003b,
    ///Gothic
    tomGothic                          = 0x0000003c,
    ///Deseret
    tomDeseret                         = 0x0000003d,
    ///Tifinagh
    tomTifinagh                        = 0x0000003e,
    ///The maximum character repertoire flag value.
    tomCharRepMax                      = 0x0000003f,
    ///Use Microsoft Rich Edit 1.0 mode.
    tomRE10Mode                        = 0x00000001,
    ///Use a font with a name that starts with @, for CJK vertical text. When rendered vertically, the characters in
    ///such a font are rotated 90 degrees so that they look upright instead of sideways.
    tomUseAtFont                       = 0x00000002,
    ///Mask for the following four text orientations.
    tomTextFlowMask                    = 0x0000000c,
    ///Ordinary left-to-right horizontal text.
    tomTextFlowES                      = 0x00000000,
    ///Ordinary East Asian vertical text.
    tomTextFlowSW                      = 0x00000004,
    ///Alternative orientation.
    tomTextFlowWN                      = 0x00000008,
    ///Alternative orientation.
    tomTextFlowNE                      = 0x0000000c,
    ///Disables the IME operation (see ES_NOIME).
    tomNoIME                           = 0x00080000,
    ///Directs the rich edit control to allow the application to handle all IME operations (see ES_SELFIME).
    tomSelfIME                         = 0x00040000,
    ///Horizontal scrolling is disabled.
    tomNoUpScroll                      = 0x00010000,
    ///Vertical scrolling is disabled.
    tomNoVpScroll                      = 0x00040000,
    ///Not a link.
    tomNoLink                          = 0x00000000,
    ///The URL only; that is, no friendly name.
    tomClientLink                      = 0x00000001,
    ///The name of friendly name link.
    tomFriendlyLinkName                = 0x00000002,
    ///The URL of a friendly name link.
    tomFriendlyLinkAddress             = 0x00000003,
    ///The URL of an automatic link.
    tomAutoLinkURL                     = 0x00000004,
    ///An automatic link to an email address.
    tomAutoLinkEmail                   = 0x00000005,
    ///An automatic link to a phone number.
    tomAutoLinkPhone                   = 0x00000006,
    ///An automatic link to a storage location.
    tomAutoLinkPath                    = 0x00000007,
    ///No compression.
    tomCompressNone                    = 0x00000000,
    ///Compress punctuation.
    tomCompressPunctuation             = 0x00000001,
    ///Compress punctuation and kana.
    tomCompressPunctuationAndKana      = 0x00000002,
    ///The maximum compression flag value.
    tomCompressMax                     = 0x00000002,
    ///Automatically set the underline position.
    tomUnderlinePositionAuto           = 0x00000000,
    ///Render underline below text.
    tomUnderlinePositionBelow          = 0x00000001,
    ///Render underline above text.
    tomUnderlinePositionAbove          = 0x00000002,
    ///The maximum underline position flag value.
    tomUnderlinePositionMax            = 0x00000002,
    ///For horizontal layout, align CJK characters on the baseline. For vertical layout, center align CJK characters.
    tomFontAlignmentAuto               = 0x00000000,
    ///For horizontal layout, top align CJK characters. For vertical layout, right align CJK characters.
    tomFontAlignmentTop                = 0x00000001,
    ///For horizontal or vertical layout, align CJK characters on the baseline.
    tomFontAlignmentBaseline           = 0x00000002,
    ///For horizontal layout, bottom align CJK characters. For vertical layout, left align CJK characters.
    tomFontAlignmentBottom             = 0x00000003,
    ///For horizontal layout, center CJK characters vertically. For vertical layout, center align CJK characters
    ///horizontally.
    tomFontAlignmentCenter             = 0x00000004,
    ///The maximum font alignment flag value.
    tomFontAlignmentMax                = 0x00000004,
    tomRubyBelow                       = 0x00000080,
    tomRubyAlignCenter                 = 0x00000000,
    tomRubyAlign010                    = 0x00000001,
    tomRubyAlign121                    = 0x00000002,
    tomRubyAlignLeft                   = 0x00000003,
    tomRubyAlignRight                  = 0x00000004,
    ///Limit locations use document default.
    tomLimitsDefault                   = 0x00000000,
    ///Limits are placed under and over the operator.
    tomLimitsUnderOver                 = 0x00000001,
    ///Limits are operator subscript and superscript.
    tomLimitsSubSup                    = 0x00000002,
    ///The upper limit is a superscript.
    tomUpperLimitAsSuperScript         = 0x00000003,
    ///Switch between <b>tomLimitsSubSup</b> and <b>tomLimitsUnderOver</b>.
    tomLimitsOpposite                  = 0x00000004,
    ///Show empty lower limit placeholder.
    tomShowLLimPlaceHldr               = 0x00000008,
    ///Show empty upper limit placeholder.
    tomShowULimPlaceHldr               = 0x00000010,
    ///Don't grow the <i>n</i>-ary operator with the argument.
    tomDontGrowWithContent             = 0x00000040,
    ///Grow the <i>n</i>-ary operator with the argument.
    tomGrowWithContent                 = 0x00000080,
    ///Align subscript under superscript.
    tomSubSupAlign                     = 0x00000001,
    ///Mask for <b>tomLimitAlignCenter</b>, <b>tomLimitAlignLeft</b>, and <b>tomLimitAlignRight.</b>
    tomLimitAlignMask                  = 0x00000003,
    ///Center limit under base.
    tomLimitAlignCenter                = 0x00000000,
    ///Align left ends of limit and base.
    tomLimitAlignLeft                  = 0x00000001,
    ///Align right ends of limit and base.
    tomLimitAlignRight                 = 0x00000002,
    ///Show empty radical degree placeholder.
    tomShowDegPlaceHldr                = 0x00000008,
    ///Center brackets at baseline.
    tomAlignDefault                    = 0x00000000,
    ///Use brackets that match the argument ascent and descent.
    tomAlignMatchAscentDescent         = 0x00000002,
    ///Bits 7, 6 can have TeX variant enumeration values:
    tomMathVariant                     = 0x00000020,
    ///The math handler determines the style.
    tomStyleDefault                    = 0x00000000,
    ///The 2<sup>nd</sup> and higher level subscript superscript size, cramped.
    tomStyleScriptScriptCramped        = 0x00000001,
    ///The 2<sup>nd</sup> and higher level subscript superscript size.
    tomStyleScriptScript               = 0x00000002,
    ///The 1<sup>st</sup> level subscript superscript size, cramped.
    tomStyleScriptCramped              = 0x00000003,
    ///The 1<sup>st</sup> level subscript superscript size.
    tomStyleScript                     = 0x00000004,
    ///Text size cramped, for example, inside a square root.
    tomStyleTextCramped                = 0x00000005,
    ///The standard inline text size.
    tomStyleText                       = 0x00000006,
    ///Display style cramped.
    tomStyleDisplayCramped             = 0x00000007,
    ///Display style.
    tomStyleDisplay                    = 0x00000008,
    ///Indicates one of these is active: <b>tomDecDecSize</b>, <b>tomDecSize</b>, <b>tomIncSize</b>,
    ///<b>tomIncIncSize</b>. Note that the maximum size is <b>tomStyleText</b> size, and the minimum size is
    ///<b>tomStyleScriptScript</b> size.
    tomMathRelSize                     = 0x00000040,
    ///Two sizes smaller than the default.
    tomDecDecSize                      = 0x000000fe,
    ///One size smaller than the default.
    tomDecSize                         = 0x000000ff,
    ///One size bigger than the default.
    tomIncSize                         = 0x00000041,
    ///Two sizes bigger than the default.
    tomIncIncSize                      = 0x00000042,
    ///Use selection user interface rules.
    tomGravityUI                       = 0x00000000,
    ///Both ends have backward gravity.
    tomGravityBack                     = 0x00000001,
    ///Both ends have forward gravity.
    tomGravityFore                     = 0x00000002,
    ///Inward gravity; that is, the start is forward, and the end is backward.
    tomGravityIn                       = 0x00000003,
    ///Outward gravity; that is, the start is backward, and the end is forward.
    tomGravityOut                      = 0x00000004,
    tomGravityBackward                 = 0x20000000,
    tomGravityForward                  = 0x40000000,
    ///Adjust CR/LFs at the start.
    tomAdjustCRLF                      = 0x00000001,
    ///Use CR/LF in place of a carriage return or a line feed.
    tomUseCRLF                         = 0x00000002,
    ///Copy up to 0xFFFC (OLE object).
    tomTextize                         = 0x00000004,
    ///Allow a final end-of-paragraph (EOP) marker.
    tomAllowFinalEOP                   = 0x00000008,
    ///Fold math alphanumerics to ASCII/Greek.
    tomFoldMathAlpha                   = 0x00000010,
    ///Don't include hidden text.
    tomNoHidden                        = 0x00000020,
    ///Include list numbers.
    tomIncludeNumbering                = 0x00000040,
    ///Replace table row delimiter characters with spaces.
    tomTranslateTableCell              = 0x00000080,
    ///Don't include math zone brackets.
    tomNoMathZoneBrackets              = 0x00000100,
    ///Convert to or from math italic and/or math bold according to the status of italic and bold retrieved by the
    ///ITextFont2::GetEffects method.
    tomConvertMathChar                 = 0x00000200,
    ///Don’t use math italics for upper-case Greek letters. This value is used with <b>tomConvertMathChar</b>.
    tomNoUCGreekItalic                 = 0x00000400,
    ///Allow math bold. This value is used with <b>tomConvertMathChar</b>.
    tomAllowMathBold                   = 0x00000800,
    ///Get the BCP-47 language tag for this range.
    tomLanguageTag                     = 0x00001000,
    ///Get text in RTF.
    tomConvertRTF                      = 0x00002000,
    ///Apply RTF document default properties.
    tomApplyRtfDocProps                = 0x00004000,
    ///Display the phantom object's argument.
    tomPhantomShow                     = 0x00000001,
    ///The phantom object has zero width.
    tomPhantomZeroWidth                = 0x00000002,
    ///The phantom object has zero ascent.
    tomPhantomZeroAscent               = 0x00000004,
    ///The phantom object has zero descent.
    tomPhantomZeroDescent              = 0x00000008,
    ///Space the phantom object as if only the argument is present.
    tomPhantomTransparent              = 0x00000010,
    ///Ascent smash.
    tomPhantomASmash                   = 0x00000005,
    ///Descent smash.
    tomPhantomDSmash                   = 0x00000009,
    ///Horizontal smash.
    tomPhantomHSmash                   = 0x00000003,
    ///Full smash.
    tomPhantomSmash                    = 0x0000000d,
    ///Horizontal phantom.
    tomPhantomHorz                     = 0x0000000c,
    ///Vertical phantom.
    tomPhantomVert                     = 0x00000002,
    ///Hide top border.
    tomBoxHideTop                      = 0x00000001,
    ///Hide bottom border.
    tomBoxHideBottom                   = 0x00000002,
    ///Hide left border.
    tomBoxHideLeft                     = 0x00000004,
    ///Hide right border.
    tomBoxHideRight                    = 0x00000008,
    ///Display horizontal strikethrough.
    tomBoxStrikeH                      = 0x00000010,
    ///Display vertical strikethrough.
    tomBoxStrikeV                      = 0x00000020,
    ///Display diagonal strikethrough from the top left to the lower right.
    tomBoxStrikeTLBR                   = 0x00000040,
    ///Display diagonal strikethrough from the lower left to the top right.
    tomBoxStrikeBLTR                   = 0x00000080,
    ///Vertically align with center on baseline.
    tomBoxAlignCenter                  = 0x00000001,
    ///Mask for <b>tomSpaceDefault</b>, <b>tomSpaceUnary</b>, <b>tomSpaceBinary</b>, <b>tomSpaceRelational</b>,
    ///<b>tomSpaceSkip</b>, <b>tomSpaceOrd</b>, and <b>tomSpaceDifferential.</b>
    tomSpaceMask                       = 0x0000001c,
    ///Default spacing
    tomSpaceDefault                    = 0x00000000,
    ///Space the object as if it were a unary operator.
    tomSpaceUnary                      = 0x00000004,
    ///Space the object as if it were a binary operator.
    tomSpaceBinary                     = 0x00000008,
    ///Space the object as if it were a relational operator.
    tomSpaceRelational                 = 0x0000000c,
    ///Space the object as if it were a unary operator.
    tomSpaceSkip                       = 0x00000010,
    ///Space the object as if it were an ordinal operator.
    tomSpaceOrd                        = 0x00000014,
    ///Space the object as if it were a differential operator.
    tomSpaceDifferential               = 0x00000018,
    ///Treat as text size.
    tomSizeText                        = 0x00000020,
    ///Treat as script size (approximately 73% of text size).
    tomSizeScript                      = 0x00000040,
    ///Treat as subscript size (approximately 60% of text size).
    tomSizeScriptScript                = 0x00000060,
    ///Do not break arguments across a line.
    tomNoBreak                         = 0x00000080,
    ///Position as if only the argument appears.
    tomTransparentForPositioning       = 0x00000100,
    ///Space according to argument properties.
    tomTransparentForSpacing           = 0x00000200,
    ///Stretch character below base.
    tomStretchCharBelow                = 0x00000000,
    ///Stretch character above base.
    tomStretchCharAbove                = 0x00000001,
    ///Stretch base below character.
    tomStretchBaseBelow                = 0x00000002,
    ///Stretch base above character.
    tomStretchBaseAbove                = 0x00000003,
    ///Mask for <b>tomMatrixAlignCenter</b>, <b>tomMatrixAlignTopRow</b>, and <b>tomMatrixAlignBottomRow.</b>
    tomMatrixAlignMask                 = 0x00000003,
    ///Align the matrix center on baseline.
    tomMatrixAlignCenter               = 0x00000000,
    ///Align the matrix top row on the baseline.
    tomMatrixAlignTopRow               = 0x00000001,
    ///Align the matrix bottom row on the baseline.
    tomMatrixAlignBottomRow            = 0x00000003,
    ///Show empty element placeholder (a dotted box).
    tomShowMatPlaceHldr                = 0x00000008,
    ///Expand the right size to the layout width (for equation number)
    tomEqArrayLayoutWidth              = 0x00000001,
    ///Mask for <b>tomEqArrayAlignCenter</b>, <b>tomEqArrayAlignTopRow</b>, and <b>tomEqArrayBottomRow.</b>
    tomEqArrayAlignMask                = 0x0000000c,
    ///Align the center of the equation array on the baseline.
    tomEqArrayAlignCenter              = 0x00000000,
    ///Align the top of equations on the baseline. Align the top row of the equation on the baseline.
    tomEqArrayAlignTopRow              = 0x00000004,
    ///Align the bottom row of the equation on the baseline.
    tomEqArrayAlignBottomRow           = 0x0000000c,
    ///Mask for <b>tomMathBreakLeft</b>, <b>tomMathBreakCenter</b>, and <b>tomMathBreakRight.</b>
    tomMathManualBreakMask             = 0x0000007f,
    ///Align text following a manual break to the left.
    tomMathBreakLeft                   = 0x0000007d,
    ///Center text following a manual break.
    tomMathBreakCenter                 = 0x0000007e,
    ///Align text following a manual break to the right.
    tomMathBreakRight                  = 0x0000007f,
    ///Math equation alignment.
    tomMathEqAlign                     = 0x00000080,
    ///Start shading math arguments.
    tomMathArgShadingStart             = 0x00000251,
    ///End shading math arguments.
    tomMathArgShadingEnd               = 0x00000252,
    ///Start shading math objects.
    tomMathObjShadingStart             = 0x00000253,
    ///End shading math objects.
    tomMathObjShadingEnd               = 0x00000254,
    ///Not in the function list.
    tomFunctionTypeNone                = 0x00000000,
    ///An ordinary math function that takes arguments.
    tomFunctionTypeTakesArg            = 0x00000001,
    ///Use the lower limit for _, and so on.
    tomFunctionTypeTakesLim            = 0x00000002,
    ///Turn the preceding FA into an NBSP.
    tomFunctionTypeTakesLim2           = 0x00000003,
    ///A "lim" function.
    tomFunctionTypeIsLim               = 0x00000004,
    ///The default alignment for math paragraphs.
    tomMathParaAlignDefault            = 0x00000000,
    ///Center math paragraphs as a group.
    tomMathParaAlignCenterGroup        = 0x00000001,
    ///Center math paragraphs.
    tomMathParaAlignCenter             = 0x00000002,
    ///Left-align math paragraphs.
    tomMathParaAlignLeft               = 0x00000003,
    ///Right-align math paragraphs.
    tomMathParaAlignRight              = 0x00000004,
    ///Mask for <b>tomMathDispAlignCenterGroup</b>, <b>tomMathDispAlignCenter</b>, <b>tomMathDispAlignLeft</b>,
    ///<b>tomMathDispAlignRight</b>, <b>tomMathDispIntUnderOver</b>, and <b>tomMathDispNaryGrow</b>.
    tomMathDispAlignMask               = 0x00000003,
    ///Center a math paragraph as a group.
    tomMathDispAlignCenterGroup        = 0x00000000,
    ///Center all equations in a math paragraph.
    tomMathDispAlignCenter             = 0x00000001,
    ///Left justify all equations in a math paragraph.
    tomMathDispAlignLeft               = 0x00000002,
    ///Right justify all equations in a math paragraph.
    tomMathDispAlignRight              = 0x00000003,
    ///Display-mode integral limits location.
    tomMathDispIntUnderOver            = 0x00000004,
    ///Indicates whether to use display-mode nested fraction script size.
    tomMathDispFracTeX                 = 0x00000008,
    ///Indicates whether to use math-paragraph n-ary grow.
    tomMathDispNaryGrow                = 0x00000010,
    ///Empty arguments display mask.
    tomMathDocEmptyArgMask             = 0x00000060,
    ///Dotted square, if necessary.
    tomMathDocEmptyArgAuto             = 0x00000000,
    ///Dotted square, always.
    tomMathDocEmptyArgAlways           = 0x00000020,
    ///Nothing.
    tomMathDocEmptyArgNever            = 0x00000040,
    ///Do not display the underscore (_) as subscripted, or the caret (^) as superscripted.
    tomMathDocSbSpOpUnchanged          = 0x00000080,
    ///Style mask for the <b>tomMathDocDiffUpright</b>, <b>tomMathDocDiffItalic</b>, <b>tomMathDocDiffOpenItalic
    ///</b>options.
    tomMathDocDiffMask                 = 0x00000300,
    ///Use default glyphs for math differentials.
    tomMathDocDiffDefault              = 0x00000000,
    ///Use upright glyphs for math differentials.
    tomMathDocDiffUpright              = 0x00000100,
    ///Use italic glyphs for math differentials.
    tomMathDocDiffItalic               = 0x00000200,
    ///No glyph change.
    tomMathDocDiffOpenItalic           = 0x00000300,
    ///Math-paragraph non-integral n-ary limits location.
    tomMathDispNarySubSup              = 0x00000400,
    ///Math-paragraph spacing defaults. Use math paragraph offsets instead of regular paragraph offsets.
    tomMathDispDef                     = 0x00000800,
    ///Enable right-to-left (RTL) math zones in RTL paragraphs.
    tomMathEnableRtl                   = 0x00001000,
    ///Equation line break mask.
    tomMathBrkBinMask                  = 0x00030000,
    ///Break before binary/relational operator.
    tomMathBrkBinBefore                = 0x00000000,
    ///Break after binary/relational operator.
    tomMathBrkBinAfter                 = 0x00010000,
    ///Duplicate binary/relational before/after.
    tomMathBrkBinDup                   = 0x00020000,
    ///Duplicate mask for minus operator.
    tomMathBrkBinSubMask               = 0x000c0000,
    ///-- (minus on both lines).
    tomMathBrkBinSubMM                 = 0x00000000,
    ///+ -
    tomMathBrkBinSubPM                 = 0x00040000,
    ///- +
    tomMathBrkBinSubMP                 = 0x00080000,
    ///Set the selection character position and character count to range values.
    tomSelRange                        = 0x00000255,
    ///Use a string handle (<b>HSTRING</b>) instead of a binary string (<b>BSTR</b>).
    tomHstring                         = 0x00000254,
    ///Gets the TeX style of the font.
    tomFontPropTeXStyle                = 0x0000033c,
    ///Use <b>tomFontPropAlign</b> to get the <b>Align</b> property of an operator in a math zone. Here are how the
    ///values are assigned:<ul> <li>Value 0 implies no special alignment.</li> <li>Values 1 through 127 align the
    ///operator with the (n – 1)st operator on the first line of an equation.</li> <li>Value 128 identifies operators
    ///to be vertically aligned with respect to one another ("Align at ="). </li> <li>Other values are illegal.</li>
    ///</ul>
    tomFontPropAlign                   = 0x0000033d,
    ///The type of font stretching. It can have one of the following values. <b>tomFontStretchDefault</b>
    ///<b>tomFontStretchUltraCondensed</b> <b>tomFontStretchExtraCondensed</b> <b>tomFontStretchCondensed</b>
    ///<b>tomFontStretchNormal</b> <b>tomFontStretchSemiExpanded</b> <b>tomFontStretchExpanded</b>
    ///<b>tomFontStretchExtraExpanded</b> <b>tomFontStretchUltraExpanded</b>
    tomFontStretch                     = 0x0000033e,
    ///The font style. It can have one of the following values.<ul> <li><b>tomFontStyleUpright</b></li>
    ///<li><b>tomFontStyleItalic</b></li> <li><b>tomFontStyleOblique</b></li> </ul>
    tomFontStyle                       = 0x0000033f,
    ///Represents the normal upright font style.
    tomFontStyleUpright                = 0x00000000,
    ///Represents an oblique font style.
    tomFontStyleOblique                = 0x00000001,
    ///Represents an italic font style.
    tomFontStyleItalic                 = 0x00000002,
    ///No defined font stretch.
    tomFontStretchDefault              = 0x00000000,
    ///An ultra-condensed font stretch (50% of normal).
    tomFontStretchUltraCondensed       = 0x00000001,
    ///An extra-condensed font stretch (62.5% of normal).
    tomFontStretchExtraCondensed       = 0x00000002,
    ///A condensed font stretch (75% of normal).
    tomFontStretchCondensed            = 0x00000003,
    ///A semi-condensed font stretch (87.5% of normal).
    tomFontStretchSemiCondensed        = 0x00000004,
    ///The normal font stretch that all other font stretch values relate to (100%).
    tomFontStretchNormal               = 0x00000005,
    ///A semi-expanded font stretch (112.5% of normal).
    tomFontStretchSemiExpanded         = 0x00000006,
    ///An expanded font stretch (125% of normal).
    tomFontStretchExpanded             = 0x00000007,
    ///An extra-expanded font stretch (150% of normal).
    tomFontStretchExtraExpanded        = 0x00000008,
    ///An ultra-expanded font stretch (200% of normal).
    tomFontStretchUltraExpanded        = 0x00000009,
    ///The default font weight.
    tomFontWeightDefault               = 0x00000000,
    ///Thin font weight.
    tomFontWeightThin                  = 0x00000064,
    ///Extra light font weight.
    tomFontWeightExtraLight            = 0x000000c8,
    ///Light font weight.
    tomFontWeightLight                 = 0x0000012c,
    ///Normal font weight.
    tomFontWeightNormal                = 0x00000190,
    ///Same as <b>tomFontWeightNormal</b>.
    tomFontWeightRegular               = 0x00000190,
    ///Medium font weight.
    tomFontWeightMedium                = 0x000001f4,
    ///Semi bold font weight.
    tomFontWeightSemiBold              = 0x00000258,
    ///Bold font weight.
    tomFontWeightBold                  = 0x000002bc,
    ///Extra bold font weight.
    tomFontWeightExtraBold             = 0x00000320,
    ///Heavy font weight.
    tomFontWeightBlack                 = 0x00000384,
    ///Same as <b>tomFontWeightBlack</b>.
    tomFontWeightHeavy                 = 0x00000384,
    ///Extra heavy font weight.
    tomFontWeightExtraBlack            = 0x000003b6,
    ///Alignment properties for a math paragraph.
    tomParaPropMathAlign               = 0x00000437,
    ///Used with the ITextDocument2::SetProperty method to set any combination of <b>tomMathAutoCorrect</b>,
    ///<b>tomTeX</b>, or <b>tomMathAlphabetics</b>.
    tomDocMathBuild                    = 0x00000080,
    ///Left margin for display math.
    tomMathLMargin                     = 0x00000081,
    ///Right margin for display math.
    tomMathRMargin                     = 0x00000082,
    ///Equation wrap indent for display math.
    tomMathWrapIndent                  = 0x00000083,
    ///Equation right wrap indent for display math (in a left-to-right (LTR) math zone).
    tomMathWrapRight                   = 0x00000084,
    ///Space after a display math equation.
    tomMathPostSpace                   = 0x00000086,
    ///Space before a display math equation.
    tomMathPreSpace                    = 0x00000085,
    ///Space between equations in math paragraphs.
    tomMathInterSpace                  = 0x00000087,
    ///Space between lines in a display math equation.
    tomMathIntraSpace                  = 0x00000088,
    ///Indicates whether data can be copied to the clipboard.
    tomCanCopy                         = 0x00000089,
    ///Indicates whether one or more redo operations exist.
    tomCanRedo                         = 0x0000008a,
    ///Indicates whether one or more undo operations exist.
    tomCanUndo                         = 0x0000008b,
    ///The undo stack count limit.
    tomUndoLimit                       = 0x0000008c,
    ///A document automatic link.
    tomDocAutoLink                     = 0x0000008d,
    ///The ellipsis mode.
    tomEllipsisMode                    = 0x0000008e,
    ///The ellipsis state.
    tomEllipsisState                   = 0x0000008f,
    ///Ellipsis is disabled.
    tomEllipsisNone                    = 0x00000000,
    ///An ellipsis forces a break anywhere in the line.
    tomEllipsisEnd                     = 0x00000001,
    ///An ellipsis forces a break between words.
    tomEllipsisWord                    = 0x00000003,
    ///Ellipsis is present.
    tomEllipsisPresent                 = 0x00000001,
    ///The top cell in vertically merged cell set.
    tomVTopCell                        = 0x00000001,
    ///Any cell except the top cell in a vertically merged cell set.
    tomVLowCell                        = 0x00000002,
    ///Start a cell in a horizontally merged cell set.
    tomHStartCell                      = 0x00000004,
    ///Any cell except the start in a horizontally merged cell set.
    tomHContCell                       = 0x00000008,
    ///Update the row to have the properties of the table row identified by the associated text range.
    tomRowUpdate                       = 0x00000001,
    tomRowApplyDefault                 = 0x00000000,
    ///Changes cell width(s) or cell count (for changing column widths and inserting/deleting columns without changing
    ///cell border properties, and so forth.)
    tomCellStructureChangeOnly         = 0x00000001,
    ///The actual height of a table row.
    tomRowHeightActual                 = 0x0000080b,
}

///Defines values that identify object types in the Text Object Model (TOM) content.
alias OBJECTTYPE = int;
enum : int
{
    ///Not an inline function.
    tomSimpleText       = 0x00000000,
    ///Base text with ruby annotation.
    tomRuby             = 0x00000001,
    ///Text flows horizontally in a vertically oriented document.
    tomHorzVert         = 0x00000002,
    ///A Warichu "2 lines in one" comment.
    tomWarichu          = 0x00000003,
    ///An RTF Eq (equation) field.
    tomEq               = 0x00000009,
    ///Math.
    tomMath             = 0x0000000a,
    ///Accent (combining mark).
    tomAccent           = 0x0000000a,
    ///Abstract box with properties.
    tomBox              = 0x0000000b,
    ///Encloses the argument in a rectangle.
    tomBoxedFormula     = 0x0000000c,
    ///Encloses the argument in brackets, parentheses, and so on.
    tomBrackets         = 0x0000000d,
    ///Encloses the argument in brackets, parentheses, and so on, and with separators.
    tomBracketsWithSeps = 0x0000000e,
    ///Column of aligned equations.
    tomEquationArray    = 0x0000000f,
    ///Fraction.
    tomFraction         = 0x00000010,
    ///Function apply.
    tomFunctionApply    = 0x00000011,
    ///Left subscript or superscript.
    tomLeftSubSup       = 0x00000012,
    ///Second argument below the first.
    tomLowerLimit       = 0x00000013,
    ///Matrix.
    tomMatrix           = 0x00000014,
    ///General <i>n</i>-ary expression.
    tomNary             = 0x00000015,
    ///Internal use for no-build operators.
    tomOpChar           = 0x00000016,
    ///Overscores argument.
    tomOverbar          = 0x00000017,
    ///Special spacing.
    tomPhantom          = 0x00000018,
    ///Square root, and so on.
    tomRadical          = 0x00000019,
    ///Skewed and built-up linear fractions.
    tomSlashedFraction  = 0x0000001a,
    ///"Fraction" with no divide bar.
    tomStack            = 0x0000001b,
    ///Stretch character horizontally over or under argument.
    tomStretchStack     = 0x0000001c,
    ///Subscript.
    tomSubscript        = 0x0000001d,
    ///Subscript and superscript combination.
    tomSubSup           = 0x0000001e,
    ///Superscript.
    tomSuperscript      = 0x0000001f,
    ///Underscores the argument.
    tomUnderbar         = 0x00000020,
    ///Second argument above the first.
    tomUpperLimit       = 0x00000021,
    tomObjectMax        = 0x00000021,
}

///Represents mathematical alphanumeric codes.
alias MANCODE = int;
enum : int
{
    ///Bold
    MBOLD   = 0x00000010,
    ///Italics
    MITAL   = 0x00000020,
    ///Greek
    MGREEK  = 0x00000040,
    ///Roman
    MROMN   = 0x00000000,
    ///Script
    MSCRP   = 0x00000001,
    ///Fraktur
    MFRAK   = 0x00000002,
    ///Double struck
    MOPEN   = 0x00000003,
    ///Sans-serif
    MSANS   = 0x00000004,
    ///Monospaced
    MMONO   = 0x00000005,
    ///Math
    MMATH   = 0x00000006,
    ///Isolated
    MISOL   = 0x00000007,
    ///Initial
    MINIT   = 0x00000008,
    ///Tailed
    MTAIL   = 0x00000009,
    ///Stretched
    MSTRCH  = 0x0000000a,
    ///Looped
    MLOOP   = 0x0000000b,
    MOPENA  = 0x0000000c,
}

alias TXTBACKSTYLE = int;
enum : int
{
    TXTBACK_TRANSPARENT = 0x00000000,
    TXTBACK_OPAQUE      = 0x00000001,
}

alias TXTHITRESULT = int;
enum : int
{
    TXTHITRESULT_NOHIT       = 0x00000000,
    TXTHITRESULT_TRANSPARENT = 0x00000001,
    TXTHITRESULT_CLOSE       = 0x00000002,
    TXTHITRESULT_HIT         = 0x00000003,
}

alias TXTNATURALSIZE = int;
enum : int
{
    TXTNS_FITTOCONTENT2   = 0x00000000,
    TXTNS_FITTOCONTENT    = 0x00000001,
    TXTNS_ROUNDTOLINE     = 0x00000002,
    TXTNS_FITTOCONTENT3   = 0x00000003,
    TXTNS_FITTOCONTENTWSP = 0x00000004,
    TXTNS_INCLUDELASTLINE = 0x40000000,
    TXTNS_EMU             = 0x80000000,
}

alias TXTVIEW = int;
enum : int
{
    TXTVIEW_ACTIVE   = 0x00000000,
    TXTVIEW_INACTIVE = 0xffffffff,
}

alias CHANGETYPE = int;
enum : int
{
    CN_GENERIC     = 0x00000000,
    CN_TEXTCHANGED = 0x00000001,
    CN_NEWUNDO     = 0x00000002,
    CN_NEWREDO     = 0x00000004,
}

alias CARET_FLAGS = int;
enum : int
{
    CARET_NONE     = 0x00000000,
    CARET_CUSTOM   = 0x00000001,
    CARET_RTL      = 0x00000002,
    CARET_ITALIC   = 0x00000020,
    CARET_NULL     = 0x00000040,
    CARET_ROTATE90 = 0x00000080,
}

alias TA_PROPERTY = int;
enum : int
{
    TAP_FLAGS              = 0x00000000,
    TAP_TRANSFORMCOUNT     = 0x00000001,
    TAP_STAGGERDELAY       = 0x00000002,
    TAP_STAGGERDELAYCAP    = 0x00000003,
    TAP_STAGGERDELAYFACTOR = 0x00000004,
    TAP_ZORDER             = 0x00000005,
}

alias TA_PROPERTY_FLAG = int;
enum : int
{
    TAPF_NONE            = 0x00000000,
    TAPF_HASSTAGGER      = 0x00000001,
    TAPF_ISRTLAWARE      = 0x00000002,
    TAPF_ALLOWCOLLECTION = 0x00000004,
    TAPF_HASBACKGROUND   = 0x00000008,
    TAPF_HASPERSPECTIVE  = 0x00000010,
}

alias TA_TRANSFORM_TYPE = int;
enum : int
{
    TATT_TRANSLATE_2D = 0x00000000,
    TATT_SCALE_2D     = 0x00000001,
    TATT_OPACITY      = 0x00000002,
    TATT_CLIP         = 0x00000003,
}

alias TA_TRANSFORM_FLAG = int;
enum : int
{
    TATF_NONE              = 0x00000000,
    TATF_TARGETVALUES_USER = 0x00000001,
    TATF_HASINITIALVALUES  = 0x00000002,
    TATF_HASORIGINVALUES   = 0x00000004,
}

alias TA_TIMINGFUNCTION_TYPE = int;
enum : int
{
    TTFT_UNDEFINED    = 0x00000000,
    TTFT_CUBIC_BEZIER = 0x00000001,
}

///Identifies the type of size value to retrieve for a visual style part.
alias THEMESIZE = int;
enum : int
{
    ///Receives the minimum size of a visual style part.
    TS_MIN  = 0x00000000,
    ///Receives the size of the visual style part that will best fit the available space.
    TS_TRUE = 0x00000001,
    ///Receives the size that the theme manager uses to draw a part.
    TS_DRAW = 0x00000002,
}

///Returned by GetThemePropertyOrigin to specify where a property was found.
alias PROPERTYORIGIN = int;
enum : int
{
    ///Property was found in the state section.
    PO_STATE    = 0x00000000,
    ///Property was found in the part section.
    PO_PART     = 0x00000001,
    ///Property was found in the class section.
    PO_CLASS    = 0x00000002,
    ///Property was found in the list of global variables.
    PO_GLOBAL   = 0x00000003,
    ///Property was not found.
    PO_NOTFOUND = 0x00000004,
}

///Specifies the type of visual style attribute to set on a window.
alias WINDOWTHEMEATTRIBUTETYPE = int;
enum : int
{
    ///Non-client area window attributes will be set.
    WTA_NONCLIENT = 0x00000001,
}

///Specifies the format of the buffer. Used by BeginBufferedAnimation and BeginBufferedPaint.
alias BP_BUFFERFORMAT = int;
enum : int
{
    ///Compatible bitmap. The number of bits per pixel is based on the color format of the device associated with the
    ///HDC specified with BeginBufferedPaint or BeginBufferedAnimation—typically, this is the display device.
    BPBF_COMPATIBLEBITMAP = 0x00000000,
    ///Bottom-up device-independent bitmap. The origin of the bitmap is the lower-left corner. Uses 32 bits per pixel.
    BPBF_DIB              = 0x00000001,
    ///Top-down device-independent bitmap. The origin of the bitmap is the upper-left corner. Uses 32 bits per pixel.
    BPBF_TOPDOWNDIB       = 0x00000002,
    ///Top-down, monochrome, device-independent bitmap. Uses 1 bit per pixel.
    BPBF_TOPDOWNMONODIB   = 0x00000003,
}

///Used in the BP_ANIMATIONPARAMS structure to declare animation options.
alias BP_ANIMATIONSTYLE = int;
enum : int
{
    ///No animation. Not implemented in Windows Vista.
    BPAS_NONE   = 0x00000000,
    ///Linear fade animation.
    BPAS_LINEAR = 0x00000001,
    ///Cubic fade animation. Not implemented in Windows Vista.
    BPAS_CUBIC  = 0x00000002,
    BPAS_SINE   = 0x00000003,
}

// Callbacks

///An application-defined callback function used with the EM_SETWORDBREAKPROC message. A multiline edit control or a
///rich edit control calls an <i>EditWordBreakProc</i> function to break a line of text. The <b>EDITWORDBREAKPROC</b>
///type defines a pointer to this callback function. <i>EditWordBreakProc</i> is a placeholder for the
///application-defined function name.
///Params:
///    lpch = Type: <b>LPTSTR</b> A pointer to the text of the edit control.
///    ichCurrent = Type: <b>int</b> An index to a character position in the buffer of text that identifies the point at which the
///                 function should begin checking for a word break.
///    cch = Type: <b>int</b> The number of <b>TCHARs</b> in the edit control text. For the ANSI text, this is the number of
///          bytes; for the Unicode text, this is the number of WCHARs.
///    code = Type: <b>int</b> The action to be taken by the callback function. This parameter can be one of the following
///           values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="WB_CLASSIFY"></a><a
///           id="wb_classify"></a><dl> <dt><b>WB_CLASSIFY</b></dt> </dl> </td> <td width="60%"> Retrieves the character class
///           and word break flags of the character at the specified position. This value is for use with rich edit controls.
///           </td> </tr> <tr> <td width="40%"><a id="WB_ISDELIMITER"></a><a id="wb_isdelimiter"></a><dl>
///           <dt><b>WB_ISDELIMITER</b></dt> </dl> </td> <td width="60%"> Checks whether the character at the specified
///           position is a delimiter. </td> </tr> <tr> <td width="40%"><a id="WB_LEFT"></a><a id="wb_left"></a><dl>
///           <dt><b>WB_LEFT</b></dt> </dl> </td> <td width="60%"> Finds the beginning of a word to the left of the specified
///           position. </td> </tr> <tr> <td width="40%"><a id="WB_LEFTBREAK"></a><a id="wb_leftbreak"></a><dl>
///           <dt><b>WB_LEFTBREAK</b></dt> </dl> </td> <td width="60%"> Finds the end-of-word delimiter to the left of the
///           specified position. This value is for use with rich edit controls. </td> </tr> <tr> <td width="40%"><a
///           id="WB_MOVEWORDLEFT"></a><a id="wb_movewordleft"></a><dl> <dt><b>WB_MOVEWORDLEFT</b></dt> </dl> </td> <td
///           width="60%"> Finds the beginning of a word to the left of the specified position. This value is used during
///           CTRL+LEFT key processing. This value is for use with rich edit controls. </td> </tr> <tr> <td width="40%"><a
///           id="WB_MOVEWORDRIGHT"></a><a id="wb_movewordright"></a><dl> <dt><b>WB_MOVEWORDRIGHT</b></dt> </dl> </td> <td
///           width="60%"> Finds the beginning of a word to the right of the specified position. This value is used during
///           CTRL+RIGHT key processing. This value is for use with rich edit controls. </td> </tr> <tr> <td width="40%"><a
///           id="WB_RIGHT"></a><a id="wb_right"></a><dl> <dt><b>WB_RIGHT</b></dt> </dl> </td> <td width="60%"> Finds the
///           beginning of a word to the right of the specified position. This is useful in right-aligned edit controls. </td>
///           </tr> <tr> <td width="40%"><a id="WB_RIGHTBREAK"></a><a id="wb_rightbreak"></a><dl> <dt><b>WB_RIGHTBREAK</b></dt>
///           </dl> </td> <td width="60%"> Finds the end-of-word delimiter to the right of the specified position. This is
///           useful in right-aligned edit controls. This value is for use with rich edit controls. </td> </tr> </table>
///Returns:
///    Type: <b>int</b> If the <i>code</i> parameter specifies <b>WB_ISDELIMITER</b>, the return value is nonzero (TRUE)
///    if the character at the specified position is a delimiter, or zero if it is not. If the <i>code</i> parameter
///    specifies <b>WB_CLASSIFY</b>, the return value is the character class and word break flags of the character at
///    the specified position. Otherwise, the return value is an index to the beginning of a word in the buffer of text.
///    
alias EDITWORDBREAKPROCA = int function(PSTR lpch, int ichCurrent, int cch, int code);
///An application-defined callback function used with the EM_SETWORDBREAKPROC message. A multiline edit control or a
///rich edit control calls an <i>EditWordBreakProc</i> function to break a line of text. The <b>EDITWORDBREAKPROC</b>
///type defines a pointer to this callback function. <i>EditWordBreakProc</i> is a placeholder for the
///application-defined function name.
///Params:
///    lpch = Type: <b>LPTSTR</b> A pointer to the text of the edit control.
///    ichCurrent = Type: <b>int</b> An index to a character position in the buffer of text that identifies the point at which the
///                 function should begin checking for a word break.
///    cch = Type: <b>int</b> The number of <b>TCHARs</b> in the edit control text. For the ANSI text, this is the number of
///          bytes; for the Unicode text, this is the number of WCHARs.
///    code = Type: <b>int</b> The action to be taken by the callback function. This parameter can be one of the following
///           values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="WB_CLASSIFY"></a><a
///           id="wb_classify"></a><dl> <dt><b>WB_CLASSIFY</b></dt> </dl> </td> <td width="60%"> Retrieves the character class
///           and word break flags of the character at the specified position. This value is for use with rich edit controls.
///           </td> </tr> <tr> <td width="40%"><a id="WB_ISDELIMITER"></a><a id="wb_isdelimiter"></a><dl>
///           <dt><b>WB_ISDELIMITER</b></dt> </dl> </td> <td width="60%"> Checks whether the character at the specified
///           position is a delimiter. </td> </tr> <tr> <td width="40%"><a id="WB_LEFT"></a><a id="wb_left"></a><dl>
///           <dt><b>WB_LEFT</b></dt> </dl> </td> <td width="60%"> Finds the beginning of a word to the left of the specified
///           position. </td> </tr> <tr> <td width="40%"><a id="WB_LEFTBREAK"></a><a id="wb_leftbreak"></a><dl>
///           <dt><b>WB_LEFTBREAK</b></dt> </dl> </td> <td width="60%"> Finds the end-of-word delimiter to the left of the
///           specified position. This value is for use with rich edit controls. </td> </tr> <tr> <td width="40%"><a
///           id="WB_MOVEWORDLEFT"></a><a id="wb_movewordleft"></a><dl> <dt><b>WB_MOVEWORDLEFT</b></dt> </dl> </td> <td
///           width="60%"> Finds the beginning of a word to the left of the specified position. This value is used during
///           CTRL+LEFT key processing. This value is for use with rich edit controls. </td> </tr> <tr> <td width="40%"><a
///           id="WB_MOVEWORDRIGHT"></a><a id="wb_movewordright"></a><dl> <dt><b>WB_MOVEWORDRIGHT</b></dt> </dl> </td> <td
///           width="60%"> Finds the beginning of a word to the right of the specified position. This value is used during
///           CTRL+RIGHT key processing. This value is for use with rich edit controls. </td> </tr> <tr> <td width="40%"><a
///           id="WB_RIGHT"></a><a id="wb_right"></a><dl> <dt><b>WB_RIGHT</b></dt> </dl> </td> <td width="60%"> Finds the
///           beginning of a word to the right of the specified position. This is useful in right-aligned edit controls. </td>
///           </tr> <tr> <td width="40%"><a id="WB_RIGHTBREAK"></a><a id="wb_rightbreak"></a><dl> <dt><b>WB_RIGHTBREAK</b></dt>
///           </dl> </td> <td width="60%"> Finds the end-of-word delimiter to the right of the specified position. This is
///           useful in right-aligned edit controls. This value is for use with rich edit controls. </td> </tr> </table>
///Returns:
///    Type: <b>int</b> If the <i>code</i> parameter specifies <b>WB_ISDELIMITER</b>, the return value is nonzero (TRUE)
///    if the character at the specified position is a delimiter, or zero if it is not. If the <i>code</i> parameter
///    specifies <b>WB_CLASSIFY</b>, the return value is the character class and word break flags of the character at
///    the specified position. Otherwise, the return value is an index to the beginning of a word in the buffer of text.
///    
alias EDITWORDBREAKPROCW = int function(PWSTR lpch, int ichCurrent, int cch, int code);
///Specifies an application-defined callback function that a property sheet calls when a page is created and when it is
///about to be destroyed. An application can use this function to perform initialization and cleanup operations for the
///page.
///Params:
///    hwnd = Type: <b>HWND</b> Reserved; must be <b>NULL</b>.
///    uMsg = Type: <b>UINT</b> Action flag. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PSPCB_ADDREF"></a><a id="pspcb_addref"></a><dl>
///           <dt><b>PSPCB_ADDREF</b></dt> </dl> </td> <td width="60%"> Version 5.80 or later. A page is being created. The
///           return value is not used. </td> </tr> <tr> <td width="40%"><a id="PSPCB_CREATE"></a><a id="pspcb_create"></a><dl>
///           <dt><b>PSPCB_CREATE</b></dt> </dl> </td> <td width="60%"> A dialog box for a page is being created. Return
///           nonzero to allow it to be created, or zero to prevent it. </td> </tr> <tr> <td width="40%"><a
///           id="PSPCB_RELEASE"></a><a id="pspcb_release"></a><dl> <dt><b>PSPCB_RELEASE</b></dt> </dl> </td> <td width="60%">
///           A page is being destroyed. The return value is ignored. </td> </tr> </table>
///    ppsp = Type: <b>LPPROPSHEETPAGE</b> Pointer to a PROPSHEETPAGE structure that defines the page being created or
///           destroyed. See the Remarks section for further discussion.
///Returns:
///    Type: <b>UINT</b> The return value depends on the value of the <i>uMsg</i> parameter.
///    
alias LPFNPSPCALLBACKA = uint function(HWND hwnd, uint uMsg, PROPSHEETPAGEA* ppsp);
///Specifies an application-defined callback function that a property sheet calls when a page is created and when it is
///about to be destroyed. An application can use this function to perform initialization and cleanup operations for the
///page.
///Params:
///    hwnd = Type: <b>HWND</b> Reserved; must be <b>NULL</b>.
///    uMsg = Type: <b>UINT</b> Action flag. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PSPCB_ADDREF"></a><a id="pspcb_addref"></a><dl>
///           <dt><b>PSPCB_ADDREF</b></dt> </dl> </td> <td width="60%"> Version 5.80 or later. A page is being created. The
///           return value is not used. </td> </tr> <tr> <td width="40%"><a id="PSPCB_CREATE"></a><a id="pspcb_create"></a><dl>
///           <dt><b>PSPCB_CREATE</b></dt> </dl> </td> <td width="60%"> A dialog box for a page is being created. Return
///           nonzero to allow it to be created, or zero to prevent it. </td> </tr> <tr> <td width="40%"><a
///           id="PSPCB_RELEASE"></a><a id="pspcb_release"></a><dl> <dt><b>PSPCB_RELEASE</b></dt> </dl> </td> <td width="60%">
///           A page is being destroyed. The return value is ignored. </td> </tr> </table>
///    ppsp = Type: <b>LPPROPSHEETPAGE</b> Pointer to a PROPSHEETPAGE structure that defines the page being created or
///           destroyed. See the Remarks section for further discussion.
///Returns:
///    Type: <b>UINT</b> The return value depends on the value of the <i>uMsg</i> parameter.
///    
alias LPFNPSPCALLBACKW = uint function(HWND hwnd, uint uMsg, PROPSHEETPAGEW* ppsp);
///An application-defined callback function that the system calls when the property sheet is being created and
///initialized.
///Params:
///    Arg1 = 
///    Arg2 = 
///    Arg3 = 
///Returns:
///    Type: <b>int</b> Returns zero.
///    
alias PFNPROPSHEETCALLBACK = int function(HWND param0, uint param1, LPARAM param2);
///Specifies an application-defined callback function that a property sheet extension uses to add a page to a property
///sheet.
///Params:
///    Arg1 = 
///    Arg2 = 
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
///    
alias LPFNADDPROPSHEETPAGE = BOOL function(HPROPSHEETPAGE param0, LPARAM param1);
alias LPFNADDPROPSHEETPAGES = BOOL function(void* param0, LPFNADDPROPSHEETPAGE param1, LPARAM param2);
alias PFNLVCOMPARE = int function(LPARAM param0, LPARAM param1, LPARAM param2);
///The <b>LVGroupCompare</b> function is an application-defined callback function used with the LVM_INSERTGROUPSORTED
///and LVM_SORTGROUPS messages. It defines the ordering of the groups, based on the ID. The <b>LVGROUPCOMPARE</b> type
///defines a pointer to this callback function. <b>LVGroupCompare</b> is a placeholder for the application-defined
///function name.
///Params:
///    Arg1 = Type: <b>INT</b> The ID of the first group.
///    Arg2 = Type: <b>INT</b> The ID of the second group.
///    Arg3 = Type: <b>VOID*</b> A pointer to the application-defined information. This comes from the message that was called;
///           for LVM_INSERTGROUPSORTED it is LVINSERTGROUPSORTED.pvData, and for LVM_SORTGROUPS it is the <i>plv</i>
///           parameter.
///Returns:
///    Type: <b>INT</b> Returns a negative value if the data for <i>Group1_ID</i> is less than the data for
///    <i>Group2_ID</i>, a positive value if it is greater, or zero if it is the same.
///    
alias PFNLVGROUPCOMPARE = int function(int param0, int param1, void* param2);
alias PFNTVCOMPARE = int function(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
///The <i>TaskDialogCallbackProc</i> function is an application-defined function used with the TaskDialogIndirect
///function. It receives messages from the task dialog when various events occur. The <b>PFTASKDIALOGCALLBACK</b> type
///defines a pointer to this callback function. <i>TaskDialogCallbackProc</i> is a placeholder for the application
///defined function name.
///Params:
///    hwnd = Type: <b>HWND</b> Handle to the TaskDialog window. Do not continue sending messages to hwnd after the callback
///           procedure returns from having been called with TDN_DESTROYED.
///    msg = Type: <b>UINT</b> One of the following notifications. <table class="clsStd"> <tr> <th>Notification</th>
///          <th>Usage</th> </tr> <tr> <td> TDN_BUTTON_CLICKED </td> <td>Indicates that a button has been selected. The
///          command ID of the button is specified by <i>wParam</i>.</td> </tr> <tr> <td> TDN_CREATED </td> <td>Indicates that
///          the Task Dialog has been created.</td> </tr> <tr> <td> TDN_DESTROYED </td> <td>Indicates that the Task Dialog has
///          been destroyed.</td> </tr> <tr> <td> TDN_DIALOG_CONSTRUCTED </td> <td>Indicates that the Task Dialog has been
///          created but has not been displayed yet.</td> </tr> <tr> <td> TDN_EXPANDO_BUTTON_CLICKED </td> <td>Indicates that
///          the exando button has been selected.</td> </tr> <tr> <td> TDN_HELP </td> <td>Indicates that the F1 key has been
///          pressed while the Task Dialog has focus.</td> </tr> <tr> <td> TDN_HYPERLINK_CLICKED </td> <td>Indicates that a
///          hyperlink has been selected. A pointer to the link text is specified by <i>lParam</i>.</td> </tr> <tr> <td>
///          TDN_NAVIGATED </td> <td>Indicates that navigation has occurred.</td> </tr> <tr> <td> TDN_RADIO_BUTTON_CLICKED
///          </td> <td>Indicates that a radio button has been selected. The command ID of the radio button is specified by
///          <i>wParam</i>.</td> </tr> <tr> <td> TDN_TIMER </td> <td>Indicates that the Task Dialog timer has fired. The total
///          elapsed time is specified by <i>wParam</i>. You can update the progress bar by sending a TDM_SET_PROGRESS_BAR_POS
///          message to the window specified by the <i>hwnd</i> parameter.</td> </tr> <tr> <td> TDN_VERIFICATION_CLICKED </td>
///          <td>Indicates that the Task Dialog verification check box has been selected.</td> </tr> </table>
///    wParam = Type: <b>WPARAM</b> Specifies additional notification information. The contents of this parameter depend on the
///             value of the <i>uNotification</i> parameter.
///    lParam = Type: <b>LPARAM</b> Specifies additional notification information. The contents of this parameter depend on the
///             value of the <i>uNotification</i> parameter.
///    lpRefData = Type: <b>LONG_PTR</b> Pointer to application specific data. This is the data pointed to by the
///                <b>lpCallbackData</b> member of structure TASKDIALOGCONFIG used to create the task dialog.
///Returns:
///    Type: <b>HRESULT</b> The return value is specific to the notification being processed. When responding to a
///    button click, your implementation should return S_FALSE if the Task Dialog is not to close. Otherwise return
///    S_OK.
///    
alias PFTASKDIALOGCALLBACK = HRESULT function(HWND hwnd, uint msg, WPARAM wParam, LPARAM lParam, 
                                              ptrdiff_t lpRefData);
///Defines the prototype for the callback function used by dynamic structure array (DSA) and dynamic pointer array (DPA)
///functions.
///Params:
///    p = Type: <b>void*</b> A pointer to the structure to be enumerated.
///    pData = Type: <b>void*</b> The value that was passed in the <i>pData</i> parameter to function DSA_EnumCallback.
///Returns:
///    Type: <b>int</b> The return value is used to determine whether to terminate or continue the iteration. A return
///    value of zero indicates that the iteration should stop; nonzero indicates that the iteration should continue.
///    
alias PFNDAENUMCALLBACK = int function(void* p, void* pData);
///Defines the prototype for the callback function used by dynamic structure array (DSA) and dynamic pointer array (DPA)
///functions when the items involved are pointers to constant data.
///Params:
///    p = Type: <b>const void*</b> A pointer to the constant structure to be enumerated.
///    pData = Type: <b>void*</b> A value that was passed in the <i>pData</i> parameter to function DSA_EnumCallback or function
///            DPA_EnumCallback.
///Returns:
///    Type: <b>int</b> The return value is used to determine whether to terminate or continue the iteration. A return
///    value of zero indicates that the iteration should stop; nonzero indicates that the iteration should continue.
///    
alias PFNDAENUMCALLBACKCONST = int function(const(void)* p, void* pData);
///Defines the prototype for the compare function used by DSA_Sort.
///Params:
///    p1 = Type: <b>void*</b> A pointer to the first item in the comparison.
///    p2 = Type: <b>void*</b> A pointer to the second item in the comparison.
///    lParam = Type: <b>LPARAM</b> Additional data passed to <i>pfnCmp</i>.
///Returns:
///    Type: <b>int</b> The meaning of the return values depends on the function that uses this callback prototype. The
///    return values for DSA_Sort are the following. <table class="clsStd"> <tr> <td>less than 0</td> <td>If <i>p1</i>
///    should be sorted ahead of <i>p2</i>.</td> </tr> <tr> <td>equal to 0</td> <td>If <i>p1</i> and <i>p2</i> should be
///    sorted together.</td> </tr> <tr> <td>greater than 0</td> <td>If <i>p1</i> should be sorted after <i>p2</i>.</td>
///    </tr> </table>
///    
alias PFNDACOMPARE = int function(void* p1, void* p2, LPARAM lParam);
///Defines the prototype for the compare function used by DSA_Sort when the items being compared are constant objects.
///Params:
///    p1 = Type: <b>const void*</b> A pointer to the first item in the comparison.
///    p2 = Type: <b>const void*</b> A pointer to the second item in the comparison.
///    lParam = Type: <b>LPARAM</b> Additional data passed to <i>pfnCmp</i>.
///Returns:
///    Type: <b>int</b> The meaning of the return values depends on the function that uses this callback prototype. The
///    return values for DSA_Sort are as follows: <table class="clsStd"> <tr> <td>less than 0</td> <td>If <i>p1</i>
///    should be sorted ahead of <i>p2</i>.</td> </tr> <tr> <td>equal to 0</td> <td>If <i>p1</i> and <i>p2</i> should be
///    sorted together.</td> </tr> <tr> <td>greater than 0</td> <td>If <i>p1</i> should be sorted after <i>p2</i>.</td>
///    </tr> </table>
///    
alias PFNDACOMPARECONST = int function(const(void)* p1, const(void)* p2, LPARAM lParam);
///Defines the prototype for the callback function used by DPA_LoadStream and DPA_SaveStream.
///Params:
///    pinfo = Type: <b>DPASTREAMINFO*</b> A pointer to a DPASTREAMINFO structure.
///    pstream = Type: <b>struct IStream*</b> An IStream object to read from or write to.
///    pvInstData = Type: <b>void*</b> A void pointer to callback data that the client passed to DPA_LoadStream or DPA_SaveStream.
alias PFNDPASTREAM = HRESULT function(DPASTREAMINFO* pinfo, IStream pstream, void* pvInstData);
///Defines the prototype for the merge function used by DPA_Merge.
///Params:
///    uMsg = Type: <b>UINT</b> A message that instructs this function how to handle the merge. One of the following values.
///           <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DPAMM_MERGE"></a><a
///           id="dpamm_merge"></a><dl> <dt><b>DPAMM_MERGE</b></dt> <dt>0x1</dt> </dl> </td> <td width="60%"> Perform any
///           additional processing needed when merging <i>pvSrc</i> into <i>pvDest</i>. The function should return a pointer
///           to an item that contains the result of the merge. The value returned by the merge function is stored into the
///           destination, which overwrites the previous value. If the merge function returns <b>NULL</b>, then the merge
///           operation is abandoned. </td> </tr> <tr> <td width="40%"><a id="DPAMM_DELETE"></a><a id="dpamm_delete"></a><dl>
///           <dt><b>DPAMM_DELETE</b></dt> <dt>0x2</dt> </dl> </td> <td width="60%"> Perform any additional processing needed
///           when a delete occurs as part of the merge. The function should return <b>NULL</b>. </td> </tr> <tr> <td
///           width="40%"><a id="DPAMM_INSERT"></a><a id="dpamm_insert"></a><dl> <dt><b>DPAMM_INSERT</b></dt> <dt>0x3</dt>
///           </dl> </td> <td width="60%"> Perform any user-defined processing when the merge results in an item being inserted
///           as part of the merge. The return value of this function should point to the item result that is inserted as part
///           of the merge. If the merge function returns <b>NULL</b>, then the merge operation is abandoned. </td> </tr>
///           </table>
///    pvDest = Type: <b>void*</b> A pointer to the first item in the merge.
///    pvSrc = Type: <b>void*</b> A pointer to the second item in the merge.
///    lParam = Type: <b>LPARAM</b> Additional data that can be used by the merge callback.
///Returns:
///    A pointer to the item which results from the merge or <b>NULL</b> if there is a failure when <b>DPAMM_MERGE</b>
///    or <b>DPAMM_INSERT</b> is used.
///    
alias PFNDPAMERGE = void* function(uint uMsg, void* pvDest, void* pvSrc, LPARAM lParam);
///Defines the prototype for the merge function used by DPA_Merge, using constant values.
///Params:
///    uMsg = Type: <b>UINT</b> A message that instructs this function how to handle the merge. One of the following values.
///           <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DPAMM_MERGE"></a><a
///           id="dpamm_merge"></a><dl> <dt><b>DPAMM_MERGE</b></dt> <dt>0x1</dt> </dl> </td> <td width="60%"> Perform any
///           additional processing needed when merging <i>p2</i> into <i>p1</i>. The function should return a pointer to an
///           item that contains the result of the merge. </td> </tr> <tr> <td width="40%"><a id="DPAMM_DELETE"></a><a
///           id="dpamm_delete"></a><dl> <dt><b>DPAMM_DELETE</b></dt> <dt>0x2</dt> </dl> </td> <td width="60%"> Perform any
///           additional processing needed when a delete occurs as part of the merge. The function should return <b>NULL</b>.
///           </td> </tr> <tr> <td width="40%"><a id="DPAMM_INSERT"></a><a id="dpamm_insert"></a><dl>
///           <dt><b>DPAMM_INSERT</b></dt> <dt>0x3</dt> </dl> </td> <td width="60%"> Perform any user-defined processing when
///           the merge results in an item being inserted as part of the merge. The return value of this function should point
///           to the item result that is inserted as part of the merge. </td> </tr> </table>
///    pvDest = Type: <b>const void*</b> A pointer to the destination item in the merge.
///    pvSrc = Type: <b>const void*</b> A pointer to the source item in the merge.
///    lParam = Type: <b>LPARAM</b> Additional data that can be used by the merge callback.
///Returns:
///    Type: <b>const void*</b> A pointer to constant data which results from the merge, or <b>NULL</b> if there is a
///    failure when DPAMM_MERGE or DPAMM_INSERT is used.
///    
alias PFNDPAMERGECONST = void* function(uint uMsg, const(void)* pvDest, const(void)* pvSrc, LPARAM lParam);
///The <i>AutoCorrectProc</i> function is an application-defined callback function that is used with the
///EM_SETAUTOCORRECTPROC message. <i>AutoCorrectProc</i> is a placeholder for the application-defined function name. It
///provides application-defined automatic error correction for text entered into a rich edit control.
///Params:
///    langid = Type: <b>LANGID</b> Language ID that identifies the autocorrect file to use for automatic correcting.
///    pszBefore = Type: <b>const WCHAR*</b> Autocorrect candidate string.
///    pszAfter = Type: <b>WCHAR*</b> Resulting autocorrect string, if the return value is not <b>ATP_NOCHANGE</b>.
///    cchAfter = Type: <b>LONG</b> Count of characters in <i>pszAfter</i>.
///    pcchReplaced = Type: <b>LONG*</b> Count of trailing characters in <i>pszBefore</i> to replace with <i>pszAfter</i>.
///Returns:
///    Type: <b>int</b> Returns one or more of the following values. <table> <tr> <th>Return code/value</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ATP_NOCHANGE</b></dt> <dt>0</dt> </dl> </td> <td
///    width="60%"> No change. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ATP_CHANGE</b></dt> <dt>1</dt> </dl> </td>
///    <td width="60%"> Change but don’t replace most delimiters, and don’t replace a span of unchanged trailing
///    characters (preserves their formatting). </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ATP_NODELIMITER</b></dt>
///    <dt>2</dt> </dl> </td> <td width="60%"> Change but don’t replace a span of unchanged trailing characters. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ATP_REPLACEALLTEXT</b></dt> <dt>4</dt> </dl> </td> <td width="60%">
///    Replace trailing characters even if they are not changed (uses the same formatting for the entire replacement
///    string). </td> </tr> </table>
///    
alias AutoCorrectProc = int function(ushort langid, const(PWSTR) pszBefore, PWSTR pszAfter, int cchAfter, 
                                     int* pcchReplaced);
///The <i>EditWordBreakProcEx</i> function is an application defined callback function used with the
///EM_SETWORDBREAKPROCEX message. It determines the character index of the word break or the character class and
///word-break flags of the characters in the specified text. The <b>EDITWORDBREAKPROCEX</b> type defines a pointer to
///this callback function. <i>EditWordBreakProcEx</i> is a placeholder for the application-defined function name.
///Params:
///    pchText = Type: <b>char*</b> Pointer to the text at the current position. If <i>code</i> specifies movement to the left,
///              the text is in the elements <i>pchText</i> [–1] through <i>pchText</i> [-<i>cchText</i>], and <i>pchText</i>[0]
///              is undefined. For all other actions, the text is in the elements <i>pchText</i>[0] through <i>pchText</i>[
///              <i>cchText</i>–1].
///    cchText = Type: <b>LONG</b> Number of characters in the buffer in the direction specified by <i>code</i>.
///    bCharSet = Type: <b>BYTE</b> Character set of the text.
///    action = 
///Returns:
///    Type: <b>LONG</b> The function returns a value based on the <i>code</i> parameter. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>code parameter</b></dt> </dl> </td> <td
///    width="60%"> Return value </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WB_CLASSIFY</b></dt> </dl> </td> <td
///    width="60%"> Returns the character class and word-break flags of the character at the specified position. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WB_ISDELIMITER</b></dt> </dl> </td> <td width="60%"> Returns <b>TRUE</b>
///    if the character at the specified position is a delimiter or <b>FALSE</b> if the character is not. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>All other values</b></dt> </dl> </td> <td width="60%"> Returns the character
///    index of the word break. </td> </tr> </table>
///    
alias EDITWORDBREAKPROCEX = int function(byte* pchText, int cchText, ubyte bCharSet, int action);
///The <i>EditStreamCallback</i> function is an application defined callback function used with the EM_STREAMIN and
///EM_STREAMOUT messages. It is used to transfer a stream of data into or out of a rich edit control. The
///<b>EDITSTREAMCALLBACK</b> type defines a pointer to this callback function. <i>EditStreamCallback</i> is a
///placeholder for the application-defined function name.
///Params:
///    dwCookie = Type: <b>DWORD_PTR</b> Value of the <i>dwCookie</i> member of the EDITSTREAM structure. The application specifies
///               this value when it sends the EM_STREAMIN or EM_STREAMOUT message.
///    pbBuff = Type: <b>LPBYTE</b> Pointer to a buffer to read from or write to. For a stream-in (read) operation, the callback
///             function fills this buffer with data to transfer into the rich edit control. For a stream-out (write) operation,
///             the buffer contains data from the control that the callback function writes to some storage.
///    cb = Type: <b>LONG</b> Number of bytes to read or write.
///    pcb = Type: <b>LONG*</b> Pointer to a variable that the callback function sets to the number of bytes actually read or
///          written.
///Returns:
///    Type: <b>DWORD</b> The callback function returns zero to indicate success. The callback function returns a
///    nonzero value to indicate an error. If an error occurs, the read or write operation ends and the rich edit
///    control discards any data in the <i>pbBuff</i> buffer. If the callback function returns a nonzero value, the rich
///    edit control uses the <i>dwError</i> member of the EDITSTREAM structure to pass the value back to the
///    application.
///    
alias EDITSTREAMCALLBACK = uint function(size_t dwCookie, ubyte* pbBuff, int cb, int* pcb);
alias PCreateTextServices = HRESULT function(IUnknown punkOuter, ITextHost pITextHost, IUnknown* ppUnk);
alias PShutdownTextServices = HRESULT function(IUnknown pTextServices);
alias DTT_CALLBACK_PROC = int function(HDC hdc, PWSTR pszText, int cchText, RECT* prc, uint dwFlags, LPARAM lParam);

// Structs


///Contains information about a notification message.
struct NMHDR
{
    ///Type: <b>HWND</b> A window handle to the control sending the message.
    HWND   hwndFrom;
    ///Type: <b>UINT_PTR</b> An identifier of the control sending the message.
    size_t idFrom;
    uint   code;
}

///Informs the system of the dimensions of an owner-drawn control or menu item. This allows the system to process user
///interaction with the control correctly.
struct MEASUREITEMSTRUCT
{
    ///Type: <b>UINT</b> The control type. This member can be one of the values shown in the following table. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ODT_COMBOBOX"></a><a
    ///id="odt_combobox"></a><dl> <dt><b>ODT_COMBOBOX</b></dt> </dl> </td> <td width="60%"> Owner-drawn combo box </td>
    ///</tr> <tr> <td width="40%"><a id="ODT_LISTBOX"></a><a id="odt_listbox"></a><dl> <dt><b>ODT_LISTBOX</b></dt> </dl>
    ///</td> <td width="60%"> Owner-drawn list box </td> </tr> <tr> <td width="40%"><a id="ODT_LISTVIEW"></a><a
    ///id="odt_listview"></a><dl> <dt><b>ODT_LISTVIEW</b></dt> </dl> </td> <td width="60%"> Owner-draw list-view control
    ///</td> </tr> <tr> <td width="40%"><a id="ODT_MENU"></a><a id="odt_menu"></a><dl> <dt><b>ODT_MENU</b></dt> </dl>
    ///</td> <td width="60%"> Owner-drawn menu </td> </tr> </table>
    uint   CtlType;
    ///Type: <b>UINT</b> The identifier of the combo box or list box. This member is not used for a menu.
    uint   CtlID;
    ///Type: <b>UINT</b> The identifier for a menu item or the position of a list box or combo box item. This value is
    ///specified for a list box only if it has the LBS_OWNERDRAWVARIABLE style; this value is specified for a combo box
    ///only if it has the CBS_OWNERDRAWVARIABLE style.
    uint   itemID;
    ///Type: <b>UINT</b> The width, in pixels, of a menu item. Before returning from the message, the owner of the
    ///owner-drawn menu item must fill this member.
    uint   itemWidth;
    ///Type: <b>UINT</b> The height, in pixels, of an individual item in a list box or a menu. Before returning from the
    ///message, the owner of the owner-drawn combo box, list box, or menu item must fill out this member.
    uint   itemHeight;
    ///Type: <b>ULONG_PTR</b> The application-defined value associated with the menu item. For a control, this member
    ///specifies the value last assigned to the list box or combo box by the LB_SETITEMDATA or CB_SETITEMDATA message.
    ///If the list box or combo box has the LB_HASSTRINGS or CB_HASSTRINGS style, this value is initially zero.
    ///Otherwise, this value is initially the value passed to the list box or combo box in the <i>lParam</i> parameter
    ///of one of the following messages: <ul> <li> CB_ADDSTRING </li> <li> CB_INSERTSTRING </li> <li> LB_ADDSTRING </li>
    ///<li> LB_INSERTSTRING </li> </ul>
    size_t itemData;
}

///Provides information that the owner window uses to determine how to paint an owner-drawn control or menu item. The
///owner window of the owner-drawn control or menu item receives a pointer to this structure as the <i>lParam</i>
///parameter of the WM_DRAWITEM message.
struct DRAWITEMSTRUCT
{
    ///Type: <b>UINT</b> The control type. This member can be one of the following values. See Remarks. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ODT_BUTTON"></a><a id="odt_button"></a><dl>
    ///<dt><b>ODT_BUTTON</b></dt> </dl> </td> <td width="60%"> Owner-drawn button </td> </tr> <tr> <td width="40%"><a
    ///id="ODT_COMBOBOX"></a><a id="odt_combobox"></a><dl> <dt><b>ODT_COMBOBOX</b></dt> </dl> </td> <td width="60%">
    ///Owner-drawn combo box </td> </tr> <tr> <td width="40%"><a id="ODT_LISTBOX"></a><a id="odt_listbox"></a><dl>
    ///<dt><b>ODT_LISTBOX</b></dt> </dl> </td> <td width="60%"> Owner-drawn list box </td> </tr> <tr> <td width="40%"><a
    ///id="ODT_LISTVIEW"></a><a id="odt_listview"></a><dl> <dt><b>ODT_LISTVIEW</b></dt> </dl> </td> <td width="60%">
    ///List-view control </td> </tr> <tr> <td width="40%"><a id="ODT_MENU"></a><a id="odt_menu"></a><dl>
    ///<dt><b>ODT_MENU</b></dt> </dl> </td> <td width="60%"> Owner-drawn menu item </td> </tr> <tr> <td width="40%"><a
    ///id="ODT_STATIC"></a><a id="odt_static"></a><dl> <dt><b>ODT_STATIC</b></dt> </dl> </td> <td width="60%">
    ///Owner-drawn static control </td> </tr> <tr> <td width="40%"><a id="ODT_TAB"></a><a id="odt_tab"></a><dl>
    ///<dt><b>ODT_TAB</b></dt> </dl> </td> <td width="60%"> Tab control </td> </tr> </table>
    uint   CtlType;
    ///Type: <b>UINT</b> The identifier of the combo box, list box, button, or static control. This member is not used
    ///for a menu item.
    uint   CtlID;
    ///Type: <b>UINT</b> The menu item identifier for a menu item or the index of the item in a list box or combo box.
    ///For an empty list box or combo box, this member can be <code>-1</code>. This allows the application to draw only
    ///the focus rectangle at the coordinates specified by the <b>rcItem</b> member even though there are no items in
    ///the control. This indicates to the user whether the list box or combo box has the focus. How the bits are set in
    ///the <b>itemAction</b> member determines whether the rectangle is to be drawn as though the list box or combo box
    ///has the focus.
    uint   itemID;
    ///Type: <b>UINT</b> The required drawing action. This member can be one or more of the values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ODA_DRAWENTIRE"></a><a
    ///id="oda_drawentire"></a><dl> <dt><b>ODA_DRAWENTIRE</b></dt> </dl> </td> <td width="60%"> The entire control needs
    ///to be drawn. </td> </tr> <tr> <td width="40%"><a id="ODA_FOCUS"></a><a id="oda_focus"></a><dl>
    ///<dt><b>ODA_FOCUS</b></dt> </dl> </td> <td width="60%"> The control has lost or gained the keyboard focus. The
    ///<b>itemState</b> member should be checked to determine whether the control has the focus. </td> </tr> <tr> <td
    ///width="40%"><a id="ODA_SELECT"></a><a id="oda_select"></a><dl> <dt><b>ODA_SELECT</b></dt> </dl> </td> <td
    ///width="60%"> The selection status has changed. The <b>itemState</b> member should be checked to determine the new
    ///selection state. </td> </tr> </table>
    uint   itemAction;
    ///Type: <b>UINT</b> The visual state of the item after the current drawing action takes place. This member can be a
    ///combination of the values shown in the following table. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="ODS_CHECKED"></a><a id="ods_checked"></a><dl> <dt><b>ODS_CHECKED</b></dt> </dl> </td> <td
    ///width="60%"> The menu item is to be checked. This bit is used only in a menu. </td> </tr> <tr> <td width="40%"><a
    ///id="ODS_COMBOBOXEDIT"></a><a id="ods_comboboxedit"></a><dl> <dt><b>ODS_COMBOBOXEDIT</b></dt> </dl> </td> <td
    ///width="60%"> The drawing takes place in the selection field (edit control) of an owner-drawn combo box. </td>
    ///</tr> <tr> <td width="40%"><a id="ODS_DEFAULT"></a><a id="ods_default"></a><dl> <dt><b>ODS_DEFAULT</b></dt> </dl>
    ///</td> <td width="60%"> The item is the default item. </td> </tr> <tr> <td width="40%"><a id="ODS_DISABLED"></a><a
    ///id="ods_disabled"></a><dl> <dt><b>ODS_DISABLED</b></dt> </dl> </td> <td width="60%"> The item is to be drawn as
    ///disabled. </td> </tr> <tr> <td width="40%"><a id="ODS_FOCUS"></a><a id="ods_focus"></a><dl>
    ///<dt><b>ODS_FOCUS</b></dt> </dl> </td> <td width="60%"> The item has the keyboard focus. </td> </tr> <tr> <td
    ///width="40%"><a id="ODS_GRAYED"></a><a id="ods_grayed"></a><dl> <dt><b>ODS_GRAYED</b></dt> </dl> </td> <td
    ///width="60%"> The item is to be grayed. This bit is used only in a menu. </td> </tr> <tr> <td width="40%"><a
    ///id="ODS_HOTLIGHT"></a><a id="ods_hotlight"></a><dl> <dt><b>ODS_HOTLIGHT</b></dt> </dl> </td> <td width="60%"> The
    ///item is being hot-tracked, that is, the item will be highlighted when the mouse is on the item. </td> </tr> <tr>
    ///<td width="40%"><a id="ODS_INACTIVE"></a><a id="ods_inactive"></a><dl> <dt><b>ODS_INACTIVE</b></dt> </dl> </td>
    ///<td width="60%"> The item is inactive and the window associated with the menu is inactive. </td> </tr> <tr> <td
    ///width="40%"><a id="ODS_NOACCEL"></a><a id="ods_noaccel"></a><dl> <dt><b>ODS_NOACCEL</b></dt> </dl> </td> <td
    ///width="60%"> The control is drawn without the keyboard accelerator cues. </td> </tr> <tr> <td width="40%"><a
    ///id="ODS_NOFOCUSRECT"></a><a id="ods_nofocusrect"></a><dl> <dt><b>ODS_NOFOCUSRECT</b></dt> </dl> </td> <td
    ///width="60%"> The control is drawn without focus indicator cues. </td> </tr> <tr> <td width="40%"><a
    ///id="ODS_SELECTED"></a><a id="ods_selected"></a><dl> <dt><b>ODS_SELECTED</b></dt> </dl> </td> <td width="60%"> The
    ///menu item's status is selected. </td> </tr> </table>
    uint   itemState;
    ///Type: <b>HWND</b> A handle to the control for combo boxes, list boxes, buttons, and static controls. For menus,
    ///this member is a handle to the menu that contains the item.
    HWND   hwndItem;
    ///Type: <b>HDC</b> A handle to a device context; this device context must be used when performing drawing
    ///operations on the control.
    HDC    hDC;
    ///Type: <b>RECT</b> A rectangle that defines the boundaries of the control to be drawn. This rectangle is in the
    ///device context specified by the <b>hDC</b> member. The system automatically clips anything that the owner window
    ///draws in the device context for combo boxes, list boxes, and buttons, but does not clip menu items. When drawing
    ///menu items, the owner window must not draw outside the boundaries of the rectangle defined by the <b>rcItem</b>
    ///member.
    RECT   rcItem;
    ///Type: <b>ULONG_PTR</b> The application-defined value associated with the menu item. For a control, this parameter
    ///specifies the value last assigned to the list box or combo box by the LB_SETITEMDATA or CB_SETITEMDATA message.
    ///If the list box or combo box has the LBS_HASSTRINGS or CBS_HASSTRINGS style, this value is initially zero.
    ///Otherwise, this value is initially the value that was passed to the list box or combo box in the <i>lParam</i>
    ///parameter of one of the following messages: <ul> <li> CB_ADDSTRING </li> <li> CB_INSERTSTRING </li> <li>
    ///LB_ADDSTRING </li> <li> LB_INSERTSTRING </li> </ul> If <b>CtlType</b> is <b>ODT_BUTTON</b> or <b>ODT_STATIC</b>,
    ///<b>itemData</b> is zero.
    size_t itemData;
}

///Describes a deleted list box or combo box item. The <i>lParam</i> parameter of a WM_DELETEITEM message contains a
///pointer to this structure. When an item is removed from a list box or combo box or when a list box or combo box is
///destroyed, the system sends the <b>WM_DELETEITEM</b> message to the owner for each deleted item. The system sends a
///WM_DELETEITEM message only for items deleted from an owner-drawn list box (with the LBS_OWNERDRAWFIXED or
///LBS_OWNERDRAWVARIABLE style) or owner-drawn combo box (with the CBS_OWNERDRAWFIXED or CBS_OWNERDRAWVARIABLE style).
struct DELETEITEMSTRUCT
{
    ///Type: <b>UINT</b> Specifies whether the item was deleted from a list box or a combo box. One of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ODT_LISTBOX"></a><a
    ///id="odt_listbox"></a><dl> <dt><b>ODT_LISTBOX</b></dt> </dl> </td> <td width="60%"> A list box. </td> </tr> <tr>
    ///<td width="40%"><a id="ODT_COMBOBOX"></a><a id="odt_combobox"></a><dl> <dt><b>ODT_COMBOBOX</b></dt> </dl> </td>
    ///<td width="60%"> A combo box. </td> </tr> </table>
    uint   CtlType;
    ///Type: <b>UINT</b> The identifier of the list box or combo box.
    uint   CtlID;
    ///Type: <b>UINT</b> The index of the item in the list box or combo box being removed.
    uint   itemID;
    ///Type: <b>HWND</b> A handle to the control.
    HWND   hwndItem;
    ///Type: <b>ULONG_PTR</b> Application-defined data for the item. This value is passed to the control in the
    ///<i>lParam</i> parameter of the message that adds the item to the list box or combo box.
    size_t itemData;
}

///Supplies the identifiers and application-supplied data for two items in a sorted, owner-drawn list box or combo box.
///Whenever an application adds a new item to an owner-drawn list box or combo box created with the CBS_SORT or LBS_SORT
///style, the system sends the owner a WM_COMPAREITEM message. The <i>lParam</i> parameter of the message contains a
///long pointer to a <b>COMPAREITEMSTRUCT</b> structure. Upon receiving the message, the owner compares the two items
///and returns a value indicating which item sorts before the other.
struct COMPAREITEMSTRUCT
{
    ///Type: <b>UINT</b> An ODT_LISTBOX (owner-drawn list box) or ODT_COMBOBOX (an owner-drawn combo box).
    uint   CtlType;
    ///Type: <b>UINT</b> The identifier of the list box or combo box.
    uint   CtlID;
    ///Type: <b>HWND</b> A handle to the control.
    HWND   hwndItem;
    ///Type: <b>UINT</b> The index of the first item in the list box or combo box being compared. This member will be
    ///–1 if the item has not been inserted or when searching for a potential item in the list box or combo box.
    uint   itemID1;
    ///Type: <b>ULONG_PTR</b> Application-supplied data for the first item being compared. (This value was passed as the
    ///<i>lParam</i> parameter of the message that added the item to the list box or combo box.)
    size_t itemData1;
    ///Type: <b>UINT</b> The index of the second item in the list box or combo box being compared.
    uint   itemID2;
    ///Type: <b>ULONG_PTR</b> Application-supplied data for the second item being compared. This value was passed as the
    ///<i>lParam</i> parameter of the message that added the item to the list box or combo box. This member will be –1
    ///if the item has not been inserted or when searching for a potential item in the list box or combo box.
    size_t itemData2;
    ///Type: <b>DWORD</b> The locale identifier. To create a locale identifier, use the MAKELCID macro.
    uint   dwLocaleId;
}

///Contains device properties (Human Interface Device (HID) global items that correspond to HID usages) for any type of
///HID input device.
struct USAGE_PROPERTIES
{
    ///A usage-specific value for a range-based linear control (knob or dial), an on/off control (toggle switch), a
    ///momentary control (mouse button), a one-shot control (button that triggers a single event), or re-trigger control
    ///(button that triggers a repeating event).
    ushort level;
    ///The Usage Page ID, such as VR Controls Page (0x03) or Game Controls Page (0x05).
    ushort page;
    ///The Usage ID associated with a Usage Page, such as Turn Right/Left (21) or Move Right/Left (24) for a Game
    ///Controls Page.
    ushort usage;
    ///The smallest value that the control can report.
    int    logicalMinimum;
    ///The largest value that the control can report.
    int    logicalMaximum;
    ///The standard of measure used to describe a control's physical value (after converting the logical value using the
    ///<i>exponent</i> value). The HID specification defines codes for the basic units of length, mass, time,
    ///temperature, current, and luminous intensity.
    ushort unit;
    ///The value used to scale a logical value to a physical value.
    ushort exponent;
    ///The number of data items contained in the report.
    ubyte  count;
    ///The <i>logicalMinimum</i> expressed in physical units (converted by multiplying <i>logicalMinimum</i> by
    ///<i>exponent</i>).
    int    physicalMinimum;
    ///The <i>logicalMaximum</i> expressed in physical units (converted by multiplying <i>logicalMaximum</i> by
    ///<i>exponent</i>).
    int    physicalMaximum;
}

///Contains information about the pointer input type.
struct POINTER_TYPE_INFO
{
    ///The pointer input device.
    POINTER_INPUT_TYPE type;
union
    {
        POINTER_TOUCH_INFO touchInfo;
        POINTER_PEN_INFO   penInfo;
    }
}

///Contains the input injection details.
struct INPUT_INJECTION_VALUE
{
    ///The Usage Page ID, such as VR Controls Page (0x03) or Game Controls Page (0x05).
    ushort page;
    ///The Usage ID associated with a Usage Page, such as Turn Right/Left (21) or Move Right/Left (24) for a Game
    ///Controls Page.
    ushort usage;
    ///The injected input value.
    int    value;
    ///The Usage index, such as the selected item in a radio button set.
    ushort index;
}

///Contains the hit test score that indicates whether the object is the likely target of the touch contact area,
///relative to other objects that intersect the touch contact area.
struct TOUCH_HIT_TESTING_PROXIMITY_EVALUATION
{
    ///The score, compared to the other objects that intersect the touch contact area.
    ushort score;
    ///The adjusted touch point that hits the closest object that's identified by the value of <i>Score</i>.
    POINT  adjustedPoint;
}

///Contains information about the touch contact area reported by the touch digitizer.
struct TOUCH_HIT_TESTING_INPUT
{
    ///The ID of the pointer. You cannot pass this value to the input message process and retrieve additional pointer
    ///info through GetPointerInfo.
    uint  pointerId;
    ///The screen coordinates of the touch point that the touch digitizer reports.
    POINT point;
    ///The bounding rectangle of the touch contact area. Valid touch targets are identified and scored based on this
    ///bounding box. <div class="alert"><b>Note</b> This bounding box may differ from the contact area that the
    ///digitizer reports when: <ul> <li>The digitizer reports a touch contact area that's outside the maximum or minimum
    ///size threshold that's recognized by Touch Hit Testing.</li> <li>A portion of the touch contact area is occluded
    ///by another object that's higher in the z-order. </li> </ul> </div> <div> </div>
    RECT  boundingBox;
    ///The touch contact area within a specific targeted window that's not occluded by other objects that are higher in
    ///the z-order. Any area that's occluded by another object is an invalid target.
    RECT  nonOccludedBoundingBox;
    ///The orientation of the touch contact area.
    uint  orientation;
}

///The <b>SCROLLINFO</b> structure contains scroll bar parameters to be set by the SetScrollInfo function (or
///SBM_SETSCROLLINFO message), or retrieved by the GetScrollInfo function (or SBM_GETSCROLLINFO message).
struct SCROLLINFO
{
    ///Type: <b>UINT</b> Specifies the size, in bytes, of this structure. The caller must set this to
    ///sizeof(<b>SCROLLINFO</b>).
    uint cbSize;
    ///Type: <b>UINT</b> Specifies the scroll bar parameters to set or retrieve. This member can be a combination of the
    ///following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SIF_ALL"></a><a
    ///id="sif_all"></a><dl> <dt><b>SIF_ALL</b></dt> </dl> </td> <td width="60%"> Combination of SIF_PAGE, SIF_POS,
    ///SIF_RANGE, and SIF_TRACKPOS. </td> </tr> <tr> <td width="40%"><a id="SIF_DISABLENOSCROLL"></a><a
    ///id="sif_disablenoscroll"></a><dl> <dt><b>SIF_DISABLENOSCROLL</b></dt> </dl> </td> <td width="60%"> This value is
    ///used only when setting a scroll bar's parameters. If the scroll bar's new parameters make the scroll bar
    ///unnecessary, disable the scroll bar instead of removing it. </td> </tr> <tr> <td width="40%"><a
    ///id="SIF_PAGE"></a><a id="sif_page"></a><dl> <dt><b>SIF_PAGE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>nPage</b> member contains the page size for a proportional scroll bar. </td> </tr> <tr> <td width="40%"><a
    ///id="SIF_POS"></a><a id="sif_pos"></a><dl> <dt><b>SIF_POS</b></dt> </dl> </td> <td width="60%"> The <b>nPos</b>
    ///member contains the scroll box position, which is not updated while the user drags the scroll box. </td> </tr>
    ///<tr> <td width="40%"><a id="SIF_RANGE"></a><a id="sif_range"></a><dl> <dt><b>SIF_RANGE</b></dt> </dl> </td> <td
    ///width="60%"> The <b>nMin</b> and <b>nMax</b> members contain the minimum and maximum values for the scrolling
    ///range. </td> </tr> <tr> <td width="40%"><a id="SIF_TRACKPOS"></a><a id="sif_trackpos"></a><dl>
    ///<dt><b>SIF_TRACKPOS</b></dt> </dl> </td> <td width="60%"> The <b>nTrackPos</b> member contains the current
    ///position of the scroll box while the user is dragging it. </td> </tr> </table>
    uint fMask;
    ///Type: <b>int</b> Specifies the minimum scrolling position.
    int  nMin;
    ///Type: <b>int</b> Specifies the maximum scrolling position.
    int  nMax;
    ///Type: <b>UINT</b> Specifies the page size, in device units. A scroll bar uses this value to determine the
    ///appropriate size of the proportional scroll box.
    uint nPage;
    ///Type: <b>int</b> Specifies the position of the scroll box.
    int  nPos;
    ///Type: <b>int</b> Specifies the immediate position of a scroll box that the user is dragging. An application can
    ///retrieve this value while processing the SB_THUMBTRACK request code. An application cannot set the immediate
    ///scroll position; the SetScrollInfo function ignores this member.
    int  nTrackPos;
}

///The <b>SCROLLBARINFO</b> structure contains scroll bar information.
struct SCROLLBARINFO
{
    ///Type: <b>DWORD</b> Specifies the size, in bytes, of the structure. Before calling the GetScrollBarInfo function,
    ///set <b>cbSize</b> to <b>sizeof</b>(<b>SCROLLBARINFO</b>).
    uint    cbSize;
    ///Type: <b>RECT</b> Coordinates of the scroll bar as specified in a RECT structure.
    RECT    rcScrollBar;
    ///Type: <b>int</b> Height or width of the thumb.
    int     dxyLineButton;
    ///Type: <b>int</b> Position of the top or left of the thumb.
    int     xyThumbTop;
    ///Type: <b>int</b> Position of the bottom or right of the thumb.
    int     xyThumbBottom;
    ///Type: <b>int</b> Reserved.
    int     reserved;
    ///Type: <b>DWORD[CCHILDREN_SCROLLBAR+1]</b> An array of <b>DWORD</b> elements. Each element indicates the state of
    ///a scroll bar component. The following values show the scroll bar component that corresponds to each array index.
    ///<table class="clsStd"> <tr> <th>Index</th> <th>Scroll bar component</th> </tr> <tr> <td>0</td> <td>The scroll bar
    ///itself.</td> </tr> <tr> <td>1</td> <td>The top or right arrow button.</td> </tr> <tr> <td>2</td> <td>The page up
    ///or page right region.</td> </tr> <tr> <td>3</td> <td>The scroll box (thumb).</td> </tr> <tr> <td>4</td> <td>The
    ///page down or page left region.</td> </tr> <tr> <td>5</td> <td>The bottom or left arrow button.</td> </tr>
    ///</table> The <b>DWORD</b> element for each scroll bar component can include a combination of the following bit
    ///flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="STATE_SYSTEM_INVISIBLE"></a><a id="state_system_invisible"></a><dl> <dt><b>STATE_SYSTEM_INVISIBLE</b></dt>
    ///</dl> </td> <td width="60%"> For the scroll bar itself, indicates the specified vertical or horizontal scroll bar
    ///does not exist. For the page up or page down regions, indicates the thumb is positioned such that the region does
    ///not exist. </td> </tr> <tr> <td width="40%"><a id="STATE_SYSTEM_OFFSCREEN"></a><a
    ///id="state_system_offscreen"></a><dl> <dt><b>STATE_SYSTEM_OFFSCREEN</b></dt> </dl> </td> <td width="60%"> For the
    ///scroll bar itself, indicates the window is sized such that the specified vertical or horizontal scroll bar is not
    ///currently displayed. </td> </tr> <tr> <td width="40%"><a id="STATE_SYSTEM_PRESSED"></a><a
    ///id="state_system_pressed"></a><dl> <dt><b>STATE_SYSTEM_PRESSED</b></dt> </dl> </td> <td width="60%"> The arrow
    ///button or page region is pressed. </td> </tr> <tr> <td width="40%"><a id="STATE_SYSTEM_UNAVAILABLE"></a><a
    ///id="state_system_unavailable"></a><dl> <dt><b>STATE_SYSTEM_UNAVAILABLE</b></dt> </dl> </td> <td width="60%"> The
    ///component is disabled. </td> </tr> </table>
    uint[6] rgstate;
}

///Contains combo box status information.
struct COMBOBOXINFO
{
    ///Type: <b>DWORD</b> The size, in bytes, of the structure. The calling application must set this to
    ///sizeof(COMBOBOXINFO).
    uint cbSize;
    ///Type: <b>RECT</b> A RECT structure that specifies the coordinates of the edit box.
    RECT rcItem;
    ///Type: <b>RECT</b> A RECT structure that specifies the coordinates of the button that contains the drop-down
    ///arrow.
    RECT rcButton;
    ///Type: <b>DWORD</b> The combo box button state. This parameter can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The
    ///button exists and is not pressed. </td> </tr> <tr> <td width="40%"><a id="STATE_SYSTEM_INVISIBLE"></a><a
    ///id="state_system_invisible"></a><dl> <dt><b>STATE_SYSTEM_INVISIBLE</b></dt> </dl> </td> <td width="60%"> There is
    ///no button. </td> </tr> <tr> <td width="40%"><a id="STATE_SYSTEM_PRESSED"></a><a
    ///id="state_system_pressed"></a><dl> <dt><b>STATE_SYSTEM_PRESSED</b></dt> </dl> </td> <td width="60%"> The button
    ///is pressed. </td> </tr> </table>
    uint stateButton;
    ///Type: <b>HWND</b> A handle to the combo box.
    HWND hwndCombo;
    ///Type: <b>HWND</b> A handle to the edit box.
    HWND hwndItem;
    ///Type: <b>HWND</b> A handle to the drop-down list.
    HWND hwndList;
}

///Contains information about a pointer device. An array of these structures is returned from the GetPointerDevices
///function. A single structure is returned from a call to the GetPointerDevice function.
struct POINTER_DEVICE_INFO
{
    ///One of the values from DISPLAYCONFIG_ROTATION, which identifies the orientation of the input digitizer. <div
    ///class="alert"><b>Note</b> This value is 0 when the source of input is Touch Injection.</div> <div> </div>
    uint                displayOrientation;
    ///The handle to the pointer device.
    HANDLE              device;
    ///The device type.
    POINTER_DEVICE_TYPE pointerDeviceType;
    ///The HMONITOR for the display that the device is mapped to. This is not necessarily the monitor that the pointer
    ///device is physically connected to.
    HMONITOR            monitor;
    ///The lowest ID that's assigned to the device.
    uint                startingCursorId;
    ///The number of supported simultaneous contacts.
    ushort              maxActiveContacts;
    ///The string that identifies the product.
    ushort[520]         productString;
}

///Contains pointer-based device properties (Human Interface Device (HID) global items that correspond to HID usages).
struct POINTER_DEVICE_PROPERTY
{
    ///The minimum value that the device can report for this property.
    int    logicalMin;
    ///The maximum value that the device can report for this property.
    int    logicalMax;
    ///The physical minimum in Himetric.
    int    physicalMin;
    ///The physical maximum in Himetric.
    int    physicalMax;
    ///The unit.
    uint   unit;
    ///The exponent.
    uint   unitExponent;
    ///The usage page for the property, as documented in the HID specification.
    ushort usagePageId;
    ///The usage of the property, as documented in the HID specification.
    ushort usageId;
}

///Contains cursor ID mappings for pointer devices.
struct POINTER_DEVICE_CURSOR_INFO
{
    ///The assigned cursor ID.
    uint cursorId;
    ///The POINTER_DEVICE_CURSOR_TYPE that the ID is mapped to.
    POINTER_DEVICE_CURSOR_TYPE cursor;
}

///Contains information about the source of the input message.
struct INPUT_MESSAGE_SOURCE
{
    ///The device type (INPUT_MESSAGE_DEVICE_TYPE) of the source of the input message.
    INPUT_MESSAGE_DEVICE_TYPE deviceType;
    ///The ID (INPUT_MESSAGE_ORIGIN_ID) of the source of the input message.
    INPUT_MESSAGE_ORIGIN_ID originId;
}

@RAIIFree!ImageList_Destroy
struct HIMAGELIST
{
    ptrdiff_t Value;
}

@RAIIFree!DestroyPropertySheetPage
struct HPROPSHEETPAGE
{
    ptrdiff_t Value;
}

struct HSYNTHETICPOINTERDEVICE
{
    ptrdiff_t Value;
}

struct CRGB
{
    ubyte bRed;
    ubyte bGreen;
    ubyte bBlue;
    ubyte bExtra;
}

struct _PSP
{
}

struct PROPSHEETPAGEA_V1
{
    uint             dwSize;
    uint             dwFlags;
    HINSTANCE        hInstance;
union
    {
        const(PSTR)  pszTemplate;
        DLGTEMPLATE* pResource;
    }
union
    {
        HICON       hIcon;
        const(PSTR) pszIcon;
    }
    const(PSTR)      pszTitle;
    DLGPROC          pfnDlgProc;
    LPARAM           lParam;
    LPFNPSPCALLBACKA pfnCallback;
    uint*            pcRefParent;
}

///Defines a page in a property sheet.
struct PROPSHEETPAGEA_V2
{
    uint             dwSize;
    uint             dwFlags;
    HINSTANCE        hInstance;
union
    {
        const(PSTR)  pszTemplate;
        DLGTEMPLATE* pResource;
    }
union
    {
        HICON       hIcon;
        const(PSTR) pszIcon;
    }
    const(PSTR)      pszTitle;
    DLGPROC          pfnDlgProc;
    LPARAM           lParam;
    LPFNPSPCALLBACKA pfnCallback;
    uint*            pcRefParent;
    ///Type: <b>LPCTSTR</b> Version 5.80 or later. Title of the header area. To use this member under the Wizard97-style
    ///wizard, you must also do the following: <ul> <li>Set the PSP_USEHEADERTITLE flag in the <b>dwFlags</b>
    ///member.</li> <li>Set the PSH_WIZARD97 flag in the <b>dwFlags</b> member of the page's PROPSHEETHEADER
    ///structure.</li> <li>Make sure that the PSP_HIDEHEADER flag in the <b>dwFlags</b> member is not set.</li> </ul>
    const(PSTR)      pszHeaderTitle;
    ///Type: <b>LPCTSTR</b> Version 5.80. Subtitle of the header area. To use this member, you must do the following:
    ///<ul> <li>Set the PSP_USEHEADERSUBTITLE flag in the <b>dwFlags</b> member.</li> <li>Set the PSH_WIZARD97 flag in
    ///the <b>dwFlags</b> member of the page's PROPSHEETHEADER structure.</li> <li>Make sure that the PSP_HIDEHEADER
    ///flag in the <b>dwFlags</b> member is not set.</li> </ul> <div class="alert"><b>Note</b> This member is ignored
    ///when using the Aero-style wizard (PSH_AEROWIZARD).</div> <div> </div>
    const(PSTR)      pszHeaderSubTitle;
}

///Defines a page in a property sheet.
struct PROPSHEETPAGEA_V3
{
    uint             dwSize;
    uint             dwFlags;
    HINSTANCE        hInstance;
union
    {
        const(PSTR)  pszTemplate;
        DLGTEMPLATE* pResource;
    }
union
    {
        HICON       hIcon;
        const(PSTR) pszIcon;
    }
    const(PSTR)      pszTitle;
    DLGPROC          pfnDlgProc;
    LPARAM           lParam;
    LPFNPSPCALLBACKA pfnCallback;
    uint*            pcRefParent;
    ///Type: <b>LPCTSTR</b> Version 5.80 or later. Title of the header area. To use this member under the Wizard97-style
    ///wizard, you must also do the following: <ul> <li>Set the PSP_USEHEADERTITLE flag in the <b>dwFlags</b>
    ///member.</li> <li>Set the PSH_WIZARD97 flag in the <b>dwFlags</b> member of the page's PROPSHEETHEADER
    ///structure.</li> <li>Make sure that the PSP_HIDEHEADER flag in the <b>dwFlags</b> member is not set.</li> </ul>
    const(PSTR)      pszHeaderTitle;
    ///Type: <b>LPCTSTR</b> Version 5.80. Subtitle of the header area. To use this member, you must do the following:
    ///<ul> <li>Set the PSP_USEHEADERSUBTITLE flag in the <b>dwFlags</b> member.</li> <li>Set the PSH_WIZARD97 flag in
    ///the <b>dwFlags</b> member of the page's PROPSHEETHEADER structure.</li> <li>Make sure that the PSP_HIDEHEADER
    ///flag in the <b>dwFlags</b> member is not set.</li> </ul> <div class="alert"><b>Note</b> This member is ignored
    ///when using the Aero-style wizard (PSH_AEROWIZARD).</div> <div> </div>
    const(PSTR)      pszHeaderSubTitle;
    ///Type: <b>HANDLE</b> Version 6.0 or later. An activation context handle. Set this member to the handle that is
    ///returned when you create the activation context with CreateActCtx. The system will activate this context before
    ///creating the dialog box. You do not need to use this member if you use a global manifest. See the Remarks.
    HANDLE           hActCtx;
}

struct PROPSHEETPAGEA
{
    uint             dwSize;
    uint             dwFlags;
    HINSTANCE        hInstance;
union
    {
        const(PSTR)  pszTemplate;
        DLGTEMPLATE* pResource;
    }
union
    {
        HICON       hIcon;
        const(PSTR) pszIcon;
    }
    const(PSTR)      pszTitle;
    DLGPROC          pfnDlgProc;
    LPARAM           lParam;
    LPFNPSPCALLBACKA pfnCallback;
    uint*            pcRefParent;
    const(PSTR)      pszHeaderTitle;
    const(PSTR)      pszHeaderSubTitle;
    HANDLE           hActCtx;
union
    {
        HBITMAP     hbmHeader;
        const(PSTR) pszbmHeader;
    }
}

struct PROPSHEETPAGEW_V1
{
    uint             dwSize;
    uint             dwFlags;
    HINSTANCE        hInstance;
union
    {
        const(PWSTR) pszTemplate;
        DLGTEMPLATE* pResource;
    }
union
    {
        HICON        hIcon;
        const(PWSTR) pszIcon;
    }
    const(PWSTR)     pszTitle;
    DLGPROC          pfnDlgProc;
    LPARAM           lParam;
    LPFNPSPCALLBACKW pfnCallback;
    uint*            pcRefParent;
}

///Defines a page in a property sheet.
struct PROPSHEETPAGEW_V2
{
    uint             dwSize;
    uint             dwFlags;
    HINSTANCE        hInstance;
union
    {
        const(PWSTR) pszTemplate;
        DLGTEMPLATE* pResource;
    }
union
    {
        HICON        hIcon;
        const(PWSTR) pszIcon;
    }
    const(PWSTR)     pszTitle;
    DLGPROC          pfnDlgProc;
    LPARAM           lParam;
    LPFNPSPCALLBACKW pfnCallback;
    uint*            pcRefParent;
    ///Type: <b>LPCTSTR</b> Version 5.80 or later. Title of the header area. To use this member under the Wizard97-style
    ///wizard, you must also do the following: <ul> <li>Set the PSP_USEHEADERTITLE flag in the <b>dwFlags</b>
    ///member.</li> <li>Set the PSH_WIZARD97 flag in the <b>dwFlags</b> member of the page's PROPSHEETHEADER
    ///structure.</li> <li>Make sure that the PSP_HIDEHEADER flag in the <b>dwFlags</b> member is not set.</li> </ul>
    const(PWSTR)     pszHeaderTitle;
    ///Type: <b>LPCTSTR</b> Version 5.80. Subtitle of the header area. To use this member, you must do the following:
    ///<ul> <li>Set the PSP_USEHEADERSUBTITLE flag in the <b>dwFlags</b> member.</li> <li>Set the PSH_WIZARD97 flag in
    ///the <b>dwFlags</b> member of the page's PROPSHEETHEADER structure.</li> <li>Make sure that the PSP_HIDEHEADER
    ///flag in the <b>dwFlags</b> member is not set.</li> </ul> <div class="alert"><b>Note</b> This member is ignored
    ///when using the Aero-style wizard (PSH_AEROWIZARD).</div> <div> </div>
    const(PWSTR)     pszHeaderSubTitle;
}

///Defines a page in a property sheet.
struct PROPSHEETPAGEW_V3
{
    uint             dwSize;
    uint             dwFlags;
    HINSTANCE        hInstance;
union
    {
        const(PWSTR) pszTemplate;
        DLGTEMPLATE* pResource;
    }
union
    {
        HICON        hIcon;
        const(PWSTR) pszIcon;
    }
    const(PWSTR)     pszTitle;
    DLGPROC          pfnDlgProc;
    LPARAM           lParam;
    LPFNPSPCALLBACKW pfnCallback;
    uint*            pcRefParent;
    ///Type: <b>LPCTSTR</b> Version 5.80 or later. Title of the header area. To use this member under the Wizard97-style
    ///wizard, you must also do the following: <ul> <li>Set the PSP_USEHEADERTITLE flag in the <b>dwFlags</b>
    ///member.</li> <li>Set the PSH_WIZARD97 flag in the <b>dwFlags</b> member of the page's PROPSHEETHEADER
    ///structure.</li> <li>Make sure that the PSP_HIDEHEADER flag in the <b>dwFlags</b> member is not set.</li> </ul>
    const(PWSTR)     pszHeaderTitle;
    ///Type: <b>LPCTSTR</b> Version 5.80. Subtitle of the header area. To use this member, you must do the following:
    ///<ul> <li>Set the PSP_USEHEADERSUBTITLE flag in the <b>dwFlags</b> member.</li> <li>Set the PSH_WIZARD97 flag in
    ///the <b>dwFlags</b> member of the page's PROPSHEETHEADER structure.</li> <li>Make sure that the PSP_HIDEHEADER
    ///flag in the <b>dwFlags</b> member is not set.</li> </ul> <div class="alert"><b>Note</b> This member is ignored
    ///when using the Aero-style wizard (PSH_AEROWIZARD).</div> <div> </div>
    const(PWSTR)     pszHeaderSubTitle;
    ///Type: <b>HANDLE</b> Version 6.0 or later. An activation context handle. Set this member to the handle that is
    ///returned when you create the activation context with CreateActCtx. The system will activate this context before
    ///creating the dialog box. You do not need to use this member if you use a global manifest. See the Remarks.
    HANDLE           hActCtx;
}

struct PROPSHEETPAGEW
{
    uint             dwSize;
    uint             dwFlags;
    HINSTANCE        hInstance;
union
    {
        const(PWSTR) pszTemplate;
        DLGTEMPLATE* pResource;
    }
union
    {
        HICON        hIcon;
        const(PWSTR) pszIcon;
    }
    const(PWSTR)     pszTitle;
    DLGPROC          pfnDlgProc;
    LPARAM           lParam;
    LPFNPSPCALLBACKW pfnCallback;
    uint*            pcRefParent;
    const(PWSTR)     pszHeaderTitle;
    const(PWSTR)     pszHeaderSubTitle;
    HANDLE           hActCtx;
union
    {
        HBITMAP      hbmHeader;
        const(PWSTR) pszbmHeader;
    }
}

struct PROPSHEETHEADERA_V1
{
    uint                 dwSize;
    uint                 dwFlags;
    HWND                 hwndParent;
    HINSTANCE            hInstance;
union
    {
        HICON       hIcon;
        const(PSTR) pszIcon;
    }
    const(PSTR)          pszCaption;
    uint                 nPages;
union
    {
        uint        nStartPage;
        const(PSTR) pStartPage;
    }
union
    {
        PROPSHEETPAGEA* ppsp;
        HPROPSHEETPAGE* phpage;
    }
    PFNPROPSHEETCALLBACK pfnCallback;
}

///Defines the frame and pages of a property sheet.
struct PROPSHEETHEADERA_V2
{
    uint                 dwSize;
    uint                 dwFlags;
    HWND                 hwndParent;
    HINSTANCE            hInstance;
union
    {
        HICON       hIcon;
        const(PSTR) pszIcon;
    }
    const(PSTR)          pszCaption;
    uint                 nPages;
union
    {
        uint        nStartPage;
        const(PSTR) pStartPage;
    }
union
    {
        PROPSHEETPAGEA* ppsp;
        HPROPSHEETPAGE* phpage;
    }
    PFNPROPSHEETCALLBACK pfnCallback;
union
    {
        HBITMAP     hbmWatermark;
        const(PSTR) pszbmWatermark;
    }
    ///Type: <b>HPALETTE</b> Version 5.80 or later. <b>HPALETTE</b> structure used for drawing the watermark bitmap
    ///and/or header bitmap. If the <b>dwFlags</b> member does not include PSH_USEHPLWATERMARK, this member is ignored.
    HPALETTE             hplWatermark;
union
    {
        HBITMAP     hbmHeader;
        const(PSTR) pszbmHeader;
    }
}

struct PROPSHEETHEADERW_V1
{
    uint                 dwSize;
    uint                 dwFlags;
    HWND                 hwndParent;
    HINSTANCE            hInstance;
union
    {
        HICON        hIcon;
        const(PWSTR) pszIcon;
    }
    const(PWSTR)         pszCaption;
    uint                 nPages;
union
    {
        uint         nStartPage;
        const(PWSTR) pStartPage;
    }
union
    {
        PROPSHEETPAGEW* ppsp;
        HPROPSHEETPAGE* phpage;
    }
    PFNPROPSHEETCALLBACK pfnCallback;
}

///Defines the frame and pages of a property sheet.
struct PROPSHEETHEADERW_V2
{
    uint                 dwSize;
    uint                 dwFlags;
    HWND                 hwndParent;
    HINSTANCE            hInstance;
union
    {
        HICON        hIcon;
        const(PWSTR) pszIcon;
    }
    const(PWSTR)         pszCaption;
    uint                 nPages;
union
    {
        uint         nStartPage;
        const(PWSTR) pStartPage;
    }
union
    {
        PROPSHEETPAGEW* ppsp;
        HPROPSHEETPAGE* phpage;
    }
    PFNPROPSHEETCALLBACK pfnCallback;
union
    {
        HBITMAP      hbmWatermark;
        const(PWSTR) pszbmWatermark;
    }
    ///Type: <b>HPALETTE</b> Version 5.80 or later. <b>HPALETTE</b> structure used for drawing the watermark bitmap
    ///and/or header bitmap. If the <b>dwFlags</b> member does not include PSH_USEHPLWATERMARK, this member is ignored.
    HPALETTE             hplWatermark;
union
    {
        HBITMAP      hbmHeader;
        const(PWSTR) pszbmHeader;
    }
}

///Contains information for the property sheet notification messages.
struct PSHNOTIFY
{
    ///Type: <b>NMHDR</b> Address of an NMHDR structure that contains additional information about the notification.
    NMHDR  hdr;
    LPARAM lParam;
}

///Carries information used to load common control classes from the dynamic-link library (DLL). This structure is used
///with the InitCommonControlsEx function.
struct INITCOMMONCONTROLSEX
{
    ///Type: <b>DWORD</b> The size of the structure, in bytes.
    uint dwSize;
    uint dwICC;
}

///Contains information for the drawing of buttons in a toolbar or rebar.
struct COLORSCHEME
{
    ///Type: <b>DWORD</b> The size of this structure, in bytes.
    uint dwSize;
    ///Type: <b>COLORREF</b> The COLORREF value that represents the highlight color of the buttons. Use
    ///<b>CLR_DEFAULT</b> for the default highlight color.
    uint clrBtnHighlight;
    uint clrBtnShadow;
}

///Contains information used with NM_TOOLTIPSCREATED notification codes.
struct NMTOOLTIPSCREATED
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains additional information about this notification.
    NMHDR hdr;
    HWND  hwndToolTips;
}

///Contains information used with mouse notification messages.
struct NMMOUSE
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains additional information about this notification.
    NMHDR  hdr;
    ///Type: <b>DWORD_PTR</b> A control-specific item identifier.
    size_t dwItemSpec;
    ///Type: <b>DWORD_PTR</b> A control-specific item data.
    size_t dwItemData;
    ///Type: <b>POINT</b> A POINT structure that contains the client coordinates of the mouse when the click occurred.
    POINT  pt;
    LPARAM dwHitInfo;
}

///Contains information used with the TBN_GETOBJECT, TCN_GETOBJECT, and PSN_GETOBJECT notification codes.
struct NMOBJECTNOTIFY
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains additional information about this notification.
    NMHDR        hdr;
    ///Type: <b>int</b> A control-specific item identifier. This value will comply to item identification standards for
    ///the control sending the notification. However, this member is not used with the PSN_GETOBJECT notification code.
    int          iItem;
    ///Type: <b>IID*</b> A pointer to an interface identifier of the requested object.
    const(GUID)* piid;
    ///Type: <b>IUnknown*</b> A pointer to an object provided by the window processing the notification code. The
    ///application processing the notification code sets this member.
    void*        pObject;
    ///Type: <b>HRESULT</b> COM success or failure flags. The application processing the notification code sets this
    ///member.
    HRESULT      hResult;
    uint         dwFlags;
}

///Contains information used with key notification messages.
struct NMKEY
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains additional information about this notification.
    NMHDR hdr;
    ///Type: <b>UINT</b> A virtual key code of the key that caused the event.
    uint  nVKey;
    uint  uFlags;
}

///Contains information used with character notification messages.
struct NMCHAR
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains additional information about this notification.
    NMHDR hdr;
    ///Type: <b>UINT</b> The character that is being processed.
    uint  ch;
    ///Type: <b>DWORD</b> A 32-bit value that is determined by the control that is sending the notification.
    uint  dwItemPrev;
    uint  dwItemNext;
}

///Contains information used with custom text notification.
struct NMCUSTOMTEXT
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains additional information about this notification.
    NMHDR        hdr;
    ///Type: <b>HDC</b> The device context to draw to.
    HDC          hDC;
    ///Type: <b>LPCWSTR</b> The string to draw.
    const(PWSTR) lpString;
    ///Type: <b>int</b> Length of lpString.
    int          nCount;
    ///Type: <b>LPRECT</b> The rect to draw in.
    RECT*        lpRect;
    ///Type: <b>UINT</b> One or more of the DT_* flags. For more information, see the description of the <i>uFormat</i>
    ///parameter of the DrawText function. This may be <b>NULL</b>.
    uint         uFormat;
    BOOL         fLink;
}

///Contains information specific to an NM_CUSTOMDRAW notification code.
struct NMCUSTOMDRAW
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains information about this notification code.
    NMHDR  hdr;
    ///Type: <b>DWORD</b> The current drawing stage. This is one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="Global_Values_"></a><a id="global_values_"></a><a
    ///id="GLOBAL_VALUES_"></a><dl> <dt><b>Global Values:</b></dt> </dl> </td> <td width="60%"></td> </tr> <tr> <td
    ///width="40%"><a id="CDDS_POSTERASE"></a><a id="cdds_posterase"></a><dl> <dt><b>CDDS_POSTERASE</b></dt> </dl> </td>
    ///<td width="60%"> After the erasing cycle is complete. </td> </tr> <tr> <td width="40%"><a
    ///id="CDDS_POSTPAINT"></a><a id="cdds_postpaint"></a><dl> <dt><b>CDDS_POSTPAINT</b></dt> </dl> </td> <td
    ///width="60%"> After the painting cycle is complete. </td> </tr> <tr> <td width="40%"><a id="CDDS_PREERASE"></a><a
    ///id="cdds_preerase"></a><dl> <dt><b>CDDS_PREERASE</b></dt> </dl> </td> <td width="60%"> Before the erasing cycle
    ///begins. </td> </tr> <tr> <td width="40%"><a id="CDDS_PREPAINT"></a><a id="cdds_prepaint"></a><dl>
    ///<dt><b>CDDS_PREPAINT</b></dt> </dl> </td> <td width="60%"> Before the painting cycle begins. </td> </tr> <tr> <td
    ///width="40%"><a id="Item-specific_Values_"></a><a id="item-specific_values_"></a><a
    ///id="ITEM-SPECIFIC_VALUES_"></a><dl> <dt><b>Item-specific Values:</b></dt> </dl> </td> <td width="60%"></td> </tr>
    ///<tr> <td width="40%"><a id="CDDS_ITEM"></a><a id="cdds_item"></a><dl> <dt><b>CDDS_ITEM</b></dt> </dl> </td> <td
    ///width="60%"> Indicates that the <b>dwItemSpec</b>, <b>uItemState</b>, and <b>lItemlParam</b> members are valid.
    ///</td> </tr> <tr> <td width="40%"><a id="CDDS_ITEMPOSTERASE"></a><a id="cdds_itemposterase"></a><dl>
    ///<dt><b>CDDS_ITEMPOSTERASE</b></dt> </dl> </td> <td width="60%"> After an item has been erased. </td> </tr> <tr>
    ///<td width="40%"><a id="CDDS_ITEMPOSTPAINT"></a><a id="cdds_itempostpaint"></a><dl>
    ///<dt><b>CDDS_ITEMPOSTPAINT</b></dt> </dl> </td> <td width="60%"> After an item has been drawn. </td> </tr> <tr>
    ///<td width="40%"><a id="CDDS_ITEMPREERASE"></a><a id="cdds_itempreerase"></a><dl>
    ///<dt><b>CDDS_ITEMPREERASE</b></dt> </dl> </td> <td width="60%"> Before an item is erased. </td> </tr> <tr> <td
    ///width="40%"><a id="CDDS_ITEMPREPAINT"></a><a id="cdds_itemprepaint"></a><dl> <dt><b>CDDS_ITEMPREPAINT</b></dt>
    ///</dl> </td> <td width="60%"> Before an item is drawn. </td> </tr> <tr> <td width="40%"><a
    ///id="CDDS_SUBITEM"></a><a id="cdds_subitem"></a><dl> <dt><b>CDDS_SUBITEM</b></dt> </dl> </td> <td width="60%">
    ///Flag combined with CDDS_ITEMPREPAINT or CDDS_ITEMPOSTPAINT if a subitem is being drawn. This will only be set if
    ///CDRF_NOTIFYITEMDRAW is returned from CDDS_PREPAINT. </td> </tr> </table>
    uint   dwDrawStage;
    ///Type: <b>HDC</b> A handle to the control's device context. Use this HDC to perform any GDI functions.
    HDC    hdc;
    ///Type: <b>RECT</b> The RECT structure that describes the bounding rectangle of the area being drawn. This member
    ///is initialized only by the CDDS_ITEMPREPAINT notification. Version 5.80. This member is also initialized by the
    ///CDDS_PREPAINT notification.
    RECT   rc;
    ///Type: <b>DWORD_PTR</b> The item number. What is contained in this member will depend on the type of control that
    ///is sending the notification. See the NM_CUSTOMDRAW notification reference for the specific control to determine
    ///what, if anything, is contained in this member.
    size_t dwItemSpec;
    ///Type: <b>UINT</b> The current item state. This value is a combination of the following flags. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CDIS_CHECKED"></a><a id="cdis_checked"></a><dl>
    ///<dt><b>CDIS_CHECKED</b></dt> </dl> </td> <td width="60%"> The item is checked. </td> </tr> <tr> <td
    ///width="40%"><a id="CDIS_DEFAULT"></a><a id="cdis_default"></a><dl> <dt><b>CDIS_DEFAULT</b></dt> </dl> </td> <td
    ///width="60%"> The item is in its default state. </td> </tr> <tr> <td width="40%"><a id="CDIS_DISABLED"></a><a
    ///id="cdis_disabled"></a><dl> <dt><b>CDIS_DISABLED</b></dt> </dl> </td> <td width="60%"> The item is disabled.
    ///</td> </tr> <tr> <td width="40%"><a id="CDIS_FOCUS"></a><a id="cdis_focus"></a><dl> <dt><b>CDIS_FOCUS</b></dt>
    ///</dl> </td> <td width="60%"> The item is in focus. </td> </tr> <tr> <td width="40%"><a id="CDIS_GRAYED"></a><a
    ///id="cdis_grayed"></a><dl> <dt><b>CDIS_GRAYED</b></dt> </dl> </td> <td width="60%"> The item is grayed. </td>
    ///</tr> <tr> <td width="40%"><a id="CDIS_HOT"></a><a id="cdis_hot"></a><dl> <dt><b>CDIS_HOT</b></dt> </dl> </td>
    ///<td width="60%"> The item is currently under the pointer ("hot"). </td> </tr> <tr> <td width="40%"><a
    ///id="CDIS_INDETERMINATE"></a><a id="cdis_indeterminate"></a><dl> <dt><b>CDIS_INDETERMINATE</b></dt> </dl> </td>
    ///<td width="60%"> The item is in an indeterminate state. </td> </tr> <tr> <td width="40%"><a
    ///id="CDIS_MARKED"></a><a id="cdis_marked"></a><dl> <dt><b>CDIS_MARKED</b></dt> </dl> </td> <td width="60%"> The
    ///item is marked. The meaning of this is determined by the implementation. </td> </tr> <tr> <td width="40%"><a
    ///id="CDIS_SELECTED"></a><a id="cdis_selected"></a><dl> <dt><b>CDIS_SELECTED</b></dt> </dl> </td> <td width="60%">
    ///The item is selected. <div class="alert"><b>Note</b> This flag does not work correctly for owner-drawn list-view
    ///controls that have the LVS_SHOWSELALWAYS style. For these controls, you can determine whether an item is selected
    ///by using LVM_GETITEMSTATE (or ListView_GetItemState) and checking for the <b>LVIS_SELECTED</b> flag.</div> <div>
    ///</div> </td> </tr> <tr> <td width="40%"><a id="CDIS_SHOWKEYBOARDCUES"></a><a id="cdis_showkeyboardcues"></a><dl>
    ///<dt><b>CDIS_SHOWKEYBOARDCUES</b></dt> </dl> </td> <td width="60%"> Version 6.0.The item is showing its keyboard
    ///cues. Note that Comctl32 version 6 is not redistributable. operating systems. To use Comctl32.dll version 6,
    ///specify it in the manifest. For more information on manifests, see Enabling Visual Styles. </td> </tr> <tr> <td
    ///width="40%"><a id="CDIS_NEARHOT"></a><a id="cdis_nearhot"></a><dl> <dt><b>CDIS_NEARHOT</b></dt> </dl> </td> <td
    ///width="60%"> The item is part of a control that is currently under the mouse pointer ("hot"), but the item is not
    ///"hot" itself. The meaning of this is determined by the implementation. </td> </tr> <tr> <td width="40%"><a
    ///id="CDIS_OTHERSIDEHOT"></a><a id="cdis_othersidehot"></a><dl> <dt><b>CDIS_OTHERSIDEHOT</b></dt> </dl> </td> <td
    ///width="60%"> The item is part of a splitbutton that is currently under the mouse pointer ("hot"), but the item is
    ///not "hot" itself. The meaning of this is determined by the implementation. </td> </tr> <tr> <td width="40%"><a
    ///id="CDIS_DROPHILITED"></a><a id="cdis_drophilited"></a><dl> <dt><b>CDIS_DROPHILITED</b></dt> </dl> </td> <td
    ///width="60%"> The item is currently the drop target of a drag-and-drop operation. </td> </tr> </table>
    uint   uItemState;
    ///Type: <b>LPARAM</b> Application-defined item data.
    LPARAM lItemlParam;
}

///Contains information specific to an NM_CUSTOMDRAW notification code sent by a tooltip control.
struct NMTTCUSTOMDRAW
{
    ///Type: <b>NMCUSTOMDRAW</b> Contains general custom draw information.
    NMCUSTOMDRAW nmcd;
    uint         uDrawFlags;
}

///Contains information about the two rectangles of a split button. Sent with the NM_GETCUSTOMSPLITRECT notification.
struct NMCUSTOMSPLITRECTINFO
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains information about the notification.
    NMHDR hdr;
    ///Type: <b>RECT</b> A RECT structure that describes the client area the button occupies.
    RECT  rcClient;
    ///Type: <b>RECT</b> A RECT structure that describes the rectangle that does not contain the drop-down arrow.
    RECT  rcButton;
    ///Type: <b>RECT</b> A RECT structure that describes the rectangle that contains the drop-down arrow.
    RECT  rcSplit;
}

struct _IMAGELIST
{
}

///Contains information about an image list draw operation and is used with the IImageList::Draw function.
struct IMAGELISTDRAWPARAMS
{
    ///Type: <b>DWORD</b> The size of this structure, in bytes.
    uint       cbSize;
    ///Type: <b>HIMAGELIST</b> A handle to the image list that contains the image to be drawn.
    HIMAGELIST himl;
    ///Type: <b>int</b> The zero-based index of the image to be drawn.
    int        i;
    ///Type: <b>HDC</b> A handle to the destination device context.
    HDC        hdcDst;
    ///Type: <b>int</b> The x-coordinate that specifies where the image is drawn.
    int        x;
    ///Type: <b>int</b> The y-coordinate that specifies where the image is drawn.
    int        y;
    ///Type: <b>int</b> A value that specifies the number of pixels to draw, relative to the upper-left corner of the
    ///drawing operation as specified by <b>xBitmap</b> and <b>yBitmap</b>. If <b>cx</b> and <b>cy</b> are zero, then
    ///Draw draws the entire valid section. The method does not ensure that the parameters are valid.
    int        cx;
    ///Type: <b>int</b> A value that specifies the number of pixels to draw, relative to the upper-left corner of the
    ///drawing operation as specified by <b>xBitmap</b> and <b>yBitmap</b>. If <b>cx</b> and <b>cy</b> are zero, then
    ///Draw draws the entire valid section. The method does not ensure that the parameters are valid.
    int        cy;
    ///Type: <b>int</b> The x-coordinate that specifies the upper-left corner of the drawing operation in reference to
    ///the image itself. Pixels of the image that are to the left of <b>xBitmap</b> and above <b>yBitmap</b> do not
    ///appear.
    int        xBitmap;
    ///Type: <b>int</b> The y-coordinate that specifies the upper-left corner of the drawing operation in reference to
    ///the image itself. Pixels of the image that are to the left of <b>xBitmap</b> and above <b>yBitmap</b> do not
    ///appear.
    int        yBitmap;
    ///Type: <b>COLORREF</b> The image background color. This parameter can be an application-defined RGB value or one
    ///of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="CLR_DEFAULT"></a><a id="clr_default"></a><dl> <dt><b>CLR_DEFAULT</b></dt> </dl> </td> <td width="60%"> The
    ///default background color. The image is drawn using the image list background color. </td> </tr> <tr> <td
    ///width="40%"><a id="CLR_NONE"></a><a id="clr_none"></a><dl> <dt><b>CLR_NONE</b></dt> </dl> </td> <td width="60%">
    ///No background color. The image is drawn transparently. </td> </tr> </table>
    uint       rgbBk;
    ///Type: <b>COLORREF</b> The image foreground color. This member is used only if <b>fStyle</b> includes the
    ///ILD_BLEND25 or ILD_BLEND50 flag. This parameter can be an application-defined RGB value or one of the following
    ///values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CLR_DEFAULT"></a><a
    ///id="clr_default"></a><dl> <dt><b>CLR_DEFAULT</b></dt> </dl> </td> <td width="60%"> The default foreground color.
    ///The image is drawn using the system highlight color as the foreground color. </td> </tr> <tr> <td width="40%"><a
    ///id="CLR_NONE"></a><a id="clr_none"></a><dl> <dt><b>CLR_NONE</b></dt> </dl> </td> <td width="60%"> No blend color.
    ///The image is blended with the color of the destination device context. </td> </tr> </table>
    uint       rgbFg;
    ///Type: <b>UINT</b> A flag specifying the drawing style and, optionally, the overlay image. See the comments
    ///section at the end of this topic for information on the overlay image. This member can contain one or more image
    ///list drawing flags.
    uint       fStyle;
    ///Type: <b>DWORD</b> A value specifying a raster operation code. These codes define how the color data for the
    ///source rectangle will be combined with the color data for the destination rectangle to achieve the final color.
    ///This member is ignored if <b>fStyle</b> does not include the ILD_ROP flag. Some common raster operation codes
    ///include: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="BLACKNESS"></a><a
    ///id="blackness"></a><dl> <dt><b>BLACKNESS</b></dt> </dl> </td> <td width="60%"> Fills the destination rectangle
    ///using the color associated with index zero in the physical palette. (This color is black for the default physical
    ///palette.) </td> </tr> <tr> <td width="40%"><a id="DSTINVERT"></a><a id="dstinvert"></a><dl>
    ///<dt><b>DSTINVERT</b></dt> </dl> </td> <td width="60%"> Inverts the destination rectangle. </td> </tr> <tr> <td
    ///width="40%"><a id="MERGECOPY"></a><a id="mergecopy"></a><dl> <dt><b>MERGECOPY</b></dt> </dl> </td> <td
    ///width="60%"> Merges the source rectangle colors with the specified pattern by using the Boolean <b>AND</b>
    ///operator. </td> </tr> <tr> <td width="40%"><a id="MERGEPAINT"></a><a id="mergepaint"></a><dl>
    ///<dt><b>MERGEPAINT</b></dt> </dl> </td> <td width="60%"> Merges the inverted source rectangle colors with the
    ///destination rectangle colors by using the Boolean <b>OR</b> operator. </td> </tr> <tr> <td width="40%"><a
    ///id="NOTSRCCOPY"></a><a id="notsrccopy"></a><dl> <dt><b>NOTSRCCOPY</b></dt> </dl> </td> <td width="60%"> Copies
    ///the inverted source rectangle to the destination. </td> </tr> <tr> <td width="40%"><a id="NOTSRCERASE"></a><a
    ///id="notsrcerase"></a><dl> <dt><b>NOTSRCERASE</b></dt> </dl> </td> <td width="60%"> Combines the source and
    ///destination rectangle colors by using the Boolean <b>OR</b> operator. Inverts the resultant color. </td> </tr>
    ///<tr> <td width="40%"><a id="PATCOPY"></a><a id="patcopy"></a><dl> <dt><b>PATCOPY</b></dt> </dl> </td> <td
    ///width="60%"> Copies the specified pattern into the destination bitmap. </td> </tr> <tr> <td width="40%"><a
    ///id="PATINVERT"></a><a id="patinvert"></a><dl> <dt><b>PATINVERT</b></dt> </dl> </td> <td width="60%"> Combines the
    ///specified pattern colors with the destination rectangle colors by using the Boolean <b>XOR</b> operator. </td>
    ///</tr> <tr> <td width="40%"><a id="PATPAINT"></a><a id="patpaint"></a><dl> <dt><b>PATPAINT</b></dt> </dl> </td>
    ///<td width="60%"> Combines the pattern colors with the inverted source rectangle colors and combines the result
    ///with the destination rectangle colors by using the Boolean <b>OR</b> operator. </td> </tr> <tr> <td
    ///width="40%"><a id="SRCAND"></a><a id="srcand"></a><dl> <dt><b>SRCAND</b></dt> </dl> </td> <td width="60%">
    ///Combines the source and destination rectangle colors by using the Boolean <b>AND</b> operator. </td> </tr> <tr>
    ///<td width="40%"><a id="SRCCOPY"></a><a id="srccopy"></a><dl> <dt><b>SRCCOPY</b></dt> </dl> </td> <td width="60%">
    ///Copies the source rectangle directly to the destination rectangle. </td> </tr> <tr> <td width="40%"><a
    ///id="SRCERASE"></a><a id="srcerase"></a><dl> <dt><b>SRCERASE</b></dt> </dl> </td> <td width="60%"> Combines the
    ///destination rectangle's inverted colors with the source rectangle colors by using the Boolean <b>AND</b>
    ///operator. </td> </tr> <tr> <td width="40%"><a id="SRCINVERT"></a><a id="srcinvert"></a><dl>
    ///<dt><b>SRCINVERT</b></dt> </dl> </td> <td width="60%"> Combines the source and destination rectangle colors by
    ///using the Boolean <b>XOR</b> operator. </td> </tr> <tr> <td width="40%"><a id="SRCPAINT"></a><a
    ///id="srcpaint"></a><dl> <dt><b>SRCPAINT</b></dt> </dl> </td> <td width="60%"> Combines the source and destination
    ///rectangle colors by using the Boolean <b>OR</b> operator. </td> </tr> <tr> <td width="40%"><a
    ///id="WHITENESS"></a><a id="whiteness"></a><dl> <dt><b>WHITENESS</b></dt> </dl> </td> <td width="60%"> Fills the
    ///destination rectangle using the color associated with index one in the physical palette. This color is white for
    ///the default physical palette. </td> </tr> </table>
    uint       dwRop;
    ///Type: <b>DWORD</b> A flag that specifies the drawing state. This member can contain one or more image list state
    ///flags. You must use comctl32.dll version 6 to use this member. See the Remarks.
    uint       fState;
    ///Type: <b>DWORD</b> Used with the <b>alpha blending</b> effect. When used with ILS_ALPHA, this member holds the
    ///value for the alpha channel. This value can be from 0 to 255, with 0 being completely transparent, and 255 being
    ///completely opaque. You must use comctl32.dll version 6 to use this member. See the Remarks.
    uint       Frame;
    ///Type: <b>DWORD</b> A color used for the <b>glow</b> and <b>shadow</b> effects. You must use comctl32.dll version
    ///6 to use this member. See the Remarks.
    uint       crEffect;
}

///Contains information about an image in an image list. This structure is used with the IImageList::GetImageInfo
///function.
struct IMAGEINFO
{
    ///Type: <b>HBITMAP</b> A handle to the bitmap that contains the images.
    HBITMAP hbmImage;
    ///Type: <b>HBITMAP</b> A handle to a monochrome bitmap that contains the masks for the images. If the image list
    ///does not contain a mask, this member is <b>NULL</b>.
    HBITMAP hbmMask;
    ///Type: <b>int</b> Not used. This member should always be zero.
    int     Unused1;
    ///Type: <b>int</b> Not used. This member should always be zero.
    int     Unused2;
    RECT    rcImage;
}

///Contains information about header control text filters.
struct HD_TEXTFILTERA
{
    ///Type: <b>LPTSTR</b> A pointer to the buffer containing the filter.
    PSTR pszText;
    ///Type: <b>INT</b> A value specifying the maximum size, in characters, for an edit control buffer.
    int  cchTextMax;
}

///Contains information about header control text filters.
struct HD_TEXTFILTERW
{
    ///Type: <b>LPTSTR</b> A pointer to the buffer containing the filter.
    PWSTR pszText;
    ///Type: <b>INT</b> A value specifying the maximum size, in characters, for an edit control buffer.
    int   cchTextMax;
}

///Contains information about an item in a header control. This structure supersedes the <b>HD_ITEM</b> structure.
struct HDITEMA
{
    ///Type: <b>UINT</b> Flags indicating which other structure members contain valid data or must be filled in. This
    ///member can be a combination of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="HDI_BITMAP"></a><a id="hdi_bitmap"></a><dl> <dt><b>HDI_BITMAP</b></dt> </dl> </td> <td
    ///width="60%"> The <b>hbm</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="HDI_DI_SETITEM"></a><a
    ///id="hdi_di_setitem"></a><dl> <dt><b>HDI_DI_SETITEM</b></dt> </dl> </td> <td width="60%"> While handling the
    ///message HDM_GETITEM, the header control may not have all the values needed to complete the request. In this case,
    ///the control must call the application back for the values via the HDN_GETDISPINFO notification. If HDI_DI_SETITEM
    ///has been passed in the <b>HDM_GETITEM</b> message, the control will cache any values returned from
    ///HDN_GETDISPINFO (otherwise the values remain unset.) </td> </tr> <tr> <td width="40%"><a id="HDI_FORMAT"></a><a
    ///id="hdi_format"></a><dl> <dt><b>HDI_FORMAT</b></dt> </dl> </td> <td width="60%"> The <b>fmt</b> member is valid.
    ///</td> </tr> <tr> <td width="40%"><a id="HDI_FILTER"></a><a id="hdi_filter"></a><dl> <dt><b>HDI_FILTER</b></dt>
    ///</dl> </td> <td width="60%"> The <b>type</b> and <b>pvFilter</b> members are valid. This is used to filter out
    ///the values specified in the <b>type</b> member. </td> </tr> <tr> <td width="40%"><a id="HDI_HEIGHT"></a><a
    ///id="hdi_height"></a><dl> <dt><b>HDI_HEIGHT</b></dt> </dl> </td> <td width="60%"> The same as HDI_WIDTH. </td>
    ///</tr> <tr> <td width="40%"><a id="HDI_IMAGE"></a><a id="hdi_image"></a><dl> <dt><b>HDI_IMAGE</b></dt> </dl> </td>
    ///<td width="60%"> The <b>iImage</b> member is valid and specifies the image to be displayed with the item. </td>
    ///</tr> <tr> <td width="40%"><a id="HDI_LPARAM"></a><a id="hdi_lparam"></a><dl> <dt><b>HDI_LPARAM</b></dt> </dl>
    ///</td> <td width="60%"> The <b>lParam</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="HDI_ORDER"></a><a id="hdi_order"></a><dl> <dt><b>HDI_ORDER</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iOrder</b> member is valid and specifies the item's order value. </td> </tr> <tr> <td width="40%"><a
    ///id="HDI_STATE"></a><a id="hdi_state"></a><dl> <dt><b>HDI_STATE</b></dt> </dl> </td> <td width="60%"> Version 6.00
    ///and later. The <b>state</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="HDI_TEXT"></a><a
    ///id="hdi_text"></a><dl> <dt><b>HDI_TEXT</b></dt> </dl> </td> <td width="60%"> The <b>pszText</b> and
    ///<b>cchTextMax</b> members are valid. </td> </tr> <tr> <td width="40%"><a id="HDI_WIDTH"></a><a
    ///id="hdi_width"></a><dl> <dt><b>HDI_WIDTH</b></dt> </dl> </td> <td width="60%"> The <b>cxy</b> member is valid and
    ///specifies the item's width. </td> </tr> </table>
    uint    mask;
    ///Type: <b>int</b> The width or height of the item.
    int     cxy;
    ///Type: <b>LPTSTR</b> A pointer to an item string. If the text is being retrieved from the control, this member
    ///must be initialized to point to a character buffer. If this member is set to LPSTR_TEXTCALLBACK, the control will
    ///request text information for this item by sending an HDN_GETDISPINFO notification code. Note that although the
    ///header control allows a string of any length to be stored as item text, only the first 260 <b>TCHAR</b><b>s</b>
    ///are displayed.
    PSTR    pszText;
    ///Type: <b>HBITMAP</b> A handle to the item bitmap.
    HBITMAP hbm;
    ///Type: <b>int</b> The length of the item string, in <b>TCHAR</b><b>s</b>. If the text is being retrieved from the
    ///control, this member must contain the number of <b>TCHAR</b><b>s</b> at the address specified by <b>pszText</b>.
    int     cchTextMax;
    ///Type: <b>int</b> Flags that specify the item's format. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="Text_Justification_"></a><a id="text_justification_"></a><a
    ///id="TEXT_JUSTIFICATION_"></a><dl> <dt><b>Text Justification:</b></dt> </dl> </td> <td width="60%"> Set one of the
    ///following flags to specify text justification: </td> </tr> <tr> <td width="40%"><a id="HDF_CENTER"></a><a
    ///id="hdf_center"></a><dl> <dt><b>HDF_CENTER</b></dt> </dl> </td> <td width="60%"> The item's contents are
    ///centered. </td> </tr> <tr> <td width="40%"><a id="HDF_LEFT"></a><a id="hdf_left"></a><dl>
    ///<dt><b>HDF_LEFT</b></dt> </dl> </td> <td width="60%"> The item's contents are left-aligned. </td> </tr> <tr> <td
    ///width="40%"><a id="HDF_RIGHT"></a><a id="hdf_right"></a><dl> <dt><b>HDF_RIGHT</b></dt> </dl> </td> <td
    ///width="60%"> The item's contents are right-aligned. </td> </tr> <tr> <td width="40%"><a id="Display_"></a><a
    ///id="display_"></a><a id="DISPLAY_"></a><dl> <dt><b>Display:</b></dt> </dl> </td> <td width="60%"> Set one of the
    ///following flags to control the display: </td> </tr> <tr> <td width="40%"><a id="HDF_BITMAP"></a><a
    ///id="hdf_bitmap"></a><dl> <dt><b>HDF_BITMAP</b></dt> </dl> </td> <td width="60%"> The item displays a bitmap.
    ///</td> </tr> <tr> <td width="40%"><a id="HDF_BITMAP_ON_RIGHT"></a><a id="hdf_bitmap_on_right"></a><dl>
    ///<dt><b>HDF_BITMAP_ON_RIGHT</b></dt> </dl> </td> <td width="60%"> The bitmap appears to the right of text. </td>
    ///</tr> <tr> <td width="40%"><a id="HDF_OWNERDRAW"></a><a id="hdf_ownerdraw"></a><dl> <dt><b>HDF_OWNERDRAW</b></dt>
    ///</dl> </td> <td width="60%"> The header control's owner draws the item. </td> </tr> <tr> <td width="40%"><a
    ///id="HDF_STRING"></a><a id="hdf_string"></a><dl> <dt><b>HDF_STRING</b></dt> </dl> </td> <td width="60%"> The item
    ///displays a string. </td> </tr> <tr> <td width="40%"><a id="Combining_Flags_"></a><a id="combining_flags_"></a><a
    ///id="COMBINING_FLAGS_"></a><dl> <dt><b>Combining Flags:</b></dt> </dl> </td> <td width="60%"> The preceding value
    ///can be combined with: </td> </tr> <tr> <td width="40%"><a id="HDF_IMAGE"></a><a id="hdf_image"></a><dl>
    ///<dt><b>HDF_IMAGE</b></dt> </dl> </td> <td width="60%"> Display an image from an image list. Specify the image
    ///list by sending an HDM_SETIMAGELIST message. Specify the index of the image in the <b>iImage</b> member of this
    ///structure. </td> </tr> <tr> <td width="40%"><a id="HDF_JUSTIFYMASK"></a><a id="hdf_justifymask"></a><dl>
    ///<dt><b>HDF_JUSTIFYMASK</b></dt> </dl> </td> <td width="60%"> Isolate the bits corresponding to the three
    ///justification flags listed in the preceding table. </td> </tr> <tr> <td width="40%"><a id="HDF_RTLREADING"></a><a
    ///id="hdf_rtlreading"></a><dl> <dt><b>HDF_RTLREADING</b></dt> </dl> </td> <td width="60%"> Typically, windows
    ///displays text left-to-right (LTR). Windows can be <i>mirrored</i> to display languages such as Hebrew or Arabic
    ///that read right-to-left (RTL). Usually, header text is read in the same direction as the text in its parent
    ///window. If HDF_RTLREADING is set, header text will read in the opposite direction from the text in the parent
    ///window. </td> </tr> <tr> <td width="40%"><a id="HDF_SORTDOWN"></a><a id="hdf_sortdown"></a><dl>
    ///<dt><b>HDF_SORTDOWN</b></dt> </dl> </td> <td width="60%"> Version 6.00 and later. Draws a down-arrow on this
    ///item. This is typically used to indicate that information in the current window is sorted on this column in
    ///descending order. This flag cannot be combined with HDF_IMAGE or HDF_BITMAP. </td> </tr> <tr> <td width="40%"><a
    ///id="HDF_SORTUP"></a><a id="hdf_sortup"></a><dl> <dt><b>HDF_SORTUP</b></dt> </dl> </td> <td width="60%"> Version
    ///6.00 and later. Draws an up-arrow on this item. This is typically used to indicate that information in the
    ///current window is sorted on this column in ascending order. This flag cannot be combined with HDF_IMAGE or
    ///HDF_BITMAP. </td> </tr> <tr> <td width="40%"><a id="HDF_CHECKBOX"></a><a id="hdf_checkbox"></a><dl>
    ///<dt><b>HDF_CHECKBOX</b></dt> </dl> </td> <td width="60%"> Version 6.00 and later. The item displays a checkbox.
    ///The flag is only valid when the HDS_CHECKBOXES style is first set on the header control. </td> </tr> <tr> <td
    ///width="40%"><a id="HDF_CHECKED"></a><a id="hdf_checked"></a><dl> <dt><b>HDF_CHECKED</b></dt> </dl> </td> <td
    ///width="60%"> Version 6.00 and later. The item displays a checked checkbox. The flag is only valid when
    ///HDF_CHECKBOX is also set. </td> </tr> <tr> <td width="40%"><a id="HDF_FIXEDWIDTH"></a><a
    ///id="hdf_fixedwidth"></a><dl> <dt><b>HDF_FIXEDWIDTH</b></dt> </dl> </td> <td width="60%"> Version 6.00 and later.
    ///The width of the item cannot be modified by a user action to resize it. </td> </tr> <tr> <td width="40%"><a
    ///id="HDF_SPLITBUTTON"></a><a id="hdf_splitbutton"></a><dl> <dt><b>HDF_SPLITBUTTON</b></dt> </dl> </td> <td
    ///width="60%"> Version 6.00 and later. The item displays a split button. The HDN_DROPDOWN notification is sent when
    ///the split button is clicked. </td> </tr> </table>
    int     fmt;
    ///Type: <b>LPARAM</b> Application-defined item data.
    LPARAM  lParam;
    ///Type: <b>int</b> The zero-based index of an image within the image list. The specified image will be displayed in
    ///the header item in addition to any image specified in the <b>hbm</b> field. If <b>iImage</b> is set to
    ///I_IMAGECALLBACK, the control requests text information for this item by using an HDN_GETDISPINFO notification
    ///code. To clear the image, set this value to I_IMAGENONE.
    int     iImage;
    ///Type: <b>int</b> The order in which the item appears within the header control, from left to right. That is, the
    ///value for the far left item is 0. The value for the next item to the right is 1, and so on.
    int     iOrder;
    ///Type: <b>UINT</b> The type of filter specified by <b>pvFilter</b>. The possible types include: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HDFT_ISSTRING"></a><a
    ///id="hdft_isstring"></a><dl> <dt><b>HDFT_ISSTRING</b></dt> </dl> </td> <td width="60%"> String data. </td> </tr>
    ///<tr> <td width="40%"><a id="HDFT_ISNUMBER"></a><a id="hdft_isnumber"></a><dl> <dt><b>HDFT_ISNUMBER</b></dt> </dl>
    ///</td> <td width="60%"> Numerical data. </td> </tr> <tr> <td width="40%"><a id="HDFT_HASNOVALUE"></a><a
    ///id="hdft_hasnovalue"></a><dl> <dt><b>HDFT_HASNOVALUE</b></dt> </dl> </td> <td width="60%"> Ignore
    ///<b>pvFilter</b>. </td> </tr> <tr> <td width="40%"><a id="HDFT_ISDATE"></a><a id="hdft_isdate"></a><dl>
    ///<dt><b>HDFT_ISDATE</b></dt> </dl> </td> <td width="60%"> Version 6.00 and later. Date data. The <b>pvFilter</b>
    ///member is a pointer to a SYSTEMTIME structure. </td> </tr> </table>
    uint    type;
    ///Type: <b>void*</b> The address of an application-defined data item. The data filter type is determined by setting
    ///the flag value of the member. Use the HDFT_ISSTRING flag to indicate a string and HDFT_ISNUMBER to indicate an
    ///integer. When the HDFT_ISSTRING flag is used <b>pvFilter</b> is a pointer to a HDTEXTFILTER structure.
    void*   pvFilter;
    ///Type: <b>UINT</b> The state. The only valid, supported value for this member is the following: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///<dt>HDIS_FOCUSED</dt> </dl> </td> <td width="60%"> The item has keyboard focus. </td> </tr> </table>
    uint    state;
}

///Contains information about an item in a header control. This structure supersedes the <b>HD_ITEM</b> structure.
struct HDITEMW
{
    ///Type: <b>UINT</b> Flags indicating which other structure members contain valid data or must be filled in. This
    ///member can be a combination of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="HDI_BITMAP"></a><a id="hdi_bitmap"></a><dl> <dt><b>HDI_BITMAP</b></dt> </dl> </td> <td
    ///width="60%"> The <b>hbm</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="HDI_DI_SETITEM"></a><a
    ///id="hdi_di_setitem"></a><dl> <dt><b>HDI_DI_SETITEM</b></dt> </dl> </td> <td width="60%"> While handling the
    ///message HDM_GETITEM, the header control may not have all the values needed to complete the request. In this case,
    ///the control must call the application back for the values via the HDN_GETDISPINFO notification. If HDI_DI_SETITEM
    ///has been passed in the <b>HDM_GETITEM</b> message, the control will cache any values returned from
    ///HDN_GETDISPINFO (otherwise the values remain unset.) </td> </tr> <tr> <td width="40%"><a id="HDI_FORMAT"></a><a
    ///id="hdi_format"></a><dl> <dt><b>HDI_FORMAT</b></dt> </dl> </td> <td width="60%"> The <b>fmt</b> member is valid.
    ///</td> </tr> <tr> <td width="40%"><a id="HDI_FILTER"></a><a id="hdi_filter"></a><dl> <dt><b>HDI_FILTER</b></dt>
    ///</dl> </td> <td width="60%"> The <b>type</b> and <b>pvFilter</b> members are valid. This is used to filter out
    ///the values specified in the <b>type</b> member. </td> </tr> <tr> <td width="40%"><a id="HDI_HEIGHT"></a><a
    ///id="hdi_height"></a><dl> <dt><b>HDI_HEIGHT</b></dt> </dl> </td> <td width="60%"> The same as HDI_WIDTH. </td>
    ///</tr> <tr> <td width="40%"><a id="HDI_IMAGE"></a><a id="hdi_image"></a><dl> <dt><b>HDI_IMAGE</b></dt> </dl> </td>
    ///<td width="60%"> The <b>iImage</b> member is valid and specifies the image to be displayed with the item. </td>
    ///</tr> <tr> <td width="40%"><a id="HDI_LPARAM"></a><a id="hdi_lparam"></a><dl> <dt><b>HDI_LPARAM</b></dt> </dl>
    ///</td> <td width="60%"> The <b>lParam</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="HDI_ORDER"></a><a id="hdi_order"></a><dl> <dt><b>HDI_ORDER</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iOrder</b> member is valid and specifies the item's order value. </td> </tr> <tr> <td width="40%"><a
    ///id="HDI_STATE"></a><a id="hdi_state"></a><dl> <dt><b>HDI_STATE</b></dt> </dl> </td> <td width="60%"> Version 6.00
    ///and later. The <b>state</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="HDI_TEXT"></a><a
    ///id="hdi_text"></a><dl> <dt><b>HDI_TEXT</b></dt> </dl> </td> <td width="60%"> The <b>pszText</b> and
    ///<b>cchTextMax</b> members are valid. </td> </tr> <tr> <td width="40%"><a id="HDI_WIDTH"></a><a
    ///id="hdi_width"></a><dl> <dt><b>HDI_WIDTH</b></dt> </dl> </td> <td width="60%"> The <b>cxy</b> member is valid and
    ///specifies the item's width. </td> </tr> </table>
    uint    mask;
    ///Type: <b>int</b> The width or height of the item.
    int     cxy;
    ///Type: <b>LPTSTR</b> A pointer to an item string. If the text is being retrieved from the control, this member
    ///must be initialized to point to a character buffer. If this member is set to LPSTR_TEXTCALLBACK, the control will
    ///request text information for this item by sending an HDN_GETDISPINFO notification code. Note that although the
    ///header control allows a string of any length to be stored as item text, only the first 260 <b>TCHAR</b><b>s</b>
    ///are displayed.
    PWSTR   pszText;
    ///Type: <b>HBITMAP</b> A handle to the item bitmap.
    HBITMAP hbm;
    ///Type: <b>int</b> The length of the item string, in <b>TCHAR</b><b>s</b>. If the text is being retrieved from the
    ///control, this member must contain the number of <b>TCHAR</b><b>s</b> at the address specified by <b>pszText</b>.
    int     cchTextMax;
    ///Type: <b>int</b> Flags that specify the item's format. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="Text_Justification_"></a><a id="text_justification_"></a><a
    ///id="TEXT_JUSTIFICATION_"></a><dl> <dt><b>Text Justification:</b></dt> </dl> </td> <td width="60%"> Set one of the
    ///following flags to specify text justification: </td> </tr> <tr> <td width="40%"><a id="HDF_CENTER"></a><a
    ///id="hdf_center"></a><dl> <dt><b>HDF_CENTER</b></dt> </dl> </td> <td width="60%"> The item's contents are
    ///centered. </td> </tr> <tr> <td width="40%"><a id="HDF_LEFT"></a><a id="hdf_left"></a><dl>
    ///<dt><b>HDF_LEFT</b></dt> </dl> </td> <td width="60%"> The item's contents are left-aligned. </td> </tr> <tr> <td
    ///width="40%"><a id="HDF_RIGHT"></a><a id="hdf_right"></a><dl> <dt><b>HDF_RIGHT</b></dt> </dl> </td> <td
    ///width="60%"> The item's contents are right-aligned. </td> </tr> <tr> <td width="40%"><a id="Display_"></a><a
    ///id="display_"></a><a id="DISPLAY_"></a><dl> <dt><b>Display:</b></dt> </dl> </td> <td width="60%"> Set one of the
    ///following flags to control the display: </td> </tr> <tr> <td width="40%"><a id="HDF_BITMAP"></a><a
    ///id="hdf_bitmap"></a><dl> <dt><b>HDF_BITMAP</b></dt> </dl> </td> <td width="60%"> The item displays a bitmap.
    ///</td> </tr> <tr> <td width="40%"><a id="HDF_BITMAP_ON_RIGHT"></a><a id="hdf_bitmap_on_right"></a><dl>
    ///<dt><b>HDF_BITMAP_ON_RIGHT</b></dt> </dl> </td> <td width="60%"> The bitmap appears to the right of text. </td>
    ///</tr> <tr> <td width="40%"><a id="HDF_OWNERDRAW"></a><a id="hdf_ownerdraw"></a><dl> <dt><b>HDF_OWNERDRAW</b></dt>
    ///</dl> </td> <td width="60%"> The header control's owner draws the item. </td> </tr> <tr> <td width="40%"><a
    ///id="HDF_STRING"></a><a id="hdf_string"></a><dl> <dt><b>HDF_STRING</b></dt> </dl> </td> <td width="60%"> The item
    ///displays a string. </td> </tr> <tr> <td width="40%"><a id="Combining_Flags_"></a><a id="combining_flags_"></a><a
    ///id="COMBINING_FLAGS_"></a><dl> <dt><b>Combining Flags:</b></dt> </dl> </td> <td width="60%"> The preceding value
    ///can be combined with: </td> </tr> <tr> <td width="40%"><a id="HDF_IMAGE"></a><a id="hdf_image"></a><dl>
    ///<dt><b>HDF_IMAGE</b></dt> </dl> </td> <td width="60%"> Display an image from an image list. Specify the image
    ///list by sending an HDM_SETIMAGELIST message. Specify the index of the image in the <b>iImage</b> member of this
    ///structure. </td> </tr> <tr> <td width="40%"><a id="HDF_JUSTIFYMASK"></a><a id="hdf_justifymask"></a><dl>
    ///<dt><b>HDF_JUSTIFYMASK</b></dt> </dl> </td> <td width="60%"> Isolate the bits corresponding to the three
    ///justification flags listed in the preceding table. </td> </tr> <tr> <td width="40%"><a id="HDF_RTLREADING"></a><a
    ///id="hdf_rtlreading"></a><dl> <dt><b>HDF_RTLREADING</b></dt> </dl> </td> <td width="60%"> Typically, windows
    ///displays text left-to-right (LTR). Windows can be <i>mirrored</i> to display languages such as Hebrew or Arabic
    ///that read right-to-left (RTL). Usually, header text is read in the same direction as the text in its parent
    ///window. If HDF_RTLREADING is set, header text will read in the opposite direction from the text in the parent
    ///window. </td> </tr> <tr> <td width="40%"><a id="HDF_SORTDOWN"></a><a id="hdf_sortdown"></a><dl>
    ///<dt><b>HDF_SORTDOWN</b></dt> </dl> </td> <td width="60%"> Version 6.00 and later. Draws a down-arrow on this
    ///item. This is typically used to indicate that information in the current window is sorted on this column in
    ///descending order. This flag cannot be combined with HDF_IMAGE or HDF_BITMAP. </td> </tr> <tr> <td width="40%"><a
    ///id="HDF_SORTUP"></a><a id="hdf_sortup"></a><dl> <dt><b>HDF_SORTUP</b></dt> </dl> </td> <td width="60%"> Version
    ///6.00 and later. Draws an up-arrow on this item. This is typically used to indicate that information in the
    ///current window is sorted on this column in ascending order. This flag cannot be combined with HDF_IMAGE or
    ///HDF_BITMAP. </td> </tr> <tr> <td width="40%"><a id="HDF_CHECKBOX"></a><a id="hdf_checkbox"></a><dl>
    ///<dt><b>HDF_CHECKBOX</b></dt> </dl> </td> <td width="60%"> Version 6.00 and later. The item displays a checkbox.
    ///The flag is only valid when the HDS_CHECKBOXES style is first set on the header control. </td> </tr> <tr> <td
    ///width="40%"><a id="HDF_CHECKED"></a><a id="hdf_checked"></a><dl> <dt><b>HDF_CHECKED</b></dt> </dl> </td> <td
    ///width="60%"> Version 6.00 and later. The item displays a checked checkbox. The flag is only valid when
    ///HDF_CHECKBOX is also set. </td> </tr> <tr> <td width="40%"><a id="HDF_FIXEDWIDTH"></a><a
    ///id="hdf_fixedwidth"></a><dl> <dt><b>HDF_FIXEDWIDTH</b></dt> </dl> </td> <td width="60%"> Version 6.00 and later.
    ///The width of the item cannot be modified by a user action to resize it. </td> </tr> <tr> <td width="40%"><a
    ///id="HDF_SPLITBUTTON"></a><a id="hdf_splitbutton"></a><dl> <dt><b>HDF_SPLITBUTTON</b></dt> </dl> </td> <td
    ///width="60%"> Version 6.00 and later. The item displays a split button. The HDN_DROPDOWN notification is sent when
    ///the split button is clicked. </td> </tr> </table>
    int     fmt;
    ///Type: <b>LPARAM</b> Application-defined item data.
    LPARAM  lParam;
    ///Type: <b>int</b> The zero-based index of an image within the image list. The specified image will be displayed in
    ///the header item in addition to any image specified in the <b>hbm</b> field. If <b>iImage</b> is set to
    ///I_IMAGECALLBACK, the control requests text information for this item by using an HDN_GETDISPINFO notification
    ///code. To clear the image, set this value to I_IMAGENONE.
    int     iImage;
    ///Type: <b>int</b> The order in which the item appears within the header control, from left to right. That is, the
    ///value for the far left item is 0. The value for the next item to the right is 1, and so on.
    int     iOrder;
    ///Type: <b>UINT</b> The type of filter specified by <b>pvFilter</b>. The possible types include: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HDFT_ISSTRING"></a><a
    ///id="hdft_isstring"></a><dl> <dt><b>HDFT_ISSTRING</b></dt> </dl> </td> <td width="60%"> String data. </td> </tr>
    ///<tr> <td width="40%"><a id="HDFT_ISNUMBER"></a><a id="hdft_isnumber"></a><dl> <dt><b>HDFT_ISNUMBER</b></dt> </dl>
    ///</td> <td width="60%"> Numerical data. </td> </tr> <tr> <td width="40%"><a id="HDFT_HASNOVALUE"></a><a
    ///id="hdft_hasnovalue"></a><dl> <dt><b>HDFT_HASNOVALUE</b></dt> </dl> </td> <td width="60%"> Ignore
    ///<b>pvFilter</b>. </td> </tr> <tr> <td width="40%"><a id="HDFT_ISDATE"></a><a id="hdft_isdate"></a><dl>
    ///<dt><b>HDFT_ISDATE</b></dt> </dl> </td> <td width="60%"> Version 6.00 and later. Date data. The <b>pvFilter</b>
    ///member is a pointer to a SYSTEMTIME structure. </td> </tr> </table>
    uint    type;
    ///Type: <b>void*</b> The address of an application-defined data item. The data filter type is determined by setting
    ///the flag value of the member. Use the HDFT_ISSTRING flag to indicate a string and HDFT_ISNUMBER to indicate an
    ///integer. When the HDFT_ISSTRING flag is used <b>pvFilter</b> is a pointer to a HDTEXTFILTER structure.
    void*   pvFilter;
    ///Type: <b>UINT</b> The state. The only valid, supported value for this member is the following: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///<dt>HDIS_FOCUSED</dt> </dl> </td> <td width="60%"> The item has keyboard focus. </td> </tr> </table>
    uint    state;
}

///Contains information used to set the size and position of a header control. <b>HDLAYOUT</b> is used with the
///HDM_LAYOUT message. This structure supersedes the <b>HD_LAYOUT</b> structure.
struct HDLAYOUT
{
    ///Type: <b>RECT*</b> Structure that contains the coordinates of a rectangle that the header control will occupy.
    RECT*      prc;
    WINDOWPOS* pwpos;
}

///Contains information about a hit test. This structure is used with the HDM_HITTEST message and it supersedes the
///<b>HD_HITTESTINFO</b> structure.
struct HDHITTESTINFO
{
    ///Type: <b>POINT</b> A POINT structure that contains the point to be hit test, in client coordinates.
    POINT pt;
    ///Type: <b>UINT</b> The variable that receives information about the results of a hit test. This member can be one
    ///or more of the values listed below. Two of these values can be combined, such as when the position is above and
    ///to the left of the client area. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="HHT_ABOVE"></a><a id="hht_above"></a><dl> <dt><b>HHT_ABOVE</b></dt> </dl> </td> <td width="60%"> The point is
    ///above the header control's bounding rectangle. </td> </tr> <tr> <td width="40%"><a id="HHT_BELOW"></a><a
    ///id="hht_below"></a><dl> <dt><b>HHT_BELOW</b></dt> </dl> </td> <td width="60%"> The point is below the header
    ///control's bounding rectangle. </td> </tr> <tr> <td width="40%"><a id="HHT_NOWHERE"></a><a
    ///id="hht_nowhere"></a><dl> <dt><b>HHT_NOWHERE</b></dt> </dl> </td> <td width="60%"> The point is inside the header
    ///control's bounding rectangle but is not over a header item. </td> </tr> <tr> <td width="40%"><a
    ///id="HHT_ONDIVIDER"></a><a id="hht_ondivider"></a><dl> <dt><b>HHT_ONDIVIDER</b></dt> </dl> </td> <td width="60%">
    ///The point is on the divider between two header items. </td> </tr> <tr> <td width="40%"><a
    ///id="HHT_ONDIVOPEN"></a><a id="hht_ondivopen"></a><dl> <dt><b>HHT_ONDIVOPEN</b></dt> </dl> </td> <td width="60%">
    ///The point is on the divider of an item that has a width of zero. Dragging the divider reveals the item instead of
    ///resizing the item to the left of the divider. </td> </tr> <tr> <td width="40%"><a id="HHT_ONHEADER"></a><a
    ///id="hht_onheader"></a><dl> <dt><b>HHT_ONHEADER</b></dt> </dl> </td> <td width="60%"> The point is inside the
    ///header control's bounding rectangle. </td> </tr> <tr> <td width="40%"><a id="HHT_ONFILTER"></a><a
    ///id="hht_onfilter"></a><dl> <dt><b>HHT_ONFILTER</b></dt> </dl> </td> <td width="60%"> Version 5.80 The point is
    ///over the filter area. </td> </tr> <tr> <td width="40%"><a id="HHT_ONFILTERBUTTON"></a><a
    ///id="hht_onfilterbutton"></a><dl> <dt><b>HHT_ONFILTERBUTTON</b></dt> </dl> </td> <td width="60%"> Version 5.80 The
    ///point is on the filter button. </td> </tr> <tr> <td width="40%"><a id="HHT_TOLEFT"></a><a
    ///id="hht_toleft"></a><dl> <dt><b>HHT_TOLEFT</b></dt> </dl> </td> <td width="60%"> The point is to the left of the
    ///header control's bounding rectangle. </td> </tr> <tr> <td width="40%"><a id="HHT_TORIGHT"></a><a
    ///id="hht_toright"></a><dl> <dt><b>HHT_TORIGHT</b></dt> </dl> </td> <td width="60%"> The point is to the right of
    ///the header control's bounding rectangle. </td> </tr> <tr> <td width="40%"><a id="HHT_ONITEMSTATEICON"></a><a
    ///id="hht_onitemstateicon"></a><dl> <dt><b>HHT_ONITEMSTATEICON</b></dt> </dl> </td> <td width="60%"> Version 6.00
    ///and <b>Windows Vista. </b> The point is within the state icon of the item. If style HDS_CHECKBOXES is specified,
    ///the point is within the checkbox of the item. </td> </tr> <tr> <td width="40%"><a id="HHT_ONDROPDOWN"></a><a
    ///id="hht_ondropdown"></a><dl> <dt><b>HHT_ONDROPDOWN</b></dt> </dl> </td> <td width="60%"> Version 6.00 and
    ///<b>Windows Vista.</b> The point is within the split button of the item. The style HDF_SPLITBUTTON must be set on
    ///the item. </td> </tr> <tr> <td width="40%"><a id="HHT_ONOVERFLOW"></a><a id="hht_onoverflow"></a><dl>
    ///<dt><b>HHT_ONOVERFLOW</b></dt> </dl> </td> <td width="60%"> Version 6.00 and <b>Windows Vista.</b> The point is
    ///within the overflow button of the header control. The style HDS_OVERFLOW must be set on the header control. </td>
    ///</tr> </table>
    uint  flags;
    int   iItem;
}

///Contains information about header control notification messages. This structure supersedes the <b>HD_NOTIFY</b>
///structure.
struct NMHEADERA
{
    ///Type: <b>NMHDR</b> A NMHDR structure that contains information about the notification message.
    NMHDR    hdr;
    ///Type: <b>int</b> The zero-based index of the header item that is the focus of the notification message.
    int      iItem;
    ///Type: <b>int</b> A value specifying the index of the mouse button used to generate the notification message. This
    ///member can be one of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> Left button </td> </tr> <tr> <td
    ///width="40%"><a id="1"></a><dl> <dt><b>1</b></dt> </dl> </td> <td width="60%"> Right button </td> </tr> <tr> <td
    ///width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> Middle button </td> </tr> </table>
    int      iButton;
    ///Type: <b>HDITEM*</b> An optional pointer to an HDITEM structure containing information about the item specified
    ///by <b>iItem</b>. The <b>mask</b> member of the <b>HDITEM</b> structure indicates which of its members are valid.
    HDITEMA* pitem;
}

///Contains information about header control notification messages. This structure supersedes the <b>HD_NOTIFY</b>
///structure.
struct NMHEADERW
{
    ///Type: <b>NMHDR</b> A NMHDR structure that contains information about the notification message.
    NMHDR    hdr;
    ///Type: <b>int</b> The zero-based index of the header item that is the focus of the notification message.
    int      iItem;
    ///Type: <b>int</b> A value specifying the index of the mouse button used to generate the notification message. This
    ///member can be one of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> Left button </td> </tr> <tr> <td
    ///width="40%"><a id="1"></a><dl> <dt><b>1</b></dt> </dl> </td> <td width="60%"> Right button </td> </tr> <tr> <td
    ///width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> Middle button </td> </tr> </table>
    int      iButton;
    ///Type: <b>HDITEM*</b> An optional pointer to an HDITEM structure containing information about the item specified
    ///by <b>iItem</b>. The <b>mask</b> member of the <b>HDITEM</b> structure indicates which of its members are valid.
    HDITEMW* pitem;
}

///Contains information used in handling HDN_GETDISPINFO notification codes.
struct NMHDDISPINFOW
{
    ///Type: <b>NMHDR</b> NMHDR structure containing information about this notification code.
    NMHDR  hdr;
    ///Type: <b>int</b> The zero-based index of the item in the header control.
    int    iItem;
    ///Type: <b>UINT</b> A set of bit flags specifying which members of the structure must be filled in by the owner of
    ///the header control. This value can be a combination of the following values: <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="HDI_TEXT"></a><a id="hdi_text"></a><dl>
    ///<dt><b>HDI_TEXT</b></dt> </dl> </td> <td width="60%"> The <b>pszText</b> field must be filled in. </td> </tr>
    ///<tr> <td width="40%"><a id="HDI_IMAGE"></a><a id="hdi_image"></a><dl> <dt><b>HDI_IMAGE</b></dt> </dl> </td> <td
    ///width="60%"> Version 4.70. The <b>iImage</b> field must be filled in. </td> </tr> <tr> <td width="40%"><a
    ///id="HDI_LPARAM"></a><a id="hdi_lparam"></a><dl> <dt><b>HDI_LPARAM</b></dt> </dl> </td> <td width="60%"> The
    ///<b>lParam</b> field must be filled in. </td> </tr> <tr> <td width="40%"><a id="HDI_DI_SETITEM"></a><a
    ///id="hdi_di_setitem"></a><dl> <dt><b>HDI_DI_SETITEM</b></dt> </dl> </td> <td width="60%"> Version 4.70. A return
    ///value. Indicates that the header control should store the item information and not ask for it again. </td> </tr>
    ///</table>
    uint   mask;
    ///Type: <b>LPTSTR</b> A pointer to a null-terminated string containing the text that will be displayed for the
    ///header item.
    PWSTR  pszText;
    ///Type: <b>int</b> The size of the buffer that <b>pszText</b> points to.
    int    cchTextMax;
    ///Type: <b>int</b> The zero-based index of an image within the image list. The specified image will be displayed
    ///with the header item, but it does not take the place of the item's bitmap. If <b>iImage</b> is set to
    ///I_IMAGECALLBACK, the control requests image information for this item by using an HDN_GETDISPINFO notification
    ///code.
    int    iImage;
    ///Type: <b>LPARAM</b> An application-defined value to associate with the item.
    LPARAM lParam;
}

///Contains information used in handling HDN_GETDISPINFO notification codes.
struct NMHDDISPINFOA
{
    ///Type: <b>NMHDR</b> NMHDR structure containing information about this notification code.
    NMHDR  hdr;
    ///Type: <b>int</b> The zero-based index of the item in the header control.
    int    iItem;
    ///Type: <b>UINT</b> A set of bit flags specifying which members of the structure must be filled in by the owner of
    ///the header control. This value can be a combination of the following values: <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="HDI_TEXT"></a><a id="hdi_text"></a><dl>
    ///<dt><b>HDI_TEXT</b></dt> </dl> </td> <td width="60%"> The <b>pszText</b> field must be filled in. </td> </tr>
    ///<tr> <td width="40%"><a id="HDI_IMAGE"></a><a id="hdi_image"></a><dl> <dt><b>HDI_IMAGE</b></dt> </dl> </td> <td
    ///width="60%"> Version 4.70. The <b>iImage</b> field must be filled in. </td> </tr> <tr> <td width="40%"><a
    ///id="HDI_LPARAM"></a><a id="hdi_lparam"></a><dl> <dt><b>HDI_LPARAM</b></dt> </dl> </td> <td width="60%"> The
    ///<b>lParam</b> field must be filled in. </td> </tr> <tr> <td width="40%"><a id="HDI_DI_SETITEM"></a><a
    ///id="hdi_di_setitem"></a><dl> <dt><b>HDI_DI_SETITEM</b></dt> </dl> </td> <td width="60%"> Version 4.70. A return
    ///value. Indicates that the header control should store the item information and not ask for it again. </td> </tr>
    ///</table>
    uint   mask;
    ///Type: <b>LPTSTR</b> A pointer to a null-terminated string containing the text that will be displayed for the
    ///header item.
    PSTR   pszText;
    ///Type: <b>int</b> The size of the buffer that <b>pszText</b> points to.
    int    cchTextMax;
    ///Type: <b>int</b> The zero-based index of an image within the image list. The specified image will be displayed
    ///with the header item, but it does not take the place of the item's bitmap. If <b>iImage</b> is set to
    ///I_IMAGECALLBACK, the control requests image information for this item by using an HDN_GETDISPINFO notification
    ///code.
    int    iImage;
    ///Type: <b>LPARAM</b> An application-defined value to associate with the item.
    LPARAM lParam;
}

///Specifies or receives the attributes of a filter button click.
struct NMHDFILTERBTNCLICK
{
    ///Type: <b>NMHDR</b> A handle of an NMHDR structure that contains additional information.
    NMHDR hdr;
    ///Type: <b>INT</b> The zero-based index of the control to which this structure refers.
    int   iItem;
    ///Type: <b>RECT</b> A pointer to a RECT structure that contains the client rectangle for the filter button.
    RECT  rc;
}

///Contains information about a button in a toolbar.
struct TBBUTTON
{
    ///Type: <b>int</b> Zero-based index of the button image. Set this member to I_IMAGECALLBACK, and the toolbar will
    ///send the TBN_GETDISPINFO notification code to retrieve the image index when it is needed. Version 5.81. Set this
    ///member to I_IMAGENONE to indicate that the button does not have an image. The button layout will not include any
    ///space for a bitmap, only text. If the button is a separator, that is, if <b>fsStyle</b> is set to BTNS_SEP,
    ///<b>iBitmap</b> determines the width of the separator, in pixels. For information on selecting button images from
    ///image lists, see TB_SETIMAGELIST message.
    int       iBitmap;
    ///Type: <b>int</b> Command identifier associated with the button. This identifier is used in a WM_COMMAND message
    ///when the button is chosen.
    int       idCommand;
    ///Type: <b>BYTE</b> Button state flags. This member can be a combination of the values listed in Toolbar Button
    ///States.
    ubyte     fsState;
    ///Type: <b>BYTE</b> Button style. This member can be a combination of the button style values listed in Toolbar
    ///Control and Button Styles.
    ubyte     fsStyle;
    ///Type: <b>BYTE</b> Reserved.
    ubyte[2]  bReserved;
    ///Type: <b>DWORD_PTR</b> Application-defined value.
    size_t    dwData;
    ///Type: <b>INT_PTR</b> Zero-based index of the button string, or a pointer to a string buffer that contains text
    ///for the button.
    ptrdiff_t iString;
}

///Contains information used by the CreateMappedBitmap function to map the colors of the bitmap.
struct COLORMAP
{
    ///Type: <b>COLORREF</b> Color to map from.
    uint from;
    uint to;
}

///Contains information specific to an NM_CUSTOMDRAW notification code sent by a toolbar control.
struct NMTBCUSTOMDRAW
{
    ///Type: <b>NMCUSTOMDRAW</b> NMCUSTOMDRAW structure that contains general custom draw information. The
    ///<b>uItemState</b> member of this structure can be modified so that a toolbar item will be drawn in the specified
    ///state without actually changing the item's state.
    NMCUSTOMDRAW nmcd;
    ///Type: <b>HBRUSH</b> HBRUSH that the control will use when drawing the background of marked or dithered items.
    ///This member is ignored if TBCDRF_NOMARK is returned from the NM_CUSTOMDRAW notification code.
    HBRUSH       hbrMonoDither;
    ///Type: <b>HBRUSH</b> HBRUSH that the control will use when drawing lines on the buttons.
    HBRUSH       hbrLines;
    ///Type: <b>HPEN</b> HPEN that the control will use when drawing lines on the buttons.
    HPEN         hpenLines;
    ///Type: <b>COLORREF</b> COLORREF that represents the color that the control will use when drawing text on normal
    ///items.
    uint         clrText;
    ///Type: <b>COLORREF</b> <b>COLORREF</b> that represents the background color that the control will use when drawing
    ///text on marked items.
    uint         clrMark;
    ///Type: <b>COLORREF</b> <b>COLORREF</b> that represents the color that the control will use when drawing text on
    ///highlighted items.
    uint         clrTextHighlight;
    ///Type: <b>COLORREF</b> <b>COLORREF</b> that represents the face color that the control will use when drawing
    ///buttons.
    uint         clrBtnFace;
    ///Type: <b>COLORREF</b> <b>COLORREF</b> that represents the face color that the control will use when drawing
    ///highlighted items. An item is highlighted if it has the TBSTATE_MARKED style and is contained in a toolbar that
    ///has the TBSTYLE_FLAT style.
    uint         clrBtnHighlight;
    ///Type: <b>COLORREF</b> <b>COLORREF</b> that represents the background color that the control will use when drawing
    ///text on hot tracked items. This member is ignored if TBCDRF_HILITEHOTTRACK is not returned from the NM_CUSTOMDRAW
    ///notification code.
    uint         clrHighlightHotTrack;
    ///Type: <b>RECT</b> RECT structure that, on entry, contains the rectangle of the item's text. The <b>right</b> and
    ///<b>bottom</b> members of this structure can be modified to change the width and height, respectively, of the text
    ///rectangle of the item.
    RECT         rcText;
    ///Type: <b>int</b> Background mode that the control will use when drawing the text of a nonhighlighted item. This
    ///can be either the TRANSPARENT or OPAQUE value.
    int          nStringBkMode;
    ///Type: <b>int</b> Background mode that the control will use when drawing the text of a highlighted item. This can
    ///be either the TRANSPARENT or OPAQUE value.
    int          nHLStringBkMode;
    int          iListGap;
}

///Adds a bitmap that contains button images to a toolbar.
struct TBADDBITMAP
{
    ///Type: <b>HINSTANCE</b> Handle to the module instance with the executable file that contains a bitmap resource. To
    ///use bitmap handles instead of resource IDs, set this member to <b>NULL</b>. You can add the system-defined button
    ///bitmaps to the list by specifying HINST_COMMCTRL as the <b>hInst</b> member and one of the following values as
    ///the <b>nID</b> member. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="IDB_STD_LARGE_COLOR"></a><a id="idb_std_large_color"></a><dl> <dt><b>IDB_STD_LARGE_COLOR</b></dt> </dl> </td>
    ///<td width="60%"> Large, color standard bitmaps. </td> </tr> <tr> <td width="40%"><a
    ///id="IDB_STD_SMALL_COLOR"></a><a id="idb_std_small_color"></a><dl> <dt><b>IDB_STD_SMALL_COLOR</b></dt> </dl> </td>
    ///<td width="60%"> Small, color standard bitmaps. </td> </tr> <tr> <td width="40%"><a
    ///id="IDB_VIEW_LARGE_COLOR"></a><a id="idb_view_large_color"></a><dl> <dt><b>IDB_VIEW_LARGE_COLOR</b></dt> </dl>
    ///</td> <td width="60%"> Small large, color view bitmaps. </td> </tr> <tr> <td width="40%"><a
    ///id="IDB_VIEW_SMALL_COLOR"></a><a id="idb_view_small_color"></a><dl> <dt><b>IDB_VIEW_SMALL_COLOR</b></dt> </dl>
    ///</td> <td width="60%"> Small, color view bitmaps. </td> </tr> <tr> <td width="40%"><a id="IDB_HIST_NORMAL"></a><a
    ///id="idb_hist_normal"></a><dl> <dt><b>IDB_HIST_NORMAL</b></dt> </dl> </td> <td width="60%"> Windows Explorer
    ///travel buttons and favorites bitmaps in normal state. </td> </tr> <tr> <td width="40%"><a
    ///id="IDB_HIST_HOT"></a><a id="idb_hist_hot"></a><dl> <dt><b>IDB_HIST_HOT</b></dt> </dl> </td> <td width="60%">
    ///Windows Explorer travel buttons and favorites bitmaps in hot state. </td> </tr> <tr> <td width="40%"><a
    ///id="IDB_HIST_DISABLED"></a><a id="idb_hist_disabled"></a><dl> <dt><b>IDB_HIST_DISABLED</b></dt> </dl> </td> <td
    ///width="60%"> Windows Explorer travel buttons and favorites bitmaps in disabled state. </td> </tr> <tr> <td
    ///width="40%"><a id="IDB_HIST_PRESSED"></a><a id="idb_hist_pressed"></a><dl> <dt><b>IDB_HIST_PRESSED</b></dt> </dl>
    ///</td> <td width="60%"> Windows Explorer travel buttons and favorites bitmaps in pressed state. </td> </tr>
    ///</table>
    HINSTANCE hInst;
    ///Type: <b>UINT_PTR</b> If <b>hInst</b> is <b>NULL</b>, set this member to the bitmap handle of the bitmap with the
    ///button images. Otherwise, set it to the resource identifier of the bitmap with the button images.
    size_t    nID;
}

///Specifies the location in the registry where the TB_SAVERESTORE message stores and retrieves information about the
///state of a toolbar.
struct TBSAVEPARAMSA
{
    ///Type: <b>HKEY</b> Handle to the registry key.
    HKEY        hkr;
    ///Type: <b>LPCTSTR</b> Subkey name.
    const(PSTR) pszSubKey;
    ///Type: <b>LPCTSTR</b> Value name.
    const(PSTR) pszValueName;
}

///Specifies the location in the registry where the TB_SAVERESTORE message stores and retrieves information about the
///state of a toolbar.
struct TBSAVEPARAMSW
{
    ///Type: <b>HKEY</b> Handle to the registry key.
    HKEY         hkr;
    ///Type: <b>LPCTSTR</b> Subkey name.
    const(PWSTR) pszSubKey;
    ///Type: <b>LPCTSTR</b> Value name.
    const(PWSTR) pszValueName;
}

///Contains information on the insertion mark in a toolbar control.
struct TBINSERTMARK
{
    ///Type: <b>int</b> Zero-based index of the insertion mark. If this member is -1, there is no insertion mark.
    int  iButton;
    uint dwFlags;
}

///Used with the TB_REPLACEBITMAP message to replace one toolbar bitmap with another.
struct TBREPLACEBITMAP
{
    ///Type: <b>HINSTANCE</b> Module instance handle to the bitmap resource being replaced. Set this member to
    ///<b>NULL</b> to instead use a bitmap handle.
    HINSTANCE hInstOld;
    ///Type: <b>UINT_PTR</b> If <b>hInstOld</b> is <b>NULL</b>, set this member to the bitmap handle of the bitmap that
    ///is being replaced. Otherwise, set it to the resource identifier of the bitmap being replaced.
    size_t    nIDOld;
    ///Type: <b>HINSTANCE</b> Module instance handle that contains the new bitmap resource. Set this member to
    ///<b>NULL</b> to instead use a bitmap handle.
    HINSTANCE hInstNew;
    ///Type: <b>UINT_PTR</b> If <b>hInstNew</b> is <b>NULL</b>, set this member to the bitmap handle of the bitmap with
    ///the new button images. Otherwise, set it to the resource identifier of the bitmap with the new button images.
    size_t    nIDNew;
    ///Type: <b>int</b> Number of button images contained in the new bitmap. The number of new images should be the same
    ///as the number of replaced images.
    int       nButtons;
}

///Contains or receives information for a specific button in a toolbar.
struct TBBUTTONINFOA
{
    ///Type: <b>UINT</b> Size of the structure, in bytes. This member must be filled in prior to sending the associated
    ///message.
    uint   cbSize;
    ///Type: <b>DWORD</b> Set of flags that indicate which members contain valid information. This member must be filled
    ///in prior to sending the associated message. This can be one or more of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TBIF_BYINDEX"></a><a id="tbif_byindex"></a><dl>
    ///<dt><b>TBIF_BYINDEX</b></dt> </dl> </td> <td width="60%"> Version 5.80. The <i>wParam</i> sent with a
    ///TB_GETBUTTONINFO or TB_SETBUTTONINFO message is an index, not an identifier. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_COMMAND"></a><a id="tbif_command"></a><dl> <dt><b>TBIF_COMMAND</b></dt> </dl> </td> <td width="60%"> The
    ///<b>idCommand</b> member contains valid information or is being requested. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_IMAGE"></a><a id="tbif_image"></a><dl> <dt><b>TBIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iImage</b> member contains valid information or is being requested. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_LPARAM"></a><a id="tbif_lparam"></a><dl> <dt><b>TBIF_LPARAM</b></dt> </dl> </td> <td width="60%"> The
    ///<b>lParam</b> member contains valid information or is being requested. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_SIZE"></a><a id="tbif_size"></a><dl> <dt><b>TBIF_SIZE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>cx</b> member contains valid information or is being requested. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_STATE"></a><a id="tbif_state"></a><dl> <dt><b>TBIF_STATE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>fsState</b> member contains valid information or is being requested. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_STYLE"></a><a id="tbif_style"></a><dl> <dt><b>TBIF_STYLE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>fsStyle</b> member contains valid information or is being requested. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_TEXT"></a><a id="tbif_text"></a><dl> <dt><b>TBIF_TEXT</b></dt> </dl> </td> <td width="60%"> The
    ///<b>pszText</b> member contains valid information or is being requested. </td> </tr> </table>
    uint   dwMask;
    ///Type: <b>int</b> Command identifier of the button.
    int    idCommand;
    ///Type: <b>int</b> Image index of the button. Set this member to I_IMAGECALLBACK, and the toolbar will send the
    ///TBN_GETDISPINFO notification code to retrieve the image index when it is needed. Version 5.81. Set this member to
    ///I_IMAGENONE to indicate that the button does not have an image. The button layout will not include any space for
    ///a bitmap, only text.
    int    iImage;
    ///Type: <b>BYTE</b> State flags of the button. This can be one or more of the values listed in Toolbar Button
    ///States.
    ubyte  fsState;
    ///Type: <b>BYTE</b> Style flags of the button. This can be one or more of the values listed in Toolbar Control and
    ///Button Styles.
    ubyte  fsStyle;
    ///Type: <b>WORD</b> Width of the button, in pixels.
    ushort cx;
    ///Type: <b>DWORD_PTR</b> Application-defined value associated with the button.
    size_t lParam;
    ///Type: <b>LPTSTR</b> Address of a character buffer that contains or receives the button text.
    PSTR   pszText;
    ///Type: <b>int</b> Size of the buffer at <b>pszText</b>. If the button information is being set, this member is
    ///ignored.
    int    cchText;
}

///Contains or receives information for a specific button in a toolbar.
struct TBBUTTONINFOW
{
    ///Type: <b>UINT</b> Size of the structure, in bytes. This member must be filled in prior to sending the associated
    ///message.
    uint   cbSize;
    ///Type: <b>DWORD</b> Set of flags that indicate which members contain valid information. This member must be filled
    ///in prior to sending the associated message. This can be one or more of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TBIF_BYINDEX"></a><a id="tbif_byindex"></a><dl>
    ///<dt><b>TBIF_BYINDEX</b></dt> </dl> </td> <td width="60%"> Version 5.80. The <i>wParam</i> sent with a
    ///TB_GETBUTTONINFO or TB_SETBUTTONINFO message is an index, not an identifier. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_COMMAND"></a><a id="tbif_command"></a><dl> <dt><b>TBIF_COMMAND</b></dt> </dl> </td> <td width="60%"> The
    ///<b>idCommand</b> member contains valid information or is being requested. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_IMAGE"></a><a id="tbif_image"></a><dl> <dt><b>TBIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iImage</b> member contains valid information or is being requested. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_LPARAM"></a><a id="tbif_lparam"></a><dl> <dt><b>TBIF_LPARAM</b></dt> </dl> </td> <td width="60%"> The
    ///<b>lParam</b> member contains valid information or is being requested. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_SIZE"></a><a id="tbif_size"></a><dl> <dt><b>TBIF_SIZE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>cx</b> member contains valid information or is being requested. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_STATE"></a><a id="tbif_state"></a><dl> <dt><b>TBIF_STATE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>fsState</b> member contains valid information or is being requested. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_STYLE"></a><a id="tbif_style"></a><dl> <dt><b>TBIF_STYLE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>fsStyle</b> member contains valid information or is being requested. </td> </tr> <tr> <td width="40%"><a
    ///id="TBIF_TEXT"></a><a id="tbif_text"></a><dl> <dt><b>TBIF_TEXT</b></dt> </dl> </td> <td width="60%"> The
    ///<b>pszText</b> member contains valid information or is being requested. </td> </tr> </table>
    uint   dwMask;
    ///Type: <b>int</b> Command identifier of the button.
    int    idCommand;
    ///Type: <b>int</b> Image index of the button. Set this member to I_IMAGECALLBACK, and the toolbar will send the
    ///TBN_GETDISPINFO notification code to retrieve the image index when it is needed. Version 5.81. Set this member to
    ///I_IMAGENONE to indicate that the button does not have an image. The button layout will not include any space for
    ///a bitmap, only text.
    int    iImage;
    ///Type: <b>BYTE</b> State flags of the button. This can be one or more of the values listed in Toolbar Button
    ///States.
    ubyte  fsState;
    ///Type: <b>BYTE</b> Style flags of the button. This can be one or more of the values listed in Toolbar Control and
    ///Button Styles.
    ubyte  fsStyle;
    ///Type: <b>WORD</b> Width of the button, in pixels.
    ushort cx;
    ///Type: <b>DWORD_PTR</b> Application-defined value associated with the button.
    size_t lParam;
    ///Type: <b>LPTSTR</b> Address of a character buffer that contains or receives the button text.
    PWSTR  pszText;
    ///Type: <b>int</b> Size of the buffer at <b>pszText</b>. If the button information is being set, this member is
    ///ignored.
    int    cchText;
}

///Defines the metrics of a toolbar that are used to shrink or expand toolbar items.
struct TBMETRICS
{
    ///Type: <b>UINT</b> Size of the <b>TBMETRICS</b> structure.
    uint cbSize;
    ///Type: <b>DWORD</b> Mask that determines the metric to retrieve. It can be any combination of the following:
    ///<table class="clsStd"> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td>TBMF_PAD</td> <td>Retrieve the
    ///<b>cxPad</b> and <b>cyPad</b> values.</td> </tr> <tr> <td>TBMF_BARPAD</td> <td>Retrieve the <b>cxBarPad</b> and
    ///<b>cyBarPad</b> values.</td> </tr> <tr> <td>TBMF_BUTTONSPACING</td> <td>Retrieve the <b>cxButtonSpacing</b> and
    ///<b>cyButtonSpacing</b> values.</td> </tr> </table>
    uint dwMask;
    ///Type: <b>int</b> Width of the padding inside the toolbar buttons, between the content and the edge of the button.
    int  cxPad;
    ///Type: <b>int</b> Height of the padding inside the toolbar buttons, between the content and the edge of the
    ///button.
    int  cyPad;
    ///Type: <b>int</b> Width of the toolbar. Not used.
    int  cxBarPad;
    ///Type: <b>int</b> Height of the toolbar. Not used.
    int  cyBarPad;
    ///Type: <b>int</b> Width of the space between toolbar buttons.
    int  cxButtonSpacing;
    ///Type: <b>int</b> Height of the space between toolbar buttons.
    int  cyButtonSpacing;
}

///Contains information used with the TBN_HOTITEMCHANGE notification code.
struct NMTBHOTITEM
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR hdr;
    ///Type: <b>int</b> Command identifier of the previously highlighted item.
    int   idOld;
    ///Type: <b>int</b> Command identifier of the item about to be highlighted.
    int   idNew;
    uint  dwFlags;
}

///This structure is passed to applications when they receive a TBN_SAVE notification code. It contains information
///about the button currently being saved. Applications can modify the values of the members to save additional
///information.
struct NMTBSAVE
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains additional information about the notification.
    NMHDR    hdr;
    ///Type: <b>DWORD*</b> A pointer to the data stream used to store the save information. When complete, it will
    ///contain blocks of Shell-defined information for each button, alternating with blocks defined by the application.
    ///Applications may also choose to place a block of global data at the start of <b>pData</b>. The format and length
    ///of the application-defined blocks are determined by the application. When the save starts, the Shell will pass
    ///the amount of memory it needs in <b>cbData</b>, but no memory will be allocated. You must allocate enough memory
    ///for <b>pData</b> to hold your data, plus the Shell's.
    uint*    pData;
    ///Type: <b>DWORD*</b> A pointer to the start of the unused portion of the data stream. You should load your data
    ///here, and then advance <b>pCurrent</b> to the start of the remaining unused portion. The Shell will then load the
    ///information for the next button, advance <b>pCurrent</b>, and so on.
    uint*    pCurrent;
    ///Type: <b>UINT</b> The size of the data stream. When the save starts, <b>cbData</b> will be set to the amount of
    ///data needed by the Shell. You should change it to the total amount allocated.
    uint     cbData;
    ///Type: <b>int</b> This parameter is usually the zero-based index of the button currently being saved. It is set to
    ///-1 to indicate that a save is starting.
    int      iItem;
    ///Type: <b>int</b> An estimate of the number of buttons. Because it is based on the size of the data stream, it may
    ///be incorrect. The client should update it as appropriate.
    int      cButtons;
    TBBUTTON tbButton;
}

///Allows applications to extract the information that was placed in NMTBSAVE when the toolbar state was saved. This
///structure is passed to applications when they receive a TBN_RESTORE notification code.
struct NMTBRESTORE
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR    hdr;
    ///Type: <b>DWORD*</b> Pointer to the data stream with the stored save information. It contains Shell-defined blocks
    ///of information for each button, alternating with application-defined blocks. Applications may also place a block
    ///of global data at the start of <b>pData</b>. The format and length of the application-defined blocks are
    ///determined by the application.
    uint*    pData;
    ///Type: <b>DWORD*</b> Pointer to the current block of application-defined data. After extracting the data, the
    ///application must advance <b>pCurrent</b> to the end of the block, so it is pointing to the next block of
    ///Shell-defined data.
    uint*    pCurrent;
    ///Type: <b>UINT</b> Size of <b>pData</b>.
    uint     cbData;
    ///Type: <b>int</b> Value of -1 indicates that the restore is starting, and <b>pCurrent</b> will point to the start
    ///of the data stream. Otherwise, it is the zero-based button index, and <b>pCurrent</b> will point to the current
    ///button's data.
    int      iItem;
    ///Type: <b>int</b> Estimate of the number of buttons. Because the estimate is based on the size of the data stream,
    ///it might be incorrect. The client should update it as appropriate.
    int      cButtons;
    ///Type: <b>int</b> Number of bytes needed to hold the data for each button. When the restore starts,
    ///<b>cbBytesPerRecord</b> will be set to the size of the Shell-defined data structure. You need to increment it by
    ///the size of the structure that holds the application-defined data.
    int      cbBytesPerRecord;
    TBBUTTON tbButton;
}

///Contains and receives infotip information for a toolbar item. This structure is used with the TBN_GETINFOTIP
///notification code.
struct NMTBGETINFOTIPA
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR  hdr;
    ///Type: <b>LPTSTR</b> Address of a character buffer that receives the infotip text.
    PSTR   pszText;
    ///Type: <b>int</b> Size of the buffer, in characters, at <b>pszText</b>. In most cases, the buffer will be
    ///INFOTIPSIZE characters in size, but you should always make sure that your application does not copy more than
    ///<b>cchTextMax</b> characters to the buffer at <b>pszText</b>.
    int    cchTextMax;
    ///Type: <b>int</b> The command identifier of the item for which infotip information is being requested. This member
    ///is filled in by the control before sending the notification code.
    int    iItem;
    ///Type: <b>LPARAM</b> The application-defined value associated with the item for which infotip information is being
    ///requested. This member is filled in by the control before sending the notification code.
    LPARAM lParam;
}

///Contains and receives infotip information for a toolbar item. This structure is used with the TBN_GETINFOTIP
///notification code.
struct NMTBGETINFOTIPW
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR  hdr;
    ///Type: <b>LPTSTR</b> Address of a character buffer that receives the infotip text.
    PWSTR  pszText;
    ///Type: <b>int</b> Size of the buffer, in characters, at <b>pszText</b>. In most cases, the buffer will be
    ///INFOTIPSIZE characters in size, but you should always make sure that your application does not copy more than
    ///<b>cchTextMax</b> characters to the buffer at <b>pszText</b>.
    int    cchTextMax;
    ///Type: <b>int</b> The command identifier of the item for which infotip information is being requested. This member
    ///is filled in by the control before sending the notification code.
    int    iItem;
    ///Type: <b>LPARAM</b> The application-defined value associated with the item for which infotip information is being
    ///requested. This member is filled in by the control before sending the notification code.
    LPARAM lParam;
}

///Contains and receives display information for a toolbar item. This structure is used with the TBN_GETDISPINFO
///notification code.
struct NMTBDISPINFOA
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR  hdr;
    ///Type: <b>DWORD</b> Set of flags that indicate which members of this structure are being requested. This can be
    ///one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TBNF_IMAGE"></a><a id="tbnf_image"></a><dl> <dt><b>TBNF_IMAGE</b></dt> </dl> </td> <td width="60%"> The
    ///item's image index is being requested. The image index must be placed in the <b>iImage</b> member. </td> </tr>
    ///<tr> <td width="40%"><a id="TBNF_TEXT"></a><a id="tbnf_text"></a><dl> <dt><b>TBNF_TEXT</b></dt> </dl> </td> <td
    ///width="60%"> Not currently implemented. </td> </tr> <tr> <td width="40%"><a id="TBNF_DI_SETITEM"></a><a
    ///id="tbnf_di_setitem"></a><dl> <dt><b>TBNF_DI_SETITEM</b></dt> </dl> </td> <td width="60%"> Set this flag when
    ///processing TBN_GETDISPINFO; the toolbar control will retain the supplied information and not request it again.
    ///</td> </tr> </table>
    uint   dwMask;
    ///Type: <b>int</b> Command identifier of the item for which display information is being requested. This member is
    ///filled in by the control before it sends the notification code.
    int    idCommand;
    ///Type: <b>DWORD_PTR</b> Application-defined value associated with the item for which display information is being
    ///requested. This member is filled in by the control before sending the notification code.
    size_t lParam;
    ///Type: <b>int</b> Image index for the item.
    int    iImage;
    ///Type: <b>LPTSTR</b> Pointer to a character buffer that receives the item's text.
    PSTR   pszText;
    ///Type: <b>int</b> Size of the <b>pszText</b> buffer, in characters.
    int    cchText;
}

///Contains and receives display information for a toolbar item. This structure is used with the TBN_GETDISPINFO
///notification code.
struct NMTBDISPINFOW
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR  hdr;
    ///Type: <b>DWORD</b> Set of flags that indicate which members of this structure are being requested. This can be
    ///one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TBNF_IMAGE"></a><a id="tbnf_image"></a><dl> <dt><b>TBNF_IMAGE</b></dt> </dl> </td> <td width="60%"> The
    ///item's image index is being requested. The image index must be placed in the <b>iImage</b> member. </td> </tr>
    ///<tr> <td width="40%"><a id="TBNF_TEXT"></a><a id="tbnf_text"></a><dl> <dt><b>TBNF_TEXT</b></dt> </dl> </td> <td
    ///width="60%"> Not currently implemented. </td> </tr> <tr> <td width="40%"><a id="TBNF_DI_SETITEM"></a><a
    ///id="tbnf_di_setitem"></a><dl> <dt><b>TBNF_DI_SETITEM</b></dt> </dl> </td> <td width="60%"> Set this flag when
    ///processing TBN_GETDISPINFO; the toolbar control will retain the supplied information and not request it again.
    ///</td> </tr> </table>
    uint   dwMask;
    ///Type: <b>int</b> Command identifier of the item for which display information is being requested. This member is
    ///filled in by the control before it sends the notification code.
    int    idCommand;
    ///Type: <b>DWORD_PTR</b> Application-defined value associated with the item for which display information is being
    ///requested. This member is filled in by the control before sending the notification code.
    size_t lParam;
    ///Type: <b>int</b> Image index for the item.
    int    iImage;
    ///Type: <b>LPTSTR</b> Pointer to a character buffer that receives the item's text.
    PWSTR  pszText;
    ///Type: <b>int</b> Size of the <b>pszText</b> buffer, in characters.
    int    cchText;
}

///Contains information used to process toolbar notification codes. This structure supersedes the <b>TBNOTIFY</b>
///structure.
struct NMTOOLBARA
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR    hdr;
    ///Type: <b>int</b> Command identifier of the button associated with the notification code.
    int      iItem;
    ///Type: <b>TBBUTTON</b> TBBUTTON structure that contains information about the toolbar button associated with the
    ///notification code. This member only contains valid information with the TBN_QUERYINSERT and TBN_QUERYDELETE
    ///notification codes.
    TBBUTTON tbButton;
    ///Type: <b>int</b> Count of characters in the button text.
    int      cchText;
    ///Type: <b>LPTSTR</b> Address of a character buffer that contains the button text.
    PSTR     pszText;
    ///Type: <b>RECT</b> Version 5.80. A RECT structure that defines the area covered by the button.
    RECT     rcButton;
}

///Contains information used to process toolbar notification codes. This structure supersedes the <b>TBNOTIFY</b>
///structure.
struct NMTOOLBARW
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR    hdr;
    ///Type: <b>int</b> Command identifier of the button associated with the notification code.
    int      iItem;
    ///Type: <b>TBBUTTON</b> TBBUTTON structure that contains information about the toolbar button associated with the
    ///notification code. This member only contains valid information with the TBN_QUERYINSERT and TBN_QUERYDELETE
    ///notification codes.
    TBBUTTON tbButton;
    ///Type: <b>int</b> Count of characters in the button text.
    int      cchText;
    ///Type: <b>LPTSTR</b> Address of a character buffer that contains the button text.
    PWSTR    pszText;
    ///Type: <b>RECT</b> Version 5.80. A RECT structure that defines the area covered by the button.
    RECT     rcButton;
}

///Contains information that describes rebar control characteristics.
struct REBARINFO
{
    ///Type: <b>UINT</b> Size of this structure, in bytes. Your application must fill this member before sending any
    ///messages that use the address of this structure as a parameter.
    uint       cbSize;
    ///Type: <b>UINT</b> Flag values that describe characteristics of the rebar control. Currently, rebar controls
    ///support only one value: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="RBIM_IMAGELIST"></a><a id="rbim_imagelist"></a><dl> <dt><b>RBIM_IMAGELIST</b></dt> </dl> </td> <td
    ///width="60%"> The <b>himl</b> member is valid or must be filled. </td> </tr> </table>
    uint       fMask;
    HIMAGELIST himl;
}

///Contains information that defines a band in a rebar control.
struct REBARBANDINFOA
{
    ///Type: <b>UINT</b> Size of this structure, in bytes. Your application must fill this member before sending any
    ///messages that use the address of this structure as a parameter.
    uint    cbSize;
    ///Type: <b>UINT</b> Flags that indicate which members of this structure are valid or must be filled. This value can
    ///be a combination of the following: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="RBBIM_BACKGROUND"></a><a id="rbbim_background"></a><dl> <dt><b>RBBIM_BACKGROUND</b></dt> </dl> </td> <td
    ///width="60%"> The <b>hbmBack</b> member is valid or must be set. </td> </tr> <tr> <td width="40%"><a
    ///id="RBBIM_CHILD"></a><a id="rbbim_child"></a><dl> <dt><b>RBBIM_CHILD</b></dt> </dl> </td> <td width="60%"> The
    ///<b>hwndChild</b> member is valid or must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_CHILDSIZE"></a><a
    ///id="rbbim_childsize"></a><dl> <dt><b>RBBIM_CHILDSIZE</b></dt> </dl> </td> <td width="60%"> The <b>cxMinChild</b>,
    ///<b>cyMinChild</b>, <b>cyChild</b>, <b>cyMaxChild</b>, and <b>cyIntegral</b> members are valid or must be set.
    ///</td> </tr> <tr> <td width="40%"><a id="RBBIM_COLORS"></a><a id="rbbim_colors"></a><dl>
    ///<dt><b>RBBIM_COLORS</b></dt> </dl> </td> <td width="60%"> The <b>clrFore</b> and <b>clrBack</b> members are valid
    ///or must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_HEADERSIZE"></a><a id="rbbim_headersize"></a><dl>
    ///<dt><b>RBBIM_HEADERSIZE</b></dt> </dl> </td> <td width="60%"> Version 4.71. The <b>cxHeader</b> member is valid
    ///or must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_IDEALSIZE"></a><a id="rbbim_idealsize"></a><dl>
    ///<dt><b>RBBIM_IDEALSIZE</b></dt> </dl> </td> <td width="60%"> Version 4.71. The <b>cxIdeal</b> member is valid or
    ///must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_ID"></a><a id="rbbim_id"></a><dl>
    ///<dt><b>RBBIM_ID</b></dt> </dl> </td> <td width="60%"> The <b>wID</b> member is valid or must be set. </td> </tr>
    ///<tr> <td width="40%"><a id="RBBIM_IMAGE"></a><a id="rbbim_image"></a><dl> <dt><b>RBBIM_IMAGE</b></dt> </dl> </td>
    ///<td width="60%"> The <b>iImage</b> member is valid or must be set. </td> </tr> <tr> <td width="40%"><a
    ///id="RBBIM_LPARAM"></a><a id="rbbim_lparam"></a><dl> <dt><b>RBBIM_LPARAM</b></dt> </dl> </td> <td width="60%">
    ///Version 4.71. The <b>lParam</b> member is valid or must be set. </td> </tr> <tr> <td width="40%"><a
    ///id="RBBIM_SIZE"></a><a id="rbbim_size"></a><dl> <dt><b>RBBIM_SIZE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>cx</b> member is valid or must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_STYLE"></a><a
    ///id="rbbim_style"></a><dl> <dt><b>RBBIM_STYLE</b></dt> </dl> </td> <td width="60%"> The <b>fStyle</b> member is
    ///valid or must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_TEXT"></a><a id="rbbim_text"></a><dl>
    ///<dt><b>RBBIM_TEXT</b></dt> </dl> </td> <td width="60%"> The <b>lpText</b> member is valid or must be set. </td>
    ///</tr> <tr> <td width="40%"><a id="RBBIM_CHEVRONLOCATION"></a><a id="rbbim_chevronlocation"></a><dl>
    ///<dt><b>RBBIM_CHEVRONLOCATION</b></dt> </dl> </td> <td width="60%"> The <b>rcChevronLocation</b> member is valid
    ///or must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_CHEVRONSTATE"></a><a
    ///id="rbbim_chevronstate"></a><dl> <dt><b>RBBIM_CHEVRONSTATE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>uChevronState</b> member is valid or must be set. </td> </tr> </table>
    uint    fMask;
    ///Type: <b>UINT</b> Flags that specify the band style. This value can be a combination of the following: <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="RBBS_BREAK"></a><a
    ///id="rbbs_break"></a><dl> <dt><b>RBBS_BREAK</b></dt> </dl> </td> <td width="60%"> The band is on a new line. </td>
    ///</tr> <tr> <td width="40%"><a id="RBBS_CHILDEDGE"></a><a id="rbbs_childedge"></a><dl>
    ///<dt><b>RBBS_CHILDEDGE</b></dt> </dl> </td> <td width="60%"> The band has an edge at the top and bottom of the
    ///child window. </td> </tr> <tr> <td width="40%"><a id="RBBS_FIXEDBMP"></a><a id="rbbs_fixedbmp"></a><dl>
    ///<dt><b>RBBS_FIXEDBMP</b></dt> </dl> </td> <td width="60%"> The background bitmap does not move when the band is
    ///resized. </td> </tr> <tr> <td width="40%"><a id="RBBS_FIXEDSIZE"></a><a id="rbbs_fixedsize"></a><dl>
    ///<dt><b>RBBS_FIXEDSIZE</b></dt> </dl> </td> <td width="60%"> The band can't be sized. With this style, the sizing
    ///grip is not displayed on the band. </td> </tr> <tr> <td width="40%"><a id="RBBS_GRIPPERALWAYS"></a><a
    ///id="rbbs_gripperalways"></a><dl> <dt><b>RBBS_GRIPPERALWAYS</b></dt> </dl> </td> <td width="60%"> Version 4.71.
    ///The band will always have a sizing grip, even if it is the only band in the rebar. </td> </tr> <tr> <td
    ///width="40%"><a id="RBBS_HIDDEN"></a><a id="rbbs_hidden"></a><dl> <dt><b>RBBS_HIDDEN</b></dt> </dl> </td> <td
    ///width="60%"> The band will not be visible. </td> </tr> <tr> <td width="40%"><a id="RBBS_NOGRIPPER"></a><a
    ///id="rbbs_nogripper"></a><dl> <dt><b>RBBS_NOGRIPPER</b></dt> </dl> </td> <td width="60%"> Version 4.71. The band
    ///will never have a sizing grip, even if there is more than one band in the rebar. </td> </tr> <tr> <td
    ///width="40%"><a id="RBBS_USECHEVRON"></a><a id="rbbs_usechevron"></a><dl> <dt><b>RBBS_USECHEVRON</b></dt> </dl>
    ///</td> <td width="60%"> Version 5.80. Show a chevron button if the band is smaller than <b>cxIdeal</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="RBBS_VARIABLEHEIGHT"></a><a id="rbbs_variableheight"></a><dl>
    ///<dt><b>RBBS_VARIABLEHEIGHT</b></dt> </dl> </td> <td width="60%"> Version 4.71. The band can be resized by the
    ///rebar control; <b>cyIntegral</b> and <b>cyMaxChild</b> affect how the rebar will resize the band. </td> </tr>
    ///<tr> <td width="40%"><a id="RBBS_NOVERT"></a><a id="rbbs_novert"></a><dl> <dt><b>RBBS_NOVERT</b></dt> </dl> </td>
    ///<td width="60%"> Do not show when vertical. </td> </tr> <tr> <td width="40%"><a id="RBBS_HIDETITLE"></a><a
    ///id="rbbs_hidetitle"></a><dl> <dt><b>RBBS_HIDETITLE</b></dt> </dl> </td> <td width="60%"> Keep band title hidden.
    ///</td> </tr> <tr> <td width="40%"><a id="RBBS_TOPALIGN"></a><a id="rbbs_topalign"></a><dl>
    ///<dt><b>RBBS_TOPALIGN</b></dt> </dl> </td> <td width="60%"> Keep band in top row. </td> </tr> </table>
    uint    fStyle;
    ///Type: <b>COLORREF</b> Band foreground colors.
    uint    clrFore;
    ///Type: <b>COLORREF</b> Band background colors. If <b>hbmBack</b> specifies a background bitmap, these members are
    ///ignored. By default, the band will use the background color of the rebar control set with the RB_SETBKCOLOR
    ///message. If a background color is specified here, then this background color will be used instead.
    uint    clrBack;
    ///Type: <b>LPTSTR</b> Pointer to a buffer that contains the display text for the band. If band information is being
    ///requested from the control and RBBIM_TEXT is specified in <b>fMask</b>, this member must be initialized to the
    ///address of the buffer that will receive the text.
    PSTR    lpText;
    ///Type: <b>UINT</b> Size of the buffer at <b>lpText</b>, in bytes. If information is not being requested from the
    ///control, this member is ignored.
    uint    cch;
    ///Type: <b>int</b> Zero-based index of any image that should be displayed in the band. The image list is set using
    ///the RB_SETBARINFO message.
    int     iImage;
    ///Type: <b>HWND</b> Handle to the child window contained in the band, if any.
    HWND    hwndChild;
    ///Type: <b>UINT</b> Minimum width of the child window, in pixels. The band can't be sized smaller than this value.
    uint    cxMinChild;
    ///Type: <b>UINT</b> Minimum height of the child window, in pixels. The band can't be sized smaller than this value.
    uint    cyMinChild;
    ///Type: <b>UINT</b> Length of the band, in pixels.
    uint    cx;
    ///Type: <b>HBITMAP</b> Handle to a bitmap that is used as the background for this band.
    HBITMAP hbmBack;
    ///Type: <b>UINT</b> UINT value that the control uses to identify this band for custom draw notification messages.
    uint    wID;
    ///Type: <b>UINT</b> Version 4.71. Initial height of the band, in pixels. This member is ignored unless the
    ///RBBS_VARIABLEHEIGHT style is specified.
    uint    cyChild;
    ///Type: <b>UINT</b> Version 4.71. Maximum height of the band, in pixels. This member is ignored unless the
    ///RBBS_VARIABLEHEIGHT style is specified.
    uint    cyMaxChild;
    ///Type: <b>UINT</b> Version 4.71. Step value by which the band can grow or shrink, in pixels. If the band is
    ///resized, it will be resized in steps specified by this value. This member is ignored unless the
    ///RBBS_VARIABLEHEIGHT style is specified.
    uint    cyIntegral;
    ///Type: <b>UINT</b> Version 4.71. Ideal width of the band, in pixels. If the band is maximized to the ideal width
    ///(see RB_MAXIMIZEBAND), the rebar control will attempt to make the band this width.
    uint    cxIdeal;
    ///Type: <b>LPARAM</b> Version 4.71. Application-defined value.
    LPARAM  lParam;
    ///Type: <b>UINT</b> Version 4.71. Size of the band's header, in pixels. The band header is the area between the
    ///edge of the band and the edge of the child window. This is the area where band text and images are displayed, if
    ///they are specified. If this value is specified, it will override the normal header dimensions that the control
    ///calculates for the band.
    uint    cxHeader;
    ///Type: <b>RECT</b> Version 6. Location of the chevron.
    RECT    rcChevronLocation;
    ///Type: <b>UINT</b> Version 6. A combination of the Object State Constants.
    uint    uChevronState;
}

///Contains information that defines a band in a rebar control.
struct REBARBANDINFOW
{
    ///Type: <b>UINT</b> Size of this structure, in bytes. Your application must fill this member before sending any
    ///messages that use the address of this structure as a parameter.
    uint    cbSize;
    ///Type: <b>UINT</b> Flags that indicate which members of this structure are valid or must be filled. This value can
    ///be a combination of the following: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="RBBIM_BACKGROUND"></a><a id="rbbim_background"></a><dl> <dt><b>RBBIM_BACKGROUND</b></dt> </dl> </td> <td
    ///width="60%"> The <b>hbmBack</b> member is valid or must be set. </td> </tr> <tr> <td width="40%"><a
    ///id="RBBIM_CHILD"></a><a id="rbbim_child"></a><dl> <dt><b>RBBIM_CHILD</b></dt> </dl> </td> <td width="60%"> The
    ///<b>hwndChild</b> member is valid or must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_CHILDSIZE"></a><a
    ///id="rbbim_childsize"></a><dl> <dt><b>RBBIM_CHILDSIZE</b></dt> </dl> </td> <td width="60%"> The <b>cxMinChild</b>,
    ///<b>cyMinChild</b>, <b>cyChild</b>, <b>cyMaxChild</b>, and <b>cyIntegral</b> members are valid or must be set.
    ///</td> </tr> <tr> <td width="40%"><a id="RBBIM_COLORS"></a><a id="rbbim_colors"></a><dl>
    ///<dt><b>RBBIM_COLORS</b></dt> </dl> </td> <td width="60%"> The <b>clrFore</b> and <b>clrBack</b> members are valid
    ///or must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_HEADERSIZE"></a><a id="rbbim_headersize"></a><dl>
    ///<dt><b>RBBIM_HEADERSIZE</b></dt> </dl> </td> <td width="60%"> Version 4.71. The <b>cxHeader</b> member is valid
    ///or must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_IDEALSIZE"></a><a id="rbbim_idealsize"></a><dl>
    ///<dt><b>RBBIM_IDEALSIZE</b></dt> </dl> </td> <td width="60%"> Version 4.71. The <b>cxIdeal</b> member is valid or
    ///must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_ID"></a><a id="rbbim_id"></a><dl>
    ///<dt><b>RBBIM_ID</b></dt> </dl> </td> <td width="60%"> The <b>wID</b> member is valid or must be set. </td> </tr>
    ///<tr> <td width="40%"><a id="RBBIM_IMAGE"></a><a id="rbbim_image"></a><dl> <dt><b>RBBIM_IMAGE</b></dt> </dl> </td>
    ///<td width="60%"> The <b>iImage</b> member is valid or must be set. </td> </tr> <tr> <td width="40%"><a
    ///id="RBBIM_LPARAM"></a><a id="rbbim_lparam"></a><dl> <dt><b>RBBIM_LPARAM</b></dt> </dl> </td> <td width="60%">
    ///Version 4.71. The <b>lParam</b> member is valid or must be set. </td> </tr> <tr> <td width="40%"><a
    ///id="RBBIM_SIZE"></a><a id="rbbim_size"></a><dl> <dt><b>RBBIM_SIZE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>cx</b> member is valid or must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_STYLE"></a><a
    ///id="rbbim_style"></a><dl> <dt><b>RBBIM_STYLE</b></dt> </dl> </td> <td width="60%"> The <b>fStyle</b> member is
    ///valid or must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_TEXT"></a><a id="rbbim_text"></a><dl>
    ///<dt><b>RBBIM_TEXT</b></dt> </dl> </td> <td width="60%"> The <b>lpText</b> member is valid or must be set. </td>
    ///</tr> <tr> <td width="40%"><a id="RBBIM_CHEVRONLOCATION"></a><a id="rbbim_chevronlocation"></a><dl>
    ///<dt><b>RBBIM_CHEVRONLOCATION</b></dt> </dl> </td> <td width="60%"> The <b>rcChevronLocation</b> member is valid
    ///or must be set. </td> </tr> <tr> <td width="40%"><a id="RBBIM_CHEVRONSTATE"></a><a
    ///id="rbbim_chevronstate"></a><dl> <dt><b>RBBIM_CHEVRONSTATE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>uChevronState</b> member is valid or must be set. </td> </tr> </table>
    uint    fMask;
    ///Type: <b>UINT</b> Flags that specify the band style. This value can be a combination of the following: <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="RBBS_BREAK"></a><a
    ///id="rbbs_break"></a><dl> <dt><b>RBBS_BREAK</b></dt> </dl> </td> <td width="60%"> The band is on a new line. </td>
    ///</tr> <tr> <td width="40%"><a id="RBBS_CHILDEDGE"></a><a id="rbbs_childedge"></a><dl>
    ///<dt><b>RBBS_CHILDEDGE</b></dt> </dl> </td> <td width="60%"> The band has an edge at the top and bottom of the
    ///child window. </td> </tr> <tr> <td width="40%"><a id="RBBS_FIXEDBMP"></a><a id="rbbs_fixedbmp"></a><dl>
    ///<dt><b>RBBS_FIXEDBMP</b></dt> </dl> </td> <td width="60%"> The background bitmap does not move when the band is
    ///resized. </td> </tr> <tr> <td width="40%"><a id="RBBS_FIXEDSIZE"></a><a id="rbbs_fixedsize"></a><dl>
    ///<dt><b>RBBS_FIXEDSIZE</b></dt> </dl> </td> <td width="60%"> The band can't be sized. With this style, the sizing
    ///grip is not displayed on the band. </td> </tr> <tr> <td width="40%"><a id="RBBS_GRIPPERALWAYS"></a><a
    ///id="rbbs_gripperalways"></a><dl> <dt><b>RBBS_GRIPPERALWAYS</b></dt> </dl> </td> <td width="60%"> Version 4.71.
    ///The band will always have a sizing grip, even if it is the only band in the rebar. </td> </tr> <tr> <td
    ///width="40%"><a id="RBBS_HIDDEN"></a><a id="rbbs_hidden"></a><dl> <dt><b>RBBS_HIDDEN</b></dt> </dl> </td> <td
    ///width="60%"> The band will not be visible. </td> </tr> <tr> <td width="40%"><a id="RBBS_NOGRIPPER"></a><a
    ///id="rbbs_nogripper"></a><dl> <dt><b>RBBS_NOGRIPPER</b></dt> </dl> </td> <td width="60%"> Version 4.71. The band
    ///will never have a sizing grip, even if there is more than one band in the rebar. </td> </tr> <tr> <td
    ///width="40%"><a id="RBBS_USECHEVRON"></a><a id="rbbs_usechevron"></a><dl> <dt><b>RBBS_USECHEVRON</b></dt> </dl>
    ///</td> <td width="60%"> Version 5.80. Show a chevron button if the band is smaller than <b>cxIdeal</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="RBBS_VARIABLEHEIGHT"></a><a id="rbbs_variableheight"></a><dl>
    ///<dt><b>RBBS_VARIABLEHEIGHT</b></dt> </dl> </td> <td width="60%"> Version 4.71. The band can be resized by the
    ///rebar control; <b>cyIntegral</b> and <b>cyMaxChild</b> affect how the rebar will resize the band. </td> </tr>
    ///<tr> <td width="40%"><a id="RBBS_NOVERT"></a><a id="rbbs_novert"></a><dl> <dt><b>RBBS_NOVERT</b></dt> </dl> </td>
    ///<td width="60%"> Do not show when vertical. </td> </tr> <tr> <td width="40%"><a id="RBBS_HIDETITLE"></a><a
    ///id="rbbs_hidetitle"></a><dl> <dt><b>RBBS_HIDETITLE</b></dt> </dl> </td> <td width="60%"> Keep band title hidden.
    ///</td> </tr> <tr> <td width="40%"><a id="RBBS_TOPALIGN"></a><a id="rbbs_topalign"></a><dl>
    ///<dt><b>RBBS_TOPALIGN</b></dt> </dl> </td> <td width="60%"> Keep band in top row. </td> </tr> </table>
    uint    fStyle;
    ///Type: <b>COLORREF</b> Band foreground colors.
    uint    clrFore;
    ///Type: <b>COLORREF</b> Band background colors. If <b>hbmBack</b> specifies a background bitmap, these members are
    ///ignored. By default, the band will use the background color of the rebar control set with the RB_SETBKCOLOR
    ///message. If a background color is specified here, then this background color will be used instead.
    uint    clrBack;
    ///Type: <b>LPTSTR</b> Pointer to a buffer that contains the display text for the band. If band information is being
    ///requested from the control and RBBIM_TEXT is specified in <b>fMask</b>, this member must be initialized to the
    ///address of the buffer that will receive the text.
    PWSTR   lpText;
    ///Type: <b>UINT</b> Size of the buffer at <b>lpText</b>, in bytes. If information is not being requested from the
    ///control, this member is ignored.
    uint    cch;
    ///Type: <b>int</b> Zero-based index of any image that should be displayed in the band. The image list is set using
    ///the RB_SETBARINFO message.
    int     iImage;
    ///Type: <b>HWND</b> Handle to the child window contained in the band, if any.
    HWND    hwndChild;
    ///Type: <b>UINT</b> Minimum width of the child window, in pixels. The band can't be sized smaller than this value.
    uint    cxMinChild;
    ///Type: <b>UINT</b> Minimum height of the child window, in pixels. The band can't be sized smaller than this value.
    uint    cyMinChild;
    ///Type: <b>UINT</b> Length of the band, in pixels.
    uint    cx;
    ///Type: <b>HBITMAP</b> Handle to a bitmap that is used as the background for this band.
    HBITMAP hbmBack;
    ///Type: <b>UINT</b> UINT value that the control uses to identify this band for custom draw notification messages.
    uint    wID;
    ///Type: <b>UINT</b> Version 4.71. Initial height of the band, in pixels. This member is ignored unless the
    ///RBBS_VARIABLEHEIGHT style is specified.
    uint    cyChild;
    ///Type: <b>UINT</b> Version 4.71. Maximum height of the band, in pixels. This member is ignored unless the
    ///RBBS_VARIABLEHEIGHT style is specified.
    uint    cyMaxChild;
    ///Type: <b>UINT</b> Version 4.71. Step value by which the band can grow or shrink, in pixels. If the band is
    ///resized, it will be resized in steps specified by this value. This member is ignored unless the
    ///RBBS_VARIABLEHEIGHT style is specified.
    uint    cyIntegral;
    ///Type: <b>UINT</b> Version 4.71. Ideal width of the band, in pixels. If the band is maximized to the ideal width
    ///(see RB_MAXIMIZEBAND), the rebar control will attempt to make the band this width.
    uint    cxIdeal;
    ///Type: <b>LPARAM</b> Version 4.71. Application-defined value.
    LPARAM  lParam;
    ///Type: <b>UINT</b> Version 4.71. Size of the band's header, in pixels. The band header is the area between the
    ///edge of the band and the edge of the child window. This is the area where band text and images are displayed, if
    ///they are specified. If this value is specified, it will override the normal header dimensions that the control
    ///calculates for the band.
    uint    cxHeader;
    ///Type: <b>RECT</b> Version 6. Location of the chevron.
    RECT    rcChevronLocation;
    ///Type: <b>UINT</b> Version 6. A combination of the Object State Constants.
    uint    uChevronState;
}

///Contains information used in handling the RBN_CHILDSIZE notification code.
struct NMREBARCHILDSIZE
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR hdr;
    ///Type: <b>UINT</b> Zero-based index of the band affected by the notification. This will be -1 if no band is
    ///affected.
    uint  uBand;
    ///Type: <b>UINT</b> Application-defined identifier of the band.
    uint  wID;
    ///Type: <b>RECT</b> RECT structure that contains the new size of the child window. This member can be changed
    ///during the notification to modify the child window's position and size.
    RECT  rcChild;
    RECT  rcBand;
}

///Contains information used in handling various rebar notifications.
struct NMREBAR
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR  hdr;
    ///Type: <b>DWORD</b> Set of flags that define which members of this structure contain valid information. This can
    ///be one or more of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="RBNM_ID"></a><a id="rbnm_id"></a><dl> <dt><b>RBNM_ID</b></dt> </dl> </td> <td width="60%"> The
    ///<b>wID</b> member contains valid information. </td> </tr> <tr> <td width="40%"><a id="RBNM_LPARAM"></a><a
    ///id="rbnm_lparam"></a><dl> <dt><b>RBNM_LPARAM</b></dt> </dl> </td> <td width="60%"> The <b>lParam</b> member
    ///contains valid information. </td> </tr> <tr> <td width="40%"><a id="RBNM_STYLE"></a><a id="rbnm_style"></a><dl>
    ///<dt><b>RBNM_STYLE</b></dt> </dl> </td> <td width="60%"> The <b>fStyle</b> member contains valid information.
    ///</td> </tr> </table>
    uint   dwMask;
    ///Type: <b>UINT</b> Zero-based index of the band affected by the notification. This will be -1 if no band is
    ///affected.
    uint   uBand;
    ///Type: <b>UINT</b> The style of the band. This is one or more of the RBBS_ styles detailed in the <b>fStyle</b>
    ///member of the REBARBANDINFO structure. This member is only valid if <b>dwMask</b> contains RBNM_STYLE.
    uint   fStyle;
    ///Type: <b>UINT</b> Application-defined identifier of the band. This member is only valid if <b>dwMask</b> contains
    ///RBNM_ID.
    uint   wID;
    LPARAM lParam;
}

///Contains information used in handling the RBN_AUTOSIZE notification codes.
struct NMRBAUTOSIZE
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR hdr;
    ///Type: <b>BOOL</b> Member that indicates if the size or layout of the rebar control has changed (nonzero if a
    ///change occurred or zero otherwise).
    BOOL  fChanged;
    ///Type: <b>RECT</b> RECT structure that contains the rectangle to which the rebar control tried to size itself.
    RECT  rcTarget;
    RECT  rcActual;
}

///Contains information used in handling the RBN_CHEVRONPUSHED notification code.
struct NMREBARCHEVRON
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR  hdr;
    ///Type: <b>UINT</b> Index of the band sending the notification.
    uint   uBand;
    ///Type: <b>UINT</b> Application-defined identifier for the band.
    uint   wID;
    ///Type: <b>LPARAM</b> Application-defined value associated with the band.
    LPARAM lParam;
    ///Type: <b>RECT</b> RECT structure that defines the area covered by the chevron.
    RECT   rc;
    LPARAM lParamNM;
}

///Contains information used to handle an RBN_SPLITTERDRAG notification code.
struct NMREBARSPLITTER
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains additional information about this notification.
    NMHDR hdr;
    RECT  rcSizing;
}

///Contains information used with the RBN_AUTOBREAK notification code.
struct NMREBARAUTOBREAK
{
    ///Type: <b>NMHDR</b> NMHDR structure that provides additional information about this notification code.
    NMHDR  hdr;
    ///Type: <b>UINT</b> Zero-based index of the band affected by the notification. This is -1 if no band is affected.
    uint   uBand;
    ///Type: <b>UINT</b> Application-defined ID of the band.
    uint   wID;
    ///Type: <b>LPARAM</b> Application-defined value from the <b>lParam</b> member of the REBARBANDINFO structure that
    ///defines the rebar band.
    LPARAM lParam;
    ///Type: <b>UINT</b> ID of the message.
    uint   uMsg;
    ///Type: <b>UINT</b> Style of the specified band.
    uint   fStyleCurrent;
    BOOL   fAutoBreak;
}

///Contains information specific to a hit test operation. This structure is used with the RB_HITTEST message.
struct RBHITTESTINFO
{
    ///Type: <b>POINT</b> POINT structure that describes the point to be hit tested, in client coordinates.
    POINT pt;
    ///Type: <b>UINT</b> Member that receives a flag value indicating the rebar band's component located at the point
    ///described by <b>pt</b>. This member will be one of the following: <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="RBHT_CAPTION"></a><a id="rbht_caption"></a><dl> <dt><b>RBHT_CAPTION</b></dt>
    ///</dl> </td> <td width="60%"> The point was in the rebar band's caption. </td> </tr> <tr> <td width="40%"><a
    ///id="RBHT_CHEVRON"></a><a id="rbht_chevron"></a><dl> <dt><b>RBHT_CHEVRON</b></dt> </dl> </td> <td width="60%"> The
    ///point was in the rebar band's chevron (version 5.80 and greater). </td> </tr> <tr> <td width="40%"><a
    ///id="RBHT_CLIENT"></a><a id="rbht_client"></a><dl> <dt><b>RBHT_CLIENT</b></dt> </dl> </td> <td width="60%"> The
    ///point was in the rebar band's client area. </td> </tr> <tr> <td width="40%"><a id="RBHT_GRABBER"></a><a
    ///id="rbht_grabber"></a><dl> <dt><b>RBHT_GRABBER</b></dt> </dl> </td> <td width="60%"> The point was in the rebar
    ///band's gripper. </td> </tr> <tr> <td width="40%"><a id="RBHT_NOWHERE"></a><a id="rbht_nowhere"></a><dl>
    ///<dt><b>RBHT_NOWHERE</b></dt> </dl> </td> <td width="60%"> The point was not in a rebar band. </td> </tr> <tr> <td
    ///width="40%"><a id="RBHT_SPLITTER"></a><a id="rbht_splitter"></a><dl> <dt><b>RBHT_SPLITTER</b></dt> </dl> </td>
    ///<td width="60%"> The point was in the rebar band's splitter. </td> </tr> </table>
    uint  flags;
    int   iBand;
}

///The <b>TOOLINFO</b> structure contains information about a tool in a tooltip control.
struct TTTOOLINFOA
{
    ///Type: <b>UINT</b> Size of this structure, in bytes. This member must be specified.
    uint      cbSize;
    ///Type: <b>UINT</b> Flags that control the tooltip display. This member can be a combination of the following
    ///values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TTF_ABSOLUTE"></a><a
    ///id="ttf_absolute"></a><dl> <dt><b>TTF_ABSOLUTE</b></dt> </dl> </td> <td width="60%"> Positions the tooltip window
    ///at the same coordinates provided by TTM_TRACKPOSITION. This flag must be used with the TTF_TRACK flag. </td>
    ///</tr> <tr> <td width="40%"><a id="TTF_CENTERTIP"></a><a id="ttf_centertip"></a><dl> <dt><b>TTF_CENTERTIP</b></dt>
    ///</dl> </td> <td width="60%"> Centers the tooltip window below the tool specified by the <b>uId</b> member. </td>
    ///</tr> <tr> <td width="40%"><a id="TTF_IDISHWND"></a><a id="ttf_idishwnd"></a><dl> <dt><b>TTF_IDISHWND</b></dt>
    ///</dl> </td> <td width="60%"> Indicates that the <b>uId</b> member is the window handle to the tool. If this flag
    ///is not set, <b>uId</b> is the tool's identifier. </td> </tr> <tr> <td width="40%"><a id="TTF_PARSELINKS"></a><a
    ///id="ttf_parselinks"></a><dl> <dt><b>TTF_PARSELINKS</b></dt> </dl> </td> <td width="60%"> Version 6.0 and later.
    ///Indicates that links in the tooltip text should be parsed. Note that Comctl32.dll version 6 is not
    ///redistributable but it is included in Windows or later. To use Comctl32.dll version 6, specify it in a manifest.
    ///For more information on manifests, see Enabling Visual Styles. </td> </tr> <tr> <td width="40%"><a
    ///id="TTF_RTLREADING"></a><a id="ttf_rtlreading"></a><dl> <dt><b>TTF_RTLREADING</b></dt> </dl> </td> <td
    ///width="60%"> Indicates that the tooltip text will be displayed in the opposite direction to the text in the
    ///parent window. </td> </tr> <tr> <td width="40%"><a id="TTF_SUBCLASS"></a><a id="ttf_subclass"></a><dl>
    ///<dt><b>TTF_SUBCLASS</b></dt> </dl> </td> <td width="60%"> Indicates that the tooltip control should subclass the
    ///tool's window to intercept messages, such as WM_MOUSEMOVE. If this flag is not set, you must use the
    ///TTM_RELAYEVENT message to forward messages to the tooltip control. For a list of messages that a tooltip control
    ///processes, see TTM_RELAYEVENT. </td> </tr> <tr> <td width="40%"><a id="TTF_TRACK"></a><a id="ttf_track"></a><dl>
    ///<dt><b>TTF_TRACK</b></dt> </dl> </td> <td width="60%"> Positions the tooltip window next to the tool to which it
    ///corresponds and moves the window according to coordinates supplied by the TTM_TRACKPOSITION messages. You must
    ///activate this type of tool using the TTM_TRACKACTIVATE message. </td> </tr> <tr> <td width="40%"><a
    ///id="TTF_TRANSPARENT"></a><a id="ttf_transparent"></a><dl> <dt><b>TTF_TRANSPARENT</b></dt> </dl> </td> <td
    ///width="60%"> Causes the tooltip control to forward mouse event messages to the parent window. This is limited to
    ///mouse events that occur within the bounds of the tooltip window. </td> </tr> </table>
    uint      uFlags;
    ///Type: <b>HWND</b> Handle to the window that contains the tool. If <b>lpszText</b> includes the LPSTR_TEXTCALLBACK
    ///value, this member identifies the window that receives the TTN_GETDISPINFO notification codes.
    HWND      hwnd;
    ///Type: <b>UINT_PTR</b> Application-defined identifier of the tool. If <b>uFlags</b> includes the TTF_IDISHWND
    ///flag, <b>uId</b> must specify the window handle to the tool.
    size_t    uId;
    ///Type: <b>RECT</b> The bounding rectangle coordinates of the tool. The coordinates are relative to the upper-left
    ///corner of the client area of the window identified by <b>hwnd</b>. If <b>uFlags</b> includes the TTF_IDISHWND
    ///flag, this member is ignored.
    RECT      rect;
    ///Type: <b>HINSTANCE</b> Handle to the instance that contains the string resource for the tool. If <b>lpszText</b>
    ///specifies the identifier of a string resource, this member is used.
    HINSTANCE hinst;
    ///Type: <b>LPTSTR</b> Pointer to the buffer that contains the text for the tool, or identifier of the string
    ///resource that contains the text. This member is sometimes used to return values. If you need to examine the
    ///returned value, must point to a valid buffer of sufficient size. Otherwise, it can be set to <b>NULL</b>. If
    ///<b>lpszText</b> is set to LPSTR_TEXTCALLBACK, the control sends the TTN_GETDISPINFO notification code to the
    ///owner window to retrieve the text.
    PSTR      lpszText;
    ///Type: <b>LPARAM</b> <b>Version 4.70 and later</b>. A 32-bit application-defined value that is associated with the
    ///tool.
    LPARAM    lParam;
    ///Type: <b>void*</b> Reserved. Must be set to <b>NULL</b>.
    void*     lpReserved;
}

///The <b>TOOLINFO</b> structure contains information about a tool in a tooltip control.
struct TTTOOLINFOW
{
    ///Type: <b>UINT</b> Size of this structure, in bytes. This member must be specified.
    uint      cbSize;
    ///Type: <b>UINT</b> Flags that control the tooltip display. This member can be a combination of the following
    ///values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TTF_ABSOLUTE"></a><a
    ///id="ttf_absolute"></a><dl> <dt><b>TTF_ABSOLUTE</b></dt> </dl> </td> <td width="60%"> Positions the tooltip window
    ///at the same coordinates provided by TTM_TRACKPOSITION. This flag must be used with the TTF_TRACK flag. </td>
    ///</tr> <tr> <td width="40%"><a id="TTF_CENTERTIP"></a><a id="ttf_centertip"></a><dl> <dt><b>TTF_CENTERTIP</b></dt>
    ///</dl> </td> <td width="60%"> Centers the tooltip window below the tool specified by the <b>uId</b> member. </td>
    ///</tr> <tr> <td width="40%"><a id="TTF_IDISHWND"></a><a id="ttf_idishwnd"></a><dl> <dt><b>TTF_IDISHWND</b></dt>
    ///</dl> </td> <td width="60%"> Indicates that the <b>uId</b> member is the window handle to the tool. If this flag
    ///is not set, <b>uId</b> is the tool's identifier. </td> </tr> <tr> <td width="40%"><a id="TTF_PARSELINKS"></a><a
    ///id="ttf_parselinks"></a><dl> <dt><b>TTF_PARSELINKS</b></dt> </dl> </td> <td width="60%"> Version 6.0 and later.
    ///Indicates that links in the tooltip text should be parsed. Note that Comctl32.dll version 6 is not
    ///redistributable but it is included in Windows or later. To use Comctl32.dll version 6, specify it in a manifest.
    ///For more information on manifests, see Enabling Visual Styles. </td> </tr> <tr> <td width="40%"><a
    ///id="TTF_RTLREADING"></a><a id="ttf_rtlreading"></a><dl> <dt><b>TTF_RTLREADING</b></dt> </dl> </td> <td
    ///width="60%"> Indicates that the tooltip text will be displayed in the opposite direction to the text in the
    ///parent window. </td> </tr> <tr> <td width="40%"><a id="TTF_SUBCLASS"></a><a id="ttf_subclass"></a><dl>
    ///<dt><b>TTF_SUBCLASS</b></dt> </dl> </td> <td width="60%"> Indicates that the tooltip control should subclass the
    ///tool's window to intercept messages, such as WM_MOUSEMOVE. If this flag is not set, you must use the
    ///TTM_RELAYEVENT message to forward messages to the tooltip control. For a list of messages that a tooltip control
    ///processes, see TTM_RELAYEVENT. </td> </tr> <tr> <td width="40%"><a id="TTF_TRACK"></a><a id="ttf_track"></a><dl>
    ///<dt><b>TTF_TRACK</b></dt> </dl> </td> <td width="60%"> Positions the tooltip window next to the tool to which it
    ///corresponds and moves the window according to coordinates supplied by the TTM_TRACKPOSITION messages. You must
    ///activate this type of tool using the TTM_TRACKACTIVATE message. </td> </tr> <tr> <td width="40%"><a
    ///id="TTF_TRANSPARENT"></a><a id="ttf_transparent"></a><dl> <dt><b>TTF_TRANSPARENT</b></dt> </dl> </td> <td
    ///width="60%"> Causes the tooltip control to forward mouse event messages to the parent window. This is limited to
    ///mouse events that occur within the bounds of the tooltip window. </td> </tr> </table>
    uint      uFlags;
    ///Type: <b>HWND</b> Handle to the window that contains the tool. If <b>lpszText</b> includes the LPSTR_TEXTCALLBACK
    ///value, this member identifies the window that receives the TTN_GETDISPINFO notification codes.
    HWND      hwnd;
    ///Type: <b>UINT_PTR</b> Application-defined identifier of the tool. If <b>uFlags</b> includes the TTF_IDISHWND
    ///flag, <b>uId</b> must specify the window handle to the tool.
    size_t    uId;
    ///Type: <b>RECT</b> The bounding rectangle coordinates of the tool. The coordinates are relative to the upper-left
    ///corner of the client area of the window identified by <b>hwnd</b>. If <b>uFlags</b> includes the TTF_IDISHWND
    ///flag, this member is ignored.
    RECT      rect;
    ///Type: <b>HINSTANCE</b> Handle to the instance that contains the string resource for the tool. If <b>lpszText</b>
    ///specifies the identifier of a string resource, this member is used.
    HINSTANCE hinst;
    ///Type: <b>LPTSTR</b> Pointer to the buffer that contains the text for the tool, or identifier of the string
    ///resource that contains the text. This member is sometimes used to return values. If you need to examine the
    ///returned value, must point to a valid buffer of sufficient size. Otherwise, it can be set to <b>NULL</b>. If
    ///<b>lpszText</b> is set to LPSTR_TEXTCALLBACK, the control sends the TTN_GETDISPINFO notification code to the
    ///owner window to retrieve the text.
    PWSTR     lpszText;
    ///Type: <b>LPARAM</b> <b>Version 4.70 and later</b>. A 32-bit application-defined value that is associated with the
    ///tool.
    LPARAM    lParam;
    ///Type: <b>void*</b> Reserved. Must be set to <b>NULL</b>.
    void*     lpReserved;
}

///Provides information about the title of a tooltip control.
struct TTGETTITLE
{
    ///Type: <b>DWORD</b> <b>DWORD</b> that specifies size of structure. Set to sizeof(TTGETTITLE).
    uint  dwSize;
    ///Type: <b>UINT</b> <b>UINT</b> that specifies the tooltip icon.
    uint  uTitleBitmap;
    ///Type: <b>UINT</b> <b>UINT</b> that specifies the number of characters in the title.
    uint  cch;
    PWSTR pszTitle;
}

///Contains information that a tooltip control uses to determine whether a point is in the bounding rectangle of the
///specified tool. If the point is in the rectangle, the structure receives information about the tool.
struct TTHITTESTINFOA
{
    ///Type: <b>HWND</b> Handle to the tool or window with the specified tool.
    HWND        hwnd;
    ///Type: <b>POINT</b> Client coordinates of the point to test.
    POINT       pt;
    ///Type: <b>TOOLINFO</b> TOOLINFO structure. If the point specified by <b>pt</b> is in the tool specified by
    ///<b>hwnd</b>, this structure receives information about the tool. The <b>cbSize</b> member of this structure must
    ///be filled in before sending this message.
    TTTOOLINFOA ti;
}

///Contains information that a tooltip control uses to determine whether a point is in the bounding rectangle of the
///specified tool. If the point is in the rectangle, the structure receives information about the tool.
struct TTHITTESTINFOW
{
    ///Type: <b>HWND</b> Handle to the tool or window with the specified tool.
    HWND        hwnd;
    ///Type: <b>POINT</b> Client coordinates of the point to test.
    POINT       pt;
    ///Type: <b>TOOLINFO</b> TOOLINFO structure. If the point specified by <b>pt</b> is in the tool specified by
    ///<b>hwnd</b>, this structure receives information about the tool. The <b>cbSize</b> member of this structure must
    ///be filled in before sending this message.
    TTTOOLINFOW ti;
}

///Contains information used in handling the TTN_GETDISPINFO notification code. This structure supersedes the
///<b>TOOLTIPTEXT</b> structure.
struct NMTTDISPINFOA
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR     hdr;
    ///Type: <b>LPTSTR</b> Pointer to a null-terminated string that will be displayed as the tooltip text. If
    ///<b>hinst</b> specifies an instance handle, this member must be the identifier of a string resource.
    PSTR      lpszText;
    ///Type: <b>TCHAR</b> Buffer that receives the tooltip text. An application can copy the text to this buffer instead
    ///of specifying a string address or string resource. For tooltip text that exceeds 80 <b>TCHAR</b><b>s</b>, see
    ///comments in the remarks section of this document.
    byte[80]  szText;
    ///Type: <b>HINSTANCE</b> Handle to the instance that contains a string resource to be used as the tooltip text. If
    ///<b>lpszText</b> is the address of the tooltip text string, this member must be <b>NULL</b>.
    HINSTANCE hinst;
    ///Type: <b>UINT</b> Flags that indicates how to interpret the <b>idFrom</b> member of the included NMHDR structure.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TTF_IDISHWND"></a><a
    ///id="ttf_idishwnd"></a><dl> <dt><b>TTF_IDISHWND</b></dt> </dl> </td> <td width="60%"> If this flag is set,
    ///<b>idFrom</b> is the tool's handle. Otherwise, it is the tool's identifier. </td> </tr> <tr> <td width="40%"><a
    ///id="TTF_RTLREADING"></a><a id="ttf_rtlreading"></a><dl> <dt><b>TTF_RTLREADING</b></dt> </dl> </td> <td
    ///width="60%"> Windows can be <i>mirrored</i> to display languages such as Hebrew or Arabic that read right-to-left
    ///(RTL). Normally, tooltip text is read in same direction as the text in its parent window. To have a tooltip read
    ///in the opposite direction from its parent window, add the TTF_RTLREADING flag to the <b>uFlags</b> member when
    ///processing the notification. </td> </tr> <tr> <td width="40%"><a id="TTF_DI_SETITEM"></a><a
    ///id="ttf_di_setitem"></a><dl> <dt><b>TTF_DI_SETITEM</b></dt> </dl> </td> <td width="60%"> Version 4.70. If you add
    ///this flag to <b>uFlags</b> while processing the notification, the tooltip control will retain the supplied
    ///information and not request it again. </td> </tr> </table>
    uint      uFlags;
    ///Type: <b>LPARAM</b> Version 4.70. Application-defined data associated with the tool.
    LPARAM    lParam;
}

///Contains information used in handling the TTN_GETDISPINFO notification code. This structure supersedes the
///<b>TOOLTIPTEXT</b> structure.
struct NMTTDISPINFOW
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR      hdr;
    ///Type: <b>LPTSTR</b> Pointer to a null-terminated string that will be displayed as the tooltip text. If
    ///<b>hinst</b> specifies an instance handle, this member must be the identifier of a string resource.
    PWSTR      lpszText;
    ///Type: <b>TCHAR</b> Buffer that receives the tooltip text. An application can copy the text to this buffer instead
    ///of specifying a string address or string resource. For tooltip text that exceeds 80 <b>TCHAR</b><b>s</b>, see
    ///comments in the remarks section of this document.
    ushort[80] szText;
    ///Type: <b>HINSTANCE</b> Handle to the instance that contains a string resource to be used as the tooltip text. If
    ///<b>lpszText</b> is the address of the tooltip text string, this member must be <b>NULL</b>.
    HINSTANCE  hinst;
    ///Type: <b>UINT</b> Flags that indicates how to interpret the <b>idFrom</b> member of the included NMHDR structure.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TTF_IDISHWND"></a><a
    ///id="ttf_idishwnd"></a><dl> <dt><b>TTF_IDISHWND</b></dt> </dl> </td> <td width="60%"> If this flag is set,
    ///<b>idFrom</b> is the tool's handle. Otherwise, it is the tool's identifier. </td> </tr> <tr> <td width="40%"><a
    ///id="TTF_RTLREADING"></a><a id="ttf_rtlreading"></a><dl> <dt><b>TTF_RTLREADING</b></dt> </dl> </td> <td
    ///width="60%"> Windows can be <i>mirrored</i> to display languages such as Hebrew or Arabic that read right-to-left
    ///(RTL). Normally, tooltip text is read in same direction as the text in its parent window. To have a tooltip read
    ///in the opposite direction from its parent window, add the TTF_RTLREADING flag to the <b>uFlags</b> member when
    ///processing the notification. </td> </tr> <tr> <td width="40%"><a id="TTF_DI_SETITEM"></a><a
    ///id="ttf_di_setitem"></a><dl> <dt><b>TTF_DI_SETITEM</b></dt> </dl> </td> <td width="60%"> Version 4.70. If you add
    ///this flag to <b>uFlags</b> while processing the notification, the tooltip control will retain the supplied
    ///information and not request it again. </td> </tr> </table>
    uint       uFlags;
    ///Type: <b>LPARAM</b> Version 4.70. Application-defined data associated with the tool.
    LPARAM     lParam;
}

///Contains information about a trackbar change notification. This message is sent with the TRBN_THUMBPOSCHANGING
///notification.
struct NMTRBTHUMBPOSCHANGING
{
    ///Type: <b>NMHDR</b> A NMHDR structure that describes the notification.
    NMHDR hdr;
    ///Type: <b>DWORD</b> Position on trackbar.
    uint  dwPos;
    int   nReason;
}

///Contains information about a drag event. The pointer to <b>DRAGLISTINFO</b> is passed as the <i>lParam</i> parameter
///of the drag list message.
struct DRAGLISTINFO
{
    ///Type: <b>UINT</b> The notification code that specifies the type of drag event. This member can be one of the
    ///following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="DL_BEGINDRAG"></a><a id="dl_begindrag"></a><dl> <dt><b>DL_BEGINDRAG</b></dt> </dl> </td> <td width="60%"> The
    ///user has clicked the left mouse button on a list item. </td> </tr> <tr> <td width="40%"><a
    ///id="DL_CANCELDRAG"></a><a id="dl_canceldrag"></a><dl> <dt><b>DL_CANCELDRAG</b></dt> </dl> </td> <td width="60%">
    ///The user has canceled the drag operation by clicking the right mouse button or pressing the ESC key. </td> </tr>
    ///<tr> <td width="40%"><a id="DL_DRAGGING"></a><a id="dl_dragging"></a><dl> <dt><b>DL_DRAGGING</b></dt> </dl> </td>
    ///<td width="60%"> The user has moved the mouse while dragging an item. </td> </tr> <tr> <td width="40%"><a
    ///id="DL_DROPPED"></a><a id="dl_dropped"></a><dl> <dt><b>DL_DROPPED</b></dt> </dl> </td> <td width="60%"> The user
    ///has released the left mouse button, completing a drag operation. </td> </tr> </table>
    uint  uNotification;
    ///Type: <b>HWND</b> A handle to the drag list box.
    HWND  hWnd;
    POINT ptCursor;
}

///Contains acceleration information for an up-down control.
struct UDACCEL
{
    ///Type: <b>UINT</b> Amount of elapsed time, in seconds, before the position change increment specified by
    ///<b>nInc</b> is used.
    uint nSec;
    uint nInc;
}

///Contains information specific to up-down control notification messages. It is identical to and replaces the
///<b>NM_UPDOWN</b> structure.
struct NMUPDOWN
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR hdr;
    ///Type: <b>int</b> Signed integer value that represents the up-down control's current position.
    int   iPos;
    ///Type: <b>int</b> Signed integer value that represents the proposed change in the up-down control's position.
    int   iDelta;
}

///Contains information about the high and low limits of a progress bar control. This structure is used with the
///PBM_GETRANGE message.
struct PBRANGE
{
    ///Type: <b>int</b> Low limit for the progress bar control. This is a signed integer.
    int iLow;
    int iHigh;
}

///Used to set and retrieve information about a link item.
struct LITEM
{
    ///Type: <b>UINT</b> Combination of one or more of the following flags, describing the information to set or
    ///retrieve: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl>
    ///<dt><b></b></dt> <dt>LIF_ITEMINDEX</dt> </dl> </td> <td width="60%"> Retrieve the numeric item index. Items are
    ///always accessed by index, therefore you must always set this flag and assign a value to <b>iLink</b>. To obtain
    ///the item ID you must set both LIF_ITEMINDEX and LIF_ITEMID. </td> </tr> <tr> <td width="40%"><a id=""></a><dl>
    ///<dt><b></b></dt> <dt>LIF_STATE</dt> </dl> </td> <td width="60%"> Use <b>stateMask</b> to get or set the state of
    ///the link. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LIF_ITEMID</dt> </dl> </td> <td
    ///width="60%"> Specify the item by the ID value given in <b>szID</b>. </td> </tr> <tr> <td width="40%"><a
    ///id=""></a><dl> <dt><b></b></dt> <dt>LIF_URL</dt> </dl> </td> <td width="60%"> Set or get the URL for this item.
    ///</td> </tr> </table>
    uint         mask;
    ///Type: <b>int</b> Value of type <b>int</b> that contains the item index. This numeric index is used to access a
    ///SysLink control link.
    int          iLink;
    ///Type: <b>UINT</b> Combination of one or more of the following flags, describing the state of the item: <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///<dt>LIS_ENABLED</dt> </dl> </td> <td width="60%"> The link can respond to user input. This is the default unless
    ///the entire control was created with WS_DISABLED. In this case, all links are disabled. </td> </tr> <tr> <td
    ///width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LIS_FOCUSED</dt> </dl> </td> <td width="60%"> The link has the
    ///keyboard focus. Pressing ENTER sends an NM_CLICK notification. </td> </tr> <tr> <td width="40%"><a id=""></a><dl>
    ///<dt><b></b></dt> <dt>LIS_VISITED</dt> </dl> </td> <td width="60%"> The link has been visited by the user.
    ///Changing the URL to one that has not been visited causes this flag to be cleared. </td> </tr> <tr> <td
    ///width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LIS_HOTTRACK</dt> </dl> </td> <td width="60%"> Indicates that
    ///the syslink control will highlight in a different color (COLOR_HIGHLIGHT) when the mouse hovers over the control.
    ///</td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LIS_DEFAULTCOLORS</dt> </dl> </td> <td
    ///width="60%"> Enable custom text colors to be used. </td> </tr> </table>
    uint         state;
    ///Type: <b>UINT</b> Combination of flags describing which state item to get or set. Allowable items are identical
    ///to those allowed in <b>state</b>.
    uint         stateMask;
    ///Type: <b>WCHAR[MAX_LINKID_TEXT]</b> <b>WCHAR</b> string that contains the ID name. The maximum number of
    ///characters in the array is MAX_LINKID_TEXT. The ID name cannot be used to access a SysLink control link. You use
    ///the item index to access the item.
    ushort[48]   szID;
    ushort[2084] szUrl;
}

///Used to get information about the link corresponding to a given location.
struct LHITTESTINFO
{
    ///Type: <b>POINT</b> Location for the hit-test, in client coordinates (not screen coordinates).
    POINT pt;
    ///Type: <b>LITEM</b> Receives information about the link corresponding to <b>pt</b>.
    LITEM item;
}

///The <b>NMLINK</b> Contains notification information. Send this structure with the NM_CLICK or NM_RETURN messages.
struct NMLINK
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about the notification.
    NMHDR hdr;
    ///Type: <b>LITEM</b> LITEM structure that contains information about the link item.
    LITEM item;
}

///Specifies or receives the attributes of a list-view item. This structure has been updated to support a new mask value
///(LVIF_INDENT) that enables item indenting. This structure supersedes the <b>LV_ITEM</b> structure.
struct LVITEMA
{
    ///Type: <b>UINT</b> Set of flags that specify which members of this structure contain data to be set or which
    ///members are being requested. This member can have one or more of the following flags set: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LVIF_COLFMT"></a><a id="lvif_colfmt"></a><dl>
    ///<dt><b>LVIF_COLFMT</b></dt> </dl> </td> <td width="60%"> <b>Windows Vista and later.</b> The <b>piColFmt</b>
    ///member is valid or must be set. If this flag is used, the <b>cColumns</b> member is valid or must be set. </td>
    ///</tr> <tr> <td width="40%"><a id="LVIF_COLUMNS"></a><a id="lvif_columns"></a><dl> <dt><b>LVIF_COLUMNS</b></dt>
    ///</dl> </td> <td width="60%"> The <b>cColumns</b> member is valid or must be set. </td> </tr> <tr> <td
    ///width="40%"><a id="LVIF_DI_SETITEM"></a><a id="lvif_di_setitem"></a><dl> <dt><b>LVIF_DI_SETITEM</b></dt> </dl>
    ///</td> <td width="60%"> The operating system should store the requested list item information and not ask for it
    ///again. This flag is used only with the LVN_GETDISPINFO notification code. </td> </tr> <tr> <td width="40%"><a
    ///id="LVIF_GROUPID"></a><a id="lvif_groupid"></a><dl> <dt><b>LVIF_GROUPID</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iGroupId</b> member is valid or must be set. If this flag is not set when an LVM_INSERTITEM message is sent,
    ///the value of <b>iGroupId</b> is assumed to be I_GROUPIDCALLBACK. </td> </tr> <tr> <td width="40%"><a
    ///id="LVIF_IMAGE"></a><a id="lvif_image"></a><dl> <dt><b>LVIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iImage</b> member is valid or must be set. </td> </tr> <tr> <td width="40%"><a id="LVIF_INDENT"></a><a
    ///id="lvif_indent"></a><dl> <dt><b>LVIF_INDENT</b></dt> </dl> </td> <td width="60%"> The <b>iIndent</b> member is
    ///valid or must be set. </td> </tr> <tr> <td width="40%"><a id="LVIF_NORECOMPUTE"></a><a
    ///id="lvif_norecompute"></a><dl> <dt><b>LVIF_NORECOMPUTE</b></dt> </dl> </td> <td width="60%"> The control will not
    ///generate LVN_GETDISPINFO to retrieve text information if it receives an LVM_GETITEM message. Instead, the
    ///<b>pszText</b> member will contain LPSTR_TEXTCALLBACK. </td> </tr> <tr> <td width="40%"><a id="LVIF_PARAM"></a><a
    ///id="lvif_param"></a><dl> <dt><b>LVIF_PARAM</b></dt> </dl> </td> <td width="60%"> The <b>lParam</b> member is
    ///valid or must be set. </td> </tr> <tr> <td width="40%"><a id="LVIF_STATE"></a><a id="lvif_state"></a><dl>
    ///<dt><b>LVIF_STATE</b></dt> </dl> </td> <td width="60%"> The <b>state</b> member is valid or must be set. </td>
    ///</tr> <tr> <td width="40%"><a id="LVIF_TEXT"></a><a id="lvif_text"></a><dl> <dt><b>LVIF_TEXT</b></dt> </dl> </td>
    ///<td width="60%"> The <b>pszText</b> member is valid or must be set. </td> </tr> </table>
    uint   mask;
    ///Type: <b>int</b> Zero-based index of the item to which this structure refers.
    int    iItem;
    ///Type: <b>int</b> One-based index of the subitem to which this structure refers, or zero if this structure refers
    ///to an item rather than a subitem.
    int    iSubItem;
    ///Type: <b>UINT</b> Indicates the item's state, state image, and overlay image. The <b>stateMask</b> member
    ///indicates the valid bits of this member. Bits 0 through 7 of this member contain the item state flags. This can
    ///be one or more of the item state values. Bits 8 through 11 of this member specify the one-based overlay image
    ///index. Both the full-sized icon image list and the small icon image list can have overlay images. The overlay
    ///image is superimposed over the item's icon image. If these bits are zero, the item has no overlay image. To
    ///isolate these bits, use the LVIS_OVERLAYMASK mask. To set the overlay image index in this member, you should use
    ///the INDEXTOOVERLAYMASK macro. The image list's overlay images are set with the ImageList_SetOverlayImage
    ///function. Bits 12 through 15 of this member specify the state image index. The state image is displayed next to
    ///an item's icon to indicate an application-defined state. If these bits are zero, the item has no state image. To
    ///isolate these bits, use the LVIS_STATEIMAGEMASK mask. To set the state image index, use the INDEXTOSTATEIMAGEMASK
    ///macro. The state image index specifies the index of the image in the state image list that should be drawn. The
    ///state image list is specified with the LVM_SETIMAGELIST message.
    uint   state;
    ///Type: <b>UINT</b> Value specifying which bits of the <b>state</b> member will be retrieved or modified. For
    ///example, setting this member to LVIS_SELECTED will cause only the item's selection state to be retrieved. This
    ///member allows you to modify one or more item states without having to retrieve all of the item states first. For
    ///example, setting this member to <b>LVIS_SELECTED</b> and <b>state</b> to zero will cause the item's selection
    ///state to be cleared, but none of the other states will be affected. To retrieve or modify all of the states, set
    ///this member to (<b>UINT</b>)-1. You can use the macro ListView_SetItemState both to set and to clear bits.
    uint   stateMask;
    ///Type: <b>LPTSTR</b> If the structure specifies item attributes, <b>pszText</b> is a pointer to a null-terminated
    ///string containing the item text. When responding to an LVN_GETDISPINFO notification, be sure that this pointer
    ///remains valid until after the next notification has been received. If the structure receives item attributes,
    ///<b>pszText</b> is a pointer to a buffer that receives the item text. Note that although the list-view control
    ///allows any length string to be stored as item text, only the first 259 <b>TCHAR</b>s are displayed. If the value
    ///of <b>pszText</b> is LPSTR_TEXTCALLBACK, the item is a callback item. If the callback text changes, you must
    ///explicitly set <b>pszText</b> to LPSTR_TEXTCALLBACK and notify the list-view control of the change by sending an
    ///LVM_SETITEM or LVM_SETITEMTEXT message. Do not set <b>pszText</b> to LPSTR_TEXTCALLBACK if the list-view control
    ///has the LVS_SORTASCENDING or LVS_SORTDESCENDING style.
    PSTR   pszText;
    ///Type: <b>int</b> Number of <b>TCHAR</b><b>s</b> in the buffer pointed to by <b>pszText</b>, including the
    ///terminating <b>NULL</b>. This member is only used when the structure receives item attributes. It is ignored when
    ///the structure specifies item attributes. For example, <b>cchTextMax</b> is ignored during LVM_SETITEM and
    ///LVM_INSERTITEM. It is read-only during LVN_GETDISPINFO and other LVN_ notifications. <div
    ///class="alert"><b>Note</b> Never copy more than <b>cchTextMax</b> <b>TCHAR</b><b>s</b>—where <b>cchTextMax</b>
    ///includes the terminating <b>NULL</b>—into <b>pszText</b> during an LVN_ notification, otherwise your program
    ///can fail.</div> <div> </div>
    int    cchTextMax;
    ///Type: <b>int</b> Index of the item's icon in the control's image list. This applies to both the large and small
    ///image list. If this member is the I_IMAGECALLBACK value, the parent window is responsible for storing the index.
    ///In this case, the list-view control sends the parent an LVN_GETDISPINFO notification code to retrieve the index
    ///when it needs to display the image.
    int    iImage;
    ///Type: <b>LPARAM</b> Value specific to the item. If you use the LVM_SORTITEMS message, the list-view control
    ///passes this value to the application-defined comparison function. You can also use the LVM_FINDITEM message to
    ///search a list-view control for an item with a specified <b>lParam</b> value.
    LPARAM lParam;
    ///Type: <b>int</b> Version 4.70. Number of image widths to indent the item. A single indentation equals the width
    ///of an item image. Therefore, the value 1 indents the item by the width of one image, the value 2 indents by two
    ///images, and so on. Note that this field is supported only for items. Attempting to set subitem indentation will
    ///cause the calling function to fail.
    int    iIndent;
    ///Type: <b>int</b> Version 6.0 Identifier of the group that the item belongs to, or one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="I_GROUPIDCALLBACK"></a><a
    ///id="i_groupidcallback"></a><dl> <dt><b>I_GROUPIDCALLBACK</b></dt> </dl> </td> <td width="60%"> The listview
    ///control sends the parent an LVN_GETDISPINFO notification code to retrieve the index of the group. </td> </tr>
    ///<tr> <td width="40%"><a id="I_GROUPIDNONE"></a><a id="i_groupidnone"></a><dl> <dt><b>I_GROUPIDNONE</b></dt> </dl>
    ///</td> <td width="60%"> The item does not belong to a group. </td> </tr> </table>
    int    iGroupId;
    ///Type: <b>UINT</b> Version 6.0 Number of data columns (subitems) to display for this item in tile view. The
    ///maximum value is 20. If this value is I_COLUMNSCALLBACK, the size of the column array and the array itself
    ///(<b>puColumns</b>) are obtained by sending a LVN_GETDISPINFO notification.
    uint   cColumns;
    ///Type: <b>PUINT</b> Version 6.0 A pointer to an array of column indices, specifying which columns are displayed
    ///for this item, and the order of those columns.
    uint*  puColumns;
    ///Type: <b>int*</b> <b>Windows Vista:</b> Not implemented. <b>Windows 7 and later:</b> A pointer to an array of the
    ///following flags (alone or in combination), specifying the format of each subitem in extended tile view. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LVCFMT_LINE_BREAK"></a><a
    ///id="lvcfmt_line_break"></a><dl> <dt><b>LVCFMT_LINE_BREAK</b></dt> </dl> </td> <td width="60%"> Forces the column
    ///to wrap to the top of the next list of columns. </td> </tr> <tr> <td width="40%"><a id="LVCFMT_FILL"></a><a
    ///id="lvcfmt_fill"></a><dl> <dt><b>LVCFMT_FILL</b></dt> </dl> </td> <td width="60%"> Fills the remainder of the
    ///tile area. Might have a title. </td> </tr> <tr> <td width="40%"><a id="LVCFMT_WRAP"></a><a
    ///id="lvcfmt_wrap"></a><dl> <dt><b>LVCFMT_WRAP</b></dt> </dl> </td> <td width="60%"> Allows the column to wrap
    ///within the remaining space in its list of columns. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCFMT_NO_TITLE"></a><a id="lvcfmt_no_title"></a><dl> <dt><b>LVCFMT_NO_TITLE</b></dt> </dl> </td> <td
    ///width="60%"> Removes the title from the subitem. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCFMT_TILE_PLACEMENTMASK"></a><a id="lvcfmt_tile_placementmask"></a><dl>
    ///<dt><b>LVCFMT_TILE_PLACEMENTMASK</b></dt> </dl> </td> <td width="60%"> Equivalent to a combination of
    ///LVCFMT_LINE_BREAK and LVCFMT_FILL. </td> </tr> </table>
    int*   piColFmt;
    ///Type: <b>int</b> Windows Vista: Group index of the item. Valid only for owner data/callback (single item in
    ///multiple groups).
    int    iGroup;
}

///Specifies or receives the attributes of a list-view item. This structure has been updated to support a new mask value
///(LVIF_INDENT) that enables item indenting. This structure supersedes the <b>LV_ITEM</b> structure.
struct LVITEMW
{
    ///Type: <b>UINT</b> Set of flags that specify which members of this structure contain data to be set or which
    ///members are being requested. This member can have one or more of the following flags set: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LVIF_COLFMT"></a><a id="lvif_colfmt"></a><dl>
    ///<dt><b>LVIF_COLFMT</b></dt> </dl> </td> <td width="60%"> <b>Windows Vista and later.</b> The <b>piColFmt</b>
    ///member is valid or must be set. If this flag is used, the <b>cColumns</b> member is valid or must be set. </td>
    ///</tr> <tr> <td width="40%"><a id="LVIF_COLUMNS"></a><a id="lvif_columns"></a><dl> <dt><b>LVIF_COLUMNS</b></dt>
    ///</dl> </td> <td width="60%"> The <b>cColumns</b> member is valid or must be set. </td> </tr> <tr> <td
    ///width="40%"><a id="LVIF_DI_SETITEM"></a><a id="lvif_di_setitem"></a><dl> <dt><b>LVIF_DI_SETITEM</b></dt> </dl>
    ///</td> <td width="60%"> The operating system should store the requested list item information and not ask for it
    ///again. This flag is used only with the LVN_GETDISPINFO notification code. </td> </tr> <tr> <td width="40%"><a
    ///id="LVIF_GROUPID"></a><a id="lvif_groupid"></a><dl> <dt><b>LVIF_GROUPID</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iGroupId</b> member is valid or must be set. If this flag is not set when an LVM_INSERTITEM message is sent,
    ///the value of <b>iGroupId</b> is assumed to be I_GROUPIDCALLBACK. </td> </tr> <tr> <td width="40%"><a
    ///id="LVIF_IMAGE"></a><a id="lvif_image"></a><dl> <dt><b>LVIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iImage</b> member is valid or must be set. </td> </tr> <tr> <td width="40%"><a id="LVIF_INDENT"></a><a
    ///id="lvif_indent"></a><dl> <dt><b>LVIF_INDENT</b></dt> </dl> </td> <td width="60%"> The <b>iIndent</b> member is
    ///valid or must be set. </td> </tr> <tr> <td width="40%"><a id="LVIF_NORECOMPUTE"></a><a
    ///id="lvif_norecompute"></a><dl> <dt><b>LVIF_NORECOMPUTE</b></dt> </dl> </td> <td width="60%"> The control will not
    ///generate LVN_GETDISPINFO to retrieve text information if it receives an LVM_GETITEM message. Instead, the
    ///<b>pszText</b> member will contain LPSTR_TEXTCALLBACK. </td> </tr> <tr> <td width="40%"><a id="LVIF_PARAM"></a><a
    ///id="lvif_param"></a><dl> <dt><b>LVIF_PARAM</b></dt> </dl> </td> <td width="60%"> The <b>lParam</b> member is
    ///valid or must be set. </td> </tr> <tr> <td width="40%"><a id="LVIF_STATE"></a><a id="lvif_state"></a><dl>
    ///<dt><b>LVIF_STATE</b></dt> </dl> </td> <td width="60%"> The <b>state</b> member is valid or must be set. </td>
    ///</tr> <tr> <td width="40%"><a id="LVIF_TEXT"></a><a id="lvif_text"></a><dl> <dt><b>LVIF_TEXT</b></dt> </dl> </td>
    ///<td width="60%"> The <b>pszText</b> member is valid or must be set. </td> </tr> </table>
    uint   mask;
    ///Type: <b>int</b> Zero-based index of the item to which this structure refers.
    int    iItem;
    ///Type: <b>int</b> One-based index of the subitem to which this structure refers, or zero if this structure refers
    ///to an item rather than a subitem.
    int    iSubItem;
    ///Type: <b>UINT</b> Indicates the item's state, state image, and overlay image. The <b>stateMask</b> member
    ///indicates the valid bits of this member. Bits 0 through 7 of this member contain the item state flags. This can
    ///be one or more of the item state values. Bits 8 through 11 of this member specify the one-based overlay image
    ///index. Both the full-sized icon image list and the small icon image list can have overlay images. The overlay
    ///image is superimposed over the item's icon image. If these bits are zero, the item has no overlay image. To
    ///isolate these bits, use the LVIS_OVERLAYMASK mask. To set the overlay image index in this member, you should use
    ///the INDEXTOOVERLAYMASK macro. The image list's overlay images are set with the ImageList_SetOverlayImage
    ///function. Bits 12 through 15 of this member specify the state image index. The state image is displayed next to
    ///an item's icon to indicate an application-defined state. If these bits are zero, the item has no state image. To
    ///isolate these bits, use the LVIS_STATEIMAGEMASK mask. To set the state image index, use the INDEXTOSTATEIMAGEMASK
    ///macro. The state image index specifies the index of the image in the state image list that should be drawn. The
    ///state image list is specified with the LVM_SETIMAGELIST message.
    uint   state;
    ///Type: <b>UINT</b> Value specifying which bits of the <b>state</b> member will be retrieved or modified. For
    ///example, setting this member to LVIS_SELECTED will cause only the item's selection state to be retrieved. This
    ///member allows you to modify one or more item states without having to retrieve all of the item states first. For
    ///example, setting this member to <b>LVIS_SELECTED</b> and <b>state</b> to zero will cause the item's selection
    ///state to be cleared, but none of the other states will be affected. To retrieve or modify all of the states, set
    ///this member to (<b>UINT</b>)-1. You can use the macro ListView_SetItemState both to set and to clear bits.
    uint   stateMask;
    ///Type: <b>LPTSTR</b> If the structure specifies item attributes, <b>pszText</b> is a pointer to a null-terminated
    ///string containing the item text. When responding to an LVN_GETDISPINFO notification, be sure that this pointer
    ///remains valid until after the next notification has been received. If the structure receives item attributes,
    ///<b>pszText</b> is a pointer to a buffer that receives the item text. Note that although the list-view control
    ///allows any length string to be stored as item text, only the first 260 <b>TCHAR</b>s are displayed. If the value
    ///of <b>pszText</b> is LPSTR_TEXTCALLBACK, the item is a callback item. If the callback text changes, you must
    ///explicitly set <b>pszText</b> to LPSTR_TEXTCALLBACK and notify the list-view control of the change by sending an
    ///LVM_SETITEM or LVM_SETITEMTEXT message. Do not set <b>pszText</b> to LPSTR_TEXTCALLBACK if the list-view control
    ///has the LVS_SORTASCENDING or LVS_SORTDESCENDING style.
    PWSTR  pszText;
    ///Type: <b>int</b> Number of <b>TCHAR</b><b>s</b> in the buffer pointed to by <b>pszText</b>, including the
    ///terminating <b>NULL</b>. This member is only used when the structure receives item attributes. It is ignored when
    ///the structure specifies item attributes. For example, <b>cchTextMax</b> is ignored during LVM_SETITEM and
    ///LVM_INSERTITEM. It is read-only during LVN_GETDISPINFO and other LVN_ notifications. <div
    ///class="alert"><b>Note</b> Never copy more than <b>cchTextMax</b> <b>TCHAR</b><b>s</b>—where <b>cchTextMax</b>
    ///includes the terminating <b>NULL</b>—into <b>pszText</b> during an LVN_ notification, otherwise your program
    ///can fail.</div> <div> </div>
    int    cchTextMax;
    ///Type: <b>int</b> Index of the item's icon in the control's image list. This applies to both the large and small
    ///image list. If this member is the I_IMAGECALLBACK value, the parent window is responsible for storing the index.
    ///In this case, the list-view control sends the parent an LVN_GETDISPINFO notification code to retrieve the index
    ///when it needs to display the image.
    int    iImage;
    ///Type: <b>LPARAM</b> Value specific to the item. If you use the LVM_SORTITEMS message, the list-view control
    ///passes this value to the application-defined comparison function. You can also use the LVM_FINDITEM message to
    ///search a list-view control for an item with a specified <b>lParam</b> value.
    LPARAM lParam;
    ///Type: <b>int</b> Version 4.70. Number of image widths to indent the item. A single indentation equals the width
    ///of an item image. Therefore, the value 1 indents the item by the width of one image, the value 2 indents by two
    ///images, and so on. Note that this field is supported only for items. Attempting to set subitem indentation will
    ///cause the calling function to fail.
    int    iIndent;
    ///Type: <b>int</b> Version 6.0 Identifier of the group that the item belongs to, or one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="I_GROUPIDCALLBACK"></a><a
    ///id="i_groupidcallback"></a><dl> <dt><b>I_GROUPIDCALLBACK</b></dt> </dl> </td> <td width="60%"> The listview
    ///control sends the parent an LVN_GETDISPINFO notification code to retrieve the index of the group. </td> </tr>
    ///<tr> <td width="40%"><a id="I_GROUPIDNONE"></a><a id="i_groupidnone"></a><dl> <dt><b>I_GROUPIDNONE</b></dt> </dl>
    ///</td> <td width="60%"> The item does not belong to a group. </td> </tr> </table>
    int    iGroupId;
    ///Type: <b>UINT</b> Version 6.0 Number of data columns (subitems) to display for this item in tile view. The
    ///maximum value is 20. If this value is I_COLUMNSCALLBACK, the size of the column array and the array itself
    ///(<b>puColumns</b>) are obtained by sending a LVN_GETDISPINFO notification.
    uint   cColumns;
    ///Type: <b>PUINT</b> Version 6.0 A pointer to an array of column indices, specifying which columns are displayed
    ///for this item, and the order of those columns.
    uint*  puColumns;
    ///Type: <b>int*</b> <b>Windows Vista:</b> Not implemented. <b>Windows 7 and later:</b> A pointer to an array of the
    ///following flags (alone or in combination), specifying the format of each subitem in extended tile view. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LVCFMT_LINE_BREAK"></a><a
    ///id="lvcfmt_line_break"></a><dl> <dt><b>LVCFMT_LINE_BREAK</b></dt> </dl> </td> <td width="60%"> Forces the column
    ///to wrap to the top of the next list of columns. </td> </tr> <tr> <td width="40%"><a id="LVCFMT_FILL"></a><a
    ///id="lvcfmt_fill"></a><dl> <dt><b>LVCFMT_FILL</b></dt> </dl> </td> <td width="60%"> Fills the remainder of the
    ///tile area. Might have a title. </td> </tr> <tr> <td width="40%"><a id="LVCFMT_WRAP"></a><a
    ///id="lvcfmt_wrap"></a><dl> <dt><b>LVCFMT_WRAP</b></dt> </dl> </td> <td width="60%"> Allows the column to wrap
    ///within the remaining space in its list of columns. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCFMT_NO_TITLE"></a><a id="lvcfmt_no_title"></a><dl> <dt><b>LVCFMT_NO_TITLE</b></dt> </dl> </td> <td
    ///width="60%"> Removes the title from the subitem. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCFMT_TILE_PLACEMENTMASK"></a><a id="lvcfmt_tile_placementmask"></a><dl>
    ///<dt><b>LVCFMT_TILE_PLACEMENTMASK</b></dt> </dl> </td> <td width="60%"> Equivalent to a combination of
    ///LVCFMT_LINE_BREAK and LVCFMT_FILL. </td> </tr> </table>
    int*   piColFmt;
    ///Type: <b>int</b> Windows Vista: Group index of the item. Valid only for owner data/callback (single item in
    ///multiple groups).
    int    iGroup;
}

///Contains information used when searching for a list-view item. This structure is identical to LV_FINDINFO but has
///been renamed to fit standard naming conventions.
struct LVFINDINFOA
{
    ///Type: <b>UINT</b> Type of search to perform. This member can be set to one or more of the following values:
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LVFI_PARAM"></a><a
    ///id="lvfi_param"></a><dl> <dt><b>LVFI_PARAM</b></dt> </dl> </td> <td width="60%"> Searches for a match between
    ///this structure's <b>lParam</b> member and the <b>lParam</b> member of an item's LVITEM structure. </td> </tr>
    ///<tr> <td width="40%"><a id="LVFI_PARTIAL"></a><a id="lvfi_partial"></a><dl> <dt><b>LVFI_PARTIAL</b></dt> </dl>
    ///</td> <td width="60%"> Checks to see if the item text begins with the string pointed to by the <b>psz</b> member.
    ///This value implies use of LVFI_STRING. </td> </tr> <tr> <td width="40%"><a id="LVFI_STRING"></a><a
    ///id="lvfi_string"></a><dl> <dt><b>LVFI_STRING</b></dt> </dl> </td> <td width="60%"> Searches based on the item
    ///text. Unless additional values are specified, the item text of the matching item must exactly match the string
    ///pointed to by the <b>psz</b> member. However, the search is case-insensitive. </td> </tr> <tr> <td width="40%"><a
    ///id="LVFI_SUBSTRING"></a><a id="lvfi_substring"></a><dl> <dt><b>LVFI_SUBSTRING</b></dt> </dl> </td> <td
    ///width="60%"> <b>Windows Vista and later.</b> Equivalent to LVFI_PARTIAL. </td> </tr> <tr> <td width="40%"><a
    ///id="LVFI_WRAP"></a><a id="lvfi_wrap"></a><dl> <dt><b>LVFI_WRAP</b></dt> </dl> </td> <td width="60%"> Continues
    ///the search at the beginning if no match is found. If this flag is used by itself, it is assumed that a string
    ///search is wanted. </td> </tr> <tr> <td width="40%"><a id="LVFI_NEARESTXY"></a><a id="lvfi_nearestxy"></a><dl>
    ///<dt><b>LVFI_NEARESTXY</b></dt> </dl> </td> <td width="60%"> Finds the item nearest to the position specified in
    ///the <b>pt</b> member, in the direction specified by the <b>vkDirection</b> member. This flag is supported only by
    ///large icon and small icon modes. If LVFI_NEARESTXY is specified, all other flags are ignored. </td> </tr>
    ///</table>
    uint        flags;
    ///Type: <b>LPCTSTR</b> Address of a null-terminated string to compare with the item text. It is valid only if
    ///LVFI_STRING or LVFI_PARTIAL is set in the <b>flags</b> member.
    const(PSTR) psz;
    ///Type: <b>LPARAM</b> Value to compare with the <b>lParam</b> member of a list-view item's LVITEM structure. It is
    ///valid only if LVFI_PARAM is set in the <b>flags</b> member.
    LPARAM      lParam;
    ///Type: <b>POINT</b> POINT structure with the initial search position. It is valid only if LVFI_NEARESTXY is set in
    ///the <b>flags</b> member.
    POINT       pt;
    ///Type: <b>UINT</b> Virtual key code that specifies the direction to search. The following codes are supported:
    ///<ul> <li>VK_LEFT </li> <li>VK_RIGHT </li> <li>VK_UP </li> <li>VK_DOWN </li> <li>VK_HOME </li> <li>VK_END </li>
    ///<li>VK_PRIOR </li> <li>VK_NEXT </li> </ul> This member is valid only if LVFI_NEARESTXY is set in the <b>flags</b>
    ///member.
    uint        vkDirection;
}

///Contains information used when searching for a list-view item. This structure is identical to LV_FINDINFO but has
///been renamed to fit standard naming conventions.
struct LVFINDINFOW
{
    ///Type: <b>UINT</b> Type of search to perform. This member can be set to one or more of the following values:
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LVFI_PARAM"></a><a
    ///id="lvfi_param"></a><dl> <dt><b>LVFI_PARAM</b></dt> </dl> </td> <td width="60%"> Searches for a match between
    ///this structure's <b>lParam</b> member and the <b>lParam</b> member of an item's LVITEM structure. </td> </tr>
    ///<tr> <td width="40%"><a id="LVFI_PARTIAL"></a><a id="lvfi_partial"></a><dl> <dt><b>LVFI_PARTIAL</b></dt> </dl>
    ///</td> <td width="60%"> Checks to see if the item text begins with the string pointed to by the <b>psz</b> member.
    ///This value implies use of LVFI_STRING. </td> </tr> <tr> <td width="40%"><a id="LVFI_STRING"></a><a
    ///id="lvfi_string"></a><dl> <dt><b>LVFI_STRING</b></dt> </dl> </td> <td width="60%"> Searches based on the item
    ///text. Unless additional values are specified, the item text of the matching item must exactly match the string
    ///pointed to by the <b>psz</b> member. However, the search is case-insensitive. </td> </tr> <tr> <td width="40%"><a
    ///id="LVFI_SUBSTRING"></a><a id="lvfi_substring"></a><dl> <dt><b>LVFI_SUBSTRING</b></dt> </dl> </td> <td
    ///width="60%"> <b>Windows Vista and later.</b> Equivalent to LVFI_PARTIAL. </td> </tr> <tr> <td width="40%"><a
    ///id="LVFI_WRAP"></a><a id="lvfi_wrap"></a><dl> <dt><b>LVFI_WRAP</b></dt> </dl> </td> <td width="60%"> Continues
    ///the search at the beginning if no match is found. If this flag is used by itself, it is assumed that a string
    ///search is wanted. </td> </tr> <tr> <td width="40%"><a id="LVFI_NEARESTXY"></a><a id="lvfi_nearestxy"></a><dl>
    ///<dt><b>LVFI_NEARESTXY</b></dt> </dl> </td> <td width="60%"> Finds the item nearest to the position specified in
    ///the <b>pt</b> member, in the direction specified by the <b>vkDirection</b> member. This flag is supported only by
    ///large icon and small icon modes. If LVFI_NEARESTXY is specified, all other flags are ignored. </td> </tr>
    ///</table>
    uint         flags;
    ///Type: <b>LPCTSTR</b> Address of a null-terminated string to compare with the item text. It is valid only if
    ///LVFI_STRING or LVFI_PARTIAL is set in the <b>flags</b> member.
    const(PWSTR) psz;
    ///Type: <b>LPARAM</b> Value to compare with the <b>lParam</b> member of a list-view item's LVITEM structure. It is
    ///valid only if LVFI_PARAM is set in the <b>flags</b> member.
    LPARAM       lParam;
    ///Type: <b>POINT</b> POINT structure with the initial search position. It is valid only if LVFI_NEARESTXY is set in
    ///the <b>flags</b> member.
    POINT        pt;
    ///Type: <b>UINT</b> Virtual key code that specifies the direction to search. The following codes are supported:
    ///<ul> <li>VK_LEFT </li> <li>VK_RIGHT </li> <li>VK_UP </li> <li>VK_DOWN </li> <li>VK_HOME </li> <li>VK_END </li>
    ///<li>VK_PRIOR </li> <li>VK_NEXT </li> </ul> This member is valid only if LVFI_NEARESTXY is set in the <b>flags</b>
    ///member.
    uint         vkDirection;
}

///Contains information about a hit test. This structure has been extended to accommodate subitem hit-testing. It is
///used in association with the LVM_HITTEST and LVM_SUBITEMHITTEST messages and their related macros. This structure
///supersedes the <b>LVHITTESTINFO</b> structure.
struct LVHITTESTINFO
{
    ///Type: <b>POINT</b> The position to hit test, in client coordinates.
    POINT pt;
    ///Type: <b>UINT</b> The variable that receives information about the results of a hit test. This member can be one
    ///or more of the following values: You can use LVHT_ABOVE, LVHT_BELOW, LVHT_TOLEFT, and LVHT_TORIGHT to determine
    ///whether to scroll the contents of a list-view control. Two of these values may be combined. For example, if the
    ///position is above and to the left of the client area, you could use both LVHT_ABOVE and LVHT_TOLEFT. You can test
    ///for LVHT_ONITEM to determine whether a specified position is over a list-view item. This value is a bitwise-OR
    ///operation on LVHT_ONITEMICON, LVHT_ONITEMLABEL, and LVHT_ONITEMSTATEICON. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="LVHT_ABOVE"></a><a id="lvht_above"></a><dl>
    ///<dt><b>LVHT_ABOVE</b></dt> </dl> </td> <td width="60%"> The position is above the control's client area. </td>
    ///</tr> <tr> <td width="40%"><a id="LVHT_BELOW"></a><a id="lvht_below"></a><dl> <dt><b>LVHT_BELOW</b></dt> </dl>
    ///</td> <td width="60%"> The position is below the control's client area. </td> </tr> <tr> <td width="40%"><a
    ///id="LVHT_NOWHERE"></a><a id="lvht_nowhere"></a><dl> <dt><b>LVHT_NOWHERE</b></dt> </dl> </td> <td width="60%"> The
    ///position is inside the list-view control's client window, but it is not over a list item. </td> </tr> <tr> <td
    ///width="40%"><a id="LVHT_ONITEMICON"></a><a id="lvht_onitemicon"></a><dl> <dt><b>LVHT_ONITEMICON</b></dt> </dl>
    ///</td> <td width="60%"> The position is over a list-view item's icon. </td> </tr> <tr> <td width="40%"><a
    ///id="LVHT_ONITEMLABEL"></a><a id="lvht_onitemlabel"></a><dl> <dt><b>LVHT_ONITEMLABEL</b></dt> </dl> </td> <td
    ///width="60%"> The position is over a list-view item's text. </td> </tr> <tr> <td width="40%"><a
    ///id="LVHT_ONITEMSTATEICON"></a><a id="lvht_onitemstateicon"></a><dl> <dt><b>LVHT_ONITEMSTATEICON</b></dt> </dl>
    ///</td> <td width="60%"> The position is over the state image of a list-view item. </td> </tr> <tr> <td
    ///width="40%"><a id="LVHT_TOLEFT"></a><a id="lvht_toleft"></a><dl> <dt><b>LVHT_TOLEFT</b></dt> </dl> </td> <td
    ///width="60%"> The position is to the left of the list-view control's client area. </td> </tr> <tr> <td
    ///width="40%"><a id="LVHT_TORIGHT"></a><a id="lvht_toright"></a><dl> <dt><b>LVHT_TORIGHT</b></dt> </dl> </td> <td
    ///width="60%"> The position is to the right of the list-view control's client area. </td> </tr> <tr> <td
    ///width="40%"><a id="LVHT_EX_GROUP_HEADER"></a><a id="lvht_ex_group_header"></a><dl>
    ///<dt><b>LVHT_EX_GROUP_HEADER</b></dt> </dl> </td> <td width="60%"> <b>Windows Vista.</b> The point is within the
    ///group header. </td> </tr> <tr> <td width="40%"><a id="LVHT_EX_GROUP_FOOTER"></a><a
    ///id="lvht_ex_group_footer"></a><dl> <dt><b>LVHT_EX_GROUP_FOOTER</b></dt> </dl> </td> <td width="60%"> <b>Windows
    ///Vista.</b> The point is within the group footer. </td> </tr> <tr> <td width="40%"><a
    ///id="LVHT_EX_GROUP_COLLAPSE"></a><a id="lvht_ex_group_collapse"></a><dl> <dt><b>LVHT_EX_GROUP_COLLAPSE</b></dt>
    ///</dl> </td> <td width="60%"> <b>Windows Vista.</b> The point is within the collapse/expand button of the group.
    ///</td> </tr> <tr> <td width="40%"><a id="LVHT_EX_GROUP_BACKGROUND"></a><a id="lvht_ex_group_background"></a><dl>
    ///<dt><b>LVHT_EX_GROUP_BACKGROUND</b></dt> </dl> </td> <td width="60%"> <b>Windows Vista.</b> The point is within
    ///the area of the group where items are displayed. </td> </tr> <tr> <td width="40%"><a
    ///id="LVHT_EX_GROUP_STATEICON"></a><a id="lvht_ex_group_stateicon"></a><dl> <dt><b>LVHT_EX_GROUP_STATEICON</b></dt>
    ///</dl> </td> <td width="60%"> <b>Windows Vista.</b> The point is within the state icon of the group. </td> </tr>
    ///<tr> <td width="40%"><a id="LVHT_EX_GROUP_SUBSETLINK"></a><a id="lvht_ex_group_subsetlink"></a><dl>
    ///<dt><b>LVHT_EX_GROUP_SUBSETLINK</b></dt> </dl> </td> <td width="60%"> <b>Windows Vista.</b> The point is within
    ///the subset link of the group. </td> </tr> <tr> <td width="40%"><a id="LVHT_EX_GROUP"></a><a
    ///id="lvht_ex_group"></a><dl> <dt><b>LVHT_EX_GROUP</b></dt> </dl> </td> <td width="60%"> <b>Windows Vista.</b>
    ///LVHT_EX_GROUP_BACKGROUND | LVHT_EX_GROUP_COLLAPSE | LVHT_EX_GROUP_FOOTER | LVHT_EX_GROUP_HEADER |
    ///LVHT_EX_GROUP_STATEICON | LVHT_EX_GROUP_SUBSETLINK. </td> </tr> <tr> <td width="40%"><a
    ///id="LVHT_EX_ONCONTENTS"></a><a id="lvht_ex_oncontents"></a><dl> <dt><b>LVHT_EX_ONCONTENTS</b></dt> </dl> </td>
    ///<td width="60%"> <b>Windows Vista.</b> The point is within the icon or text content of the item and not on the
    ///background. </td> </tr> <tr> <td width="40%"><a id="LVHT_EX_FOOTER"></a><a id="lvht_ex_footer"></a><dl>
    ///<dt><b>LVHT_EX_FOOTER</b></dt> </dl> </td> <td width="60%"> <b>Windows Vista.</b> The point is within the footer
    ///of the list-view control. </td> </tr> </table>
    uint  flags;
    ///Type: <b>int</b> Receives the index of the matching item. Or if hit-testing a subitem, this value represents the
    ///subitem's parent item.
    int   iItem;
    ///Type: <b>int</b> Version 4.70. Receives the index of the matching subitem. When hit-testing an item, this member
    ///will be zero.
    int   iSubItem;
    int   iGroup;
}

///Contains information about a column in report view. This structure is used both for creating and manipulating
///columns. This structure supersedes the LV_COLUMN structure.
struct LVCOLUMNA
{
    ///Type: <b>UINT</b> Variable specifying which members contain valid information. This member can be zero, or one or
    ///more of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="LVCF_FMT"></a><a id="lvcf_fmt"></a><dl> <dt><b>LVCF_FMT</b></dt> </dl> </td> <td width="60%"> The <b>fmt</b>
    ///member is valid. </td> </tr> <tr> <td width="40%"><a id="LVCF_WIDTH"></a><a id="lvcf_width"></a><dl>
    ///<dt><b>LVCF_WIDTH</b></dt> </dl> </td> <td width="60%"> The <b>cx</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="LVCF_TEXT"></a><a id="lvcf_text"></a><dl> <dt><b>LVCF_TEXT</b></dt> </dl> </td> <td
    ///width="60%"> The <b>pszText</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="LVCF_SUBITEM"></a><a
    ///id="lvcf_subitem"></a><dl> <dt><b>LVCF_SUBITEM</b></dt> </dl> </td> <td width="60%"> The <b>iSubItem</b> member
    ///is valid. </td> </tr> <tr> <td width="40%"><a id="LVCF_IMAGE"></a><a id="lvcf_image"></a><dl>
    ///<dt><b>LVCF_IMAGE</b></dt> </dl> </td> <td width="60%"> Version 4.70. The <b>iImage</b> member is valid. </td>
    ///</tr> <tr> <td width="40%"><a id="LVCF_ORDER"></a><a id="lvcf_order"></a><dl> <dt><b>LVCF_ORDER</b></dt> </dl>
    ///</td> <td width="60%"> Version 4.70. The <b>iOrder</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCF_MINWIDTH"></a><a id="lvcf_minwidth"></a><dl> <dt><b>LVCF_MINWIDTH</b></dt> </dl> </td> <td width="60%">
    ///Version 6.00 and <b>Windows Vista.</b>The <b>cxMin</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCF_DEFAULTWIDTH"></a><a id="lvcf_defaultwidth"></a><dl> <dt><b>LVCF_DEFAULTWIDTH</b></dt> </dl> </td> <td
    ///width="60%"> Version 6.00 and <b>Windows Vista.</b>The <b>cxDefault</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="LVCF_IDEALWIDTH"></a><a id="lvcf_idealwidth"></a><dl> <dt><b>LVCF_IDEALWIDTH</b></dt> </dl>
    ///</td> <td width="60%"> Version 6.00 and <b>Windows Vista.</b>The <b>cxIdeal</b> member is valid. </td> </tr>
    ///</table>
    uint mask;
    ///Type: <b>int</b> Alignment of the column header and the subitem text in the column. The alignment of the leftmost
    ///column is always LVCFMT_LEFT; it cannot be changed. This member can be a combination of the following values.
    ///Note that not all combinations are valid. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="LVCFMT_LEFT"></a><a id="lvcfmt_left"></a><dl> <dt><b>LVCFMT_LEFT</b></dt> </dl> </td> <td
    ///width="60%"> Text is left-aligned. </td> </tr> <tr> <td width="40%"><a id="LVCFMT_RIGHT"></a><a
    ///id="lvcfmt_right"></a><dl> <dt><b>LVCFMT_RIGHT</b></dt> </dl> </td> <td width="60%"> Text is right-aligned. </td>
    ///</tr> <tr> <td width="40%"><a id="LVCFMT_CENTER"></a><a id="lvcfmt_center"></a><dl> <dt><b>LVCFMT_CENTER</b></dt>
    ///</dl> </td> <td width="60%"> Text is centered. </td> </tr> <tr> <td width="40%"><a id="LVCFMT_JUSTIFYMASK"></a><a
    ///id="lvcfmt_justifymask"></a><dl> <dt><b>LVCFMT_JUSTIFYMASK</b></dt> </dl> </td> <td width="60%"> A bitmask used
    ///to select those bits of <b>fmt</b> that control field justification. To check the format of a column, use a
    ///logical "and" to combine LCFMT_JUSTIFYMASK with <b>fmt</b>. You can then use a switch statement to determine
    ///whether the LVCFMT_LEFT, LVCFMT_RIGHT, or LVCFMT_CENTER bits are set. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCFMT_IMAGE"></a><a id="lvcfmt_image"></a><dl> <dt><b>LVCFMT_IMAGE</b></dt> </dl> </td> <td width="60%">
    ///Version 4.70. The item displays an image from an image list. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCFMT_BITMAP_ON_RIGHT"></a><a id="lvcfmt_bitmap_on_right"></a><dl> <dt><b>LVCFMT_BITMAP_ON_RIGHT</b></dt>
    ///</dl> </td> <td width="60%"> Version 4.70. The bitmap appears to the right of text. This does not affect an image
    ///from an image list assigned to the header item. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCFMT_COL_HAS_IMAGES"></a><a id="lvcfmt_col_has_images"></a><dl> <dt><b>LVCFMT_COL_HAS_IMAGES</b></dt> </dl>
    ///</td> <td width="60%"> Version 4.70. The header item contains an image in the image list. </td> </tr> <tr> <td
    ///width="40%"><a id="LVCFMT_FIXED_WIDTH"></a><a id="lvcfmt_fixed_width"></a><dl> <dt><b>LVCFMT_FIXED_WIDTH</b></dt>
    ///</dl> </td> <td width="60%"> Version 6.00 and <b>Windows Vista.</b> Can't resize the column; same as
    ///HDF_FIXEDWIDTH. </td> </tr> <tr> <td width="40%"><a id="LVCFMT_NO_DPI_SCALE"></a><a
    ///id="lvcfmt_no_dpi_scale"></a><dl> <dt><b>LVCFMT_NO_DPI_SCALE</b></dt> </dl> </td> <td width="60%"> Version 6.00
    ///and <b>Windows Vista.</b> If not set, CCM_DPISCALE will govern scaling up fixed width. </td> </tr> <tr> <td
    ///width="40%"><a id="LVCFMT_FIXED_RATIO"></a><a id="lvcfmt_fixed_ratio"></a><dl> <dt><b>LVCFMT_FIXED_RATIO</b></dt>
    ///</dl> </td> <td width="60%"> Version 6.00 and <b>Windows Vista.</b> Width will augment with the row height. </td>
    ///</tr> <tr> <td width="40%"><a id="LVCFMT_SPLITBUTTON"></a><a id="lvcfmt_splitbutton"></a><dl>
    ///<dt><b>LVCFMT_SPLITBUTTON</b></dt> </dl> </td> <td width="60%"> Version 6.00 and <b>Windows Vista.</b> Column is
    ///a split button (same as HDF_SPLITBUTTON). The header of the column displays a split button (same as
    ///HDF_SPLITBUTTON). </td> </tr> </table>
    int  fmt;
    ///Type: <b>int</b> Width of the column, in pixels.
    int  cx;
    ///Type: <b>LPTSTR</b> If column information is being set, this member is the address of a null-terminated string
    ///that contains the column header text. If the structure is receiving information about a column, this member
    ///specifies the address of the buffer that receives the column header text.
    PSTR pszText;
    ///Type: <b>int</b> Size in <b>TCHAR</b>s of the buffer pointed to by the <b>pszText</b> member. If the structure is
    ///not receiving information about a column, this member is ignored.
    int  cchTextMax;
    ///Type: <b>int</b> Index of subitem associated with the column.
    int  iSubItem;
    ///Type: <b>int</b> Version 4.70. Zero-based index of an image within the image list. The specified image will
    ///appear within the column.
    int  iImage;
    ///Type: <b>int</b> Version 4.70. Zero-based column offset. Column offset is in left-to-right order. For example,
    ///zero indicates the leftmost column.
    int  iOrder;
    ///Type: <b>int</b> <b>Windows Vista</b>. Minimum width of the column in pixels.
    int  cxMin;
    ///Type: <b>int</b> <b>Windows Vista</b>. Application-defined value typically used to store the default width of the
    ///column. This member is ignored by the list-view control.
    int  cxDefault;
    ///Type: <b>int</b> <b>Windows Vista</b>. Read-only. The ideal width of the column in pixels, as the column may
    ///currently be autosized to a lesser width.
    int  cxIdeal;
}

///Contains information about a column in report view. This structure is used both for creating and manipulating
///columns. This structure supersedes the LV_COLUMN structure.
struct LVCOLUMNW
{
    ///Type: <b>UINT</b> Variable specifying which members contain valid information. This member can be zero, or one or
    ///more of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="LVCF_FMT"></a><a id="lvcf_fmt"></a><dl> <dt><b>LVCF_FMT</b></dt> </dl> </td> <td width="60%"> The <b>fmt</b>
    ///member is valid. </td> </tr> <tr> <td width="40%"><a id="LVCF_WIDTH"></a><a id="lvcf_width"></a><dl>
    ///<dt><b>LVCF_WIDTH</b></dt> </dl> </td> <td width="60%"> The <b>cx</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="LVCF_TEXT"></a><a id="lvcf_text"></a><dl> <dt><b>LVCF_TEXT</b></dt> </dl> </td> <td
    ///width="60%"> The <b>pszText</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="LVCF_SUBITEM"></a><a
    ///id="lvcf_subitem"></a><dl> <dt><b>LVCF_SUBITEM</b></dt> </dl> </td> <td width="60%"> The <b>iSubItem</b> member
    ///is valid. </td> </tr> <tr> <td width="40%"><a id="LVCF_IMAGE"></a><a id="lvcf_image"></a><dl>
    ///<dt><b>LVCF_IMAGE</b></dt> </dl> </td> <td width="60%"> Version 4.70. The <b>iImage</b> member is valid. </td>
    ///</tr> <tr> <td width="40%"><a id="LVCF_ORDER"></a><a id="lvcf_order"></a><dl> <dt><b>LVCF_ORDER</b></dt> </dl>
    ///</td> <td width="60%"> Version 4.70. The <b>iOrder</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCF_MINWIDTH"></a><a id="lvcf_minwidth"></a><dl> <dt><b>LVCF_MINWIDTH</b></dt> </dl> </td> <td width="60%">
    ///Version 6.00 and <b>Windows Vista.</b>The <b>cxMin</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCF_DEFAULTWIDTH"></a><a id="lvcf_defaultwidth"></a><dl> <dt><b>LVCF_DEFAULTWIDTH</b></dt> </dl> </td> <td
    ///width="60%"> Version 6.00 and <b>Windows Vista.</b>The <b>cxDefault</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="LVCF_IDEALWIDTH"></a><a id="lvcf_idealwidth"></a><dl> <dt><b>LVCF_IDEALWIDTH</b></dt> </dl>
    ///</td> <td width="60%"> Version 6.00 and <b>Windows Vista.</b>The <b>cxIdeal</b> member is valid. </td> </tr>
    ///</table>
    uint  mask;
    ///Type: <b>int</b> Alignment of the column header and the subitem text in the column. The alignment of the leftmost
    ///column is always LVCFMT_LEFT; it cannot be changed. This member can be a combination of the following values.
    ///Note that not all combinations are valid. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="LVCFMT_LEFT"></a><a id="lvcfmt_left"></a><dl> <dt><b>LVCFMT_LEFT</b></dt> </dl> </td> <td
    ///width="60%"> Text is left-aligned. </td> </tr> <tr> <td width="40%"><a id="LVCFMT_RIGHT"></a><a
    ///id="lvcfmt_right"></a><dl> <dt><b>LVCFMT_RIGHT</b></dt> </dl> </td> <td width="60%"> Text is right-aligned. </td>
    ///</tr> <tr> <td width="40%"><a id="LVCFMT_CENTER"></a><a id="lvcfmt_center"></a><dl> <dt><b>LVCFMT_CENTER</b></dt>
    ///</dl> </td> <td width="60%"> Text is centered. </td> </tr> <tr> <td width="40%"><a id="LVCFMT_JUSTIFYMASK"></a><a
    ///id="lvcfmt_justifymask"></a><dl> <dt><b>LVCFMT_JUSTIFYMASK</b></dt> </dl> </td> <td width="60%"> A bitmask used
    ///to select those bits of <b>fmt</b> that control field justification. To check the format of a column, use a
    ///logical "and" to combine LCFMT_JUSTIFYMASK with <b>fmt</b>. You can then use a switch statement to determine
    ///whether the LVCFMT_LEFT, LVCFMT_RIGHT, or LVCFMT_CENTER bits are set. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCFMT_IMAGE"></a><a id="lvcfmt_image"></a><dl> <dt><b>LVCFMT_IMAGE</b></dt> </dl> </td> <td width="60%">
    ///Version 4.70. The item displays an image from an image list. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCFMT_BITMAP_ON_RIGHT"></a><a id="lvcfmt_bitmap_on_right"></a><dl> <dt><b>LVCFMT_BITMAP_ON_RIGHT</b></dt>
    ///</dl> </td> <td width="60%"> Version 4.70. The bitmap appears to the right of text. This does not affect an image
    ///from an image list assigned to the header item. </td> </tr> <tr> <td width="40%"><a
    ///id="LVCFMT_COL_HAS_IMAGES"></a><a id="lvcfmt_col_has_images"></a><dl> <dt><b>LVCFMT_COL_HAS_IMAGES</b></dt> </dl>
    ///</td> <td width="60%"> Version 4.70. The header item contains an image in the image list. </td> </tr> <tr> <td
    ///width="40%"><a id="LVCFMT_FIXED_WIDTH"></a><a id="lvcfmt_fixed_width"></a><dl> <dt><b>LVCFMT_FIXED_WIDTH</b></dt>
    ///</dl> </td> <td width="60%"> Version 6.00 and <b>Windows Vista.</b> Can't resize the column; same as
    ///HDF_FIXEDWIDTH. </td> </tr> <tr> <td width="40%"><a id="LVCFMT_NO_DPI_SCALE"></a><a
    ///id="lvcfmt_no_dpi_scale"></a><dl> <dt><b>LVCFMT_NO_DPI_SCALE</b></dt> </dl> </td> <td width="60%"> Version 6.00
    ///and <b>Windows Vista.</b> If not set, CCM_DPISCALE will govern scaling up fixed width. </td> </tr> <tr> <td
    ///width="40%"><a id="LVCFMT_FIXED_RATIO"></a><a id="lvcfmt_fixed_ratio"></a><dl> <dt><b>LVCFMT_FIXED_RATIO</b></dt>
    ///</dl> </td> <td width="60%"> Version 6.00 and <b>Windows Vista.</b> Width will augment with the row height. </td>
    ///</tr> <tr> <td width="40%"><a id="LVCFMT_SPLITBUTTON"></a><a id="lvcfmt_splitbutton"></a><dl>
    ///<dt><b>LVCFMT_SPLITBUTTON</b></dt> </dl> </td> <td width="60%"> Version 6.00 and <b>Windows Vista.</b> Column is
    ///a split button (same as HDF_SPLITBUTTON). The header of the column displays a split button (same as
    ///HDF_SPLITBUTTON). </td> </tr> </table>
    int   fmt;
    ///Type: <b>int</b> Width of the column, in pixels.
    int   cx;
    ///Type: <b>LPTSTR</b> If column information is being set, this member is the address of a null-terminated string
    ///that contains the column header text. If the structure is receiving information about a column, this member
    ///specifies the address of the buffer that receives the column header text.
    PWSTR pszText;
    ///Type: <b>int</b> Size in <b>TCHAR</b>s of the buffer pointed to by the <b>pszText</b> member. If the structure is
    ///not receiving information about a column, this member is ignored.
    int   cchTextMax;
    ///Type: <b>int</b> Index of subitem associated with the column.
    int   iSubItem;
    ///Type: <b>int</b> Version 4.70. Zero-based index of an image within the image list. The specified image will
    ///appear within the column.
    int   iImage;
    ///Type: <b>int</b> Version 4.70. Zero-based column offset. Column offset is in left-to-right order. For example,
    ///zero indicates the leftmost column.
    int   iOrder;
    ///Type: <b>int</b> <b>Windows Vista</b>. Minimum width of the column in pixels.
    int   cxMin;
    ///Type: <b>int</b> <b>Windows Vista</b>. Application-defined value typically used to store the default width of the
    ///column. This member is ignored by the list-view control.
    int   cxDefault;
    ///Type: <b>int</b> <b>Windows Vista</b>. Read-only. The ideal width of the column in pixels, as the column may
    ///currently be autosized to a lesser width.
    int   cxIdeal;
}

///Contains information about the background image of a list-view control. This structure is used for both setting and
///retrieving background image information.
struct LVBKIMAGEA
{
    ///Type: <b>ULONG</b> This member may be one or more of the following flags. You can use the LVBKIF_SOURCE_MASK
    ///value to mask off all but the source flags. You can use the LVBKIF_STYLE_MASK value to mask off all but the style
    ///flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LVBKIF_SOURCE_NONE"></a><a
    ///id="lvbkif_source_none"></a><dl> <dt><b>LVBKIF_SOURCE_NONE</b></dt> </dl> </td> <td width="60%"> The list-view
    ///control has no background image. </td> </tr> <tr> <td width="40%"><a id="LVBKIF_SOURCE_HBITMAP"></a><a
    ///id="lvbkif_source_hbitmap"></a><dl> <dt><b>LVBKIF_SOURCE_HBITMAP</b></dt> </dl> </td> <td width="60%"> A
    ///background bitmap is supplied via the <b>hbm</b> member of <b>LVBKIMAGE</b>. If the message LVM_SETBKIMAGE
    ///succeeds, then the list-view takes ownership of the bitmap. </td> </tr> <tr> <td width="40%"><a
    ///id="LVBKIF_SOURCE_URL"></a><a id="lvbkif_source_url"></a><dl> <dt><b>LVBKIF_SOURCE_URL</b></dt> </dl> </td> <td
    ///width="60%"> The <b>pszImage</b> member contains the URL of the background image. </td> </tr> <tr> <td
    ///width="40%"><a id="LVBKIF_STYLE_NORMAL"></a><a id="lvbkif_style_normal"></a><dl>
    ///<dt><b>LVBKIF_STYLE_NORMAL</b></dt> </dl> </td> <td width="60%"> The background image is displayed normally.
    ///</td> </tr> <tr> <td width="40%"><a id="LVBKIF_STYLE_TILE"></a><a id="lvbkif_style_tile"></a><dl>
    ///<dt><b>LVBKIF_STYLE_TILE</b></dt> </dl> </td> <td width="60%"> The background image will be tiled to fill the
    ///entire background of the control. </td> </tr> <tr> <td width="40%"><a id="LVBKIF_FLAG_TILEOFFSET"></a><a
    ///id="lvbkif_flag_tileoffset"></a><dl> <dt><b>LVBKIF_FLAG_TILEOFFSET</b></dt> </dl> </td> <td width="60%"> Specify
    ///the coordinates of the first tile. This flag is valid only if the <b>LVBKIF_STYLE_TILE</b> flag is also
    ///specified. If this flag is not specified, the first tile begins at the upper-left corner of the client area. If
    ///you use ComCtl32.dll Version 6.0 the <b>xOffsetPercent</b> and <b>yOffsetPercent</b> fields contain pixels, not
    ///percentage values, to specify the coordinates of the first tile. Comctl32.dll version 6 is not redistributable
    ///but it is included in Windows or later. Also, you must specify Comctl32.dll version 6 in a manifest. For more
    ///information on manifests, see Enabling Visual Styles. </td> </tr> <tr> <td width="40%"><a
    ///id="LVBKIF_TYPE_WATERMARK"></a><a id="lvbkif_type_watermark"></a><dl> <dt><b>LVBKIF_TYPE_WATERMARK</b></dt> </dl>
    ///</td> <td width="60%"> A watermark background bitmap is supplied via the <b>hbm</b> member of <b>LVBKIMAGE</b>.
    ///If the LVM_SETBKIMAGE message succeeds, then the list-view control takes ownership of the bitmap. </td> </tr>
    ///<tr> <td width="40%"><a id="LVBKIF_FLAG_ALPHABLEND"></a><a id="lvbkif_flag_alphablend"></a><dl>
    ///<dt><b>LVBKIF_FLAG_ALPHABLEND</b></dt> </dl> </td> <td width="60%"> Valid only when LVBKIF_TYPE_WATERMARK is also
    ///specified. This flag indicates the bitmap provided via LVBKIF_TYPE_WATERMARK contains a valid alpha channel.
    ///</td> </tr> </table>
    uint    ulFlags;
    ///Type: <b>HBITMAP</b> The handle of the background bitmap. This member is valid only if the
    ///<b>LVBKIF_SOURCE_HBITMAP</b> flag is set in <b>ulFlags</b>.
    HBITMAP hbm;
    ///Type: <b>LPTSTR</b> Address of a NULL-terminated string that contains the URL of the background image. This
    ///member is valid only if the <b>LVBKIF_SOURCE_URL</b> flag is set in <b>ulFlags</b>. This member must be
    ///initialized to point to the buffer that contains or receives the text before sending the message.
    PSTR    pszImage;
    ///Type: <b>UINT</b> Size of the buffer at the address in <b>pszImage</b>. If information is being sent to the
    ///control, this member is ignored.
    uint    cchImageMax;
    ///Type: <b>int</b> Percentage of the control's client area that the image should be offset horizontally. For
    ///example, at 0 percent, the image will be displayed against the left edge of the control's client area. At 50
    ///percent, the image will be displayed horizontally centered in the control's client area. At 100 percent, the
    ///image will be displayed against the right edge of the control's client area. This member is valid only when
    ///<b>LVBKIF_STYLE_NORMAL</b> is specified in <b>ulFlags</b>. If both <b>LVBKIF_FLAG_TILEOFFSET</b> and
    ///<b>LVBKIF_STYLE_TILE</b> are specified in <b>ulFlags</b>, then the value specifies the pixel, not percentage
    ///offset, of the first tile. Otherwise, the value is ignored.
    int     xOffsetPercent;
    ///Type: <b>int</b> Percentage of the control's client area that the image should be offset vertically. For example,
    ///at 0 percent, the image will be displayed against the top edge of the control's client area. At 50 percent, the
    ///image will be displayed vertically centered in the control's client area. At 100 percent, the image will be
    ///displayed against the bottom edge of the control's client area. This member is valid only when
    ///<b>LVBKIF_STYLE_NORMAL</b> is specified in <b>ulFlags</b>. If both <b>LVBKIF_FLAG_TILEOFFSET</b> and
    ///<b>LVBKIF_STYLE_TILE</b> are specified in <b>ulFlags</b>, then the value specifies the pixel, not percentage
    ///offset, of the first tile. Otherwise, the value is ignored.
    int     yOffsetPercent;
}

///Contains information about the background image of a list-view control. This structure is used for both setting and
///retrieving background image information.
struct LVBKIMAGEW
{
    ///Type: <b>ULONG</b> This member may be one or more of the following flags. You can use the LVBKIF_SOURCE_MASK
    ///value to mask off all but the source flags. You can use the LVBKIF_STYLE_MASK value to mask off all but the style
    ///flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LVBKIF_SOURCE_NONE"></a><a
    ///id="lvbkif_source_none"></a><dl> <dt><b>LVBKIF_SOURCE_NONE</b></dt> </dl> </td> <td width="60%"> The list-view
    ///control has no background image. </td> </tr> <tr> <td width="40%"><a id="LVBKIF_SOURCE_HBITMAP"></a><a
    ///id="lvbkif_source_hbitmap"></a><dl> <dt><b>LVBKIF_SOURCE_HBITMAP</b></dt> </dl> </td> <td width="60%"> A
    ///background bitmap is supplied via the <b>hbm</b> member of <b>LVBKIMAGE</b>. If the message LVM_SETBKIMAGE
    ///succeeds, then the list-view takes ownership of the bitmap. </td> </tr> <tr> <td width="40%"><a
    ///id="LVBKIF_SOURCE_URL"></a><a id="lvbkif_source_url"></a><dl> <dt><b>LVBKIF_SOURCE_URL</b></dt> </dl> </td> <td
    ///width="60%"> The <b>pszImage</b> member contains the URL of the background image. </td> </tr> <tr> <td
    ///width="40%"><a id="LVBKIF_STYLE_NORMAL"></a><a id="lvbkif_style_normal"></a><dl>
    ///<dt><b>LVBKIF_STYLE_NORMAL</b></dt> </dl> </td> <td width="60%"> The background image is displayed normally.
    ///</td> </tr> <tr> <td width="40%"><a id="LVBKIF_STYLE_TILE"></a><a id="lvbkif_style_tile"></a><dl>
    ///<dt><b>LVBKIF_STYLE_TILE</b></dt> </dl> </td> <td width="60%"> The background image will be tiled to fill the
    ///entire background of the control. </td> </tr> <tr> <td width="40%"><a id="LVBKIF_FLAG_TILEOFFSET"></a><a
    ///id="lvbkif_flag_tileoffset"></a><dl> <dt><b>LVBKIF_FLAG_TILEOFFSET</b></dt> </dl> </td> <td width="60%"> Specify
    ///the coordinates of the first tile. This flag is valid only if the <b>LVBKIF_STYLE_TILE</b> flag is also
    ///specified. If this flag is not specified, the first tile begins at the upper-left corner of the client area. If
    ///you use ComCtl32.dll Version 6.0 the <b>xOffsetPercent</b> and <b>yOffsetPercent</b> fields contain pixels, not
    ///percentage values, to specify the coordinates of the first tile. Comctl32.dll version 6 is not redistributable
    ///but it is included in Windows or later. Also, you must specify Comctl32.dll version 6 in a manifest. For more
    ///information on manifests, see Enabling Visual Styles. </td> </tr> <tr> <td width="40%"><a
    ///id="LVBKIF_TYPE_WATERMARK"></a><a id="lvbkif_type_watermark"></a><dl> <dt><b>LVBKIF_TYPE_WATERMARK</b></dt> </dl>
    ///</td> <td width="60%"> A watermark background bitmap is supplied via the <b>hbm</b> member of <b>LVBKIMAGE</b>.
    ///If the LVM_SETBKIMAGE message succeeds, then the list-view control takes ownership of the bitmap. </td> </tr>
    ///<tr> <td width="40%"><a id="LVBKIF_FLAG_ALPHABLEND"></a><a id="lvbkif_flag_alphablend"></a><dl>
    ///<dt><b>LVBKIF_FLAG_ALPHABLEND</b></dt> </dl> </td> <td width="60%"> Valid only when LVBKIF_TYPE_WATERMARK is also
    ///specified. This flag indicates the bitmap provided via LVBKIF_TYPE_WATERMARK contains a valid alpha channel.
    ///</td> </tr> </table>
    uint    ulFlags;
    ///Type: <b>HBITMAP</b> The handle of the background bitmap. This member is valid only if the
    ///<b>LVBKIF_SOURCE_HBITMAP</b> flag is set in <b>ulFlags</b>.
    HBITMAP hbm;
    ///Type: <b>LPTSTR</b> Address of a NULL-terminated string that contains the URL of the background image. This
    ///member is valid only if the <b>LVBKIF_SOURCE_URL</b> flag is set in <b>ulFlags</b>. This member must be
    ///initialized to point to the buffer that contains or receives the text before sending the message.
    PWSTR   pszImage;
    ///Type: <b>UINT</b> Size of the buffer at the address in <b>pszImage</b>. If information is being sent to the
    ///control, this member is ignored.
    uint    cchImageMax;
    ///Type: <b>int</b> Percentage of the control's client area that the image should be offset horizontally. For
    ///example, at 0 percent, the image will be displayed against the left edge of the control's client area. At 50
    ///percent, the image will be displayed horizontally centered in the control's client area. At 100 percent, the
    ///image will be displayed against the right edge of the control's client area. This member is valid only when
    ///<b>LVBKIF_STYLE_NORMAL</b> is specified in <b>ulFlags</b>. If both <b>LVBKIF_FLAG_TILEOFFSET</b> and
    ///<b>LVBKIF_STYLE_TILE</b> are specified in <b>ulFlags</b>, then the value specifies the pixel, not percentage
    ///offset, of the first tile. Otherwise, the value is ignored.
    int     xOffsetPercent;
    ///Type: <b>int</b> Percentage of the control's client area that the image should be offset vertically. For example,
    ///at 0 percent, the image will be displayed against the top edge of the control's client area. At 50 percent, the
    ///image will be displayed vertically centered in the control's client area. At 100 percent, the image will be
    ///displayed against the bottom edge of the control's client area. This member is valid only when
    ///<b>LVBKIF_STYLE_NORMAL</b> is specified in <b>ulFlags</b>. If both <b>LVBKIF_FLAG_TILEOFFSET</b> and
    ///<b>LVBKIF_STYLE_TILE</b> are specified in <b>ulFlags</b>, then the value specifies the pixel, not percentage
    ///offset, of the first tile. Otherwise, the value is ignored.
    int     yOffsetPercent;
}

///Used to set and retrieve groups.
struct LVGROUP
{
    ///Type: <b>UINT</b> Size of this structure, in bytes.
    uint  cbSize;
    ///Type: <b>UINT</b> Mask that specifies which members of the structure are valid input. One or more of the
    ///following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="LVGF_NONE"></a><a id="lvgf_none"></a><dl> <dt><b>LVGF_NONE</b></dt> </dl> </td> <td width="60%"> No other
    ///items are valid. </td> </tr> <tr> <td width="40%"><a id="LVGF_HEADER"></a><a id="lvgf_header"></a><dl>
    ///<dt><b>LVGF_HEADER</b></dt> </dl> </td> <td width="60%"> <b>pszHeader</b> and <b>cchHeader</b> members are valid.
    ///</td> </tr> <tr> <td width="40%"><a id="LVGF_FOOTER"></a><a id="lvgf_footer"></a><dl> <dt><b>LVGF_FOOTER</b></dt>
    ///</dl> </td> <td width="60%"> <b>pszFooter</b> and <b>cchFooter</b> members are valid. </td> </tr> <tr> <td
    ///width="40%"><a id="LVGF_STATE"></a><a id="lvgf_state"></a><dl> <dt><b>LVGF_STATE</b></dt> </dl> </td> <td
    ///width="60%"> <b>state</b> and <b>stateMask</b> members are valid. </td> </tr> <tr> <td width="40%"><a
    ///id=""></a><dl> <dt><b></b></dt> <dt>LVGF_ALIGN</dt> </dl> </td> <td width="60%"> <b>uAlign</b> member is valid.
    ///</td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGF_GROUPID</dt> </dl> </td> <td
    ///width="60%"> <b>iGroupId</b> member is valid. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///<dt>LVGF_SUBTITLE</dt> </dl> </td> <td width="60%"> Version 6.00 and later. The <b>pszSubtitle</b> member is
    ///valid. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGF_TASK</dt> </dl> </td> <td
    ///width="60%"> Version 6.00 and later. The <b>pszTask</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id=""></a><dl> <dt><b></b></dt> <dt>LVGF_DESCRIPTIONTOP</dt> </dl> </td> <td width="60%"> Version 6.00 and later.
    ///The <b>pszDescriptionTop</b> member is valid. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///<dt>LVGF_DESCRIPTIONBOTTOM</dt> </dl> </td> <td width="60%"> Version 6.00 and later. The
    ///<b>pszDescriptionBottom</b> member is valid. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///<dt>LVGF_TITLEIMAGE</dt> </dl> </td> <td width="60%"> Version 6.00 and later. The <b>iTitleImage</b> member is
    ///valid. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGF_EXTENDEDIMAGE</dt> </dl>
    ///</td> <td width="60%"> Version 6.00 and later. The <b>iExtendedImage</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGF_ITEMS</dt> </dl> </td> <td width="60%"> Version 6.00 and
    ///later. The <b>cItems</b> member is valid. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///<dt>LVGF_SUBSET</dt> </dl> </td> <td width="60%"> Version 6.00 and later. The <b>pszSubsetTitle</b> member is
    ///valid. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGF_SUBSETITEMS</dt> </dl> </td>
    ///<td width="60%"> Version 6.00 and later. The <b>cchSubsetTitle</b> member is valid. </td> </tr> </table>
    uint  mask;
    ///Type: <b>LPWSTR</b> Pointer to a null-terminated string that contains the header text when item information is
    ///being set. If group information is being retrieved, this member specifies the address of the buffer that receives
    ///the header text.
    PWSTR pszHeader;
    ///Type: <b>int</b> Size in <b>TCHAR</b>s of the buffer pointed to by the <b>pszHeader</b> member. If the structure
    ///is not receiving information about a group, this member is ignored.
    int   cchHeader;
    ///Type: <b>LPWSTR</b> Pointer to a null-terminated string that contains the footer text when item information is
    ///being set. If group information is being retrieved, this member specifies the address of the buffer that receives
    ///the footer text.
    PWSTR pszFooter;
    ///Type: <b>int</b> Size in <b>TCHAR</b>s of the buffer pointed to by the <b>pszFooter</b> member. If the structure
    ///is not receiving information about a group, this member is ignored.
    int   cchFooter;
    ///Type: <b>int</b> ID of the group.
    int   iGroupId;
    ///Type: <b>UINT</b> Mask used with LVM_GETGROUPINFO and LVM_SETGROUPINFO to specify which flags in the <b>state</b>
    ///value are being retrieved or set.
    uint  stateMask;
    ///Type: <b>UINT</b> Flag that can have one of the following values: <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGS_NORMAL</dt> </dl> </td> <td width="60%">
    ///Groups are expanded, the group name is displayed, and all items in the group are displayed. </td> </tr> <tr> <td
    ///width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGS_COLLAPSED</dt> </dl> </td> <td width="60%"> The group is
    ///collapsed. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGS_HIDDEN</dt> </dl> </td>
    ///<td width="60%"> The group is hidden. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///<dt>LVGS_NOHEADER</dt> </dl> </td> <td width="60%"> Version 6.00 and later. The group does not display a header.
    ///</td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGS_COLLAPSIBLE</dt> </dl> </td> <td
    ///width="60%"> Version 6.00 and later. The group can be collapsed. </td> </tr> <tr> <td width="40%"><a
    ///id=""></a><dl> <dt><b></b></dt> <dt>LVGS_FOCUSED</dt> </dl> </td> <td width="60%"> Version 6.00 and later. The
    ///group has keyboard focus. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///<dt>LVGS_SELECTED</dt> </dl> </td> <td width="60%"> Version 6.00 and later. The group is selected. </td> </tr>
    ///<tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGS_SUBSETED</dt> </dl> </td> <td width="60%">
    ///Version 6.00 and later. The group displays only a portion of its items. </td> </tr> <tr> <td width="40%"><a
    ///id=""></a><dl> <dt><b></b></dt> <dt>LVGS_SUBSETLINKFOCUSED</dt> </dl> </td> <td width="60%"> Version 6.00 and
    ///later. The subset link of the group has keyboard focus. </td> </tr> </table>
    uint  state;
    ///Type: <b>UINT</b> Indicates the alignment of the header or footer text for the group. It can have one or more of
    ///the following values. Use one of the header flags. Footer flags are optional. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGA_FOOTER_CENTER</dt> </dl>
    ///</td> <td width="60%"> Footer text is centered horizontally in the window. </td> </tr> <tr> <td width="40%"><a
    ///id=""></a><dl> <dt><b></b></dt> <dt>LVGA_FOOTER_LEFT</dt> </dl> </td> <td width="60%"> Footer text is aligned at
    ///the left of the window. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///<dt>LVGA_FOOTER_RIGHT</dt> </dl> </td> <td width="60%"> Footer text is aligned at the right of the window. </td>
    ///</tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGA_HEADER_CENTER</dt> </dl> </td> <td
    ///width="60%"> Header text is centered horizontally in the window. </td> </tr> <tr> <td width="40%"><a
    ///id=""></a><dl> <dt><b></b></dt> <dt>LVGA_HEADER_LEFT</dt> </dl> </td> <td width="60%"> Header text is aligned at
    ///the left of the window. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///<dt>LVGA_HEADER_RIGHT</dt> </dl> </td> <td width="60%"> Header text is aligned at the right of the window. </td>
    ///</tr> </table>
    uint  uAlign;
    ///Type: <b>LPWSTR</b> Pointer to a null-terminated string that contains the subtitle text when item information is
    ///being set. If group information is being retrieved, this member specifies the address of the buffer that receives
    ///the subtitle text. This element is drawn under the header text.
    PWSTR pszSubtitle;
    ///Type: <b>UINT</b> Size, in <b>TCHAR</b>s, of the buffer pointed to by the <b>pszSubtitle</b> member. If the
    ///structure is not receiving information about a group, this member is ignored.
    uint  cchSubtitle;
    ///Type: <b>LPWSTR</b> Pointer to a null-terminated string that contains the text for a task link when item
    ///information is being set. If group information is being retrieved, this member specifies the address of the
    ///buffer that receives the task text. This item is drawn right-aligned opposite the header text. When clicked by
    ///the user, the task link generates an LVN_LINKCLICK notification.
    PWSTR pszTask;
    ///Type: <b>UINT</b> Size in <b>TCHAR</b>s of the buffer pointed to by the <b>pszTask</b> member. If the structure
    ///is not receiving information about a group, this member is ignored.
    uint  cchTask;
    ///Type: <b>LPWSTR</b> Pointer to a null-terminated string that contains the top description text when item
    ///information is being set. If group information is being retrieved, this member specifies the address of the
    ///buffer that receives the top description text. This item is drawn opposite the title image when there is a title
    ///image, no extended image, and <b>uAlign</b>==<b>LVGA_HEADER_CENTER</b>.
    PWSTR pszDescriptionTop;
    ///Type: <b>UINT</b> Size in <b>TCHAR</b>s of the buffer pointed to by the <b>pszDescriptionTop</b> member. If the
    ///structure is not receiving information about a group, this member is ignored.
    uint  cchDescriptionTop;
    ///Type: <b>LPWSTR</b> Pointer to a null-terminated string that contains the bottom description text when item
    ///information is being set. If group information is being retrieved, this member specifies the address of the
    ///buffer that receives the bottom description text. This item is drawn under the top description text when there is
    ///a title image, no extended image, and <b>uAlign</b>==<b>LVGA_HEADER_CENTER</b>.
    PWSTR pszDescriptionBottom;
    ///Type: <b>UINT</b> Size in <b>TCHAR</b>s of the buffer pointed to by the <b>pszDescriptionBottom</b> member. If
    ///the structure is not receiving information about a group, this member is ignored.
    uint  cchDescriptionBottom;
    ///Type: <b>int</b> Index of the title image in the control imagelist.
    int   iTitleImage;
    ///Type: <b>int</b> Index of the extended image in the control imagelist.
    int   iExtendedImage;
    ///Type: <b>int</b> Read-only.
    int   iFirstItem;
    ///Type: <b>UINT</b> Read-only in non-owner data mode.
    uint  cItems;
    ///Type: <b>LPWSTR</b> <b>NULL</b> if group is not a subset. Pointer to a null-terminated string that contains the
    ///subset title text when item information is being set. If group information is being retrieved, this member
    ///specifies the address of the buffer that receives the subset title text.
    PWSTR pszSubsetTitle;
    ///Type: <b>UINT</b> Size in <b>TCHAR</b>s of the buffer pointed to by the <b>pszSubsetTitle</b> member. If the
    ///structure is not receiving information about a group, this member is ignored.
    uint  cchSubsetTitle;
}

///Contains information about the display of groups in a list-view control.
struct LVGROUPMETRICS
{
    ///Type: <b>UINT</b> Size of the <b>LVGROUPMETRICS</b> structure.
    uint cbSize;
    ///Type: <b>UINT</b> Flags that specify which members contain or are to receive valid data. Can be one or more of
    ///the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl>
    ///<dt><b></b></dt> <dt>LVGMF_BORDERCOLOR</dt> </dl> </td> <td width="60%"> Not implemented. </td> </tr> <tr> <td
    ///width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGMF_BORDERSIZE</dt> </dl> </td> <td width="60%"> The
    ///<b>Left</b>, <b>Top</b>, <b>Right</b>, and <b>Bottom</b> members are valid. </td> </tr> <tr> <td width="40%"><a
    ///id=""></a><dl> <dt><b></b></dt> <dt>LVGMF_NONE</dt> </dl> </td> <td width="60%"> No members are valid. </td>
    ///</tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVGMF_TEXTCOLOR</dt> </dl> </td> <td
    ///width="60%"> Not implemented. </td> </tr> </table>
    uint mask;
    ///Type: <b>UINT</b> Specifies the width of the left border in icon, small icon, or tile view.
    uint Left;
    ///Type: <b>UINT</b> Specifies the width of the top border in all group views.
    uint Top;
    ///Type: <b>UINT</b> Specifies the width of the right border in icon, small icon, or tile view.
    uint Right;
    ///Type: <b>UINT</b> Specifies the width of the bottom border in all group views.
    uint Bottom;
    ///Type: <b>COLORREF</b> Specifies the color of the left border. Not implemented.
    uint crLeft;
    ///Type: <b>COLORREF</b> Specifies the color of the top border. Not implemented.
    uint crTop;
    ///Type: <b>COLORREF</b> Specifies the color of the right border. Not implemented.
    uint crRight;
    ///Type: <b>COLORREF</b> Specifies the color of the bottom border. Not implemented.
    uint crBottom;
    ///Type: <b>COLORREF</b> Specifies the color of the header text. Not implemented.
    uint crHeader;
    ///Type: <b>COLORREF</b> Specifies the color of the footer text. Not implemented.
    uint crFooter;
}

///Used to sort groups. It is used with LVM_INSERTGROUPSORTED.
struct LVINSERTGROUPSORTED
{
    ///Type: <b>PFNLVGROUPCOMPARE</b> Pointer to application-defined function LVGroupCompare that is used to sort the
    ///groups.
    PFNLVGROUPCOMPARE pfnGroupCompare;
    ///Type: <b>LPVOID*</b> Data to sort; this is application-defined.
    void*             pvData;
    ///Type: <b>LVGROUP</b> Group to sort; this is application-defined.
    LVGROUP           lvGroup;
}

///Provides information about a list-view control when it is displayed in tile view.
struct LVTILEVIEWINFO
{
    ///Type: <b>UINT</b> Size of the <b>LVTILEVIEWINFO</b> structure.
    uint cbSize;
    ///Type: <b>DWORD</b> Mask that determines which members are valid. This member may be one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///<dt>LVTVIM_TILESIZE</dt> </dl> </td> <td width="60%"> <b>sizeTile</b> is valid. </td> </tr> <tr> <td
    ///width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVTVIM_COLUMNS</dt> </dl> </td> <td width="60%"> <b>cLines</b>
    ///is valid. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVTVIM_LABELMARGIN</dt> </dl>
    ///</td> <td width="60%"> <b>rcLabelMargin</b> is valid. </td> </tr> </table>
    uint dwMask;
    ///Type: <b>DWORD</b> Flags that determines how the tiles are sized in tile view. This member may be one of the
    ///following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl>
    ///<dt><b></b></dt> <dt>LVTVIF_AUTOSIZE</dt> </dl> </td> <td width="60%"> Size the tiles automatically. </td> </tr>
    ///<tr> <td width="40%"><a id="LVTVIF_EXTENDED"></a><a id="lvtvif_extended"></a><dl> <dt><b>LVTVIF_EXTENDED</b></dt>
    ///</dl> </td> <td width="60%"> This flag is not supported and should not be used. </td> </tr> <tr> <td
    ///width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVTVIF_FIXEDWIDTH</dt> </dl> </td> <td width="60%"> Apply a
    ///fixed width to the tiles. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///<dt>LVTVIF_FIXEDHEIGHT</dt> </dl> </td> <td width="60%"> Apply a fixed height to the tiles. </td> </tr> <tr> <td
    ///width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>LVTVIF_FIXEDSIZE</dt> </dl> </td> <td width="60%"> Apply a
    ///fixed height and width to the tiles. </td> </tr> </table>
    uint dwFlags;
    ///Type: <b>SIZE</b> Size of an individual tile. Values for dimensions not specified as fixed in <b>dwFlags</b> are
    ///ignored.
    SIZE sizeTile;
    ///Type: <b>int</b> Maximum number of text lines in each item label, not counting the title.
    int  cLines;
    ///Type: <b>RECT</b> RECT that contains coordinates of the label margin.
    RECT rcLabelMargin;
}

///Provides information about an item in a list-view control when it is displayed in tile view.
struct LVTILEINFO
{
    ///Type: <b>UINT</b> The size of the <b>LVTILEINFO</b> structure.
    uint  cbSize;
    ///Type: <b>int</b> The item for which the information is retrieved or set.
    int   iItem;
    ///Type: <b>UINT</b> The number of data columns displayed for this item. When retrieving information, initialize
    ///this value to the size of the <b>puColumns</b> array. On return, the member is set to the number of columns
    ///actually set for the item.
    uint  cColumns;
    ///Type: <b>PUINT</b> A pointer to an array of column indices, specifying which columns are displayed for this item,
    ///and the order of those columns. When retrieving information, allocate an array large enough to hold the greatest
    ///number of columns expected.
    uint* puColumns;
    ///Type: <b>int*</b> A pointer to an array of column formats (for example, LVCFMT_LEFT), one for each of the columns
    ///specified in <b>puColumns</b>. When retrieving information, allocate an array large enough to hold the greatest
    ///number of column formats expected.
    int*  piColFmt;
}

///Used to describe insertion points.
struct LVINSERTMARK
{
    ///Type: <b>UINT</b> Size of the <b>LVINSERTMARK</b> structure.
    uint cbSize;
    ///Type: <b>DWORD</b> Flag that specifies where the insertion point should appear. Use the following: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LVIM_AFTER"></a><a id="lvim_after"></a><dl>
    ///<dt><b>LVIM_AFTER</b></dt> </dl> </td> <td width="60%"> The insertion point appears after the item specified if
    ///the LVIM_AFTER flag is set; otherwise it appears before the specified item. </td> </tr> </table>
    uint dwFlags;
    ///Type: <b>int</b> Item next to which the insertion point appears. If this member contains -1, there is no
    ///insertion point.
    int  iItem;
    uint dwReserved;
}

///Provides information about tooltip text that is to be set.
struct LVSETINFOTIP
{
    ///Type: <b>UINT</b> Size of the <b>LVSETINFOTIP</b> structure.
    uint  cbSize;
    ///Type: <b>DWORD</b> Flag that specifies how the text should be set. Set to zero.
    uint  dwFlags;
    ///Type: <b>LPWSTR</b> Pointer to a Unicode string that contains the tooltip text.
    PWSTR pszText;
    ///Type: <b>int</b> Value of type <b>int</b> that contains the zero-based index of the item to which this structure
    ///refers.
    int   iItem;
    int   iSubItem;
}

///Contains information on a footer in a list-view control.
struct LVFOOTERINFO
{
    ///Type: <b>UINT</b> Set of flags that specify which members of this structure contain data to be set or which
    ///members are being requested. Currently, this value must be LVFF_ITEMCOUNT, for the <b>cItems</b> member.
    uint  mask;
    ///Type: <b>LPWSTR</b> Not supported. Must be set to zero.
    PWSTR pszText;
    ///Type: <b>int</b> Not supported. Must be set to zero.
    int   cchTextMax;
    ///Type: <b>UINT</b> The number of items in the footer. When this structure is used to get information, this member
    ///will be set by the message receiver.
    uint  cItems;
}

///Contains information on a footer item.
struct LVFOOTERITEM
{
    ///Type: <b>UINT</b> Set of flags that specify which members of this structure contain data to be set or which
    ///members are being requested. This parameter must be one of the following values: <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="LVFIF_TEXT"></a><a id="lvfif_text"></a><dl>
    ///<dt><b>LVFIF_TEXT</b></dt> </dl> </td> <td width="60%"> The <b>pszText</b> member is valid input from the caller
    ///or is requested and thus should be set by the receiver. </td> </tr> <tr> <td width="40%"><a
    ///id="LVFIF_STATE"></a><a id="lvfif_state"></a><dl> <dt><b>LVFIF_STATE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>state</b> member is valid input from the caller or is requested and thus should be set by the receiver. </td>
    ///</tr> </table>
    uint  mask;
    ///Type: <b>int</b> The index of the item.
    int   iItem;
    ///Type: <b>LPWSTR</b> A pointer to a null-terminated, Unicode buffer. The calling process is responsible for
    ///allocating the buffer.
    PWSTR pszText;
    ///Type: <b>int</b> The number of <b>WCHAR</b><b>s</b> in the buffer pointed to by <b>pszText</b>, including the
    ///terminating <b>NULL</b>.
    int   cchTextMax;
    ///Type: <b>UINT</b> Indicates the item's state. The <b>stateMask</b> member indicates the valid bits of this
    ///member. Currently, <b>state</b> must be set to the following: <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="LVFIS_FOCUSED"></a><a id="lvfis_focused"></a><dl> <dt><b>LVFIS_FOCUSED</b></dt> </dl>
    ///</td> <td width="60%"> Bit indicating focus state. Set if the item is in focus, otherwise cleared. </td> </tr>
    ///</table>
    uint  state;
    ///Type: <b>UINT</b> Value specifying which bits of the <b>state</b> member will be retrieved or modified.
    ///Currently, this value must be the following: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="LVFIS_FOCUSED"></a><a id="lvfis_focused"></a><dl> <dt><b>LVFIS_FOCUSED</b></dt> </dl> </td>
    ///<td width="60%"> The LVFIS_FOCUSED bit of member <b>state</b> is valid. For example, setting this member to
    ///LVFIS_FOCUSED will cause the focus state to be retrieved to member <b>state</b>. </td> </tr> </table>
    uint  stateMask;
}

///Contains index information about a list-view item.
struct LVITEMINDEX
{
    ///Type: <b>int</b> The index of the item.
    int iItem;
    ///Type: <b>int</b> The index of the group the item belongs to.
    int iGroup;
}

///Contains information about a list-view notification message. This structure is the same as the <b>NM_LISTVIEW</b>
///structure but has been renamed to fit standard naming conventions.
struct NMLISTVIEW
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification message.
    NMHDR  hdr;
    ///Type: <b>int</b> Identifies the list-view item, or -1 if not used.
    int    iItem;
    ///Type: <b>int</b> Identifies the subitem, or zero if none.
    int    iSubItem;
    ///Type: <b>UINT</b> New item state. This member is zero for notification messages that do not use it. For a list of
    ///possible values, see List-View Item States.
    uint   uNewState;
    ///Type: <b>UINT</b> Old item state. This member is zero for notification messages that do not use it. For a list of
    ///possible values, see List-View Item States.
    uint   uOldState;
    ///Type: <b>UINT</b> Set of flags that indicate the item attributes that have changed. This member is zero for
    ///notifications that do not use it. Otherwise, it can have the same values as the <b>mask</b> member of the LVITEM
    ///structure.
    uint   uChanged;
    ///Type: <b>POINT</b> POINT structure that indicates the location at which the event occurred. This member is
    ///undefined for notification messages that do not use it.
    POINT  ptAction;
    LPARAM lParam;
}

///Contains information about an LVN_ITEMACTIVATE notification code.
struct NMITEMACTIVATE
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification code.
    NMHDR  hdr;
    ///Type: <b>int</b> Index of the list-view item. If the item index is not used for the notification, this member
    ///will contain -1.
    int    iItem;
    ///Type: <b>int</b> One-based index of the subitem. If the subitem index is not used for the notification or the
    ///notification does not apply to a subitem, this member will contain zero.
    int    iSubItem;
    ///Type: <b>UINT</b> New item state. This member is zero for notification codes that do not use it.
    uint   uNewState;
    ///Type: <b>UINT</b> Old item state. This member is zero for notification codes that do not use it.
    uint   uOldState;
    ///Type: <b>UINT</b> Set of flags that indicate the item attributes that have changed. This member is zero for
    ///notifications that do not use it. Otherwise, it can have the same values as the <b>mask</b> member of the LVITEM
    ///structure.
    uint   uChanged;
    ///Type: <b>POINT</b> POINT structure that indicates the location at which the event occurred, in client
    ///coordinates. This member is undefined for notification codes that do not use it.
    POINT  ptAction;
    ///Type: <b>LPARAM</b> Application-defined value of the item. This member is undefined for notification codes that
    ///do not use it.
    LPARAM lParam;
    uint   uKeyFlags;
}

///Contains information specific to an NM_CUSTOMDRAW (list view) notification code sent by a list-view control.
struct NMLVCUSTOMDRAW
{
    ///Type: <b>NMCUSTOMDRAW</b> NMCUSTOMDRAW structure that contains general custom draw information.
    NMCUSTOMDRAW nmcd;
    ///Type: <b>COLORREF</b> <b>COLORREF</b> value representing the color that will be used to display text foreground
    ///in the list-view control.
    uint         clrText;
    ///Type: <b>COLORREF</b> <b>COLORREF</b> value representing the color that will be used to display text background
    ///in the list-view control. In Version 6.0., this member is ignored if the background image is set with the
    ///LVM_SETBKIMAGE message.
    uint         clrTextBk;
    ///Type: <b>int</b> Version 4.71. Index of the subitem that is being drawn. If the main item is being drawn, this
    ///member will be zero.
    int          iSubItem;
    ///Type: <b>DWORD</b> Version 6.0. <b>DWORD</b> that contains the type of the item to draw. This member can be one
    ///of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="LVCDI_ITEM"></a><a id="lvcdi_item"></a><dl> <dt><b>LVCDI_ITEM</b></dt> </dl> </td> <td width="60%"> An item
    ///is to be drawn. </td> </tr> <tr> <td width="40%"><a id="LVCDI_GROUP"></a><a id="lvcdi_group"></a><dl>
    ///<dt><b>LVCDI_GROUP</b></dt> </dl> </td> <td width="60%"> A group is to be drawn. </td> </tr> <tr> <td
    ///width="40%"><a id="LVCDI_ITEMSLIST"></a><a id="lvcdi_itemslist"></a><dl> <dt><b>LVCDI_ITEMSLIST</b></dt> </dl>
    ///</td> <td width="60%"> Every item is to be drawn. </td> </tr> </table>
    uint         dwItemType;
    ///Type: <b>COLORREF</b> Version 6.0. <b>COLORREF</b> value representing the color that will be used to display the
    ///face of an item.
    uint         clrFace;
    ///Type: <b>int</b> Version 6.0. Value of type <b>int</b> that specifies the effect that is applied to an icon, such
    ///as Glow, Shadow, or Pulse.
    int          iIconEffect;
    ///Type: <b>int</b> Version 6.0. Value of type <b>int</b> that specifies the phase of an icon.
    int          iIconPhase;
    ///Type: <b>int</b> Version 6.0. Value of type <b>int</b> that specifies the ID of the part of an item to draw.
    int          iPartId;
    ///Type: <b>int</b> Version 6.0. Value of type <b>int</b> that specifies the ID of the state of an item to draw.
    int          iStateId;
    ///Type: <b>RECT</b> Version 6.0. <b>RECT</b> that specifies the rectangle in which the text is to be drawn.
    RECT         rcText;
    ///Type: <b>UINT</b> Version 6.0. <b>UINT</b> that specifies how a group should be aligned. This member can be one
    ///of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="LVGA_HEADER_CENTER"></a><a id="lvga_header_center"></a><dl> <dt><b>LVGA_HEADER_CENTER</b></dt> </dl> </td>
    ///<td width="60%"> Center the group. </td> </tr> <tr> <td width="40%"><a id="LVGA_HEADER_LEFT"></a><a
    ///id="lvga_header_left"></a><dl> <dt><b>LVGA_HEADER_LEFT</b></dt> </dl> </td> <td width="60%"> Align the group on
    ///the left. </td> </tr> <tr> <td width="40%"><a id="LVGA_HEADER_RIGHT"></a><a id="lvga_header_right"></a><dl>
    ///<dt><b>LVGA_HEADER_RIGHT</b></dt> </dl> </td> <td width="60%"> Align the group on the right. </td> </tr> </table>
    uint         uAlign;
}

///Contains information used to update the cached item information for use with a virtual list view.
struct NMLVCACHEHINT
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification message.
    NMHDR hdr;
    ///Type: <b>int</b> Starting index of the requested range of items. This value is inclusive.
    int   iFrom;
    int   iTo;
}

///Contains information the owner needs to find items requested by a virtual list-view control. This structure is used
///with the LVN_ODFINDITEM notification code.
struct NMLVFINDITEMA
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information on this notification code.
    NMHDR       hdr;
    ///Type: <b>int</b> Index of the item at which the search will start.
    int         iStart;
    ///Type: <b>LVFINDINFO</b> LVFINDINFO structure that contains information necessary to perform a search.
    LVFINDINFOA lvfi;
}

///Contains information the owner needs to find items requested by a virtual list-view control. This structure is used
///with the LVN_ODFINDITEM notification code.
struct NMLVFINDITEMW
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information on this notification code.
    NMHDR       hdr;
    ///Type: <b>int</b> Index of the item at which the search will start.
    int         iStart;
    ///Type: <b>LVFINDINFO</b> LVFINDINFO structure that contains information necessary to perform a search.
    LVFINDINFOW lvfi;
}

///Structure that contains information for use in processing the LVN_ODSTATECHANGED notification code.
struct NMLVODSTATECHANGE
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR hdr;
    ///Type: <b>int</b> Zero-based index of the first item in the range of items.
    int   iFrom;
    ///Type: <b>int</b> Zero-based index of the last item in the range of items.
    int   iTo;
    ///Type: <b>UINT</b> Value indicating the new state for the item or items. This member can be any valid combination
    ///of the list-view item states.
    uint  uNewState;
    uint  uOldState;
}

///Contains information about an LVN_GETDISPINFO or LVN_SETDISPINFO notification code. This structure is the same as the
///<b>LV_DISPINFO</b> structure, but has been renamed to fit standard naming conventions.
struct NMLVDISPINFOA
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification code.
    NMHDR   hdr;
    ///Type: <b>LVITEM</b> LVITEM structure that identifies the item or subitem. The structure either contains or
    ///receives information about the item. The <b>mask</b> member contains a set of bit flags that specify which item
    ///attributes are relevant. For more information on the available bit flags, see <b>LVITEM</b>.
    LVITEMA item;
}

///Contains information about an LVN_GETDISPINFO or LVN_SETDISPINFO notification code. This structure is the same as the
///<b>LV_DISPINFO</b> structure, but has been renamed to fit standard naming conventions.
struct NMLVDISPINFOW
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification code.
    NMHDR   hdr;
    ///Type: <b>LVITEM</b> LVITEM structure that identifies the item or subitem. The structure either contains or
    ///receives information about the item. The <b>mask</b> member contains a set of bit flags that specify which item
    ///attributes are relevant. For more information on the available bit flags, see <b>LVITEM</b>.
    LVITEMW item;
}

///Contains information used in processing the LVN_KEYDOWN notification code. This structure is the same as the
///<b>NMLVKEYDOWN</b> structure but has been renamed to fit standard naming conventions.
struct NMLVKEYDOWN
{
align (1):
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR  hdr;
    ///Type: <b>WORD</b> Virtual key code.
    ushort wVKey;
    uint   flags;
}

///Contains information about an LVN_LINKCLICK notification code.
struct NMLVLINK
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains basic information about the notification code.
    NMHDR hdr;
    ///Type: <b>LITEM</b> LITEM structure that contains information about the link that was clicked.
    LITEM link;
    ///Type: <b>int</b> Index of the item that contains the link.
    int   iItem;
    int   iSubItem;
}

///Contains and receives list-view item information needed to display a tooltip for an item. This structure is used with
///the LVN_GETINFOTIP notification code.
struct NMLVGETINFOTIPA
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information on this notification code.
    NMHDR  hdr;
    ///Type: <b>DWORD</b> Either zero or LVGIT_UNFOLDED. See Remarks.
    uint   dwFlags;
    ///Type: <b>LPTSTR</b> Address of a string buffer that receives any additional text information. If <b>dwFlags</b>
    ///is zero, this member will contain the existing item text. In this case, you should append any additional text
    ///onto the end of this string. The size of this buffer is specified by the <b>cchTextMax</b> structure.
    PSTR   pszText;
    ///Type: <b>int</b> Size, in characters, of the buffer pointed to by <b>pszText</b>. Although you should never
    ///assume that this buffer will be of any particular size, the INFOTIPSIZE value can be used for design purposes.
    int    cchTextMax;
    ///Type: <b>int</b> Zero-based index of the item to which this structure refers.
    int    iItem;
    ///Type: <b>int</b> One-based index of the subitem to which this structure refers. If this member is zero, the
    ///structure is referring to the item and not a subitem. This member is not currently used and will always be zero.
    int    iSubItem;
    ///Type: <b>LPARAM</b> Application-defined value associated with the item. This member is not currently used and
    ///will always be zero.
    LPARAM lParam;
}

///Contains and receives list-view item information needed to display a tooltip for an item. This structure is used with
///the LVN_GETINFOTIP notification code.
struct NMLVGETINFOTIPW
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information on this notification code.
    NMHDR  hdr;
    ///Type: <b>DWORD</b> Either zero or LVGIT_UNFOLDED. See Remarks.
    uint   dwFlags;
    ///Type: <b>LPTSTR</b> Address of a string buffer that receives any additional text information. If <b>dwFlags</b>
    ///is zero, this member will contain the existing item text. In this case, you should append any additional text
    ///onto the end of this string. The size of this buffer is specified by the <b>cchTextMax</b> structure.
    PWSTR  pszText;
    ///Type: <b>int</b> Size, in characters, of the buffer pointed to by <b>pszText</b>. Although you should never
    ///assume that this buffer will be of any particular size, the INFOTIPSIZE value can be used for design purposes.
    int    cchTextMax;
    ///Type: <b>int</b> Zero-based index of the item to which this structure refers.
    int    iItem;
    ///Type: <b>int</b> One-based index of the subitem to which this structure refers. If this member is zero, the
    ///structure is referring to the item and not a subitem. This member is not currently used and will always be zero.
    int    iSubItem;
    ///Type: <b>LPARAM</b> Application-defined value associated with the item. This member is not currently used and
    ///will always be zero.
    LPARAM lParam;
}

///Provides information about a scrolling operation.
struct NMLVSCROLL
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about a LVN_ENDSCROLL or a LVN_BEGINSCROLL
    ///notification code.
    NMHDR hdr;
    ///Type: <b>int</b> Value of type <b>int</b> that specifies in pixels the horizontal position where a scrolling
    ///operation should begin or end.
    int   dx;
    int   dy;
}

///Contains information used with the LVN_GETEMPTYMARKUP notification code.
struct NMLVEMPTYMARKUP
{
    ///Type: <b>NMHDR</b> Info on the notification message.
    NMHDR        hdr;
    ///Type: <b>DWORD</b> One of the following values. If <b>NULL</b>, markup is rendered left-justified in the listview
    ///area. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="EMF_CENTERED"></a><a
    ///id="emf_centered"></a><dl> <dt><b>EMF_CENTERED</b></dt> </dl> </td> <td width="60%"> Render markup centered in
    ///the listview area. </td> </tr> </table>
    uint         dwFlags;
    ushort[2084] szMarkup;
}

struct _TREEITEM
{
}

///Contains information about an NM_TVSTATEIMAGECHANGING notification code.
struct NMTVSTATEIMAGECHANGING
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification code.
    NMHDR      hdr;
    ///Type: <b>HTREEITEM</b> Handle to the tree-view item whose state image is changing.
    _TREEITEM* hti;
    ///Type: <b>int</b> The index of the old state image.
    int        iOldStateImageIndex;
    int        iNewStateImageIndex;
}

///Specifies or receives attributes of a tree-view item. This structure is identical to the <b>TV_ITEM</b> structure,
///but it has been renamed to follow current naming conventions. New applications should use this structure.
struct TVITEMA
{
    ///Type: <b>UINT</b> Array of flags that indicate which of the other structure members contain valid data. When this
    ///structure is used with the TVM_GETITEM message, the <b>mask</b> member indicates the item attributes to retrieve.
    ///If used with the TVM_SETITEM message, the <b>mask</b> indicates the attributes to set. This member can be one or
    ///more of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TVIF_CHILDREN"></a><a id="tvif_children"></a><dl> <dt><b>TVIF_CHILDREN</b></dt> </dl> </td> <td width="60%">
    ///The <b>cChildren</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_DI_SETITEM"></a><a
    ///id="tvif_di_setitem"></a><dl> <dt><b>TVIF_DI_SETITEM</b></dt> </dl> </td> <td width="60%"> The tree-view control
    ///will retain the supplied information and will not request it again. This flag is valid only when processing the
    ///TVN_GETDISPINFO notification. </td> </tr> <tr> <td width="40%"><a id="TVIF_HANDLE"></a><a
    ///id="tvif_handle"></a><dl> <dt><b>TVIF_HANDLE</b></dt> </dl> </td> <td width="60%"> The <b>hItem</b> member is
    ///valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_IMAGE"></a><a id="tvif_image"></a><dl>
    ///<dt><b>TVIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The <b>iImage</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="TVIF_PARAM"></a><a id="tvif_param"></a><dl> <dt><b>TVIF_PARAM</b></dt> </dl> </td> <td
    ///width="60%"> The <b>lParam</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="TVIF_SELECTEDIMAGE"></a><a id="tvif_selectedimage"></a><dl> <dt><b>TVIF_SELECTEDIMAGE</b></dt> </dl> </td>
    ///<td width="60%"> The <b>iSelectedImage</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="TVIF_STATE"></a><a id="tvif_state"></a><dl> <dt><b>TVIF_STATE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>state</b> and <b>stateMask</b> members are valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_TEXT"></a><a
    ///id="tvif_text"></a><dl> <dt><b>TVIF_TEXT</b></dt> </dl> </td> <td width="60%"> The <b>pszText</b> and
    ///<b>cchTextMax</b> members are valid. </td> </tr> </table>
    uint       mask;
    ///Type: <b>HTREEITEM</b> Handle to the item.
    _TREEITEM* hItem;
    ///Type: <b>UINT</b> Set of bit flags and image list indexes that indicate the item's state. When setting the state
    ///of an item, the <b>stateMask</b> member indicates the valid bits of this member. When retrieving the state of an
    ///item, this member returns the current state for the bits indicated in the <b>stateMask</b> member. Bits 0 through
    ///7 of this member contain the item state flags. For a list of possible item state flags, see Tree-View Control
    ///Item States. The overlay image is superimposed over the item's icon image. Bits 8 through 11 of this member
    ///specify the one-based overlay image index. If these bits are zero, the item has no overlay image. To isolate
    ///these bits, use the TVIS_OVERLAYMASK mask. To set the overlay image index in this member, use the
    ///INDEXTOOVERLAYMASK macro. The image list's overlay images are set with the ImageList_SetOverlayImage function. A
    ///state image is displayed next to an item's icon to indicate an application-defined state. Specify the state image
    ///list by sending a TVM_SETIMAGELIST message. To set an item's state image, include the TVIS_STATEIMAGEMASK value
    ///in the <b>stateMask</b> member of the <b>TVITEM</b> structure. Bits 12 through 15 of the structure's <b>state</b>
    ///member specify the index in the state image list of the image to be drawn. To set the state image index, use
    ///INDEXTOSTATEIMAGEMASK. This macro takes an index and sets bits 12 through 15 appropriately. To indicate that the
    ///item has no state image, set the index to zero. This convention means that image zero in the state image list
    ///cannot be used as a state image. To isolate bits 12 through 15 of the <b>state</b> member, use the
    ///TVIS_STATEIMAGEMASK mask.
    uint       state;
    ///Type: <b>UINT</b> Bits of the <b>state</b> member that are valid. If you are retrieving an item's state, set the
    ///bits of the <b>stateMask</b> member to indicate the bits to be returned in the <b>state</b> member. If you are
    ///setting an item's state, set the bits of the <b>stateMask</b> member to indicate the bits of the <b>state</b>
    ///member that you want to set. To set or retrieve an item's overlay image index, set the TVIS_OVERLAYMASK bits. To
    ///set or retrieve an item's state image index, set the TVIS_STATEIMAGEMASK bits.
    uint       stateMask;
    ///Type: <b>LPTSTR</b> Pointer to a null-terminated string that contains the item text if the structure specifies
    ///item attributes. If this member is the LPSTR_TEXTCALLBACK value, the parent window is responsible for storing the
    ///name. In this case, the tree-view control sends the parent window a TVN_GETDISPINFO notification code when it
    ///needs the item text for displaying, sorting, or editing and a TVN_SETDISPINFO notification code when the item
    ///text changes. If the structure is receiving item attributes, this member is the address of the buffer that
    ///receives the item text. Note that although the tree-view control allows any length string to be stored as item
    ///text, only the first 260 characters are displayed.
    PSTR       pszText;
    ///Type: <b>int</b> Size of the buffer pointed to by the <b>pszText</b> member, in characters. If this structure is
    ///being used to set item attributes, this member is ignored.
    int        cchTextMax;
    ///Type: <b>int</b> Index in the tree-view control's image list of the icon image to use when the item is in the
    ///nonselected state. If this member is the I_IMAGECALLBACK value, the parent window is responsible for storing the
    ///index. In this case, the tree-view control sends the parent a TVN_GETDISPINFO notification code to retrieve the
    ///index when it needs to display the image.
    int        iImage;
    ///Type: <b>int</b> Index in the tree-view control's image list of the icon image to use when the item is in the
    ///selected state. If this member is the I_IMAGECALLBACK value, the parent window is responsible for storing the
    ///index. In this case, the tree-view control sends the parent a TVN_GETDISPINFO notification code to retrieve the
    ///index when it needs to display the image.
    int        iSelectedImage;
    ///Type: <b>int</b> Flag that indicates whether the item has associated child items. This member can be one of the
    ///following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="zero"></a><a
    ///id="ZERO"></a><dl> <dt><b>zero</b></dt> </dl> </td> <td width="60%"> The item has no child items. </td> </tr>
    ///<tr> <td width="40%"><a id="one"></a><a id="ONE"></a><dl> <dt><b>one</b></dt> </dl> </td> <td width="60%"> The
    ///item has one or more child items. </td> </tr> <tr> <td width="40%"><a id="I_CHILDRENCALLBACK"></a><a
    ///id="i_childrencallback"></a><dl> <dt><b>I_CHILDRENCALLBACK</b></dt> </dl> </td> <td width="60%"> The parent
    ///window keeps track of whether the item has child items. In this case, when the tree-view control needs to display
    ///the item, the control sends the parent a TVN_GETDISPINFO notification code to determine whether the item has
    ///child items. If the tree-view control has the TVS_HASBUTTONS style, it uses this member to determine whether to
    ///display the button indicating the presence of child items. You can use this member to force the control to
    ///display the button even though the item does not have any child items inserted. This allows you to display the
    ///button while minimizing the control's memory usage by inserting child items only when the item is visible or
    ///expanded. </td> </tr> <tr> <td width="40%"><a id="I_CHILDRENAUTO"></a><a id="i_childrenauto"></a><dl>
    ///<dt><b>I_CHILDRENAUTO</b></dt> </dl> </td> <td width="60%"> Version 6.0 <b>Intended for internal use; not
    ///recommended for use in applications.</b> The tree-view control automatically determines whether the item has
    ///child items. <div class="alert"><b>Note</b> This flag may not be supported in future versions of Comctl32.dll.
    ///Also, this flag is not defined in commctrl.h. Add the following definition to the source files of your
    ///application to use the flag: ```
    int        cChildren;
    ///Type: <b>LPARAM</b> A value to associate with the item.
    LPARAM     lParam;
}

///Specifies or receives attributes of a tree-view item. This structure is identical to the <b>TV_ITEM</b> structure,
///but it has been renamed to follow current naming conventions. New applications should use this structure.
struct TVITEMW
{
    ///Type: <b>UINT</b> Array of flags that indicate which of the other structure members contain valid data. When this
    ///structure is used with the TVM_GETITEM message, the <b>mask</b> member indicates the item attributes to retrieve.
    ///If used with the TVM_SETITEM message, the <b>mask</b> indicates the attributes to set. This member can be one or
    ///more of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TVIF_CHILDREN"></a><a id="tvif_children"></a><dl> <dt><b>TVIF_CHILDREN</b></dt> </dl> </td> <td width="60%">
    ///The <b>cChildren</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_DI_SETITEM"></a><a
    ///id="tvif_di_setitem"></a><dl> <dt><b>TVIF_DI_SETITEM</b></dt> </dl> </td> <td width="60%"> The tree-view control
    ///will retain the supplied information and will not request it again. This flag is valid only when processing the
    ///TVN_GETDISPINFO notification. </td> </tr> <tr> <td width="40%"><a id="TVIF_HANDLE"></a><a
    ///id="tvif_handle"></a><dl> <dt><b>TVIF_HANDLE</b></dt> </dl> </td> <td width="60%"> The <b>hItem</b> member is
    ///valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_IMAGE"></a><a id="tvif_image"></a><dl>
    ///<dt><b>TVIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The <b>iImage</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="TVIF_PARAM"></a><a id="tvif_param"></a><dl> <dt><b>TVIF_PARAM</b></dt> </dl> </td> <td
    ///width="60%"> The <b>lParam</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="TVIF_SELECTEDIMAGE"></a><a id="tvif_selectedimage"></a><dl> <dt><b>TVIF_SELECTEDIMAGE</b></dt> </dl> </td>
    ///<td width="60%"> The <b>iSelectedImage</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="TVIF_STATE"></a><a id="tvif_state"></a><dl> <dt><b>TVIF_STATE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>state</b> and <b>stateMask</b> members are valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_TEXT"></a><a
    ///id="tvif_text"></a><dl> <dt><b>TVIF_TEXT</b></dt> </dl> </td> <td width="60%"> The <b>pszText</b> and
    ///<b>cchTextMax</b> members are valid. </td> </tr> </table>
    uint       mask;
    ///Type: <b>HTREEITEM</b> Handle to the item.
    _TREEITEM* hItem;
    ///Type: <b>UINT</b> Set of bit flags and image list indexes that indicate the item's state. When setting the state
    ///of an item, the <b>stateMask</b> member indicates the valid bits of this member. When retrieving the state of an
    ///item, this member returns the current state for the bits indicated in the <b>stateMask</b> member. Bits 0 through
    ///7 of this member contain the item state flags. For a list of possible item state flags, see Tree-View Control
    ///Item States. The overlay image is superimposed over the item's icon image. Bits 8 through 11 of this member
    ///specify the one-based overlay image index. If these bits are zero, the item has no overlay image. To isolate
    ///these bits, use the TVIS_OVERLAYMASK mask. To set the overlay image index in this member, use the
    ///INDEXTOOVERLAYMASK macro. The image list's overlay images are set with the ImageList_SetOverlayImage function. A
    ///state image is displayed next to an item's icon to indicate an application-defined state. Specify the state image
    ///list by sending a TVM_SETIMAGELIST message. To set an item's state image, include the TVIS_STATEIMAGEMASK value
    ///in the <b>stateMask</b> member of the <b>TVITEM</b> structure. Bits 12 through 15 of the structure's <b>state</b>
    ///member specify the index in the state image list of the image to be drawn. To set the state image index, use
    ///INDEXTOSTATEIMAGEMASK. This macro takes an index and sets bits 12 through 15 appropriately. To indicate that the
    ///item has no state image, set the index to zero. This convention means that image zero in the state image list
    ///cannot be used as a state image. To isolate bits 12 through 15 of the <b>state</b> member, use the
    ///TVIS_STATEIMAGEMASK mask.
    uint       state;
    ///Type: <b>UINT</b> Bits of the <b>state</b> member that are valid. If you are retrieving an item's state, set the
    ///bits of the <b>stateMask</b> member to indicate the bits to be returned in the <b>state</b> member. If you are
    ///setting an item's state, set the bits of the <b>stateMask</b> member to indicate the bits of the <b>state</b>
    ///member that you want to set. To set or retrieve an item's overlay image index, set the TVIS_OVERLAYMASK bits. To
    ///set or retrieve an item's state image index, set the TVIS_STATEIMAGEMASK bits.
    uint       stateMask;
    ///Type: <b>LPTSTR</b> Pointer to a null-terminated string that contains the item text if the structure specifies
    ///item attributes. If this member is the LPSTR_TEXTCALLBACK value, the parent window is responsible for storing the
    ///name. In this case, the tree-view control sends the parent window a TVN_GETDISPINFO notification code when it
    ///needs the item text for displaying, sorting, or editing and a TVN_SETDISPINFO notification code when the item
    ///text changes. If the structure is receiving item attributes, this member is the address of the buffer that
    ///receives the item text. Note that although the tree-view control allows any length string to be stored as item
    ///text, only the first 260 characters are displayed.
    PWSTR      pszText;
    ///Type: <b>int</b> Size of the buffer pointed to by the <b>pszText</b> member, in characters. If this structure is
    ///being used to set item attributes, this member is ignored.
    int        cchTextMax;
    ///Type: <b>int</b> Index in the tree-view control's image list of the icon image to use when the item is in the
    ///nonselected state. If this member is the I_IMAGECALLBACK value, the parent window is responsible for storing the
    ///index. In this case, the tree-view control sends the parent a TVN_GETDISPINFO notification code to retrieve the
    ///index when it needs to display the image.
    int        iImage;
    ///Type: <b>int</b> Index in the tree-view control's image list of the icon image to use when the item is in the
    ///selected state. If this member is the I_IMAGECALLBACK value, the parent window is responsible for storing the
    ///index. In this case, the tree-view control sends the parent a TVN_GETDISPINFO notification code to retrieve the
    ///index when it needs to display the image.
    int        iSelectedImage;
    ///Type: <b>int</b> Flag that indicates whether the item has associated child items. This member can be one of the
    ///following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="zero"></a><a
    ///id="ZERO"></a><dl> <dt><b>zero</b></dt> </dl> </td> <td width="60%"> The item has no child items. </td> </tr>
    ///<tr> <td width="40%"><a id="one"></a><a id="ONE"></a><dl> <dt><b>one</b></dt> </dl> </td> <td width="60%"> The
    ///item has one or more child items. </td> </tr> <tr> <td width="40%"><a id="I_CHILDRENCALLBACK"></a><a
    ///id="i_childrencallback"></a><dl> <dt><b>I_CHILDRENCALLBACK</b></dt> </dl> </td> <td width="60%"> The parent
    ///window keeps track of whether the item has child items. In this case, when the tree-view control needs to display
    ///the item, the control sends the parent a TVN_GETDISPINFO notification code to determine whether the item has
    ///child items. If the tree-view control has the TVS_HASBUTTONS style, it uses this member to determine whether to
    ///display the button indicating the presence of child items. You can use this member to force the control to
    ///display the button even though the item does not have any child items inserted. This allows you to display the
    ///button while minimizing the control's memory usage by inserting child items only when the item is visible or
    ///expanded. </td> </tr> <tr> <td width="40%"><a id="I_CHILDRENAUTO"></a><a id="i_childrenauto"></a><dl>
    ///<dt><b>I_CHILDRENAUTO</b></dt> </dl> </td> <td width="60%"> Version 6.0 <b>Intended for internal use; not
    ///recommended for use in applications.</b> The tree-view control automatically determines whether the item has
    ///child items. <div class="alert"><b>Note</b> This flag may not be supported in future versions of Comctl32.dll.
    ///Also, this flag is not defined in commctrl.h. Add the following definition to the source files of your
    ///application to use the flag: ```
    int        cChildren;
    ///Type: <b>LPARAM</b> A value to associate with the item.
    LPARAM     lParam;
}

///Specifies or receives attributes of a tree-view item. This structure is an enhancement to the TVITEM structure. New
///applications should use this structure where appropriate.
struct TVITEMEXA
{
    ///Type: <b>UINT</b> Array of flags that indicate which of the other structure members contain valid data. When this
    ///structure is used with the TVM_GETITEM message, the <b>mask</b> member indicates the item attributes to retrieve.
    ///If used with the TVM_SETITEM message, the <b>mask</b> indicates the attributes to set. This member can be one or
    ///more of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TVIF_CHILDREN"></a><a id="tvif_children"></a><dl> <dt><b>TVIF_CHILDREN</b></dt> </dl> </td> <td width="60%">
    ///The <b>cChildren</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_DI_SETITEM"></a><a
    ///id="tvif_di_setitem"></a><dl> <dt><b>TVIF_DI_SETITEM</b></dt> </dl> </td> <td width="60%"> The tree-view control
    ///will retain the supplied information and will not request it again. This flag is valid only when processing the
    ///TVN_GETDISPINFO notification. </td> </tr> <tr> <td width="40%"><a id="TVIF_EXPANDEDIMAGE"></a><a
    ///id="tvif_expandedimage"></a><dl> <dt><b>TVIF_EXPANDEDIMAGE</b></dt> </dl> </td> <td width="60%"> Version 6.00 and
    ///<b>Windows Vista.</b> The <b>iExpandedImage</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="TVIF_HANDLE"></a><a id="tvif_handle"></a><dl> <dt><b>TVIF_HANDLE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>hItem</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_IMAGE"></a><a id="tvif_image"></a><dl>
    ///<dt><b>TVIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The <b>iImage</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="TVIF_INTEGRAL"></a><a id="tvif_integral"></a><dl> <dt><b>TVIF_INTEGRAL</b></dt> </dl> </td>
    ///<td width="60%"> The <b>iIntegral</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_PARAM"></a><a
    ///id="tvif_param"></a><dl> <dt><b>TVIF_PARAM</b></dt> </dl> </td> <td width="60%"> The <b>lParam</b> member is
    ///valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_SELECTEDIMAGE"></a><a id="tvif_selectedimage"></a><dl>
    ///<dt><b>TVIF_SELECTEDIMAGE</b></dt> </dl> </td> <td width="60%"> The <b>iSelectedImage</b> member is valid. </td>
    ///</tr> <tr> <td width="40%"><a id="TVIF_STATE"></a><a id="tvif_state"></a><dl> <dt><b>TVIF_STATE</b></dt> </dl>
    ///</td> <td width="60%"> The <b>state</b> and <b>stateMask</b> members are valid. </td> </tr> <tr> <td
    ///width="40%"><a id="TVIF_STATEEX"></a><a id="tvif_stateex"></a><dl> <dt><b>TVIF_STATEEX</b></dt> </dl> </td> <td
    ///width="60%"> Version 6.00 and <b>Windows Vista.</b> The <b>uStateEx</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="TVIF_TEXT"></a><a id="tvif_text"></a><dl> <dt><b>TVIF_TEXT</b></dt> </dl> </td> <td
    ///width="60%"> The <b>pszText</b> and <b>cchTextMax</b> members are valid. </td> </tr> </table>
    uint       mask;
    ///Type: <b>HTREEITEM</b> Handle to the item.
    _TREEITEM* hItem;
    ///Type: <b>UINT</b> Set of bit flags and image list indexes that indicate the item's state. When setting the state
    ///of an item, the <b>stateMask</b> member indicates the valid bits of this member. When retrieving the state of an
    ///item, this member returns the current state for the bits indicated in the <b>stateMask</b> member. For more
    ///information regarding this member, see remarks section. Bits 0 through 7 of this member contain the item state
    ///flags. For a list of possible item state flags, see Tree-View Control Item States. Bits 8 through 11 of this
    ///member specify the one-based overlay image index. The overlay image is superimposed over the item's icon image.
    ///If these bits are zero, the item has no overlay image. To isolate these bits, use the TVIS_OVERLAYMASK mask. To
    ///set the overlay image index in this member, use the INDEXTOOVERLAYMASK macro. The image list's overlay images are
    ///set with the ImageList_SetOverlayImage function. A state image is displayed next to an item's icon to indicate an
    ///application-defined state. Specify the state image list by sending a TVM_SETIMAGELIST message. To set an item's
    ///state image, include the TVIS_STATEIMAGEMASK value in The <b>stateMask</b> member of the TVITEM structure. Bits
    ///12 through 15 of the structure's <b>state</b> member specify the index in the state image list of the image to be
    ///drawn. To set the state image index, use INDEXTOSTATEIMAGEMASK. This macro takes an index and sets bits 12
    ///through 15 appropriately. To indicate that the item has no state image, set the index to zero. This convention
    ///means that image zero in the state image list cannot be used as a state image. To isolate bits 12 through 15 of
    ///The <b>state</b> member, use the TVIS_STATEIMAGEMASK mask.
    uint       state;
    ///Type: <b>UINT</b> Bits of the <b>state</b> member that are valid. If you are retrieving an item's state, set the
    ///bits of the <b>stateMask</b> member to indicate the bits to be returned in the <b>state</b> member. If you are
    ///setting an item's state, set the bits of the <b>stateMask</b> member to indicate the bits of the <b>state</b>
    ///member that you want to set. To set or retrieve an item's overlay image index, set the TVIS_OVERLAYMASK bits. To
    ///set or retrieve an item's state image index, set the TVIS_STATEIMAGEMASK bits.
    uint       stateMask;
    ///Type: <b>LPTSTR</b> Pointer to a null-terminated string that contains the item text if the structure specifies
    ///item attributes. If this member is the LPSTR_TEXTCALLBACK value, the parent window is responsible for storing the
    ///name. In this case, the tree-view control sends the parent window a TVN_GETDISPINFO notification code when it
    ///needs the item text for displaying, sorting, or editing and a TVN_SETDISPINFO notification code when the item
    ///text changes. If the structure is receiving item attributes, this member is the address of the buffer that
    ///receives the item text. Note that although the tree-view control allows any length string to be stored as item
    ///text, only the first 260 characters are displayed.
    PSTR       pszText;
    ///Type: <b>int</b> Size of the buffer pointed to by the <b>pszText</b> member, in characters. If this structure is
    ///being used to set item attributes, this member is ignored.
    int        cchTextMax;
    ///Type: <b>int</b> Index in the tree-view control's image list of the icon image to use when the item is in the
    ///nonselected state. If this member is the I_IMAGECALLBACK value, the parent window is responsible for storing the
    ///index. In this case, the tree-view control sends the parent a TVN_GETDISPINFO notification code to retrieve the
    ///index when it needs to display the image.
    int        iImage;
    ///Type: <b>int</b> Index in the tree-view control's image list of the icon image to use when the item is in the
    ///selected state. If this member is the I_IMAGECALLBACK value, the parent window is responsible for storing the
    ///index. In this case, the tree-view control sends the parent a TVN_GETDISPINFO notification code to retrieve the
    ///index when it needs to display the image.
    int        iSelectedImage;
    ///Type: <b>int</b> Flag that indicates whether the item has associated child items. This member can be one of the
    ///following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="zero"></a><a
    ///id="ZERO"></a><dl> <dt><b>zero</b></dt> </dl> </td> <td width="60%"> The item has no child items. </td> </tr>
    ///<tr> <td width="40%"><a id="one"></a><a id="ONE"></a><dl> <dt><b>one</b></dt> </dl> </td> <td width="60%"> The
    ///item has one or more child items. </td> </tr> <tr> <td width="40%"><a id="I_CHILDRENCALLBACK"></a><a
    ///id="i_childrencallback"></a><dl> <dt><b>I_CHILDRENCALLBACK</b></dt> </dl> </td> <td width="60%"> The parent
    ///window keeps track of whether the item has child items. In this case, when the tree-view control needs to display
    ///the item, the control sends the parent a TVN_GETDISPINFO notification code to determine whether the item has
    ///child items. If the tree-view control has the TVS_HASBUTTONS style, it uses this member to determine whether to
    ///display the button indicating the presence of child items. You can use this member to force the control to
    ///display the button even though the item does not have any child items inserted. This allows you to display the
    ///button while minimizing the control's memory usage by inserting child items only when the item is visible or
    ///expanded. </td> </tr> <tr> <td width="40%"><a id="I_CHILDRENAUTO"></a><a id="i_childrenauto"></a><dl>
    ///<dt><b>I_CHILDRENAUTO</b></dt> </dl> </td> <td width="60%"> Version 6.0 <b>Intended for internal use; not
    ///recommended for use in applications.</b> The tree-view control automatically determines whether the item has
    ///child items. <div class="alert"><b>Note</b> This flag may not be supported in future versions of Comctl32.dll.
    ///Also, this flag is not defined in commctrl.h. Add the following definition to the source files of your
    ///application to use the flag: ```
    int        cChildren;
    ///Type: <b>LPARAM</b> A value to associate with the item.
    LPARAM     lParam;
    ///Type: <b>int</b> Height of the item, in multiples of the standard item height (see TVM_SETITEMHEIGHT). For
    ///example, setting this member to 2 will give the item twice the standard height. The tree-view control does not
    ///draw in the extra area, which appears below the item content, but this space can be used by the application for
    ///drawing when using custom draw. Applications that are not using custom draw should set this value to 1, as
    ///otherwise the behavior is undefined.
    int        iIntegral;
    ///Type: <b>UINT</b> <b>Internet Explorer 6 and later</b>. One or more (as a bitwise combination) of the following
    ///extended states. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TVIS_EX_DISABLED"></a><a id="tvis_ex_disabled"></a><dl> <dt><b>TVIS_EX_DISABLED</b></dt> </dl> </td> <td
    ///width="60%"> <b>Windows Vista and later</b>. Creates a control that is drawn in gray, that the user cannot
    ///interact with. </td> </tr> <tr> <td width="40%"><a id="TVIS_EX_FLAT"></a><a id="tvis_ex_flat"></a><dl>
    ///<dt><b>TVIS_EX_FLAT</b></dt> </dl> </td> <td width="60%"> Creates a flat item—the item is virtual and is not
    ///visible in the tree; instead, its children take its place in the tree hierarchy. This state is valid only when
    ///adding an item to the tree-view control. </td> </tr> <tr> <td width="40%"><a id="TVIS_EX_HWND"></a><a
    ///id="tvis_ex_hwnd"></a><dl> <dt><b>TVIS_EX_HWND</b></dt> </dl> </td> <td width="60%"> Creates a separate HWND for
    ///the item. This state is valid only when adding an item to the tree-view control. </td> </tr> </table>
    uint       uStateEx;
    ///Type: <b>HWND</b> <b>Internet Explorer 6 and later</b>. Not used; must be <b>NULL</b>.
    HWND       hwnd;
    ///Type: <b>int</b> <b>Internet Explorer 6 and later</b>. Index of the image in the control's image list to display
    ///when the item is in the expanded state.
    int        iExpandedImage;
    ///Type: <b>int</b> Reserved member. Do not use.
    int        iReserved;
}

///Specifies or receives attributes of a tree-view item. This structure is an enhancement to the TVITEM structure. New
///applications should use this structure where appropriate.
struct TVITEMEXW
{
    ///Type: <b>UINT</b> Array of flags that indicate which of the other structure members contain valid data. When this
    ///structure is used with the TVM_GETITEM message, the <b>mask</b> member indicates the item attributes to retrieve.
    ///If used with the TVM_SETITEM message, the <b>mask</b> indicates the attributes to set. This member can be one or
    ///more of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TVIF_CHILDREN"></a><a id="tvif_children"></a><dl> <dt><b>TVIF_CHILDREN</b></dt> </dl> </td> <td width="60%">
    ///The <b>cChildren</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_DI_SETITEM"></a><a
    ///id="tvif_di_setitem"></a><dl> <dt><b>TVIF_DI_SETITEM</b></dt> </dl> </td> <td width="60%"> The tree-view control
    ///will retain the supplied information and will not request it again. This flag is valid only when processing the
    ///TVN_GETDISPINFO notification. </td> </tr> <tr> <td width="40%"><a id="TVIF_EXPANDEDIMAGE"></a><a
    ///id="tvif_expandedimage"></a><dl> <dt><b>TVIF_EXPANDEDIMAGE</b></dt> </dl> </td> <td width="60%"> Version 6.00 and
    ///<b>Windows Vista.</b> The <b>iExpandedImage</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="TVIF_HANDLE"></a><a id="tvif_handle"></a><dl> <dt><b>TVIF_HANDLE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>hItem</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_IMAGE"></a><a id="tvif_image"></a><dl>
    ///<dt><b>TVIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The <b>iImage</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="TVIF_INTEGRAL"></a><a id="tvif_integral"></a><dl> <dt><b>TVIF_INTEGRAL</b></dt> </dl> </td>
    ///<td width="60%"> The <b>iIntegral</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_PARAM"></a><a
    ///id="tvif_param"></a><dl> <dt><b>TVIF_PARAM</b></dt> </dl> </td> <td width="60%"> The <b>lParam</b> member is
    ///valid. </td> </tr> <tr> <td width="40%"><a id="TVIF_SELECTEDIMAGE"></a><a id="tvif_selectedimage"></a><dl>
    ///<dt><b>TVIF_SELECTEDIMAGE</b></dt> </dl> </td> <td width="60%"> The <b>iSelectedImage</b> member is valid. </td>
    ///</tr> <tr> <td width="40%"><a id="TVIF_STATE"></a><a id="tvif_state"></a><dl> <dt><b>TVIF_STATE</b></dt> </dl>
    ///</td> <td width="60%"> The <b>state</b> and <b>stateMask</b> members are valid. </td> </tr> <tr> <td
    ///width="40%"><a id="TVIF_STATEEX"></a><a id="tvif_stateex"></a><dl> <dt><b>TVIF_STATEEX</b></dt> </dl> </td> <td
    ///width="60%"> Version 6.00 and <b>Windows Vista.</b> The <b>uStateEx</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="TVIF_TEXT"></a><a id="tvif_text"></a><dl> <dt><b>TVIF_TEXT</b></dt> </dl> </td> <td
    ///width="60%"> The <b>pszText</b> and <b>cchTextMax</b> members are valid. </td> </tr> </table>
    uint       mask;
    ///Type: <b>HTREEITEM</b> Handle to the item.
    _TREEITEM* hItem;
    ///Type: <b>UINT</b> Set of bit flags and image list indexes that indicate the item's state. When setting the state
    ///of an item, the <b>stateMask</b> member indicates the valid bits of this member. When retrieving the state of an
    ///item, this member returns the current state for the bits indicated in the <b>stateMask</b> member. For more
    ///information regarding this member, see remarks section. Bits 0 through 7 of this member contain the item state
    ///flags. For a list of possible item state flags, see Tree-View Control Item States. Bits 8 through 11 of this
    ///member specify the one-based overlay image index. The overlay image is superimposed over the item's icon image.
    ///If these bits are zero, the item has no overlay image. To isolate these bits, use the TVIS_OVERLAYMASK mask. To
    ///set the overlay image index in this member, use the INDEXTOOVERLAYMASK macro. The image list's overlay images are
    ///set with the ImageList_SetOverlayImage function. A state image is displayed next to an item's icon to indicate an
    ///application-defined state. Specify the state image list by sending a TVM_SETIMAGELIST message. To set an item's
    ///state image, include the TVIS_STATEIMAGEMASK value in The <b>stateMask</b> member of the TVITEM structure. Bits
    ///12 through 15 of the structure's <b>state</b> member specify the index in the state image list of the image to be
    ///drawn. To set the state image index, use INDEXTOSTATEIMAGEMASK. This macro takes an index and sets bits 12
    ///through 15 appropriately. To indicate that the item has no state image, set the index to zero. This convention
    ///means that image zero in the state image list cannot be used as a state image. To isolate bits 12 through 15 of
    ///The <b>state</b> member, use the TVIS_STATEIMAGEMASK mask.
    uint       state;
    ///Type: <b>UINT</b> Bits of the <b>state</b> member that are valid. If you are retrieving an item's state, set the
    ///bits of the <b>stateMask</b> member to indicate the bits to be returned in the <b>state</b> member. If you are
    ///setting an item's state, set the bits of the <b>stateMask</b> member to indicate the bits of the <b>state</b>
    ///member that you want to set. To set or retrieve an item's overlay image index, set the TVIS_OVERLAYMASK bits. To
    ///set or retrieve an item's state image index, set the TVIS_STATEIMAGEMASK bits.
    uint       stateMask;
    ///Type: <b>LPTSTR</b> Pointer to a null-terminated string that contains the item text if the structure specifies
    ///item attributes. If this member is the LPSTR_TEXTCALLBACK value, the parent window is responsible for storing the
    ///name. In this case, the tree-view control sends the parent window a TVN_GETDISPINFO notification code when it
    ///needs the item text for displaying, sorting, or editing and a TVN_SETDISPINFO notification code when the item
    ///text changes. If the structure is receiving item attributes, this member is the address of the buffer that
    ///receives the item text. Note that although the tree-view control allows any length string to be stored as item
    ///text, only the first 260 characters are displayed.
    PWSTR      pszText;
    ///Type: <b>int</b> Size of the buffer pointed to by the <b>pszText</b> member, in characters. If this structure is
    ///being used to set item attributes, this member is ignored.
    int        cchTextMax;
    ///Type: <b>int</b> Index in the tree-view control's image list of the icon image to use when the item is in the
    ///nonselected state. If this member is the I_IMAGECALLBACK value, the parent window is responsible for storing the
    ///index. In this case, the tree-view control sends the parent a TVN_GETDISPINFO notification code to retrieve the
    ///index when it needs to display the image.
    int        iImage;
    ///Type: <b>int</b> Index in the tree-view control's image list of the icon image to use when the item is in the
    ///selected state. If this member is the I_IMAGECALLBACK value, the parent window is responsible for storing the
    ///index. In this case, the tree-view control sends the parent a TVN_GETDISPINFO notification code to retrieve the
    ///index when it needs to display the image.
    int        iSelectedImage;
    ///Type: <b>int</b> Flag that indicates whether the item has associated child items. This member can be one of the
    ///following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="zero"></a><a
    ///id="ZERO"></a><dl> <dt><b>zero</b></dt> </dl> </td> <td width="60%"> The item has no child items. </td> </tr>
    ///<tr> <td width="40%"><a id="one"></a><a id="ONE"></a><dl> <dt><b>one</b></dt> </dl> </td> <td width="60%"> The
    ///item has one or more child items. </td> </tr> <tr> <td width="40%"><a id="I_CHILDRENCALLBACK"></a><a
    ///id="i_childrencallback"></a><dl> <dt><b>I_CHILDRENCALLBACK</b></dt> </dl> </td> <td width="60%"> The parent
    ///window keeps track of whether the item has child items. In this case, when the tree-view control needs to display
    ///the item, the control sends the parent a TVN_GETDISPINFO notification code to determine whether the item has
    ///child items. If the tree-view control has the TVS_HASBUTTONS style, it uses this member to determine whether to
    ///display the button indicating the presence of child items. You can use this member to force the control to
    ///display the button even though the item does not have any child items inserted. This allows you to display the
    ///button while minimizing the control's memory usage by inserting child items only when the item is visible or
    ///expanded. </td> </tr> <tr> <td width="40%"><a id="I_CHILDRENAUTO"></a><a id="i_childrenauto"></a><dl>
    ///<dt><b>I_CHILDRENAUTO</b></dt> </dl> </td> <td width="60%"> Version 6.0 <b>Intended for internal use; not
    ///recommended for use in applications.</b> The tree-view control automatically determines whether the item has
    ///child items. <div class="alert"><b>Note</b> This flag may not be supported in future versions of Comctl32.dll.
    ///Also, this flag is not defined in commctrl.h. Add the following definition to the source files of your
    ///application to use the flag: ```
    int        cChildren;
    ///Type: <b>LPARAM</b> A value to associate with the item.
    LPARAM     lParam;
    ///Type: <b>int</b> Height of the item, in multiples of the standard item height (see TVM_SETITEMHEIGHT). For
    ///example, setting this member to 2 will give the item twice the standard height. The tree-view control does not
    ///draw in the extra area, which appears below the item content, but this space can be used by the application for
    ///drawing when using custom draw. Applications that are not using custom draw should set this value to 1, as
    ///otherwise the behavior is undefined.
    int        iIntegral;
    ///Type: <b>UINT</b> <b>Internet Explorer 6 and later</b>. One or more (as a bitwise combination) of the following
    ///extended states. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TVIS_EX_DISABLED"></a><a id="tvis_ex_disabled"></a><dl> <dt><b>TVIS_EX_DISABLED</b></dt> </dl> </td> <td
    ///width="60%"> <b>Windows Vista and later</b>. Creates a control that is drawn in gray, that the user cannot
    ///interact with. </td> </tr> <tr> <td width="40%"><a id="TVIS_EX_FLAT"></a><a id="tvis_ex_flat"></a><dl>
    ///<dt><b>TVIS_EX_FLAT</b></dt> </dl> </td> <td width="60%"> Creates a flat item—the item is virtual and is not
    ///visible in the tree; instead, its children take its place in the tree hierarchy. This state is valid only when
    ///adding an item to the tree-view control. </td> </tr> <tr> <td width="40%"><a id="TVIS_EX_HWND"></a><a
    ///id="tvis_ex_hwnd"></a><dl> <dt><b>TVIS_EX_HWND</b></dt> </dl> </td> <td width="60%"> Creates a separate HWND for
    ///the item. This state is valid only when adding an item to the tree-view control. </td> </tr> </table>
    uint       uStateEx;
    ///Type: <b>HWND</b> <b>Internet Explorer 6 and later</b>. Not used; must be <b>NULL</b>.
    HWND       hwnd;
    ///Type: <b>int</b> <b>Internet Explorer 6 and later</b>. Index of the image in the control's image list to display
    ///when the item is in the expanded state.
    int        iExpandedImage;
    ///Type: <b>int</b> Reserved member. Do not use.
    int        iReserved;
}

///Contains information used to add a new item to a tree-view control. This structure is used with the TVM_INSERTITEM
///message. The structure is identical to the <b>TV_INSERTSTRUCT</b> structure, but it has been renamed to follow
///current naming conventions.
struct TVINSERTSTRUCTA
{
    ///Type: <b>HTREEITEM</b> Handle to the parent item. If this member is the TVI_ROOT value or <b>NULL</b>, the item
    ///is inserted at the root of the tree-view control.
    _TREEITEM* hParent;
    ///Type: <b>HTREEITEM</b> Handle to the item after which the new item is to be inserted, or one of the following
    ///values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TVI_FIRST"></a><a
    ///id="tvi_first"></a><dl> <dt><b>TVI_FIRST</b></dt> </dl> </td> <td width="60%"> Inserts the item at the beginning
    ///of the list. </td> </tr> <tr> <td width="40%"><a id="TVI_LAST"></a><a id="tvi_last"></a><dl>
    ///<dt><b>TVI_LAST</b></dt> </dl> </td> <td width="60%"> Inserts the item at the end of the list. </td> </tr> <tr>
    ///<td width="40%"><a id="TVI_ROOT"></a><a id="tvi_root"></a><dl> <dt><b>TVI_ROOT</b></dt> </dl> </td> <td
    ///width="60%"> Add the item as a root item. </td> </tr> <tr> <td width="40%"><a id="TVI_SORT"></a><a
    ///id="tvi_sort"></a><dl> <dt><b>TVI_SORT</b></dt> </dl> </td> <td width="60%"> Inserts the item into the list in
    ///alphabetical order. </td> </tr> </table>
    _TREEITEM* hInsertAfter;
union
    {
        TVITEMEXA itemex;
        TVITEMA   item;
    }
}

///Contains information used to add a new item to a tree-view control. This structure is used with the TVM_INSERTITEM
///message. The structure is identical to the <b>TV_INSERTSTRUCT</b> structure, but it has been renamed to follow
///current naming conventions.
struct TVINSERTSTRUCTW
{
    ///Type: <b>HTREEITEM</b> Handle to the parent item. If this member is the TVI_ROOT value or <b>NULL</b>, the item
    ///is inserted at the root of the tree-view control.
    _TREEITEM* hParent;
    ///Type: <b>HTREEITEM</b> Handle to the item after which the new item is to be inserted, or one of the following
    ///values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TVI_FIRST"></a><a
    ///id="tvi_first"></a><dl> <dt><b>TVI_FIRST</b></dt> </dl> </td> <td width="60%"> Inserts the item at the beginning
    ///of the list. </td> </tr> <tr> <td width="40%"><a id="TVI_LAST"></a><a id="tvi_last"></a><dl>
    ///<dt><b>TVI_LAST</b></dt> </dl> </td> <td width="60%"> Inserts the item at the end of the list. </td> </tr> <tr>
    ///<td width="40%"><a id="TVI_ROOT"></a><a id="tvi_root"></a><dl> <dt><b>TVI_ROOT</b></dt> </dl> </td> <td
    ///width="60%"> Add the item as a root item. </td> </tr> <tr> <td width="40%"><a id="TVI_SORT"></a><a
    ///id="tvi_sort"></a><dl> <dt><b>TVI_SORT</b></dt> </dl> </td> <td width="60%"> Inserts the item into the list in
    ///alphabetical order. </td> </tr> </table>
    _TREEITEM* hInsertAfter;
union
    {
        TVITEMEXW itemex;
        TVITEMW   item;
    }
}

///Contains information used to determine the location of a point relative to a tree-view control. This structure is
///used with the TVM_HITTEST message. The structure is identical to the <b>TV_HITTESTINFO</b> structure, but it has been
///renamed to follow current naming conventions.
struct TVHITTESTINFO
{
    ///Type: <b>POINT</b> Client coordinates of the point to test.
    POINT      pt;
    ///Type: <b>UINT</b> Variable that receives information about the results of a hit test. This member can be one or
    ///more of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TVHT_ABOVE"></a><a id="tvht_above"></a><dl> <dt><b>TVHT_ABOVE</b></dt> </dl> </td> <td width="60%"> Above the
    ///client area. </td> </tr> <tr> <td width="40%"><a id="TVHT_BELOW"></a><a id="tvht_below"></a><dl>
    ///<dt><b>TVHT_BELOW</b></dt> </dl> </td> <td width="60%"> Below the client area. </td> </tr> <tr> <td
    ///width="40%"><a id="TVHT_NOWHERE"></a><a id="tvht_nowhere"></a><dl> <dt><b>TVHT_NOWHERE</b></dt> </dl> </td> <td
    ///width="60%"> In the client area, but below the last item. </td> </tr> <tr> <td width="40%"><a
    ///id="TVHT_ONITEM"></a><a id="tvht_onitem"></a><dl> <dt><b>TVHT_ONITEM</b></dt> </dl> </td> <td width="60%"> On the
    ///bitmap or label associated with an item. </td> </tr> <tr> <td width="40%"><a id="TVHT_ONITEMBUTTON"></a><a
    ///id="tvht_onitembutton"></a><dl> <dt><b>TVHT_ONITEMBUTTON</b></dt> </dl> </td> <td width="60%"> On the button
    ///associated with an item. </td> </tr> <tr> <td width="40%"><a id="TVHT_ONITEMICON"></a><a
    ///id="tvht_onitemicon"></a><dl> <dt><b>TVHT_ONITEMICON</b></dt> </dl> </td> <td width="60%"> On the bitmap
    ///associated with an item. </td> </tr> <tr> <td width="40%"><a id="TVHT_ONITEMINDENT"></a><a
    ///id="tvht_onitemindent"></a><dl> <dt><b>TVHT_ONITEMINDENT</b></dt> </dl> </td> <td width="60%"> In the indentation
    ///associated with an item. </td> </tr> <tr> <td width="40%"><a id="TVHT_ONITEMLABEL"></a><a
    ///id="tvht_onitemlabel"></a><dl> <dt><b>TVHT_ONITEMLABEL</b></dt> </dl> </td> <td width="60%"> On the label
    ///(string) associated with an item. </td> </tr> <tr> <td width="40%"><a id="TVHT_ONITEMRIGHT"></a><a
    ///id="tvht_onitemright"></a><dl> <dt><b>TVHT_ONITEMRIGHT</b></dt> </dl> </td> <td width="60%"> In the area to the
    ///right of an item. </td> </tr> <tr> <td width="40%"><a id="TVHT_ONITEMSTATEICON"></a><a
    ///id="tvht_onitemstateicon"></a><dl> <dt><b>TVHT_ONITEMSTATEICON</b></dt> </dl> </td> <td width="60%"> On the state
    ///icon for a tree-view item that is in a user-defined state. </td> </tr> <tr> <td width="40%"><a
    ///id="TVHT_TOLEFT"></a><a id="tvht_toleft"></a><dl> <dt><b>TVHT_TOLEFT</b></dt> </dl> </td> <td width="60%"> To the
    ///left of the client area. </td> </tr> <tr> <td width="40%"><a id="TVHT_TORIGHT"></a><a id="tvht_toright"></a><dl>
    ///<dt><b>TVHT_TORIGHT</b></dt> </dl> </td> <td width="60%"> To the right of the client area. </td> </tr> </table>
    uint       flags;
    _TREEITEM* hItem;
}

///Contains information for identifying the "hit zone" for a specified part of a tree item. The structure is used with
///the TVM_GETITEMPARTRECT message and the TreeView_GetItemPartRect macro.
struct TVGETITEMPARTRECTINFO
{
    ///Type: <b>HTREEITEM</b> Handle to the parent item.
    _TREEITEM* hti;
    ///Type: <b>RECT*</b> Pointer to a RECT structure to receive the coordinates of the bounding rectangle. The sender
    ///of the message (the caller) is responsible for allocating this structure.
    RECT*      prc;
    TVITEMPART partID;
}

///Contains information used to sort child items in a tree-view control. This structure is used with the
///TVM_SORTCHILDRENCB message. This structure is identical to the <b>TV_SORTCB</b> structure, but it has been renamed to
///follow current naming conventions.
struct TVSORTCB
{
    ///Type: <b>HTREEITEM</b> Handle to the parent item.
    _TREEITEM*   hParent;
    ///Type: <b>PFNTVCOMPARE</b> Address of an application-defined callback function, which is called during a sort
    ///operation each time the relative order of two list items needs to be compared.
    PFNTVCOMPARE lpfnCompare;
    ///Type: <b>LPARAM</b> Application-defined value that gets passed as the <i>lParamSort</i> argument in the callback
    ///function specified in <b>lpfnCompare</b>.
    LPARAM       lParam;
}

///Contains information about a tree-view notification message. This structure is identical to the <b>NM_TREEVIEW</b>
///structure, but it has been renamed to follow current naming conventions.
struct NMTREEVIEWA
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification message.
    NMHDR   hdr;
    ///Type: <b>UINT</b> Notification-specific action flag. This member is used with the following notification codes.
    ///<ul> <li> TVN_ITEMEXPANDING </li> <li> TVN_ITEMEXPANDED </li> <li> TVN_SELCHANGING </li> <li> TVN_SELCHANGED
    ///</li> </ul> For the possible action flag values, see TVM_EXPAND and TVN_SELCHANGED.
    uint    action;
    ///Type: <b>TVITEM</b> TVITEM structure that contains information about the old item state. This member is zero for
    ///notification messages that do not use it.
    TVITEMA itemOld;
    ///Type: <b>TVITEM</b> TVITEM structure that contains information about the new item state. This member is zero for
    ///notification messages that do not use it.
    TVITEMA itemNew;
    ///Type: <b>POINT</b> POINT structure that contains the client coordinates of the mouse at the time the event
    ///occurred that caused the notification message to be sent.
    POINT   ptDrag;
}

///Contains information about a tree-view notification message. This structure is identical to the <b>NM_TREEVIEW</b>
///structure, but it has been renamed to follow current naming conventions.
struct NMTREEVIEWW
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification message.
    NMHDR   hdr;
    ///Type: <b>UINT</b> Notification-specific action flag. This member is used with the following notification codes.
    ///<ul> <li> TVN_ITEMEXPANDING </li> <li> TVN_ITEMEXPANDED </li> <li> TVN_SELCHANGING </li> <li> TVN_SELCHANGED
    ///</li> </ul> For the possible action flag values, see TVM_EXPAND and TVN_SELCHANGED.
    uint    action;
    ///Type: <b>TVITEM</b> TVITEM structure that contains information about the old item state. This member is zero for
    ///notification messages that do not use it.
    TVITEMW itemOld;
    ///Type: <b>TVITEM</b> TVITEM structure that contains information about the new item state. This member is zero for
    ///notification messages that do not use it.
    TVITEMW itemNew;
    ///Type: <b>POINT</b> POINT structure that contains the client coordinates of the mouse at the time the event
    ///occurred that caused the notification message to be sent.
    POINT   ptDrag;
}

///Contains and receives display information for a tree-view item. This structure is identical to the <b>TV_DISPINFO</b>
///structure, but it has been renamed to follow current naming conventions.
struct NMTVDISPINFOA
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification.
    NMHDR   hdr;
    ///Type: <b>TVITEM</b> TVITEM structure that identifies and contains information about the tree-view item. The
    ///<b>mask</b> member of the <b>TVITEM</b> structure specifies which information is being set or retrieved. It can
    ///be one or more of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="TVIF_CHILDREN"></a><a id="tvif_children"></a><dl> <dt><b>TVIF_CHILDREN</b></dt> </dl> </td>
    ///<td width="60%"> The <b>cChildren</b> member specifies, or is to receive, a value that indicates whether the item
    ///has child items. </td> </tr> <tr> <td width="40%"><a id="TVIF_IMAGE"></a><a id="tvif_image"></a><dl>
    ///<dt><b>TVIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The <b>iImage</b> member specifies, or is to receive, the
    ///index of the item's nonselected icon in the image list. </td> </tr> <tr> <td width="40%"><a
    ///id="TVIF_SELECTEDIMAGE"></a><a id="tvif_selectedimage"></a><dl> <dt><b>TVIF_SELECTEDIMAGE</b></dt> </dl> </td>
    ///<td width="60%"> The <b>iSelectedImage</b> member specifies, or is to receive, the index of the item's selected
    ///icon in the image list. </td> </tr> <tr> <td width="40%"><a id="TVIF_TEXT"></a><a id="tvif_text"></a><dl>
    ///<dt><b>TVIF_TEXT</b></dt> </dl> </td> <td width="60%"> The <b>pszText</b> member specifies the new item text or
    ///the address of a buffer that is to receive the item text. If the structure is receiving item text, you typically
    ///copy the text to the buffer pointed to by the <b>pszText</b> member of the TVITEM structure. However, you can
    ///return a string in the <b>pszText</b> member instead. If you do so, you cannot change or delete the string until
    ///the corresponding item text is deleted or until two additional TVN_GETDISPINFO notification codes have been sent.
    ///</td> </tr> </table>
    TVITEMA item;
}

///Contains and receives display information for a tree-view item. This structure is identical to the <b>TV_DISPINFO</b>
///structure, but it has been renamed to follow current naming conventions.
struct NMTVDISPINFOW
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification.
    NMHDR   hdr;
    ///Type: <b>TVITEM</b> TVITEM structure that identifies and contains information about the tree-view item. The
    ///<b>mask</b> member of the <b>TVITEM</b> structure specifies which information is being set or retrieved. It can
    ///be one or more of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="TVIF_CHILDREN"></a><a id="tvif_children"></a><dl> <dt><b>TVIF_CHILDREN</b></dt> </dl> </td>
    ///<td width="60%"> The <b>cChildren</b> member specifies, or is to receive, a value that indicates whether the item
    ///has child items. </td> </tr> <tr> <td width="40%"><a id="TVIF_IMAGE"></a><a id="tvif_image"></a><dl>
    ///<dt><b>TVIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The <b>iImage</b> member specifies, or is to receive, the
    ///index of the item's nonselected icon in the image list. </td> </tr> <tr> <td width="40%"><a
    ///id="TVIF_SELECTEDIMAGE"></a><a id="tvif_selectedimage"></a><dl> <dt><b>TVIF_SELECTEDIMAGE</b></dt> </dl> </td>
    ///<td width="60%"> The <b>iSelectedImage</b> member specifies, or is to receive, the index of the item's selected
    ///icon in the image list. </td> </tr> <tr> <td width="40%"><a id="TVIF_TEXT"></a><a id="tvif_text"></a><dl>
    ///<dt><b>TVIF_TEXT</b></dt> </dl> </td> <td width="60%"> The <b>pszText</b> member specifies the new item text or
    ///the address of a buffer that is to receive the item text. If the structure is receiving item text, you typically
    ///copy the text to the buffer pointed to by the <b>pszText</b> member of the TVITEM structure. However, you can
    ///return a string in the <b>pszText</b> member instead. If you do so, you cannot change or delete the string until
    ///the corresponding item text is deleted or until two additional TVN_GETDISPINFO notification codes have been sent.
    ///</td> </tr> </table>
    TVITEMW item;
}

///Contains information pertaining to extended TreeView notification information.
struct NMTVDISPINFOEXA
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification.
    NMHDR     hdr;
    ///Type: <b>TVITEMEX</b> Specifies or receives attributes of a TreeView item.
    TVITEMEXA item;
}

///Contains information pertaining to extended TreeView notification information.
struct NMTVDISPINFOEXW
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification.
    NMHDR     hdr;
    ///Type: <b>TVITEMEX</b> Specifies or receives attributes of a TreeView item.
    TVITEMEXW item;
}

///Contains information about a keyboard event in a tree-view control. This structure is used with the TVN_KEYDOWN
///notification code. The structure is identical to the <b>TV_KEYDOWN</b> structure, but it has been renamed to follow
///current naming conventions.
struct NMTVKEYDOWN
{
align (1):
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification.
    NMHDR  hdr;
    ///Type: <b>WORD</b> Virtual key code.
    ushort wVKey;
    ///Type: <b>UINT</b> Always zero.
    uint   flags;
}

///Contains information specific to an NM_CUSTOMDRAW (tree view) notification code sent by a tree-view control.
struct NMTVCUSTOMDRAW
{
    ///Type: <b>NMCUSTOMDRAW</b> NMCUSTOMDRAW structure that contains general custom draw information.
    NMCUSTOMDRAW nmcd;
    ///Type: <b>COLORREF</b> COLORREF value representing the color that will be used to display text foreground in the
    ///tree-view control.
    uint         clrText;
    ///Type: <b>COLORREF</b> COLORREF value representing the color that will be used to display text background in the
    ///tree-view control.
    uint         clrTextBk;
    int          iLevel;
}

///Contains and receives tree-view item information needed to display a tooltip for an item. This structure is used with
///the TVN_GETINFOTIP notification code.
struct NMTVGETINFOTIPA
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification.
    NMHDR      hdr;
    ///Type: <b>LPTSTR</b> Address of a character buffer that contains the text to be displayed. If you want to change
    ///the text displayed in the tooltip, you will need to modify the contents of this buffer. The size of this buffer
    ///is specified by the <b>cchTextMax</b> structure.
    PSTR       pszText;
    ///Type: <b>int</b> Size of the buffer at <b>pszText</b>, in characters. Although you should never assume that this
    ///buffer will be of any particular size, the INFOTIPSIZE value can be used for design purposes.
    int        cchTextMax;
    ///Type: <b>HTREEITEM</b> Tree handle to the item for which the tooltip is being displayed.
    _TREEITEM* hItem;
    ///Type: <b>LPARAM</b> Application-defined data associated with the item for which the tooltip is being displayed.
    LPARAM     lParam;
}

///Contains and receives tree-view item information needed to display a tooltip for an item. This structure is used with
///the TVN_GETINFOTIP notification code.
struct NMTVGETINFOTIPW
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification.
    NMHDR      hdr;
    ///Type: <b>LPTSTR</b> Address of a character buffer that contains the text to be displayed. If you want to change
    ///the text displayed in the tooltip, you will need to modify the contents of this buffer. The size of this buffer
    ///is specified by the <b>cchTextMax</b> structure.
    PWSTR      pszText;
    ///Type: <b>int</b> Size of the buffer at <b>pszText</b>, in characters. Although you should never assume that this
    ///buffer will be of any particular size, the INFOTIPSIZE value can be used for design purposes.
    int        cchTextMax;
    ///Type: <b>HTREEITEM</b> Tree handle to the item for which the tooltip is being displayed.
    _TREEITEM* hItem;
    ///Type: <b>LPARAM</b> Application-defined data associated with the item for which the tooltip is being displayed.
    LPARAM     lParam;
}

///Contains information on a tree-view item change. This structure is sent with the TVN_ITEMCHANGED and TVN_ITEMCHANGING
///notifications.
struct NMTVITEMCHANGE
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about the notification.
    NMHDR      hdr;
    ///Type: <b>UINT</b> Specifies the attribute. The only supported attribute is state. <b>uChanged</b> must have the
    ///following value: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl>
    ///<dt><b></b></dt> <dt>TVIF_STATE</dt> </dl> </td> <td width="60%"> The change is the state attribute. </td> </tr>
    ///</table>
    uint       uChanged;
    ///Type: <b>HTREEITEM</b> Handle to the changed tree-view item.
    _TREEITEM* hItem;
    ///Type: <b>UINT</b> Flag that specifies the new item state.
    uint       uStateNew;
    ///Type: <b>UINT</b> Flag that specifies the item's previous state.
    uint       uStateOld;
    LPARAM     lParam;
}

///Contains an explanation of why the draw of an icon or overlay tree item failed. This structure is sent on a
///TVN_ASYNCDRAW notification. Set the <b>dwRetFlags</b> member to indicate what action the control should take. Note
///that a draw can fail if there is no image; in other words, when the icon image has not been extracted.
struct NMTVASYNCDRAW
{
    ///Type: <b>NMHDR</b> NMHDR structure.
    NMHDR                hdr;
    ///Type: <b>IMAGELISTDRAWPARAMS*</b> IMAGELISTDRAWPARAMS structure describing the image that failed to draw.
    IMAGELISTDRAWPARAMS* pimldp;
    ///Type: <b>HRESULT</b> Result code indicating why the draw failed, either ILDRF_IMAGELOWQUALITY,
    ///ILDRF_OVERLAYLOWQUALITY, E_PENDING, or S_OK. A code of S_OK indicates that the image is present but not at the
    ///required image quality.
    HRESULT              hr;
    ///Type: <b>HTREEITEM</b> Handle of the tree item that failed to draw.
    _TREEITEM*           hItem;
    ///Type: <b>LPARAM</b> Data for <b>hItem</b>. This is the same data for the item that is retrieved with the message
    ///TVM_GETITEM using the appropriate <b>mask</b> in structure TVITEM. This data is parent specific; the parent can
    ///store information that helps it identify the tree item or other information. Data is provided in <b>lParam</b>
    ///for convenience, so that the parent does not need to send message <b>TVM_GETITEM</b>.
    LPARAM               lParam;
    ///Type: <b>DWORD</b> Action that the sender (the tree-view control) should execute on return. Value must be one of
    ///the following flags: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="ADRF_DRAWIMAGE"></a><a id="adrf_drawimage"></a><dl> <dt><b>ADRF_DRAWIMAGE</b></dt> </dl> </td> <td
    ///width="60%"> Draw the image specified by <b>iRetImageIndex</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="ADRF_DRAWSYNC"></a><a id="adrf_drawsync"></a><dl> <dt><b>ADRF_DRAWSYNC</b></dt> </dl> </td> <td width="60%">
    ///Proceed to draw the image anyway, that is, synchronously extract the image and paint. Assuming the control is on
    ///the UI thread, use of this flag implies low priority UI performance, since extraction times may vary and the UI
    ///could be unresponsive for an extended period of time during extraction. </td> </tr> <tr> <td width="40%"><a
    ///id="ADRF_DRAWNOTHING"></a><a id="adrf_drawnothing"></a><dl> <dt><b>ADRF_DRAWNOTHING</b></dt> </dl> </td> <td
    ///width="60%"> Do not draw an image. </td> </tr> </table>
    uint                 dwRetFlags;
    int                  iRetImageIndex;
}

///Contains information about an item in a ComboBoxEx control.
struct COMBOBOXEXITEMA
{
    ///Type: <b>UINT</b> A set of bit flags that specify attributes of this structure or of an operation that is using
    ///this structure. The flags specify members that are valid or must be filled in. This member can be a combination
    ///of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="CBEIF_DI_SETITEM"></a><a id="cbeif_di_setitem"></a><dl> <dt><b>CBEIF_DI_SETITEM</b></dt> </dl> </td> <td
    ///width="60%"> Set this flag when processing CBEN_GETDISPINFO; the ComboBoxEx control will retain the supplied
    ///information and will not request it again. </td> </tr> <tr> <td width="40%"><a id="CBEIF_IMAGE"></a><a
    ///id="cbeif_image"></a><dl> <dt><b>CBEIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The <b>iImage</b> member is
    ///valid or must be filled in. </td> </tr> <tr> <td width="40%"><a id="CBEIF_INDENT"></a><a
    ///id="cbeif_indent"></a><dl> <dt><b>CBEIF_INDENT</b></dt> </dl> </td> <td width="60%"> The <b>iIndent</b> member is
    ///valid or must be filled in. </td> </tr> <tr> <td width="40%"><a id="CBEIF_LPARAM"></a><a
    ///id="cbeif_lparam"></a><dl> <dt><b>CBEIF_LPARAM</b></dt> </dl> </td> <td width="60%"> The <b>lParam</b> member is
    ///valid or must be filled in. </td> </tr> <tr> <td width="40%"><a id="CBEIF_OVERLAY"></a><a
    ///id="cbeif_overlay"></a><dl> <dt><b>CBEIF_OVERLAY</b></dt> </dl> </td> <td width="60%"> The <b>iOverlay</b> member
    ///is valid or must be filled in. </td> </tr> <tr> <td width="40%"><a id="CBEIF_SELECTEDIMAGE"></a><a
    ///id="cbeif_selectedimage"></a><dl> <dt><b>CBEIF_SELECTEDIMAGE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iSelectedImage</b> member is valid or must be filled in. </td> </tr> <tr> <td width="40%"><a
    ///id="CBEIF_TEXT"></a><a id="cbeif_text"></a><dl> <dt><b>CBEIF_TEXT</b></dt> </dl> </td> <td width="60%"> The
    ///<b>pszText</b> member is valid or must be filled in. </td> </tr> </table>
    uint      mask;
    ///Type: <b>INT_PTR</b> The zero-based index of the item.
    ptrdiff_t iItem;
    ///Type: <b>LPTSTR</b> A pointer to a character buffer that contains or receives the item's text. If text
    ///information is being retrieved, this member must be set to the address of a character buffer that will receive
    ///the text. The size of this buffer must also be indicated in <b>cchTextMax</b>. If this member is set to
    ///LPSTR_TEXTCALLBACK, the control will request the information by using the CBEN_GETDISPINFO notification codes.
    PSTR      pszText;
    ///Type: <b>int</b> The length of <b>pszText</b>, in <b>TCHAR</b><b>s</b>. If text information is being set, this
    ///member is ignored.
    int       cchTextMax;
    ///Type: <b>int</b> The zero-based index of an image within the image list. The specified image will be displayed
    ///for the item when it is not selected. If this member is set to I_IMAGECALLBACK, the control will request the
    ///information by using CBEN_GETDISPINFO notification codes.
    int       iImage;
    ///Type: <b>int</b> The zero-based index of an image within the image list. The specified image will be displayed
    ///for the item when it is selected. If this member is set to I_IMAGECALLBACK, the control will request the
    ///information by using CBEN_GETDISPINFO notification codes.
    int       iSelectedImage;
    ///Type: <b>int</b> The one-based index of an overlay image within the image list. If this member is set to
    ///I_IMAGECALLBACK, the control will request the information by using CBEN_GETDISPINFO notification codes.
    int       iOverlay;
    ///Type: <b>int</b> The number of indent spaces to display for the item. Each indentation equals 10 pixels. If this
    ///member is set to I_INDENTCALLBACK, the control will request the information by using CBEN_GETDISPINFO
    ///notification codes.
    int       iIndent;
    ///Type: <b>LPARAM</b> A value specific to the item.
    LPARAM    lParam;
}

///Contains information about an item in a ComboBoxEx control.
struct COMBOBOXEXITEMW
{
    ///Type: <b>UINT</b> A set of bit flags that specify attributes of this structure or of an operation that is using
    ///this structure. The flags specify members that are valid or must be filled in. This member can be a combination
    ///of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="CBEIF_DI_SETITEM"></a><a id="cbeif_di_setitem"></a><dl> <dt><b>CBEIF_DI_SETITEM</b></dt> </dl> </td> <td
    ///width="60%"> Set this flag when processing CBEN_GETDISPINFO; the ComboBoxEx control will retain the supplied
    ///information and will not request it again. </td> </tr> <tr> <td width="40%"><a id="CBEIF_IMAGE"></a><a
    ///id="cbeif_image"></a><dl> <dt><b>CBEIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The <b>iImage</b> member is
    ///valid or must be filled in. </td> </tr> <tr> <td width="40%"><a id="CBEIF_INDENT"></a><a
    ///id="cbeif_indent"></a><dl> <dt><b>CBEIF_INDENT</b></dt> </dl> </td> <td width="60%"> The <b>iIndent</b> member is
    ///valid or must be filled in. </td> </tr> <tr> <td width="40%"><a id="CBEIF_LPARAM"></a><a
    ///id="cbeif_lparam"></a><dl> <dt><b>CBEIF_LPARAM</b></dt> </dl> </td> <td width="60%"> The <b>lParam</b> member is
    ///valid or must be filled in. </td> </tr> <tr> <td width="40%"><a id="CBEIF_OVERLAY"></a><a
    ///id="cbeif_overlay"></a><dl> <dt><b>CBEIF_OVERLAY</b></dt> </dl> </td> <td width="60%"> The <b>iOverlay</b> member
    ///is valid or must be filled in. </td> </tr> <tr> <td width="40%"><a id="CBEIF_SELECTEDIMAGE"></a><a
    ///id="cbeif_selectedimage"></a><dl> <dt><b>CBEIF_SELECTEDIMAGE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iSelectedImage</b> member is valid or must be filled in. </td> </tr> <tr> <td width="40%"><a
    ///id="CBEIF_TEXT"></a><a id="cbeif_text"></a><dl> <dt><b>CBEIF_TEXT</b></dt> </dl> </td> <td width="60%"> The
    ///<b>pszText</b> member is valid or must be filled in. </td> </tr> </table>
    uint      mask;
    ///Type: <b>INT_PTR</b> The zero-based index of the item.
    ptrdiff_t iItem;
    ///Type: <b>LPTSTR</b> A pointer to a character buffer that contains or receives the item's text. If text
    ///information is being retrieved, this member must be set to the address of a character buffer that will receive
    ///the text. The size of this buffer must also be indicated in <b>cchTextMax</b>. If this member is set to
    ///LPSTR_TEXTCALLBACK, the control will request the information by using the CBEN_GETDISPINFO notification codes.
    PWSTR     pszText;
    ///Type: <b>int</b> The length of <b>pszText</b>, in <b>TCHAR</b><b>s</b>. If text information is being set, this
    ///member is ignored.
    int       cchTextMax;
    ///Type: <b>int</b> The zero-based index of an image within the image list. The specified image will be displayed
    ///for the item when it is not selected. If this member is set to I_IMAGECALLBACK, the control will request the
    ///information by using CBEN_GETDISPINFO notification codes.
    int       iImage;
    ///Type: <b>int</b> The zero-based index of an image within the image list. The specified image will be displayed
    ///for the item when it is selected. If this member is set to I_IMAGECALLBACK, the control will request the
    ///information by using CBEN_GETDISPINFO notification codes.
    int       iSelectedImage;
    ///Type: <b>int</b> The one-based index of an overlay image within the image list. If this member is set to
    ///I_IMAGECALLBACK, the control will request the information by using CBEN_GETDISPINFO notification codes.
    int       iOverlay;
    ///Type: <b>int</b> The number of indent spaces to display for the item. Each indentation equals 10 pixels. If this
    ///member is set to I_INDENTCALLBACK, the control will request the information by using CBEN_GETDISPINFO
    ///notification codes.
    int       iIndent;
    ///Type: <b>LPARAM</b> A value specific to the item.
    LPARAM    lParam;
}

///Contains information specific to ComboBoxEx items for use with notification codes.
struct NMCOMBOBOXEXA
{
    ///Type: <b>NMHDR</b> The NMHDR structure that contains information about the notification code.
    NMHDR           hdr;
    ///Type: <b>COMBOBOXEXITEM</b> The COMBOBOXEXITEM structure that holds item information specific to the current
    ///notification. Upon receiving a notification code, the <b>COMBOBOXEXITEM</b> structure holds information required
    ///for the owner to respond. The members of this structure are often used as fields for the owner to return values
    ///in response to the notification.
    COMBOBOXEXITEMA ceItem;
}

///Contains information specific to ComboBoxEx items for use with notification codes.
struct NMCOMBOBOXEXW
{
    ///Type: <b>NMHDR</b> The NMHDR structure that contains information about the notification code.
    NMHDR           hdr;
    ///Type: <b>COMBOBOXEXITEM</b> The COMBOBOXEXITEM structure that holds item information specific to the current
    ///notification. Upon receiving a notification code, the <b>COMBOBOXEXITEM</b> structure holds information required
    ///for the owner to respond. The members of this structure are often used as fields for the owner to return values
    ///in response to the notification.
    COMBOBOXEXITEMW ceItem;
}

///Contains information used with the CBEN_DRAGBEGIN notification code.
struct NMCBEDRAGBEGINW
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains information about the notification code.
    NMHDR       hdr;
    ///Type: <b>int</b> The zero-based index of the item being dragged. This value will always be -1, indicating that
    ///the item being dragged is the item displayed in the edit portion of the control.
    int         iItemid;
    ///Type: <b>TCHAR</b> The character buffer that contains the text of the item being dragged.
    ushort[260] szText;
}

///Contains information used with the CBEN_DRAGBEGIN notification code.
struct NMCBEDRAGBEGINA
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains information about the notification code.
    NMHDR     hdr;
    ///Type: <b>int</b> The zero-based index of the item being dragged. This value will always be -1, indicating that
    ///the item being dragged is the item displayed in the edit portion of the control.
    int       iItemid;
    ///Type: <b>TCHAR</b> The character buffer that contains the text of the item being dragged.
    byte[260] szText;
}

///Contains information about the conclusion of an edit operation within a ComboBoxEx control. This structure is used
///with the CBEN_ENDEDIT notification code.
struct NMCBEENDEDITW
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains information about the notification code.
    NMHDR       hdr;
    ///Type: <b>BOOL</b> A value indicating whether the contents of the control's edit box have changed. This value is
    ///nonzero if the contents have been modified, or zero otherwise.
    BOOL        fChanged;
    ///Type: <b>int</b> The zero-based index of the item that will be selected after completing the edit operation. This
    ///value can be CB_ERR if no item will be selected.
    int         iNewSelection;
    ///Type: <b>TCHAR</b> A zero-terminated string that contains the text from within the control's edit box.
    ushort[260] szText;
    ///Type: <b>int</b> A value that specifies the action that generated the CBEN_ENDEDIT notification code. This value
    ///can be one of the following: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="CBENF_DROPDOWN"></a><a id="cbenf_dropdown"></a><dl> <dt><b>CBENF_DROPDOWN</b></dt> </dl> </td> <td
    ///width="60%"> The user activated the drop-down list. </td> </tr> <tr> <td width="40%"><a id="CBENF_ESCAPE"></a><a
    ///id="cbenf_escape"></a><dl> <dt><b>CBENF_ESCAPE</b></dt> </dl> </td> <td width="60%"> The user pressed ESC. </td>
    ///</tr> <tr> <td width="40%"><a id="CBENF_KILLFOCUS"></a><a id="cbenf_killfocus"></a><dl>
    ///<dt><b>CBENF_KILLFOCUS</b></dt> </dl> </td> <td width="60%"> The edit box lost the keyboard focus. </td> </tr>
    ///<tr> <td width="40%"><a id="CBENF_RETURN"></a><a id="cbenf_return"></a><dl> <dt><b>CBENF_RETURN</b></dt> </dl>
    ///</td> <td width="60%"> The user completed the edit operation by pressing ENTER. </td> </tr> </table>
    int         iWhy;
}

///Contains information about the conclusion of an edit operation within a ComboBoxEx control. This structure is used
///with the CBEN_ENDEDIT notification code.
struct NMCBEENDEDITA
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains information about the notification code.
    NMHDR     hdr;
    ///Type: <b>BOOL</b> A value indicating whether the contents of the control's edit box have changed. This value is
    ///nonzero if the contents have been modified, or zero otherwise.
    BOOL      fChanged;
    ///Type: <b>int</b> The zero-based index of the item that will be selected after completing the edit operation. This
    ///value can be CB_ERR if no item will be selected.
    int       iNewSelection;
    ///Type: <b>TCHAR</b> A zero-terminated string that contains the text from within the control's edit box.
    byte[260] szText;
    ///Type: <b>int</b> A value that specifies the action that generated the CBEN_ENDEDIT notification code. This value
    ///can be one of the following: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="CBENF_DROPDOWN"></a><a id="cbenf_dropdown"></a><dl> <dt><b>CBENF_DROPDOWN</b></dt> </dl> </td> <td
    ///width="60%"> The user activated the drop-down list. </td> </tr> <tr> <td width="40%"><a id="CBENF_ESCAPE"></a><a
    ///id="cbenf_escape"></a><dl> <dt><b>CBENF_ESCAPE</b></dt> </dl> </td> <td width="60%"> The user pressed ESC. </td>
    ///</tr> <tr> <td width="40%"><a id="CBENF_KILLFOCUS"></a><a id="cbenf_killfocus"></a><dl>
    ///<dt><b>CBENF_KILLFOCUS</b></dt> </dl> </td> <td width="60%"> The edit box lost the keyboard focus. </td> </tr>
    ///<tr> <td width="40%"><a id="CBENF_RETURN"></a><a id="cbenf_return"></a><dl> <dt><b>CBENF_RETURN</b></dt> </dl>
    ///</td> <td width="60%"> The user completed the edit operation by pressing ENTER. </td> </tr> </table>
    int       iWhy;
}

///Specifies or receives the attributes of a tab. It is used with the TCM_INSERTITEM, TCM_GETITEM, and TCM_SETITEM
///messages. This structure supersedes the <b>TC_ITEMHEADER</b> structure.
struct TCITEMHEADERA
{
    ///Type: <b>UINT</b> Value that specifies which members to retrieve or set. This member can be a combination of the
    ///following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TCIF_IMAGE"></a><a id="tcif_image"></a><dl> <dt><b>TCIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iImage</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TCIF_RTLREADING"></a><a
    ///id="tcif_rtlreading"></a><dl> <dt><b>TCIF_RTLREADING</b></dt> </dl> </td> <td width="60%"> The string pointed to
    ///by <b>pszText</b> will be displayed in the direction opposite to the text in the parent window. </td> </tr> <tr>
    ///<td width="40%"><a id="TCIF_TEXT"></a><a id="tcif_text"></a><dl> <dt><b>TCIF_TEXT</b></dt> </dl> </td> <td
    ///width="60%"> The <b>pszText</b> member is valid. </td> </tr> </table>
    uint mask;
    ///Type: <b>UINT</b> Reserved member. Do not use.
    uint lpReserved1;
    ///Type: <b>UINT</b> Reserved member. Do not use.
    uint lpReserved2;
    ///Type: <b>LPTSTR</b> Address of a null-terminated string that contains the tab text if item information is being
    ///set. If item information is being retrieved, this member specifies the address of the buffer that receives the
    ///tab text.
    PSTR pszText;
    ///Type: <b>int</b> Size of the buffer pointed to by the pszText member. If the structure is not receiving
    ///information, this member is ignored.
    int  cchTextMax;
    ///Type: <b>int</b> Index into the tab control's image list, or -1 if there is no image for the tab.
    int  iImage;
}

///Specifies or receives the attributes of a tab. It is used with the TCM_INSERTITEM, TCM_GETITEM, and TCM_SETITEM
///messages. This structure supersedes the <b>TC_ITEMHEADER</b> structure.
struct TCITEMHEADERW
{
    ///Type: <b>UINT</b> Value that specifies which members to retrieve or set. This member can be a combination of the
    ///following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TCIF_IMAGE"></a><a id="tcif_image"></a><dl> <dt><b>TCIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iImage</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TCIF_RTLREADING"></a><a
    ///id="tcif_rtlreading"></a><dl> <dt><b>TCIF_RTLREADING</b></dt> </dl> </td> <td width="60%"> The string pointed to
    ///by <b>pszText</b> will be displayed in the direction opposite to the text in the parent window. </td> </tr> <tr>
    ///<td width="40%"><a id="TCIF_TEXT"></a><a id="tcif_text"></a><dl> <dt><b>TCIF_TEXT</b></dt> </dl> </td> <td
    ///width="60%"> The <b>pszText</b> member is valid. </td> </tr> </table>
    uint  mask;
    ///Type: <b>UINT</b> Reserved member. Do not use.
    uint  lpReserved1;
    ///Type: <b>UINT</b> Reserved member. Do not use.
    uint  lpReserved2;
    ///Type: <b>LPTSTR</b> Address of a null-terminated string that contains the tab text if item information is being
    ///set. If item information is being retrieved, this member specifies the address of the buffer that receives the
    ///tab text.
    PWSTR pszText;
    ///Type: <b>int</b> Size of the buffer pointed to by the pszText member. If the structure is not receiving
    ///information, this member is ignored.
    int   cchTextMax;
    ///Type: <b>int</b> Index into the tab control's image list, or -1 if there is no image for the tab.
    int   iImage;
}

///Specifies or receives the attributes of a tab item. It is used with the TCM_INSERTITEM, TCM_GETITEM, and TCM_SETITEM
///messages. This structure supersedes the <b>TC_ITEM</b> structure.
struct TCITEMA
{
    ///Type: <b>UINT</b> Value that specifies which members to retrieve or set. This member can be a combination of the
    ///following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TCIF_IMAGE"></a><a id="tcif_image"></a><dl> <dt><b>TCIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iImage</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TCIF_PARAM"></a><a
    ///id="tcif_param"></a><dl> <dt><b>TCIF_PARAM</b></dt> </dl> </td> <td width="60%"> The <b>lParam</b> member is
    ///valid. </td> </tr> <tr> <td width="40%"><a id="TCIF_RTLREADING"></a><a id="tcif_rtlreading"></a><dl>
    ///<dt><b>TCIF_RTLREADING</b></dt> </dl> </td> <td width="60%"> The string pointed to by <b>pszText</b> will be
    ///displayed in the direction opposite to the text in the parent window. </td> </tr> <tr> <td width="40%"><a
    ///id="TCIF_STATE"></a><a id="tcif_state"></a><dl> <dt><b>TCIF_STATE</b></dt> </dl> </td> <td width="60%"> Version
    ///4.70. The <b>dwState</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TCIF_TEXT"></a><a
    ///id="tcif_text"></a><dl> <dt><b>TCIF_TEXT</b></dt> </dl> </td> <td width="60%"> The <b>pszText</b> member is
    ///valid. </td> </tr> </table>
    uint   mask;
    ///Type: <b>DWORD</b> Version 4.70. Specifies the item's current state if information is being retrieved. If item
    ///information is being set, this member contains the state value to be set for the item. For a list of valid tab
    ///control item states, see Tab Control Item States. This member is ignored in the TCM_INSERTITEM message.
    uint   dwState;
    ///Type: <b>DWORD</b> Version 4.70. Specifies which bits of the <b>dwState</b> member contain valid information.
    ///This member is ignored in the TCM_INSERTITEM message.
    uint   dwStateMask;
    ///Type: <b>LPTSTR</b> Pointer to a null-terminated string that contains the tab text when item information is being
    ///set. If item information is being retrieved, this member specifies the address of the buffer that receives the
    ///tab text.
    PSTR   pszText;
    ///Type: <b>int</b> Size in <b>TCHAR</b><b>s</b> of the buffer pointed to by the <b>pszText</b> member. If the
    ///structure is not receiving information, this member is ignored.
    int    cchTextMax;
    ///Type: <b>int</b> Index in the tab control's image list, or -1 if there is no image for the tab.
    int    iImage;
    ///Type: <b>LPARAM</b> Application-defined data associated with the tab control item. If more or less than 4 bytes
    ///of application-defined data exist per tab, an application must define a structure and use it instead of the
    ///<b>TCITEM</b> structure. The first member of the application-defined structure must be a TCITEMHEADER structure.
    LPARAM lParam;
}

///Specifies or receives the attributes of a tab item. It is used with the TCM_INSERTITEM, TCM_GETITEM, and TCM_SETITEM
///messages. This structure supersedes the <b>TC_ITEM</b> structure.
struct TCITEMW
{
    ///Type: <b>UINT</b> Value that specifies which members to retrieve or set. This member can be a combination of the
    ///following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TCIF_IMAGE"></a><a id="tcif_image"></a><dl> <dt><b>TCIF_IMAGE</b></dt> </dl> </td> <td width="60%"> The
    ///<b>iImage</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TCIF_PARAM"></a><a
    ///id="tcif_param"></a><dl> <dt><b>TCIF_PARAM</b></dt> </dl> </td> <td width="60%"> The <b>lParam</b> member is
    ///valid. </td> </tr> <tr> <td width="40%"><a id="TCIF_RTLREADING"></a><a id="tcif_rtlreading"></a><dl>
    ///<dt><b>TCIF_RTLREADING</b></dt> </dl> </td> <td width="60%"> The string pointed to by <b>pszText</b> will be
    ///displayed in the direction opposite to the text in the parent window. </td> </tr> <tr> <td width="40%"><a
    ///id="TCIF_STATE"></a><a id="tcif_state"></a><dl> <dt><b>TCIF_STATE</b></dt> </dl> </td> <td width="60%"> Version
    ///4.70. The <b>dwState</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="TCIF_TEXT"></a><a
    ///id="tcif_text"></a><dl> <dt><b>TCIF_TEXT</b></dt> </dl> </td> <td width="60%"> The <b>pszText</b> member is
    ///valid. </td> </tr> </table>
    uint   mask;
    ///Type: <b>DWORD</b> Version 4.70. Specifies the item's current state if information is being retrieved. If item
    ///information is being set, this member contains the state value to be set for the item. For a list of valid tab
    ///control item states, see Tab Control Item States. This member is ignored in the TCM_INSERTITEM message.
    uint   dwState;
    ///Type: <b>DWORD</b> Version 4.70. Specifies which bits of the <b>dwState</b> member contain valid information.
    ///This member is ignored in the TCM_INSERTITEM message.
    uint   dwStateMask;
    ///Type: <b>LPTSTR</b> Pointer to a null-terminated string that contains the tab text when item information is being
    ///set. If item information is being retrieved, this member specifies the address of the buffer that receives the
    ///tab text.
    PWSTR  pszText;
    ///Type: <b>int</b> Size in <b>TCHAR</b><b>s</b> of the buffer pointed to by the <b>pszText</b> member. If the
    ///structure is not receiving information, this member is ignored.
    int    cchTextMax;
    ///Type: <b>int</b> Index in the tab control's image list, or -1 if there is no image for the tab.
    int    iImage;
    LPARAM lParam;
}

///Contains information about a hit test. This structure supersedes the <b>TC_HITTESTINFO</b> structure.
struct TCHITTESTINFO
{
    ///Type: <b>POINT</b> Position to hit test, in client coordinates.
    POINT pt;
    ///Type: <b>UINT</b> Variable that receives the results of a hit test. The tab control sets this member to one of
    ///the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TCHT_NOWHERE"></a><a id="tcht_nowhere"></a><dl> <dt><b>TCHT_NOWHERE</b></dt> </dl> </td> <td width="60%"> The
    ///position is not over a tab. </td> </tr> <tr> <td width="40%"><a id="TCHT_ONITEM"></a><a id="tcht_onitem"></a><dl>
    ///<dt><b>TCHT_ONITEM</b></dt> </dl> </td> <td width="60%"> The position is over a tab but not over its icon or its
    ///text. For owner-drawn tab controls, this value is specified if the position is anywhere over a tab. </td> </tr>
    ///<tr> <td width="40%"><a id="TCHT_ONITEMICON"></a><a id="tcht_onitemicon"></a><dl> <dt><b>TCHT_ONITEMICON</b></dt>
    ///</dl> </td> <td width="60%"> The position is over a tab's icon. </td> </tr> <tr> <td width="40%"><a
    ///id="TCHT_ONITEMLABEL"></a><a id="tcht_onitemlabel"></a><dl> <dt><b>TCHT_ONITEMLABEL</b></dt> </dl> </td> <td
    ///width="60%"> The position is over a tab's text. </td> </tr> <tr> <td width="40%"><a id=""></a><dl>
    ///<dt><b></b></dt> </dl> </td> <td width="60%"> TCHT_ONITEM is a bitwise-OR operation on TCHT_ONITEMICON and
    ///TCHT_ONITEMLABEL. </td> </tr> </table>
    uint  flags;
}

///Contains information about a key press in a tab control. It is used with the TCN_KEYDOWN notification code. This
///structure supersedes the <b>TC_KEYDOWN</b> structure.
struct NMTCKEYDOWN
{
align (1):
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about the notification.
    NMHDR  hdr;
    ///Type: <b>WORD</b> Virtual key code.
    ushort wVKey;
    uint   flags;
}

///Carries information specific to hit-testing points for a month calendar control. This structure is used with the
///MCM_HITTEST message and the corresponding MonthCal_HitTest macro.
struct MCHITTESTINFO
{
    ///Type: <b>UINT</b> The size of this structure, in bytes.
    uint       cbSize;
    ///Type: <b>POINT</b> Point to be hit-tested.
    POINT      pt;
    ///Type: <b>UINT</b> Output member that receives a bit flag representing the result of the hit-test operation. This
    ///value will be one of the following: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="MCHT_CALENDARBK"></a><a id="mcht_calendarbk"></a><dl> <dt><b>MCHT_CALENDARBK</b></dt> </dl> </td> <td
    ///width="60%"> The given point was in the calendar's background. </td> </tr> <tr> <td width="40%"><a
    ///id="MCHT_CALENDARCONTROL"></a><a id="mcht_calendarcontrol"></a><dl> <dt><b>MCHT_CALENDARCONTROL</b></dt> </dl>
    ///</td> <td width="60%"> The given point is outside of any calendar but within the calendar controls RECT. </td>
    ///</tr> <tr> <td width="40%"><a id="MCHT_CALENDARDATE"></a><a id="mcht_calendardate"></a><dl>
    ///<dt><b>MCHT_CALENDARDATE</b></dt> </dl> </td> <td width="60%"> The given point was on a particular date within
    ///the calendar. The SYSTEMTIME structure at <i>lpMCHitTest</i>&gt;st is set to the date at the given point. </td>
    ///</tr> <tr> <td width="40%"><a id="MCHT_CALENDARDATEMIN"></a><a id="mcht_calendardatemin"></a><dl>
    ///<dt><b>MCHT_CALENDARDATEMIN</b></dt> </dl> </td> <td width="60%"> The given point was over the minimum date(s) in
    ///the calendar. </td> </tr> <tr> <td width="40%"><a id="MCHT_CALENDARDATEMAX"></a><a
    ///id="mcht_calendardatemax"></a><dl> <dt><b>MCHT_CALENDARDATEMAX</b></dt> </dl> </td> <td width="60%"> The given
    ///point was over the maximum date(s) in the calendar. </td> </tr> <tr> <td width="40%"><a
    ///id="MCHT_CALENDARDATENEXT"></a><a id="mcht_calendardatenext"></a><dl> <dt><b>MCHT_CALENDARDATENEXT</b></dt> </dl>
    ///</td> <td width="60%"> The given point was over a date from the next month (partially displayed at the end of the
    ///currently displayed month). If the user clicks here, the month calendar will scroll its display to the next month
    ///or set of months. </td> </tr> <tr> <td width="40%"><a id="MCHT_CALENDARDATEPREV"></a><a
    ///id="mcht_calendardateprev"></a><dl> <dt><b>MCHT_CALENDARDATEPREV</b></dt> </dl> </td> <td width="60%"> The given
    ///point was over a date from the previous month (partially displayed at the end of the currently displayed month).
    ///If the user clicks here, the month calendar will scroll its display to the previous month or set of months. </td>
    ///</tr> <tr> <td width="40%"><a id="MCHT_CALENDARDAY"></a><a id="mcht_calendarday"></a><dl>
    ///<dt><b>MCHT_CALENDARDAY</b></dt> </dl> </td> <td width="60%"> The given point was over a day abbreviation ("Fri",
    ///for example). The SYSTEMTIME structure at <i>lpMCHitTest</i>&gt;st is set to the corresponding date in the top
    ///row. </td> </tr> <tr> <td width="40%"><a id="MCHT_CALENDARWEEKNUM"></a><a id="mcht_calendarweeknum"></a><dl>
    ///<dt><b>MCHT_CALENDARWEEKNUM</b></dt> </dl> </td> <td width="60%"> The given point was over a week number
    ///(MCS_WEEKNUMBERS style only). The SYSTEMTIME structure at <i>lpMCHitTest</i>&gt;st is set to the corresponding
    ///date in the leftmost column. </td> </tr> <tr> <td width="40%"><a id="MCHT_NOWHERE"></a><a
    ///id="mcht_nowhere"></a><dl> <dt><b>MCHT_NOWHERE</b></dt> </dl> </td> <td width="60%"> The given point was not on
    ///the month calendar control, or it was in an inactive portion of the control. </td> </tr> <tr> <td width="40%"><a
    ///id="MCHT_TITLEBK"></a><a id="mcht_titlebk"></a><dl> <dt><b>MCHT_TITLEBK</b></dt> </dl> </td> <td width="60%"> The
    ///given point was over the background of a month's title. </td> </tr> <tr> <td width="40%"><a
    ///id="MCHT_TITLEBTNNEXT"></a><a id="mcht_titlebtnnext"></a><dl> <dt><b>MCHT_TITLEBTNNEXT</b></dt> </dl> </td> <td
    ///width="60%"> The given point was over the button at the top right corner of the control. If the user clicks here,
    ///the month calendar will scroll its display to the next month or set of months. </td> </tr> <tr> <td
    ///width="40%"><a id="MCHT_TITLEBTNPREV"></a><a id="mcht_titlebtnprev"></a><dl> <dt><b>MCHT_TITLEBTNPREV</b></dt>
    ///</dl> </td> <td width="60%"> The given point was over the button at the top left corner of the control. If the
    ///user clicks here, the month calendar will scroll its display to the previous month or set of months. </td> </tr>
    ///<tr> <td width="40%"><a id="MCHT_TITLEMONTH"></a><a id="mcht_titlemonth"></a><dl> <dt><b>MCHT_TITLEMONTH</b></dt>
    ///</dl> </td> <td width="60%"> The given point was in a month's title bar, over a month name. </td> </tr> <tr> <td
    ///width="40%"><a id="MCHT_TITLEYEAR"></a><a id="mcht_titleyear"></a><dl> <dt><b>MCHT_TITLEYEAR</b></dt> </dl> </td>
    ///<td width="60%"> The given point was in a month's title bar, over the year value. </td> </tr> </table>
    uint       uHit;
    ///Type: <b>SYSTEMTIME</b> Receives date and time information specific to the location that was hit-tested.
    SYSTEMTIME st;
    ///Type: <b>RECT</b> Hit-tested location.
    RECT       rc;
    ///Type: <b>int</b> When displaying more than one calendar, this is the offset of the calendar at the hit-tested
    ///point (zero-based).
    int        iOffset;
    ///Type: <b>int</b> The row number for the calendar grid that the given hit point was over. Example: If you
    ///hit-tested the 8th of a month, which is in the second week of the month, <b>iRow</b> will be one since the index
    ///of the row is zero-based row index.
    int        iRow;
    ///Type: <b>int</b> The column number for the calendar grid that the given point was over. For example, if your week
    ///starts on Sunday and the 1st of the month is Friday, hit testing the 1st will return five (5) for <b>iCol</b>,
    ///since Friday is in the fifth column from the beginning of the row, using a zero-based column index.
    int        iCol;
}

///Contains information about part of a calendar control.
struct MCGRIDINFO
{
    ///Type: <b>UINT</b> Size of this structure, in bytes.
    uint       cbSize;
    ///Type: <b>DWORD</b> The part of the calendar control for which information is being requested. One of the
    ///following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="MCGIP_CALENDARCONTROL"></a><a id="mcgip_calendarcontrol"></a><dl> <dt><b>MCGIP_CALENDARCONTROL</b></dt> </dl>
    ///</td> <td width="60%"> The entire calendar control, which may include up to 12 calendars. </td> </tr> <tr> <td
    ///width="40%"><a id="MCGIP_NEXT"></a><a id="mcgip_next"></a><dl> <dt><b>MCGIP_NEXT</b></dt> </dl> </td> <td
    ///width="60%"> The next button. </td> </tr> <tr> <td width="40%"><a id="MCGIP_PREV"></a><a id="mcgip_prev"></a><dl>
    ///<dt><b>MCGIP_PREV</b></dt> </dl> </td> <td width="60%"> The previous button. </td> </tr> <tr> <td width="40%"><a
    ///id="MCGIP_FOOTER"></a><a id="mcgip_footer"></a><dl> <dt><b>MCGIP_FOOTER</b></dt> </dl> </td> <td width="60%"> The
    ///footer. </td> </tr> <tr> <td width="40%"><a id="MCGIP_CALENDAR"></a><a id="mcgip_calendar"></a><dl>
    ///<dt><b>MCGIP_CALENDAR</b></dt> </dl> </td> <td width="60%"> One specific calendar. Used with <b>iCalendar</b> and
    ///<b>pszName</b>. </td> </tr> <tr> <td width="40%"><a id="MCGIP_CALENDARHEADER"></a><a
    ///id="mcgip_calendarheader"></a><dl> <dt><b>MCGIP_CALENDARHEADER</b></dt> </dl> </td> <td width="60%"> Calendar
    ///header. Used with <b>iCalendar</b> and <b>pszName</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="MCGIP_CALENDARBODY"></a><a id="mcgip_calendarbody"></a><dl> <dt><b>MCGIP_CALENDARBODY</b></dt> </dl> </td>
    ///<td width="60%"> Calendar body. Used with <b>iCalendar</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="MCGIP_CALENDARROW"></a><a id="mcgip_calendarrow"></a><dl> <dt><b>MCGIP_CALENDARROW</b></dt> </dl> </td> <td
    ///width="60%"> A given calendar row. Used with <b>iCalendar</b> and <b>iRow</b>. </td> </tr> <tr> <td
    ///width="40%"><a id="MCGIP_CALENDARCELL"></a><a id="mcgip_calendarcell"></a><dl> <dt><b>MCGIP_CALENDARCELL</b></dt>
    ///</dl> </td> <td width="60%"> A given calendar cell. Used with <b>iCalendar</b>, <b>iRow</b>, <b>iCol</b>,
    ///<b>bSelected</b> and <b>pszName</b>. </td> </tr> </table>
    uint       dwPart;
    ///Type: <b>DWORD</b> Indicates what information is to be filled in. A combination of one or more of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MCGIF_DATE"></a><a
    ///id="mcgif_date"></a><dl> <dt><b>MCGIF_DATE</b></dt> </dl> </td> <td width="60%"> <b>stStart</b> and <b>stEnd</b>.
    ///</td> </tr> <tr> <td width="40%"><a id="MCGIF_RECT"></a><a id="mcgif_rect"></a><dl> <dt><b>MCGIF_RECT</b></dt>
    ///</dl> </td> <td width="60%"> <b>rc</b>. </td> </tr> <tr> <td width="40%"><a id="MCGIF_NAME"></a><a
    ///id="mcgif_name"></a><dl> <dt><b>MCGIF_NAME</b></dt> </dl> </td> <td width="60%"> <b>pszName</b>. </td> </tr>
    ///</table>
    uint       dwFlags;
    ///Type: <b>int</b> If <b>dwPart</b> is MCGIP_CALENDAR, MCGIP_CALENDARHEADER, MCGIP_CALENDARBODY, MCGIP_CALENDARROW,
    ///or MCGIP_CALENDARCELL, this member specifies the index of the calendar for which to retrieve information. For
    ///those parts, this must be a valid value even if there is only one calendar that is currently in the control.
    int        iCalendar;
    ///Type: <b>int</b> If <b>dwPart</b> is MCGIP_CALENDARROW, specifies the row for which to return information.
    int        iRow;
    ///Type: <b>int</b> If <b>dwPart</b> is MCGIP_CALENDARCELL, specifies the column of the cell for which to return
    ///information. The <b>iRow</b> member provides the row of the cell for which to return information.
    int        iCol;
    ///Type: <b>BOOL</b> If <b>dwPart</b> is MCGIP_CALENDARCELL, indicates if the cell described by <b>iRow</b> and
    ///<b>iCol</b> is currently selected.
    BOOL       bSelected;
    ///Type: <b>SYSTEMTIME</b> Returns the start date specified by iCalendar. Used only when <b>dwFlags</b> contains
    ///MCGIF_DATE.
    SYSTEMTIME stStart;
    ///Type: <b>SYSTEMTIME</b> Returns the end date specified by iCalendar. Used only when <b>dwFlags</b> contains
    ///MCGIF_DATE.
    SYSTEMTIME stEnd;
    ///Type: <b>RECT</b> Returns the rectangle of the part specified in <b>dwPart</b>. Set only if <b>dwFlags</b>
    ///contains MCGIF_RECT.
    RECT       rc;
    ///Type: <b>PWSTR</b> Pointer to a string for which <b>cchName</b> is the length. Set only if <b>dwFlags</b>
    ///contains MCGIF_NAME, and only for the following parts, as described in the <b>dwPart</b> member. <ul>
    ///<li>MCGIP_CALENDAR: Returns the text of the selected dates. In the case of multiple selection, returns the date
    ///at the start of the selection.</li> <li>MCGIP_CALENDARCELL: Returns the text of the cell indicated by <b>iRow</b>
    ///and <b>iCol</b>, for instance "11" if the 11th day was specified.</li> <li>MCGIP_CALENDARHEADER: Returns the text
    ///of what it says in the calendar header, for instance "July, 2006".</li> </ul>
    PWSTR      pszName;
    size_t     cchName;
}

///Carries information required to process the MCN_SELCHANGE notification code.
struct NMSELCHANGE
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification.
    NMHDR      nmhdr;
    ///Type: <b>SYSTEMTIME</b> SYSTEMTIME structure that contains the date for the first day in the user's selection
    ///range.
    SYSTEMTIME stSelStart;
    SYSTEMTIME stSelEnd;
}

///Carries information required to process the MCN_GETDAYSTATE notification code. All members of this structure are for
///input, except <b>prgDayState</b>, which the receiving application must set when processing MCN_GETDAYSTATE.
struct NMDAYSTATE
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification code.
    NMHDR      nmhdr;
    ///Type: <b>SYSTEMTIME</b> SYSTEMTIME structure that contains the starting date.
    SYSTEMTIME stStart;
    ///Type: <b>int</b> INT value specifying the total number of elements that must be in the array at
    ///<b>prgDayState</b>.
    int        cDayState;
    uint*      prgDayState;
}

///Stores information required to process the MCN_VIEWCHANGE notification code.
struct NMVIEWCHANGE
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about this notification code.
    NMHDR nmhdr;
    ///Type: <b>DWORD</b> Old view. One of the following constants. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="MCMV_MONTH"></a><a id="mcmv_month"></a><dl> <dt><b>MCMV_MONTH</b></dt> </dl> </td>
    ///<td width="60%"> Monthly view. </td> </tr> <tr> <td width="40%"><a id="MCMV_YEAR"></a><a id="mcmv_year"></a><dl>
    ///<dt><b>MCMV_YEAR</b></dt> </dl> </td> <td width="60%"> Annual view. </td> </tr> <tr> <td width="40%"><a
    ///id="MCMV_DECADE"></a><a id="mcmv_decade"></a><dl> <dt><b>MCMV_DECADE</b></dt> </dl> </td> <td width="60%"> Decade
    ///view. </td> </tr> <tr> <td width="40%"><a id="MCMV_CENTURY"></a><a id="mcmv_century"></a><dl>
    ///<dt><b>MCMV_CENTURY</b></dt> </dl> </td> <td width="60%"> Century view. </td> </tr> </table>
    uint  dwOldView;
    uint  dwNewView;
}

///Contains information about a date and time picker (DTP) control.
struct DATETIMEPICKERINFO
{
    ///Type: <b>DWORD</b> Set to <code>sizeof(DATETIMEPICKERINFO)</code>. This member must be set before sending a
    ///pointer to this structure with the DTM_GETDATETIMEPICKERINFO message, or the DateTime_GetDateTimePickerInfo
    ///macro.
    uint cbSize;
    ///Type: <b>RECT</b> A RECT structure describing location of checkbox. If a checkbox is displayed and checked, an
    ///edit control should be available to update the selected date-time value.
    RECT rcCheck;
    ///Type: <b>DWORD</b> The state of <b>rcCheck</b>—one of the Object State Constants, such as
    ///<b>STATE_SYSTEM_CHECKED</b> or <b>STATE_SYSTEM_INVISIBLE</b>.
    uint stateCheck;
    ///Type: <b>RECT</b> A RECT structure describing the location of a drop-down grid or up/down control.
    RECT rcButton;
    ///Type: <b>DWORD</b> The state of <b>rcButton</b>— one or a bitwise combination of the Object State Constants,
    ///such as <b>STATE_SYSTEM_UNAVAILABLE</b>, <b>STATE_SYSTEM_INVISIBLE</b>, or <b>STATE_SYSTEM_PRESSED</b>. If the
    ///up/down control is in use, the state of the button is <b>STATE_SYSTEM_INVISIBLE</b>.
    uint stateButton;
    ///Type: <b>HWND</b> A handle to the edit control. For information see, Edit Controls.
    HWND hwndEdit;
    ///Type: <b>HWND</b> A handle to the up/down control—an alternative to using the drop-down grid (looks like month
    ///calendar control). For more information, see Up-Down Controls.
    HWND hwndUD;
    HWND hwndDropDown;
}

///Contains information about a change that has taken place in a date and time picker (DTP) control. This structure is
///used with the DTN_DATETIMECHANGE notification code.
struct NMDATETIMECHANGE
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains information about the notification code.
    NMHDR      nmhdr;
    ///Type: <b>DWORD</b> A value that indicates if the control was set to "no date" status (for DTS_SHOWNONE only).
    ///This flag also specifies whether the contents of the <b>st</b> member are valid and contain current time
    ///information. This value can be one of the following: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="GDT_NONE"></a><a id="gdt_none"></a><dl> <dt><b>GDT_NONE</b></dt> </dl> </td> <td width="60%">
    ///The control is set to "no date" status. The "no date" status applies only to controls that are set to the
    ///DTS_SHOWNONE style. </td> </tr> <tr> <td width="40%"><a id="GDT_VALID"></a><a id="gdt_valid"></a><dl>
    ///<dt><b>GDT_VALID</b></dt> </dl> </td> <td width="60%"> The control is not set to the "no date" status. The
    ///<b>st</b> member contains the current date and time. </td> </tr> </table>
    uint       dwFlags;
    SYSTEMTIME st;
}

///Contains information specific to an edit operation that has taken place in a date and time picker (DTP) control. This
///message is used with the DTN_USERSTRING notification code.
struct NMDATETIMESTRINGA
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains information about this notification code.
    NMHDR       nmhdr;
    ///Type: <b>LPCTSTR</b> The address of the zero-terminated string that the user entered.
    const(PSTR) pszUserString;
    ///Type: <b>SYSTEMTIME</b> A SYSTEMTIME structure that must be filled in by the owner when handling the
    ///DTN_USERSTRING notification code.
    SYSTEMTIME  st;
    ///Type: <b>DWORD</b> The return field. Set this member to GDT_VALID to indicate that the <b>st</b> member is valid
    ///or to GDT_NONE to set the control to "no date" status (DTS_SHOWNONE style only).
    uint        dwFlags;
}

///Contains information specific to an edit operation that has taken place in a date and time picker (DTP) control. This
///message is used with the DTN_USERSTRING notification code.
struct NMDATETIMESTRINGW
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains information about this notification code.
    NMHDR        nmhdr;
    ///Type: <b>LPCTSTR</b> The address of the zero-terminated string that the user entered.
    const(PWSTR) pszUserString;
    ///Type: <b>SYSTEMTIME</b> A SYSTEMTIME structure that must be filled in by the owner when handling the
    ///DTN_USERSTRING notification code.
    SYSTEMTIME   st;
    ///Type: <b>DWORD</b> The return field. Set this member to GDT_VALID to indicate that the <b>st</b> member is valid
    ///or to GDT_NONE to set the control to "no date" status (DTS_SHOWNONE style only).
    uint         dwFlags;
}

///Carries information used to describe and handle a DTN_WMKEYDOWN notification code.
struct NMDATETIMEWMKEYDOWNA
{
    ///Type: <b>NMHDR</b> A NMHDR structure that contains information about the notification code.
    NMHDR       nmhdr;
    ///Type: <b>int</b> A virtual key code that represents the key that the user pressed.
    int         nVirtKey;
    ///Type: <b>LPCTSTR</b> A zero-terminated substring, taken from the format string, that defines the callback field.
    ///The substring is one or more "X" characters, followed by a <b>NULL</b>.
    const(PSTR) pszFormat;
    ///Type: <b>SYSTEMTIME</b> A SYSTEMTIME structure containing the current date and time from the DTP control. The
    ///owner of the control must modify the time information based on the user's keystroke.
    SYSTEMTIME  st;
}

///Carries information used to describe and handle a DTN_WMKEYDOWN notification code.
struct NMDATETIMEWMKEYDOWNW
{
    ///Type: <b>NMHDR</b> A NMHDR structure that contains information about the notification code.
    NMHDR        nmhdr;
    ///Type: <b>int</b> A virtual key code that represents the key that the user pressed.
    int          nVirtKey;
    ///Type: <b>LPCTSTR</b> A zero-terminated substring, taken from the format string, that defines the callback field.
    ///The substring is one or more "X" characters, followed by a <b>NULL</b>.
    const(PWSTR) pszFormat;
    ///Type: <b>SYSTEMTIME</b> A SYSTEMTIME structure containing the current date and time from the DTP control. The
    ///owner of the control must modify the time information based on the user's keystroke.
    SYSTEMTIME   st;
}

///Contains information about a portion of the format string that defines a callback field within a date and time picker
///(DTP) control. It carries the substring that defines the callback field and contains a buffer to receive the string
///that will be displayed in the callback field. This structure is used with the DTN_FORMAT notification code.
struct NMDATETIMEFORMATA
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains information about the notification code.
    NMHDR       nmhdr;
    ///Type: <b>LPCTSTR</b> A pointer to the substring that defines a DTP control callback field. The substring consists
    ///of one or more "X" characters followed by a NULL character. (For more information about callback fields, see
    ///Callback fields.)
    const(PSTR) pszFormat;
    ///Type: <b>SYSTEMTIME</b> A SYSTEMTIME structure that contains the date and time to be formatted.
    SYSTEMTIME  st;
    ///Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the display text of the control. By
    ///default, this is the address of the <b>szDisplay</b> member of this structure. It is acceptable to have
    ///<b>pszDisplay</b> point to an existing string. In this case, you do not need to assign a value to
    ///<b>szDisplay</b>. However, the string that <b>pszDisplay</b> points to must remain valid until another DTN_FORMAT
    ///notification is sent, or until the control is destroyed.
    const(PSTR) pszDisplay;
    ///Type: <b>TCHAR</b> 64-character buffer that is to receive the zero-terminated string that the DTP control will
    ///display. It is not necessary to fill the entire buffer.
    byte[64]    szDisplay;
}

///Contains information about a portion of the format string that defines a callback field within a date and time picker
///(DTP) control. It carries the substring that defines the callback field and contains a buffer to receive the string
///that will be displayed in the callback field. This structure is used with the DTN_FORMAT notification code.
struct NMDATETIMEFORMATW
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains information about the notification code.
    NMHDR        nmhdr;
    ///Type: <b>LPCTSTR</b> A pointer to the substring that defines a DTP control callback field. The substring consists
    ///of one or more "X" characters followed by a NULL character. (For more information about callback fields, see
    ///Callback fields.)
    const(PWSTR) pszFormat;
    ///Type: <b>SYSTEMTIME</b> A SYSTEMTIME structure that contains the date and time to be formatted.
    SYSTEMTIME   st;
    ///Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the display text of the control. By
    ///default, this is the address of the <b>szDisplay</b> member of this structure. It is acceptable to have
    ///<b>pszDisplay</b> point to an existing string. In this case, you do not need to assign a value to
    ///<b>szDisplay</b>. However, the string that <b>pszDisplay</b> points to must remain valid until another DTN_FORMAT
    ///notification is sent, or until the control is destroyed.
    const(PWSTR) pszDisplay;
    ///Type: <b>TCHAR</b> 64-character buffer that is to receive the zero-terminated string that the DTP control will
    ///display. It is not necessary to fill the entire buffer.
    ushort[64]   szDisplay;
}

///Contains information about a date and time picker (DTP) control callback field. It contains a substring (taken from
///the control's format string) that defines a callback field. The structure receives the maximum allowable size of the
///text that will be displayed in the callback field. This structure is used with the DTN_FORMATQUERY notification code.
struct NMDATETIMEFORMATQUERYA
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains information about this notification code.
    NMHDR       nmhdr;
    ///Type: <b>LPCTSTR</b> A pointer to a substring that defines a DTP control callback field. The substring is one or
    ///more "X" characters followed by a <b>NULL</b>. (For additional information about callback fields, see Callback
    ///fields.)
    const(PSTR) pszFormat;
    ///Type: <b>SIZE</b> A SIZE structure that must be filled with the maximum size of the text that will be displayed
    ///in the callback field.
    SIZE        szMax;
}

///Contains information about a date and time picker (DTP) control callback field. It contains a substring (taken from
///the control's format string) that defines a callback field. The structure receives the maximum allowable size of the
///text that will be displayed in the callback field. This structure is used with the DTN_FORMATQUERY notification code.
struct NMDATETIMEFORMATQUERYW
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains information about this notification code.
    NMHDR        nmhdr;
    ///Type: <b>LPCTSTR</b> A pointer to a substring that defines a DTP control callback field. The substring is one or
    ///more "X" characters followed by a <b>NULL</b>. (For additional information about callback fields, see Callback
    ///fields.)
    const(PWSTR) pszFormat;
    ///Type: <b>SIZE</b> A SIZE structure that must be filled with the maximum size of the text that will be displayed
    ///in the callback field.
    SIZE         szMax;
}

///Contains information for the IPN_FIELDCHANGED notification code.
struct NMIPADDRESS
{
    ///Type: <b>NMHDR</b> An NMHDR structure that contains additional information about the notification.
    NMHDR hdr;
    ///Type: <b>int</b> The zero-based number of the field that was changed.
    int   iField;
    int   iValue;
}

///Contains and receives information that the pager control uses when scrolling the contained window. It is used with
///the PGN_SCROLL notification.
struct NMPGSCROLL
{
align (1):
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about the notification.
    NMHDR  hdr;
    ///Type: <b>BOOL</b> Modifier keys that are down when the scroll occurs. This can be one or more of the following
    ///values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl>
    ///<dt><b>0</b></dt> </dl> </td> <td width="60%"> None of the modifier keys are down. </td> </tr> <tr> <td
    ///width="40%"><a id="PGK_SHIFT"></a><a id="pgk_shift"></a><dl> <dt><b>PGK_SHIFT</b></dt> </dl> </td> <td
    ///width="60%"> The SHIFT key is down. </td> </tr> <tr> <td width="40%"><a id="PGK_CONTROL"></a><a
    ///id="pgk_control"></a><dl> <dt><b>PGK_CONTROL</b></dt> </dl> </td> <td width="60%"> The CONTROL key is down. </td>
    ///</tr> <tr> <td width="40%"><a id="PGK_MENU"></a><a id="pgk_menu"></a><dl> <dt><b>PGK_MENU</b></dt> </dl> </td>
    ///<td width="60%"> The ALT key is down. </td> </tr> </table>
    ushort fwKeys;
    ///Type: <b>RECT</b> Contains the client rectangle of the pager control.
    RECT   rcParent;
    ///Type: <b>int</b> Value that indicates in which direction the scroll is occurring. This will be one of the
    ///following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="PGF_SCROLLDOWN"></a><a id="pgf_scrolldown"></a><dl> <dt><b>PGF_SCROLLDOWN</b></dt> </dl> </td> <td
    ///width="60%"> The contained window is being scrolled down. </td> </tr> <tr> <td width="40%"><a
    ///id="PGF_SCROLLLEFT"></a><a id="pgf_scrollleft"></a><dl> <dt><b>PGF_SCROLLLEFT</b></dt> </dl> </td> <td
    ///width="60%"> The contained window is being scrolled to the left. </td> </tr> <tr> <td width="40%"><a
    ///id="PGF_SCROLLRIGHT"></a><a id="pgf_scrollright"></a><dl> <dt><b>PGF_SCROLLRIGHT</b></dt> </dl> </td> <td
    ///width="60%"> The contained window is being scrolled to the right. </td> </tr> <tr> <td width="40%"><a
    ///id="PGF_SCROLLUP"></a><a id="pgf_scrollup"></a><dl> <dt><b>PGF_SCROLLUP</b></dt> </dl> </td> <td width="60%"> The
    ///contained window is being scrolled up. </td> </tr> </table>
    int    iDir;
    ///Type: <b>int</b> Contains the horizontal scroll position of the contained window, in pixels, before the scroll
    ///action.
    int    iXpos;
    ///Type: <b>int</b> Contains the vertical scroll position of the contained window, in pixels, before the scroll
    ///action.
    int    iYpos;
    int    iScroll;
}

///Contains and receives information that the pager control uses to calculate the scrollable area of the contained
///window. It is used with the PGN_CALCSIZE notification.
struct NMPGCALCSIZE
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains information about the notification.
    NMHDR hdr;
    ///Type: <b>DWORD</b> Value that indicates which dimension is being requested. This will be one of the following
    ///values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PGF_CALCHEIGHT"></a><a
    ///id="pgf_calcheight"></a><dl> <dt><b>PGF_CALCHEIGHT</b></dt> </dl> </td> <td width="60%"> The height of the
    ///scrollable area is being requested. The height must be placed in the <b>iHeight</b> member before returning from
    ///the notification. </td> </tr> <tr> <td width="40%"><a id="PGF_CALCWIDTH"></a><a id="pgf_calcwidth"></a><dl>
    ///<dt><b>PGF_CALCWIDTH</b></dt> </dl> </td> <td width="60%"> The width of the scrollable area is being requested.
    ///The width must be placed in the <b>iWidth</b> member before returning from the notification. </td> </tr> </table>
    uint  dwFlag;
    ///Type: <b>int</b> Receives the desired width of the scrollable area, in pixels.
    int   iWidth;
    int   iHeight;
}

///Contains information used with the PGN_HOTITEMCHANGE notification code.
struct NMPGHOTITEM
{
    ///Type: <b>NMHDR</b> NMHDR structure that contains additional information about the notification.
    NMHDR hdr;
    ///Type: <b>int</b> Value of type <b>int</b> that specifies the command identifier of the previously highlighted
    ///item.
    int   idOld;
    ///Type: <b>int</b> Value of type <b>int</b> that specifies the command identifier of the highlighted item.
    int   idNew;
    uint  dwFlags;
}

///Contains information about an image list that is used with a button control.
struct BUTTON_IMAGELIST
{
    ///Type: <b>HIMAGELIST</b> A handle to the image list. The provider retains ownership of the image list and is
    ///ultimately responsible for its disposal. Under Windows Vista, you can pass BCCL_NOGLYPH in this parameter to
    ///indicate that no glyph should be displayed.
    HIMAGELIST himl;
    ///Type: <b>RECT</b> A RECT that specifies the margin around the icon.
    RECT       margin;
    ///Type: <b>UINT</b> A <b>UINT</b> that specifies the alignment to use. This parameter can be one of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="BUTTON_IMAGELIST_ALIGN_LEFT"></a><a id="button_imagelist_align_left"></a><dl>
    ///<dt><b>BUTTON_IMAGELIST_ALIGN_LEFT</b></dt> </dl> </td> <td width="60%"> Align the image with the left margin.
    ///</td> </tr> <tr> <td width="40%"><a id="BUTTON_IMAGELIST_ALIGN_RIGHT"></a><a
    ///id="button_imagelist_align_right"></a><dl> <dt><b>BUTTON_IMAGELIST_ALIGN_RIGHT</b></dt> </dl> </td> <td
    ///width="60%"> Align the image with the right margin. </td> </tr> <tr> <td width="40%"><a
    ///id="BUTTON_IMAGELIST_ALIGN_TOP"></a><a id="button_imagelist_align_top"></a><dl>
    ///<dt><b>BUTTON_IMAGELIST_ALIGN_TOP</b></dt> </dl> </td> <td width="60%"> Align the image with the top margin </td>
    ///</tr> <tr> <td width="40%"><a id="BUTTON_IMAGELIST_ALIGN_BOTTOM"></a><a
    ///id="button_imagelist_align_bottom"></a><dl> <dt><b>BUTTON_IMAGELIST_ALIGN_BOTTOM</b></dt> </dl> </td> <td
    ///width="60%"> Align the image with the bottom margin </td> </tr> <tr> <td width="40%"><a
    ///id="BUTTON_IMAGELIST_ALIGN_CENTER"></a><a id="button_imagelist_align_center"></a><dl>
    ///<dt><b>BUTTON_IMAGELIST_ALIGN_CENTER</b></dt> </dl> </td> <td width="60%"> Center the image. </td> </tr> </table>
    uint       uAlign;
}

///Contains information about the movement of the mouse over a button control.
struct NMBCHOTITEM
{
    ///Type: <b>NMHDR</b> An NMHDR structure.
    NMHDR hdr;
    ///Type: <b>DWORD</b> The action of the mouse. This parameter can be one of the following values combined with
    ///HICF_MOUSE. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HICF_ENTERING"></a><a
    ///id="hicf_entering"></a><dl> <dt><b>HICF_ENTERING</b></dt> </dl> </td> <td width="60%"> The mouse is entering the
    ///button. </td> </tr> <tr> <td width="40%"><a id="HICF_LEAVING"></a><a id="hicf_leaving"></a><dl>
    ///<dt><b>HICF_LEAVING</b></dt> </dl> </td> <td width="60%"> The mouse is leaving the button. </td> </tr> </table>
    uint  dwFlags;
}

///Contains information that defines a split button (BS_SPLITBUTTON and BS_DEFSPLITBUTTON styles). Used with the
///BCM_GETSPLITINFO and BCM_SETSPLITINFO messages.
struct BUTTON_SPLITINFO
{
    ///Type: <b>UINT</b> A set of flags that specify which members of this structure contain data to be set or which
    ///members are being requested. Set this member to one or more of the following flags. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="BCSIF_GLYPH"></a><a id="bcsif_glyph"></a><dl>
    ///<dt><b>BCSIF_GLYPH</b></dt> </dl> </td> <td width="60%"> <b>himlGlyph</b> is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="BCSIF_IMAGE"></a><a id="bcsif_image"></a><dl> <dt><b>BCSIF_IMAGE</b></dt> </dl> </td> <td
    ///width="60%"> <b>himlGlyph</b> is valid. Use when <b>uSplitStyle</b> is set to BCSS_IMAGE. </td> </tr> <tr> <td
    ///width="40%"><a id="BCSIF_SIZE"></a><a id="bcsif_size"></a><dl> <dt><b>BCSIF_SIZE</b></dt> </dl> </td> <td
    ///width="60%"> <b>size</b> is valid. </td> </tr> <tr> <td width="40%"><a id="BCSIF_STYLE"></a><a
    ///id="bcsif_style"></a><dl> <dt><b>BCSIF_STYLE</b></dt> </dl> </td> <td width="60%"> <b>uSplitStyle</b> is valid.
    ///</td> </tr> </table>
    uint       mask;
    ///Type: <b>HIMAGELIST</b> A handle to the image list. The provider retains ownership of the image list and is
    ///ultimately responsible for its disposal.
    HIMAGELIST himlGlyph;
    ///Type: <b>UINT</b> The split button style. Value must be one or more of the following flags. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="BCSS_ALIGNLEFT"></a><a
    ///id="bcss_alignleft"></a><dl> <dt><b>BCSS_ALIGNLEFT</b></dt> </dl> </td> <td width="60%"> Align the image or glyph
    ///horizontally with the left margin. </td> </tr> <tr> <td width="40%"><a id="BCSS_IMAGE"></a><a
    ///id="bcss_image"></a><dl> <dt><b>BCSS_IMAGE</b></dt> </dl> </td> <td width="60%"> Draw an icon image as the glyph.
    ///</td> </tr> <tr> <td width="40%"><a id="BCSS_NOSPLIT"></a><a id="bcss_nosplit"></a><dl>
    ///<dt><b>BCSS_NOSPLIT</b></dt> </dl> </td> <td width="60%"> No split. </td> </tr> <tr> <td width="40%"><a
    ///id="BCSS_STRETCH"></a><a id="bcss_stretch"></a><dl> <dt><b>BCSS_STRETCH</b></dt> </dl> </td> <td width="60%">
    ///Stretch glyph, but try to retain aspect ratio. </td> </tr> </table>
    uint       uSplitStyle;
    ///Type: <b>SIZE</b> A SIZE structure that specifies the size of the glyph in <b>himlGlyph</b>.
    SIZE       size;
}

///Contains information about a BCN_DROPDOWN notification.
struct NMBCDROPDOWN
{
    ///Type: <b>NMHDR</b> An NMHDR structure containing information about the notification.
    NMHDR hdr;
    RECT  rcButton;
}

///Contains information about a balloon tip associated with a button control.
struct EDITBALLOONTIP
{
    ///Type: <b>DWORD</b> A <b>DWORD</b> that contains the size, in bytes, of the structure.
    uint         cbStruct;
    ///Type: <b>LPCWSTR</b> A pointer to a Unicode string that contains the title of the balloon tip.
    const(PWSTR) pszTitle;
    ///Type: <b>LPCWSTR</b> A pointer to a Unicode string that contains the balloon tip text.
    const(PWSTR) pszText;
    ///Type: <b>INT</b> A value of type <b>INT</b> that specifies the type of icon to associate with the balloon tip.
    ///This member can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="TTI_ERROR"></a><a id="tti_error"></a><dl> <dt><b>TTI_ERROR</b></dt> </dl> </td> <td
    ///width="60%"> Use the error icon. </td> </tr> <tr> <td width="40%"><a id="TTI_INFO"></a><a id="tti_info"></a><dl>
    ///<dt><b>TTI_INFO</b></dt> </dl> </td> <td width="60%"> Use the information icon. </td> </tr> <tr> <td
    ///width="40%"><a id="TTI_NONE"></a><a id="tti_none"></a><dl> <dt><b>TTI_NONE</b></dt> </dl> </td> <td width="60%">
    ///Use no icon. </td> </tr> <tr> <td width="40%"><a id="TTI_WARNING"></a><a id="tti_warning"></a><dl>
    ///<dt><b>TTI_WARNING</b></dt> </dl> </td> <td width="60%"> Use the warning icon. </td> </tr> <tr> <td
    ///width="40%"><a id="TTI_INFO_LARGE"></a><a id="tti_info_large"></a><dl> <dt><b>TTI_INFO_LARGE</b></dt> </dl> </td>
    ///<td width="60%"> Use the large information icon. This is assumed to be an HICON value. </td> </tr> <tr> <td
    ///width="40%"><a id="TTI_WARNING_LARGE"></a><a id="tti_warning_large"></a><dl> <dt><b>TTI_WARNING_LARGE</b></dt>
    ///</dl> </td> <td width="60%"> Use the large warning icon. This is assumed to be an HICON value. </td> </tr> <tr>
    ///<td width="40%"><a id="TTI_ERROR_LARGE"></a><a id="tti_error_large"></a><dl> <dt><b>TTI_ERROR_LARGE</b></dt>
    ///</dl> </td> <td width="60%"> Use the large error icon. This is assumed to be an HICON value. </td> </tr> </table>
    int          ttiIcon;
}

struct NMSEARCHWEB
{
    NMHDR hdr;
    EC_SEARCHWEB_ENTRYPOINT entrypoint;
    BOOL  hasQueryText;
    BOOL  invokeSucceeded;
}

///The <b>TASKDIALOG_BUTTON</b> structure contains information used to display a button in a task dialog. The
///TASKDIALOGCONFIG structure uses this structure.
struct TASKDIALOG_BUTTON
{
align (1):
    ///Type: <b>int</b> Indicates the value to be returned when this button is selected.
    int          nButtonID;
    const(PWSTR) pszButtonText;
}

///The <b>TASKDIALOGCONFIG</b> structure contains information used to display a task dialog. The TaskDialogIndirect
///function uses this structure.
struct TASKDIALOGCONFIG
{
align (1):
    ///Type: <b>UINT</b> Specifies the structure size, in bytes.
    uint                 cbSize;
    ///Type: <b>HWND</b> Handle to the parent window. This member can be <b>NULL</b>.
    HWND                 hwndParent;
    ///Type: <b>HINSTANCE</b> Handle to the module that contains the icon resource identified by the <b>pszMainIcon</b>
    ///or <b>pszFooterIcon</b> members, and the string resources identified by the <b>pszWindowTitle</b>,
    ///<b>pszMainInstruction</b>, <b>pszContent</b>, <b>pszVerificationText</b>, <b>pszExpandedInformation</b>,
    ///<b>pszExpandedControlText</b>, <b>pszCollapsedControlText</b> or <b>pszFooter</b> members.
    HINSTANCE            hInstance;
    ///Type: <b>TASKDIALOG_FLAGS</b> Specifies the behavior of the task dialog. This parameter can be a combination of
    ///flags from the following group: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TDF_ENABLE_HYPERLINKS"></a><a id="tdf_enable_hyperlinks"></a><dl> <dt><b>TDF_ENABLE_HYPERLINKS</b></dt> </dl>
    ///</td> <td width="60%"> Enables hyperlink processing for the strings specified in the <b>pszContent</b>,
    ///<b>pszExpandedInformation</b> and <b>pszFooter</b> members. When enabled, these members may point to strings that
    ///contain hyperlinks in the following form: ``` <A HREF="executablestring">Hyperlink Text</A> ``` <b>Warning:
    ///Enabling hyperlinks when using content from an unsafe source may cause security vulnerabilities.</b> <div
    ///class="alert"><b>Note</b> Task Dialogs will not actually execute any hyperlinks. Hyperlink execution must be
    ///handled in the callback function specified by <b>pfCallback</b>. For more details, see
    ///TaskDialogCallbackProc.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a id="TDF_USE_HICON_MAIN"></a><a
    ///id="tdf_use_hicon_main"></a><dl> <dt><b>TDF_USE_HICON_MAIN</b></dt> </dl> </td> <td width="60%"> Indicates that
    ///the dialog should use the icon referenced by the handle in the <b>hMainIcon</b> member as the primary icon in the
    ///task dialog. If this flag is specified, the <b>pszMainIcon</b> member is ignored. </td> </tr> <tr> <td
    ///width="40%"><a id="TDF_USE_HICON_FOOTER"></a><a id="tdf_use_hicon_footer"></a><dl>
    ///<dt><b>TDF_USE_HICON_FOOTER</b></dt> </dl> </td> <td width="60%"> Indicates that the dialog should use the icon
    ///referenced by the handle in the <b>hFooterIcon</b> member as the footer icon in the task dialog. If this flag is
    ///specified, the <b>pszFooterIcon</b> member is ignored. </td> </tr> <tr> <td width="40%"><a
    ///id="TDF_ALLOW_DIALOG_CANCELLATION"></a><a id="tdf_allow_dialog_cancellation"></a><dl>
    ///<dt><b>TDF_ALLOW_DIALOG_CANCELLATION</b></dt> </dl> </td> <td width="60%"> Indicates that the dialog should be
    ///able to be closed using Alt-F4, Escape, and the title bar's close button even if no cancel button is specified in
    ///either the <b>dwCommonButtons</b> or <b>pButtons</b> members. </td> </tr> <tr> <td width="40%"><a
    ///id="TDF_USE_COMMAND_LINKS"></a><a id="tdf_use_command_links"></a><dl> <dt><b>TDF_USE_COMMAND_LINKS</b></dt> </dl>
    ///</td> <td width="60%"> Indicates that the buttons specified in the <b>pButtons</b> member are to be displayed as
    ///command links (using a standard task dialog glyph) instead of push buttons. When using command links, all
    ///characters up to the first new line character in the <b>pszButtonText</b> member will be treated as the command
    ///link's main text, and the remainder will be treated as the command link's note. This flag is ignored if the
    ///<b>cButtons</b> member is zero. </td> </tr> <tr> <td width="40%"><a id="TDF_USE_COMMAND_LINKS_NO_ICON"></a><a
    ///id="tdf_use_command_links_no_icon"></a><dl> <dt><b>TDF_USE_COMMAND_LINKS_NO_ICON</b></dt> </dl> </td> <td
    ///width="60%"> Indicates that the buttons specified in the <b>pButtons</b> member are to be displayed as command
    ///links (without a glyph) instead of push buttons. When using command links, all characters up to the first new
    ///line character in the <b>pszButtonText</b> member will be treated as the command link's main text, and the
    ///remainder will be treated as the command link's note. This flag is ignored if the <b>cButtons</b> member is zero.
    ///</td> </tr> <tr> <td width="40%"><a id="TDF_EXPAND_FOOTER_AREA"></a><a id="tdf_expand_footer_area"></a><dl>
    ///<dt><b>TDF_EXPAND_FOOTER_AREA</b></dt> </dl> </td> <td width="60%"> Indicates that the string specified by the
    ///<b>pszExpandedInformation</b> member is displayed at the bottom of the dialog's footer area instead of
    ///immediately after the dialog's content. This flag is ignored if the <b>pszExpandedInformation</b> member is
    ///<b>NULL</b>. </td> </tr> <tr> <td width="40%"><a id="TDF_EXPANDED_BY_DEFAULT"></a><a
    ///id="tdf_expanded_by_default"></a><dl> <dt><b>TDF_EXPANDED_BY_DEFAULT</b></dt> </dl> </td> <td width="60%">
    ///Indicates that the string specified by the <b>pszExpandedInformation</b> member is displayed when the dialog is
    ///initially displayed. This flag is ignored if the <b>pszExpandedInformation</b> member is <b>NULL</b>. </td> </tr>
    ///<tr> <td width="40%"><a id="TDF_VERIFICATION_FLAG_CHECKED"></a><a id="tdf_verification_flag_checked"></a><dl>
    ///<dt><b>TDF_VERIFICATION_FLAG_CHECKED</b></dt> </dl> </td> <td width="60%"> Indicates that the verification
    ///checkbox in the dialog is checked when the dialog is initially displayed. This flag is ignored if the
    ///<b>pszVerificationText</b> parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TDF_SHOW_PROGRESS_BAR"></a><a id="tdf_show_progress_bar"></a><dl> <dt><b>TDF_SHOW_PROGRESS_BAR</b></dt> </dl>
    ///</td> <td width="60%"> Indicates that a Progress Bar is to be displayed. </td> </tr> <tr> <td width="40%"><a
    ///id="TDF_SHOW_MARQUEE_PROGRESS_BAR"></a><a id="tdf_show_marquee_progress_bar"></a><dl>
    ///<dt><b>TDF_SHOW_MARQUEE_PROGRESS_BAR</b></dt> </dl> </td> <td width="60%"> Indicates that an Marquee Progress Bar
    ///is to be displayed. </td> </tr> <tr> <td width="40%"><a id="TDF_CALLBACK_TIMER"></a><a
    ///id="tdf_callback_timer"></a><dl> <dt><b>TDF_CALLBACK_TIMER</b></dt> </dl> </td> <td width="60%"> Indicates that
    ///the task dialog's callback is to be called approximately every 200 milliseconds. </td> </tr> <tr> <td
    ///width="40%"><a id="TDF_POSITION_RELATIVE_TO_WINDOW"></a><a id="tdf_position_relative_to_window"></a><dl>
    ///<dt><b>TDF_POSITION_RELATIVE_TO_WINDOW</b></dt> </dl> </td> <td width="60%"> Indicates that the task dialog is
    ///positioned (centered) relative to the window specified by <b>hwndParent</b>. If the flag is not supplied (or no
    ///<b>hwndParent</b> member is specified), the task dialog is positioned (centered) relative to the monitor. </td>
    ///</tr> <tr> <td width="40%"><a id="TDF_RTL_LAYOUT"></a><a id="tdf_rtl_layout"></a><dl>
    ///<dt><b>TDF_RTL_LAYOUT</b></dt> </dl> </td> <td width="60%"> Indicates that text is displayed reading right to
    ///left. </td> </tr> <tr> <td width="40%"><a id="TDF_NO_DEFAULT_RADIO_BUTTON"></a><a
    ///id="tdf_no_default_radio_button"></a><dl> <dt><b>TDF_NO_DEFAULT_RADIO_BUTTON</b></dt> </dl> </td> <td
    ///width="60%"> Indicates that no default item will be selected. </td> </tr> <tr> <td width="40%"><a
    ///id="TDF_CAN_BE_MINIMIZED"></a><a id="tdf_can_be_minimized"></a><dl> <dt><b>TDF_CAN_BE_MINIMIZED</b></dt> </dl>
    ///</td> <td width="60%"> Indicates that the task dialog can be minimized. </td> </tr> <tr> <td width="40%"><a
    ///id="TDIF_SIZE_TO_CONTENT"></a><a id="tdif_size_to_content"></a><dl> <dt><b>TDIF_SIZE_TO_CONTENT</b></dt> </dl>
    ///</td> <td width="60%"> This flag is deprecated. Use <b>TDF_SIZE_TO_CONTENT</b> instead. </td> </tr> <tr> <td
    ///width="40%"><a id="TDF_SIZE_TO_CONTENT"></a><a id="tdf_size_to_content"></a><dl>
    ///<dt><b>TDF_SIZE_TO_CONTENT</b></dt> </dl> </td> <td width="60%"> Indicates that the width of the task dialog is
    ///determined by the width of its content area. This flag is ignored if <b>cxWidth</b> is not set to 0. </td> </tr>
    ///</table>
    int                  dwFlags;
    ///Type: <b>TASKDIALOG_COMMON_BUTTON_FLAGS</b> Specifies the push buttons displayed in the task dialog. If no common
    ///buttons are specified and no custom buttons are specified using the <b>cButtons</b> and <b>pButtons</b> members,
    ///the task dialog will contain the <b>OK</b> button by default. This parameter may be a combination of flags from
    ///the following group: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TDCBF_OK_BUTTON"></a><a id="tdcbf_ok_button"></a><dl> <dt><b>TDCBF_OK_BUTTON</b></dt> </dl> </td> <td
    ///width="60%"> The task dialog contains the push button: <b>OK</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TDCBF_YES_BUTTON"></a><a id="tdcbf_yes_button"></a><dl> <dt><b>TDCBF_YES_BUTTON</b></dt> </dl> </td> <td
    ///width="60%"> The task dialog contains the push button: <b>Yes</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TDCBF_NO_BUTTON"></a><a id="tdcbf_no_button"></a><dl> <dt><b>TDCBF_NO_BUTTON</b></dt> </dl> </td> <td
    ///width="60%"> The task dialog contains the push button: <b>No</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TDCBF_CANCEL_BUTTON"></a><a id="tdcbf_cancel_button"></a><dl> <dt><b>TDCBF_CANCEL_BUTTON</b></dt> </dl> </td>
    ///<td width="60%"> The task dialog contains the push button: <b>Cancel</b>. If this button is specified, the task
    ///dialog will respond to typical cancel actions (Alt-F4 and Escape). </td> </tr> <tr> <td width="40%"><a
    ///id="TDCBF_RETRY_BUTTON"></a><a id="tdcbf_retry_button"></a><dl> <dt><b>TDCBF_RETRY_BUTTON</b></dt> </dl> </td>
    ///<td width="60%"> The task dialog contains the push button: <b>Retry</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TDCBF_CLOSE_BUTTON"></a><a id="tdcbf_close_button"></a><dl> <dt><b>TDCBF_CLOSE_BUTTON</b></dt> </dl> </td>
    ///<td width="60%"> The task dialog contains the push button: <b>Close</b>. </td> </tr> </table>
    int                  dwCommonButtons;
    ///Type: <b>PCWSTR</b> Pointer that references the string to be used for the task dialog title. This parameter can
    ///be either a null-terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro. If this
    ///parameter is <b>NULL</b>, the filename of the executable program is used.
    const(PWSTR)         pszWindowTitle;
union
    {
    align (1):
        HICON        hMainIcon;
        const(PWSTR) pszMainIcon;
    }
    ///Type: <b>PCWSTR</b> Pointer that references the string to be used for the main instruction. This parameter can be
    ///either a null-terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro.
    const(PWSTR)         pszMainInstruction;
    ///Type: <b>PCWSTR</b> Pointer that references the string to be used for the dialog's primary content. This
    ///parameter can be either a null-terminated string or an integer resource identifier passed to the MAKEINTRESOURCE
    ///macro. If the ENABLE_HYPERLINKS flag is specified for the <b>dwFlags</b> member, then this string may contain
    ///hyperlinks in the form: &lt;A HREF="executablestring"&gt;Hyperlink Text&lt;/A&gt;. <b>WARNING: Enabling
    ///hyperlinks when using content from an unsafe source may cause security vulnerabilities.</b>
    const(PWSTR)         pszContent;
    ///Type: <b>UINT</b> The number of entries in the <b>pButtons</b> array that is used to create buttons or command
    ///links in the task dialog. If this member is zero and no common buttons have been specified using the
    ///<b>dwCommonButtons</b> member, then the task dialog will have a single <b>OK</b> button displayed.
    uint                 cButtons;
    ///Type: <b>const TASKDIALOG_BUTTON*</b> Pointer to an array of TASKDIALOG_BUTTON structures containing the
    ///definition of the custom buttons that are to be displayed in the task dialog. This array must contain at least
    ///the number of entries that are specified by the <b>cButtons</b> member.
    const(TASKDIALOG_BUTTON)* pButtons;
    ///Type: <b>int</b> The default button for the task dialog. This may be any of the values specified in
    ///<b>nButtonID</b> members of one of the TASKDIALOG_BUTTON structures in the <b>pButtons</b> array, or one of the
    ///IDs corresponding to the buttons specified in the <b>dwCommonButtons</b> member: <table class="clsStd"> <tr>
    ///<td>IDCANCEL</td> <td>Make the <b>Cancel</b> button the default.</td> </tr> <tr> <td>IDNO</td> <td>Make the
    ///<b>No</b> button the default.</td> </tr> <tr> <td>IDOK</td> <td>Make the <b>OK</b> button the default.</td> </tr>
    ///<tr> <td>IDRETRY</td> <td>Make the <b>Retry</b> button the default.</td> </tr> <tr> <td>IDYES</td> <td>Make the
    ///<b>Yes</b> button the default.</td> </tr> <tr> <td>IDCLOSE</td> <td>Make the <b>Close</b> button the
    ///default.</td> </tr> </table> If this member is zero or its value does not correspond to any button ID in the
    ///dialog, then the first button in the dialog will be the default.
    int                  nDefaultButton;
    ///Type: <b>UINT</b> The number of entries in the <b>pRadioButtons</b> array that is used to create radio buttons in
    ///the task dialog.
    uint                 cRadioButtons;
    ///Type: <b>const TASKDIALOG_BUTTON*</b> Pointer to an array of TASKDIALOG_BUTTON structures containing the
    ///definition of the radio buttons that are to be displayed in the task dialog. This array must contain at least the
    ///number of entries that are specified by the <b>cRadioButtons</b> member. This parameter can be <b>NULL</b>.
    const(TASKDIALOG_BUTTON)* pRadioButtons;
    ///Type: <b>int</b> The button ID of the radio button that is selected by default. If this value does not correspond
    ///to a button ID, the first button in the array is selected by default.
    int                  nDefaultRadioButton;
    ///Type: <b>PCWSTR</b> Pointer that references the string to be used to label the verification checkbox. This
    ///parameter can be either a null-terminated string or an integer resource identifier passed to the MAKEINTRESOURCE
    ///macro. If this parameter is <b>NULL</b>, the verification checkbox is not displayed in the task dialog. If the
    ///<i>pfVerificationFlagChecked</i> parameter of TaskDialogIndirect is <b>NULL</b>, the checkbox is not enabled.
    const(PWSTR)         pszVerificationText;
    ///Type: <b>PCWSTR</b> Pointer that references the string to be used for displaying additional information. This
    ///parameter can be either a null-terminated string or an integer resource identifier passed to the MAKEINTRESOURCE
    ///macro. The additional information is displayed either immediately below the content or below the footer text
    ///depending on whether the TDF_EXPAND_FOOTER_AREA flag is specified. If the TDF_ENABLE_HYPERLINKS flag is specified
    ///for the <b>dwFlags</b> member, then this string may contain hyperlinks in the form: &lt;A
    ///HREF="executablestring"&gt;Hyperlink Text&lt;/A&gt;. <b>WARNING: Enabling hyperlinks when using content from an
    ///unsafe source may cause security vulnerabilities.</b>
    const(PWSTR)         pszExpandedInformation;
    ///Type: <b>PCWSTR</b> Pointer that references the string to be used to label the button for collapsing the
    ///expandable information. This parameter can be either a null-terminated string or an integer resource identifier
    ///passed to the MAKEINTRESOURCE macro. This member is ignored when the <b>pszExpandedInformation</b> member is
    ///<b>NULL</b>. If this member is <b>NULL</b> and the <b>pszCollapsedControlText</b> is specified, then the
    ///<b>pszCollapsedControlText</b> value will be used for this member as well.
    const(PWSTR)         pszExpandedControlText;
    ///Type: <b>PCWSTR</b> Pointer that references the string to be used to label the button for expanding the
    ///expandable information. This parameter can be either a null-terminated string or an integer resource identifier
    ///passed to the MAKEINTRESOURCE macro. This member is ignored when the <b>pszExpandedInformation</b> member is
    ///<b>NULL</b>. If this member is <b>NULL</b> and the <b>pszCollapsedControlText</b> is specified, then the
    ///<b>pszCollapsedControlText</b> value will be used for this member as well.
    const(PWSTR)         pszCollapsedControlText;
union
    {
    align (1):
        HICON        hFooterIcon;
        const(PWSTR) pszFooterIcon;
    }
    ///Type: <b>PCWSTR</b> Pointer to the string to be used in the footer area of the task dialog. This parameter can be
    ///either a null-terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro. If the
    ///TDF_ENABLE_HYPERLINKS flag is specified for the <b>dwFlags</b> member, then this string may contain hyperlinks in
    ///this form. ``` <A HREF="executablestring">Hyperlink Text</A> ``` <div class="alert"><b>Warning</b> Enabling
    ///hyperlinks when using content from an unsafe source may cause security vulnerabilities.</div> <div> </div>
    const(PWSTR)         pszFooter;
    ///Type: <b>PFTASKDIALOGCALLBACK</b> Pointer to an application-defined callback function. For more information see
    ///TaskDialogCallbackProc.
    PFTASKDIALOGCALLBACK pfCallback;
    ///Type: <b>LONG_PTR</b> A pointer to application-defined reference data. This value is defined by the caller.
    ptrdiff_t            lpCallbackData;
    uint                 cxWidth;
}

struct _DSA
{
}

struct _DPA
{
}

///Contains a stream item used by the PFNDPASTREAM callback function.
struct DPASTREAMINFO
{
    ///Type: <b>int</b> An index of the item in the DPA.
    int   iPos;
    void* pvItem;
}

///Contains image list statistics. Used by GetStatistics.
struct IMAGELISTSTATS
{
    ///Type: <b>DWORD</b> The image list size.
    uint cbSize;
    ///Type: <b>int</b> The number of images allocated.
    int  cAlloc;
    ///Type: <b>int</b> The number of images in use.
    int  cUsed;
    int  cStandby;
}

///Contains information about the Input Method Editor (IME) composition text in a Microsoft Rich Edit control.
struct IMECOMPTEXT
{
    ///Type: <b>LONG</b> Size of the output buffer, in bytes.
    int  cb;
    ///Type: <b>DWORD</b> Type of composition string. It can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="ICT_RESULTREADSTR"></a><a id="ict_resultreadstr"></a><dl>
    ///<dt><b>ICT_RESULTREADSTR</b></dt> </dl> </td> <td width="60%"> The final composed string. </td> </tr> </table>
    uint flags;
}

///Defines the attributes of rows in a table. The definitions include the corresponding Rich Text Format (RTF) control
///words, which are defined in the Rich Text Format (RTF) Specification.
struct TABLEROWPARMS
{
    ///Type: <b>BYTE</b> The count of bytes in this structure.
    ubyte cbRow;
    ///Type: <b>BYTE</b> The count of bytes in TABLECELLPARMS.
    ubyte cbCell;
    ///Type: <b>BYTE</b> The count of cells in a row, up to the maximum specified by MAX_TABLE_CELLS.
    ubyte cCell;
    ///Type: <b>BYTE</b> The count of rows.
    ubyte cRow;
    ///Type: <b>LONG</b> The size of the left and right margins in a cell (\trgaph).
    int   dxCellMargin;
    ///Type: <b>LONG</b> The amount of left indentation, or right indentation if the <b>fRTL</b> member is <b>TRUE</b>
    ///(similar to \trleft).
    int   dxIndent;
    ///Type: <b>LONG</b> The height of a row (\trrh).
    int   dyHeight;
    uint  _bitfield0;
    ///Type: <b>LONG</b> The character position that indicates where to insert table. A value of –1 indicates the
    ///character position of the selection.
    int   cpStartRow;
    ///Type: <b>BYTE</b> The table nesting level (EM_GETTABLEPARMS only).
    ubyte bTableLevel;
    ///Type: <b>BYTE</b> The index of the cell to insert or delete (EM_SETTABLEPARMS only).
    ubyte iCell;
}

///Defines the attributes of cells in a table row. The definitions include the corresponding Rich Text Format (RTF)
///control words, which are defined in the Rich Text Format (RTF) Specification.
struct TABLECELLPARMS
{
    ///Type: <b>LONG</b> The width of a cell (\cellx).
    int    dxWidth;
    ushort _bitfield1;
    ///Type: <b>WORD</b> Shading in .01% (\clshdng). This controls the amount of pattern foreground color
    ///(<b>crForePat</b>) and pattern background color (<b>crBackPat</b>) that is used to create the cell background
    ///color. If <b>wShading</b> is 0, the cell background is <b>crBackPat</b>. If it's 10000, the cell background is
    ///<b>crForePat</b>. Values of <b>wShading</b> in between are mixtures of the two pattern colors.
    ushort wShading;
    ///Type: <b>SHORT</b> Left border width, in twips (\clbrdrl\brdrwN).
    short  dxBrdrLeft;
    ///Type: <b>SHORT</b> Top border width (\clbrdrt\brdrwN).
    short  dyBrdrTop;
    ///Type: <b>SHORT</b> Right border width (\clbrdrr\brdrwN).
    short  dxBrdrRight;
    ///Type: <b>SHORT</b> Bottom border width (\clbrdrb\brdrwN).
    short  dyBrdrBottom;
    ///Type: <b>COLORREF</b> Left border color (\clbrdrl\brdrcf).
    uint   crBrdrLeft;
    ///Type: <b>COLORREF</b> Top border color (\clbrdrt\brdrcf).
    uint   crBrdrTop;
    ///Type: <b>COLORREF</b> Right border color (\clbrdrr\brdrcf).
    uint   crBrdrRight;
    ///Type: <b>COLORREF</b> Bottom border color (\clbrdrb\brdrcf).
    uint   crBrdrBottom;
    ///Type: <b>COLORREF</b> Background color (\clcbpat).
    uint   crBackPat;
    ///Type: <b>COLORREF</b> Foreground color (\clcfpat).
    uint   crForePat;
}

///Defines the attributes of an image to be inserted by the EM_INSERTIMAGE message.
struct RICHEDIT_IMAGE_PARAMETERS
{
    ///The width, in HIMETRIC units (0.01 mm), of the image.
    int          xWidth;
    int          yHeight;
    ///If <i>Type</i> is TA_BASELINE, this parameter is the distance, in HIMETRIC units, that the top of the image
    ///extends above the text baseline. If <i>Type</i> is TA_BASELINE and ascent is zero, the bottom of the image is
    ///placed at the text baseline.
    int          Ascent;
    ///The vertical alignment of the image. It can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="TA_BASELINE"></a><a id="ta_baseline"></a><dl>
    ///<dt><b>TA_BASELINE</b></dt> </dl> </td> <td width="60%"> Align the image relative to the text baseline. </td>
    ///</tr> <tr> <td width="40%"><a id="TA_BOTTOM"></a><a id="ta_bottom"></a><dl> <dt><b>TA_BOTTOM</b></dt> </dl> </td>
    ///<td width="60%"> Align the bottom of the image at the bottom of the text line. </td> </tr> <tr> <td
    ///width="40%"><a id="TA_TOP"></a><a id="ta_top"></a><dl> <dt><b>TA_TOP</b></dt> </dl> </td> <td width="60%"> Align
    ///the top of the image at the top of the text line </td> </tr> </table>
    int          Type;
    ///The alternate text for the image.
    const(PWSTR) pwszAlternateText;
    ///The stream that contains the image data.
    IStream      pIStream;
}

///Contains information about an EN_ENDCOMPOSITION notification code from a rich edit control.
struct ENDCOMPOSITIONNOTIFY
{
    ///The <b>code</b> member of this structure identifies the notification code being sent.
    NMHDR nmhdr;
    uint  dwCode;
}

///Contains information about character formatting in a rich edit control. <b>Rich Edit 2.0:</b> The CHARFORMAT2
///structure is a Microsoft Rich Edit 2.0 extension of the <b>CHARFORMAT</b> structure. Microsoft Rich Edit 2.0 and
///later allows you to use either structure with the EM_GETCHARFORMAT and EM_SETCHARFORMAT messages.
struct CHARFORMATA
{
    ///Type: <b>UINT</b> Size in bytes of the specified structure. This member must be set before passing the structure
    ///to the rich edit control.
    uint     cbSize;
    ///Type: <b>DWORD</b> Members containing valid information or attributes to set. This member can be zero, one, or
    ///more than one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="CFM_ALL"></a><a id="cfm_all"></a><dl> <dt><b>CFM_ALL</b></dt> </dl> </td> <td width="60%"> <b>Windows 8</b>:
    ///A combination of the following values: CFM_EFFECTS | CFM_SIZE | CFM_FACE | CFM_OFFSET | CFM_CHARSET </td> </tr>
    ///<tr> <td width="40%"><a id="CFM_BOLD"></a><a id="cfm_bold"></a><dl> <dt><b>CFM_BOLD</b></dt> </dl> </td> <td
    ///width="60%"> The CFE_BOLD value of the <b>dwEffects</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="CFM_CHARSET"></a><a id="cfm_charset"></a><dl> <dt><b>CFM_CHARSET</b></dt> </dl> </td> <td width="60%"> The
    ///<b>bCharSet</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="CFM_COLOR"></a><a
    ///id="cfm_color"></a><dl> <dt><b>CFM_COLOR</b></dt> </dl> </td> <td width="60%"> The <b>crTextColor</b> member and
    ///the CFE_AUTOCOLOR value of the <b>dwEffects</b> member are valid. </td> </tr> <tr> <td width="40%"><a
    ///id="CFM_EFFECTS"></a><a id="cfm_effects"></a><dl> <dt><b>CFM_EFFECTS</b></dt> </dl> </td> <td width="60%">
    ///<b>Windows 8</b>: A combination of the following values: CFM_BOLD | CFM_ITALIC | CFM_UNDERLINE | CFM_COLOR |
    ///CFM_STRIKEOUT | CFE_PROTECTED | CFM_LINK </td> </tr> <tr> <td width="40%"><a id="CFM_FACE"></a><a
    ///id="cfm_face"></a><dl> <dt><b>CFM_FACE</b></dt> </dl> </td> <td width="60%"> The <b>szFaceName</b> member is
    ///valid. </td> </tr> <tr> <td width="40%"><a id="CFM_ITALIC"></a><a id="cfm_italic"></a><dl>
    ///<dt><b>CFM_ITALIC</b></dt> </dl> </td> <td width="60%"> The CFE_ITALIC value of the <b>dwEffects</b> member is
    ///valid. </td> </tr> <tr> <td width="40%"><a id="CFM_OFFSET"></a><a id="cfm_offset"></a><dl>
    ///<dt><b>CFM_OFFSET</b></dt> </dl> </td> <td width="60%"> The <b>yOffset</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="CFM_PROTECTED"></a><a id="cfm_protected"></a><dl> <dt><b>CFM_PROTECTED</b></dt> </dl> </td>
    ///<td width="60%"> The CFE_PROTECTED value of the <b>dwEffects</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="CFM_SIZE"></a><a id="cfm_size"></a><dl> <dt><b>CFM_SIZE</b></dt> </dl> </td> <td width="60%">
    ///The <b>yHeight</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="CFM_STRIKEOUT"></a><a
    ///id="cfm_strikeout"></a><dl> <dt><b>CFM_STRIKEOUT</b></dt> </dl> </td> <td width="60%"> The CFE_STRIKEOUT value of
    ///the <b>dwEffects</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="CFM_UNDERLINE."></a><a
    ///id="cfm_underline."></a><dl> <dt><b>CFM_UNDERLINE.</b></dt> </dl> </td> <td width="60%"> The CFE_UNDERLINE value
    ///of the <b>dwEffects</b> member is valid. </td> </tr> </table>
    uint     dwMask;
    ///Type: <b>DWORD</b> Character effects. This member can be a combination of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CFE_AUTOCOLOR"></a><a
    ///id="cfe_autocolor"></a><dl> <dt><b>CFE_AUTOCOLOR</b></dt> </dl> </td> <td width="60%"> The text color is the
    ///return value of GetSysColor(COLOR_WINDOWTEXT). </td> </tr> <tr> <td width="40%"><a id="CFE_BOLD"></a><a
    ///id="cfe_bold"></a><dl> <dt><b>CFE_BOLD</b></dt> </dl> </td> <td width="60%"> Characters are bold. </td> </tr>
    ///<tr> <td width="40%"><a id="CFE_DISABLED"></a><a id="cfe_disabled"></a><dl> <dt><b>CFE_DISABLED</b></dt> </dl>
    ///</td> <td width="60%"> <b>RichEdit 2.0 and later:</b> Characters are displayed with a shadow that is offset by
    ///3/4 point or one pixel, whichever is larger. </td> </tr> <tr> <td width="40%"><a id="CFE_ITALIC"></a><a
    ///id="cfe_italic"></a><dl> <dt><b>CFE_ITALIC</b></dt> </dl> </td> <td width="60%"> Characters are italic. </td>
    ///</tr> <tr> <td width="40%"><a id="CFE_STRIKEOUT"></a><a id="cfe_strikeout"></a><dl> <dt><b>CFE_STRIKEOUT</b></dt>
    ///</dl> </td> <td width="60%"> Characters are struck. </td> </tr> <tr> <td width="40%"><a id="CFE_UNDERLINE"></a><a
    ///id="cfe_underline"></a><dl> <dt><b>CFE_UNDERLINE</b></dt> </dl> </td> <td width="60%"> Characters are underlined.
    ///</td> </tr> <tr> <td width="40%"><a id="CFE_PROTECTED"></a><a id="cfe_protected"></a><dl>
    ///<dt><b>CFE_PROTECTED</b></dt> </dl> </td> <td width="60%"> Characters are protected; an attempt to modify them
    ///will cause an EN_PROTECTED notification code. </td> </tr> </table>
    uint     dwEffects;
    ///Type: <b>LONG</b> Character height, in twips (1/1440 of an inch or 1/20 of a printer's point).
    int      yHeight;
    ///Type: <b>LONG</b> Character offset, in twips, from the baseline. If the value of this member is positive, the
    ///character is a superscript; if it is negative, the character is a subscript.
    int      yOffset;
    ///Type: <b>COLORREF</b> Text color. This member is ignored if the CFE_AUTOCOLOR character effect is specified. To
    ///generate a COLORREF, use the RGB macro.
    uint     crTextColor;
    ///Type: <b>BYTE</b> Character set value. The <b>bCharSet</b> member can be one of the values specified for the
    ///<b>lfCharSet</b> member of the LOGFONT structure. Microsoft Rich Edit 3.0 may override this value if it is
    ///invalid for the target characters.
    ubyte    bCharSet;
    ///Type: <b>BYTE</b> Font family and pitch. This member is the same as the <b>lfPitchAndFamily</b> member of the
    ///LOGFONT structure.
    ubyte    bPitchAndFamily;
    ///Type: <b>TCHAR[LF_FACESIZE]</b> Null-terminated character array specifying the font name.
    byte[32] szFaceName;
}

///Contains information about character formatting in a rich edit control. <b>Rich Edit 2.0:</b> The CHARFORMAT2
///structure is a Microsoft Rich Edit 2.0 extension of the <b>CHARFORMAT</b> structure. Microsoft Rich Edit 2.0 and
///later allows you to use either structure with the EM_GETCHARFORMAT and EM_SETCHARFORMAT messages.
struct CHARFORMATW
{
    ///Type: <b>UINT</b> Size in bytes of the specified structure. This member must be set before passing the structure
    ///to the rich edit control.
    uint       cbSize;
    ///Type: <b>DWORD</b> Members containing valid information or attributes to set. This member can be zero, one, or
    ///more than one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="CFM_ALL"></a><a id="cfm_all"></a><dl> <dt><b>CFM_ALL</b></dt> </dl> </td> <td width="60%"> <b>Windows 8</b>:
    ///A combination of the following values: CFM_EFFECTS | CFM_SIZE | CFM_FACE | CFM_OFFSET | CFM_CHARSET </td> </tr>
    ///<tr> <td width="40%"><a id="CFM_BOLD"></a><a id="cfm_bold"></a><dl> <dt><b>CFM_BOLD</b></dt> </dl> </td> <td
    ///width="60%"> The CFE_BOLD value of the <b>dwEffects</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="CFM_CHARSET"></a><a id="cfm_charset"></a><dl> <dt><b>CFM_CHARSET</b></dt> </dl> </td> <td width="60%"> The
    ///<b>bCharSet</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="CFM_COLOR"></a><a
    ///id="cfm_color"></a><dl> <dt><b>CFM_COLOR</b></dt> </dl> </td> <td width="60%"> The <b>crTextColor</b> member and
    ///the CFE_AUTOCOLOR value of the <b>dwEffects</b> member are valid. </td> </tr> <tr> <td width="40%"><a
    ///id="CFM_EFFECTS"></a><a id="cfm_effects"></a><dl> <dt><b>CFM_EFFECTS</b></dt> </dl> </td> <td width="60%">
    ///<b>Windows 8</b>: A combination of the following values: CFM_BOLD | CFM_ITALIC | CFM_UNDERLINE | CFM_COLOR |
    ///CFM_STRIKEOUT | CFE_PROTECTED | CFM_LINK </td> </tr> <tr> <td width="40%"><a id="CFM_FACE"></a><a
    ///id="cfm_face"></a><dl> <dt><b>CFM_FACE</b></dt> </dl> </td> <td width="60%"> The <b>szFaceName</b> member is
    ///valid. </td> </tr> <tr> <td width="40%"><a id="CFM_ITALIC"></a><a id="cfm_italic"></a><dl>
    ///<dt><b>CFM_ITALIC</b></dt> </dl> </td> <td width="60%"> The CFE_ITALIC value of the <b>dwEffects</b> member is
    ///valid. </td> </tr> <tr> <td width="40%"><a id="CFM_OFFSET"></a><a id="cfm_offset"></a><dl>
    ///<dt><b>CFM_OFFSET</b></dt> </dl> </td> <td width="60%"> The <b>yOffset</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="CFM_PROTECTED"></a><a id="cfm_protected"></a><dl> <dt><b>CFM_PROTECTED</b></dt> </dl> </td>
    ///<td width="60%"> The CFE_PROTECTED value of the <b>dwEffects</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="CFM_SIZE"></a><a id="cfm_size"></a><dl> <dt><b>CFM_SIZE</b></dt> </dl> </td> <td width="60%">
    ///The <b>yHeight</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="CFM_STRIKEOUT"></a><a
    ///id="cfm_strikeout"></a><dl> <dt><b>CFM_STRIKEOUT</b></dt> </dl> </td> <td width="60%"> The CFE_STRIKEOUT value of
    ///the <b>dwEffects</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="CFM_UNDERLINE."></a><a
    ///id="cfm_underline."></a><dl> <dt><b>CFM_UNDERLINE.</b></dt> </dl> </td> <td width="60%"> The CFE_UNDERLINE value
    ///of the <b>dwEffects</b> member is valid. </td> </tr> </table>
    uint       dwMask;
    ///Type: <b>DWORD</b> Character effects. This member can be a combination of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CFE_AUTOCOLOR"></a><a
    ///id="cfe_autocolor"></a><dl> <dt><b>CFE_AUTOCOLOR</b></dt> </dl> </td> <td width="60%"> The text color is the
    ///return value of GetSysColor(COLOR_WINDOWTEXT). </td> </tr> <tr> <td width="40%"><a id="CFE_BOLD"></a><a
    ///id="cfe_bold"></a><dl> <dt><b>CFE_BOLD</b></dt> </dl> </td> <td width="60%"> Characters are bold. </td> </tr>
    ///<tr> <td width="40%"><a id="CFE_DISABLED"></a><a id="cfe_disabled"></a><dl> <dt><b>CFE_DISABLED</b></dt> </dl>
    ///</td> <td width="60%"> <b>RichEdit 2.0 and later:</b> Characters are displayed with a shadow that is offset by
    ///3/4 point or one pixel, whichever is larger. </td> </tr> <tr> <td width="40%"><a id="CFE_ITALIC"></a><a
    ///id="cfe_italic"></a><dl> <dt><b>CFE_ITALIC</b></dt> </dl> </td> <td width="60%"> Characters are italic. </td>
    ///</tr> <tr> <td width="40%"><a id="CFE_STRIKEOUT"></a><a id="cfe_strikeout"></a><dl> <dt><b>CFE_STRIKEOUT</b></dt>
    ///</dl> </td> <td width="60%"> Characters are struck. </td> </tr> <tr> <td width="40%"><a id="CFE_UNDERLINE"></a><a
    ///id="cfe_underline"></a><dl> <dt><b>CFE_UNDERLINE</b></dt> </dl> </td> <td width="60%"> Characters are underlined.
    ///</td> </tr> <tr> <td width="40%"><a id="CFE_PROTECTED"></a><a id="cfe_protected"></a><dl>
    ///<dt><b>CFE_PROTECTED</b></dt> </dl> </td> <td width="60%"> Characters are protected; an attempt to modify them
    ///will cause an EN_PROTECTED notification code. </td> </tr> </table>
    uint       dwEffects;
    ///Type: <b>LONG</b> Character height, in twips (1/1440 of an inch or 1/20 of a printer's point).
    int        yHeight;
    ///Type: <b>LONG</b> Character offset, in twips, from the baseline. If the value of this member is positive, the
    ///character is a superscript; if it is negative, the character is a subscript.
    int        yOffset;
    ///Type: <b>COLORREF</b> Text color. This member is ignored if the CFE_AUTOCOLOR character effect is specified. To
    ///generate a COLORREF, use the RGB macro.
    uint       crTextColor;
    ///Type: <b>BYTE</b> Character set value. The <b>bCharSet</b> member can be one of the values specified for the
    ///<b>lfCharSet</b> member of the LOGFONT structure. Microsoft Rich Edit 3.0 may override this value if it is
    ///invalid for the target characters.
    ubyte      bCharSet;
    ///Type: <b>BYTE</b> Font family and pitch. This member is the same as the <b>lfPitchAndFamily</b> member of the
    ///LOGFONT structure.
    ubyte      bPitchAndFamily;
    ///Type: <b>TCHAR[LF_FACESIZE]</b> Null-terminated character array specifying the font name.
    ushort[32] szFaceName;
}

///Contains information about character formatting in a rich edit control. <b>CHARFORMAT2</b> is a Microsoft Rich Edit
///2.0 extension of the CHARFORMAT structure. Microsoft Rich Edit 2.0 allows you to use either structure with the
///EM_GETCHARFORMAT and EM_SETCHARFORMAT messages.
struct CHARFORMAT2W
{
    CHARFORMATW __AnonymousBase_richedit_L711_C23;
    ///Type: <b>WORD</b> Font weight. This member is the same as the <b>lfWeight</b> member of the LOGFONT structure. To
    ///use this member, set the <b>CFM_WEIGHT</b> flag in the <b>dwMask</b> member.
    ushort      wWeight;
    ///Type: <b>SHORT</b> Horizontal space between letters, in twips. This value has no effect on the text displayed by
    ///a rich edit control; it is included for compatibility with Windows TOM interfaces. To use this member, set the
    ///<b>CFM_SPACING</b> flag in the <b>dwMask</b> member.
    short       sSpacing;
    ///Type: <b>COLORREF</b> Background color. To use this member, set the <b>CFM_BACKCOLOR</b> flag in the
    ///<b>dwMask</b> member. This member is ignored if the <b>CFE_AUTOBACKCOLOR</b> character effect is specified. To
    ///generate a , use the macro.
    uint        crBackColor;
    ///Type: <b>LCID</b> A 32-bit locale identifier that contains a language identifier in the lower word and a sorting
    ///identifier and reserved value in the upper word. This member has no effect on the text displayed by a rich edit
    ///control, but spelling and grammar checkers can use it to deal with language-dependent problems. You can use the
    ///macro to create an <b>LCID</b> value. To use this member, set the <b>CFM_LCID</b> flag in the <b>dwMask</b>
    ///member.
    uint        lcid;
union
    {
        uint dwReserved;
        uint dwCookie;
    }
    ///Type: <b>SHORT</b> Character style handle. This value has no effect on the text displayed by a rich edit control;
    ///it is included for compatibility with WindowsTOM interfaces. To use this member, set the <b>CFM_STYLE</b> flag in
    ///the <b>dwMask</b> member. For more information see the TOM documentation.
    short       sStyle;
    ///Type: <b>WORD</b> Value of the font size, above which to kern the character (<b>yHeight</b>). This value has no
    ///effect on the text displayed by a rich edit control; it is included for compatibility with TOM interfaces. To use
    ///this member, set the <b>CFM_KERNING</b> flag in the <b>dwMask</b> member.
    ushort      wKerning;
    ///Type: <b>BYTE</b> Specifies the underline type. To use this member, set the <b>CFM_UNDERLINETYPE</b> flag in the
    ///<b>dwMask</b> member. This member can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="CFU_CF1UNDERLINE"></a><a id="cfu_cf1underline"></a><dl>
    ///<dt><b>CFU_CF1UNDERLINE</b></dt> </dl> </td> <td width="60%"> The structure maps CHARFORMAT's bit underline to
    ///<b>CHARFORMAT2</b>, (that is, it performs a <b>CHARFORMAT</b> type of underline on this text). </td> </tr> <tr>
    ///<td width="40%"><a id="CFU_INVERT"></a><a id="cfu_invert"></a><dl> <dt><b>CFU_INVERT</b></dt> </dl> </td> <td
    ///width="60%"> For IME composition, fake a selection. </td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINE"></a><a
    ///id="cfu_underline"></a><dl> <dt><b>CFU_UNDERLINE</b></dt> </dl> </td> <td width="60%"> Text underlined with a
    ///single solid line. </td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINEDASH"></a><a
    ///id="cfu_underlinedash"></a><dl> <dt><b>CFU_UNDERLINEDASH</b></dt> </dl> </td> <td width="60%"> Text underlined
    ///with dashes. </td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINEDASHDOT"></a><a
    ///id="cfu_underlinedashdot"></a><dl> <dt><b>CFU_UNDERLINEDASHDOT</b></dt> </dl> </td> <td width="60%"> Text
    ///underlined with a dashed and dotted line. </td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINEDASHDOTDOT"></a><a
    ///id="cfu_underlinedashdotdot"></a><dl> <dt><b>CFU_UNDERLINEDASHDOTDOT</b></dt> </dl> </td> <td width="60%"> Text
    ///underlined with a dashed and doubled dotted line. </td> </tr> <tr> <td width="40%"><a
    ///id="CFU_UNDERLINEDOTTED"></a><a id="cfu_underlinedotted"></a><dl> <dt><b>CFU_UNDERLINEDOTTED</b></dt> </dl> </td>
    ///<td width="60%"> Text underlined with a dotted line. For versions earlier than Microsoft Rich Edit 3.0, text is
    ///displayed with a solid underline. </td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINEDOUBLE"></a><a
    ///id="cfu_underlinedouble"></a><dl> <dt><b>CFU_UNDERLINEDOUBLE</b></dt> </dl> </td> <td width="60%"> Text
    ///underlined with a double line. The rich edit control displays the text with a solid underline. </td> </tr> <tr>
    ///<td width="40%"><a id="CFU_UNDERLINEDOUBLEWAVE"></a><a id="cfu_underlinedoublewave"></a><dl>
    ///<dt><b>CFU_UNDERLINEDOUBLEWAVE</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEWAVE</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="CFU_UNDERLINEHAIRLINE"></a><a id="cfu_underlinehairline"></a><dl>
    ///<dt><b>CFU_UNDERLINEHAIRLINE</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINE</b>. </td> </tr>
    ///<tr> <td width="40%"><a id="CFU_UNDERLINEHEAVYWAVE"></a><a id="cfu_underlineheavywave"></a><dl>
    ///<dt><b>CFU_UNDERLINEHEAVYWAVE</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEWAVE</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="CFU_UNDERLINELONGDASH"></a><a id="cfu_underlinelongdash"></a><dl>
    ///<dt><b>CFU_UNDERLINELONGDASH</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEDASH</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="CFU_UNDERLINENONE"></a><a id="cfu_underlinenone"></a><dl>
    ///<dt><b>CFU_UNDERLINENONE</b></dt> </dl> </td> <td width="60%"> No underline. This is the default. </td> </tr>
    ///<tr> <td width="40%"><a id="CFU_UNDERLINETHICK"></a><a id="cfu_underlinethick"></a><dl>
    ///<dt><b>CFU_UNDERLINETHICK</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINE</b>. </td> </tr> <tr>
    ///<td width="40%"><a id="CFU_UNDERLINETHICKDASH"></a><a id="cfu_underlinethickdash"></a><dl>
    ///<dt><b>CFU_UNDERLINETHICKDASH</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEDASH</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="CFU_UNDERLINETHICKDASHDOT"></a><a id="cfu_underlinethickdashdot"></a><dl>
    ///<dt><b>CFU_UNDERLINETHICKDASHDOT</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEDASHDOT</b>.
    ///</td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINETHICKDASHDOTDOT"></a><a
    ///id="cfu_underlinethickdashdotdot"></a><dl> <dt><b>CFU_UNDERLINETHICKDASHDOTDOT</b></dt> </dl> </td> <td
    ///width="60%"> Display as <b>CFU_UNDERLINEDASHDOT</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="CFU_UNDERLINETHICKDOTTED"></a><a id="cfu_underlinethickdotted"></a><dl>
    ///<dt><b>CFU_UNDERLINETHICKDOTTED</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEDOT</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="CFU_UNDERLINETHICKLONGDASH"></a><a id="cfu_underlinethicklongdash"></a><dl>
    ///<dt><b>CFU_UNDERLINETHICKLONGDASH</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEDASH</b>.
    ///</td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINEWAVE"></a><a id="cfu_underlinewave"></a><dl>
    ///<dt><b>CFU_UNDERLINEWAVE</b></dt> </dl> </td> <td width="60%"> <b>RichEdit 4.1 and later</b>: Text underlined
    ///with a wavy line. </td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINEWORD"></a><a
    ///id="cfu_underlineword"></a><dl> <dt><b>CFU_UNDERLINEWORD</b></dt> </dl> </td> <td width="60%"> <b>RichEdit 4.1
    ///and later</b>: Underline words only. The rich edit control displays the text with a solid underline. </td> </tr>
    ///</table>
    ubyte       bUnderlineType;
    ///Type: <b>BYTE</b> Text animation type. This value has no effect on the text displayed by a rich edit control; it
    ///is included for compatibility with TOM interfaces. To use this member, set the <b>CFM_ANIMATION</b> flag in the
    ///<b>dwMask</b> member.
    ubyte       bAnimation;
    ///Type: <b>BYTE</b> An index that identifies the author making a revision. The rich edit control uses different
    ///text colors for each different author index. To use this member, set the <b>CFM_REVAUTHOR</b> flag in the
    ///<b>dwMask</b> member.
    ubyte       bRevAuthor;
    ///Type: <b>BYTE</b> Underline color: * UnderlineColor_Black = 0x00; * UnderlineColor_Blue = 0x01; *
    ///UnderlineColor_Aqua = 0x02; * UnderlineColor_Lime = 0x03; * UnderlineColor_Fuchsia = 0x04; * UnderlineColor_Red =
    ///0x05; * UnderlineColor_Yellow = 0x06; * UnderlineColor_White = 0x07; * UnderlineColor_Navy = 0x08; *
    ///UnderlineColor_Teal = 0x09; * UnderlineColor_Green = 0x0A; * UnderlineColor_Purple = 0x0B; *
    ///UnderlineColor_Maroon = 0x0C; * UnderlineColor_Olive = 0x0D; * UnderlineColor_DkGray = 0x0E; *
    ///UnderlineColor_LtGray = 0x0F;
    ubyte       bUnderlineColor;
}

///Contains information about character formatting in a rich edit control. <b>CHARFORMAT2</b> is a Microsoft Rich Edit
///2.0 extension of the CHARFORMAT structure. Microsoft Rich Edit 2.0 allows you to use either structure with the
///EM_GETCHARFORMAT and EM_SETCHARFORMAT messages.
struct CHARFORMAT2A
{
    CHARFORMATA __AnonymousBase_richedit_L736_C23;
    ///Type: <b>WORD</b> Font weight. This member is the same as the <b>lfWeight</b> member of the LOGFONT structure. To
    ///use this member, set the <b>CFM_WEIGHT</b> flag in the <b>dwMask</b> member.
    ushort      wWeight;
    ///Type: <b>SHORT</b> Horizontal space between letters, in twips. This value has no effect on the text displayed by
    ///a rich edit control; it is included for compatibility with Windows TOM interfaces. To use this member, set the
    ///<b>CFM_SPACING</b> flag in the <b>dwMask</b> member.
    short       sSpacing;
    ///Type: <b>COLORREF</b> Background color. To use this member, set the <b>CFM_BACKCOLOR</b> flag in the
    ///<b>dwMask</b> member. This member is ignored if the <b>CFE_AUTOBACKCOLOR</b> character effect is specified. To
    ///generate a , use the macro.
    uint        crBackColor;
    ///Type: <b>LCID</b> A 32-bit locale identifier that contains a language identifier in the lower word and a sorting
    ///identifier and reserved value in the upper word. This member has no effect on the text displayed by a rich edit
    ///control, but spelling and grammar checkers can use it to deal with language-dependent problems. You can use the
    ///macro to create an <b>LCID</b> value. To use this member, set the <b>CFM_LCID</b> flag in the <b>dwMask</b>
    ///member.
    uint        lcid;
union
    {
        uint dwReserved;
        uint dwCookie;
    }
    ///Type: <b>SHORT</b> Character style handle. This value has no effect on the text displayed by a rich edit control;
    ///it is included for compatibility with WindowsTOM interfaces. To use this member, set the <b>CFM_STYLE</b> flag in
    ///the <b>dwMask</b> member. For more information see the TOM documentation.
    short       sStyle;
    ///Type: <b>WORD</b> Value of the font size, above which to kern the character (<b>yHeight</b>). This value has no
    ///effect on the text displayed by a rich edit control; it is included for compatibility with TOM interfaces. To use
    ///this member, set the <b>CFM_KERNING</b> flag in the <b>dwMask</b> member.
    ushort      wKerning;
    ///Type: <b>BYTE</b> Specifies the underline type. To use this member, set the <b>CFM_UNDERLINETYPE</b> flag in the
    ///<b>dwMask</b> member. This member can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="CFU_CF1UNDERLINE"></a><a id="cfu_cf1underline"></a><dl>
    ///<dt><b>CFU_CF1UNDERLINE</b></dt> </dl> </td> <td width="60%"> The structure maps CHARFORMAT's bit underline to
    ///<b>CHARFORMAT2</b>, (that is, it performs a <b>CHARFORMAT</b> type of underline on this text). </td> </tr> <tr>
    ///<td width="40%"><a id="CFU_INVERT"></a><a id="cfu_invert"></a><dl> <dt><b>CFU_INVERT</b></dt> </dl> </td> <td
    ///width="60%"> For IME composition, fake a selection. </td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINE"></a><a
    ///id="cfu_underline"></a><dl> <dt><b>CFU_UNDERLINE</b></dt> </dl> </td> <td width="60%"> Text underlined with a
    ///single solid line. </td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINEDASH"></a><a
    ///id="cfu_underlinedash"></a><dl> <dt><b>CFU_UNDERLINEDASH</b></dt> </dl> </td> <td width="60%"> Text underlined
    ///with dashes. </td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINEDASHDOT"></a><a
    ///id="cfu_underlinedashdot"></a><dl> <dt><b>CFU_UNDERLINEDASHDOT</b></dt> </dl> </td> <td width="60%"> Text
    ///underlined with a dashed and dotted line. </td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINEDASHDOTDOT"></a><a
    ///id="cfu_underlinedashdotdot"></a><dl> <dt><b>CFU_UNDERLINEDASHDOTDOT</b></dt> </dl> </td> <td width="60%"> Text
    ///underlined with a dashed and doubled dotted line. </td> </tr> <tr> <td width="40%"><a
    ///id="CFU_UNDERLINEDOTTED"></a><a id="cfu_underlinedotted"></a><dl> <dt><b>CFU_UNDERLINEDOTTED</b></dt> </dl> </td>
    ///<td width="60%"> Text underlined with a dotted line. For versions earlier than Microsoft Rich Edit 3.0, text is
    ///displayed with a solid underline. </td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINEDOUBLE"></a><a
    ///id="cfu_underlinedouble"></a><dl> <dt><b>CFU_UNDERLINEDOUBLE</b></dt> </dl> </td> <td width="60%"> Text
    ///underlined with a double line. The rich edit control displays the text with a solid underline. </td> </tr> <tr>
    ///<td width="40%"><a id="CFU_UNDERLINEDOUBLEWAVE"></a><a id="cfu_underlinedoublewave"></a><dl>
    ///<dt><b>CFU_UNDERLINEDOUBLEWAVE</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEWAVE</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="CFU_UNDERLINEHAIRLINE"></a><a id="cfu_underlinehairline"></a><dl>
    ///<dt><b>CFU_UNDERLINEHAIRLINE</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINE</b>. </td> </tr>
    ///<tr> <td width="40%"><a id="CFU_UNDERLINEHEAVYWAVE"></a><a id="cfu_underlineheavywave"></a><dl>
    ///<dt><b>CFU_UNDERLINEHEAVYWAVE</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEWAVE</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="CFU_UNDERLINELONGDASH"></a><a id="cfu_underlinelongdash"></a><dl>
    ///<dt><b>CFU_UNDERLINELONGDASH</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEDASH</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="CFU_UNDERLINENONE"></a><a id="cfu_underlinenone"></a><dl>
    ///<dt><b>CFU_UNDERLINENONE</b></dt> </dl> </td> <td width="60%"> No underline. This is the default. </td> </tr>
    ///<tr> <td width="40%"><a id="CFU_UNDERLINETHICK"></a><a id="cfu_underlinethick"></a><dl>
    ///<dt><b>CFU_UNDERLINETHICK</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINE</b>. </td> </tr> <tr>
    ///<td width="40%"><a id="CFU_UNDERLINETHICKDASH"></a><a id="cfu_underlinethickdash"></a><dl>
    ///<dt><b>CFU_UNDERLINETHICKDASH</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEDASH</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="CFU_UNDERLINETHICKDASHDOT"></a><a id="cfu_underlinethickdashdot"></a><dl>
    ///<dt><b>CFU_UNDERLINETHICKDASHDOT</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEDASHDOT</b>.
    ///</td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINETHICKDASHDOTDOT"></a><a
    ///id="cfu_underlinethickdashdotdot"></a><dl> <dt><b>CFU_UNDERLINETHICKDASHDOTDOT</b></dt> </dl> </td> <td
    ///width="60%"> Display as <b>CFU_UNDERLINEDASHDOT</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="CFU_UNDERLINETHICKDOTTED"></a><a id="cfu_underlinethickdotted"></a><dl>
    ///<dt><b>CFU_UNDERLINETHICKDOTTED</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEDOT</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="CFU_UNDERLINETHICKLONGDASH"></a><a id="cfu_underlinethicklongdash"></a><dl>
    ///<dt><b>CFU_UNDERLINETHICKLONGDASH</b></dt> </dl> </td> <td width="60%"> Display as <b>CFU_UNDERLINEDASH</b>.
    ///</td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINEWAVE"></a><a id="cfu_underlinewave"></a><dl>
    ///<dt><b>CFU_UNDERLINEWAVE</b></dt> </dl> </td> <td width="60%"> <b>RichEdit 4.1 and later</b>: Text underlined
    ///with a wavy line. </td> </tr> <tr> <td width="40%"><a id="CFU_UNDERLINEWORD"></a><a
    ///id="cfu_underlineword"></a><dl> <dt><b>CFU_UNDERLINEWORD</b></dt> </dl> </td> <td width="60%"> <b>RichEdit 4.1
    ///and later</b>: Underline words only. The rich edit control displays the text with a solid underline. </td> </tr>
    ///</table>
    ubyte       bUnderlineType;
    ///Type: <b>BYTE</b> Text animation type. This value has no effect on the text displayed by a rich edit control; it
    ///is included for compatibility with TOM interfaces. To use this member, set the <b>CFM_ANIMATION</b> flag in the
    ///<b>dwMask</b> member.
    ubyte       bAnimation;
    ///Type: <b>BYTE</b> An index that identifies the author making a revision. The rich edit control uses different
    ///text colors for each different author index. To use this member, set the <b>CFM_REVAUTHOR</b> flag in the
    ///<b>dwMask</b> member.
    ubyte       bRevAuthor;
    ///Type: <b>BYTE</b> Underline color: * UnderlineColor_Black = 0x00; * UnderlineColor_Blue = 0x01; *
    ///UnderlineColor_Aqua = 0x02; * UnderlineColor_Lime = 0x03; * UnderlineColor_Fuchsia = 0x04; * UnderlineColor_Red =
    ///0x05; * UnderlineColor_Yellow = 0x06; * UnderlineColor_White = 0x07; * UnderlineColor_Navy = 0x08; *
    ///UnderlineColor_Teal = 0x09; * UnderlineColor_Green = 0x0A; * UnderlineColor_Purple = 0x0B; *
    ///UnderlineColor_Maroon = 0x0C; * UnderlineColor_Olive = 0x0D; * UnderlineColor_DkGray = 0x0E; *
    ///UnderlineColor_LtGray = 0x0F;
    ubyte       bUnderlineColor;
}

///Specifies a range of characters in a rich edit control. If the <b>cpMin</b> and <b>cpMax</b> members are equal, the
///range is empty. The range includes everything if <b>cpMin</b> is 0 and <b>cpMax</b> is –1.
struct CHARRANGE
{
    ///Type: <b>LONG</b> Character position index immediately preceding the first character in the range.
    int cpMin;
    ///Type: <b>LONG</b> Character position immediately following the last character in the range.
    int cpMax;
}

///A range of text from a rich edit control. This structure is filled in by the EM_GETTEXTRANGE message. The buffer
///pointed to by the <b>lpstrText</b> member must be large enough to receive all characters and the terminating null
///character.
struct TEXTRANGEA
{
    ///Type: <b>CHARRANGE</b> The range of characters to retrieve.
    CHARRANGE chrg;
    ///Type: <b>LPSTR</b> The text.
    PSTR      lpstrText;
}

///A range of text from a rich edit control. This structure is filled in by the EM_GETTEXTRANGE message. The buffer
///pointed to by the <b>lpstrText</b> member must be large enough to receive all characters and the terminating null
///character.
struct TEXTRANGEW
{
    ///Type: <b>CHARRANGE</b> The range of characters to retrieve.
    CHARRANGE chrg;
    ///Type: <b>LPSTR</b> The text.
    PWSTR     lpstrText;
}

///Contains information that an application passes to a rich edit control in a EM_STREAMIN or EM_STREAMOUT message. The
///rich edit control uses the information to transfer a stream of data into or out of the control.
struct EDITSTREAM
{
    ///Type: <b>DWORD_PTR</b> Specifies an application-defined value that the rich edit control passes to the
    ///EditStreamCallback callback function specified by the <b>pfnCallback</b> member.
    size_t             dwCookie;
    ///Type: <b>DWORD</b> Indicates the results of the stream-in (read) or stream-out (write) operation. A value of zero
    ///indicates no error. A nonzero value can be the return value of the EditStreamCallback function or a code
    ///indicating that the control encountered an error.
    uint               dwError;
    ///Type: <b>EDITSTREAMCALLBACK</b> Pointer to an EditStreamCallback function, which is an application-defined
    ///function that the control calls to transfer data. The control calls the callback function repeatedly,
    ///transferring a portion of the data with each call.
    EDITSTREAMCALLBACK pfnCallback;
}

///Contains information about a search operation in a rich edit control. This structure is used with the EM_FINDTEXT
///message.
struct FINDTEXTA
{
    ///Type: <b>CHARRANGE</b> The range of characters to search.
    CHARRANGE   chrg;
    ///Type: <b>LPCTSTR</b> The null-terminated string used in the find operation.
    const(PSTR) lpstrText;
}

///Contains information about a search operation in a rich edit control. This structure is used with the EM_FINDTEXT
///message.
struct FINDTEXTW
{
    ///Type: <b>CHARRANGE</b> The range of characters to search.
    CHARRANGE    chrg;
    ///Type: <b>LPCTSTR</b> The null-terminated string used in the find operation.
    const(PWSTR) lpstrText;
}

///Contains information about text to search for in a rich edit control. This structure is used with the EM_FINDTEXTEX
///message.
struct FINDTEXTEXA
{
    ///Type: <b>CHARRANGE</b> The range of characters to search. To search forward in the entire control, set
    ///<b>cpMin</b> to 0 and <b>cpMax</b> to -1.
    CHARRANGE   chrg;
    ///Type: <b>LPCTSTR</b> The null-terminated string to find.
    const(PSTR) lpstrText;
    ///Type: <b>CHARRANGE</b> The range of characters in which the text was found. If the text was not found,
    ///<b>cpMin</b> and <b>cpMax</b> are -1.
    CHARRANGE   chrgText;
}

///Contains information about text to search for in a rich edit control. This structure is used with the EM_FINDTEXTEX
///message.
struct FINDTEXTEXW
{
    ///Type: <b>CHARRANGE</b> The range of characters to search. To search forward in the entire control, set
    ///<b>cpMin</b> to 0 and <b>cpMax</b> to -1.
    CHARRANGE    chrg;
    ///Type: <b>LPCTSTR</b> The null-terminated string to find.
    const(PWSTR) lpstrText;
    ///Type: <b>CHARRANGE</b> The range of characters in which the text was found. If the text was not found,
    ///<b>cpMin</b> and <b>cpMax</b> are -1.
    CHARRANGE    chrgText;
}

///Information that a rich edit control uses to format its output for a particular device. This structure is used with
///the EM_FORMATRANGE message.
struct FORMATRANGE
{
    ///Type: <b>HDC</b> A HDC for the device to render to, if EM_FORMATRANGE is being used to send the output to a
    ///device.
    HDC       hdc;
    ///Type: <b>HDC</b> An HDC for the target device to format for.
    HDC       hdcTarget;
    ///Type: <b>RECT</b> The area within the <i>rcPage</i> rectangle to render to. Units are measured in twips.
    RECT      rc;
    ///Type: <b>RECT</b> The entire area of a page on the rendering device. Units are measured in twips.
    RECT      rcPage;
    ///Type: <b>CHARRANGE</b> The range of characters to format.
    CHARRANGE chrg;
}

///Contains information about paragraph formatting attributes in a rich edit control. This structure is used with the
///EM_GETPARAFORMAT and EM_SETPARAFORMAT messages. In Microsoft Rich Edit 2.0, the PARAFORMAT2 structure is a Microsoft
///Rich Edit 2.0 extension of the <b>PARAFORMAT</b> structure. Microsoft Rich Edit 2.0 allows you to use either
///structure with EM_GETPARAFORMAT and EM_SETPARAFORMAT.
struct PARAFORMAT
{
    ///Type: <b>UINT</b> Structure size, in bytes. The member must be filled before passing to the rich edit control.
    uint    cbSize;
    ///Type: <b>DWORD</b> Members containing valid information or attributes to set. This parameter can be none or a
    ///combination of the following values. If both PFM_STARTINDENT and PFM_OFFSETINDENT are specified, PFM_STARTINDENT
    ///takes precedence. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="PFM_ALIGNMENT"></a><a id="pfm_alignment"></a><dl> <dt><b>PFM_ALIGNMENT</b></dt> </dl> </td> <td width="60%">
    ///The <b>wAlignment</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="PFM_NUMBERING"></a><a
    ///id="pfm_numbering"></a><dl> <dt><b>PFM_NUMBERING</b></dt> </dl> </td> <td width="60%"> The <b>wNumbering</b>
    ///member is valid. </td> </tr> <tr> <td width="40%"><a id="PFM_OFFSET"></a><a id="pfm_offset"></a><dl>
    ///<dt><b>PFM_OFFSET</b></dt> </dl> </td> <td width="60%"> The <b>dxOffset</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="PFM_OFFSETINDENT"></a><a id="pfm_offsetindent"></a><dl> <dt><b>PFM_OFFSETINDENT</b></dt> </dl>
    ///</td> <td width="60%"> The <b>dxStartIndent</b> member is valid and specifies a relative value. </td> </tr> <tr>
    ///<td width="40%"><a id="PFM_RIGHTINDENT"></a><a id="pfm_rightindent"></a><dl> <dt><b>PFM_RIGHTINDENT</b></dt>
    ///</dl> </td> <td width="60%"> The <b>dxRightIndent</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="PFM_RTLPARA"></a><a id="pfm_rtlpara"></a><dl> <dt><b>PFM_RTLPARA</b></dt> </dl> </td> <td width="60%">
    ///<b>Rich Edit 2.0:</b> The <b>wEffects</b> member is valid </td> </tr> <tr> <td width="40%"><a
    ///id="PFM_STARTINDENT"></a><a id="pfm_startindent"></a><dl> <dt><b>PFM_STARTINDENT</b></dt> </dl> </td> <td
    ///width="60%"> The <b>dxStartIndent</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="PFM_TABSTOPS"></a><a id="pfm_tabstops"></a><dl> <dt><b>PFM_TABSTOPS</b></dt> </dl> </td> <td width="60%"> The
    ///<i>cTabStobs</i> and <i>rgxTabStops</i> members are valid. </td> </tr> </table>
    uint    dwMask;
    ///Type: <b>WORD</b> Value specifying numbering options. This member can be zero or PFN_BULLET.
    ushort  wNumbering;
union
    {
        ushort wReserved;
        ushort wEffects;
    }
    ///Type: <b>LONG</b> Indentation of the first line in the paragraph, in twips. If the paragraph formatting is being
    ///set and PFM_OFFSETINDENT is specified, this member is treated as a relative value that is added to the starting
    ///indentation of each affected paragraph.
    int     dxStartIndent;
    ///Type: <b>LONG</b> Size, of the right indentation relative to the right margin, in twips.
    int     dxRightIndent;
    ///Type: <b>LONG</b> Indentation of the second and subsequent lines of a paragraph relative to the starting
    ///indentation, in twips. The first line is indented if this member is negative or outdented if this member is
    ///positive.
    int     dxOffset;
    ///Type: <b>WORD</b> Value specifying the paragraph alignment. This member can be one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PFA_CENTER"></a><a
    ///id="pfa_center"></a><dl> <dt><b>PFA_CENTER</b></dt> </dl> </td> <td width="60%"> Paragraphs are centered. </td>
    ///</tr> <tr> <td width="40%"><a id="PFA_LEFT"></a><a id="pfa_left"></a><dl> <dt><b>PFA_LEFT</b></dt> </dl> </td>
    ///<td width="60%"> Paragraphs are aligned with the left margin. </td> </tr> <tr> <td width="40%"><a
    ///id="PFA_RIGHT"></a><a id="pfa_right"></a><dl> <dt><b>PFA_RIGHT</b></dt> </dl> </td> <td width="60%"> Paragraphs
    ///are aligned with the right margin. </td> </tr> </table>
    ushort  wAlignment;
    ///Type: <b>SHORT</b> Number of tab stops.
    short   cTabCount;
    ///Type: <b>LONG</b> Array of absolute tab stop positions. Each element in the array specifies information about a
    ///tab stop. The 24 low-order bits specify the absolute offset, in twips. To use this member, set the PFM_TABSTOPS
    ///flag in the <b>dwMask</b> member. <b>Rich Edit 2.0:</b> For compatibility with TOM interfaces, you can use the
    ///eight high-order bits to store additional information about each tab stop. Bits 24-27 can specify one of the
    ///following values to indicate the tab alignment. These bits do not affect the rich edit control display for
    ///versions earlier than Microsoft Rich Edit 3.0. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> Ordinary tab </td> </tr> <tr> <td
    ///width="40%"><a id="1"></a><dl> <dt><b>1</b></dt> </dl> </td> <td width="60%"> Center tab </td> </tr> <tr> <td
    ///width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> Right-aligned tab </td> </tr> <tr>
    ///<td width="40%"><a id="3"></a><dl> <dt><b>3</b></dt> </dl> </td> <td width="60%"> Decimal tab </td> </tr> <tr>
    ///<td width="40%"><a id="4"></a><dl> <dt><b>4</b></dt> </dl> </td> <td width="60%"> Word bar tab (vertical bar)
    ///</td> </tr> </table> Bits 28-31 can specify one of the following values to indicate the type of tab leader. These
    ///bits do not affect the rich edit control display. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> No leader </td> </tr> <tr> <td
    ///width="40%"><a id="1"></a><dl> <dt><b>1</b></dt> </dl> </td> <td width="60%"> Dotted leader </td> </tr> <tr> <td
    ///width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> Dashed leader </td> </tr> <tr> <td
    ///width="40%"><a id="3"></a><dl> <dt><b>3</b></dt> </dl> </td> <td width="60%"> Underlined leader </td> </tr> <tr>
    ///<td width="40%"><a id="4"></a><dl> <dt><b>4</b></dt> </dl> </td> <td width="60%"> Thick line leader </td> </tr>
    ///<tr> <td width="40%"><a id="5"></a><dl> <dt><b>5</b></dt> </dl> </td> <td width="60%"> Double line leader </td>
    ///</tr> </table>
    int[32] rgxTabs;
}

///Contains information about paragraph formatting attributes in a rich edit control. <b>PARAFORMAT2</b> is a Microsoft
///Rich Edit 2.0 extension of the PARAFORMAT structure. Microsoft Rich Edit 2.0 allows you to use either structure with
///the EM_GETPARAFORMAT and EM_SETPARAFORMAT messages.
struct PARAFORMAT2
{
    PARAFORMAT __AnonymousBase_richedit_L1149_C22;
    ///Type: <b>LONG</b> Size of the spacing above the paragraph, in twips. To use this member, set the PFM_SPACEBEFORE
    ///flag in the <b>dwMask</b> member. The value must be greater than or equal to zero.
    int        dySpaceBefore;
    ///Type: <b>LONG</b> Specifies the size of the spacing below the paragraph, in twips. To use this member, set the
    ///PFM_SPACEAFTER flag in the <b>dwMask</b> member. The value must be greater than or equal to zero.
    int        dySpaceAfter;
    ///Type: <b>LONG</b> Spacing between lines. For a description of how this value is interpreted, see the
    ///<b>bLineSpacingRule</b> member. To use this member, set the PFM_LINESPACING flag in the <b>dwMask</b> member.
    int        dyLineSpacing;
    ///Type: <b>SHORT</b> Text style. To use this member, set the PFM_STYLE flag in the <b>dwMask</b> member. This
    ///member is included only for compatibility with TOM interfaces and Word; the rich edit control stores the value
    ///but does not use it to display the text.
    short      sStyle;
    ///Type: <b>BYTE</b> Type of line spacing. To use this member, set the PFM_LINESPACING flag in the <b>dwMask</b>
    ///member. This member can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> Single spacing. The
    ///<b>dyLineSpacing</b> member is ignored. </td> </tr> <tr> <td width="40%"><a id="1"></a><dl> <dt><b>1</b></dt>
    ///</dl> </td> <td width="60%"> One-and-a-half spacing. The <b>dyLineSpacing</b> member is ignored. </td> </tr> <tr>
    ///<td width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> Double spacing. The
    ///<b>dyLineSpacing</b> member is ignored. </td> </tr> <tr> <td width="40%"><a id="3"></a><dl> <dt><b>3</b></dt>
    ///</dl> </td> <td width="60%"> The <b>dyLineSpacing</b> member specifies the spacingfrom one line to the next, in
    ///twips. However, if <b>dyLineSpacing</b> specifies a value that is less than single spacing, the control displays
    ///single-spaced text. </td> </tr> <tr> <td width="40%"><a id="4"></a><dl> <dt><b>4</b></dt> </dl> </td> <td
    ///width="60%"> The <b>dyLineSpacing</b> member specifies the spacing from one line to the next, in twips. The
    ///control uses the exact spacing specified, even if <b>dyLineSpacing</b> specifies a value that is less than single
    ///spacing. </td> </tr> <tr> <td width="40%"><a id="5"></a><dl> <dt><b>5</b></dt> </dl> </td> <td width="60%"> The
    ///value of <b>dyLineSpacing</b> / 20 is the spacing, in lines, from one line to the next. Thus, setting
    ///<b>dyLineSpacing</b> to 20 produces single-spaced text, 40 is double spaced, 60 is triple spaced, and so on.
    ///</td> </tr> </table>
    ubyte      bLineSpacingRule;
    ///Type: <b>BYTE</b> Reserved; must be zero.
    ubyte      bOutlineLevel;
    ///Type: <b>WORD</b> Percentage foreground color used in shading. The <b>wShadingStyle</b> member specifies the
    ///foreground and background shading colors. A value of 5 indicates a shading color consisting of 5 percent
    ///foreground color and 95 percent background color. To use these members, set the PFM_SHADING flag in the
    ///<b>dwMask</b> member. This member is included only for compatibility with Word; the rich edit control stores the
    ///value but does not use it to display the text.
    ushort     wShadingWeight;
    ///Type: <b>WORD</b> Style and colors used for background shading. Bits 0 to 3 contain the shading style, bits 4 to
    ///7 contain the foreground color index, and bits 8 to 11 contain the background color index. To use this member,
    ///set the PFM_SHADING flag in the <b>dwMask</b> member. This member is included only for compatibility with Word;
    ///the rich edit control stores the value but does not use it to display the text. The shading style can be one of
    ///the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl>
    ///<dt><b>0</b></dt> </dl> </td> <td width="60%"> None </td> </tr> <tr> <td width="40%"><a id="1"></a><dl>
    ///<dt><b>1</b></dt> </dl> </td> <td width="60%"> Dark horizontal </td> </tr> <tr> <td width="40%"><a
    ///id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> Dark vertical </td> </tr> <tr> <td width="40%"><a
    ///id="3"></a><dl> <dt><b>3</b></dt> </dl> </td> <td width="60%"> Dark down diagonal </td> </tr> <tr> <td
    ///width="40%"><a id="4"></a><dl> <dt><b>4</b></dt> </dl> </td> <td width="60%"> Dark up diagonal </td> </tr> <tr>
    ///<td width="40%"><a id="5"></a><dl> <dt><b>5</b></dt> </dl> </td> <td width="60%"> Dark grid </td> </tr> <tr> <td
    ///width="40%"><a id="6"></a><dl> <dt><b>6</b></dt> </dl> </td> <td width="60%"> Dark trellis </td> </tr> <tr> <td
    ///width="40%"><a id="7"></a><dl> <dt><b>7</b></dt> </dl> </td> <td width="60%"> Light horizontal </td> </tr> <tr>
    ///<td width="40%"><a id="8"></a><dl> <dt><b>8</b></dt> </dl> </td> <td width="60%"> Light vertical </td> </tr> <tr>
    ///<td width="40%"><a id="9"></a><dl> <dt><b>9</b></dt> </dl> </td> <td width="60%"> Light down diagonal </td> </tr>
    ///<tr> <td width="40%"><a id="10"></a><dl> <dt><b>10</b></dt> </dl> </td> <td width="60%"> Light up diagonal </td>
    ///</tr> <tr> <td width="40%"><a id="11"></a><dl> <dt><b>11</b></dt> </dl> </td> <td width="60%"> Light grid </td>
    ///</tr> <tr> <td width="40%"><a id="12"></a><dl> <dt><b>12</b></dt> </dl> </td> <td width="60%"> Light trellis
    ///</td> </tr> </table> The foreground and background color indexes can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td
    ///width="60%"> Black </td> </tr> <tr> <td width="40%"><a id="1"></a><dl> <dt><b>1</b></dt> </dl> </td> <td
    ///width="60%"> Blue </td> </tr> <tr> <td width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td
    ///width="60%"> Cyan </td> </tr> <tr> <td width="40%"><a id="3"></a><dl> <dt><b>3</b></dt> </dl> </td> <td
    ///width="60%"> Green </td> </tr> <tr> <td width="40%"><a id="4"></a><dl> <dt><b>4</b></dt> </dl> </td> <td
    ///width="60%"> Magenta </td> </tr> <tr> <td width="40%"><a id="5"></a><dl> <dt><b>5</b></dt> </dl> </td> <td
    ///width="60%"> Red </td> </tr> <tr> <td width="40%"><a id="6"></a><dl> <dt><b>6</b></dt> </dl> </td> <td
    ///width="60%"> Yellow </td> </tr> <tr> <td width="40%"><a id="7"></a><dl> <dt><b>7</b></dt> </dl> </td> <td
    ///width="60%"> White </td> </tr> <tr> <td width="40%"><a id="8"></a><dl> <dt><b>8</b></dt> </dl> </td> <td
    ///width="60%"> Dark blue </td> </tr> <tr> <td width="40%"><a id="9"></a><dl> <dt><b>9</b></dt> </dl> </td> <td
    ///width="60%"> Dark cyan </td> </tr> <tr> <td width="40%"><a id="10"></a><dl> <dt><b>10</b></dt> </dl> </td> <td
    ///width="60%"> Dark green </td> </tr> <tr> <td width="40%"><a id="11"></a><dl> <dt><b>11</b></dt> </dl> </td> <td
    ///width="60%"> Dark magenta </td> </tr> <tr> <td width="40%"><a id="12"></a><dl> <dt><b>12</b></dt> </dl> </td> <td
    ///width="60%"> Dark red </td> </tr> <tr> <td width="40%"><a id="13"></a><dl> <dt><b>13</b></dt> </dl> </td> <td
    ///width="60%"> Dark yellow </td> </tr> <tr> <td width="40%"><a id="14"></a><dl> <dt><b>14</b></dt> </dl> </td> <td
    ///width="60%"> Dark gray </td> </tr> <tr> <td width="40%"><a id="15"></a><dl> <dt><b>15</b></dt> </dl> </td> <td
    ///width="60%"> Light gray </td> </tr> </table>
    ushort     wShadingStyle;
    ///Type: <b>WORD</b> Starting number or Unicode value used for numbered paragraphs. Use this member in conjunction
    ///with the <b>wNumbering</b> member. This member is included only for compatibility with TOM interfaces; the rich
    ///edit control stores the value but does not use it to display the text or bullets. To use this member, set the
    ///PFM_NUMBERINGSTART flag in the <b>dwMask</b> member.
    ushort     wNumberingStart;
    ///Type: <b>WORD</b> Numbering style used with numbered paragraphs. Use this member in conjunction with the
    ///<b>wNumbering</b> member. This member is included only for compatibility with TOM interfaces; the rich edit
    ///control stores the value but rich edit versions earlier than 3.0 do not use it to display the text or bullets. To
    ///use this member, set the PFM_NUMBERINGSTYLE flag in the <b>dwMask</b> member. This member can be one of the
    ///following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="PFNS_PAREN"></a><a id="pfns_paren"></a><dl> <dt><b>PFNS_PAREN</b></dt> </dl> </td> <td width="60%"> Follows
    ///the number with a right parenthesis. </td> </tr> <tr> <td width="40%"><a id="PFNS_PARENS"></a><a
    ///id="pfns_parens"></a><dl> <dt><b>PFNS_PARENS</b></dt> </dl> </td> <td width="60%"> Encloses the number in
    ///parentheses. </td> </tr> <tr> <td width="40%"><a id="PFNS_PERIOD"></a><a id="pfns_period"></a><dl>
    ///<dt><b>PFNS_PERIOD</b></dt> </dl> </td> <td width="60%"> Follows the number with a period. </td> </tr> <tr> <td
    ///width="40%"><a id="PFNS_PLAIN"></a><a id="pfns_plain"></a><dl> <dt><b>PFNS_PLAIN</b></dt> </dl> </td> <td
    ///width="60%"> Displays only the number. </td> </tr> <tr> <td width="40%"><a id="PFNS_NONUMBER"></a><a
    ///id="pfns_nonumber"></a><dl> <dt><b>PFNS_NONUMBER</b></dt> </dl> </td> <td width="60%"> Continues a numbered list
    ///without applying the next number or bullet. </td> </tr> <tr> <td width="40%"><a id="PFNS_NEWNUMBER"></a><a
    ///id="pfns_newnumber"></a><dl> <dt><b>PFNS_NEWNUMBER</b></dt> </dl> </td> <td width="60%"> Starts a new number with
    ///<b>wNumberingStart</b>. </td> </tr> </table>
    ushort     wNumberingStyle;
    ///Type: <b>WORD</b> Minimum space between a paragraph number and the paragraph text, in twips. Use this member in
    ///conjunction with the <b>wNumbering</b> member. The <b>wNumberingTab</b> member is included for compatibility with
    ///TOM interfaces; previous to Microsoft Rich Edit 3.0, the rich edit control stores the value but does not use it
    ///to display text. To use this member, set the PFM_NUMBERINGTAB flag in the <b>dwMask</b> member.
    ushort     wNumberingTab;
    ///Type: <b>WORD</b> The space between the border and the paragraph text, in twips. The <b>wBorderSpace</b> member
    ///is included for compatibility with Word; the rich edit control stores the values but does not use them to display
    ///text. To use this member, set the PFM_BORDER flag in the <b>dwMask</b> member.
    ushort     wBorderSpace;
    ///Type: <b>WORD</b> Border width, in twips. To use this member, set the PFM_BORDER flag in the <b>dwMask</b>
    ///member.
    ushort     wBorderWidth;
    ///Type: <b>WORD</b> Border location, style, and color. Bits 0 to 7 specify the border locations, bits 8 to 11
    ///specify the border style, and bits 12 to 15 specify the border color index. To use this member, set the
    ///PFM_BORDER flag in the <b>dwMask</b> member. Specify the border locations using a combination of the following
    ///values in bits 0 to 7. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="1"></a><dl>
    ///<dt><b>1</b></dt> </dl> </td> <td width="60%"> Left border. </td> </tr> <tr> <td width="40%"><a id="2"></a><dl>
    ///<dt><b>2</b></dt> </dl> </td> <td width="60%"> Right border. </td> </tr> <tr> <td width="40%"><a id="4"></a><dl>
    ///<dt><b>4</b></dt> </dl> </td> <td width="60%"> Top border. </td> </tr> <tr> <td width="40%"><a id="8"></a><dl>
    ///<dt><b>8</b></dt> </dl> </td> <td width="60%"> Bottom border. </td> </tr> <tr> <td width="40%"><a
    ///id="16"></a><dl> <dt><b>16</b></dt> </dl> </td> <td width="60%"> Inside borders. </td> </tr> <tr> <td
    ///width="40%"><a id="32"></a><dl> <dt><b>32</b></dt> </dl> </td> <td width="60%"> Outside borders. </td> </tr> <tr>
    ///<td width="40%"><a id="64"></a><dl> <dt><b>64</b></dt> </dl> </td> <td width="60%"> Autocolor. If this bit is
    ///set, the color index in bits 12 to 15 is not used. </td> </tr> </table> Specify the border style using one of the
    ///following values for bits 8 to 11. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> None </td> </tr> <tr> <td width="40%"><a
    ///id="1"></a><dl> <dt><b>1</b></dt> </dl> </td> <td width="60%"> <b>3</b>/<b>4</b> point </td> </tr> <tr> <td
    ///width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> 1<b>1</b>/<b>2</b> point </td>
    ///</tr> <tr> <td width="40%"><a id="3"></a><dl> <dt><b>3</b></dt> </dl> </td> <td width="60%"> 2<b>1</b>/<b>4</b>
    ///point </td> </tr> <tr> <td width="40%"><a id="4"></a><dl> <dt><b>4</b></dt> </dl> </td> <td width="60%"> 3 point
    ///</td> </tr> <tr> <td width="40%"><a id="5"></a><dl> <dt><b>5</b></dt> </dl> </td> <td width="60%">
    ///4<b>1</b>/<b>2</b> point </td> </tr> <tr> <td width="40%"><a id="6"></a><dl> <dt><b>6</b></dt> </dl> </td> <td
    ///width="60%"> 6 point </td> </tr> <tr> <td width="40%"><a id="7"></a><dl> <dt><b>7</b></dt> </dl> </td> <td
    ///width="60%"> <b>3</b>/<b>4</b> point double </td> </tr> <tr> <td width="40%"><a id="8"></a><dl> <dt><b>8</b></dt>
    ///</dl> </td> <td width="60%"> 1<b>1</b>/<b>2</b> point double </td> </tr> <tr> <td width="40%"><a id="9"></a><dl>
    ///<dt><b>9</b></dt> </dl> </td> <td width="60%"> 2<b>1</b>/<b>4</b> point double </td> </tr> <tr> <td
    ///width="40%"><a id="10"></a><dl> <dt><b>10</b></dt> </dl> </td> <td width="60%"> <b>3</b>/<b>4</b> point gray
    ///</td> </tr> <tr> <td width="40%"><a id="11"></a><dl> <dt><b>11</b></dt> </dl> </td> <td width="60%">
    ///<b>3</b>/<b>4</b> point gray dashed </td> </tr> </table> Specify the border color using one of the following
    ///values for bits 12 to 15. This value is ignored if the autocolor bit (bit 6) is set. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%">
    ///Black </td> </tr> <tr> <td width="40%"><a id="1"></a><dl> <dt><b>1</b></dt> </dl> </td> <td width="60%"> Blue
    ///</td> </tr> <tr> <td width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> Cyan </td>
    ///</tr> <tr> <td width="40%"><a id="3"></a><dl> <dt><b>3</b></dt> </dl> </td> <td width="60%"> Green </td> </tr>
    ///<tr> <td width="40%"><a id="4"></a><dl> <dt><b>4</b></dt> </dl> </td> <td width="60%"> Magenta </td> </tr> <tr>
    ///<td width="40%"><a id="5"></a><dl> <dt><b>5</b></dt> </dl> </td> <td width="60%"> Red </td> </tr> <tr> <td
    ///width="40%"><a id="6"></a><dl> <dt><b>6</b></dt> </dl> </td> <td width="60%"> Yellow </td> </tr> <tr> <td
    ///width="40%"><a id="7"></a><dl> <dt><b>7</b></dt> </dl> </td> <td width="60%"> White </td> </tr> <tr> <td
    ///width="40%"><a id="8"></a><dl> <dt><b>8</b></dt> </dl> </td> <td width="60%"> Dark blue </td> </tr> <tr> <td
    ///width="40%"><a id="9"></a><dl> <dt><b>9</b></dt> </dl> </td> <td width="60%"> Dark cyan </td> </tr> <tr> <td
    ///width="40%"><a id="10"></a><dl> <dt><b>10</b></dt> </dl> </td> <td width="60%"> Dark green </td> </tr> <tr> <td
    ///width="40%"><a id="11"></a><dl> <dt><b>11</b></dt> </dl> </td> <td width="60%"> Dark magenta </td> </tr> <tr> <td
    ///width="40%"><a id="12"></a><dl> <dt><b>12</b></dt> </dl> </td> <td width="60%"> Dark red </td> </tr> <tr> <td
    ///width="40%"><a id="13"></a><dl> <dt><b>13</b></dt> </dl> </td> <td width="60%"> Dark yellow </td> </tr> <tr> <td
    ///width="40%"><a id="14"></a><dl> <dt><b>14</b></dt> </dl> </td> <td width="60%"> Dark gray </td> </tr> <tr> <td
    ///width="40%"><a id="15"></a><dl> <dt><b>15</b></dt> </dl> </td> <td width="60%"> Light gray </td> </tr> </table>
    ushort     wBorders;
}

///Contains information about a keyboard or mouse event. A rich edit control sends this structure to its parent window
///as part of an EN_MSGFILTER notification code, enabling the parent to change the message or prevent it from being
///processed.
struct MSGFILTER
{
    ///Type: <b>NMHDR</b> The <b>code</b> member of the NMHDR structure is the EN_MSGFILTER notification code that
    ///identifies the message being sent.
    NMHDR  nmhdr;
    ///Type: <b>UINT</b> Keyboard or mouse message identifier.
    uint   msg;
    ///Type: <b>WPARAM</b> The <b>wParam</b> parameter of the message.
    WPARAM wParam;
    ///Type: <b>LPARAM</b> The <b>lParam</b> parameter of the message.
    LPARAM lParam;
}

///Contains the requested size of a rich edit control. A rich edit control sends this structure to its parent window as
///part of an EN_REQUESTRESIZE notification code.
struct REQRESIZE
{
    ///Type: <b>NMHDR</b> Notification header.
    NMHDR nmhdr;
    ///Type: <b>RECT</b> Requested new size.
    RECT  rc;
}

///Contains information associated with an EN_SELCHANGE notification code. A rich edit control sends this notification
///to its parent window when the current selection changes.
struct SELCHANGE
{
    ///Type: <b>NMHDR</b> Notification header.
    NMHDR     nmhdr;
    ///Type: <b>CHARRANGE</b> New selection range.
    CHARRANGE chrg;
    ///Type: <b>WORD</b> Value specifying the contents of the new selection. This member is SEL_EMPTY if the selection
    ///is empty or one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="SEL_TEXT"></a><a id="sel_text"></a><dl> <dt><b>SEL_TEXT</b></dt> </dl> </td> <td width="60%">
    ///Text. </td> </tr> <tr> <td width="40%"><a id="SEL_OBJECT"></a><a id="sel_object"></a><dl>
    ///<dt><b>SEL_OBJECT</b></dt> </dl> </td> <td width="60%"> At least one COM object. </td> </tr> <tr> <td
    ///width="40%"><a id="SEL_MULTICHAR"></a><a id="sel_multichar"></a><dl> <dt><b>SEL_MULTICHAR</b></dt> </dl> </td>
    ///<td width="60%"> More than one character of text. </td> </tr> <tr> <td width="40%"><a id="SEL_MULTIOBJECT"></a><a
    ///id="sel_multiobject"></a><dl> <dt><b>SEL_MULTIOBJECT</b></dt> </dl> </td> <td width="60%"> More than one COM
    ///object. </td> </tr> </table>
    ushort    seltyp;
}

struct _grouptypingchange
{
    NMHDR nmhdr;
    BOOL  fGroupTyping;
}

///Specifies the clipboard format. This structure included with the EN_CLIPFORMAT notification.
struct CLIPBOARDFORMAT
{
    ///Type: <b>NMHDR</b> Structure that contains information about this notification message.
    NMHDR  nmhdr;
    ///Type: <b>DWORD</b> A clipboard format registered by a call to the RegisterClipboardFormat function.
    ushort cf;
}

///Contains context menu information that is passed to the IRichEditOleCallback::GetContextMenu method.
struct GETCONTEXTMENUEX
{
    ///Type: <b>CHARRANGE</b> The character-position range in the active display.
    CHARRANGE chrg;
    ///Type: <b>DWORD</b> One or more of the following content menu flags: <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="GCMF_GRIPPER"></a><a id="gcmf_gripper"></a><dl> <dt><b>GCMF_GRIPPER</b></dt>
    ///</dl> </td> <td width="60%"> Get the context menu that is invoked by tapping a touch gripper handle. </td> </tr>
    ///<tr> <td width="40%"><a id="GCMF_SPELLING"></a><a id="gcmf_spelling"></a><dl> <dt><b>GCMF_SPELLING</b></dt> </dl>
    ///</td> <td width="60%"> Get the context menu for a spelling error. </td> </tr> <tr> <td width="40%"><a
    ///id="GCMF_MOUSEMENU"></a><a id="gcmf_mousemenu"></a><dl> <dt><b>GCMF_MOUSEMENU</b></dt> </dl> </td> <td
    ///width="60%"> Get the context menu that is invoked by mouse. </td> </tr> <tr> <td width="40%"><a
    ///id="GCMF_TOUCHMENU"></a><a id="gcmf_touchmenu"></a><dl> <dt><b>GCMF_TOUCHMENU</b></dt> </dl> </td> <td
    ///width="60%"> Get the context menu that is invoked by touch. </td> </tr> </table>
    uint      dwFlags;
    ///Type: <b>POINT</b> The screen coordinates for the content menu.
    POINT     pt;
    ///Type: <b>void*</b> Not used; must be zero.
    void*     pvReserved;
}

///Contains information associated with an EN_DROPFILES notification code. A rich edit control sends this notification
///code when it receives a WM_DROPFILES message.
struct ENDROPFILES
{
    ///Type: <b>NMHDR</b> Notification header.
    NMHDR  nmhdr;
    ///Type: <b>HANDLE</b> Handle to the dropped files list (same as with WM_DROPFILES ). This handle is used with the
    ///DragFinish, DragQueryFile, and DragQueryPoint functions.
    HANDLE hDrop;
    ///Type: <b>LONG</b> Character position at which the dropped files would be inserted.
    int    cp;
    BOOL   fProtected;
}

///Contains information associated with an EN_PROTECTED notification code. A rich edit control sends this notification
///when the user attempts to edit protected text.
struct ENPROTECTED
{
    ///Type: <b>NMHDR</b> NMHDR notification header.
    NMHDR     nmhdr;
    ///Type: <b>UINT</b> Message that triggered the notification.
    uint      msg;
    ///Type: <b>WPARAM</b> The <b>wParam</b> parameter of the message.
    WPARAM    wParam;
    ///Type: <b>LPARAM</b> The <b>lParam</b> parameter of the message.
    LPARAM    lParam;
    ///Type: <b>CHARRANGE</b> The current selection.
    CHARRANGE chrg;
}

///Contains information about objects and text on the clipboard.
struct ENSAVECLIPBOARD
{
    ///Type: <b>NMHDR</b> NMHDR notification header.
    NMHDR nmhdr;
    ///Type: <b>LONG</b> Number of objects on the clipboard.
    int   cObjectCount;
    ///Type: <b>LONG</b> Number of characters on the clipboard.
    int   cch;
}

///Contains information about a failed operation.
struct ENOLEOPFAILED
{
    ///Type: <b>NMHDR</b> NMHDR notification header.
    NMHDR   nmhdr;
    ///Type: <b>LONG</b> Object index.
    int     iob;
    ///Type: <b>LONG</b> Operation that failed. This can be <b>OLEOP_DOVERB</b> to indicate that IOleObject::DoVerb
    ///failed.
    int     lOper;
    ///Type: <b>HRESULT</b> Error code returned by the object on the operation.
    HRESULT hr;
}

///Contains object position information.
struct OBJECTPOSITIONS
{
    ///Type: <b>NMHDR</b> The <b>code</b> member of this structure identifies the notification code being sent.
    NMHDR nmhdr;
    ///Type: <b>LONG</b> Number of object positions.
    int   cObjectCount;
    ///Type: <b>LONG*</b> The object positions.
    int*  pcpPositions;
}

///Contains information about an EN_LINK notification code from a rich edit control.
struct ENLINK
{
    ///Type: <b>NMHDR</b> The code member of this structure identifies the notification code being sent.
    NMHDR     nmhdr;
    ///Type: <b>UINT</b> Identifier of the message that caused the rich edit control to send the EN_LINK notification
    ///code.
    uint      msg;
    ///Type: <b>WPARAM</b> The <b>wParam</b> parameter of the message received by the rich edit control.
    WPARAM    wParam;
    ///Type: <b>LPARAM</b> The <b>lParam</b> parameter of the message received by the rich edit control.
    LPARAM    lParam;
    ///Type: <b>CHARRANGE</b> The range of consecutive characters in the rich edit control that have the CFE_LINK
    ///effect.
    CHARRANGE chrg;
}

///Contains information about an unsupported Rich Text Format (RTF) keyword in a Microsoft Rich Edit control.
struct ENLOWFIRTF
{
    ///Type: <b>NMHDR</b> Specifies an NMHDR structure.
    NMHDR nmhdr;
    ///Type: <b>CHAR*</b> The unsupported RTF keyword.
    byte* szControl;
}

///Contains information about the selected text to be corrected.
struct ENCORRECTTEXT
{
    ///Type: <b>NMHDR</b> An NMHDR structure. The <b>code</b> member of this structure identifies the notification code
    ///being sent.
    NMHDR     nmhdr;
    ///Type: <b>CHARRANGE</b> A CHARRANGE structure that specifies the range of selected characters.
    CHARRANGE chrg;
    ///Type: <b>WORD</b> Value specifying the contents of the new selection. This member is SEL_EMPTY if the selection
    ///is empty or one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="SEL_TEXT"></a><a id="sel_text"></a><dl> <dt><b>SEL_TEXT</b></dt> </dl> </td> <td width="60%">
    ///The new selection contains text. </td> </tr> <tr> <td width="40%"><a id="SEL_OBJECT"></a><a
    ///id="sel_object"></a><dl> <dt><b>SEL_OBJECT</b></dt> </dl> </td> <td width="60%"> The new selection contains at
    ///least one COM object. </td> </tr> <tr> <td width="40%"><a id="SEL_MULTICHAR"></a><a id="sel_multichar"></a><dl>
    ///<dt><b>SEL_MULTICHAR</b></dt> </dl> </td> <td width="60%"> The new selection contains more than one character of
    ///text. </td> </tr> <tr> <td width="40%"><a id="SEL_MULTIOBJECT"></a><a id="sel_multiobject"></a><dl>
    ///<dt><b>SEL_MULTIOBJECT</b></dt> </dl> </td> <td width="60%"> The new selection contains more than one COM object.
    ///</td> </tr> </table>
    ushort    seltyp;
}

///Contains information about the punctuation used in a rich edit control.
struct PUNCTUATION
{
    ///Type: <b>UINT</b> Size of buffer pointed to by the <b>szPunctuation</b> member, in bytes.
    uint iSize;
    ///Type: <b>LPSTR</b> The buffer containing the punctuation characters.
    PSTR szPunctuation;
}

///Contains color settings for a composition string.
struct COMPCOLOR
{
    ///Type: <b>COLORREF</b> Color of text. To generate a COLORREF, use the RGB macro.
    uint crText;
    ///Type: <b>COLORREF</b> Color of background. To generate a COLORREF, use the RGB macro.
    uint crBackground;
    ///Type: <b>DWORD</b> Character effect values as described for the <b>dwEffects</b> member in the CHARFORMAT
    ///structure.
    uint dwEffects;
}

///Contains information identifying whether the display aspect of a pasted object should be based on the content of the
///object or the icon that represent the object.
struct REPASTESPECIAL
{
    ///Type: <b>DWORD</b> Display aspect. It can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="DVASPECT_CONTENT"></a><a id="dvaspect_content"></a><dl>
    ///<dt><b>DVASPECT_CONTENT</b></dt> </dl> </td> <td width="60%"> Aspect is based on the content of the object. </td>
    ///</tr> <tr> <td width="40%"><a id="DVASPECT_ICON"></a><a id="dvaspect_icon"></a><dl> <dt><b>DVASPECT_ICON</b></dt>
    ///</dl> </td> <td width="60%"> Aspect is based on the icon view of the object. </td> </tr> </table>
    uint   dwAspect;
    ///Type: <b>DWORD_PTR</b> Type: <b>DWORD</b> Aspect data. If <b>dwAspect</b> is DVASPECT_ICON, this member contains
    ///the handle to the metafile with the icon view of the object.
    size_t dwParam;
}

///Specifies which code page (if any) to use in setting text, whether the text replaces all the text in the control or
///just the selection, and whether the undo state is to be preserved. This structure is used with the EM_SETTEXTEX
///message.
struct SETTEXTEX
{
    ///Type: <b>DWORD</b> Option flags. It can be any reasonable combination of the following flags. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ST_DEFAULT"></a><a id="st_default"></a><dl>
    ///<dt><b>ST_DEFAULT</b></dt> </dl> </td> <td width="60%"> Deletes the undo stack, discards rich-text formatting,
    ///replaces all text. </td> </tr> <tr> <td width="40%"><a id="ST_KEEPUNDO"></a><a id="st_keepundo"></a><dl>
    ///<dt><b>ST_KEEPUNDO</b></dt> </dl> </td> <td width="60%"> Keeps the undo stack. </td> </tr> <tr> <td
    ///width="40%"><a id="ST_SELECTION"></a><a id="st_selection"></a><dl> <dt><b>ST_SELECTION</b></dt> </dl> </td> <td
    ///width="60%"> Replaces selection and keeps rich-text formatting. </td> </tr> <tr> <td width="40%"><a
    ///id="ST_NEWCHARS"></a><a id="st_newchars"></a><dl> <dt><b>ST_NEWCHARS</b></dt> </dl> </td> <td width="60%"> Act as
    ///if new characters are being entered. </td> </tr> <tr> <td width="40%"><a id="ST_UNICODE"></a><a
    ///id="st_unicode"></a><dl> <dt><b>ST_UNICODE</b></dt> </dl> </td> <td width="60%"> The text is UTF-16 (the
    ///<b>WCHAR</b> data type). </td> </tr> </table>
    uint flags;
    ///Type: <b>UINT</b> The code page used to translate the text to Unicode. If <b>codepage</b> is 1200 (Unicode code
    ///page), no translation is done. If <b>codepage</b> is CP_ACP, the system code page is used.
    uint codepage;
}

///Contains information used in getting text from a rich edit control. This structure used with the EM_GETTEXTEX
///message.
struct GETTEXTEX
{
    ///Type: <b>DWORD</b> The size, in bytes, of the buffer used to store the retrieved text.
    uint        cb;
    ///Type: <b>DWORD</b> Value specifying a text operation. This member can be one of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="GT_DEFAULT"></a><a
    ///id="gt_default"></a><dl> <dt><b>GT_DEFAULT</b></dt> </dl> </td> <td width="60%"> All text is retrieved according
    ///to the following criteria: <ul> <li>Carriage returns (U+000D) are not translated into CRLF (U+000D U+000A).</li>
    ///<li>Table and math-object structure characters are removed (see <b>GT_RAWTEXT</b>).</li> <li>Hidden text is
    ///included. </li> <li>List numbers are not included. </li> </ul> </td> </tr> <tr> <td width="40%"><a
    ///id="GT_NOHIDDENTEXT"></a><a id="gt_nohiddentext"></a><dl> <dt><b>GT_NOHIDDENTEXT</b></dt> </dl> </td> <td
    ///width="60%"> Hidden text is not included in the retrieved text. </td> </tr> <tr> <td width="40%"><a
    ///id="GT_RAWTEXT"></a><a id="gt_rawtext"></a><dl> <dt><b>GT_RAWTEXT</b></dt> </dl> </td> <td width="60%"> Text is
    ///retrieved exactly as it appears in memory. This includes special structure characters for table row and cell
    ///delimiters (see Remarks for EM_INSERTTABLE) as well as math object delimiters (start delimiter U+FDD0, argument
    ///delimiter U+FDEE, and end delimiter U+FDDF) and object markers (U+FFFC). This maintains character-position
    ///alignment between the retrieved text and the text in memory. </td> </tr> <tr> <td width="40%"><a
    ///id="GT_SELECTION"></a><a id="gt_selection"></a><dl> <dt><b>GT_SELECTION</b></dt> </dl> </td> <td width="60%">
    ///Retrieve the text for the current selection. </td> </tr> <tr> <td width="40%"><a id="GT_USECRLF"></a><a
    ///id="gt_usecrlf"></a><dl> <dt><b>GT_USECRLF</b></dt> </dl> </td> <td width="60%"> When copying text, translate
    ///each CR into a CR/LF. </td> </tr> </table>
    uint        flags;
    ///Type: <b>UINT</b> Code page used in the translation. It is <b>CP_ACP</b> for ANSI code page and 1200 for Unicode.
    uint        codepage;
    ///Type: <b>LPCSTR</b> The character used if a wide character cannot be represented in the specified code page. It
    ///is used only if the code page is <b>not</b> 1200 (Unicode). If this member is <b>NULL</b>, a system default value
    ///is used.
    const(PSTR) lpDefaultChar;
    ///Type: <b>LPBOOL</b> A flag that indicates whether the default character (<b>lpDefaultChar</b>) was used. This
    ///member is used only if the code page is not 1200 or <b>CP_UTF8</b> (Unicode). The flag is <b>TRUE</b> if one or
    ///more wide characters in the source string cannot be represented in the specified code page. Otherwise, the flag
    ///is <b>FALSE</b>. This member can be NULL.
    int*        lpUsedDefChar;
}

///Contains information about how the text length of a rich edit control should be calculated. This structure is passed
///in the <b>wParam</b> in the EM_GETTEXTLENGTHEX message.
struct GETTEXTLENGTHEX
{
    ///Type: <b>DWORD</b> Value specifying the method to be used in determining the text length. This member can be one
    ///or more of the following values (some values are mutually exclusive). <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="GTL_DEFAULT"></a><a id="gtl_default"></a><dl>
    ///<dt><b>GTL_DEFAULT</b></dt> </dl> </td> <td width="60%"> Returns the number of characters. This is the default.
    ///</td> </tr> <tr> <td width="40%"><a id="GTL_USECRLF"></a><a id="gtl_usecrlf"></a><dl> <dt><b>GTL_USECRLF</b></dt>
    ///</dl> </td> <td width="60%"> Computes the answer by using CR/LFs at the end of paragraphs. </td> </tr> <tr> <td
    ///width="40%"><a id="GTL_PRECISE"></a><a id="gtl_precise"></a><dl> <dt><b>GTL_PRECISE</b></dt> </dl> </td> <td
    ///width="60%"> Computes a precise answer. This approach could necessitate a conversion and thereby take longer.
    ///This flag cannot be used with the GTL_CLOSE flag. E_INVALIDARG will be returned if both are used. </td> </tr>
    ///<tr> <td width="40%"><a id="GTL_CLOSE"></a><a id="gtl_close"></a><dl> <dt><b>GTL_CLOSE</b></dt> </dl> </td> <td
    ///width="60%"> Computes an approximate (close) answer. It is obtained quickly and can be used to set the buffer
    ///size. This flag cannot be used with the GTL_PRECISE flag. E_INVALIDARG will be returned if both are used. </td>
    ///</tr> <tr> <td width="40%"><a id="GTL_NUMCHARS"></a><a id="gtl_numchars"></a><dl> <dt><b>GTL_NUMCHARS</b></dt>
    ///</dl> </td> <td width="60%"> Returns the number of characters. This flag cannot be used with the GTL_NUMBYTES
    ///flag. E_INVALIDARG will be returned if both are used. </td> </tr> <tr> <td width="40%"><a
    ///id="GTL_NUMBYTES"></a><a id="gtl_numbytes"></a><dl> <dt><b>GTL_NUMBYTES</b></dt> </dl> </td> <td width="60%">
    ///Returns the number of bytes. This flag cannot be used with the GTL_NUMCHARS flag. E_INVALIDARG will be returned
    ///if both are used. </td> </tr> </table>
    uint flags;
    ///Type: <b>UINT</b> Code page used in the translation. It is CP_ACP for ANSI Code Page and 1200 for Unicode.
    uint codepage;
}

///Contains bidirectional information about a rich edit control. This structure is used by the EM_GETBIDIOPTIONS and
///EM_SETBIDIOPTIONS messages to get and set the bidirectional information for a control.
struct BIDIOPTIONS
{
    ///Type: <b>UINT</b> Specifies the size, in bytes, of the structure. Before passing this structure to a rich edit
    ///control, set <b>cbSize</b> to the size of the <b>BIDIOPTIONS</b> structure. The rich edit control checks the size
    ///of <b>cbSize</b> before sending an EM_GETBIDIOPTIONS message.
    uint   cbSize;
    ///Type: <b>WORD</b> A set of mask bits that determine which of the <b>wEffects</b> flags will be set to 1 or 0 by
    ///the rich edit control. This approach eliminates the need to read the effects flags before changing them. Obsolete
    ///bits are valid only for the bidirectional version of Rich Edit 1.0. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="BOM_CONTEXTALIGNMENT"></a><a id="bom_contextalignment"></a><dl>
    ///<dt><b>BOM_CONTEXTALIGNMENT</b></dt> </dl> </td> <td width="60%"> The BOE_CONTEXTALIGNMENT value is valid. </td>
    ///</tr> <tr> <td width="40%"><a id="BOM_CONTEXTREADING"></a><a id="bom_contextreading"></a><dl>
    ///<dt><b>BOM_CONTEXTREADING</b></dt> </dl> </td> <td width="60%"> The BOE_CONTEXTREADING value is valid. </td>
    ///</tr> <tr> <td width="40%"><a id="BOM_DEFPARADIR"></a><a id="bom_defparadir"></a><dl>
    ///<dt><b>BOM_DEFPARADIR</b></dt> </dl> </td> <td width="60%"> The BOE_RTLDIR value is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="BOM_LEGACYBIDICLASS"></a><a id="bom_legacybidiclass"></a><dl>
    ///<dt><b>BOM_LEGACYBIDICLASS</b></dt> </dl> </td> <td width="60%"> The BOE_LEGACYBIDICLASS value is valid. </td>
    ///</tr> <tr> <td width="40%"><a id="BOM_NEUTRALOVERRIDE"></a><a id="bom_neutraloverride"></a><dl>
    ///<dt><b>BOM_NEUTRALOVERRIDE</b></dt> </dl> </td> <td width="60%"> The BOE_NEUTRALOVERRIDE value is valid. </td>
    ///</tr> <tr> <td width="40%"><a id="BOM_PLAINTEXT"></a><a id="bom_plaintext"></a><dl> <dt><b>BOM_PLAINTEXT</b></dt>
    ///</dl> </td> <td width="60%"> The BOE_PLAINTEXT value is valid. (obsolete). </td> </tr> <tr> <td width="40%"><a
    ///id="BOM_UNICODEBIDI"></a><a id="bom_unicodebidi"></a><dl> <dt><b>BOM_UNICODEBIDI</b></dt> </dl> </td> <td
    ///width="60%"> The BOE_UNICODEBIDI value is valid. </td> </tr> </table>
    ushort wMask;
    ///Type: <b>WORD</b> A set of flags that indicate the desired or current state of the effects flags. Obsolete bits
    ///are valid only for the bidirectional version of Rich Edit 1.0. Obsolete bits are valid only for the bidirectional
    ///version of Rich Edit 1.0. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="BOE_CONTEXTALIGNMENT"></a><a id="boe_contextalignment"></a><dl> <dt><b>BOE_CONTEXTALIGNMENT</b></dt> </dl>
    ///</td> <td width="60%"> If this flag is 1, context paragraph alignment is active. This feature is used only for
    ///plain-text controls. When active, the paragraph alignment is set to PFA_LEFT if the first strongly directional
    ///character is LTR, or PFA_RIGHT if the first strongly directional character is RTL. If the control has no strongly
    ///directional character, the alignment is chosen according to the directionality of the keyboard language when the
    ///control regains focus (default: 0). </td> </tr> <tr> <td width="40%"><a id="BOE_CONTEXTREADING"></a><a
    ///id="boe_contextreading"></a><dl> <dt><b>BOE_CONTEXTREADING</b></dt> </dl> </td> <td width="60%"> If this flag is
    ///1, context paragraph directionality is active. This feature is used only for plain-text controls. When active,
    ///the paragraph directionality effect PFE_RTLPARA is set to 0 if the first strongly directional character is LTR,
    ///or 1 if the first strongly directional character is RTL. If the control has no strongly directional character,
    ///the directionality is chosen according to the directionality of the keyboard language when the control regains
    ///focus (default: 0). </td> </tr> <tr> <td width="40%"><a id="BOE_FORCERECALC"></a><a id="boe_forcerecalc"></a><dl>
    ///<dt><b>BOE_FORCERECALC</b></dt> </dl> </td> <td width="60%"> <b>Windows 8</b>: Force the rich edit control to
    ///recalculate the bidirectional information, and then redraw the control. </td> </tr> <tr> <td width="40%"><a
    ///id="BOE_LEGACYBIDICLASS"></a><a id="boe_legacybidiclass"></a><dl> <dt><b>BOE_LEGACYBIDICLASS</b></dt> </dl> </td>
    ///<td width="60%"> Causes the plus and minus characters to be treated as neutral characters with no implied
    ///direction. Also causes the slash character to be treated as a common separator. </td> </tr> <tr> <td
    ///width="40%"><a id="BOE_NEUTRALOVERRIDE"></a><a id="boe_neutraloverride"></a><dl>
    ///<dt><b>BOE_NEUTRALOVERRIDE</b></dt> </dl> </td> <td width="60%"> If this flag is 1, the characters !"
    ushort wEffects;
}

///Contains information about the result of hyphenation in a Microsoft Rich Edit control.
struct hyphresult
{
    ///Type: <b>KHYPH</b> The type of hyphenation.
    KHYPH  khyph;
    ///Type: <b>LONG</b> The index of the WCHAR in the passed string where hyphenation occurred.
    int    ichHyph;
    ///Type: <b>WCHAR</b> The character used when hyphenation requires a replacement or an addition or a change. If no
    ///new character is needed, the value is zero.
    ushort chHyph;
}

///Contains information about hyphenation in a Microsoft Rich Edit control.
struct HYPHENATEINFO
{
    ///Type: <b>SHORT</b> Size of the <b>HYPHENATEINFO</b> structure, in bytes.
    short     cbSize;
    ///Type: <b>SHORT</b> Size, in TWIPS (one TWIP is 1/1440 inch), of the area near the margin that excludes
    ///hyphenation. If a space character is closer to the margin than this value, do not hyphenate the following word.
    short     dxHyphenateZone;
    ///Type: <b>PFNHYPHENATEPROC</b> The client-defined HyphenateProc callback function.
    ptrdiff_t pfnHyphenate;
}

///Contains information about an OLE or image object in a rich edit control.
struct REOBJECT
{
    ///Type: <b>DWORD</b> Structure size, in bytes.
    uint           cbStruct;
    ///Type: <b>LONG</b> Character position of the object.
    int            cp;
    ///Type: <b>CLSID</b> Class identifier of the object.
    GUID           clsid;
    ///Type: <b>LPOLEOBJECT</b> An instance of the IOleObject interface for the object.
    IOleObject     poleobj;
    ///Type: <b>LPSTORAGE</b> An instance of the IStorage interface. This is the storage object associated with the
    ///object.
    IStorage       pstg;
    ///Type: <b>LPOLECLIENTSITE</b> An instance of the IOleClientSite interface. This is the object's client site in the
    ///rich edit control. This address must have been obtained from the GetClientSite method.
    IOleClientSite polesite;
    ///Type: <b>SIZEL</b> The size of the object. The unit of measure is 0.01 millimeters, which is a HIMETRIC
    ///measurement. For more information, see function GetMapMode. A 0, 0 on insertion indicates that an object is free
    ///to determine its size until the modify flag is turned off.
    SIZE           sizel;
    ///Type: <b>DWORD</b> Display aspect used. See DVASPECT for an explanation of possible values.
    uint           dvaspect;
    ///Type: <b>DWORD</b> Object status flag. It can be a combination of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="REO_ALIGNTORIGHT"></a><a
    ///id="reo_aligntoright"></a><dl> <dt><b>REO_ALIGNTORIGHT</b></dt> </dl> </td> <td width="60%"> Align the object
    ///with the right side of the view. This value is ignored if REO_WRAPTEXTAROUND is not specified. </td> </tr> <tr>
    ///<td width="40%"><a id="REO_BELOWBASELINE"></a><a id="reo_belowbaseline"></a><dl>
    ///<dt><b>REO_BELOWBASELINE</b></dt> </dl> </td> <td width="60%"> The object sits below the baseline of the
    ///surrounding text; the default is to sit on the baseline. </td> </tr> <tr> <td width="40%"><a
    ///id="REO_BLANK"></a><a id="reo_blank"></a><dl> <dt><b>REO_BLANK</b></dt> </dl> </td> <td width="60%"> The object
    ///is new. This value gives the object an opportunity to save nothing and be deleted from the control automatically.
    ///</td> </tr> <tr> <td width="40%"><a id="REO_CANROTATE"></a><a id="reo_canrotate"></a><dl>
    ///<dt><b>REO_CANROTATE</b></dt> </dl> </td> <td width="60%"> The object can display itself in a rotated position.
    ///</td> </tr> <tr> <td width="40%"><a id="REO_DONTNEEDPALETTE"></a><a id="reo_dontneedpalette"></a><dl>
    ///<dt><b>REO_DONTNEEDPALETTE</b></dt> </dl> </td> <td width="60%"> The object is rendered before the creation and
    ///realization of a half-tone palette. Applies to 32-bit platforms only. </td> </tr> <tr> <td width="40%"><a
    ///id="REO_DYNAMICSIZE"></a><a id="reo_dynamicsize"></a><dl> <dt><b>REO_DYNAMICSIZE</b></dt> </dl> </td> <td
    ///width="60%"> The object always determines its extents and may change despite the modify flag being turned off.
    ///</td> </tr> <tr> <td width="40%"><a id="REO_GETMETAFILE"></a><a id="reo_getmetafile"></a><dl>
    ///<dt><b>REO_GETMETAFILE</b></dt> </dl> </td> <td width="60%"> The rich edit control retrieved the metafile from
    ///the object to correctly determine the object's extents. This flag can be read but not set. </td> </tr> <tr> <td
    ///width="40%"><a id="REO_HILITED"></a><a id="reo_hilited"></a><dl> <dt><b>REO_HILITED</b></dt> </dl> </td> <td
    ///width="60%"> The object is currently highlighted to indicate selection. Occurs when focus is in the control and
    ///<b>REO_SELECTED</b> is set. This flag can be read but not set. </td> </tr> <tr> <td width="40%"><a
    ///id="REO_INPLACEACTIVE"></a><a id="reo_inplaceactive"></a><dl> <dt><b>REO_INPLACEACTIVE</b></dt> </dl> </td> <td
    ///width="60%"> The object is currently inplace active. This flag can be read but not set. </td> </tr> <tr> <td
    ///width="40%"><a id="REO_INVERTEDSELECT"></a><a id="reo_invertedselect"></a><dl> <dt><b>REO_INVERTEDSELECT</b></dt>
    ///</dl> </td> <td width="60%"> The object is to be drawn entirely inverted when selected; the default is to be
    ///drawn with a border. </td> </tr> <tr> <td width="40%"><a id="REO_LINK"></a><a id="reo_link"></a><dl>
    ///<dt><b>REO_LINK</b></dt> </dl> </td> <td width="60%"> The object is a link. This flag can be read but not set.
    ///</td> </tr> <tr> <td width="40%"><a id="REO_LINKAVAILABLE"></a><a id="reo_linkavailable"></a><dl>
    ///<dt><b>REO_LINKAVAILABLE</b></dt> </dl> </td> <td width="60%"> The object is a link and is believed to be
    ///available. This flag can be read but not set. </td> </tr> <tr> <td width="40%"><a id="REO_OPEN"></a><a
    ///id="reo_open"></a><dl> <dt><b>REO_OPEN</b></dt> </dl> </td> <td width="60%"> The object is currently open in its
    ///server. This flag can be read but not set. </td> </tr> <tr> <td width="40%"><a id="REO_OWNERDRAWSELECT"></a><a
    ///id="reo_ownerdrawselect"></a><dl> <dt><b>REO_OWNERDRAWSELECT</b></dt> </dl> </td> <td width="60%"> The owner
    ///draws the selected object. </td> </tr> <tr> <td width="40%"><a id="REO_RESIZABLE"></a><a
    ///id="reo_resizable"></a><dl> <dt><b>REO_RESIZABLE</b></dt> </dl> </td> <td width="60%"> The object may be resized.
    ///</td> </tr> <tr> <td width="40%"><a id="REO_SELECTED"></a><a id="reo_selected"></a><dl>
    ///<dt><b>REO_SELECTED</b></dt> </dl> </td> <td width="60%"> The object is currently selected in the rich edit
    ///control. This flag can be read but not set. </td> </tr> <tr> <td width="40%"><a id="REO_STATIC"></a><a
    ///id="reo_static"></a><dl> <dt><b>REO_STATIC</b></dt> </dl> </td> <td width="60%"> The object is a static object.
    ///This flag can be read but not set. </td> </tr> <tr> <td width="40%"><a id="REO_USEASBACKGROUND"></a><a
    ///id="reo_useasbackground"></a><dl> <dt><b>REO_USEASBACKGROUND</b></dt> </dl> </td> <td width="60%"> Use the object
    ///as the background picture. </td> </tr> <tr> <td width="40%"><a id="REO_WRAPTEXTAROUND"></a><a
    ///id="reo_wraptextaround"></a><dl> <dt><b>REO_WRAPTEXTAROUND</b></dt> </dl> </td> <td width="60%"> Wrap text around
    ///the object. </td> </tr> </table>
    uint           dwFlags;
    ///Type: <b>DWORD</b> Reserved for user-defined values.
    uint           dwUser;
}

///Contains information that is associated with an EN_CHANGE notification code. A windowless rich edit control sends
///this notification to its host window when the content of the control changes.
struct CHANGENOTIFY
{
    ///The type of change that occurred. It can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="CN_GENERIC"></a><a id="cn_generic"></a><dl>
    ///<dt><b>CN_GENERIC</b></dt> </dl> </td> <td width="60%"> No significant change occurred. </td> </tr> <tr> <td
    ///width="40%"><a id="CN_NEWREDO"></a><a id="cn_newredo"></a><dl> <dt><b>CN_NEWREDO</b></dt> </dl> </td> <td
    ///width="60%"> A new redo action was added. </td> </tr> <tr> <td width="40%"><a id="CN_NEWUNDO"></a><a
    ///id="cn_newundo"></a><dl> <dt><b>CN_NEWUNDO</b></dt> </dl> </td> <td width="60%"> A new undo action was added.
    ///</td> </tr> <tr> <td width="40%"><a id="CN_TEXTCHANGED"></a><a id="cn_textchanged"></a><dl>
    ///<dt><b>CN_TEXTCHANGED</b></dt> </dl> </td> <td width="60%"> The text changed. </td> </tr> </table>
    uint  dwChangeType;
    ///Cookie for the undo action that is associated with the change.
    void* pvCookieData;
}

union CARET_INFO
{
    HBITMAP     hbitmap;
    CARET_FLAGS caretFlags;
}

struct TA_TRANSFORM
{
    TA_TRANSFORM_TYPE eTransformType;
    uint              dwTimingFunctionId;
    uint              dwStartTime;
    uint              dwDurationTime;
    TA_TRANSFORM_FLAG eFlags;
}

struct TA_TRANSFORM_2D
{
    TA_TRANSFORM header;
    float        rX;
    float        rY;
    float        rInitialX;
    float        rInitialY;
    float        rOriginX;
    float        rOriginY;
}

struct TA_TRANSFORM_OPACITY
{
    TA_TRANSFORM header;
    float        rOpacity;
    float        rInitialOpacity;
}

struct TA_TRANSFORM_CLIP
{
    TA_TRANSFORM header;
    float        rLeft;
    float        rTop;
    float        rRight;
    float        rBottom;
    float        rInitialLeft;
    float        rInitialTop;
    float        rInitialRight;
    float        rInitialBottom;
}

struct TA_TIMINGFUNCTION
{
    TA_TIMINGFUNCTION_TYPE eTimingFunctionType;
}

struct TA_CUBIC_BEZIER
{
    TA_TIMINGFUNCTION header;
    float             rX0;
    float             rY0;
    float             rX1;
    float             rY1;
}

///Defines the options for the DrawThemeBackgroundEx function.
struct DTBGOPTS
{
    ///Type: <b>DWORD</b> Size of the structure. Set this to sizeof(DTBGOPTS).
    uint dwSize;
    ///Type: <b>DWORD</b> Flags that specify the selected options. This member can be one of the following: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DTBG_CLIPRECT"></a><a
    ///id="dtbg_cliprect"></a><dl> <dt><b>DTBG_CLIPRECT</b></dt> </dl> </td> <td width="60%"> <b>rcClip</b> specifies
    ///the rectangle to which drawing is clipped. </td> </tr> <tr> <td width="40%"><a id="DTBG_DRAWSOLID"></a><a
    ///id="dtbg_drawsolid"></a><dl> <dt><b>DTBG_DRAWSOLID</b></dt> </dl> </td> <td width="60%"> Deprecated. Draw
    ///transparent and alpha images as solid. </td> </tr> <tr> <td width="40%"><a id="DTBG_OMITBORDER"></a><a
    ///id="dtbg_omitborder"></a><dl> <dt><b>DTBG_OMITBORDER</b></dt> </dl> </td> <td width="60%"> Do not draw the border
    ///of the part (currently this value is only supported for bgtype=borderfill). </td> </tr> <tr> <td width="40%"><a
    ///id="DTBG_OMITCONTENT"></a><a id="dtbg_omitcontent"></a><dl> <dt><b>DTBG_OMITCONTENT</b></dt> </dl> </td> <td
    ///width="60%"> Do not draw the content area of the part (currently this value is only supported for
    ///bgtype=borderfill). </td> </tr> <tr> <td width="40%"><a id="DTBG_COMPUTINGREGION"></a><a
    ///id="dtbg_computingregion"></a><dl> <dt><b>DTBG_COMPUTINGREGION</b></dt> </dl> </td> <td width="60%"> Deprecated.
    ///</td> </tr> <tr> <td width="40%"><a id="DTBG_MIRRORDC"></a><a id="dtbg_mirrordc"></a><dl>
    ///<dt><b>DTBG_MIRRORDC</b></dt> </dl> </td> <td width="60%"> Assume the <b>hdc</b> is mirrored and flip images as
    ///appropriate (currently this value is only supported for bgtype=imagefile). </td> </tr> <tr> <td width="40%"><a
    ///id="DTBG_NOMIRROR"></a><a id="dtbg_nomirror"></a><dl> <dt><b>DTBG_NOMIRROR</b></dt> </dl> </td> <td width="60%">
    ///Do not mirror the output; even in right-to-left (RTL) layout. </td> </tr> <tr> <td width="40%"><a
    ///id="DTBG_VALIDBITS"></a><a id="dtbg_validbits"></a><dl> <dt><b>DTBG_VALIDBITS</b></dt> </dl> </td> <td
    ///width="60%"> DTBG_CLIPRECT | DTBG_DRAWSOLID | DTBG_OMITBORDER | DTBG_OMITCONTENT | DTBG_COMPUTINGREGION |
    ///DTBG_MIRRORDC | DTBG_NOMIRROR. </td> </tr> </table>
    uint dwFlags;
    ///Type: <b>RECT</b> A RECT that specifies the bounding rectangle of the clip region.
    RECT rcClip;
}

///Returned by the GetThemeMargins function to define the margins of windows that have visual styles applied.
struct MARGINS
{
    ///Type: <b>int</b> Width of the left border that retains its size.
    int cxLeftWidth;
    ///Type: <b>int</b> Width of the right border that retains its size.
    int cxRightWidth;
    ///Type: <b>int</b> Height of the top border that retains its size.
    int cyTopHeight;
    ///Type: <b>int</b> Height of the bottom border that retains its size.
    int cyBottomHeight;
}

///Contains an array or list of <b>int</b> data items from a visual style.
struct INTLIST
{
    ///Type: <b>int</b> Number of values in the list.
    int      iValueCount;
    ///Type: <b>int[MAX_INTLIST_COUNT]</b> List of integers. The constant MAX_INTLIST_COUNT, by definition, is equal to
    ///402 under Windows Vista, but only 10 under earlier versions of Windows.
    int[402] iValues;
}

///Defines options that are used to set window visual style attributes.
struct WTA_OPTIONS
{
    ///Type: <b>DWORD</b> A combination of flags that modify window visual style attributes. Can be a combination of the
    ///WTNCA constants.
    uint dwFlags;
    ///Type: <b>DWORD</b> A bitmask that describes how the values specified in <b>dwFlags</b> should be applied. If the
    ///bit corresponding to a value in <b>dwFlags</b> is 0, that flag will be removed. If the bit is 1, the flag will be
    ///added.
    uint dwMask;
}

///Defines the options for the DrawThemeTextEx function.
struct DTTOPTS
{
    ///Type: <b>DWORD</b> Size of the structure.
    uint              dwSize;
    ///Type: <b>DWORD</b> A combination of flags that specify whether certain values of the <b>DTTOPTS</b> structure
    ///have been specified, and how to interpret these values. This member can be a combination of the following.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DTT_TEXTCOLOR"></a><a
    ///id="dtt_textcolor"></a><dl> <dt><b>DTT_TEXTCOLOR</b></dt> </dl> </td> <td width="60%"> The <b>crText</b> member
    ///value is valid. </td> </tr> <tr> <td width="40%"><a id="DTT_BORDERCOLOR"></a><a id="dtt_bordercolor"></a><dl>
    ///<dt><b>DTT_BORDERCOLOR</b></dt> </dl> </td> <td width="60%"> The <b>crBorder</b> member value is valid. </td>
    ///</tr> <tr> <td width="40%"><a id="DTT_SHADOWCOLOR"></a><a id="dtt_shadowcolor"></a><dl>
    ///<dt><b>DTT_SHADOWCOLOR</b></dt> </dl> </td> <td width="60%"> The <b>crShadow</b> member value is valid. </td>
    ///</tr> <tr> <td width="40%"><a id="DTT_SHADOWTYPE"></a><a id="dtt_shadowtype"></a><dl>
    ///<dt><b>DTT_SHADOWTYPE</b></dt> </dl> </td> <td width="60%"> The <b>iTextShadowType</b> member value is valid.
    ///</td> </tr> <tr> <td width="40%"><a id="DTT_SHADOWOFFSET"></a><a id="dtt_shadowoffset"></a><dl>
    ///<dt><b>DTT_SHADOWOFFSET</b></dt> </dl> </td> <td width="60%"> The <b>ptShadowOffset</b> member value is valid.
    ///</td> </tr> <tr> <td width="40%"><a id="DTT_BORDERSIZE"></a><a id="dtt_bordersize"></a><dl>
    ///<dt><b>DTT_BORDERSIZE</b></dt> </dl> </td> <td width="60%"> The <b>iBorderSize</b> member value is valid. </td>
    ///</tr> <tr> <td width="40%"><a id="DTT_FONTPROP"></a><a id="dtt_fontprop"></a><dl> <dt><b>DTT_FONTPROP</b></dt>
    ///</dl> </td> <td width="60%"> The <b>iFontPropId</b> member value is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="DTT_COLORPROP"></a><a id="dtt_colorprop"></a><dl> <dt><b>DTT_COLORPROP</b></dt> </dl> </td> <td width="60%">
    ///The <b>iColorPropId</b> member value is valid. </td> </tr> <tr> <td width="40%"><a id="DTT_STATEID"></a><a
    ///id="dtt_stateid"></a><dl> <dt><b>DTT_STATEID</b></dt> </dl> </td> <td width="60%"> The <b>iStateId</b> member
    ///value is valid. </td> </tr> <tr> <td width="40%"><a id="DTT_CALCRECT"></a><a id="dtt_calcrect"></a><dl>
    ///<dt><b>DTT_CALCRECT</b></dt> </dl> </td> <td width="60%"> The <i>pRect</i> parameter of the DrawThemeTextEx
    ///function that uses this structure will be used as both an in and an out parameter. After the function returns,
    ///the <i>pRect</i> parameter will contain the rectangle that corresponds to the region calculated to be drawn.
    ///</td> </tr> <tr> <td width="40%"><a id="DTT_APPLYOVERLAY"></a><a id="dtt_applyoverlay"></a><dl>
    ///<dt><b>DTT_APPLYOVERLAY</b></dt> </dl> </td> <td width="60%"> The <b>fApplyOverlay</b> member value is valid.
    ///</td> </tr> <tr> <td width="40%"><a id="DTT_GLOWSIZE"></a><a id="dtt_glowsize"></a><dl>
    ///<dt><b>DTT_GLOWSIZE</b></dt> </dl> </td> <td width="60%"> The <b>iGlowSize</b> member value is valid. </td> </tr>
    ///<tr> <td width="40%"><a id="DTT_CALLBACK"></a><a id="dtt_callback"></a><dl> <dt><b>DTT_CALLBACK</b></dt> </dl>
    ///</td> <td width="60%"> The <b>pfnDrawTextCallback</b> member value is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="DTT_COMPOSITED"></a><a id="dtt_composited"></a><dl> <dt><b>DTT_COMPOSITED</b></dt> </dl> </td> <td
    ///width="60%"> Draws text with antialiased alpha. Use of this flag requires a top-down DIB section. This flag works
    ///only if the HDC passed to function DrawThemeTextEx has a top-down DIB section currently selected in it. For more
    ///information, see Device-Independent Bitmaps. </td> </tr> <tr> <td width="40%"><a id="DTT_VALIDBITS"></a><a
    ///id="dtt_validbits"></a><dl> <dt><b>DTT_VALIDBITS</b></dt> </dl> </td> <td width="60%"> DTT_TEXTCOLOR |
    ///DTT_BORDERCOLOR | DTT_SHADOWCOLOR | DTT_SHADOWTYPE | DTT_SHADOWOFFSET | DTT_BORDERSIZE | DTT_FONTPROP |
    ///DTT_COLORPROP | DTT_STATEID | DTT_CALCRECT | DTT_APPLYOVERLAY | DTT_GLOWSIZE | DTT_COMPOSITED. </td> </tr>
    ///</table>
    uint              dwFlags;
    ///Type: <b>COLORREF</b> Specifies the color of the text that will be drawn.
    uint              crText;
    ///Type: <b>COLORREF</b> Specifies the color of the outline that will be drawn around the text.
    uint              crBorder;
    ///Type: <b>COLORREF</b> Specifies the color of the shadow that will be drawn behind the text.
    uint              crShadow;
    ///Type: <b>int</b> Specifies the type of the shadow that will be drawn behind the text. This member can have one of
    ///the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TST_NONE"></a><a id="tst_none"></a><dl> <dt><b>TST_NONE</b></dt> </dl> </td> <td width="60%"> No shadow will
    ///be drawn. </td> </tr> <tr> <td width="40%"><a id="TST_SINGLE"></a><a id="tst_single"></a><dl>
    ///<dt><b>TST_SINGLE</b></dt> </dl> </td> <td width="60%"> The shadow will be drawn to appear detailed underneath
    ///text. </td> </tr> <tr> <td width="40%"><a id="TST_CONTINUOUS"></a><a id="tst_continuous"></a><dl>
    ///<dt><b>TST_CONTINUOUS</b></dt> </dl> </td> <td width="60%"> The shadow will be drawn to appear blurred underneath
    ///text. </td> </tr> </table>
    int               iTextShadowType;
    ///Type: <b>POINT</b> Specifies the amount of offset, in logical coordinates, between the shadow and the text.
    POINT             ptShadowOffset;
    ///Type: <b>int</b> Specifies the radius of the outline that will be drawn around the text.
    int               iBorderSize;
    ///Type: <b>int</b> Specifies an alternate font property to use when drawing text. For a list of possible values,
    ///see GetThemeSysFont.
    int               iFontPropId;
    ///Type: <b>int</b> Specifies an alternate color property to use when drawing text. If this value is valid and the
    ///corresponding flag is set in <b>dwFlags</b>, this value will override the value of <b>crText</b>. See the values
    ///listed in GetSysColor for the <i>nIndex</i> parameter.
    int               iColorPropId;
    ///Type: <b>int</b> Specifies an alternate state to use. This member is not used by DrawThemeTextEx.
    int               iStateId;
    ///Type: <b>BOOL</b> If <b>TRUE</b>, text will be drawn on top of the shadow and outline effects. If <b>FALSE</b>,
    ///just the shadow and outline effects will be drawn.
    BOOL              fApplyOverlay;
    ///Type: <b>int</b> Specifies the size of a glow that will be drawn on the background prior to any text being drawn.
    int               iGlowSize;
    ///Type: <b>DTT_CALLBACK_PROC</b> Pointer to callback function for DrawThemeTextEx.
    DTT_CALLBACK_PROC pfnDrawTextCallback;
    LPARAM            lParam;
}

///Defines animation parameters for the BP_PAINTPARAMS structure used by BeginBufferedPaint.
struct BP_ANIMATIONPARAMS
{
    ///Type: <b>DWORD</b> The size, in bytes, of this structure.
    uint              cbSize;
    ///Type: <b>DWORD</b> Reserved.
    uint              dwFlags;
    ///Type: <b>BP_ANIMATIONSTYLE</b> Animation style.
    BP_ANIMATIONSTYLE style;
    uint              dwDuration;
}

///Defines paint operation parameters for BeginBufferedPaint.
struct BP_PAINTPARAMS
{
    ///Type: <b>DWORD</b> The size, in bytes, of this structure.
    uint         cbSize;
    ///Type: <b>DWORD</b> One or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="BPPF_ERASE"></a><a id="bppf_erase"></a><dl> <dt><b>BPPF_ERASE</b></dt> <dt>0x0001</dt>
    ///</dl> </td> <td width="60%"> Initialize the buffer to ARGB = {0, 0, 0, 0} during BeginBufferedPaint. This erases
    ///the previous contents of the buffer. </td> </tr> <tr> <td width="40%"><a id="BPPF_NOCLIP"></a><a
    ///id="bppf_noclip"></a><dl> <dt><b>BPPF_NOCLIP</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> Do not apply
    ///the clip region of the target DC to the double buffer. If this flag is not set and if the target DC is a window
    ///DC, then clipping due to overlapping windows is applied to the double buffer. </td> </tr> <tr> <td width="40%"><a
    ///id="BPPF_NONCLIENT"></a><a id="bppf_nonclient"></a><dl> <dt><b>BPPF_NONCLIENT</b></dt> <dt>0x0004</dt> </dl>
    ///</td> <td width="60%"> A non-client DC is being used. </td> </tr> </table>
    uint         dwFlags;
    ///Type: <b>const RECT*</b> A pointer to exclusion RECT structure. This rectangle is excluded from the clipping
    ///region. May be <b>NULL</b> for no exclusion rectangle.
    const(RECT)* prcExclude;
    const(BLENDFUNCTION)* pBlendFunction;
}

// Functions

///Changes the check state of a button control.
///Params:
///    hDlg = Type: <b>HWND</b> A handle to the dialog box that contains the button.
///    nIDButton = Type: <b>int</b> The identifier of the button to modify.
///    uCheck = Type: <b>UINT</b> The check state of the button. This parameter can be one of the following values. <table> <tr>
///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="BST_CHECKED"></a><a id="bst_checked"></a><dl>
///             <dt><b>BST_CHECKED</b></dt> </dl> </td> <td width="60%"> Sets the button state to checked. </td> </tr> <tr> <td
///             width="40%"><a id="BST_INDETERMINATE"></a><a id="bst_indeterminate"></a><dl> <dt><b>BST_INDETERMINATE</b></dt>
///             </dl> </td> <td width="60%"> Sets the button state to grayed, indicating an indeterminate state. Use this value
///             only if the button has the BS_3STATE or BS_AUTO3STATE style. </td> </tr> <tr> <td width="40%"><a
///             id="BST_UNCHECKED"></a><a id="bst_unchecked"></a><dl> <dt><b>BST_UNCHECKED</b></dt> </dl> </td> <td width="60%">
///             Sets the button state to cleared </td> </tr> </table>
///Returns:
///    Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value
///    is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL CheckDlgButton(HWND hDlg, int nIDButton, uint uCheck);

///Adds a check mark to (checks) a specified radio button in a group and removes a check mark from (clears) all other
///radio buttons in the group.
///Params:
///    hDlg = Type: <b>HWND</b> A handle to the dialog box that contains the radio button.
///    nIDFirstButton = Type: <b>int</b> The identifier of the first radio button in the group.
///    nIDLastButton = Type: <b>int</b> The identifier of the last radio button in the group.
///    nIDCheckButton = Type: <b>int</b> The identifier of the radio button to select.
///Returns:
///    Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value
///    is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton);

///The <b>IsDlgButtonChecked</b> function determines whether a button control is checked or whether a three-state button
///control is checked, unchecked, or indeterminate.
///Params:
///    hDlg = Type: <b>HWND</b> A handle to the dialog box that contains the button control.
///    nIDButton = Type: <b>int</b> The identifier of the button control.
///Returns:
///    Type: <b>UINT</b> The return value from a button created with the BS_AUTOCHECKBOX, BS_AUTORADIOBUTTON,
///    BS_AUTO3STATE, BS_CHECKBOX, BS_RADIOBUTTON, or BS_3STATE styles can be one of the values in the following table.
///    If the button has any other style, the return value is zero. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>BST_CHECKED</b></dt> </dl> </td> <td width="60%">
///    The button is checked. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>BST_INDETERMINATE</b></dt> </dl> </td> <td
///    width="60%"> The button is in an indeterminate state (applies only if the button has the BS_3STATE or
///    BS_AUTO3STATE style). </td> </tr> <tr> <td width="40%"> <dl> <dt><b>BST_UNCHECKED</b></dt> </dl> </td> <td
///    width="60%"> The button is not checked. </td> </tr> </table>
///    
@DllImport("USER32")
uint IsDlgButtonChecked(HWND hDlg, int nIDButton);

///Determines whether a character is lowercase. This determination is based on the semantics of the language selected by
///the user during setup or through Control Panel.
///Params:
///    ch = Type: <b>TCHAR</b> The character to be tested.
///Returns:
///    Type: <b>BOOL</b> If the character is lowercase, the return value is nonzero. If the character is not lowercase,
///    the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL IsCharLowerW(ushort ch);

///Configures the touch injection context for the calling application and initializes the maximum number of simultaneous
///contacts that the app can inject.<div class="alert"><b>Note</b> <b>InitializeTouchInjection</b> must precede any call
///to InjectTouchInput.</div> <div> </div>
///Params:
///    maxCount = The maximum number of touch contacts. The <i>maxCount</i> parameter must be greater than 0 and less than or equal
///               to MAX_TOUCH_COUNT (256) as defined in winuser.h.
///    dwMode = The contact visualization mode. The <i>dwMode</i> parameter must be TOUCH_FEEDBACK_DEFAULT,
///             <b>TOUCH_FEEDBACK_INDIRECT</b>, or <b>TOUCH_FEEDBACK_NONE</b>.
///Returns:
///    If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. To get
///    extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL InitializeTouchInjection(uint maxCount, uint dwMode);

///Simulates touch input.<div class="alert"><b>Note</b> InitializeTouchInjection must precede any call to
///InjectTouchInput.</div> <div> </div>
///Params:
///    count = The size of the array in <i>contacts</i>. The maximum value for <i>count</i> is specified by the <i>maxCount</i>
///            parameter of the InitializeTouchInjection function.
///    contacts = Array of POINTER_TOUCH_INFO structures that represents all contacts on the desktop. The screen coordinates of
///               each contact must be within the bounds of the desktop.
///Returns:
///    If the function succeeds, the return value is non-zero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL InjectTouchInput(uint count, const(POINTER_TOUCH_INFO)* contacts);

///Configures the pointer injection device for the calling application, and initializes the maximum number of
///simultaneous pointers that the app can inject.
///Params:
///    pointerType = The pointer injection device type. Must be either PT_TOUCH or <b>PT_PEN</b>.
///    maxCount = The maximum number of contacts. For PT_TOUCH this value must be greater than 0 and less than or equal to
///               MAX_TOUCH_COUNT. For PT_PEN this value must be 1.
///    mode = The contact visualization mode.
@DllImport("USER32")
HSYNTHETICPOINTERDEVICE CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, uint maxCount, 
                                                     POINTER_FEEDBACK_MODE mode);

///Simulates pointer input (pen or touch).
///Params:
///    device = A handle to the pointer injection device created by CreateSyntheticPointerDevice.
///    pointerInfo = Array of injected pointers. The type must match the <i>pointerType</i> parameter of the
///                  CreateSyntheticPointerDevice call that created the injection device. The ptPixelLocation for each
///                  POINTER_TYPE_INFO is specified relative to top left of the virtual screen:
///    count = The number of contacts. For PT_TOUCH this value must be greater than 0 and less than or equal to MAX_TOUCH_COUNT.
///            For PT_PEN this value must be 1.
@DllImport("USER32")
BOOL InjectSyntheticPointerInput(HSYNTHETICPOINTERDEVICE device, const(POINTER_TYPE_INFO)* pointerInfo, uint count);

///Destroys the specified pointer injection device.
@DllImport("USER32")
void DestroySyntheticPointerDevice(HSYNTHETICPOINTERDEVICE device);

///Registers a window to process the WM_TOUCHHITTESTING notification.
///Params:
///    hwnd = The window that receives the WM_TOUCHHITTESTING notification.
///    value = One of the following values: <ul> <li> TOUCH_HIT_TESTING_CLIENT: Send WM_TOUCHHITTESTING messages to the target
///            window.</li> <li> TOUCH_HIT_TESTING_DEFAULT: Don't send WM_TOUCHHITTESTING messages to the target window but
///            continue to send the messages to child windows. </li> <li> TOUCH_HIT_TESTING_NONE: Don't send WM_TOUCHHITTESTING
///            messages to the target window or child windows. </li> </ul>
///Returns:
///    If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information,
///    call the GetLastError function.
///    
@DllImport("USER32")
BOOL RegisterTouchHitTestingWindow(HWND hwnd, uint value);

///Returns the score of a rectangle as the probable touch target, compared to all other rectangles that intersect the
///touch contact area, and an adjusted touch point within the rectangle.
///Params:
///    controlBoundingBox = The RECT structure that defines the bounding box of the UI element.
///    pHitTestingInput = The TOUCH_HIT_TESTING_INPUT structure that holds the data for the touch contact area.
///    pProximityEval = The TOUCH_HIT_TESTING_PROXIMITY_EVALUATION structure that holds the score and adjusted touch-point data.
///Returns:
///    If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information,
///    call the GetLastError function.
///    
@DllImport("USER32")
BOOL EvaluateProximityToRect(const(RECT)* controlBoundingBox, const(TOUCH_HIT_TESTING_INPUT)* pHitTestingInput, 
                             TOUCH_HIT_TESTING_PROXIMITY_EVALUATION* pProximityEval);

///Returns the score of a polygon as the probable touch target (compared to all other polygons that intersect the touch
///contact area) and an adjusted touch point within the polygon.
///Params:
///    numVertices = The number of vertices in the polygon. This value must be greater than or equal to 3. This value indicates the
///                  size of the array, as specified by the <i>controlPolygon</i> parameter.
///    controlPolygon = The array of x-y screen coordinates that define the shape of the UI element. The <i>numVertices</i> parameter
///                     specifies the number of coordinates.
///    pHitTestingInput = The TOUCH_HIT_TESTING_INPUT structure that holds the data for the touch contact area.
///    pProximityEval = The TOUCH_HIT_TESTING_PROXIMITY_EVALUATION structure that holds the score and adjusted touch-point data.
///Returns:
///    If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information,
///    call the GetLastError function.
///    
@DllImport("USER32")
BOOL EvaluateProximityToPolygon(uint numVertices, const(POINT)* controlPolygon, 
                                const(TOUCH_HIT_TESTING_INPUT)* pHitTestingInput, 
                                TOUCH_HIT_TESTING_PROXIMITY_EVALUATION* pProximityEval);

///Returns the proximity evaluation score and the adjusted touch-point coordinates as a packed value for the
///WM_TOUCHHITTESTING callback.
///Params:
///    pHitTestingInput = The TOUCH_HIT_TESTING_INPUT structure that holds the data for the touch contact area.
///    pProximityEval = The TOUCH_HIT_TESTING_PROXIMITY_EVALUATION structure that holds the score and adjusted touch-point data that the
///                     EvaluateProximityToPolygon or EvaluateProximityToRect function returns.
///Returns:
///    If this function succeeds, it returns the <b>score</b> and <b>adjustedPoint</b> values from
///    TOUCH_HIT_TESTING_PROXIMITY_EVALUATION as an LRESULT. To retrieve extended error information, call the
///    GetLastError function.
///    
@DllImport("USER32")
LRESULT PackTouchHitTestingProximityEvaluation(const(TOUCH_HIT_TESTING_INPUT)* pHitTestingInput, 
                                               const(TOUCH_HIT_TESTING_PROXIMITY_EVALUATION)* pProximityEval);

///Retrieves the feedback configuration for a window.
///Params:
///    hwnd = The window to check for feedback configuration.
///    feedback = One of the values from the FEEDBACK_TYPE enumeration.
///    dwFlags = Specify GWFS_INCLUDE_ANCESTORS to check the parent window chain until a value is found. The default is 0 and
///              indicates that only the specified window will be checked.
///    pSize = The size of memory region that the <i>config</i> parameter points to. The <i>pSize</i> parameter specifies the
///            size of the configuration data for the feedback type in <i>feedback</i> and must be sizeof(BOOL).
///    config = The configuration data. The <i>config</i> parameter must point to a value of type BOOL.
///Returns:
///    Returns TRUE if the specified feedback setting is configured on the specified window. Otherwise, it returns FALSE
///    (and <i>config</i> won't be modified).
///    
@DllImport("USER32")
BOOL GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, uint dwFlags, uint* pSize, void* config);

///Sets the feedback configuration for a window.
///Params:
///    hwnd = The window to configure feedback on.
///    feedback = One of the values from the FEEDBACK_TYPE enumeration.
///    dwFlags = Reserved. Must be 0.
///    size = The size, in bytes, of the configuration data. Must be sizeof(BOOL) or 0 if the feedback setting is being reset.
///    configuration = The configuration data. Must be BOOL or NULL if the feedback setting is being reset.
///Returns:
///    Returns TRUE if successful; otherwise, returns FALSE.
///    
@DllImport("USER32")
BOOL SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, uint dwFlags, uint size, 
                              const(void)* configuration);

///The <b>ScrollWindow</b> function scrolls the contents of the specified window's client area. <div
///class="alert"><b>Note</b> The <b>ScrollWindow</b> function is provided for backward compatibility. New applications
///should use the ScrollWindowEx function.</div><div> </div>
///Params:
///    hWnd = Type: <b>HWND</b> Handle to the window where the client area is to be scrolled.
///    XAmount = Type: <b>int</b> Specifies the amount, in device units, of horizontal scrolling. If the window being scrolled has
///              the CS_OWNDC or CS_CLASSDC style, then this parameter uses logical units rather than device units. This parameter
///              must be a negative value to scroll the content of the window to the left.
///    YAmount = Type: <b>int</b> Specifies the amount, in device units, of vertical scrolling. If the window being scrolled has
///              the CS_OWNDC or CS_CLASSDC style, then this parameter uses logical units rather than device units. This parameter
///              must be a negative value to scroll the content of the window up.
///    lpRect = Type: <b>const RECT*</b> Pointer to the RECT structure specifying the portion of the client area to be scrolled.
///             If this parameter is <b>NULL</b>, the entire client area is scrolled.
///    lpClipRect = Type: <b>const RECT*</b> Pointer to the RECT structure containing the coordinates of the clipping rectangle. Only
///                 device bits within the clipping rectangle are affected. Bits scrolled from the outside of the rectangle to the
///                 inside are painted; bits scrolled from the inside of the rectangle to the outside are not painted.
///Returns:
///    Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value
///    is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL ScrollWindow(HWND hWnd, int XAmount, int YAmount, const(RECT)* lpRect, const(RECT)* lpClipRect);

///The <b>ScrollDC</b> function scrolls a rectangle of bits horizontally and vertically.
///Params:
///    hDC = Type: <b>HDC</b> Handle to the device context that contains the bits to be scrolled.
///    dx = Type: <b>int</b> Specifies the amount, in device units, of horizontal scrolling. This parameter must be a
///         negative value to scroll to the left.
///    dy = Type: <b>int</b> Specifies the amount, in device units, of vertical scrolling. This parameter must be a negative
///         value to scroll up.
///    lprcScroll = Type: <b>const RECT*</b> Pointer to a RECT structure containing the coordinates of the bits to be scrolled. The
///                 only bits affected by the scroll operation are bits in the intersection of this rectangle and the rectangle
///                 specified by <i>lprcClip</i>. If <i>lprcScroll</i> is <b>NULL</b>, the entire client area is used.
///    lprcClip = Type: <b>const RECT*</b> Pointer to a RECT structure containing the coordinates of the clipping rectangle. The
///               only bits that will be painted are the bits that remain inside this rectangle after the scroll operation has been
///               completed. If <i>lprcClip</i> is <b>NULL</b>, the entire client area is used.
///    hrgnUpdate = Type: <b>HRGN</b> Handle to the region uncovered by the scrolling process. <b>ScrollDC</b> defines this region;
///                 it is not necessarily a rectangle.
///    lprcUpdate = Type: <b>LPRECT</b> Pointer to a RECT structure that receives the coordinates of the rectangle bounding the
///                 scrolling update region. This is the largest rectangular area that requires repainting. When the function
///                 returns, the values in the structure are in client coordinates, regardless of the mapping mode for the specified
///                 device context. This allows applications to use the update region in a call to the InvalidateRgn function, if
///                 required.
///Returns:
///    Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value
///    is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL ScrollDC(HDC hDC, int dx, int dy, const(RECT)* lprcScroll, const(RECT)* lprcClip, HRGN hrgnUpdate, 
              RECT* lprcUpdate);

///The <b>ScrollWindowEx</b> function scrolls the contents of the specified window's client area.
///Params:
///    hWnd = Type: <b>HWND</b> Handle to the window where the client area is to be scrolled.
///    dx = Type: <b>int</b> Specifies the amount, in device units, of horizontal scrolling. This parameter must be a
///         negative value to scroll to the left.
///    dy = Type: <b>int</b> Specifies the amount, in device units, of vertical scrolling. This parameter must be a negative
///         value to scroll up.
///    prcScroll = Type: <b>const RECT*</b> Pointer to a RECT structure that specifies the portion of the client area to be
///                scrolled. If this parameter is <b>NULL</b>, the entire client area is scrolled.
///    prcClip = Type: <b>const RECT*</b> Pointer to a RECT structure that contains the coordinates of the clipping rectangle.
///              Only device bits within the clipping rectangle are affected. Bits scrolled from the outside of the rectangle to
///              the inside are painted; bits scrolled from the inside of the rectangle to the outside are not painted. This
///              parameter may be <b>NULL</b>.
///    hrgnUpdate = Type: <b>HRGN</b> Handle to the region that is modified to hold the region invalidated by scrolling. This
///                 parameter may be <b>NULL</b>.
///    prcUpdate = Type: <b>LPRECT</b> Pointer to a RECT structure that receives the boundaries of the rectangle invalidated by
///                scrolling. This parameter may be <b>NULL</b>.
///    flags = Type: <b>UINT</b> Specifies flags that control scrolling. This parameter can be a combination of the following
///            values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SW_ERASE"></a><a
///            id="sw_erase"></a><dl> <dt><b>SW_ERASE</b></dt> </dl> </td> <td width="60%"> Erases the newly invalidated region
///            by sending a WM_ERASEBKGND message to the window when specified with the SW_INVALIDATE flag. </td> </tr> <tr> <td
///            width="40%"><a id="SW_INVALIDATE"></a><a id="sw_invalidate"></a><dl> <dt><b>SW_INVALIDATE</b></dt> </dl> </td>
///            <td width="60%"> Invalidates the region identified by the <i>hrgnUpdate</i> parameter after scrolling. </td>
///            </tr> <tr> <td width="40%"><a id="SW_SCROLLCHILDREN"></a><a id="sw_scrollchildren"></a><dl>
///            <dt><b>SW_SCROLLCHILDREN</b></dt> </dl> </td> <td width="60%"> Scrolls all child windows that intersect the
///            rectangle pointed to by the <i>prcScroll</i> parameter. The child windows are scrolled by the number of pixels
///            specified by the <i>dx</i> and <i>dy</i> parameters. The system sends a WM_MOVE message to all child windows that
///            intersect the <i>prcScroll</i> rectangle, even if they do not move. </td> </tr> <tr> <td width="40%"><a
///            id="SW_SMOOTHSCROLL"></a><a id="sw_smoothscroll"></a><dl> <dt><b>SW_SMOOTHSCROLL</b></dt> </dl> </td> <td
///            width="60%"> Scrolls using smooth scrolling. Use the HIWORD portion of the <i>flags</i> parameter to indicate how
///            much time, in milliseconds, the smooth-scrolling operation should take. </td> </tr> </table>
///Returns:
///    Type: <b>int</b> If the function succeeds, the return value is SIMPLEREGION (rectangular invalidated region),
///    COMPLEXREGION (nonrectangular invalidated region; overlapping rectangles), or NULLREGION (no invalidated region).
///    If the function fails, the return value is ERROR. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
int ScrollWindowEx(HWND hWnd, int dx, int dy, const(RECT)* prcScroll, const(RECT)* prcClip, HRGN hrgnUpdate, 
                   RECT* prcUpdate, uint flags);

///The <b>SetScrollPos</b> function sets the position of the scroll box (thumb) in the specified scroll bar and, if
///requested, redraws the scroll bar to reflect the new position of the scroll box. <div class="alert"><b>Note</b> The
///<b>SetScrollPos</b> function is provided for backward compatibility. New applications should use the SetScrollInfo
///function.</div><div> </div>
///Params:
///    hWnd = Type: <b>HWND</b> Handle to a scroll bar control or a window with a standard scroll bar, depending on the value
///           of the <i>nBar</i> parameter.
///    nBar = Type: <b>int</b> Specifies the scroll bar to be set. This parameter can be one of the following values. <table>
///           <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_CTL"></a><a id="sb_ctl"></a><dl>
///           <dt><b>SB_CTL</b></dt> </dl> </td> <td width="60%"> Sets the position of the scroll box in a scroll bar control.
///           The <i>hwnd</i> parameter must be the handle to the scroll bar control. </td> </tr> <tr> <td width="40%"><a
///           id="SB_HORZ"></a><a id="sb_horz"></a><dl> <dt><b>SB_HORZ</b></dt> </dl> </td> <td width="60%"> Sets the position
///           of the scroll box in a window's standard horizontal scroll bar. </td> </tr> <tr> <td width="40%"><a
///           id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td> <td width="60%"> Sets the position
///           of the scroll box in a window's standard vertical scroll bar. </td> </tr> </table>
///    nPos = Type: <b>int</b> Specifies the new position of the scroll box. The position must be within the scrolling range.
///           For more information about the scrolling range, see the SetScrollRange function.
///    bRedraw = Type: <b>BOOL</b> Specifies whether the scroll bar is redrawn to reflect the new scroll box position. If this
///              parameter is <b>TRUE</b>, the scroll bar is redrawn. If it is <b>FALSE</b>, the scroll bar is not redrawn.
///Returns:
///    Type: <b>int</b> If the function succeeds, the return value is the previous position of the scroll box. If the
///    function fails, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
int SetScrollPos(HWND hWnd, int nBar, int nPos, BOOL bRedraw);

///The <b>GetScrollPos</b> function retrieves the current position of the scroll box (thumb) in the specified scroll
///bar. The current position is a relative value that depends on the current scrolling range. For example, if the
///scrolling range is 0 through 100 and the scroll box is in the middle of the bar, the current position is 50. <div
///class="alert"><b>Note</b> The <b>GetScrollPos</b> function is provided for backward compatibility. New applications
///should use the GetScrollInfo function. </div><div> </div>
///Params:
///    hWnd = Type: <b>HWND</b> Handle to a scroll bar control or a window with a standard scroll bar, depending on the value
///           of the <i>nBar</i> parameter.
///    nBar = Type: <b>int</b> Specifies the scroll bar to be examined. This parameter can be one of the following values.
///           <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_CTL"></a><a
///           id="sb_ctl"></a><dl> <dt><b>SB_CTL</b></dt> </dl> </td> <td width="60%"> Retrieves the position of the scroll box
///           in a scroll bar control. The <i>hWnd</i> parameter must be the handle to the scroll bar control. </td> </tr> <tr>
///           <td width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl> <dt><b>SB_HORZ</b></dt> </dl> </td> <td width="60%">
///           Retrieves the position of the scroll box in a window's standard horizontal scroll bar. </td> </tr> <tr> <td
///           width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td> <td width="60%">
///           Retrieves the position of the scroll box in a window's standard vertical scroll bar. </td> </tr> </table>
///Returns:
///    Type: <b>int</b> If the function succeeds, the return value is the current position of the scroll box. If the
///    function fails, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
int GetScrollPos(HWND hWnd, int nBar);

///The <b>SetScrollRange</b> function sets the minimum and maximum scroll box positions for the specified scroll bar.
///<div class="alert"><b>Note</b> The <b>SetScrollRange</b> function is provided for backward compatibility. New
///applications should use the SetScrollInfo function.</div><div> </div>
///Params:
///    hWnd = Type: <b>HWND</b> Handle to a scroll bar control or a window with a standard scroll bar, depending on the value
///           of the <i>nBar</i> parameter.
///    nBar = Type: <b>int</b> Specifies the scroll bar to be set. This parameter can be one of the following values. <table>
///           <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_CTL"></a><a id="sb_ctl"></a><dl>
///           <dt><b>SB_CTL</b></dt> </dl> </td> <td width="60%"> Sets the range of a scroll bar control. The <i>hwnd</i>
///           parameter must be the handle to the scroll bar control. </td> </tr> <tr> <td width="40%"><a id="SB_HORZ"></a><a
///           id="sb_horz"></a><dl> <dt><b>SB_HORZ</b></dt> </dl> </td> <td width="60%"> Sets the range of a window's standard
///           horizontal scroll bar. </td> </tr> <tr> <td width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl>
///           <dt><b>SB_VERT</b></dt> </dl> </td> <td width="60%"> Sets the range of a window's standard vertical scroll bar.
///           </td> </tr> </table>
///    nMinPos = Type: <b>int</b> Specifies the minimum scrolling position.
///    nMaxPos = Type: <b>int</b> Specifies the maximum scrolling position.
///    bRedraw = Type: <b>BOOL</b> Specifies whether the scroll bar should be redrawn to reflect the change. If this parameter is
///              <b>TRUE</b>, the scroll bar is redrawn. If it is <b>FALSE</b>, the scroll bar is not redrawn.
///Returns:
///    Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value
///    is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL SetScrollRange(HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw);

///The <b>GetScrollRange</b> function retrieves the current minimum and maximum scroll box (thumb) positions for the
///specified scroll bar. <div class="alert"><b>Note</b> The <b>GetScrollRange</b> function is provided for compatibility
///only. New applications should use the GetScrollInfo function.</div><div> </div>
///Params:
///    hWnd = Type: <b>HWND</b> Handle to a scroll bar control or a window with a standard scroll bar, depending on the value
///           of the <i>nBar</i> parameter.
///    nBar = Type: <b>int</b> Specifies the scroll bar from which the positions are retrieved. This parameter can be one of
///           the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///           id="SB_CTL"></a><a id="sb_ctl"></a><dl> <dt><b>SB_CTL</b></dt> </dl> </td> <td width="60%"> Retrieves the
///           positions of a scroll bar control. The <i>hWnd</i> parameter must be the handle to the scroll bar control. </td>
///           </tr> <tr> <td width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl> <dt><b>SB_HORZ</b></dt> </dl> </td> <td
///           width="60%"> Retrieves the positions of the window's standard horizontal scroll bar. </td> </tr> <tr> <td
///           width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td> <td width="60%">
///           Retrieves the positions of the window's standard vertical scroll bar. </td> </tr> </table>
///    lpMinPos = Type: <b>LPINT</b> Pointer to the integer variable that receives the minimum position.
///    lpMaxPos = Type: <b>LPINT</b> Pointer to the integer variable that receives the maximum position.
///Returns:
///    Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value
///    is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL GetScrollRange(HWND hWnd, int nBar, int* lpMinPos, int* lpMaxPos);

///The <b>ShowScrollBar</b> function shows or hides the specified scroll bar.
///Params:
///    hWnd = Type: <b>HWND</b> Handle to a scroll bar control or a window with a standard scroll bar, depending on the value
///           of the <i>wBar</i> parameter.
///    wBar = Type: <b>int</b> Specifies the scroll bar(s) to be shown or hidden. This parameter can be one of the following
///           values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_BOTH"></a><a
///           id="sb_both"></a><dl> <dt><b>SB_BOTH</b></dt> </dl> </td> <td width="60%"> Shows or hides a window's standard
///           horizontal and vertical scroll bars. </td> </tr> <tr> <td width="40%"><a id="SB_CTL"></a><a id="sb_ctl"></a><dl>
///           <dt><b>SB_CTL</b></dt> </dl> </td> <td width="60%"> Shows or hides a scroll bar control. The <i>hwnd</i>
///           parameter must be the handle to the scroll bar control. </td> </tr> <tr> <td width="40%"><a id="SB_HORZ"></a><a
///           id="sb_horz"></a><dl> <dt><b>SB_HORZ</b></dt> </dl> </td> <td width="60%"> Shows or hides a window's standard
///           horizontal scroll bars. </td> </tr> <tr> <td width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl>
///           <dt><b>SB_VERT</b></dt> </dl> </td> <td width="60%"> Shows or hides a window's standard vertical scroll bar.
///           </td> </tr> </table>
///    bShow = Type: <b>BOOL</b> Specifies whether the scroll bar is shown or hidden. If this parameter is <b>TRUE</b>, the
///            scroll bar is shown; otherwise, it is hidden.
///Returns:
///    Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value
///    is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL ShowScrollBar(HWND hWnd, int wBar, BOOL bShow);

///The <b>EnableScrollBar</b> function enables or disables one or both scroll bar arrows.
///Params:
///    hWnd = Type: <b>HWND</b> Handle to a window or a scroll bar control, depending on the value of the <i>wSBflags</i>
///           parameter.
///    wSBflags = Type: <b>UINT</b> Specifies the scroll bar type. This parameter can be one of the following values. <table> <tr>
///               <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_BOTH"></a><a id="sb_both"></a><dl>
///               <dt><b>SB_BOTH</b></dt> </dl> </td> <td width="60%"> Enables or disables the arrows on the horizontal and
///               vertical scroll bars associated with the specified window. The <i>hWnd</i> parameter must be the handle to the
///               window. </td> </tr> <tr> <td width="40%"><a id="SB_CTL"></a><a id="sb_ctl"></a><dl> <dt><b>SB_CTL</b></dt> </dl>
///               </td> <td width="60%"> Indicates that the scroll bar is a scroll bar control. The <i>hWnd</i> must be the handle
///               to the scroll bar control. </td> </tr> <tr> <td width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl>
///               <dt><b>SB_HORZ</b></dt> </dl> </td> <td width="60%"> Enables or disables the arrows on the horizontal scroll bar
///               associated with the specified window. The <i>hWnd</i> parameter must be the handle to the window. </td> </tr>
///               <tr> <td width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td> <td
///               width="60%"> Enables or disables the arrows on the vertical scroll bar associated with the specified window. The
///               <i>hWnd</i> parameter must be the handle to the window. </td> </tr> </table>
///    wArrows = Type: <b>UINT</b> Specifies whether the scroll bar arrows are enabled or disabled and indicates which arrows are
///              enabled or disabled. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ESB_DISABLE_BOTH"></a><a id="esb_disable_both"></a><dl>
///              <dt><b>ESB_DISABLE_BOTH</b></dt> </dl> </td> <td width="60%"> Disables both arrows on a scroll bar. </td> </tr>
///              <tr> <td width="40%"><a id="ESB_DISABLE_DOWN"></a><a id="esb_disable_down"></a><dl>
///              <dt><b>ESB_DISABLE_DOWN</b></dt> </dl> </td> <td width="60%"> Disables the down arrow on a vertical scroll bar.
///              </td> </tr> <tr> <td width="40%"><a id="ESB_DISABLE_LEFT"></a><a id="esb_disable_left"></a><dl>
///              <dt><b>ESB_DISABLE_LEFT</b></dt> </dl> </td> <td width="60%"> Disables the left arrow on a horizontal scroll bar.
///              </td> </tr> <tr> <td width="40%"><a id="ESB_DISABLE_LTUP"></a><a id="esb_disable_ltup"></a><dl>
///              <dt><b>ESB_DISABLE_LTUP</b></dt> </dl> </td> <td width="60%"> Disables the left arrow on a horizontal scroll bar
///              or the up arrow of a vertical scroll bar. </td> </tr> <tr> <td width="40%"><a id="ESB_DISABLE_RIGHT"></a><a
///              id="esb_disable_right"></a><dl> <dt><b>ESB_DISABLE_RIGHT</b></dt> </dl> </td> <td width="60%"> Disables the right
///              arrow on a horizontal scroll bar. </td> </tr> <tr> <td width="40%"><a id="ESB_DISABLE_RTDN"></a><a
///              id="esb_disable_rtdn"></a><dl> <dt><b>ESB_DISABLE_RTDN</b></dt> </dl> </td> <td width="60%"> Disables the right
///              arrow on a horizontal scroll bar or the down arrow of a vertical scroll bar. </td> </tr> <tr> <td width="40%"><a
///              id="ESB_DISABLE_UP"></a><a id="esb_disable_up"></a><dl> <dt><b>ESB_DISABLE_UP</b></dt> </dl> </td> <td
///              width="60%"> Disables the up arrow on a vertical scroll bar. </td> </tr> <tr> <td width="40%"><a
///              id="ESB_ENABLE_BOTH"></a><a id="esb_enable_both"></a><dl> <dt><b>ESB_ENABLE_BOTH</b></dt> </dl> </td> <td
///              width="60%"> Enables both arrows on a scroll bar. </td> </tr> </table>
@DllImport("USER32")
BOOL EnableScrollBar(HWND hWnd, uint wSBflags, uint wArrows);

///Replaces the contents of a list box with the names of the subdirectories and files in a specified directory. You can
///filter the list of names by specifying a set of file attributes. The list can optionally include mapped drives.
///Params:
///    hDlg = Type: <b>HWND</b> A handle to the dialog box that contains the list box.
///    lpPathSpec = Type: <b>LPTSTR</b> A pointer to a buffer containing a null-terminated string that specifies an absolute path,
///                 relative path, or filename. An absolute path can begin with a drive letter (for example, d:\) or a UNC name (for
///                 example, \\\<i>machinename</i>\\<i>sharename</i>). The function splits the string into a directory and a
///                 filename. The function searches the directory for names that match the filename. If the string does not specify a
///                 directory, the function searches the current directory. If the string includes a filename, the filename must
///                 contain at least one wildcard character (? or \*). If the string does not include a filename, the function
///                 behaves as if you had specified the asterisk wildcard character (\*) as the filename. All names in the specified
///                 directory that match the filename and have the attributes specified by the <i>uFileType</i> parameter are added
///                 to the list box.
///    nIDListBox = Type: <b>int</b> The identifier of a list box in the <i>hDlg</i> dialog box. If this parameter is zero,
///                 <b>DlgDirList</b> does not try to fill a list box.
///    nIDStaticPath = Type: <b>int</b> The identifier of a static control in the <i>hDlg</i> dialog box. <b>DlgDirList</b> sets the
///                    text of this control to display the current drive and directory. This parameter can be zero if you do not want to
///                    display the current drive and directory.
///    uFileType = Type: <b>UINT</b> Specifies the attributes of the files or directories to be added to the list box. This
///                parameter can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                width="40%"><a id="DDL_ARCHIVE"></a><a id="ddl_archive"></a><dl> <dt><b>DDL_ARCHIVE</b></dt> </dl> </td> <td
///                width="60%"> Includes archived files. </td> </tr> <tr> <td width="40%"><a id="DDL_DIRECTORY"></a><a
///                id="ddl_directory"></a><dl> <dt><b>DDL_DIRECTORY</b></dt> </dl> </td> <td width="60%"> Includes subdirectories.
///                Subdirectory names are enclosed in square brackets ([ ]). </td> </tr> <tr> <td width="40%"><a
///                id="DDL_DRIVES"></a><a id="ddl_drives"></a><dl> <dt><b>DDL_DRIVES</b></dt> </dl> </td> <td width="60%"> All
///                mapped drives are added to the list. Drives are listed in the form [- <i>x</i>-], where <i>x</i> is the drive
///                letter. </td> </tr> <tr> <td width="40%"><a id="DDL_EXCLUSIVE"></a><a id="ddl_exclusive"></a><dl>
///                <dt><b>DDL_EXCLUSIVE</b></dt> </dl> </td> <td width="60%"> Includes only files with the specified attributes. By
///                default, read/write files are listed even if DDL_READWRITE is not specified. </td> </tr> <tr> <td width="40%"><a
///                id="DDL_HIDDEN"></a><a id="ddl_hidden"></a><dl> <dt><b>DDL_HIDDEN</b></dt> </dl> </td> <td width="60%"> Includes
///                hidden files. </td> </tr> <tr> <td width="40%"><a id="DDL_READONLY"></a><a id="ddl_readonly"></a><dl>
///                <dt><b>DDL_READONLY</b></dt> </dl> </td> <td width="60%"> Includes read-only files. </td> </tr> <tr> <td
///                width="40%"><a id="DDL_READWRITE"></a><a id="ddl_readwrite"></a><dl> <dt><b>DDL_READWRITE</b></dt> </dl> </td>
///                <td width="60%"> Includes read/write files with no additional attributes. This is the default setting. </td>
///                </tr> <tr> <td width="40%"><a id="DDL_SYSTEM"></a><a id="ddl_system"></a><dl> <dt><b>DDL_SYSTEM</b></dt> </dl>
///                </td> <td width="60%"> Includes system files. </td> </tr> <tr> <td width="40%"><a id="DDL_POSTMSGS"></a><a
///                id="ddl_postmsgs"></a><dl> <dt><b>DDL_POSTMSGS</b></dt> </dl> </td> <td width="60%"> If set, <b>DlgDirList</b>
///                uses the PostMessage function to send messages to the list box. If not set, <b>DlgDirList</b> uses the
///                SendMessage function. </td> </tr> </table>
///Returns:
///    Type: <b>int</b> If the function succeeds, the return value is nonzero. If the function fails, the return value
///    is zero. For example, if the string specified by <i>lpPathSpec</i> is not a valid path, the function fails. To
///    get extended error information, call .
///    
@DllImport("USER32")
int DlgDirListA(HWND hDlg, PSTR lpPathSpec, int nIDListBox, int nIDStaticPath, uint uFileType);

///Replaces the contents of a list box with the names of the subdirectories and files in a specified directory. You can
///filter the list of names by specifying a set of file attributes. The list can optionally include mapped drives.
///Params:
///    hDlg = Type: <b>HWND</b> A handle to the dialog box that contains the list box.
///    lpPathSpec = Type: <b>LPTSTR</b> A pointer to a buffer containing a null-terminated string that specifies an absolute path,
///                 relative path, or filename. An absolute path can begin with a drive letter (for example, d:\) or a UNC name (for
///                 example, \\ <i>machinename</i>\ <i>sharename</i>). The function splits the string into a directory and a
///                 filename. The function searches the directory for names that match the filename. If the string does not specify a
///                 directory, the function searches the current directory. If the string includes a filename, the filename must
///                 contain at least one wildcard character (? or *). If the string does not include a filename, the function behaves
///                 as if you had specified the asterisk wildcard character (*) as the filename. All names in the specified directory
///                 that match the filename and have the attributes specified by the <i>uFileType</i> parameter are added to the list
///                 box.
///    nIDListBox = Type: <b>int</b> The identifier of a list box in the <i>hDlg</i> dialog box. If this parameter is zero,
///                 <b>DlgDirList</b> does not try to fill a list box.
///    nIDStaticPath = Type: <b>int</b> The identifier of a static control in the <i>hDlg</i> dialog box. <b>DlgDirList</b> sets the
///                    text of this control to display the current drive and directory. This parameter can be zero if you do not want to
///                    display the current drive and directory.
///    uFileType = Type: <b>UINT</b> Specifies the attributes of the files or directories to be added to the list box. This
///                parameter can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                width="40%"><a id="DDL_ARCHIVE"></a><a id="ddl_archive"></a><dl> <dt><b>DDL_ARCHIVE</b></dt> </dl> </td> <td
///                width="60%"> Includes archived files. </td> </tr> <tr> <td width="40%"><a id="DDL_DIRECTORY"></a><a
///                id="ddl_directory"></a><dl> <dt><b>DDL_DIRECTORY</b></dt> </dl> </td> <td width="60%"> Includes subdirectories.
///                Subdirectory names are enclosed in square brackets ([ ]). </td> </tr> <tr> <td width="40%"><a
///                id="DDL_DRIVES"></a><a id="ddl_drives"></a><dl> <dt><b>DDL_DRIVES</b></dt> </dl> </td> <td width="60%"> All
///                mapped drives are added to the list. Drives are listed in the form [- <i>x</i>-], where <i>x</i> is the drive
///                letter. </td> </tr> <tr> <td width="40%"><a id="DDL_EXCLUSIVE"></a><a id="ddl_exclusive"></a><dl>
///                <dt><b>DDL_EXCLUSIVE</b></dt> </dl> </td> <td width="60%"> Includes only files with the specified attributes. By
///                default, read/write files are listed even if DDL_READWRITE is not specified. </td> </tr> <tr> <td width="40%"><a
///                id="DDL_HIDDEN"></a><a id="ddl_hidden"></a><dl> <dt><b>DDL_HIDDEN</b></dt> </dl> </td> <td width="60%"> Includes
///                hidden files. </td> </tr> <tr> <td width="40%"><a id="DDL_READONLY"></a><a id="ddl_readonly"></a><dl>
///                <dt><b>DDL_READONLY</b></dt> </dl> </td> <td width="60%"> Includes read-only files. </td> </tr> <tr> <td
///                width="40%"><a id="DDL_READWRITE"></a><a id="ddl_readwrite"></a><dl> <dt><b>DDL_READWRITE</b></dt> </dl> </td>
///                <td width="60%"> Includes read/write files with no additional attributes. This is the default setting. </td>
///                </tr> <tr> <td width="40%"><a id="DDL_SYSTEM"></a><a id="ddl_system"></a><dl> <dt><b>DDL_SYSTEM</b></dt> </dl>
///                </td> <td width="60%"> Includes system files. </td> </tr> <tr> <td width="40%"><a id="DDL_POSTMSGS"></a><a
///                id="ddl_postmsgs"></a><dl> <dt><b>DDL_POSTMSGS</b></dt> </dl> </td> <td width="60%"> If set, <b>DlgDirList</b>
///                uses the PostMessage function to send messages to the list box. If not set, <b>DlgDirList</b> uses the
///                SendMessage function. </td> </tr> </table>
///Returns:
///    Type: <b>int</b> If the function succeeds, the return value is nonzero. If the function fails, the return value
///    is zero. For example, if the string specified by <i>lpPathSpec</i> is not a valid path, the function fails. To
///    get extended error information, call .
///    
@DllImport("USER32")
int DlgDirListW(HWND hDlg, PWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, uint uFileType);

///Retrieves the current selection from a single-selection list box. It assumes that the list box has been filled by the
///DlgDirList function and that the selection is a drive letter, filename, or directory name.
///Params:
///    hwndDlg = Type: <b>HWND</b> A handle to the dialog box that contains the list box.
///    lpString = Type: <b>LPTSTR</b> A pointer to a buffer that receives the selected path.
///    chCount = Type: <b>int</b> The length, in <b>TCHARs</b>, of the buffer pointed to by <i>lpString</i>.
///    idListBox = Type: <b>int</b> The identifier of a list box in the dialog box.
///Returns:
///    Type: <b>BOOL</b> If the current selection is a directory name, the return value is nonzero. If the current
///    selection is not a directory name, the return value is zero. To get extended error information, call
///    GetLastError.
///    
@DllImport("USER32")
BOOL DlgDirSelectExA(HWND hwndDlg, PSTR lpString, int chCount, int idListBox);

///Retrieves the current selection from a single-selection list box. It assumes that the list box has been filled by the
///DlgDirList function and that the selection is a drive letter, filename, or directory name.
///Params:
///    hwndDlg = Type: <b>HWND</b> A handle to the dialog box that contains the list box.
///    lpString = Type: <b>LPTSTR</b> A pointer to a buffer that receives the selected path.
///    chCount = Type: <b>int</b> The length, in <b>TCHARs</b>, of the buffer pointed to by <i>lpString</i>.
///    idListBox = Type: <b>int</b> The identifier of a list box in the dialog box.
///Returns:
///    Type: <b>BOOL</b> If the current selection is a directory name, the return value is nonzero. If the current
///    selection is not a directory name, the return value is zero. To get extended error information, call
///    GetLastError.
///    
@DllImport("USER32")
BOOL DlgDirSelectExW(HWND hwndDlg, PWSTR lpString, int chCount, int idListBox);

///Replaces the contents of a combo box with the names of the subdirectories and files in a specified directory. You can
///filter the list of names by specifying a set of file attributes. The list of names can include mapped drive letters.
///Params:
///    hDlg = Type: <b>HWND</b> A handle to the dialog box that contains the combo box.
///    lpPathSpec = Type: <b>LPTSTR</b> A pointer to a buffer containing a null-terminated string that specifies an absolute path,
///                 relative path, or file name. An absolute path can begin with a drive letter (for example, d:\) or a UNC name (for
///                 example, &
///    nIDComboBox = Type: <b>int</b> The identifier of a combo box in the <i>hDlg</i> dialog box. If this parameter is zero,
///                  <b>DlgDirListComboBox</b> does not try to fill a combo box.
///    nIDStaticPath = Type: <b>int</b> The identifier of a static control in the <i>hDlg</i> dialog box. <b>DlgDirListComboBox</b> sets
///                    the text of this control to display the current drive and directory. This parameter can be zero if you do not
///                    want to display the current drive and directory.
///    uFiletype = Type: <b>UINT</b> A set of bit flags that specifies the attributes of the files or directories to be added to the
///                combo box. This parameter can be a combination of the following values. <table> <tr> <th>Value</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DDL_ARCHIVE"></a><a id="ddl_archive"></a><dl>
///                <dt><b>DDL_ARCHIVE</b></dt> </dl> </td> <td width="60%"> Includes archived files. </td> </tr> <tr> <td
///                width="40%"><a id="DDL_DIRECTORY"></a><a id="ddl_directory"></a><dl> <dt><b>DDL_DIRECTORY</b></dt> </dl> </td>
///                <td width="60%"> Includes subdirectories, which are enclosed in square brackets ([ ]). </td> </tr> <tr> <td
///                width="40%"><a id="DDL_DRIVES"></a><a id="ddl_drives"></a><dl> <dt><b>DDL_DRIVES</b></dt> </dl> </td> <td
///                width="60%"> All mapped drives are added to the list. Drives are listed in the form [-<i>x</i>-], where <i>x</i>
///                is the drive letter. </td> </tr> <tr> <td width="40%"><a id="DDL_EXCLUSIVE"></a><a id="ddl_exclusive"></a><dl>
///                <dt><b>DDL_EXCLUSIVE</b></dt> </dl> </td> <td width="60%"> Includes only files with the specified attributes. By
///                default, read/write files are listed even if DDL_READWRITE is not specified. </td> </tr> <tr> <td width="40%"><a
///                id="DDL_HIDDEN"></a><a id="ddl_hidden"></a><dl> <dt><b>DDL_HIDDEN</b></dt> </dl> </td> <td width="60%"> Includes
///                hidden files. </td> </tr> <tr> <td width="40%"><a id="DDL_READONLY"></a><a id="ddl_readonly"></a><dl>
///                <dt><b>DDL_READONLY</b></dt> </dl> </td> <td width="60%"> Includes read-only files. </td> </tr> <tr> <td
///                width="40%"><a id="DDL_READWRITE"></a><a id="ddl_readwrite"></a><dl> <dt><b>DDL_READWRITE</b></dt> </dl> </td>
///                <td width="60%"> Includes read/write files with no additional attributes. This is the default setting. </td>
///                </tr> <tr> <td width="40%"><a id="DDL_SYSTEM"></a><a id="ddl_system"></a><dl> <dt><b>DDL_SYSTEM</b></dt> </dl>
///                </td> <td width="60%"> Includes system files. </td> </tr> <tr> <td width="40%"><a id="DDL_POSTMSGS"></a><a
///                id="ddl_postmsgs"></a><dl> <dt><b>DDL_POSTMSGS</b></dt> </dl> </td> <td width="60%"> If this flag is set,
///                <b>DlgDirListComboBox</b> uses the PostMessage function to send messages to the combo box. If this flag is not
///                set, <b>DlgDirListComboBox</b> uses the SendMessage function. </td> </tr> </table>
///Returns:
///    Type: <b>int</b> If the function succeeds, the return value is nonzero. If the function fails, the return value
///    is zero. For example, if the string specified by <i>lpPathSpec</i> is not a valid path, the function fails. To
///    get extended error information, call GetLastError.
///    
@DllImport("USER32")
int DlgDirListComboBoxA(HWND hDlg, PSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, uint uFiletype);

///Replaces the contents of a combo box with the names of the subdirectories and files in a specified directory. You can
///filter the list of names by specifying a set of file attributes. The list of names can include mapped drive letters.
///Params:
///    hDlg = Type: <b>HWND</b> A handle to the dialog box that contains the combo box.
///    lpPathSpec = Type: <b>LPTSTR</b> A pointer to a buffer containing a null-terminated string that specifies an absolute path,
///                 relative path, or file name. An absolute path can begin with a drive letter (for example, d:\) or a UNC name (for
///                 example, &
///    nIDComboBox = Type: <b>int</b> The identifier of a combo box in the <i>hDlg</i> dialog box. If this parameter is zero,
///                  <b>DlgDirListComboBox</b> does not try to fill a combo box.
///    nIDStaticPath = Type: <b>int</b> The identifier of a static control in the <i>hDlg</i> dialog box. <b>DlgDirListComboBox</b> sets
///                    the text of this control to display the current drive and directory. This parameter can be zero if you do not
///                    want to display the current drive and directory.
///    uFiletype = Type: <b>UINT</b> A set of bit flags that specifies the attributes of the files or directories to be added to the
///                combo box. This parameter can be a combination of the following values. <table> <tr> <th>Value</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DDL_ARCHIVE"></a><a id="ddl_archive"></a><dl>
///                <dt><b>DDL_ARCHIVE</b></dt> </dl> </td> <td width="60%"> Includes archived files. </td> </tr> <tr> <td
///                width="40%"><a id="DDL_DIRECTORY"></a><a id="ddl_directory"></a><dl> <dt><b>DDL_DIRECTORY</b></dt> </dl> </td>
///                <td width="60%"> Includes subdirectories, which are enclosed in square brackets ([ ]). </td> </tr> <tr> <td
///                width="40%"><a id="DDL_DRIVES"></a><a id="ddl_drives"></a><dl> <dt><b>DDL_DRIVES</b></dt> </dl> </td> <td
///                width="60%"> All mapped drives are added to the list. Drives are listed in the form [-<i>x</i>-], where <i>x</i>
///                is the drive letter. </td> </tr> <tr> <td width="40%"><a id="DDL_EXCLUSIVE"></a><a id="ddl_exclusive"></a><dl>
///                <dt><b>DDL_EXCLUSIVE</b></dt> </dl> </td> <td width="60%"> Includes only files with the specified attributes. By
///                default, read/write files are listed even if DDL_READWRITE is not specified. </td> </tr> <tr> <td width="40%"><a
///                id="DDL_HIDDEN"></a><a id="ddl_hidden"></a><dl> <dt><b>DDL_HIDDEN</b></dt> </dl> </td> <td width="60%"> Includes
///                hidden files. </td> </tr> <tr> <td width="40%"><a id="DDL_READONLY"></a><a id="ddl_readonly"></a><dl>
///                <dt><b>DDL_READONLY</b></dt> </dl> </td> <td width="60%"> Includes read-only files. </td> </tr> <tr> <td
///                width="40%"><a id="DDL_READWRITE"></a><a id="ddl_readwrite"></a><dl> <dt><b>DDL_READWRITE</b></dt> </dl> </td>
///                <td width="60%"> Includes read/write files with no additional attributes. This is the default setting. </td>
///                </tr> <tr> <td width="40%"><a id="DDL_SYSTEM"></a><a id="ddl_system"></a><dl> <dt><b>DDL_SYSTEM</b></dt> </dl>
///                </td> <td width="60%"> Includes system files. </td> </tr> <tr> <td width="40%"><a id="DDL_POSTMSGS"></a><a
///                id="ddl_postmsgs"></a><dl> <dt><b>DDL_POSTMSGS</b></dt> </dl> </td> <td width="60%"> If this flag is set,
///                <b>DlgDirListComboBox</b> uses the PostMessage function to send messages to the combo box. If this flag is not
///                set, <b>DlgDirListComboBox</b> uses the SendMessage function. </td> </tr> </table>
///Returns:
///    Type: <b>int</b> If the function succeeds, the return value is nonzero. If the function fails, the return value
///    is zero. For example, if the string specified by <i>lpPathSpec</i> is not a valid path, the function fails. To
///    get extended error information, call GetLastError.
///    
@DllImport("USER32")
int DlgDirListComboBoxW(HWND hDlg, PWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, uint uFiletype);

///Retrieves the current selection from a combo box filled by using the DlgDirListComboBox function. The selection is
///interpreted as a drive letter, a file, or a directory name.
///Params:
///    hwndDlg = Type: <b>HWND</b> A handle to the dialog box that contains the combo box.
///    lpString = Type: <b>LPTSTR</b> A pointer to the buffer that receives the selected path.
///    cchOut = Type: <b>int</b> The length, in characters, of the buffer pointed to by the <i>lpString</i> parameter.
///    idComboBox = Type: <b>int</b> The integer identifier of the combo box control in the dialog box.
///Returns:
///    Type: <b>BOOL</b> If the current selection is a directory name, the return value is nonzero. If the current
///    selection is not a directory name, the return value is zero. To get extended error information, call
///    GetLastError.
///    
@DllImport("USER32")
BOOL DlgDirSelectComboBoxExA(HWND hwndDlg, PSTR lpString, int cchOut, int idComboBox);

///Retrieves the current selection from a combo box filled by using the DlgDirListComboBox function. The selection is
///interpreted as a drive letter, a file, or a directory name.
///Params:
///    hwndDlg = Type: <b>HWND</b> A handle to the dialog box that contains the combo box.
///    lpString = Type: <b>LPTSTR</b> A pointer to the buffer that receives the selected path.
///    cchOut = Type: <b>int</b> The length, in characters, of the buffer pointed to by the <i>lpString</i> parameter.
///    idComboBox = Type: <b>int</b> The integer identifier of the combo box control in the dialog box.
///Returns:
///    Type: <b>BOOL</b> If the current selection is a directory name, the return value is nonzero. If the current
///    selection is not a directory name, the return value is zero. To get extended error information, call
///    GetLastError.
///    
@DllImport("USER32")
BOOL DlgDirSelectComboBoxExW(HWND hwndDlg, PWSTR lpString, int cchOut, int idComboBox);

///The <b>SetScrollInfo</b> function sets the parameters of a scroll bar, including the minimum and maximum scrolling
///positions, the page size, and the position of the scroll box (thumb). The function also redraws the scroll bar, if
///requested.
///Params:
///    hwnd = Type: <b>HWND</b> Handle to a scroll bar control or a window with a standard scroll bar, depending on the value
///           of the <i>fnBar</i> parameter.
///    nBar = Type: <b>int</b> Specifies the type of scroll bar for which to set parameters. This parameter can be one of the
///           following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_CTL"></a><a
///           id="sb_ctl"></a><dl> <dt><b>SB_CTL</b></dt> </dl> </td> <td width="60%"> Sets the parameters of a scroll bar
///           control. The <i>hwnd</i> parameter must be the handle to the scroll bar control. </td> </tr> <tr> <td
///           width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl> <dt><b>SB_HORZ</b></dt> </dl> </td> <td width="60%">
///           Sets the parameters of the window's standard horizontal scroll bar. </td> </tr> <tr> <td width="40%"><a
///           id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td> <td width="60%"> Sets the
///           parameters of the window's standard vertical scroll bar. </td> </tr> </table>
///    lpsi = Type: <b>LPCSCROLLINFO</b> Pointer to a SCROLLINFO structure. Before calling <b>SetScrollInfo</b>, set the
///           <b>cbSize</b> member of the structure to <b>sizeof</b>(<b>SCROLLINFO</b>), set the <b>fMask</b> member to
///           indicate the parameters to set, and specify the new parameter values in the appropriate members. The <b>fMask</b>
///           member can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///           width="40%"><a id="SIF_DISABLENOSCROLL"></a><a id="sif_disablenoscroll"></a><dl>
///           <dt><b>SIF_DISABLENOSCROLL</b></dt> </dl> </td> <td width="60%"> Disables the scroll bar instead of removing it,
///           if the scroll bar's new parameters make the scroll bar unnecessary. </td> </tr> <tr> <td width="40%"><a
///           id="SIF_PAGE"></a><a id="sif_page"></a><dl> <dt><b>SIF_PAGE</b></dt> </dl> </td> <td width="60%"> Sets the scroll
///           page to the value specified in the <b>nPage</b> member of the SCROLLINFO structure pointed to by <i>lpsi</i>.
///           </td> </tr> <tr> <td width="40%"><a id="SIF_POS"></a><a id="sif_pos"></a><dl> <dt><b>SIF_POS</b></dt> </dl> </td>
///           <td width="60%"> Sets the scroll position to the value specified in the <b>nPos</b> member of the SCROLLINFO
///           structure pointed to by <i>lpsi</i>. </td> </tr> <tr> <td width="40%"><a id="SIF_RANGE"></a><a
///           id="sif_range"></a><dl> <dt><b>SIF_RANGE</b></dt> </dl> </td> <td width="60%"> Sets the scroll range to the value
///           specified in the <b>nMin</b> and <b>nMax</b> members of the SCROLLINFO structure pointed to by <i>lpsi</i>. </td>
///           </tr> </table>
///    redraw = Type: <b>BOOL</b> Specifies whether the scroll bar is redrawn to reflect the changes to the scroll bar. If this
///             parameter is <b>TRUE</b>, the scroll bar is redrawn, otherwise, it is not redrawn.
///Returns:
///    Type: <b>int</b> The return value is the current position of the scroll box.
///    
@DllImport("USER32")
int SetScrollInfo(HWND hwnd, int nBar, SCROLLINFO* lpsi, BOOL redraw);

///The <b>GetScrollInfo</b> function retrieves the parameters of a scroll bar, including the minimum and maximum
///scrolling positions, the page size, and the position of the scroll box (thumb).
///Params:
///    hwnd = Type: <b>HWND</b> Handle to a scroll bar control or a window with a standard scroll bar, depending on the value
///           of the <i>fnBar</i> parameter.
///    nBar = Type: <b>int</b> Specifies the type of scroll bar for which to retrieve parameters. This parameter can be one of
///           the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///           id="SB_CTL"></a><a id="sb_ctl"></a><dl> <dt><b>SB_CTL</b></dt> </dl> </td> <td width="60%"> Retrieves the
///           parameters for a scroll bar control. The <i>hwnd</i> parameter must be the handle to the scroll bar control.
///           </td> </tr> <tr> <td width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl> <dt><b>SB_HORZ</b></dt> </dl> </td>
///           <td width="60%"> Retrieves the parameters for the window's standard horizontal scroll bar. </td> </tr> <tr> <td
///           width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td> <td width="60%">
///           Retrieves the parameters for the window's standard vertical scroll bar. </td> </tr> </table>
///    lpsi = Type: <b>LPSCROLLINFO</b> Pointer to a SCROLLINFO structure. Before calling <b>GetScrollInfo</b>, set the
///           <b>cbSize</b> member to <b>sizeof</b>(<b>SCROLLINFO</b>), and set the <b>fMask</b> member to specify the scroll
///           bar parameters to retrieve. Before returning, the function copies the specified parameters to the appropriate
///           members of the structure. The <b>fMask</b> member can be one or more of the following values. <table> <tr>
///           <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SIF_PAGE"></a><a id="sif_page"></a><dl>
///           <dt><b>SIF_PAGE</b></dt> </dl> </td> <td width="60%"> Copies the scroll page to the <b>nPage</b> member of the
///           SCROLLINFO structure pointed to by <i>lpsi</i>. </td> </tr> <tr> <td width="40%"><a id="SIF_POS"></a><a
///           id="sif_pos"></a><dl> <dt><b>SIF_POS</b></dt> </dl> </td> <td width="60%"> Copies the scroll position to the
///           <b>nPos</b> member of the SCROLLINFO structure pointed to by <i>lpsi</i>. </td> </tr> <tr> <td width="40%"><a
///           id="SIF_RANGE"></a><a id="sif_range"></a><dl> <dt><b>SIF_RANGE</b></dt> </dl> </td> <td width="60%"> Copies the
///           scroll range to the <b>nMin</b> and <b>nMax</b> members of the SCROLLINFO structure pointed to by <i>lpsi</i>.
///           </td> </tr> <tr> <td width="40%"><a id="SIF_TRACKPOS"></a><a id="sif_trackpos"></a><dl>
///           <dt><b>SIF_TRACKPOS</b></dt> </dl> </td> <td width="60%"> Copies the current scroll box tracking position to the
///           <b>nTrackPos</b> member of the SCROLLINFO structure pointed to by <i>lpsi</i>. </td> </tr> </table>
///Returns:
///    Type: <b>BOOL</b> If the function retrieved any values, the return value is nonzero. If the function does not
///    retrieve any values, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL GetScrollInfo(HWND hwnd, int nBar, SCROLLINFO* lpsi);

///The <b>GetScrollBarInfo</b> function retrieves information about the specified scroll bar.
///Params:
///    hwnd = Type: <b>HWND</b> Handle to a window associated with the scroll bar whose information is to be retrieved. If the
///           <i>idObject</i> parameter is OBJID_CLIENT, <i>hwnd</i> is a handle to a scroll bar control. Otherwise,
///           <i>hwnd</i> is a handle to a window created with WS_VSCROLL and/or WS_HSCROLL style.
///    idObject = Type: <b>LONG</b> Specifies the scroll bar object. This parameter can be one of the following values. <table>
///               <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="OBJID_CLIENT"></a><a
///               id="objid_client"></a><dl> <dt><b>OBJID_CLIENT</b></dt> </dl> </td> <td width="60%"> The <i>hwnd</i> parameter is
///               a handle to a scroll bar control. </td> </tr> <tr> <td width="40%"><a id="OBJID_HSCROLL"></a><a
///               id="objid_hscroll"></a><dl> <dt><b>OBJID_HSCROLL</b></dt> </dl> </td> <td width="60%"> The horizontal scroll bar
///               of the <i>hwnd</i> window. </td> </tr> <tr> <td width="40%"><a id="OBJID_VSCROLL"></a><a
///               id="objid_vscroll"></a><dl> <dt><b>OBJID_VSCROLL</b></dt> </dl> </td> <td width="60%"> The vertical scroll bar of
///               the <i>hwnd</i> window. </td> </tr> </table>
///    psbi = Type: <b>PSCROLLBARINFO</b> Pointer to a SCROLLBARINFO structure to receive the information. Before calling
///           <b>GetScrollBarInfo</b>, set the <b>cbSize</b> member to <b>sizeof</b>(<b>SCROLLBARINFO</b>).
///Returns:
///    Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value
///    is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL GetScrollBarInfo(HWND hwnd, int idObject, SCROLLBARINFO* psbi);

///Retrieves information about the specified combo box.
///Params:
///    hwndCombo = Type: <b>HWND</b> A handle to the combo box.
///    pcbi = Type: <b>PCOMBOBOXINFO</b> A pointer to a COMBOBOXINFO structure that receives the information. You must set
///           <b>COMBOBOXINFO.cbSize</b> before calling this function.
///Returns:
///    Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value
///    is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL GetComboBoxInfo(HWND hwndCombo, COMBOBOXINFO* pcbi);

///Retrieves the number of items per column in a specified list box.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to the list box whose number of items per column is to be retrieved.
///Returns:
///    Type: <b>DWORD</b> The return value is the number of items per column.
///    
@DllImport("USER32")
uint GetListBoxInfo(HWND hwnd);

///Gets information about the pointer devices attached to the system.
///Params:
///    deviceCount = If <i>pointerDevices</i> is NULL, <i>deviceCount</i> returns the total number of attached pointer devices.
///                  Otherwise, <i>deviceCount</i> specifies the number of POINTER_DEVICE_INFO structures pointed to by
///                  <i>pointerDevices</i>.
///    pointerDevices = Array of POINTER_DEVICE_INFO structures for the pointer devices attached to the system. If NULL, the total number
///                     of attached pointer devices is returned in <i>deviceCount</i>.
///Returns:
///    If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information,
///    call the GetLastError function.
///    
@DllImport("USER32")
BOOL GetPointerDevices(uint* deviceCount, POINTER_DEVICE_INFO* pointerDevices);

///Gets information about the pointer device.
///Params:
///    device = The handle to the device.
///    pointerDevice = A POINTER_DEVICE_INFO structure that contains information about the pointer device.
///Returns:
///    If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information,
///    call the GetLastError function.
///    
@DllImport("USER32")
BOOL GetPointerDevice(HANDLE device, POINTER_DEVICE_INFO* pointerDevice);

///Gets device properties that aren't included in the POINTER_DEVICE_INFO structure.
///Params:
///    device = The pointer device to query properties from. A call to the GetPointerDevices function returns this handle in the
///             POINTER_DEVICE_INFO structure.
///    propertyCount = The number of properties. Returns the count that's written or needed if <i>pointerProperties</i> is NULL. If this
///                    value is less than the number of properties that the pointer device supports and <i>pointerProperties</i> is not
///                    NULL, the function returns the actual number of properties in this variable and fails.
///    pointerProperties = The array of properties.
///Returns:
///    TRUE if the function succeeds; otherwise, FALSE. If the function fails, call the GetLastError function for more
///    information.
///    
@DllImport("USER32")
BOOL GetPointerDeviceProperties(HANDLE device, uint* propertyCount, POINTER_DEVICE_PROPERTY* pointerProperties);

///Registers a window to process the WM_POINTERDEVICECHANGE, WM_POINTERDEVICEINRANGE, and WM_POINTERDEVICEOUTOFRANGE
///pointer device notifications.
///Params:
///    window = The window that receives WM_POINTERDEVICECHANGE, WM_POINTERDEVICEINRANGE, and WM_POINTERDEVICEOUTOFRANGE
///             notifications.
///    notifyRange = If set to TRUE, process the WM_POINTERDEVICEINRANGE and WM_POINTERDEVICEOUTOFRANGE messages. If set to FALSE,
///                  these messages aren't processed.
///Returns:
///    If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information,
///    call the GetLastError function.
///    
@DllImport("USER32")
BOOL RegisterPointerDeviceNotifications(HWND window, BOOL notifyRange);

///Gets the x and y range for the pointer device (in himetric) and the x and y range (current resolution) for the
///display that the pointer device is mapped to.
///Params:
///    device = The handle to the pointer device.
///    pointerDeviceRect = The structure for retrieving the device's physical range data.
///    displayRect = The structure for retrieving the display resolution.
///Returns:
///    TRUE if the function succeeds; otherwise, FALSE. If the function fails, call the GetLastError function for more
///    information.
///    
@DllImport("USER32")
BOOL GetPointerDeviceRects(HANDLE device, RECT* pointerDeviceRect, RECT* displayRect);

///Gets the cursor IDs that are mapped to the cursors associated with a pointer device.
///Params:
///    device = The device handle.
///    cursorCount = The number of cursors associated with the pointer device.
///    deviceCursors = An array of POINTER_DEVICE_CURSOR_INFO structures that contain info about the cursors. If NULL,
///                    <i>cursorCount</i> returns the number of cursors associated with the pointer device.
///Returns:
///    TRUE if the function succeeds; otherwise, FALSE. If the function fails, call the GetLastError function for more
///    information.
///    
@DllImport("USER32")
BOOL GetPointerDeviceCursors(HANDLE device, uint* cursorCount, POINTER_DEVICE_CURSOR_INFO* deviceCursors);

///Gets the raw input data from the pointer device.
///Params:
///    pointerId = An identifier of the pointer for which to retrieve information.
///    historyCount = The pointer history.
///    propertiesCount = Number of properties to retrieve.
///    pProperties = Array of POINTER_DEVICE_PROPERTY structures that contain raw data reported by the device.
///    pValues = The values for <i>pProperties</i>.
///Returns:
///    TRUE if the function succeeds; otherwise, FALSE. If the function fails, call the GetLastError function for more
///    information.
///    
@DllImport("USER32")
BOOL GetRawPointerDeviceData(uint pointerId, uint historyCount, uint propertiesCount, 
                             POINTER_DEVICE_PROPERTY* pProperties, int* pValues);

///Retrieves the source of the input message.
///Params:
///    inputMessageSource = The INPUT_MESSAGE_SOURCE structure that holds the device type and the ID of the input message source. <div
///                         class="alert"><b>Note</b> <b>deviceType</b> in INPUT_MESSAGE_SOURCE is set to IMDT_UNAVAILABLE when SendMessage
///                         is used to inject input (system generated or through messages such as WM_PAINT). This remains true until
///                         <b>SendMessage</b> returns.</div> <div> </div>
///Returns:
///    If this function succeeds, it returns TRUE. Otherwise, it returns FALSE. To retrieve extended error information,
///    call the GetLastError function.
///    
@DllImport("USER32")
BOOL GetCurrentInputMessageSource(INPUT_MESSAGE_SOURCE* inputMessageSource);

///<p class="CCE_Message">[<b>GetCIMSSM</b> may be altered or unavailable in the future. Instead, use
///GetCurrentInputMessageSource.] Retrieves the source of the input message (GetCurrentInputMessageSourceInSendMessage).
///Params:
///    inputMessageSource = The INPUT_MESSAGE_SOURCE structure that holds the device type and the ID of the input message source.
///Returns:
///    If this function succeeds, it returns TRUE. Otherwise, it returns ERROR_INVALID_PARAMETER. This function fails
///    when:<ul> <li>The input parameter is invalid.</li> <li> GetCurrentInputMessageSource returns a value other than
///    IMDT_UNAVAILABLE for the device type.</li> </ul>
///    
@DllImport("USER32")
BOOL GetCIMSSM(INPUT_MESSAGE_SOURCE* inputMessageSource);

///Creates a new page for a property sheet.
///Params:
///    constPropSheetPagePointer = Type: <b>LPCPROPSHEETPAGE</b> Pointer to a PROPSHEETPAGE structure that defines a page to be included in a
///                                property sheet.
///Returns:
///    Type: <b>HPROPSHEETPAGE</b> Returns the handle to the new property page if successful, or <b>NULL</b> otherwise.
///    
@DllImport("COMCTL32")
HPROPSHEETPAGE CreatePropertySheetPageA(PROPSHEETPAGEA* constPropSheetPagePointer);

///Creates a new page for a property sheet.
///Params:
///    constPropSheetPagePointer = Type: <b>LPCPROPSHEETPAGE</b> Pointer to a PROPSHEETPAGE structure that defines a page to be included in a
///                                property sheet.
///Returns:
///    Type: <b>HPROPSHEETPAGE</b> Returns the handle to the new property page if successful, or <b>NULL</b> otherwise.
///    
@DllImport("COMCTL32")
HPROPSHEETPAGE CreatePropertySheetPageW(PROPSHEETPAGEW* constPropSheetPagePointer);

///Destroys a property sheet page. An application must call this function for pages that have not been passed to the
///PropertySheet function.
///Params:
///    Arg1 = Type: <b>HPROPSHEETPAGE</b> Handle to the property sheet page to delete.
@DllImport("COMCTL32")
BOOL DestroyPropertySheetPage(HPROPSHEETPAGE param0);

///Creates a property sheet and adds the pages defined in the specified property sheet header structure.
///Params:
///    Arg1 = Type: <b>LPCPROPSHEETHEADER</b> Pointer to a PROPSHEETHEADER structure that defines the frame and pages of a
///           property sheet.
///Returns:
///    Type: <b>INT_PTR</b> For modal property sheets, the return value is as follows: <table class="clsStd"> <tr>
///    <td>&gt;=1</td> <td>Changes were saved by the user.</td> </tr> <tr> <td>0</td> <td>No changes were saved by the
///    user.</td> </tr> <tr> <td>-1</td> <td>An error occurred.</td> </tr> </table> For modeless property sheets, the
///    return value is the property sheet's window handle. The following return values have a special meaning. <table>
///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ID_PSREBOOTSYSTEM</b></dt>
///    </dl> </td> <td width="60%"> A page sent the PSM_REBOOTSYSTEM message to the property sheet. The computer must be
///    restarted for the user's changes to take effect. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ID_PSRESTARTWINDOWS</b></dt> </dl> </td> <td width="60%"> A page sent the PSM_RESTARTWINDOWS message to
///    the property sheet. Windows must be restarted for the user's changes to take effect. </td> </tr> </table>
///    
@DllImport("COMCTL32")
ptrdiff_t PropertySheetA(PROPSHEETHEADERA_V2* param0);

///Creates a property sheet and adds the pages defined in the specified property sheet header structure.
///Params:
///    Arg1 = Type: <b>LPCPROPSHEETHEADER</b> Pointer to a PROPSHEETHEADER structure that defines the frame and pages of a
///           property sheet.
///Returns:
///    Type: <b>INT_PTR</b> For modal property sheets, the return value is as follows: <table class="clsStd"> <tr>
///    <td>&gt;=1</td> <td>Changes were saved by the user.</td> </tr> <tr> <td>0</td> <td>No changes were saved by the
///    user.</td> </tr> <tr> <td>-1</td> <td>An error occurred.</td> </tr> </table> For modeless property sheets, the
///    return value is the property sheet's window handle. The following return values have a special meaning. <table>
///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ID_PSREBOOTSYSTEM</b></dt>
///    </dl> </td> <td width="60%"> A page sent the PSM_REBOOTSYSTEM message to the property sheet. The computer must be
///    restarted for the user's changes to take effect. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ID_PSRESTARTWINDOWS</b></dt> </dl> </td> <td width="60%"> A page sent the PSM_RESTARTWINDOWS message to
///    the property sheet. Windows must be restarted for the user's changes to take effect. </td> </tr> </table>
///    
@DllImport("COMCTL32")
ptrdiff_t PropertySheetW(PROPSHEETHEADERW_V2* param0);

///Registers and initializes certain common control window classes. This function is obsolete. New applications should
///use the InitCommonControlsEx function.
@DllImport("COMCTL32")
void InitCommonControls();

///Ensures that the common control DLL (Comctl32.dll) is loaded, and registers specific common control classes from the
///DLL. An application must call this function before creating a common control.
///Params:
///    picce = Type: <b>const LPINITCOMMONCONTROLSEX</b> A pointer to an INITCOMMONCONTROLSEX structure that contains
///            information specifying which control classes will be registered.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
///    
@DllImport("COMCTL32")
BOOL InitCommonControlsEx(const(INITCOMMONCONTROLSEX)* picce);

///Creates a new image list.
///Params:
///    cx = Type: <b>int</b> The width, in pixels, of each image.
///    cy = Type: <b>int</b> The height, in pixels, of each image.
///    flags = Type: <b>UINT</b> A set of bit flags that specify the type of image list to create. This parameter can be a
///            combination of the Image List Creation Flags.
///    cInitial = Type: <b>int</b> The number of images that the image list initially contains.
///    cGrow = Type: <b>int</b> The number of images by which the image list can grow when the system needs to make room for new
///            images. This parameter represents the number of new images that the resized image list can contain.
///Returns:
///    Type: <b>HIMAGELIST</b> Returns the handle to the image list if successful, or <b>NULL</b> otherwise.
///    
@DllImport("COMCTL32")
HIMAGELIST ImageList_Create(int cx, int cy, uint flags, int cInitial, int cGrow);

///Destroys an image list.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list to destroy.
@DllImport("COMCTL32")
BOOL ImageList_Destroy(HIMAGELIST himl);

///Retrieves the number of images in an image list.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
@DllImport("COMCTL32")
int ImageList_GetImageCount(HIMAGELIST himl);

///Resizes an existing image list.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list that will be resized.
///    uNewCount = Type: <b>UINT</b> A value specifying the new size of the image list.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL ImageList_SetImageCount(HIMAGELIST himl, uint uNewCount);

///Adds an image or images to an image list.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    hbmImage = Type: <b>HBITMAP</b> A handle to the bitmap that contains the image or images. The number of images is inferred
///               from the width of the bitmap.
///    hbmMask = Type: <b>HBITMAP</b> A handle to the bitmap that contains the mask. If no mask is used with the image list, this
///              parameter is ignored. This parameter can be <b>NULL</b>.
///Returns:
///    Type: <b>int</b> Returns the index of the first new image if successful, or -1 otherwise.
///    
@DllImport("COMCTL32")
int ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask);

///Replaces an image with an icon or cursor.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    i = Type: <b>int</b> The index of the image to replace. If <i>i</i> is -1, the function appends the image to the end
///        of the list.
///    hicon = Type: <b>HICON</b> The handle to the icon or cursor that contains the bitmap and mask for the new image.
///Returns:
///    Type: <b>int</b> Returns the index of the image if successful, or -1 otherwise.
///    
@DllImport("COMCTL32")
int ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon);

///Sets the background color for an image list. This function only works if you add an icon or use ImageList_AddMasked
///with a black and white bitmap. Without a mask, the entire image is drawn; hence the background color is not visible.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    clrBk = Type: <b>COLORREF</b> The background color to set. This parameter can be the CLR_NONE value; in that case, images
///            are drawn transparently using the mask.
@DllImport("COMCTL32")
uint ImageList_SetBkColor(HIMAGELIST himl, uint clrBk);

///Retrieves the current background color for an image list.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
@DllImport("COMCTL32")
uint ImageList_GetBkColor(HIMAGELIST himl);

///Adds a specified image to the list of images to be used as overlay masks. An image list can have up to four overlay
///masks in version 4.70 and earlier and up to 15 in version 4.71. The function assigns an overlay mask index to the
///specified image.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    iImage = Type: <b>int</b> The zero-based index of an image in the <i>himl</i> image list. This index identifies the image
///             to use as an overlay mask.
///    iOverlay = Type: <b>int</b> The one-based index of the overlay mask.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL ImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay);

///Draws an image list item in the specified device context.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    i = Type: <b>int</b> The zero-based index of the image to draw.
///    hdcDst = Type: <b>HDC</b> A handle to the destination device context.
///    x = Type: <b>int</b> The x-coordinate at which to draw within the specified device context.
///    y = Type: <b>int</b> The y-coordinate at which to draw within the specified device context.
///    fStyle = Type: <b>UINT</b> The drawing style and, optionally, the overlay image. For information about specifying an
///             overlay image index, see the comments section at the end of this topic. This parameter can be a combination of an
///             overlay image index and one or more of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///             <tr> <td width="40%"><a id="ILD_BLEND"></a><a id="ild_blend"></a><dl> <dt><b>ILD_BLEND</b></dt> </dl> </td> <td
///             width="60%"></td> </tr> <tr> <td width="40%"><a id="ILD_BLEND25"></a><a id="ild_blend25"></a><dl>
///             <dt><b>ILD_BLEND25</b></dt> </dl> </td> <td width="60%"> Draws the image, blending 25 percent with the system
///             highlight color. This value has no effect if the image list does not contain a mask. </td> </tr> <tr> <td
///             width="40%"><a id="ILD_BLEND50"></a><a id="ild_blend50"></a><dl> <dt><b>ILD_BLEND50</b></dt> </dl> </td> <td
///             width="60%"> Draws the image, blending 50 percent with the system highlight color. This value has no effect if
///             the image list does not contain a mask. </td> </tr> <tr> <td width="40%"><a id="ILD_FOCUS"></a><a
///             id="ild_focus"></a><dl> <dt><b>ILD_FOCUS</b></dt> </dl> </td> <td width="60%"></td> </tr> <tr> <td width="40%"><a
///             id="ILD_IMAGE"></a><a id="ild_image"></a><dl> <dt><b>ILD_IMAGE</b></dt> </dl> </td> <td width="60%"> Set this
///             flag if the overlay does not require a mask to be drawn. This flag causes ImageList_DrawEx to draw just the
///             image, ignoring the mask. </td> </tr> <tr> <td width="40%"><a id="ILD_MASK"></a><a id="ild_mask"></a><dl>
///             <dt><b>ILD_MASK</b></dt> </dl> </td> <td width="60%"> Draws the mask. </td> </tr> <tr> <td width="40%"><a
///             id="ILD_NORMAL"></a><a id="ild_normal"></a><dl> <dt><b>ILD_NORMAL</b></dt> </dl> </td> <td width="60%"> Draws the
///             image using the background color for the image list. If the background color is the CLR_NONE value, the image is
///             drawn transparently using the mask. </td> </tr> <tr> <td width="40%"><a id="ILD_SELECTED"></a><a
///             id="ild_selected"></a><dl> <dt><b>ILD_SELECTED</b></dt> </dl> </td> <td width="60%"></td> </tr> <tr> <td
///             width="40%"><a id="ILD_TRANSPARENT"></a><a id="ild_transparent"></a><dl> <dt><b>ILD_TRANSPARENT</b></dt> </dl>
///             </td> <td width="60%"> Draws the image transparently using the mask, regardless of the background color. This
///             value has no effect if the image list does not contain a mask. </td> </tr> </table>
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL ImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, uint fStyle);

///Replaces an image in an image list with a new image.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    i = Type: <b>int</b> An index of the image to replace.
///    hbmImage = Type: <b>HBITMAP</b> A handle to the bitmap that contains the image.
///    hbmMask = Type: <b>HBITMAP</b> A handle to the bitmap that contains the mask. If no mask is used with the image list, this
///              parameter is ignored.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL ImageList_Replace(HIMAGELIST himl, int i, HBITMAP hbmImage, HBITMAP hbmMask);

///Adds an image or images to an image list, generating a mask from the specified bitmap.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    hbmImage = Type: <b>HBITMAP</b> A handle to the bitmap that contains one or more images. The number of images is inferred
///               from the width of the bitmap.
///    crMask = Type: <b>COLORREF</b> The color used to generate the mask. Each pixel of this color in the specified bitmap is
///             changed to black, and the corresponding bit in the mask is set to 1.
///Returns:
///    Type: <b>int</b> Returns the index of the first new image if successful, or -1 otherwise.
///    
@DllImport("COMCTL32")
int ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, uint crMask);

///Draws an image list item in the specified device context. The function uses the specified drawing style and blends
///the image with the specified color.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list
///    i = Type: <b>int</b> The index of the image to draw.
///    hdcDst = Type: <b>HDC</b> A handle to the destination device context.
///    x = Type: <b>int</b> The x-coordinate at which to draw within the specified device context.
///    y = Type: <b>int</b> The y-coordinate at which to draw within the specified device context.
///    dx = Type: <b>int</b> The width of the portion of the image to draw relative to the upper-left corner of the image. If
///         <i>dx</i> and <i>dy</i> are zero, the function draws the entire image. The function does not ensure that the
///         parameters are valid.
///    dy = Type: <b>int</b> The height of the portion of the image to draw, relative to the upper-left corner of the image.
///         If <i>dx</i> and <i>dy</i> are zero, the function draws the entire image. The function does not ensure that the
///         parameters are valid.
///    rgbBk = Type: <b>COLORREF</b> The background color of the image. This parameter can be an application-defined RGB value
///            or one of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="CLR_NONE"></a><a id="clr_none"></a><dl> <dt><b>CLR_NONE</b></dt> </dl> </td> <td width="60%"> No background
///            color. The image is drawn transparently. </td> </tr> <tr> <td width="40%"><a id="CLR_DEFAULT"></a><a
///            id="clr_default"></a><dl> <dt><b>CLR_DEFAULT</b></dt> </dl> </td> <td width="60%"> The default background color.
///            The image is drawn using the background color of the image list. </td> </tr> </table>
///    rgbFg = Type: <b>COLORREF</b> The foreground color of the image. This parameter can be an application-defined RGB value
///            or one of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="CLR_NONE"></a><a id="clr_none"></a><dl> <dt><b>CLR_NONE</b></dt> </dl> </td> <td width="60%"> No blend color.
///            The image is blended with the color of the destination device context. </td> </tr> <tr> <td width="40%"><a
///            id="CLR_DEFAULT"></a><a id="clr_default"></a><dl> <dt><b>CLR_DEFAULT</b></dt> </dl> </td> <td width="60%"> The
///            default foreground color. The image is drawn using the system highlight color as the foreground color. </td>
///            </tr> </table>
///    fStyle = Type: <b>UINT</b> The drawing style and, optionally, the overlay image. For information about specifying an
///             overlay image index, see the comments section at the end of this topic. This parameter can be a combination of an
///             overlay image index and one or more of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///             <tr> <td width="40%"><a id="ILD_BLEND"></a><a id="ild_blend"></a><dl> <dt><b>ILD_BLEND</b></dt> </dl> </td> <td
///             width="60%"></td> </tr> <tr> <td width="40%"><a id="ILD_BLEND25"></a><a id="ild_blend25"></a><dl>
///             <dt><b>ILD_BLEND25</b></dt> </dl> </td> <td width="60%"> Draws the image, blending 25 percent with the blend
///             color specified by <i>rgbFg</i>. This value has no effect if the image list does not contain a mask. </td> </tr>
///             <tr> <td width="40%"><a id="ILD_BLEND50"></a><a id="ild_blend50"></a><dl> <dt><b>ILD_BLEND50</b></dt> </dl> </td>
///             <td width="60%"> Draws the image, blending 50 percent with the blend color specified by <i>rgbFg</i>. This value
///             has no effect if the image list does not contain a mask. </td> </tr> <tr> <td width="40%"><a
///             id="ILD_FOCUS"></a><a id="ild_focus"></a><dl> <dt><b>ILD_FOCUS</b></dt> </dl> </td> <td width="60%"></td> </tr>
///             <tr> <td width="40%"><a id="ILD_IMAGE"></a><a id="ild_image"></a><dl> <dt><b>ILD_IMAGE</b></dt> </dl> </td> <td
///             width="60%"> Set this flag if the overlay does not require a mask to be drawn. This flag causes
///             <b>ImageList_DrawEx</b> to draw just the image, ignoring the mask. </td> </tr> <tr> <td width="40%"><a
///             id="ILD_MASK"></a><a id="ild_mask"></a><dl> <dt><b>ILD_MASK</b></dt> </dl> </td> <td width="60%"> Draws the mask.
///             </td> </tr> <tr> <td width="40%"><a id="ILD_NORMAL"></a><a id="ild_normal"></a><dl> <dt><b>ILD_NORMAL</b></dt>
///             </dl> </td> <td width="60%"> Draws the image using the background color for the image list. If the background
///             color is the CLR_NONE value, the image is drawn transparently using the mask. </td> </tr> <tr> <td width="40%"><a
///             id="ILD_SELECTED"></a><a id="ild_selected"></a><dl> <dt><b>ILD_SELECTED</b></dt> </dl> </td> <td
///             width="60%"></td> </tr> <tr> <td width="40%"><a id="ILD_TRANSPARENT"></a><a id="ild_transparent"></a><dl>
///             <dt><b>ILD_TRANSPARENT</b></dt> </dl> </td> <td width="60%"> Draws the image transparently using the mask,
///             regardless of the background color. This value has no effect if the image list does not contain a mask. </td>
///             </tr> </table>
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, uint rgbBk, uint rgbFg, 
                      uint fStyle);

///Draws an image list image based on an IMAGELISTDRAWPARAMS structure.
///Params:
///    pimldp = Type: <b>IMAGELISTDRAWPARAMS*</b> A pointer to an IMAGELISTDRAWPARAMS structure that contains information about
///             the draw operation.
@DllImport("COMCTL32")
BOOL ImageList_DrawIndirect(IMAGELISTDRAWPARAMS* pimldp);

///Removes an image from an image list.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    i = Type: <b>int</b> The index of the image to remove. If this parameter is -1, the function removes all images.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL ImageList_Remove(HIMAGELIST himl, int i);

///Creates an icon from an image and mask in an image list.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    i = Type: <b>int</b> An index of the image.
///    flags = Type: <b>UINT</b> A combination of flags that specify the drawing style. For a list of values, see the
///            description of the <i>fStyle</i> parameter of the ImageList_Draw function.
///Returns:
///    Type: <b>HICON</b> Returns the handle to the icon if successful, or <b>NULL</b> otherwise.
///    
@DllImport("COMCTL32")
HICON ImageList_GetIcon(HIMAGELIST himl, int i, uint flags);

///Creates an image list from the specified bitmap.
///Params:
///    hi = Type: <b>HINSTANCE</b> A handle to the instance that contains the resource. This parameter can be <b>NULL</b> if
///         you are loading an image from a file or loading an OEM resource.
///    lpbmp = Type: <b>LPCTSTR</b> The image to load. If the <i>uFlags</i> parameter includes LR_LOADFROMFILE, <i>lpbmp</i> is
///            the address of a null-terminated string that names the file containing the image to load. If the <i>hi</i>
///            parameter is non-<b>NULL</b> and LR_LOADFROMFILE is not specified, <i>lpbmp</i> is the address of a
///            null-terminated string that contains the name of the image resource in the <i>hi</i> module. If <i>hi</i> is
///            <b>NULL</b> and LR_LOADFROMFILE is not specified, the LOWORD of this parameter must be the identifier of an OEM
///            image to load. To create this value, use the MAKEINTRESOURCE macro with one of the OEM image identifiers defined
///            in Winuser.h. These identifiers have the following prefixes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///            <tr> <td width="40%"><a id="OBM__for_OEM_bitmaps"></a><a id="obm__for_oem_bitmaps"></a><a
///            id="OBM__FOR_OEM_BITMAPS"></a><dl> <dt><b>OBM_ for OEM bitmaps</b></dt> </dl> </td> <td width="60%"></td> </tr>
///            <tr> <td width="40%"><a id="OIC__for_OEM_icons"></a><a id="oic__for_oem_icons"></a><a
///            id="OIC__FOR_OEM_ICONS"></a><dl> <dt><b>OIC_ for OEM icons</b></dt> </dl> </td> <td width="60%"></td> </tr> <tr>
///            <td width="40%"><a id="OCR__for_OEM_cursors"></a><a id="ocr__for_oem_cursors"></a><a
///            id="OCR__FOR_OEM_CURSORS"></a><dl> <dt><b>OCR_ for OEM cursors</b></dt> </dl> </td> <td width="60%"></td> </tr>
///            </table>
///    cx = Type: <b>int</b> The width of each image. The height of each image and the initial number of images are inferred
///         by the dimensions of the specified resource.
///    cGrow = Type: <b>int</b> The number of images by which the image list can grow when the system needs to make room for new
///            images. This parameter represents the number of new images that the resized image list can contain.
///    crMask = Type: <b>COLORREF</b> The color used to generate a mask. Each pixel of this color in the specified bitmap,
///             cursor, or icon is changed to black, and the corresponding bit in the mask is set to 1. If this parameter is the
///             CLR_NONE value, no mask is generated. If this parameter is the CLR_DEFAULT value, the color of the pixel at the
///             upper-left corner of the image is treated as the mask color.
///    uType = Type: <b>UINT</b> A flag that specifies the type of image to load. This parameter must be IMAGE_BITMAP to
///            indicate that a bitmap is being loaded. <div class="alert"><b>Note</b> <b>ImageList_LoadImage</b> is for use only
///            with bitmap files. No other image types are supported.</div> <div> </div> <table> <tr> <th>Value</th>
///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IMAGE_BITMAP"></a><a id="image_bitmap"></a><dl>
///            <dt><b>IMAGE_BITMAP</b></dt> </dl> </td> <td width="60%"> Loads a bitmap. </td> </tr> </table>
///    uFlags = Type: <b>UINT</b> Flags that specify how to load the image. This parameter can be a combination of the following
///             values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///             id="LR_CREATEDIBSECTION"></a><a id="lr_createdibsection"></a><dl> <dt><b>LR_CREATEDIBSECTION</b></dt> </dl> </td>
///             <td width="60%"> Causes the function to return a DIB section bitmap rather than a compatible bitmap when the
///             <i>uType</i> parameter specifies IMAGE_BITMAP. LR_CREATEDIBSECTION is useful for loading a bitmap without mapping
///             it to the colors of the display device. </td> </tr> <tr> <td width="40%"><a id="LR_DEFAULTCOLOR"></a><a
///             id="lr_defaultcolor"></a><dl> <dt><b>LR_DEFAULTCOLOR</b></dt> </dl> </td> <td width="60%"> Uses the color format
///             of the display. </td> </tr> <tr> <td width="40%"><a id="LR_DEFAULTSIZE"></a><a id="lr_defaultsize"></a><dl>
///             <dt><b>LR_DEFAULTSIZE</b></dt> </dl> </td> <td width="60%"> Uses the width or height specified by the system
///             metric values for cursors and icons if the <i>cx</i> parameter is set to zero. If this value is not specified and
///             <i>cx</i> is set to zero, the function sets the size to the one specified in the resource. If the resource
///             contains multiple images, the function sets the size to that of the first image. </td> </tr> <tr> <td
///             width="40%"><a id="LR_LOADFROMFILE"></a><a id="lr_loadfromfile"></a><dl> <dt><b>LR_LOADFROMFILE</b></dt> </dl>
///             </td> <td width="60%"> Loads the image from the file specified by the <i>lpbmp</i> parameter. </td> </tr> <tr>
///             <td width="40%"><a id="LR_LOADMAP3DCOLORS"></a><a id="lr_loadmap3dcolors"></a><dl>
///             <dt><b>LR_LOADMAP3DCOLORS</b></dt> </dl> </td> <td width="60%"> Searches the color table for the image and
///             replaces the following shades of gray with the corresponding three-dimensional color: Dk Gray: RGB(128, 128,
///             128)COLOR_3DSHADOW Gray: RGB(192, 192, 192)COLOR_3DFACE Lt Gray: RGB(223, 223, 223)COLOR_3DLIGHT For more
///             information, see the Remarks section. </td> </tr> <tr> <td width="40%"><a id="LR_LOADTRANSPARENT"></a><a
///             id="lr_loadtransparent"></a><dl> <dt><b>LR_LOADTRANSPARENT</b></dt> </dl> </td> <td width="60%"> Retrieves the
///             color value of the first pixel in the image and replaces the corresponding entry in the color table with the
///             default window color (the COLOR_WINDOW display color). All pixels in the image that use that color become the
///             default window value color. This value applies only to images that have a corresponding color table. For more
///             information, see the Remarks section. </td> </tr> <tr> <td width="40%"><a id="LR_MONOCHROME"></a><a
///             id="lr_monochrome"></a><dl> <dt><b>LR_MONOCHROME</b></dt> </dl> </td> <td width="60%"> Loads the image in black
///             and white. </td> </tr> <tr> <td width="40%"><a id="LR_SHARED"></a><a id="lr_shared"></a><dl>
///             <dt><b>LR_SHARED</b></dt> </dl> </td> <td width="60%"> Shares the image handle if the image is loaded multiple
///             times. Do not use this value for images that have nontraditional sizes that might change after loading or for
///             images that are loaded from a file. </td> </tr> </table>
///Returns:
///    Type: <b>HIMAGELIST</b> Returns the handle to the image list if successful, or <b>NULL</b> otherwise.
///    
@DllImport("COMCTL32")
HIMAGELIST ImageList_LoadImageA(HINSTANCE hi, const(PSTR) lpbmp, int cx, int cGrow, uint crMask, uint uType, 
                                uint uFlags);

///Creates an image list from the specified bitmap.
///Params:
///    hi = Type: <b>HINSTANCE</b> A handle to the instance that contains the resource. This parameter can be <b>NULL</b> if
///         you are loading an image from a file or loading an OEM resource.
///    lpbmp = Type: <b>LPCTSTR</b> The image to load. If the <i>uFlags</i> parameter includes LR_LOADFROMFILE, <i>lpbmp</i> is
///            the address of a null-terminated string that names the file containing the image to load. If the <i>hi</i>
///            parameter is non-<b>NULL</b> and LR_LOADFROMFILE is not specified, <i>lpbmp</i> is the address of a
///            null-terminated string that contains the name of the image resource in the <i>hi</i> module. If <i>hi</i> is
///            <b>NULL</b> and LR_LOADFROMFILE is not specified, the LOWORD of this parameter must be the identifier of an OEM
///            image to load. To create this value, use the MAKEINTRESOURCE macro with one of the OEM image identifiers defined
///            in Winuser.h. These identifiers have the following prefixes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///            <tr> <td width="40%"><a id="OBM__for_OEM_bitmaps"></a><a id="obm__for_oem_bitmaps"></a><a
///            id="OBM__FOR_OEM_BITMAPS"></a><dl> <dt><b>OBM_ for OEM bitmaps</b></dt> </dl> </td> <td width="60%"></td> </tr>
///            <tr> <td width="40%"><a id="OIC__for_OEM_icons"></a><a id="oic__for_oem_icons"></a><a
///            id="OIC__FOR_OEM_ICONS"></a><dl> <dt><b>OIC_ for OEM icons</b></dt> </dl> </td> <td width="60%"></td> </tr> <tr>
///            <td width="40%"><a id="OCR__for_OEM_cursors"></a><a id="ocr__for_oem_cursors"></a><a
///            id="OCR__FOR_OEM_CURSORS"></a><dl> <dt><b>OCR_ for OEM cursors</b></dt> </dl> </td> <td width="60%"></td> </tr>
///            </table>
///    cx = Type: <b>int</b> The width of each image. The height of each image and the initial number of images are inferred
///         by the dimensions of the specified resource.
///    cGrow = Type: <b>int</b> The number of images by which the image list can grow when the system needs to make room for new
///            images. This parameter represents the number of new images that the resized image list can contain.
///    crMask = Type: <b>COLORREF</b> The color used to generate a mask. Each pixel of this color in the specified bitmap,
///             cursor, or icon is changed to black, and the corresponding bit in the mask is set to 1. If this parameter is the
///             CLR_NONE value, no mask is generated. If this parameter is the CLR_DEFAULT value, the color of the pixel at the
///             upper-left corner of the image is treated as the mask color.
///    uType = Type: <b>UINT</b> A flag that specifies the type of image to load. This parameter must be IMAGE_BITMAP to
///            indicate that a bitmap is being loaded. <div class="alert"><b>Note</b> <b>ImageList_LoadImage</b> is for use only
///            with bitmap files. No other image types are supported.</div> <div> </div> <table> <tr> <th>Value</th>
///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IMAGE_BITMAP"></a><a id="image_bitmap"></a><dl>
///            <dt><b>IMAGE_BITMAP</b></dt> </dl> </td> <td width="60%"> Loads a bitmap. </td> </tr> </table>
///    uFlags = Type: <b>UINT</b> Flags that specify how to load the image. This parameter can be a combination of the following
///             values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///             id="LR_CREATEDIBSECTION"></a><a id="lr_createdibsection"></a><dl> <dt><b>LR_CREATEDIBSECTION</b></dt> </dl> </td>
///             <td width="60%"> Causes the function to return a DIB section bitmap rather than a compatible bitmap when the
///             <i>uType</i> parameter specifies IMAGE_BITMAP. LR_CREATEDIBSECTION is useful for loading a bitmap without mapping
///             it to the colors of the display device. </td> </tr> <tr> <td width="40%"><a id="LR_DEFAULTCOLOR"></a><a
///             id="lr_defaultcolor"></a><dl> <dt><b>LR_DEFAULTCOLOR</b></dt> </dl> </td> <td width="60%"> Uses the color format
///             of the display. </td> </tr> <tr> <td width="40%"><a id="LR_DEFAULTSIZE"></a><a id="lr_defaultsize"></a><dl>
///             <dt><b>LR_DEFAULTSIZE</b></dt> </dl> </td> <td width="60%"> Uses the width or height specified by the system
///             metric values for cursors and icons if the <i>cx</i> parameter is set to zero. If this value is not specified and
///             <i>cx</i> is set to zero, the function sets the size to the one specified in the resource. If the resource
///             contains multiple images, the function sets the size to that of the first image. </td> </tr> <tr> <td
///             width="40%"><a id="LR_LOADFROMFILE"></a><a id="lr_loadfromfile"></a><dl> <dt><b>LR_LOADFROMFILE</b></dt> </dl>
///             </td> <td width="60%"> Loads the image from the file specified by the <i>lpbmp</i> parameter. </td> </tr> <tr>
///             <td width="40%"><a id="LR_LOADMAP3DCOLORS"></a><a id="lr_loadmap3dcolors"></a><dl>
///             <dt><b>LR_LOADMAP3DCOLORS</b></dt> </dl> </td> <td width="60%"> Searches the color table for the image and
///             replaces the following shades of gray with the corresponding three-dimensional color: Dk Gray: RGB(128, 128,
///             128)COLOR_3DSHADOW Gray: RGB(192, 192, 192)COLOR_3DFACE Lt Gray: RGB(223, 223, 223)COLOR_3DLIGHT For more
///             information, see the Remarks section. </td> </tr> <tr> <td width="40%"><a id="LR_LOADTRANSPARENT"></a><a
///             id="lr_loadtransparent"></a><dl> <dt><b>LR_LOADTRANSPARENT</b></dt> </dl> </td> <td width="60%"> Retrieves the
///             color value of the first pixel in the image and replaces the corresponding entry in the color table with the
///             default window color (the COLOR_WINDOW display color). All pixels in the image that use that color become the
///             default window value color. This value applies only to images that have a corresponding color table. For more
///             information, see the Remarks section. </td> </tr> <tr> <td width="40%"><a id="LR_MONOCHROME"></a><a
///             id="lr_monochrome"></a><dl> <dt><b>LR_MONOCHROME</b></dt> </dl> </td> <td width="60%"> Loads the image in black
///             and white. </td> </tr> <tr> <td width="40%"><a id="LR_SHARED"></a><a id="lr_shared"></a><dl>
///             <dt><b>LR_SHARED</b></dt> </dl> </td> <td width="60%"> Shares the image handle if the image is loaded multiple
///             times. Do not use this value for images that have nontraditional sizes that might change after loading or for
///             images that are loaded from a file. </td> </tr> </table>
///Returns:
///    Type: <b>HIMAGELIST</b> Returns the handle to the image list if successful, or <b>NULL</b> otherwise.
///    
@DllImport("COMCTL32")
HIMAGELIST ImageList_LoadImageW(HINSTANCE hi, const(PWSTR) lpbmp, int cx, int cGrow, uint crMask, uint uType, 
                                uint uFlags);

///Copies images within a given image list.
///Params:
///    himlDst = Type: <b>HIMAGELIST</b> A handle to an image list that is the target of the copy operation. In current versions
///              of Windows, both <i>himlDst</i> and <i>himlSrc</i> must be identical.
///    iDst = Type: <b>int</b> The zero-based index of the image to be used as the destination of the copy operation.
///    himlSrc = Type: <b>HIMAGELIST</b> A handle to an image list that is the target of the copy operation. In current versions
///              of Windows, both <i>himlDst</i> and <i>himlSrc</i> must be identical.
///    iSrc = Type: <b>int</b> The zero-based index of the image to be used as the source of the copy operation.
///    uFlags = Type: <b>UINT</b> the bit flag value that specifies the type of copy operation to be made. This parameter can be
///             one of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///             id="ILCF_MOVE"></a><a id="ilcf_move"></a><dl> <dt><b>ILCF_MOVE</b></dt> </dl> </td> <td width="60%"> The source
///             image is copied to the destination image's index. This operation results in multiple instances of a given image.
///             </td> </tr> <tr> <td width="40%"><a id="ILCF_SWAP"></a><a id="ilcf_swap"></a><dl> <dt><b>ILCF_SWAP</b></dt> </dl>
///             </td> <td width="60%"> The source and destination images exchange positions within the image list. </td> </tr>
///             </table>
@DllImport("COMCTL32")
BOOL ImageList_Copy(HIMAGELIST himlDst, int iDst, HIMAGELIST himlSrc, int iSrc, uint uFlags);

///Begins dragging an image.
///Params:
///    himlTrack = Type: <b>HIMAGELIST</b> A handle to the image list.
///    iTrack = Type: <b>int</b> The index of the image to drag.
///    dxHotspot = Type: <b>int</b> The x-coordinate of the location of the drag position relative to the upper-left corner of the
///                image.
///    dyHotspot = Type: <b>int</b> The y-coordinate of the location of the drag position relative to the upper-left corner of the
///                image.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL ImageList_BeginDrag(HIMAGELIST himlTrack, int iTrack, int dxHotspot, int dyHotspot);

///Ends a drag operation.
@DllImport("COMCTL32")
void ImageList_EndDrag();

///Displays the drag image at the specified position within the window.
///Params:
///    hwndLock = Type: <b>HWND</b> A handle to the window that owns the drag image.
///    x = Type: <b>int</b> The x-coordinate at which to display the drag image. The coordinate is relative to the
///        upper-left corner of the window, not the client area.
///    y = Type: <b>int</b> The y-coordinate at which to display the drag image. The coordinate is relative to the
///        upper-left corner of the window, not the client area.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL ImageList_DragEnter(HWND hwndLock, int x, int y);

///Unlocks the specified window and hides the drag image, allowing the window to be updated.
///Params:
///    hwndLock = Type: <b>HWND</b> A handle to the window that owns the drag image.
@DllImport("COMCTL32")
BOOL ImageList_DragLeave(HWND hwndLock);

///Moves the image that is being dragged during a drag-and-drop operation. This function is typically called in response
///to a WM_MOUSEMOVE message.
///Params:
///    x = Type: <b>int</b> The x-coordinate at which to display the drag image. The coordinate is relative to the
///        upper-left corner of the window, not the client area.
///    y = Type: <b>int</b> The y-coordinate at which to display the drag image. The coordinate is relative to the
///        upper-left corner of the window, not the client area.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL ImageList_DragMove(int x, int y);

///Creates a new drag image by combining the specified image (typically a mouse cursor image) with the current drag
///image.
///Params:
///    himlDrag = Type: <b>HIMAGELIST</b> A handle to the image list that contains the new image to combine with the drag image.
///    iDrag = Type: <b>int</b> The index of the new image to combine with the drag image.
///    dxHotspot = Type: <b>int</b> The x-position of the hot spot within the new image.
///    dyHotspot = Type: <b>int</b> The y-position of the hot spot within the new image.
@DllImport("COMCTL32")
BOOL ImageList_SetDragCursorImage(HIMAGELIST himlDrag, int iDrag, int dxHotspot, int dyHotspot);

///Shows or hides the image being dragged.
///Params:
///    fShow = Type: <b>BOOL</b> A value specifying whether to show or hide the image being dragged. Specify <b>TRUE</b> to show
///            the image or <b>FALSE</b> to hide the image.
@DllImport("COMCTL32")
BOOL ImageList_DragShowNolock(BOOL fShow);

///Retrieves the temporary image list that is used for the drag image. The function also retrieves the current drag
///position and the offset of the drag image relative to the drag position.
///Params:
///    ppt = Type: <b>POINT*</b> A pointer to a POINT structure that receives the current drag position. Can be <b>NULL</b>.
///    pptHotspot = Type: <b>POINT*</b> A pointer to a <b>POINT</b> structure that receives the offset of the drag image relative to
///                 the drag position. Can be <b>NULL</b>.
///Returns:
///    Type: <b>HIMAGELIST</b> Returns the handle to the image list if successful, or <b>NULL</b> otherwise.
///    
@DllImport("COMCTL32")
HIMAGELIST ImageList_GetDragImage(POINT* ppt, POINT* pptHotspot);

///Reads an image list from a stream.
///Params:
///    pstm = Type: <b>LPSTREAM</b> A pointer to the stream.
@DllImport("COMCTL32")
HIMAGELIST ImageList_Read(IStream pstm);

///Writes an image list to a stream.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    pstm = Type: <b>LPSTREAM</b> A pointer to the stream.
@DllImport("COMCTL32")
BOOL ImageList_Write(HIMAGELIST himl, IStream pstm);

///Reads an image list from a stream, and returns an IImageList interface to the image list.
///Params:
///    dwFlags = Type: <b>DWORD</b> A flag that specifies how the stream is read. <table> <tr> <th>Value</th> <th>Meaning</th>
///              </tr> <tr> <td width="40%"><a id="ILP_NORMAL"></a><a id="ilp_normal"></a><dl> <dt><b>ILP_NORMAL</b></dt> </dl>
///              </td> <td width="60%"> Expects an image list that was written with the ILP_NORMAL flag specified. </td> </tr>
///              <tr> <td width="40%"><a id="ILP_DOWNLEVEL"></a><a id="ilp_downlevel"></a><dl> <dt><b>ILP_DOWNLEVEL</b></dt> </dl>
///              </td> <td width="60%"> Expects an image list that was written with the ILP_DOWNLEVEL flag specified. </td> </tr>
///              </table>
///    pstm = Type: <b>LPSTREAM</b> The address of the stream.
///    riid = Type: <b>REFIID</b> An IID for the image list.
///    ppv = Type: <b>void**</b> The address of a pointer to the interface for the image list if successful, <b>NULL</b>
///          otherwise.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("COMCTL32")
HRESULT ImageList_ReadEx(uint dwFlags, IStream pstm, const(GUID)* riid, void** ppv);

///Writes an image list to a stream.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    dwFlags = Type: <b>DWORD</b> A flag that specifies how the stream is written. <table> <tr> <th>Value</th> <th>Meaning</th>
///              </tr> <tr> <td width="40%"><a id="ILP_NORMAL"></a><a id="ilp_normal"></a><dl> <dt><b>ILP_NORMAL</b></dt> </dl>
///              </td> <td width="60%"> Writes to the stream using the file format for Common Controls 6.0, which includes
///              information about image list attributes new to this version. </td> </tr> <tr> <td width="40%"><a
///              id="ILP_DOWNLEVEL"></a><a id="ilp_downlevel"></a><dl> <dt><b>ILP_DOWNLEVEL</b></dt> </dl> </td> <td width="60%">
///              Writes to the stream using a file format previous to version 6.0. Specify this flag if you need to save image
///              lists loaded under Common Controls versions earlier than version 6.0. </td> </tr> </table>
///    pstm = Type: <b>LPSTREAM</b> The address of the stream.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("COMCTL32")
HRESULT ImageList_WriteEx(HIMAGELIST himl, uint dwFlags, IStream pstm);

///Retrieves the dimensions of images in an image list. All images in an image list have the same dimensions.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    cx = Type: <b>int*</b> A pointer to an integer variable that receives the width, in pixels, of each image.
///    cy = Type: <b>int*</b> A pointer to an integer variable that receives the height, in pixels, of each image.
@DllImport("COMCTL32")
BOOL ImageList_GetIconSize(HIMAGELIST himl, int* cx, int* cy);

///Sets the dimensions of images in an image list and removes all images from the list.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    cx = Type: <b>int</b> The width, in pixels, of the images in the image list. All images in an image list have the same
///         dimensions.
///    cy = Type: <b>int</b> The height, in pixels, of the images in the image list. All images in an image list have the
///         same dimensions.
@DllImport("COMCTL32")
BOOL ImageList_SetIconSize(HIMAGELIST himl, int cx, int cy);

///Retrieves information about an image.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list.
///    i = Type: <b>int</b> The index of the image.
///    pImageInfo = Type: <b>IMAGEINFO*</b> A pointer to an IMAGEINFO structure that receives information about the image. The
///                 information in this structure can be used to directly manipulate the bitmaps for the image.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL ImageList_GetImageInfo(HIMAGELIST himl, int i, IMAGEINFO* pImageInfo);

///Creates a new image by combining two existing images. The function also creates a new image list in which to store
///the image.
///Params:
///    himl1 = Type: <b>HIMAGELIST</b> A handle to the first image list.
///    i1 = Type: <b>int</b> The index of the first existing image.
///    himl2 = Type: <b>HIMAGELIST</b> A handle to the second image list.
///    i2 = Type: <b>int</b> The index of the second existing image.
///    dx = Type: <b>int</b> The x-offset of the second image relative to the first image.
///    dy = Type: <b>int</b> The y-offset of the second image relative to the first image.
///Returns:
///    Type: <b>HIMAGELIST</b> Returns the handle to the new image list if successful, or <b>NULL</b> otherwise.
///    
@DllImport("COMCTL32")
HIMAGELIST ImageList_Merge(HIMAGELIST himl1, int i1, HIMAGELIST himl2, int i2, int dx, int dy);

///Creates a duplicate of an existing image list.
///Params:
///    himl = Type: <b>HIMAGELIST</b> A handle to the image list to be duplicated. All information contained in the original
///           image list for normal images is copied to the new image list. Overlay images are not copied.
@DllImport("COMCTL32")
HIMAGELIST ImageList_Duplicate(HIMAGELIST himl);

///Retrieves a pointer to an IImageList or IImageList2 object that corresponds to the image list's HIMAGELIST handle.
///Params:
///    himl = Type: <b>HIMAGELIST</b> The handle to the image list.
///    riid = Type: <b>REFIID</b> The identifier of the interface being requested. Normally IID_IImageList or IID_IImageList2.
///    ppv = Type: <b>void**</b> When this method returns, contains the address of the interface pointer requested in
///          <i>riid</i>. If the object does not support the interface specified in <i>riid</i>, <i>ppv</i> is <b>NULL</b>.
@DllImport("COMCTL32")
HRESULT HIMAGELIST_QueryInterface(HIMAGELIST himl, const(GUID)* riid, void** ppv);

///Creates a toolbar window and adds the specified buttons to the toolbar. <div class="alert"><b>Note</b> This function
///is deprecated, because it does not support all features of toolbars. Use CreateWindowEx instead. For examples, see
///Using Toolbar Controls.</div><div> </div>
///Params:
///    hwnd = Type: <b>HWND</b> Handle to the parent window for the toolbar.
///    ws = Type: <b>DWORD</b> Window styles for the toolbar. The WS_CHILD style is included by default. This parameter can
///         also include a combination of styles as discussed in Toolbar Control and Button Styles.
///    wID = Type: <b>UINT</b> Control identifier for the toolbar.
///    nBitmaps = Type: <b>int</b> Number of button images contained in the bitmap specified by <i>hBMInst</i> and <i>wBMID</i>.
///    hBMInst = Type: <b>HINSTANCE</b> Module instance with the executable file that contains the bitmap resource.
///    wBMID = Type: <b>UINT_PTR</b> Resource identifier for the bitmap resource. If <i>hBMInst</i> is <b>NULL</b>, this
///            parameter must be a valid bitmap handle.
///    lpButtons = Type: <b>LPCTBBUTTON</b> Pointer to an array of TBBUTTON structures that contain information about the buttons to
///                add to the toolbar.
///    iNumButtons = Type: <b>int</b> Number of buttons to add to the toolbar.
///    dxButton = Type: <b>int</b> Width, in pixels, of the buttons to add to the toolbar.
///    dyButton = Type: <b>int</b> Height, in pixels, of the buttons to add to the toolbar.
///    dxBitmap = Type: <b>int</b> Width, in pixels, of the button images to add to the buttons in the toolbar.
///    dyBitmap = Type: <b>int</b> Height, in pixels, of the button images to add to the buttons in the toolbar.
///    uStructSize = Type: <b>UINT</b> Size of a TBBUTTON structure.
///Returns:
///    Type: <b>HWND</b> Returns the window handle to the toolbar if successful, or <b>NULL</b> otherwise. To retrieve
///    extended error information, call GetLastError.
///    
@DllImport("COMCTL32")
HWND CreateToolbarEx(HWND hwnd, uint ws, uint wID, int nBitmaps, HINSTANCE hBMInst, size_t wBMID, 
                     TBBUTTON* lpButtons, int iNumButtons, int dxButton, int dyButton, int dxBitmap, int dyBitmap, 
                     uint uStructSize);

///Creates a bitmap for use in a toolbar.
///Params:
///    hInstance = Type: <b>HINSTANCE</b> Handle to the module instance with the executable file that contains the bitmap resource.
///    idBitmap = Type: <b>INT_PTR</b> Resource identifier of the bitmap resource.
///    wFlags = Type: <b>UINT</b> Bitmap flag. This parameter can be zero or the following value: <table> <tr> <th>Value</th>
///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CMB_MASKED"></a><a id="cmb_masked"></a><dl>
///             <dt><b>CMB_MASKED</b></dt> </dl> </td> <td width="60%"> Uses a bitmap as a mask. </td> </tr> </table>
///    lpColorMap = Type: <b>LPCOLORMAP</b> Pointer to a COLORMAP structure that contains the color information needed to map the
///                 bitmaps. If this parameter is <b>NULL</b>, the function uses the default color map.
///    iNumMaps = Type: <b>int</b> Number of color maps pointed to by <i>lpColorMap</i>.
///Returns:
///    Type: <b>HBITMAP</b> Returns the handle to the bitmap if successful, or <b>NULL</b> otherwise. To retrieve
///    extended error information, call GetLastError.
///    
@DllImport("COMCTL32")
HBITMAP CreateMappedBitmap(HINSTANCE hInstance, ptrdiff_t idBitmap, uint wFlags, COLORMAP* lpColorMap, 
                           int iNumMaps);

///The <b>DrawStatusText</b> function draws the specified text in the style of a status window with borders.
///Params:
///    hDC = Type: <b>HDC</b> Handle to the display context for the window.
///    lprc = Type: <b>LPCRECT</b> Pointer to a RECT structure that contains the position, in client coordinates, of the
///           rectangle in which the text is drawn. The function draws the borders just inside the edges of the specified
///           rectangle.
///    pszText = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the text to display. Tab characters in
///              the string determine whether the string is left-aligned, right-aligned, or centered.
///    uFlags = Type: <b>UINT</b> Text drawing flags. This parameter can be a combination of these values: <table> <tr>
///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SBT_NOBORDERS"></a><a
///             id="sbt_noborders"></a><dl> <dt><b>SBT_NOBORDERS</b></dt> </dl> </td> <td width="60%"> Prevents borders from
///             being drawn around the specified text. </td> </tr> <tr> <td width="40%"><a id="SBT_POPOUT"></a><a
///             id="sbt_popout"></a><dl> <dt><b>SBT_POPOUT</b></dt> </dl> </td> <td width="60%"> Draws highlighted borders that
///             make the text stand out. </td> </tr> <tr> <td width="40%"><a id="SBT_RTLREADING"></a><a
///             id="sbt_rtlreading"></a><dl> <dt><b>SBT_RTLREADING</b></dt> </dl> </td> <td width="60%"> Indicates that the
///             string pointed to by <i>pszText</i> will be displayed in the opposite direction to the text in the parent window.
///             </td> </tr> </table>
@DllImport("COMCTL32")
void DrawStatusTextA(HDC hDC, RECT* lprc, const(PSTR) pszText, uint uFlags);

///The <b>DrawStatusText</b> function draws the specified text in the style of a status window with borders.
///Params:
///    hDC = Type: <b>HDC</b> Handle to the display context for the window.
///    lprc = Type: <b>LPCRECT</b> Pointer to a RECT structure that contains the position, in client coordinates, of the
///           rectangle in which the text is drawn. The function draws the borders just inside the edges of the specified
///           rectangle.
///    pszText = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the text to display. Tab characters in
///              the string determine whether the string is left-aligned, right-aligned, or centered.
///    uFlags = Type: <b>UINT</b> Text drawing flags. This parameter can be a combination of these values: <table> <tr>
///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SBT_NOBORDERS"></a><a
///             id="sbt_noborders"></a><dl> <dt><b>SBT_NOBORDERS</b></dt> </dl> </td> <td width="60%"> Prevents borders from
///             being drawn around the specified text. </td> </tr> <tr> <td width="40%"><a id="SBT_POPOUT"></a><a
///             id="sbt_popout"></a><dl> <dt><b>SBT_POPOUT</b></dt> </dl> </td> <td width="60%"> Draws highlighted borders that
///             make the text stand out. </td> </tr> <tr> <td width="40%"><a id="SBT_RTLREADING"></a><a
///             id="sbt_rtlreading"></a><dl> <dt><b>SBT_RTLREADING</b></dt> </dl> </td> <td width="60%"> Indicates that the
///             string pointed to by <i>pszText</i> will be displayed in the opposite direction to the text in the parent window.
///             </td> </tr> </table>
@DllImport("COMCTL32")
void DrawStatusTextW(HDC hDC, RECT* lprc, const(PWSTR) pszText, uint uFlags);

///Creates a status window, which is typically used to display the status of an application. The window generally
///appears at the bottom of the parent window, and it contains the specified text. <div class="alert"><b>Note</b> This
///function is obsolete. Use CreateWindow instead.</div><div> </div>
///Params:
///    style = Type: <b>LONG</b> Window styles for the status window. This parameter must include the WS_CHILD style and should
///            also include the WS_VISIBLE style.
///    lpszText = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the status text for the first part.
///    hwndParent = Type: <b>HWND</b> handle to the parent window.
///    wID = Type: <b>UINT</b> Control identifier for the status window. The window procedure uses this value to identify
///          messages it sends to the parent window.
///Returns:
///    Type: <b>HWND</b> Returns the handle to the status window if successful, or <b>NULL</b> otherwise. To retrieve
///    extended error information, call GetLastError.
///    
@DllImport("COMCTL32")
HWND CreateStatusWindowA(int style, const(PSTR) lpszText, HWND hwndParent, uint wID);

///Creates a status window, which is typically used to display the status of an application. The window generally
///appears at the bottom of the parent window, and it contains the specified text. <div class="alert"><b>Note</b> This
///function is obsolete. Use CreateWindow instead.</div><div> </div>
///Params:
///    style = Type: <b>LONG</b> Window styles for the status window. This parameter must include the WS_CHILD style and should
///            also include the WS_VISIBLE style.
///    lpszText = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the status text for the first part.
///    hwndParent = Type: <b>HWND</b> handle to the parent window.
///    wID = Type: <b>UINT</b> Control identifier for the status window. The window procedure uses this value to identify
///          messages it sends to the parent window.
///Returns:
///    Type: <b>HWND</b> Returns the handle to the status window if successful, or <b>NULL</b> otherwise. To retrieve
///    extended error information, call GetLastError.
///    
@DllImport("COMCTL32")
HWND CreateStatusWindowW(int style, const(PWSTR) lpszText, HWND hwndParent, uint wID);

///Processes WM_MENUSELECT and WM_COMMAND messages and displays Help text about the current menu in the specified status
///window.
///Params:
///    uMsg = Type: <b>UINT</b> Message being processed. This can be either WM_MENUSELECT or WM_COMMAND.
///    wParam = Type: <b>WPARAM</b> wParam of the message specified in <i>uMsg</i>.
///    lParam = Type: <b>LPARAM</b> lParam of the message specified in <i>uMsg</i>.
///    hMainMenu = Type: <b>HMENU</b> Handle to the application's main menu.
///    hInst = Type: <b>HINSTANCE</b> Handle to the module that contains the string resources.
///    hwndStatus = Type: <b>HWND</b> Handle to the status window.
///    lpwIDs = Type: <b>LPUINT</b> Pointer to an array of values that contains pairs of string resource identifiers and menu
///             handles. The function searches the array for the handle to the selected menu and, if found, uses the
///             corresponding resource identifier to load the appropriate Help string.
@DllImport("COMCTL32")
void MenuHelp(uint uMsg, WPARAM wParam, LPARAM lParam, HMENU hMainMenu, HINSTANCE hInst, HWND hwndStatus, 
              uint* lpwIDs);

///<p class="CCE_Message">[<b>ShowHideMenuCtl</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Sets or removes the specified menu
///item's check mark attribute and shows or hides the corresponding control. The function adds a check mark to the
///specified menu item if it does not have one and then displays the corresponding control. If the menu item already has
///a check mark, the function removes the check mark and hides the corresponding control.
///Params:
///    hWnd = Type: <b>HWND</b> A handle to the window that contains the menu and controls.
///    uFlags = Type: <b>UINT_PTR</b> The identifier of the menu item to receive or lose a check mark.
///    lpInfo = Type: <b>LPINT</b> A pointer to an array that contains pairs of values. The second value in the first pair must
///             be the handle to the application's main menu. Each subsequent pair consists of a menu item identifier and a
///             control window identifier. The function searches the array for a value that matches <i>uFlags</i> and, if the
///             value is found, checks or unchecks the menu item and shows or hides the corresponding control.
@DllImport("COMCTL32")
BOOL ShowHideMenuCtl(HWND hWnd, size_t uFlags, int* lpInfo);

///Calculates the dimensions of a rectangle in the client area that contains all the specified controls.
///Params:
///    hWnd = Type: <b>HWND</b> A handle to the window that has the client area to check.
///    lprc = Type: <b>LPRECT</b> A pointer to a RECT structure that receives the dimensions of the rectangle.
///    lpInfo = Type: <b>const INT*</b> A pointer to a null-terminated array of integers that identify controls in the client
///             area. Each control requires a pair of consecutive elements. The first element of the pair must be nonzero and the
///             second element of the pair must be the control identifier. The first pair represents the menu and is ignored. The
///             last element must be zero to identify the end of the array.
@DllImport("COMCTL32")
void GetEffectiveClientRect(HWND hWnd, RECT* lprc, const(int)* lpInfo);

///Changes the specified single-selection list box to a drag list box.
///Params:
///    hLB = Type: <b>HWND</b> A handle to the single-selection list box.
@DllImport("COMCTL32")
BOOL MakeDragList(HWND hLB);

///Draws the insert icon in the parent window of the specified drag list box.
///Params:
///    handParent = Type: <b>HWND</b> A handle to the parent window of the drag list box.
///    hLB = Type: <b>HWND</b> A handle to the drag list box.
@DllImport("COMCTL32")
void DrawInsert(HWND handParent, HWND hLB, int nItem);

///Retrieves the index of the item at the specified point in a list box.
///Params:
///    hLB = Type: <b>HWND</b> A handle to the list box to check.
///    pt = Type: <b>POINT</b> A POINT structure that contains the screen coordinates to check.
///    bAutoScroll = Type: <b>BOOL</b> A scroll flag. If this parameter is <b>TRUE</b> and the point is directly above or below the
///                  list box, the function scrolls the list box by one line and returns -1. Otherwise, the function does not scroll
///                  the list box.
///Returns:
///    Type: <b>int</b> Returns the item identifier if the point is over a list item, or -1 otherwise.
///    
@DllImport("COMCTL32")
int LBItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll);

///Creates an up-down control. Note: This function is obsolete. It is a 16 bit function and cannot handle 32 bit values
///for range and position.
///Params:
///    dwStyle = Type: <b>DWORD</b> Window styles for the control. This parameter should include the WS_CHILD, WS_BORDER, and
///              WS_VISIBLE styles, and it may include any of the window styles specific to the up-down control.
///    x = Type: <b>int</b> Horizontal coordinate, in client coordinates, of the upper-left corner of the control.
///    y = Type: <b>int</b> Vertical coordinate, in client coordinates, of the upper-left corner of the control.
///    cx = Type: <b>int</b> Width, in pixels, of the up-down control.
///    cy = Type: <b>int</b> Height, in pixels, of the up-down control.
///    hParent = Type: <b>HWND</b> Handle to the parent window of the up-down control.
///    nID = Type: <b>int</b> Identifier for the up-down control.
///    hInst = Type: <b>HINSTANCE</b> Handle to the module instance of the application creating the up-down control.
///    hBuddy = Type: <b>HWND</b> Handle to the window associated with the up-down control. If this parameter is <b>NULL</b>, the
///             control has no buddy window.
///    nUpper = Type: <b>int</b> Upper limit (range) of the up-down control.
///    nLower = Type: <b>int</b> Lower limit (range) of the up-down control.
///    nPos = Type: <b>int</b> Position of the control.
@DllImport("COMCTL32")
HWND CreateUpDownControl(uint dwStyle, int x, int y, int cx, int cy, HWND hParent, int nID, HINSTANCE hInst, 
                         HWND hBuddy, int nUpper, int nLower, int nPos);

///The <b>TaskDialogIndirect</b> function creates, displays, and operates a task dialog. The task dialog contains
///application-defined icons, messages, title, verification check box, command links, push buttons, and radio buttons.
///This function can register a callback function to receive notification messages.
///Params:
///    pTaskConfig = Type: <b>const TASKDIALOGCONFIG*</b> Pointer to a TASKDIALOGCONFIG structure that contains information used to
///                  display the task dialog.
///    pnButton = Type: <b>int*</b> Address of a variable that receives either: <ul> <li>one of the button IDs specified in the
///               <b>pButtons</b> member of the <i>pTaskConfig</i> parameter</li> <li>one of the following values:</li> </ul>
///               <table class="clsStd"> <tr> <th>Value</th> <th>Description</th> </tr> <tr> <td>0</td> <td>Function call failed.
///               Refer to return value for more information.</td> </tr> <tr> <td><b>IDCANCEL</b></td> <td><b>Cancel</b> button was
///               selected, Alt-F4 was pressed, Escape was pressed or the user clicked on the <b>close window</b> button.</td>
///               </tr> <tr> <td><b>IDNO</b></td> <td><b>No</b> button was selected.</td> </tr> <tr> <td><b>IDOK</b></td>
///               <td><b>OK</b> button was selected.</td> </tr> <tr> <td><b>IDRETRY</b></td> <td><b>Retry</b> button was
///               selected.</td> </tr> <tr> <td><b>IDYES</b></td> <td><b>Yes</b> button was selected.</td> </tr> </table> If this
///               parameter is <b>NULL</b>, no value is returned.
///    pnRadioButton = Type: <b>int*</b> Address of a variable that receives one of the button IDs specified in the <b>pRadioButtons</b>
///                    member of the <i>pTaskConfig</i> parameter. If this parameter is <b>NULL</b>, no value is returned.
///    pfVerificationFlagChecked = Type: <b>BOOL*</b> Address of a variable that receives one of the following values. <table class="clsStd"> <tr>
///                                <th>Value</th> <th>Description</th> </tr> <tr> <td><b>TRUE</b></td> <td>The verification checkbox was checked
///                                when the dialog was dismissed.</td> </tr> <tr> <td><b>FALSE</b></td> <td>The verification checkbox was not
///                                checked when the dialog was dismissed.</td> </tr> </table> If this parameter is <b>NULL</b>, the verification
///                                checkbox is disabled.
///Returns:
///    Type: <b>HRESULT</b> This function can return one of these values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
///    operation completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
///    </td> <td width="60%"> There is insufficient memory to complete the operation. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more arguments are not valid. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr>
///    </table>
///    
@DllImport("COMCTL32")
HRESULT TaskDialogIndirect(const(TASKDIALOGCONFIG)* pTaskConfig, int* pnButton, int* pnRadioButton, 
                           BOOL* pfVerificationFlagChecked);

///The <b>TaskDialog</b> function creates, displays, and operates a task dialog. The task dialog contains
///application-defined message text and title, icons, and any combination of predefined push buttons. This function does
///not support the registration of a callback function to receive notifications.
///Params:
///    hwndOwner = Type: <b>HWND</b> Handle to the owner window of the task dialog to be created. If this parameter is <b>NULL</b>,
///                the task dialog has no owner window.
///    hInstance = Type: <b>HINSTANCE</b> Handle to the module that contains the icon resource identified by the <i>pszIcon</i>
///                member, and the string resources identified by the <i>pszWindowTitle</i> and <i>pszMainInstruction</i> members.
///                If this parameter is <b>NULL</b>, <i>pszIcon</i> must be <b>NULL</b> or a pointer to a null-terminated, Unicode
///                string that contains a system resource identifier, for example, TD_ERROR_ICON.
///    pszWindowTitle = Type: <b>PCWSTR</b> Pointer to the string to be used for the task dialog title. This parameter is a
///                     null-terminated, Unicode string that contains either text, or an integer resource identifier passed through the
///                     MAKEINTRESOURCE macro. If this parameter is <b>NULL</b>, the filename of the executable program is used.
///    pszMainInstruction = Type: <b>PCWSTR</b> Pointer to the string to be used for the main instruction. This parameter is a
///                         null-terminated, Unicode string that contains either text, or an integer resource identifier passed through the
///                         MAKEINTRESOURCE macro. This parameter can be <b>NULL</b> if no main instruction is wanted.
///    pszContent = Type: <b>PCWSTR</b> Pointer to a string used for additional text that appears below the main instruction, in a
///                 smaller font. This parameter is a null-terminated, Unicode string that contains either text, or an integer
///                 resource identifier passed through the MAKEINTRESOURCE macro. Can be <b>NULL</b> if no additional text is wanted.
///    dwCommonButtons = Type: <b>TASKDIALOG_COMMON_BUTTON_FLAGS</b> Specifies the push buttons displayed in the dialog box. This
///                      parameter may be a combination of flags from the following group. <div class="alert"><b>Note</b> If no buttons
///                      are specified, the dialog box will contain the <b>OK</b> button by default.</div> <div> </div> <table> <tr>
///                      <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TDCBF_OK_BUTTON"></a><a
///                      id="tdcbf_ok_button"></a><dl> <dt><b>TDCBF_OK_BUTTON</b></dt> </dl> </td> <td width="60%"> The task dialog
///                      contains the push button: <b>OK</b>. </td> </tr> <tr> <td width="40%"><a id="TDCBF_YES_BUTTON"></a><a
///                      id="tdcbf_yes_button"></a><dl> <dt><b>TDCBF_YES_BUTTON</b></dt> </dl> </td> <td width="60%"> The task dialog
///                      contains the push button: <b>Yes</b>. </td> </tr> <tr> <td width="40%"><a id="TDCBF_NO_BUTTON"></a><a
///                      id="tdcbf_no_button"></a><dl> <dt><b>TDCBF_NO_BUTTON</b></dt> </dl> </td> <td width="60%"> The task dialog
///                      contains the push button: <b>No</b>. </td> </tr> <tr> <td width="40%"><a id="TDCBF_CANCEL_BUTTON"></a><a
///                      id="tdcbf_cancel_button"></a><dl> <dt><b>TDCBF_CANCEL_BUTTON</b></dt> </dl> </td> <td width="60%"> The task
///                      dialog contains the push button: <b>Cancel</b>. This button must be specified for the dialog box to respond to
///                      typical cancel actions (Alt-F4 and Escape). </td> </tr> <tr> <td width="40%"><a id="TDCBF_RETRY_BUTTON"></a><a
///                      id="tdcbf_retry_button"></a><dl> <dt><b>TDCBF_RETRY_BUTTON</b></dt> </dl> </td> <td width="60%"> The task dialog
///                      contains the push button: <b>Retry</b>. </td> </tr> <tr> <td width="40%"><a id="TDCBF_CLOSE_BUTTON"></a><a
///                      id="tdcbf_close_button"></a><dl> <dt><b>TDCBF_CLOSE_BUTTON</b></dt> </dl> </td> <td width="60%"> The task dialog
///                      contains the push button: <b>Close</b>. </td> </tr> </table>
///    pszIcon = Type: <b>PCWSTR</b> Pointer to a string that identifies the icon to display in the task dialog. This parameter
///              must be an integer resource identifier passed to the MAKEINTRESOURCE macro or one of the following predefined
///              values. If this parameter is <b>NULL</b>, no icon will be displayed. If the <i>hInstance</i> parameter is
///              <b>NULL</b> and one of the predefined values is not used, the <b>TaskDialog</b> function fails. <table> <tr>
///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TD_ERROR_ICON"></a><a
///              id="td_error_icon"></a><dl> <dt><b>TD_ERROR_ICON</b></dt> </dl> </td> <td width="60%"> A stop-sign icon appears
///              in the task dialog. </td> </tr> <tr> <td width="40%"><a id="TD_INFORMATION_ICON"></a><a
///              id="td_information_icon"></a><dl> <dt><b>TD_INFORMATION_ICON</b></dt> </dl> </td> <td width="60%"> An icon
///              consisting of a lowercase letter i in a circle appears in the task dialog. </td> </tr> <tr> <td width="40%"><a
///              id="TD_SHIELD_ICON"></a><a id="td_shield_icon"></a><dl> <dt><b>TD_SHIELD_ICON</b></dt> </dl> </td> <td
///              width="60%"> A security shield icon appears in the task dialog. </td> </tr> <tr> <td width="40%"><a
///              id="TD_WARNING_ICON"></a><a id="td_warning_icon"></a><dl> <dt><b>TD_WARNING_ICON</b></dt> </dl> </td> <td
///              width="60%"> An exclamation-point icon appears in the task dialog. </td> </tr> </table>
///    pnButton = Type: <b>int*</b> When this function returns, contains a pointer to an integer location that receives one of the
///               following values: <table class="clsStd"> <tr> <th>Value</th> <th>Description</th> </tr> <tr> <td>0</td>
///               <td>Function call failed. Refer to return value for more information.</td> </tr> <tr> <td><b>IDCANCEL</b></td>
///               <td><b>Cancel</b> button was selected, Alt-F4 was pressed, Escape was pressed or the user clicked on the <b>close
///               window</b> button.</td> </tr> <tr> <td><b>IDNO</b></td> <td><b>No</b> button was selected.</td> </tr> <tr>
///               <td><b>IDOK</b></td> <td><b>OK</b> button was selected.</td> </tr> <tr> <td><b>IDRETRY</b></td> <td><b>Retry</b>
///               button was selected.</td> </tr> <tr> <td><b>IDYES</b></td> <td><b>Yes</b> button was selected.</td> </tr>
///               </table> If this value is <b>NULL</b>, no value is returned.
///Returns:
///    Type: <b>HRESULT</b> This function can return one of these values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
///    operation completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
///    </td> <td width="60%"> There is insufficient memory to complete the operation. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more arguments are not valid. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr>
///    </table>
///    
@DllImport("COMCTL32")
HRESULT TaskDialog(HWND hwndOwner, HINSTANCE hInstance, const(PWSTR) pszWindowTitle, 
                   const(PWSTR) pszMainInstruction, const(PWSTR) pszContent, int dwCommonButtons, 
                   const(PWSTR) pszIcon, int* pnButton);

///Enables an application to specify a language to be used with the common controls that is different from the system
///language.
///Params:
///    uiLang = Type: <b>LANGID</b> The language identifier of the language to be used by the common controls.
@DllImport("COMCTL32")
void InitMUILanguage(ushort uiLang);

///Gets the language currently in use by the common controls for a particular process.
///Returns:
///    Type: <b>LANGID</b> Returns the language identifier of the language an application has specified for the common
///    controls by calling InitMUILanguage. <b>GetMUILanguage</b> returns the value for the process from which it is
///    called. If <b>InitMUILanguage</b> has not been called or was not called from the same process,
///    <b>GetMUILanguage</b> returns the language-neutral LANGID, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL).
///    
@DllImport("COMCTL32")
ushort GetMUILanguage();

///<p class="CCE_Message">[<b>DSA_Create</b> is available for use in the operating systems specified in the Requirements
///section. It may be altered or unavailable in subsequent versions.] Creates a dynamic structure array (DSA).
///Params:
///    cbItem = Type: <b>int</b> The size, in bytes, of the item.
///    cItemGrow = Type: <b>int</b> The number of items by which the array should be incremented, if the DSA needs to be enlarged.
///Returns:
///    Type: <b>HDSA</b> Returns a handle to a DSA if successful, or <b>NULL</b> if the creation fails.
///    
@DllImport("COMCTL32")
_DSA* DSA_Create(int cbItem, int cItemGrow);

///<p class="CCE_Message">[<b>DSA_Destroy</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Frees a dynamic structure array
///(DSA).
///Params:
///    hdsa = Type: <b>HDSA</b> A handle to a DSA to destroy.
@DllImport("COMCTL32")
BOOL DSA_Destroy(_DSA* hdsa);

///<p class="CCE_Message">[<b>DSA_DestroyCallback</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Iterates through a dynamic structure
///array (DSA), calling a specified callback function on each item. Upon reaching the end of the array, the DSA is
///freed.
///Params:
///    hdsa = Type: <b>HDSA</b> A handle to a DSA to walk and destroy.
///    pfnCB = Type: <b>PFNDSAENUMCALLBACK</b> A callback function pointer. For the callback function prototype, see
///            PFNDSAENUMCALLBACK.
@DllImport("COMCTL32")
void DSA_DestroyCallback(_DSA* hdsa, PFNDAENUMCALLBACK pfnCB, void* pData);

///<p class="CCE_Message">[<b>DSA_DeleteItem</b> is available through Windows XP with Service Pack 2 (SP2). It might be
///altered or unavailable in subsequent versions.] Deletes an item from a dynamic structure array (DSA).
///Params:
///    hdsa = Type: <b>HDSA</b> A handle to an existing DSA.
///    i = Type: <b>int</b> The zero-based index of the item to delete.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if the item was successfully deleted; otherwise, <b>FALSE</b>.
///    
@DllImport("COMCTL32")
BOOL DSA_DeleteItem(_DSA* hdsa, int i);

///Deletes all items from a dynamic structure array (DSA).
///Params:
///    hdsa = Type: <b>HDSA</b> A handle to an existing DSA.
@DllImport("COMCTL32")
BOOL DSA_DeleteAllItems(_DSA* hdsa);

///Iterates through the dynamic structure array (DSA) and calls <i>pfnCB</i> on each item.
///Params:
///    hdsa = Type: <b>HDSA</b> A handle to an existing DSA.
///    pfnCB = Type: <b>PFNDAENUMCALLBACK*</b> A callback function pointer. See PFNDSAENUMCALLBACK for the callback function
///            prototype.
///    pData = Type: <b>void*</b> A callback data pointer. <i>pData</i> is passed as a parameter to <i>pfnCB</i>.
@DllImport("COMCTL32")
void DSA_EnumCallback(_DSA* hdsa, PFNDAENUMCALLBACK pfnCB, void* pData);

///<p class="CCE_Message">[<b>DSA_InsertItem</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Inserts a new item into a dynamic
///structure array (DSA). If necessary, the DSA expands to accommodate the new item.
///Params:
///    hdsa = Type: <b>HDSA</b> A handle to the DSA in which to insert the item.
///    i = Type: <b>int</b> The position in the DSA where new item is to be inserted, or DSA_APPEND to insert the item at
///        the end of the array.
///    pitem = Type: <b>void*</b> A pointer to the item that is to be inserted.
///Returns:
///    Type: <b>int</b> Returns the index of the new item if the insertion succeeds, or DSA_ERR (<code>-1</code>) if the
///    insertion fails.
///    
@DllImport("COMCTL32")
int DSA_InsertItem(_DSA* hdsa, int i, const(void)* pitem);

///<p class="CCE_Message">[<b>DSA_GetItemPtr</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Gets a pointer to an element from a
///dynamic structure array (DSA).
///Params:
///    hdsa = Type: <b>HDSA</b> A handle to the DSA containing the element.
///    i = Type: <b>int</b> The index of the element to be retrieved (zero-based).
///Returns:
///    Returns a pointer to the specified element or <b>NULL</b> if the call fails.
///    
@DllImport("COMCTL32")
void* DSA_GetItemPtr(_DSA* hdsa, int i);

///Gets an element from a dynamic structure array (DSA).
///Params:
///    hdsa = Type: <b>HDSA</b> A handle to the DSA containing the element.
///    i = Type: <b>int</b> The index of the element to be retrieved (zero-based).
///    pitem = Type: <b>void*</b> A pointer to a buffer which is filled with a copy of the specified element of the DSA.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise.
///    
@DllImport("COMCTL32")
BOOL DSA_GetItem(_DSA* hdsa, int i, void* pitem);

///<p class="CCE_Message">[<b>DSA_SetItem</b> is available through Windows XP with Service Pack 2 (SP2). It might be
///altered or unavailable in subsequent versions.] Sets the contents of an element in a dynamic structure array (DSA).
///Params:
///    hdsa = Type: <b>HDSA</b> A handle to an existing DSA that contains the element.
///    i = Type: <b>int</b> The zero-based index of the item to set.
///    pitem = Type: <b>void*</b> A pointer to the item that will replace the specified item in the array.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("COMCTL32")
BOOL DSA_SetItem(_DSA* hdsa, int i, const(void)* pitem);

///Duplicates a dynamic structure array (DSA).
///Params:
///    hdsa = Type: <b>HDSA</b> A handle to an existing DSA.
///Returns:
///    Type: <b>HDSA</b> Returns a handle to the clone, or <b>NULL</b> if the operation fails.
///    
@DllImport("COMCTL32")
_DSA* DSA_Clone(_DSA* hdsa);

///Gets the size of the dynamic structure array (DSA).
///Params:
///    hdsa = Type: <b>HDSA</b> A handle to an existing DSA.
@DllImport("COMCTL32")
ulong DSA_GetSize(_DSA* hdsa);

///Sorts the items in a dynamic structure array (DSA).
///Params:
///    hdsa = Type: <b>HDSA</b> A handle to an existing DSA.
///    pfnCompare = Type: <b>PFNDACOMPARECONST</b> A comparison function pointer.
///    lParam = Type: <b>LPARAM</b> An additional parameter to be passed to <i>pfnCmp</i>.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> on success or <b>FALSE</b> on failure.
///    
@DllImport("COMCTL32")
BOOL DSA_Sort(_DSA* pdsa, PFNDACOMPARE pfnCompare, LPARAM lParam);

///<p class="CCE_Message">[<b>DPA_Create</b> is available for use in the operating systems specified in the Requirements
///section. It may be altered or unavailable in subsequent versions.] Creates a dynamic pointer array (DPA).
///Params:
///    cItemGrow = Type: <b>int</b> The number of elements by which the array should be expanded, if the DPA needs to be enlarged.
///Returns:
///    Type: <b>HDPA</b> Returns a handle to a DPA if successful, or <b>NULL</b> if the call fails.
///    
@DllImport("COMCTL32")
_DPA* DPA_Create(int cItemGrow);

///Creates a dynamic pointer array (DPA) using a given specified size and heap location.
///Params:
///    cpGrow = Type: <b>int</b> The number of elements by which the array should be expanded, if the DPA needs to be enlarged.
///    hheap = Type: <b>HANDLE</b> A handle to the heap where the array is stored.
///Returns:
///    Type: <b>HDPA</b> Returns a handle to a DPA if successful, or <b>NULL</b> if the call fails.
///    
@DllImport("COMCTL32")
_DPA* DPA_CreateEx(int cpGrow, HANDLE hheap);

///<p class="CCE_Message">[<b>DPA_Clone</b> is available through Windows XP with Service Pack 2 (SP2). It might be
///altered or unavailable in subsequent versions.] Duplicates a dynamic pointer array (DPA).
///Params:
///    hdpa = Type: <b>const HDPA</b> A handle to an existing DPA to copy.
///    hdpaNew = Type: <b>HDPA</b> When <b>NULL</b>, a new array is copied from <i>hdpaSource</i>. This parameter can also contain
///              an array created with DPA_Create or DPA_CreateEx. The data is overwritten but the original delta size and heap
///              handle retained.
///Returns:
///    Type: <b>HDPA</b> The handle to the new or altered DPA (<i>hdpaNew</i>) if successful; otherwise, <b>NULL</b>.
///    
@DllImport("COMCTL32")
_DPA* DPA_Clone(const(_DPA)* hdpa, _DPA* hdpaNew);

///<p class="CCE_Message">[<b>DPA_Destroy</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Frees a Dynamic Pointer Array (DPA).
///Params:
///    hdpa = Type: <b>HDPA</b> A handle to a DPA.
@DllImport("COMCTL32")
BOOL DPA_Destroy(_DPA* hdpa);

///<p class="CCE_Message">[<b>DPA_DestroyCallback</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Calls <i>pfnCB</i> on each element of
///the dynamic pointer array (DPA), then frees the DPA.
///Params:
///    hdpa = Type: <b>HDPA</b> A handle to a DPA.
///    pfnCB = Type: <b>PFNDPAENUMCALLBACK</b> A callback function pointer. See PFNDPAENUMCALLBACK for the callback function
///            prototype.
@DllImport("COMCTL32")
void DPA_DestroyCallback(_DPA* hdpa, PFNDAENUMCALLBACK pfnCB, void* pData);

///<p class="CCE_Message">[<b>DPA_DeletePtr</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Removes an item from a dynamic
///pointer array (DPA). The DPA shrinks if necessary to accommodate the removed item.
///Params:
///    hdpa = Type: <b>HDPA</b> A handle to a DPA.
///    i = Type: <b>int</b> An index of item to be removed from DPA.
@DllImport("COMCTL32")
void* DPA_DeletePtr(_DPA* hdpa, int i);

///<p class="CCE_Message">[<b>DPA_DeleteAllPtrs</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Removes all items from a dynamic
///pointer array (DPA) and shrinks the DPA accordingly.
///Params:
///    hdpa = Type: <b>HDPA</b> Handle to a DPA.
@DllImport("COMCTL32")
BOOL DPA_DeleteAllPtrs(_DPA* hdpa);

///<p class="CCE_Message">[<b>DPA_EnumCallback</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Iterates through the Dynamic Pointer
///Array (DPA) and calls <i>pfnCB</i> on each item.
///Params:
///    hdpa = Type: <b>HDPA</b> A handle to a DPA.
///    pfnCB = Type: <b>PFNDPAENUMCALLBACK</b> A callback function pointer. See PFNDPAENUMCALLBACK for the callback function
///            prototype.
///    pData = Type: <b>void*</b> A callback data pointer. <i>pData</i> is passed as a parameter to <i>pfnCB</i>.
@DllImport("COMCTL32")
void DPA_EnumCallback(_DPA* hdpa, PFNDAENUMCALLBACK pfnCB, void* pData);

///Changes the number of pointers in a dynamic pointer array (DPA).
///Params:
///    pdpa = Type: <b>HDPA</b> A handle to an existing DPA.
///    cp = Type: <b>int</b> The number of pointers desired in the DPA.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
///    
@DllImport("COMCTL32")
BOOL DPA_Grow(_DPA* pdpa, int cp);

///<p class="CCE_Message">[<b>DPA_InsertPtr</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Inserts a new item at a specified
///position in a dynamic pointer array (DPA). If neccessary, the DPA expands to accommodate the new item.
///Params:
///    hdpa = Type: <b>HDPA</b> A handle to a DPA.
///    i = Type: <b>int</b> Tbe position where new item is to be inserted.
///    p = Type: <b>void*</b> A pointer to the item that is to be inserted.
@DllImport("COMCTL32")
int DPA_InsertPtr(_DPA* hdpa, int i, void* p);

///<p class="CCE_Message">[<b>DPA_SetPtr</b> is available for use in the operating systems specified in the Requirements
///section. It may be altered or unavailable in subsequent versions.] Assigns a value to an item in a dynamic pointer
///array (DPA).
///Params:
///    hdpa = Type: <b>HDPA</b> A handle to a DPA.
///    i = Type: <b>int</b> The index of the item in the DPA. <div class="alert"><b>Note</b> If the index is beyond the
///        current size of the DPA, the DPA expands to accommodate it. You do not need to assign items contiguously.</div>
///        <div> </div>
///    p = Type: <b>void*</b> A pointer to the value to assign to the specified DPA item.
@DllImport("COMCTL32")
BOOL DPA_SetPtr(_DPA* hdpa, int i, void* p);

///<p class="CCE_Message">[<b>DPA_GetPtr</b> is available for use in the operating systems specified in the Requirements
///section. It may be altered or unavailable in subsequent versions.] Gets an item from a dynamic pointer array (DPA).
///Params:
///    hdpa = Type: <b>HDPA</b> A handle to a DPA.
///    i = Type: <b>int</b> The index of item to be retrieved.
@DllImport("COMCTL32")
void* DPA_GetPtr(_DPA* hdpa, ptrdiff_t i);

///<p class="CCE_Message">[<b>DPA_GetPtrIndex</b> is available through Windows XP with Service Pack 2 (SP2). It might be
///altered or unavailable in subsequent versions.] Gets the index of a matching item found in a dynamic pointer array
///(DPA).
///Params:
///    hdpa = Type: <b>HDPA</b> A handle to an existing DPA.
///    p = Type: <b>const void*</b> A pointer to an item to locate in <i>hdpa</i>.
///Returns:
///    Type: <b>int</b> The index of the item pointed to by <i>pvoid</i>, if found; otherwise, -1.
///    
@DllImport("COMCTL32")
int DPA_GetPtrIndex(_DPA* hdpa, const(void)* p);

///Gets the size of a dynamic pointer array (DPA).
///Params:
///    hdpa = Type: <b>HDPA</b> A handle to an existing DPA.
@DllImport("COMCTL32")
ulong DPA_GetSize(_DPA* hdpa);

///<p class="CCE_Message">[<b>DPA_Sort</b> is available for use in the operating systems specified in the Requirements
///section. It may be altered or unavailable in subsequent versions.] Sorts the items in a Dynamic Pointer Array (DPA).
///Params:
///    hdpa = Type: <b>HDPA</b> A handle to a DPA.
///    pfnCompare = Type: <b>PFNDPACOMPARE</b> A comparison function pointer. See PFNDPACOMPARE for the comparison function
///                 prototype.
///    lParam = Type: <b>LPARAM</b> An additional parameter to be passed to <i>pfnCmp</i>.
@DllImport("COMCTL32")
BOOL DPA_Sort(_DPA* hdpa, PFNDACOMPARE pfnCompare, LPARAM lParam);

///<p class="CCE_Message">[<b>DPA_LoadStream</b> is available in Windows Vista. It might be altered or unavailable in
///subsequent versions. ] Loads the dynamic pointer array (DPA) from a stream by calling the specified callback function
///to read each element.
///Params:
///    phdpa = Type: <b>HDPA*</b> A handle to a DPA.
///    pfn = Type: <b>PFNDPASTREAM</b> The callback function. See PFNDPASTREAM for the callback function prototype.
///    pstream = Type: <b>IStream*</b> An IStream object.
///    pvInstData = Type: <b>void*</b> A pointer to callback data. <i>pvInstData</i> is passed as a parameter to <i>pfn</i>.
///Returns:
///    Type: <b>HRESULT</b> Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Indicates that the callback
///    function was successful and the element was loaded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Indicates that the callback function was unsuccessful in
///    loading the element; however, the process should continue. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Indicates that one or more of the parameters is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Indicates
///    that the stream object could not be read. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
///    </dl> </td> <td width="60%"> The buffer length is invalid or there was insufficient memory to complete the
///    operation. </td> </tr> </table>
///    
@DllImport("COMCTL32")
HRESULT DPA_LoadStream(_DPA** phdpa, PFNDPASTREAM pfn, IStream pstream, void* pvInstData);

///<p class="CCE_Message">[<b>DPA_SaveStream</b> is available in Windows Vista. It might be altered or unavailable in
///subsequent versions. ] Saves the dynamic pointer array (DPA) to a stream by writing out a header, and then calling
///the specified callback function to write each element.
///Params:
///    hdpa = Type: <b>HDPA</b> Receives a handle to a DPA.
///    pfn = Type: <b>PFNDPASTREAM</b> The callback function. See PFNDPASTREAM for the callback function prototype.
///    pstream = Type: <b>IStream*</b> An IStream object.
///    pvInstData = Type: <b>void*</b> A pointer to callback data. <i>pvInstData</i> is passed as a parameter to <i>pfn</i>.
///Returns:
///    Type: <b>HRESULT</b> Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Indicates that the callback
///    function was unsuccessful in saving the element; however, the process should continue. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Indicates that even though the callback
///    was unsuccessful, the process was uninterrupted. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Indicates that one or more of the parameters is
///    invalid. </td> </tr> </table>
///    
@DllImport("COMCTL32")
HRESULT DPA_SaveStream(_DPA* hdpa, PFNDPASTREAM pfn, IStream pstream, void* pvInstData);

///<p class="CCE_Message">[<b>DPA_Merge</b> is available through Windows XP with Service Pack 2 (SP2). It might be
///altered or unavailable in subsequent versions.] Combines the contents of two dynamic pointer arrays (DPAs).
///Params:
///    hdpaDest = Type: <b>HDPA</b> A handle to the first DPA. This array can be optionally presorted. When this function returns,
///               contains the handle to the merged array.
///    hdpaSrc = Type: <b>HDPA</b> A handle to the second DPA. This array can be optionally presorted.
///    dwFlags = Type: <b>DWORD</b> Options determining the method used to merge the two arrays. DPAM_NORMAL, DPAM_UNION, and
///              DPAM_UNION are mutually exclusive—only one of those flags can be set, optionally in conjunction with
///              DPAM_SORTED. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DPAM_SORTED"></a><a
///              id="dpam_sorted"></a><dl> <dt><b>DPAM_SORTED</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The arrays
///              are presorted; skip sorting. If this flag is not set, the arrays are sorted before they are merged. </td> </tr>
///              <tr> <td width="40%"><a id="DPAM_NORMAL"></a><a id="dpam_normal"></a><dl> <dt><b>DPAM_NORMAL</b></dt>
///              <dt>0x00000002</dt> </dl> </td> <td width="60%"> The final array consists of all of the elements originally
///              present in <i>hdpaDest</i>. If any of those elements are also found in <i>hdpaSrc</i>, those elements are merged
///              in the final array. The PFNDPAMERGE callback function is called with the DPAMM_MERGE message. When this flag is
///              set, the final size of the array at <i>hdpaDest</i> is the same as its initial size. </td> </tr> <tr> <td
///              width="40%"><a id="DPAM_UNION"></a><a id="dpam_union"></a><dl> <dt><b>DPAM_UNION</b></dt> <dt>0x00000004</dt>
///              </dl> </td> <td width="60%"> The final array is the union of all elements in both arrays. Elements found in both
///              arrays are merged in the final array. Elements found in only one array or the other are added as found. When this
///              flag is set, the PFNDPAMERGE callback function can be called with the DPAMM_MERGE or DPAMM_INSERT message. The
///              final size of the array is at least the size of the larger of <i>hdpaDest</i> and <i>hdpaSrc</i>, and at most the
///              sum of the two. </td> </tr> <tr> <td width="40%"><a id="DPAM_INTERSECT"></a><a id="dpam_intersect"></a><dl>
///              <dt><b>DPAM_INTERSECT</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> Only elements found in both
///              <i>hdpaSrc</i> and <i>hdpaDest</i> are merged to form the final array. When this flag is set, the PFNDPAMERGE
///              callback function can be called with the DPAMM_MERGE or DPAMM_DELETE message. The final size of the array can
///              range between 0 and the smaller of <i>hdpaDest</i> and <i>hdpaSrc</i>. </td> </tr> </table>
///    pfnCompare = Type: <b>PFNDPACOMPARE</b> The PFNDPACOMPARE callback function that compares two elements, one from each DPA, to
///                 determine whether they are the same item. If so, the callback function pointed to by <i>pfnCompare</i> is called.
///    pfnMerge = Type: <b>PFNDPAMERGE</b> The PFNDPAMERGE callback function that merges the contents when an element is found in
///               both DPAs and is found to be the same item by PFNDPACOMPARE.
///    lParam = Type: <b>LPARAM</b> Additional parameter used to declare the basis of comparison upon which equality is
///             determined.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("COMCTL32")
BOOL DPA_Merge(_DPA* hdpaDest, _DPA* hdpaSrc, uint dwFlags, PFNDACOMPARE pfnCompare, PFNDPAMERGE pfnMerge, 
               LPARAM lParam);

///<p class="CCE_Message">[<b>DPA_Search</b> is available for use in the operating systems specified in the Requirements
///section. It may be altered or unavailable in subsequent versions.] Finds an item in a dynamic pointer array (DPA).
///Params:
///    hdpa = Type: <b>HDPA</b> A handle to a DPA.
///    pFind = Type: <b>void*</b> A pointer to search for.
///    iStart = Type: <b>int</b> The index at which to start search.
///    pfnCompare = Type: <b>PFNDPACOMPARE</b> A comparison function pointer. See PFNDPACOMPARE for the comparison function
///                 prototype.
///    lParam = Type: <b>LPARAM</b> An additional parameter to be passed to <i>pfnCmp</i>.
///    options = Type: <b>UINT</b> This parameter may be one or more of the following. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DPAS_SORTED"></a><a id="dpas_sorted"></a><dl>
///              <dt><b>DPAS_SORTED</b></dt> </dl> </td> <td width="60%"> Indicates that the DPA is sorted. </td> </tr> <tr> <td
///              width="40%"><a id="DPAS_INSERTBEFORE"></a><a id="dpas_insertbefore"></a><dl> <dt><b>DPAS_INSERTBEFORE</b></dt>
///              </dl> </td> <td width="60%"> This value is only valid in conjunction with DPAS_SORTED. If the item is not found,
///              return the position where the item is expected to be found in the sorted DPA. </td> </tr> <tr> <td width="40%"><a
///              id="DPAS_INSERTAFTER"></a><a id="dpas_insertafter"></a><dl> <dt><b>DPAS_INSERTAFTER</b></dt> </dl> </td> <td
///              width="60%"> This value is only valid in conjunction with DPAS_SORTED. If the item is not found, return the
///              position where the item is expected to be found in the sorted DPA. </td> </tr> </table>
@DllImport("COMCTL32")
int DPA_Search(_DPA* hdpa, void* pFind, int iStart, PFNDACOMPARE pfnCompare, LPARAM lParam, uint options);

///Sets <i>ppszCurrent</i> to a copy of <i>pszNew</i> and frees the previous value, if necessary.
///Params:
///    ppsz = Type: <b>LPTSTR*</b> The address of a pointer to the current string. The current string is freed and the pointer
///           is set to a copy of <i>pszNew</i>.
///    psz = Type: <b>LPCTSTR</b> A pointer to the string to copy into <i>ppszCurrent</i>.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("COMCTL32")
BOOL Str_SetPtrW(PWSTR* ppsz, const(PWSTR) psz);

///Enables or disables one or both flat scroll bar direction buttons. If flat scroll bars are not initialized for the
///window, this function calls the standard EnableScrollBar function.
///Params:
///    arg1 = Type: <b>HWND</b> A handle to the window that contains the flat scroll bar. This window handle must have been
///           passed previously in a call to InitializeFlatSB.
///    arg2 = Type: <b>int</b> A parameter that specifies the scroll bar type. It can be one of the following values: <table>
///           <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_BOTH"></a><a id="sb_both"></a><dl>
///           <dt><b>SB_BOTH</b></dt> </dl> </td> <td width="60%"> Enables or disables the direction buttons on the horizontal
///           and vertical scroll bars. </td> </tr> <tr> <td width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl>
///           <dt><b>SB_HORZ</b></dt> </dl> </td> <td width="60%"> Enables or disables the direction buttons on the horizontal
///           scroll bar. </td> </tr> <tr> <td width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt>
///           </dl> </td> <td width="60%"> Enables or disables the direction buttons on the vertical scroll bar. </td> </tr>
///           </table>
///    arg3 = Type: <b>UINT</b> A parameter that specifies whether the scroll bar arrows are enabled or disabled and indicates
///           which arrows are enabled or disabled. It can be one of the following values: <table> <tr> <th>Value</th>
///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ESB_DISABLE_BOTH"></a><a id="esb_disable_both"></a><dl>
///           <dt><b>ESB_DISABLE_BOTH</b></dt> </dl> </td> <td width="60%"> Disables both direction buttons on the specified
///           scroll bar. </td> </tr> <tr> <td width="40%"><a id="ESB_DISABLE_DOWN"></a><a id="esb_disable_down"></a><dl>
///           <dt><b>ESB_DISABLE_DOWN</b></dt> </dl> </td> <td width="60%"> Disables the down direction button on the vertical
///           scroll bar. </td> </tr> <tr> <td width="40%"><a id="ESB_DISABLE_LEFT"></a><a id="esb_disable_left"></a><dl>
///           <dt><b>ESB_DISABLE_LEFT</b></dt> </dl> </td> <td width="60%"> Disables the left direction button on the
///           horizontal scroll bar. </td> </tr> <tr> <td width="40%"><a id="ESB_DISABLE_LTUP"></a><a
///           id="esb_disable_ltup"></a><dl> <dt><b>ESB_DISABLE_LTUP</b></dt> </dl> </td> <td width="60%"> Disables the left
///           direction button on the horizontal scroll bar or the up direction button on the vertical scroll bar. </td> </tr>
///           <tr> <td width="40%"><a id="ESB_DISABLE_RIGHT"></a><a id="esb_disable_right"></a><dl>
///           <dt><b>ESB_DISABLE_RIGHT</b></dt> </dl> </td> <td width="60%"> Disables the right direction button on the
///           horizontal scroll bar. </td> </tr> <tr> <td width="40%"><a id="ESB_DISABLE_RTDN"></a><a
///           id="esb_disable_rtdn"></a><dl> <dt><b>ESB_DISABLE_RTDN</b></dt> </dl> </td> <td width="60%"> Disables the right
///           direction button on the horizontal scroll bar or the down direction button on the vertical scroll bar. </td>
///           </tr> <tr> <td width="40%"><a id="ESB_DISABLE_UP"></a><a id="esb_disable_up"></a><dl>
///           <dt><b>ESB_DISABLE_UP</b></dt> </dl> </td> <td width="60%"> Disables the up direction button on the vertical
///           scroll bar. </td> </tr> <tr> <td width="40%"><a id="ESB_ENABLE_BOTH"></a><a id="esb_enable_both"></a><dl>
///           <dt><b>ESB_ENABLE_BOTH</b></dt> </dl> </td> <td width="60%"> Enables both direction buttons on the specified
///           scroll bar. </td> </tr> </table>
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if the scroll bar changes, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL FlatSB_EnableScrollBar(HWND param0, int param1, uint param2);

///Shows or hides a flat scroll bar. If flat scroll bars are not initialized for the window, this function calls the
///standard ShowScrollBar function.
///Params:
///    arg1 = Type: <b>HWND</b> A handle to the window that contains the flat scroll bar. This window handle must have been
///           passed previously in a call to InitializeFlatSB.
///    code = Type: <b>int</b> The scroll bar type. It can be one of the following values: <table> <tr> <th>Value</th>
///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_BOTH"></a><a id="sb_both"></a><dl> <dt><b>SB_BOTH</b></dt>
///           </dl> </td> <td width="60%"> Shows or hides the horizontal and vertical scroll bars. </td> </tr> <tr> <td
///           width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl> <dt><b>SB_HORZ</b></dt> </dl> </td> <td width="60%">
///           Shows or hides the horizontal scroll bar. </td> </tr> <tr> <td width="40%"><a id="SB_VERT"></a><a
///           id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td> <td width="60%"> Shows or hides the vertical scroll
///           bar. </td> </tr> </table>
///    arg3 = Type: <b>BOOL</b> Specifies whether the scroll bar should be shown or hidden. If this parameter is nonzero, the
///           scroll bar will be shown; if it is zero, the scroll bar will be hidden.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL FlatSB_ShowScrollBar(HWND param0, int code, BOOL param2);

///Gets the scroll range for a flat scroll bar. If flat scroll bars are not initialized for the window, this function
///calls the standard GetScrollRange function.
///Params:
///    arg1 = Type: <b>HWND</b> A handle to the window that contains the flat scroll bar. This window handle must have been
///           passed previously in a call to InitializeFlatSB.
///    code = Type: <b>int</b> The scroll bar type. It can be one of the following values: <table> <tr> <th>Value</th>
///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl> <dt><b>SB_HORZ</b></dt>
///           </dl> </td> <td width="60%"> Retrieves the scroll range of the horizontal scroll bar. </td> </tr> <tr> <td
///           width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td> <td width="60%">
///           Retrieves the scroll range of the vertical scroll bar. </td> </tr> </table>
///    arg3 = Type: <b>LPINT</b> A pointer to an INT value that receives the minimum scroll range value.
///    arg4 = Type: <b>LPINT</b> A pointer to an INT value that receives the maximum scroll range value.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL FlatSB_GetScrollRange(HWND param0, int code, int* param2, int* param3);

///Gets the information for a flat scroll bar. If flat scroll bars are not initialized for the window, this function
///calls the standard GetScrollInfo function.
///Params:
///    arg1 = Type: <b>HWND</b> A handle to the window that contains the flat scroll bar. This window handle must have been
///           passed previously in a call to InitializeFlatSB.
///    code = Type: <b>int</b> A parameter that specifies the scroll bar type. It can be one of the following values: <table>
///           <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl>
///           <dt><b>SB_HORZ</b></dt> </dl> </td> <td width="60%"> Retrieves the information for the horizontal scroll bar.
///           </td> </tr> <tr> <td width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td>
///           <td width="60%"> Retrieves the information for the vertical scroll bar. </td> </tr> </table>
///    arg3 = Type: <b>LPSCROLLINFO</b> A pointer to a SCROLLINFO structure that will receive the information for the specified
///           scroll bar. The <b>cbSize</b> and <b>fMask</b> members of the structure must be filled out prior to calling
///           <b>FlatSB_GetScrollInfo</b>. The <b>fMask</b> member specifies which properties should be retrieved and can be
///           any combination of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///           width="40%"><a id="SIF_PAGE"></a><a id="sif_page"></a><dl> <dt><b>SIF_PAGE</b></dt> </dl> </td> <td width="60%">
///           Retrieves the page information for the flat scroll bar. This will be placed in the <b>nPage</b> member of the
///           SCROLLINFO structure. </td> </tr> <tr> <td width="40%"><a id="SIF_POS"></a><a id="sif_pos"></a><dl>
///           <dt><b>SIF_POS</b></dt> </dl> </td> <td width="60%"> Retrieves the position information for the flat scroll bar.
///           This will be placed in the <b>nPos</b> member of the SCROLLINFO structure. </td> </tr> <tr> <td width="40%"><a
///           id="SIF_RANGE"></a><a id="sif_range"></a><dl> <dt><b>SIF_RANGE</b></dt> </dl> </td> <td width="60%"> Retrieves
///           the range information for the flat scroll bar. This will be placed in the <b>nMin</b> and <b>nMax</b> members of
///           the SCROLLINFO structure. </td> </tr> <tr> <td width="40%"><a id="SIF_ALL"></a><a id="sif_all"></a><dl>
///           <dt><b>SIF_ALL</b></dt> </dl> </td> <td width="60%"> A combination of SIF_PAGE, SIF_POS, and SIF_RANGE. </td>
///           </tr> </table>
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL FlatSB_GetScrollInfo(HWND param0, int code, SCROLLINFO* param2);

///Gets the thumb position in a flat scroll bar. If flat scroll bars are not initialized for the window, this function
///calls the standard GetScrollPos function.
///Params:
///    arg1 = Type: <b>HWND</b> A handle to the window that contains the flat scroll bar. This window handle must have been
///           passed previously in a call to InitializeFlatSB.
///    code = Type: <b>int</b> The parameter that specifies the scroll bar type. It can be one of the following values: <table>
///           <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl>
///           <dt><b>SB_HORZ</b></dt> </dl> </td> <td width="60%"> Retrieves the thumb position of the horizontal scroll bar.
///           </td> </tr> <tr> <td width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td>
///           <td width="60%"> Retrieves the thumb position of the vertical scroll bar. </td> </tr> </table>
///Returns:
///    Type: <b>int</b> Returns the current thumb position of the specified flat scroll bar.
///    
@DllImport("COMCTL32")
int FlatSB_GetScrollPos(HWND param0, int code);

///Gets the properties for a flat scroll bar. This function can also be used to determine if InitializeFlatSB has been
///called for this window.
///Params:
///    arg1 = Type: <b>HWND</b> A handle to the window that contains the flat scroll bar. This window handle must have been
///           passed previously in a call to InitializeFlatSB.
///    propIndex = Type: <b>UINT</b> The parameter that determines what <i>pValue</i> represents and which property is being
///                retrieved. It can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                width="40%"><a id="WSB_PROP_CXHSCROLL"></a><a id="wsb_prop_cxhscroll"></a><dl> <dt><b>WSB_PROP_CXHSCROLL</b></dt>
///                </dl> </td> <td width="60%"> <i>pValue</i> is a pointer to an INT value that receives the width, in pixels, of
///                the direction buttons in a horizontal scroll bar. </td> </tr> <tr> <td width="40%"><a
///                id="WSB_PROP_CXHTHUMB"></a><a id="wsb_prop_cxhthumb"></a><dl> <dt><b>WSB_PROP_CXHTHUMB</b></dt> </dl> </td> <td
///                width="60%"> <i>pValue</i> is a pointer to an INT value that receives the width, in pixels, of the thumb in a
///                horizontal scroll bar. </td> </tr> <tr> <td width="40%"><a id="WSB_PROP_CXVSCROLL"></a><a
///                id="wsb_prop_cxvscroll"></a><dl> <dt><b>WSB_PROP_CXVSCROLL</b></dt> </dl> </td> <td width="60%"> <i>pValue</i> a
///                pointer to an INT value that receives the width, in pixels, of a vertical scroll bar. </td> </tr> <tr> <td
///                width="40%"><a id="WSB_PROP_CYHSCROLL"></a><a id="wsb_prop_cyhscroll"></a><dl> <dt><b>WSB_PROP_CYHSCROLL</b></dt>
///                </dl> </td> <td width="60%"> <i>pValue</i> is a pointer to an INT value that receives the height, in pixels, of a
///                horizontal scroll bar. </td> </tr> <tr> <td width="40%"><a id="WSB_PROP_CYVSCROLL"></a><a
///                id="wsb_prop_cyvscroll"></a><dl> <dt><b>WSB_PROP_CYVSCROLL</b></dt> </dl> </td> <td width="60%"> <i>pValue</i> is
///                a pointer to an INT value that receives the height, in pixels, of the direction buttons in a vertical scroll bar.
///                </td> </tr> <tr> <td width="40%"><a id="WSB_PROP_CYVTHUMB"></a><a id="wsb_prop_cyvthumb"></a><dl>
///                <dt><b>WSB_PROP_CYVTHUMB</b></dt> </dl> </td> <td width="60%"> <i>pValue</i> is a pointer to an INT value that
///                receives the height, in pixels, of the thumb in a vertical scroll bar. </td> </tr> <tr> <td width="40%"><a
///                id="WSB_PROP_HBKGCOLOR"></a><a id="wsb_prop_hbkgcolor"></a><dl> <dt><b>WSB_PROP_HBKGCOLOR</b></dt> </dl> </td>
///                <td width="60%"> <i>pValue</i> is a pointer to a <b>COLORREF</b> value that receives the background color in a
///                horizontal scroll bar. </td> </tr> <tr> <td width="40%"><a id="WSB_PROP_HSTYLE"></a><a
///                id="wsb_prop_hstyle"></a><dl> <dt><b>WSB_PROP_HSTYLE</b></dt> </dl> </td> <td width="60%"> <i>pValue</i> is a
///                pointer to an INT value that receives one of the following visual effects for the horizontal scroll bar. <dl>
///                <dt>FSB_ENCARTA_MODE</dt> <dd> A standard flat scroll bar is displayed. When the mouse moves over a direction
///                button or the thumb, that portion of the scroll bar is displayed in 3-D. </dd> <dt>FSB_FLAT_MODE</dt> <dd> A
///                standard flat scroll bar is displayed. When the mouse moves over a direction button or the thumb, that portion of
///                the scroll bar is displayed in inverted colors. </dd> <dt>FSB_REGULAR_MODE</dt> <dd> A normal, nonflat scroll bar
///                is displayed. No special visual effects are applied. </dd> </dl> </td> </tr> <tr> <td width="40%"><a
///                id="WSB_PROP_PALETTE"></a><a id="wsb_prop_palette"></a><dl> <dt><b>WSB_PROP_PALETTE</b></dt> </dl> </td> <td
///                width="60%"> <i>pValue</i> is a pointer to an <b>HPALETTE</b> value that receives the palette that a scroll bar
///                uses when drawing. </td> </tr> <tr> <td width="40%"><a id="WSB_PROP_VBKGCOLOR"></a><a
///                id="wsb_prop_vbkgcolor"></a><dl> <dt><b>WSB_PROP_VBKGCOLOR</b></dt> </dl> </td> <td width="60%"> <i>pValue</i> is
///                a pointer to a <b>COLORREF</b> value that receives the background color in a vertical scroll bar. </td> </tr>
///                <tr> <td width="40%"><a id="WSB_PROP_VSTYLE"></a><a id="wsb_prop_vstyle"></a><dl> <dt><b>WSB_PROP_VSTYLE</b></dt>
///                </dl> </td> <td width="60%"> <i>pValue</i> is a pointer to an INT value that receives one of the following visual
///                effects for the vertical scroll bar. <dl> <dt>FSB_ENCARTA_MODE</dt> <dd> A standard flat scroll bar is displayed.
///                When the mouse moves over a direction button or the thumb, that portion of the scroll bar is displayed in 3-D.
///                </dd> <dt>FSB_FLAT_MODE</dt> <dd> A standard flat scroll bar is displayed. When the mouse moves over a direction
///                button or the thumb, that portion of the scroll bar is displayed in inverted colors. </dd>
///                <dt>FSB_REGULAR_MODE</dt> <dd> A normal, nonflat scroll bar is displayed. No special visual effects are applied.
///                </dd> </dl> </td> </tr> <tr> <td width="40%"><a id="WSB_PROP_WINSTYLE"></a><a id="wsb_prop_winstyle"></a><dl>
///                <dt><b>WSB_PROP_WINSTYLE</b></dt> </dl> </td> <td width="60%"> <i>pValue</i> is a pointer to an INT value that
///                receives the WS_HSCROLL and WS_VSCROLL style bits contained by the current window. </td> </tr> </table>
///    arg3 = Type: <b>LPINT</b> A pointer to an <b>int</b> that receives the requested data. This parameter depends on the
///           flag passed in <i>index</i>.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise. If <i>index</i> is WSB_PROP_HSTYLE, the
///    return is nonzero if InitializeFlatSB has been called for this window, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL FlatSB_GetScrollProp(HWND param0, int propIndex, int* param2);

///Sets the current position of the thumb in a flat scroll bar. If flat scroll bars are not initialized for the window,
///this function calls the standard SetScrollPos function.
///Params:
///    arg1 = Type: <b>HWND</b> A handle to the window that contains the flat scroll bar. This window handle must have been
///           passed previously in a call to InitializeFlatSB.
///    code = Type: <b>int</b> The scroll bar type. It can be one of the following values: <table> <tr> <th>Value</th>
///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl> <dt><b>SB_HORZ</b></dt>
///           </dl> </td> <td width="60%"> Sets the thumb position of the horizontal scroll bar. </td> </tr> <tr> <td
///           width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td> <td width="60%">
///           Sets the thumb position of the vertical scroll bar. </td> </tr> </table>
///    pos = Type: <b>int</b> The new thumb position.
///    fRedraw = Type: <b>BOOL</b> Specifies whether the scroll bar should be redrawn immediately to reflect the change. If this
///              parameter is <b>TRUE</b>, the scroll bar is redrawn; if it is <b>FALSE</b>, the scroll bar is not redrawn.
///Returns:
///    Type: <b>int</b> Returns the previous position of the thumb in the specified flat scroll bar.
///    
@DllImport("COMCTL32")
int FlatSB_SetScrollPos(HWND param0, int code, int pos, BOOL fRedraw);

///Sets the information for a flat scroll bar. If flat scroll bars are not initialized for the window, this function
///calls the standard SetScrollInfo function.
///Params:
///    arg1 = Type: <b>HWND</b> A handle to the window that contains the flat scroll bar. This window handle must have been
///           passed previously in a call to InitializeFlatSB.
///    code = Type: <b>int</b> The scroll bar type. It can be one of the following values: <table> <tr> <th>Value</th>
///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl> <dt><b>SB_HORZ</b></dt>
///           </dl> </td> <td width="60%"> Sets the information for the horizontal scroll bar. </td> </tr> <tr> <td
///           width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td> <td width="60%">
///           Sets the information for the vertical scroll bar. </td> </tr> </table>
///    psi = Type: <b>LPSCROLLINFO</b> A pointer to a SCROLLINFO structure that contains the new information for the specified
///          scroll bar. The <b>cbSize</b> and <b>fMask</b> members of the structure must be filled in prior to calling
///          <b>FlatSB_SetScrollInfo</b>. The <b>fMask</b> member specifies which members of the structure contain valid
///          information and can be any combination of the following values: <table> <tr> <th>Value</th> <th>Meaning</th>
///          </tr> <tr> <td width="40%"><a id="SIF_DISABLENOSCROLL"></a><a id="sif_disablenoscroll"></a><dl>
///          <dt><b>SIF_DISABLENOSCROLL</b></dt> </dl> </td> <td width="60%"> Disables the scroll bar if the new information
///          would cause the scroll bar to be removed. </td> </tr> <tr> <td width="40%"><a id="SIF_PAGE"></a><a
///          id="sif_page"></a><dl> <dt><b>SIF_PAGE</b></dt> </dl> </td> <td width="60%"> Sets the page information for the
///          flat scroll bar. The <b>nPage</b> member of the SCROLLINFO structure must contain the new page value. </td> </tr>
///          <tr> <td width="40%"><a id="SIF_POS"></a><a id="sif_pos"></a><dl> <dt><b>SIF_POS</b></dt> </dl> </td> <td
///          width="60%"> Sets the position information for the flat scroll bar. The <b>nPos</b> member of the SCROLLINFO
///          structure must contain the new position value. </td> </tr> <tr> <td width="40%"><a id="SIF_RANGE"></a><a
///          id="sif_range"></a><dl> <dt><b>SIF_RANGE</b></dt> </dl> </td> <td width="60%"> Sets the range information for the
///          flat scroll bar. The <b>nMin</b> and <b>nMax</b> members of the SCROLLINFO structure must contain the new range
///          values. </td> </tr> <tr> <td width="40%"><a id="SIF_ALL"></a><a id="sif_all"></a><dl> <dt><b>SIF_ALL</b></dt>
///          </dl> </td> <td width="60%"> A combination of SIF_PAGE, SIF_POS, and SIF_RANGE. </td> </tr> </table>
///    fRedraw = Type: <b>BOOL</b> Specifies whether the scroll bar should be redrawn immediately to reflect the change. If this
///              parameter is <b>TRUE</b>, the scroll bar is redrawn; if it is <b>FALSE</b>, the scroll bar is not redrawn.
///Returns:
///    Type: <b>int</b> Returns the current scroll position. If the call to <b>FlatSB_SetScrollInfo</b> changes the
///    scroll position, then the previous position is returned.
///    
@DllImport("COMCTL32")
int FlatSB_SetScrollInfo(HWND param0, int code, SCROLLINFO* psi, BOOL fRedraw);

///Sets the scroll range of a flat scroll bar. If flat scroll bars are not initialized for the window, this function
///calls the standard SetScrollRange function.
///Params:
///    arg1 = Type: <b>HWND</b> A handle to the window that contains the flat scroll bar. This window handle must have been
///           passed previously in a call to InitializeFlatSB.
///    code = Type: <b>int</b> The scroll bar type. It can be one of the following values: <table> <tr> <th>Value</th>
///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl> <dt><b>SB_HORZ</b></dt>
///           </dl> </td> <td width="60%"> Sets the scroll range of the horizontal scroll bar. </td> </tr> <tr> <td
///           width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td> <td width="60%">
///           Sets the scroll range of the vertical scroll bar. </td> </tr> </table>
///    min = Type: <b>int</b> The new minimum scroll range value.
///    max = Type: <b>int</b> The new maximum scroll range value.
///    fRedraw = Type: <b>BOOL</b> Specifies whether the scroll bar should be redrawn immediately to reflect the change. If this
///              parameter is <b>TRUE</b>, the scroll bar is redrawn; if it is <b>FALSE</b>, the scroll bar is not redrawn.
///Returns:
///    Type: <b>int</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
int FlatSB_SetScrollRange(HWND param0, int code, int min, int max, BOOL fRedraw);

///Sets the properties for a flat scroll bar.
///Params:
///    arg1 = Type: <b>HWND</b> A handle to the window that contains the flat scroll bar. This window handle must have been
///           passed previously in a call to InitializeFlatSB.
///    index = Type: <b>UINT</b> Determines what <i>newValue</i> represents and which property is being set. This parameter can
///            be one of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="WSB_PROP_CXHSCROLL"></a><a id="wsb_prop_cxhscroll"></a><dl> <dt><b>WSB_PROP_CXHSCROLL</b></dt> </dl> </td>
///            <td width="60%"> <i>newValue</i> is an INT_PTR value that represents the width, in pixels, of the direction
///            buttons in a horizontal scroll bar. </td> </tr> <tr> <td width="40%"><a id="WSB_PROP_CXHTHUMB"></a><a
///            id="wsb_prop_cxhthumb"></a><dl> <dt><b>WSB_PROP_CXHTHUMB</b></dt> </dl> </td> <td width="60%"> <i>newValue</i> is
///            an INT_PTR value that represents the width, in pixels, of the thumb in a horizontal scroll bar. </td> </tr> <tr>
///            <td width="40%"><a id="WSB_PROP_CXVSCROLL"></a><a id="wsb_prop_cxvscroll"></a><dl>
///            <dt><b>WSB_PROP_CXVSCROLL</b></dt> </dl> </td> <td width="60%"> <i>newValue</i> is an INT_PTR value that
///            represents the width, in pixels, of the vertical scroll bar. </td> </tr> <tr> <td width="40%"><a
///            id="WSB_PROP_CYHSCROLL"></a><a id="wsb_prop_cyhscroll"></a><dl> <dt><b>WSB_PROP_CYHSCROLL</b></dt> </dl> </td>
///            <td width="60%"> <i>newValue</i> is an INT_PTR value that represents the height, in pixels, of the horizontal
///            scroll bar. </td> </tr> <tr> <td width="40%"><a id="WSB_PROP_CYVSCROLL"></a><a id="wsb_prop_cyvscroll"></a><dl>
///            <dt><b>WSB_PROP_CYVSCROLL</b></dt> </dl> </td> <td width="60%"> <i>newValue</i> is an INT_PTR value that
///            represents the height, in pixels, of the direction buttons in a vertical scroll bar. </td> </tr> <tr> <td
///            width="40%"><a id="WSB_PROP_CYVTHUMB"></a><a id="wsb_prop_cyvthumb"></a><dl> <dt><b>WSB_PROP_CYVTHUMB</b></dt>
///            </dl> </td> <td width="60%"> <i>newValue</i> is an INT_PTR value that represents the height, in pixels, of the
///            thumb in a vertical scroll bar. </td> </tr> <tr> <td width="40%"><a id="WSB_PROP_HBKGCOLOR"></a><a
///            id="wsb_prop_hbkgcolor"></a><dl> <dt><b>WSB_PROP_HBKGCOLOR</b></dt> </dl> </td> <td width="60%"> <i>newValue</i>
///            is a <b>COLORREF</b> value that represents the background color in a horizontal scroll bar. </td> </tr> <tr> <td
///            width="40%"><a id="WSB_PROP_HSTYLE"></a><a id="wsb_prop_hstyle"></a><dl> <dt><b>WSB_PROP_HSTYLE</b></dt> </dl>
///            </td> <td width="60%"> <i>newValue</i> is one of the following values that changes the visual effects for the
///            horizontal scroll bar. <dl> <dt>FSB_ENCARTA_MODE</dt> <dd> A standard flat scroll bar is displayed. When the
///            mouse moves over a direction button or the thumb, that portion of the scroll bar will be displayed in 3-D. </dd>
///            <dt>FSB_FLAT_MODE</dt> <dd> A standard flat scroll bar is displayed. When the mouse moves over a direction button
///            or the thumb, that portion of the scroll bar will be displayed in inverted colors. </dd>
///            <dt>FSB_REGULAR_MODE</dt> <dd> A normal, nonflat scroll bar is displayed. No special visual effects will be
///            applied. </dd> </dl> </td> </tr> <tr> <td width="40%"><a id="WSB_PROP_PALETTE"></a><a
///            id="wsb_prop_palette"></a><dl> <dt><b>WSB_PROP_PALETTE</b></dt> </dl> </td> <td width="60%"> <i>newValue</i> is
///            an <b>HPALETTE</b> value that represents the new palette that the scroll bar should use when drawing. </td> </tr>
///            <tr> <td width="40%"><a id="WSB_PROP_VBKGCOLOR"></a><a id="wsb_prop_vbkgcolor"></a><dl>
///            <dt><b>WSB_PROP_VBKGCOLOR</b></dt> </dl> </td> <td width="60%"> <i>newValue</i> is a <b>COLORREF</b> value that
///            represents the background color in a vertical scroll bar. </td> </tr> <tr> <td width="40%"><a
///            id="WSB_PROP_VSTYLE"></a><a id="wsb_prop_vstyle"></a><dl> <dt><b>WSB_PROP_VSTYLE</b></dt> </dl> </td> <td
///            width="60%"> <i>newValue</i> is one of the following values that changes the visual effects for the vertical
///            scroll bar: <dl> <dt>FSB_ENCARTA_MODE</dt> <dd> A standard flat scroll bar is displayed. When the mouse moves
///            over a direction button or the thumb, that portion of the scroll bar will be displayed in 3-D. </dd>
///            <dt>FSB_FLAT_MODE</dt> <dd> A standard flat scroll bar is displayed. When the mouse moves over a direction button
///            or the thumb, that portion of the scroll bar will be displayed in inverted colors. </dd>
///            <dt>FSB_REGULAR_MODE</dt> <dd> A normal, nonflat scroll bar is displayed. No special visual effects will be
///            applied. </dd> </dl> </td> </tr> </table>
///    newValue = Type: <b>INT_PTR</b> A new value to set. This parameter depends on the flag passed in <i>index</i>.
///    arg4 = Type: <b>BOOL</b> Specifies whether the scroll bar should be redrawn immediately to reflect the change. If this
///           parameter is <b>TRUE</b>, the scroll bar is redrawn; if it is <b>FALSE</b>, the scroll bar is not redrawn.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL FlatSB_SetScrollProp(HWND param0, uint index, ptrdiff_t newValue, BOOL param3);

///Initializes flat scroll bars for a particular window.
///Params:
///    Arg1 = Type: <b>HWND</b> A handle to the window that will receive flat scroll bars.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("COMCTL32")
BOOL InitializeFlatSB(HWND param0);

///Uninitializes flat scroll bars for a particular window. The specified window will revert to standard scroll bars.
///Params:
///    Arg1 = Type: <b>HWND</b> A handle to the window with the flat scroll bars that will be uninitialized.
///Returns:
///    Type: <b>HRESULT</b> Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> One of the window's scroll
///    bars is currently in use. The operation cannot be completed at this time. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The window does not have flat scroll bars initialized. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
///    </td> </tr> </table>
///    
@DllImport("COMCTL32")
HRESULT UninitializeFlatSB(HWND param0);

///Loads a specified icon resource with a client-specified system metric.
///Params:
///    hinst = Type: <b>HINSTANCE</b> A handle to the module of either a DLL or executable (.exe) file that contains the icon to
///            be loaded. For more information, see GetModuleHandle. To load a predefined icon or a standalone icon file, set
///            this parameter to <b>NULL</b>.
///    pszName = Type: <b>PCWSTR</b> A pointer to a null-terminated, Unicode buffer that contains location information about the
///              icon to load. It is interpreted as follows: If <i>hinst</i> is <b>NULL</b>, <i>pszName</i> can specify one of two
///              things. <ol> <li>The name of a standalone icon (.ico) file.</li> <li>The identifier of a predefined icon to load.
///              These identifiers are recognized:</li> <ul> <li>IDI_APPLICATION</li> <li>IDI_INFORMATION</li> <li>IDI_ERROR</li>
///              <li>IDI_WARNING</li> <li>IDI_SHIELD</li> <li>IDI_QUESTION To pass these constants to the <b>LoadIconMetric</b>
///              function, use the MAKEINTRESOURCE macro. For example, to load the IDI_ERROR icon, pass
///              <code>MAKEINTRESOURCE(IDI_ERROR)</code> as the <i>pszName</i> parameter and <b>NULL</b> as the <i>hinst</i>
///              parameter. </ul> </ol> If <i>hinst</i> is non-null, <i>pszName</i> can specify one of two things. <ol> <li>The
///              name of the icon resource, if the icon resource is to be loaded by name from the module.</li> <li>The icon
///              ordinal, if the icon resource is to be loaded by ordinal from the module. This ordinal must be packaged by using
///              the MAKEINTRESOURCE macro.</li> </ol>
///    lims = Type: <b>int</b> The desired metric. One of the following values: <table> <tr> <th>Value</th> <th>Meaning</th>
///           </tr> <tr> <td width="40%"><a id="LIM_SMALL"></a><a id="lim_small"></a><dl> <dt><b>LIM_SMALL</b></dt> </dl> </td>
///           <td width="60%"> Corresponds to SM_CXSMICON, the recommended pixel width of a small icon. </td> </tr> <tr> <td
///           width="40%"><a id="LIM_LARGE"></a><a id="lim_large"></a><dl> <dt><b>LIM_LARGE</b></dt> </dl> </td> <td
///           width="60%"> Corresponds toSM_CXICON, the default pixel width of an icon. </td> </tr> </table>
///    phico = Type: <b>HICON*</b> When this function returns, contains a pointer to the handle of the loaded icon.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, otherwise an error, including the following value. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
///    </td> <td width="60%"> The contents of the buffer pointed to by <i>pszName</i> do not fit any of the expected
///    interpretations. </td> </tr> </table>
///    
@DllImport("COMCTL32")
HRESULT LoadIconMetric(HINSTANCE hinst, const(PWSTR) pszName, int lims, HICON* phico);

///Loads an icon. If the icon is not a standard size, this function scales down a larger image instead of scaling up a
///smaller image.
///Params:
///    hinst = Type: <b>HINSTANCE</b> A handle to the module of either a DLL or executable (.exe) file that contains the icon to
///            be loaded. For more information, see GetModuleHandle. To load a predefined icon or a standalone icon file, set
///            this parameter to <b>NULL</b>.
///    pszName = Type: <b>PCWSTR</b> A pointer to a null-terminated, Unicode buffer that contains location information about the
///              icon to load. If <i>hinst</i> is non-<b>NULL</b>, <i>pszName</i> specifies the icon resource either by name or
///              ordinal. This ordinal must be packaged by using the MAKEINTRESOURCE macro. If <i>hinst</i> is <b>NULL</b>,
///              <i>pszName</i> specifies either the name of a standalone icon (.ico) file or the identifier of a predefined icon
///              to load. The following identifiers are recognized. To pass these constants to the <b>LoadIconWithScaleDown</b>
///              function, use the MAKEINTRESOURCE macro. For example, to load the IDI_ERROR icon, pass
///              <code>MAKEINTRESOURCE(IDI_ERROR)</code> as the <i>pszName</i> parameter and <b>NULL</b> as the <i>hinst</i>
///              parameter. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IDI_APPLICATION"></a><a
///              id="idi_application"></a><dl> <dt><b>IDI_APPLICATION</b></dt> </dl> </td> <td width="60%"> Default application
///              icon. </td> </tr> <tr> <td width="40%"><a id="IDI_ASTERISK"></a><a id="idi_asterisk"></a><dl>
///              <dt><b>IDI_ASTERISK</b></dt> </dl> </td> <td width="60%"> Same as IDI_INFORMATION. </td> </tr> <tr> <td
///              width="40%"><a id="IDI_ERROR"></a><a id="idi_error"></a><dl> <dt><b>IDI_ERROR</b></dt> </dl> </td> <td
///              width="60%"> Hand-shaped icon. </td> </tr> <tr> <td width="40%"><a id="IDI_EXCLAMATION"></a><a
///              id="idi_exclamation"></a><dl> <dt><b>IDI_EXCLAMATION</b></dt> </dl> </td> <td width="60%"> Same as IDI_WARNING.
///              </td> </tr> <tr> <td width="40%"><a id="IDI_HAND"></a><a id="idi_hand"></a><dl> <dt><b>IDI_HAND</b></dt> </dl>
///              </td> <td width="60%"> Same as IDI_ERROR. </td> </tr> <tr> <td width="40%"><a id="IDI_INFORMATION"></a><a
///              id="idi_information"></a><dl> <dt><b>IDI_INFORMATION</b></dt> </dl> </td> <td width="60%"> Asterisk icon. </td>
///              </tr> <tr> <td width="40%"><a id="IDI_QUESTION"></a><a id="idi_question"></a><dl> <dt><b>IDI_QUESTION</b></dt>
///              </dl> </td> <td width="60%"> Question mark icon. </td> </tr> <tr> <td width="40%"><a id="IDI_WARNING"></a><a
///              id="idi_warning"></a><dl> <dt><b>IDI_WARNING</b></dt> </dl> </td> <td width="60%"> Exclamation point icon. </td>
///              </tr> <tr> <td width="40%"><a id="IDI_WINLOGO"></a><a id="idi_winlogo"></a><dl> <dt><b>IDI_WINLOGO</b></dt> </dl>
///              </td> <td width="60%"> Windows logo icon. </td> </tr> <tr> <td width="40%"><a id="IDI_SHIELD"></a><a
///              id="idi_shield"></a><dl> <dt><b>IDI_SHIELD</b></dt> </dl> </td> <td width="60%"> Security Shield icon. </td>
///              </tr> </table>
///    cx = Type: <b>int</b> The desired width, in pixels, of the icon.
///    cy = Type: <b>int</b> The desired height, in pixels, of the icon.
///    phico = Type: <b>HICON*</b> When this function returns, contains a pointer to the handle of the loaded icon.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following: <table>
///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
///    </dl> </td> <td width="60%"> The contents of the buffer pointed to by <i>pszName</i> do not fit any of the
///    expected interpretations. </td> </tr> </table>
///    
@DllImport("COMCTL32")
HRESULT LoadIconWithScaleDown(HINSTANCE hinst, const(PWSTR) pszName, int cx, int cy, HICON* phico);

///Draws text that has a shadow.
///Params:
///    hdc = Type: <b>HDC</b> HDC.
///    pszText = Type: <b>LPCWSTR</b> A pointer to a string that contains the text to be drawn.
///    cch = Type: <b>UINT</b> A <b>UINT</b> that specifies the number of characters in the string that is to be drawn.
///    prc = Type: <b>const RECT*</b> A pointer to a RECT structure that contains, in logical coordinates, the rectangle in
///          which the text is to be drawn.
///    dwFlags = Type: <b>DWORD</b> A <b>DWORD</b> that specifies how the text is to be drawn. See Format Values for possible
///              parameter values.
///    crText = Type: <b>COLORREF</b> A COLORREF structure that contains the color of the text.
///    crShadow = Type: <b>COLORREF</b> A COLORREF structure that contains the color of the text shadow.
///    ixOffset = Type: <b>int</b> A value of type <b>int</b> that specifies the x-coordinate of where the text should begin.
///    iyOffset = Type: <b>int</b> A value of type <b>int</b> that specifies the y-coordinate of where the text should begin.
///Returns:
///    Type: <b>int</b> Returns the height of the text in logical units if the function succeeds, otherwise returns
///    zero.
///    
@DllImport("COMCTL32")
int DrawShadowText(HDC hdc, const(PWSTR) pszText, uint cch, RECT* prc, uint dwFlags, uint crText, uint crShadow, 
                   int ixOffset, int iyOffset);

///Creates a single instance of an imagelist and returns an interface pointer to it.
///Params:
///    rclsid = Type: <b>REFCLSID</b> A reference to the CLSID—a GUID that identifies the COM object to be created. This should
///             be <b>CLSID_ImageList</b>.
///    punkOuter = Type: <b>const IUnknown*</b> A pointer to the outer IUnknown interface that aggregates the object created by this
///                function, or <b>NULL</b> if no aggregation is desired.
///    riid = Type: <b>REFIID</b> Reference to the desired interface ID.
///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This is
///          normally IImageList2, which provides the Initialize method.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("COMCTL32")
HRESULT ImageList_CoCreateInstance(const(GUID)* rclsid, const(IUnknown) punkOuter, const(GUID)* riid, void** ppv);

///Gets a theme animation property based on the storyboard id and the target id.
///Params:
///    hTheme = An opened theme handle.
///    iStoryboardId = A predefined storyboard identifier.
///    iTargetId = A predefined target identifier.
///    eProperty = The property that is associated with the animation storyboard and target.
///    pvProperty = The buffer to receive the returned property value.
///    cbSize = The byte size of a buffer that is pointed by <i>pvProperty</i>.
///    pcbSizeOut = The byte size of the returned property.
@DllImport("UXTHEME")
HRESULT GetThemeAnimationProperty(ptrdiff_t hTheme, int iStoryboardId, int iTargetId, TA_PROPERTY eProperty, 
                                  void* pvProperty, uint cbSize, uint* pcbSizeOut);

///Gets an animation transform operation based on storyboard id, target id and transform index.
///Params:
///    hTheme = An opened theme handle.
///    iStoryboardId = A predefined storyboard identifier.
///    iTargetId = A predefined target identifier.
///    dwTransformIndex = The zero-based index of a transform operation.
///    pTransform = A pointer to a buffer to receive a transform structure.
///    cbSize = The byte size of the buffer pointed by <i>pTransform</i>.
///    pcbSizeOut = The byte size of a transform operation structure.
@DllImport("UXTHEME")
HRESULT GetThemeAnimationTransform(ptrdiff_t hTheme, int iStoryboardId, int iTargetId, uint dwTransformIndex, 
                                   TA_TRANSFORM* pTransform, uint cbSize, uint* pcbSizeOut);

///Gets a predefined timing function based on a timing function identifier.
///Params:
///    hTheme = An opened theme handle.
///    iTimingFunctionId = A timing function identifier.
///    pTimingFunction = A buffer to receive a predefined timing function pointer.
///    cbSize = The byte size of the buffer pointed by <i>pTimingFunction</i>.
///    pcbSizeOut = The byte size of the timing function structure.
@DllImport("UXTHEME")
HRESULT GetThemeTimingFunction(ptrdiff_t hTheme, int iTimingFunctionId, TA_TIMINGFUNCTION* pTimingFunction, 
                               uint cbSize, uint* pcbSizeOut);

///Opens the theme data for a window and its associated class.
///Params:
///    hwnd = Type: <b>HWND</b> Handle of the window for which theme data is required.
///    pszClassList = Type: <b>LPCWSTR</b> Pointer to a string that contains a semicolon-separated list of classes.
///Returns:
///    Type: <b>HTHEME</b> <b>OpenThemeData</b> tries to match each class, one at a time, to a class data section in the
///    active theme. If a match is found, an associated HTHEME handle is returned. If no match is found <b>NULL</b> is
///    returned.
///    
@DllImport("UXTHEME")
ptrdiff_t OpenThemeData(HWND hwnd, const(PWSTR) pszClassList);

///Opens the theme data associated with a window for specified theme classes.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to a window or control that the theme is to be retrieved from.
///    pszClassList = Type: <b>LPCWSTR</b> A semicolon-separated list of class names to match.
///    dwFlags = Type: <b>DWORD</b> Optional flags that control how to return the theme data. May be set to a combination of the
///              following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="OTD_FORCE_RECT_SIZING"></a><a id="otd_force_rect_sizing"></a><dl> <dt><b>OTD_FORCE_RECT_SIZING</b></dt> </dl>
///              </td> <td width="60%"> Forces drawn images from this theme to stretch to fit the rectangles specified by drawing
///              functions. </td> </tr> <tr> <td width="40%"><a id="OTD_NONCLIENT"></a><a id="otd_nonclient"></a><dl>
///              <dt><b>OTD_NONCLIENT</b></dt> </dl> </td> <td width="60%"> Allows theme elements to be drawn in the non-client
///              area of the window. </td> </tr> </table>
///Returns:
///    Type: <b>HTHEME</b> If a match is found, a valid handle to a theme is returned. Otherwise, a <b>NULL</b> value
///    will be returned.
///    
@DllImport("UXTHEME")
ptrdiff_t OpenThemeDataEx(HWND hwnd, const(PWSTR) pszClassList, uint dwFlags);

///Closes the theme data handle.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an <b>HTHEME</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT CloseThemeData(ptrdiff_t hTheme);

///Draws the border and fill defined by the visual style for the specified control part.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC used for drawing the theme-defined background image.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part to draw. See Parts and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part to draw. See Parts and States.
///    pRect = Type: <b>const RECT*</b> Pointer to a RECT structure that contains the rectangle, in logical coordinates, in
///            which the background image is drawn.
///    pClipRect = Type: <b>const RECT*</b> Pointer to a RECT structure that contains a clipping rectangle. This parameter may be
///                set to <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT DrawThemeBackground(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, RECT* pRect, RECT* pClipRect);

///<p class="CCE_Message">[<b>DrawThemeBackgroundEx</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Draws the background image defined by
///the visual style for the specified control part.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC used for drawing the theme-defined background image.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part to draw. See Parts and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part to draw. See Parts and States.
///    pRect = Type: <b>const RECT*</b> Pointer to a RECT structure that contains the rectangle, in logical coordinates, in
///            which the background image is drawn.
///    pOptions = Type: <b>const DTBGOPTS*</b> Pointer to a DTBGOPTS structure that contains clipping information. This parameter
///               may be set to <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT DrawThemeBackgroundEx(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, RECT* pRect, 
                              const(DTBGOPTS)* pOptions);

///Draws text using the color and font defined by the visual style.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC to use for drawing.
///    iPartId = Type: <b>int</b> The control part that has the desired text appearance. See Parts and States. If this value is 0,
///              the text is drawn in the default font, or a font selected into the device context.
///    iStateId = Type: <b>int</b> The control state that has the desired text appearance. See Parts and States.
///    pszText = Type: <b>LPCWSTR</b> Pointer to a string that contains the text to draw.
///    cchText = Type: <b>int</b> Value of type <b>int</b> that contains the number of characters to draw. If the parameter is set
///              to -1, all the characters in the string are drawn.
///    dwTextFlags = Type: <b>DWORD</b> <b>DWORD</b> that contains one or more values that specify the string's formatting. See Format
///                  Values for possible parameter values. <div class="alert"><b>Note</b> DrawThemeText does not support DT_CALCRECT.
///                  However, DrawThemeTextEx does support DT_CALCRECT.</div> <div> </div>
///    dwTextFlags2 = Type: <b>DWORD</b> Not used. Set to zero.
///    pRect = Type: <b>LPCRECT</b> Pointer to a RECT structure that contains the rectangle, in logical coordinates, in which
///            the text is to be drawn. It is recommended to use <b>pExtentRect</b> from GetThemeTextExtent to retrieve the
///            correct coordinates.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT DrawThemeText(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, const(PWSTR) pszText, int cchText, 
                      uint dwTextFlags, uint dwTextFlags2, RECT* pRect);

///Retrieves the size of the content area for the background defined by the visual style.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC to use when drawing. This parameter may be set to <b>NULL</b>.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the content area. See Parts and
///              States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part that contains the content area.
///               See Parts and States.
///    pBoundingRect = Type: <b>LPCRECT</b> Pointer to a RECT structure that contains the total background rectangle, in logical
///                    coordinates. This is the area inside the borders or margins.
///    pContentRect = Type: <b>LPRECT</b> Pointer to a RECT structure that receives the content area background rectangle, in logical
///                   coordinates. This rectangle is calculated to fit the content area.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT GetThemeBackgroundContentRect(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, RECT* pBoundingRect, 
                                      RECT* pContentRect);

///Calculates the size and location of the background, defined by the visual style, given the content area.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC to use when drawing. This parameter may be set to <b>NULL</b>.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the content. See Parts and
///              States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part that contains the content. See
///               Parts and States.
///    pContentRect = Type: <b>LPCRECT</b> Pointer to a RECT structure that contains the content background rectangle, in logical
///                   coordinates. This rectangle is returned from GetThemeBackgroundContentRect.
///    pExtentRect = Type: <b>LPRECT</b> Pointer to a RECT structure that receives the background rectangle, in logical coordinates.
///                  This rectangle is based on the <i>pContentRect</i>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT GetThemeBackgroundExtent(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, RECT* pContentRect, 
                                 RECT* pExtentRect);

///Computes the region for a regular or partially transparent background that is bounded by a specified rectangle.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC to draw into. The DC uses dots per inch (DPI) scaling. This parameter may be set to
///          <b>NULL</b>.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the region. See Parts and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    pRect = Type: <b>LPCRECT</b> Pointer to a RECT structure that contains, in logical coordinates, the specified rectangle
///            used to compute the region.
///    pRegion = Type: <b>HRGN*</b> Pointer to the handle to the computed region.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT GetThemeBackgroundRegion(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, RECT* pRect, HRGN* pRegion);

///Calculates the original size of the part defined by a visual style.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC to select fonts into.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part to calculate the size of. See Parts and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    prc = Type: <b>LPCRECT</b> Pointer to a RECT structure that contains the rectangle used for the part drawing
///          destination. This parameter may be set to <b>NULL</b>.
///    arg6 = Type: <b>THEMESIZE</b> Enumerated type that specifies the type of size to retrieve. See THEMESIZE for a list of
///           type values.
///    psz = Type: <b>SIZE*</b> Pointer to a SIZE structure that receives the dimensions of the specified part.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT GetThemePartSize(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, RECT* prc, THEMESIZE eSize, 
                         SIZE* psz);

///Calculates the size and location of the specified text when rendered in the visual style font.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC to select the font into.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part in which the text will be drawn. See Parts and
///              States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    pszText = Type: <b>LPCWSTR</b> Pointer to a string that contains the text to draw.
///    cchCharCount = Type: <b>int</b> Value of type<b>int</b> that contains the number of characters to draw. If the parameter is set
///                   to -1, all the characters in the string are drawn.
///    dwTextFlags = Type: <b>DWORD</b> <b>DWORD</b> that contains one or more values that specify the string's formatting. See Format
///                  Values for possible parameter values.
///    pBoundingRect = Type: <b>LPCRECT</b> Pointer to a RECT structure that contains the rectangle used to control layout of the text.
///                    This parameter may be set to <b>NULL</b>.
///    pExtentRect = Type: <b>LPRECT</b> Pointer to a RECT structure that contains, in logical coordinates, the rectangle required to
///                  fit the rendered text.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT GetThemeTextExtent(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, const(PWSTR) pszText, 
                           int cchCharCount, uint dwTextFlags, RECT* pBoundingRect, RECT* pExtentRect);

///Retrieves information about the font specified by a visual style for a particular part.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC to use for screen context. This parameter may be set to <b>NULL</b>.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part to retrieve font information about. See Parts
///              and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    ptm = Type: <b>TEXTMETRIC*</b> Receives the font information.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT GetThemeTextMetrics(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, TEXTMETRICW* ptm);

///Retrieves a hit test code for a point in the background specified by a visual style.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC to use when drawing. This parameter may be set to <b>NULL</b>.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part. See Parts and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    dwOptions = Type: <b>DWORD</b> <b>DWORD</b> that specifies the hit test options. See Hit Test Options for a list of options.
///    pRect = Type: <b>LPCRECT</b> Pointer to a RECT structure that contains, in logical coordinates, the rectangle that bounds
///            the background.
///    hrgn = Type: <b>HRGN</b> Handle to a region that can be used to specify the bounds of a hit test area. This parameter
///           may be set to <b>NULL</b>.
///    ptTest = Type: <b>POINT</b> POINT structure that contains the coordinates of the point.
///    pwHitTestCode = Type: <b>WORD*</b> <b>WORD</b> that receives the hit test code that indicates whether the point in <i>ptTest</i>
///                    is in the background area bounded by <i>pRect</i> or <i>hrgn</i>. See Hit Test Return Values for a list of values
///                    returned.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT HitTestThemeBackground(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, uint dwOptions, RECT* pRect, 
                               HRGN hrgn, POINT ptTest, ushort* pwHitTestCode);

///Draws one or more edges defined by the visual style of a rectangle.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the rectangle. See Parts and
///              States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    pDestRect = Type: <b>LPCRECT</b> Pointer to a RECT structure that contains, in logical coordinates, the rectangle.
///    uEdge = Type: <b>UINT</b> <b>UINT</b> that specifies the type of inner and outer edges to draw. This parameter must be a
///            combination of one inner-border flag and one outer-border flag, or one of the combination flags. The border flags
///            are: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
///            <dt>BDR_RAISEDINNER</dt> </dl> </td> <td width="60%"> Raised inner edge </td> </tr> <tr> <td width="40%"><a
///            id=""></a><dl> <dt><b></b></dt> <dt>BDR_SUNKENINNER</dt> </dl> </td> <td width="60%"> Sunken inner edge </td>
///            </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>BDR_RAISEDOUTER</dt> </dl> </td> <td
///            width="60%"> Raised outer edge </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
///            <dt>BDR_SUNKENOUTER</dt> </dl> </td> <td width="60%"> Sunken outer edge </td> </tr> <tr> <td width="40%"><a
///            id=""></a><dl> <dt><b></b></dt> <dt>EDGE_BUMP</dt> </dl> </td> <td width="60%"> Combination of BDR_RAISEDOUTER
///            and BDR_SUNKENINNER </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>EDGE_ETCHED</dt>
///            </dl> </td> <td width="60%"> Combination of BDR_SUNKENOUTER and BDR_RAISEDINNER </td> </tr> <tr> <td
///            width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>EDGE_RAISED</dt> </dl> </td> <td width="60%"> Combination of
///            BDR_RAISEDOUTER and BDR_RAISEDINNER </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
///            <dt>EDGE_SUNKEN</dt> </dl> </td> <td width="60%"> Combination of BDR_SUNKENOUTER and BDR_SUNKENINNER </td> </tr>
///            </table>
///    uFlags = Type: <b>UINT</b> <b>UINT</b> that specifies the type of border to draw. This parameter can be a combination of
///             the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl>
///             <dt><b></b></dt> <dt>BF_ADJUST</dt> </dl> </td> <td width="60%"> The rectangle pointed to by the <i>pDestRect</i>
///             parameter is shrunk to exclude the edges that were drawn; otherwise the rectangle does not change. </td> </tr>
///             <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>BF_BOTTOM</dt> </dl> </td> <td width="60%"> Bottom of
///             border rectangle. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>BF_BOTTOMLEFT</dt>
///             </dl> </td> <td width="60%"> Bottom and left side of border rectangle. </td> </tr> <tr> <td width="40%"><a
///             id=""></a><dl> <dt><b></b></dt> <dt>BF_BOTTOMRIGHT</dt> </dl> </td> <td width="60%"> Bottom and right side of
///             border rectangle. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>BF_DIAGONAL</dt> </dl>
///             </td> <td width="60%"> Diagonal border. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
///             <dt>BF_DIAGONAL_ENDBOTTOMLEFT</dt> </dl> </td> <td width="60%"> Diagonal border. The end point is the lower-left
///             corner of the rectangle; the origin is the upper-right corner. </td> </tr> <tr> <td width="40%"><a id=""></a><dl>
///             <dt><b></b></dt> <dt>BF_DIAGONAL_ENDBOTTOMRIGHT</dt> </dl> </td> <td width="60%"> Diagonal border. The end point
///             is the lower-right corner of the rectangle; the origin is the upper-left corner. </td> </tr> <tr> <td
///             width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>BF_DIAGONAL_ENDTOPLEFT</dt> </dl> </td> <td width="60%">
///             Diagonal border. The end point is the upper-left corner of the rectangle; the origin is the lower-right corner.
///             </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>BF_DIAGONAL_ENDTOPRIGHT</dt> </dl> </td>
///             <td width="60%"> Diagonal border. The end point is the upper-right corner of the rectangle; the origin is the
///             lower-left corner. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>BF_FLAT</dt> </dl>
///             </td> <td width="60%"> Flat border. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
///             <dt>BF_LEFT</dt> </dl> </td> <td width="60%"> Left side of border rectangle. </td> </tr> <tr> <td width="40%"><a
///             id=""></a><dl> <dt><b></b></dt> <dt>BF_MIDDLE</dt> </dl> </td> <td width="60%"> Interior of the rectangle is to
///             be filled. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>BF_MONO</dt> </dl> </td> <td
///             width="60%"> One-dimensional border. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
///             <dt>BF_RECT</dt> </dl> </td> <td width="60%"> Entire border rectangle. </td> </tr> <tr> <td width="40%"><a
///             id=""></a><dl> <dt><b></b></dt> <dt>BF_RIGHT</dt> </dl> </td> <td width="60%"> Right side of border rectangle.
///             </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>BF_SOFT</dt> </dl> </td> <td width="60%">
///             Soft buttons instead of tiles. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
///             <dt>BF_TOP</dt> </dl> </td> <td width="60%"> Top of border rectangle. </td> </tr> <tr> <td width="40%"><a
///             id=""></a><dl> <dt><b></b></dt> <dt>BF_TOPLEFT</dt> </dl> </td> <td width="60%"> Top and left side of border
///             rectangle. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>BF_TOPRIGHT</dt> </dl> </td>
///             <td width="60%"> Top and right side of border rectangle. </td> </tr> </table>
///    pContentRect = Type: <b>LPRECT</b> Pointer to a RECT structure that contains, in logical coordinates, the rectangle that
///                   receives the interior rectangle, if <i>uFlags</i> is set to BF_ADJUST. This parameter may be set to <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT DrawThemeEdge(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, RECT* pDestRect, uint uEdge, 
                      uint uFlags, RECT* pContentRect);

///Draws an image from an image list with the icon effect defined by the visual style.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part in which the image is drawn. See Parts and
///              States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    pRect = Type: <b>LPCRECT</b> Pointer to a RECT structure that contains, in logical coordinates, the rectangle in which
///            the image is drawn.
///    himl = Type: <b>HIMAGELIST</b> Handle to an image list that contains the image to draw.
///    iImageIndex = Type: <b>int</b> Value of type <b>int</b> that specifies the index of the image to draw.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT DrawThemeIcon(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, RECT* pRect, HIMAGELIST himl, 
                      int iImageIndex);

///Retrieves whether a visual style has defined parameters for the specified part and state.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part. See Parts and States.
///    iStateId = Type: <b>int</b> Currently unused. The value should be 0.
@DllImport("UXTHEME")
BOOL IsThemePartDefined(ptrdiff_t hTheme, int iPartId, int iStateId);

///Retrieves whether the background specified by the visual style has transparent pieces or alpha-blended pieces.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part. See Parts and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
@DllImport("UxTheme")
BOOL IsThemeBackgroundPartiallyTransparent(ptrdiff_t hTheme, int iPartId, int iStateId);

///Retrieves the value of a color property.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the color property. See Parts and
///              States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    iPropId = Type: <b>int</b> Value of type <b>int</b> that specifies the property to retrieve. For a list of possible values,
///              see Property Identifiers.
///    pColor = Type: <b>COLORREF*</b> Pointer to a COLORREF structure that receives the color value.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT GetThemeColor(ptrdiff_t hTheme, int iPartId, int iStateId, int iPropId, uint* pColor);

///Retrieves the value of a metric property.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC. This parameter may be set to <b>NULL</b>.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the metric property. See Parts
///              and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    iPropId = Type: <b>int</b> Value of type <b>int</b> that specifies the property to retrieve. Can be one of the following
///              values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TMT_ALPHALEVEL"></a><a
///              id="tmt_alphalevel"></a><dl> <dt><b>TMT_ALPHALEVEL</b></dt> </dl> </td> <td width="60%"> The alpha value (0-255)
///              used for DrawThemeIcon. </td> </tr> <tr> <td width="40%"><a id="TMT_ALPHATHRESHOLD"></a><a
///              id="tmt_alphathreshold"></a><dl> <dt><b>TMT_ALPHATHRESHOLD</b></dt> </dl> </td> <td width="60%"> The minimum
///              alpha value (0-255) that a pixel must be to be considered opaque. </td> </tr> <tr> <td width="40%"><a
///              id="TMT_BORDERSIZE"></a><a id="tmt_bordersize"></a><dl> <dt><b>TMT_BORDERSIZE</b></dt> </dl> </td> <td
///              width="60%"> The thickness of the border drawn if this part uses a border fill. </td> </tr> <tr> <td
///              width="40%"><a id="TMT_GLYPHINDEX"></a><a id="tmt_glyphindex"></a><dl> <dt><b>TMT_GLYPHINDEX</b></dt> </dl> </td>
///              <td width="60%"> The character index into the selected font that will be used for the glyph, if the part uses a
///              font-based glyph. </td> </tr> <tr> <td width="40%"><a id="TMT_GRADIENTRATIO1"></a><a
///              id="tmt_gradientratio1"></a><dl> <dt><b>TMT_GRADIENTRATIO1</b></dt> </dl> </td> <td width="60%"> The amount of
///              the first gradient color to use in drawing the part. This value can be from 0 to 255, but this value plus the
///              values of each of the GRADIENTRATIO values must add up to 255. See the TMT_GRADIENTCOLOR1 value of GetThemeColor.
///              </td> </tr> <tr> <td width="40%"><a id="TMT_GRADIENTRATIO2"></a><a id="tmt_gradientratio2"></a><dl>
///              <dt><b>TMT_GRADIENTRATIO2</b></dt> </dl> </td> <td width="60%"> The amount of the second gradient color to use in
///              drawing the part. </td> </tr> <tr> <td width="40%"><a id="TMT_GRADIENTRATIO3"></a><a
///              id="tmt_gradientratio3"></a><dl> <dt><b>TMT_GRADIENTRATIO3</b></dt> </dl> </td> <td width="60%"> The amount of
///              the third gradient color to use in drawing the part. </td> </tr> <tr> <td width="40%"><a
///              id="TMT_GRADIENTRATIO4"></a><a id="tmt_gradientratio4"></a><dl> <dt><b>TMT_GRADIENTRATIO4</b></dt> </dl> </td>
///              <td width="60%"> The amount of the fourth gradient color to use in drawing the part. </td> </tr> <tr> <td
///              width="40%"><a id="TMT_GRADIENTRATIO5"></a><a id="tmt_gradientratio5"></a><dl> <dt><b>TMT_GRADIENTRATIO5</b></dt>
///              </dl> </td> <td width="60%"> The amount of the fifth gradient color to use in drawing the part. </td> </tr> <tr>
///              <td width="40%"><a id="TMT_HEIGHT"></a><a id="tmt_height"></a><dl> <dt><b>TMT_HEIGHT</b></dt> </dl> </td> <td
///              width="60%"> The height of the part. </td> </tr> <tr> <td width="40%"><a id="TMT_IMAGECOUNT"></a><a
///              id="tmt_imagecount"></a><dl> <dt><b>TMT_IMAGECOUNT</b></dt> </dl> </td> <td width="60%"> The number of state
///              images present in an image file. </td> </tr> <tr> <td width="40%"><a id="TMT_MINDPI1"></a><a
///              id="tmt_mindpi1"></a><dl> <dt><b>TMT_MINDPI1</b></dt> </dl> </td> <td width="60%"> The minimum dpi that the first
///              image file was designed for. See GetThemeFilename. </td> </tr> <tr> <td width="40%"><a id="TMT_MINDPI2"></a><a
///              id="tmt_mindpi2"></a><dl> <dt><b>TMT_MINDPI2</b></dt> </dl> </td> <td width="60%"> The minimum dpi that the
///              second image file was designed for. </td> </tr> <tr> <td width="40%"><a id="TMT_MINDPI3"></a><a
///              id="tmt_mindpi3"></a><dl> <dt><b>TMT_MINDPI3</b></dt> </dl> </td> <td width="60%"> The minimum dpi that the third
///              image file was designed for. </td> </tr> <tr> <td width="40%"><a id="TMT_MINDPI4"></a><a
///              id="tmt_mindpi4"></a><dl> <dt><b>TMT_MINDPI4</b></dt> </dl> </td> <td width="60%"> The minimum dpi that the
///              fourth image file was designed for. </td> </tr> <tr> <td width="40%"><a id="TMT_MINDPI5"></a><a
///              id="tmt_mindpi5"></a><dl> <dt><b>TMT_MINDPI5</b></dt> </dl> </td> <td width="60%"> The minimum dpi that the fifth
///              image file was designed for. </td> </tr> <tr> <td width="40%"><a id="TMT_PROGRESSCHUNKSIZE"></a><a
///              id="tmt_progresschunksize"></a><dl> <dt><b>TMT_PROGRESSCHUNKSIZE</b></dt> </dl> </td> <td width="60%"> The size
///              of the progress control "chunk" shapes that define how far an operation has progressed. </td> </tr> <tr> <td
///              width="40%"><a id="TMT_PROGRESSSPACESIZE"></a><a id="tmt_progressspacesize"></a><dl>
///              <dt><b>TMT_PROGRESSSPACESIZE</b></dt> </dl> </td> <td width="60%"> The total size of all of the progress control
///              "chunks". </td> </tr> <tr> <td width="40%"><a id="TMT_ROUNDCORNERWIDTH"></a><a id="tmt_roundcornerwidth"></a><dl>
///              <dt><b>TMT_ROUNDCORNERWIDTH</b></dt> </dl> </td> <td width="60%"> The roundness (0-100%) of the part's corners.
///              </td> </tr> <tr> <td width="40%"><a id="TMT_ROUNDCORNERHEIGHT"></a><a id="tmt_roundcornerheight"></a><dl>
///              <dt><b>TMT_ROUNDCORNERHEIGHT</b></dt> </dl> </td> <td width="60%"> The roundness (0-100%) of the part's corners.
///              </td> </tr> <tr> <td width="40%"><a id="TMT_SATURATION"></a><a id="tmt_saturation"></a><dl>
///              <dt><b>TMT_SATURATION</b></dt> </dl> </td> <td width="60%"> The amount of saturation (0-255) to apply to an icon
///              drawn using DrawThemeIcon. </td> </tr> <tr> <td width="40%"><a id="TMT_TEXTBORDERSIZE"></a><a
///              id="tmt_textbordersize"></a><dl> <dt><b>TMT_TEXTBORDERSIZE</b></dt> </dl> </td> <td width="60%"> The thickness of
///              the border drawn around text characters. </td> </tr> <tr> <td width="40%"><a id="TMT_TRUESIZESTRETCHMARK"></a><a
///              id="tmt_truesizestretchmark"></a><dl> <dt><b>TMT_TRUESIZESTRETCHMARK</b></dt> </dl> </td> <td width="60%"> The
///              percentage of a true-size image's original size at which the image will be stretched. </td> </tr> <tr> <td
///              width="40%"><a id="TMT_WIDTH"></a><a id="tmt_width"></a><dl> <dt><b>TMT_WIDTH</b></dt> </dl> </td> <td
///              width="60%"> The width of the part. </td> </tr> </table>
///    piVal = Type: <b>int*</b> Pointer to an <b>int</b> that receives the metric property value.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT GetThemeMetric(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, int iPropId, int* piVal);

///Retrieves the value of a string property.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part containing the string property. See Parts and
///              States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    iPropId = Type: <b>int</b> Value of type <b>int</b> that specifies the property to retrieve. For a list of possible values,
///              see Property Identifiers.
///    pszBuff = Type: <b>LPWSTR</b> Pointer to a buffer that receives the string value.
///    cchMaxBuffChars = Type: <b>int</b> Value of type <b>int</b> that specifies the maximum number of characters <i>pszBuff</i> can
///                      contain.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT GetThemeString(ptrdiff_t hTheme, int iPartId, int iStateId, int iPropId, PWSTR pszBuff, 
                       int cchMaxBuffChars);

///Retrieves the value of a <b>BOOL</b> property from the SysMetrics section of theme data.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part containing the BOOL property. See Parts and
///              States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    iPropId = Type: <b>int</b> Value of type <b>int</b> that specifies the property to retrieve. May be one of the following
///              values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TMT_TRANSPARENT"></a><a
///              id="tmt_transparent"></a><dl> <dt><b>TMT_TRANSPARENT</b></dt> </dl> </td> <td width="60%"> <b>TRUE</b> if the
///              image associated with the part and state have transparent areas. See GetThemeColor for the definition of the
///              TMT_TRANSPARENTCOLOR value that defines the transparent color. </td> </tr> <tr> <td width="40%"><a
///              id="TMT_AUTOSIZE"></a><a id="tmt_autosize"></a><dl> <dt><b>TMT_AUTOSIZE</b></dt> </dl> </td> <td width="60%">
///              <b>TRUE</b> if the nonclient caption area associated with the part and state vary with text width. </td> </tr>
///              <tr> <td width="40%"><a id="TMT_BORDERONLY"></a><a id="tmt_borderonly"></a><dl> <dt><b>TMT_BORDERONLY</b></dt>
///              </dl> </td> <td width="60%"> <b>TRUE</b> if the image associated with the part and state should only have its
///              border drawn. </td> </tr> <tr> <td width="40%"><a id="TMT_COMPOSITED"></a><a id="tmt_composited"></a><dl>
///              <dt><b>TMT_COMPOSITED</b></dt> </dl> </td> <td width="60%"> <b>TRUE</b> if the control associated with the part
///              and state will handle its own compositing of images. </td> </tr> <tr> <td width="40%"><a id="TMT_BGFILL"></a><a
///              id="tmt_bgfill"></a><dl> <dt><b>TMT_BGFILL</b></dt> </dl> </td> <td width="60%"> <b>TRUE</b> if true-sized images
///              associated with this part and state are to be drawn on the background fill. </td> </tr> <tr> <td width="40%"><a
///              id="TMT_GLYPHTRANSPARENT"></a><a id="tmt_glyphtransparent"></a><dl> <dt><b>TMT_GLYPHTRANSPARENT</b></dt> </dl>
///              </td> <td width="60%"> <b>TRUE</b> if the glyph associated with this part and state have transparent areas. See
///              GetThemeColor for the definition of the TMT_GLYPHCOLOR value that defines the transparent color. </td> </tr> <tr>
///              <td width="40%"><a id="TMT_GLYPHONLY"></a><a id="tmt_glyphonly"></a><dl> <dt><b>TMT_GLYPHONLY</b></dt> </dl>
///              </td> <td width="60%"> <b>TRUE</b> if the glyph associated with this part and state should be drawn without a
///              background. </td> </tr> <tr> <td width="40%"><a id="TMT_ALWAYSSHOWSIZINGBAR"></a><a
///              id="tmt_alwaysshowsizingbar"></a><dl> <dt><b>TMT_ALWAYSSHOWSIZINGBAR</b></dt> </dl> </td> <td width="60%">
///              <b>TRUE</b> if the sizing bar associated with this part and state should always be shown. </td> </tr> <tr> <td
///              width="40%"><a id="TMT_MIRRORIMAGE"></a><a id="tmt_mirrorimage"></a><dl> <dt><b>TMT_MIRRORIMAGE</b></dt> </dl>
///              </td> <td width="60%"> <b>TRUE</b> if the image associated with this part and state should be flipped if the
///              window is being viewed in right-to-left reading mode. </td> </tr> <tr> <td width="40%"><a
///              id="TMT_UNIFORMSIZING"></a><a id="tmt_uniformsizing"></a><dl> <dt><b>TMT_UNIFORMSIZING</b></dt> </dl> </td> <td
///              width="60%"> <b>TRUE</b> if the image associated with this part and state must have equal height and width. </td>
///              </tr> <tr> <td width="40%"><a id="TMT_INTEGRALSIZING"></a><a id="tmt_integralsizing"></a><dl>
///              <dt><b>TMT_INTEGRALSIZING</b></dt> </dl> </td> <td width="60%"> <b>TRUE</b> if the truesize image or border
///              associated with this part and state must be sized to a factor of 2. </td> </tr> <tr> <td width="40%"><a
///              id="TMT_SOURCEGROW"></a><a id="tmt_sourcegrow"></a><dl> <dt><b>TMT_SOURCEGROW</b></dt> </dl> </td> <td
///              width="60%"> <b>TRUE</b> if the image associated with this part and state will scale larger in size if necessary.
///              </td> </tr> <tr> <td width="40%"><a id="TMT_SOURCESHRINK"></a><a id="tmt_sourceshrink"></a><dl>
///              <dt><b>TMT_SOURCESHRINK</b></dt> </dl> </td> <td width="60%"> <b>TRUE</b> if the image associated with this part
///              and state will scale smaller in size if necessary. </td> </tr> <tr> <td width="40%"><a
///              id="TMT_USERPICTURE"></a><a id="tmt_userpicture"></a><dl> <dt><b>TMT_USERPICTURE</b></dt> </dl> </td> <td
///              width="60%"> <b>TRUE</b> if the image associated with this part and state is based on the current user. </td>
///              </tr> </table>
///    pfVal = Type: <b>BOOL*</b> Pointer to a <b>BOOL</b> that receives the retrieved property value.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT GetThemeBool(ptrdiff_t hTheme, int iPartId, int iStateId, int iPropId, BOOL* pfVal);

///Retrieves the value of an <b>int</b> property.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the <b>int</b> property. See
///              Parts and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    iPropId = Type: <b>int</b> Value of type <b>int</b> that specifies the property to retrieve. For a list of possible values,
///              see Property Identifiers.
///    piVal = Type: <b>int*</b> Pointer to an <b>int</b> that receives the retrieved value.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT GetThemeInt(ptrdiff_t hTheme, int iPartId, int iStateId, int iPropId, int* piVal);

///Retrieves the value of an enumerated type property.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the enumerated type property. See
///              Parts and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    iPropId = Type: <b>int</b> Value of type <b>int</b> that specifies the property to retrieve. For a list of possible values,
///              see Property Identifiers.
///    piVal = Type: <b>int*</b> Pointer to an <b>int</b> that receives the enumerated type value.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT GetThemeEnumValue(ptrdiff_t hTheme, int iPartId, int iStateId, int iPropId, int* piVal);

///Retrieves the value of a position property.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the position property. See Parts
///              and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    iPropId = Type: <b>int</b> Value of type <b>int</b> that specifies the property to retrieve. For a list of possible values,
///              see Property Identifiers.
///    pPoint = Type: <b>POINT*</b> Pointer to a POINT structure that receives the position value.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT GetThemePosition(ptrdiff_t hTheme, int iPartId, int iStateId, int iPropId, POINT* pPoint);

///Retrieves the value of a font property.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC. This parameter may be set to <b>NULL</b>.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the font property. See Parts and
///              States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    iPropId = Type: <b>int</b> Value of type <b>int</b> that specifies the property to retrieve. For a list of possible values,
///              see Property Identifiers.
///    pFont = Type: <b>LOGFONTW*</b> Pointer to a LOGFONT structure that receives the font property value.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT GetThemeFont(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, int iPropId, LOGFONTW* pFont);

///Retrieves the value of a RECT property.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part containing the RECT property. See Parts and
///              States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    iPropId = Type: <b>int</b> Value of type <b>int</b> that specifies the property to retrieve. For a list of possible values,
///              see Property Identifiers.
///    pRect = Type: <b>LPRECT</b> Pointer to a RECT structure that receives a rectangle.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT GetThemeRect(ptrdiff_t hTheme, int iPartId, int iStateId, int iPropId, RECT* pRect);

///Retrieves the value of a MARGINS property.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC to select fonts into. This parameter may be set to <b>NULL</b>.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the MARGINS property. See Parts
///              and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    iPropId = Type: <b>int</b> Value of type <b>int</b> that specifies the property to retrieve. For a list of possible values,
///              see Property Identifiers.
///    prc = Type: <b>LPRECT</b> Pointer to a RECT structure that contains the rectangle that specifies the area to be drawn
///          into. This parameter may be set to <b>NULL</b>.
///    pMargins = Type: <b>MARGINS*</b> Pointer to a MARGINS structure that receives the retrieved value.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT GetThemeMargins(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, int iPropId, RECT* prc, 
                        MARGINS* pMargins);

///Retrieves a list of <b>int</b> data from a visual style.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the list of data to return. See
///              Parts and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    iPropId = Type: <b>int</b> Value of type <b>int</b> that specifies the property to retrieve. See Property Identifiers.
///    pIntList = Type: <b>INTLIST*</b> Pointer to an INTLIST structure that receives the <b>int</b> data.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, otherwise an error code.
///    
@DllImport("UxTheme")
HRESULT GetThemeIntList(ptrdiff_t hTheme, int iPartId, int iStateId, int iPropId, INTLIST* pIntList);

///Retrieves the location of the theme property definition for a property.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the theme. See Parts and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    iPropId = Type: <b>int</b> Value of type <b>int</b> that specifies the property to retrieve. You may use any of the
///              property values from Vssym32.h. These values are described in the reference pages for the functions that use
///              them. For instance, the GetThemeInt function uses the TMT_BORDERSIZE value. See the Visual Styles Reference for a
///              list of functions.
///    arg5 = Type: <b>PROPERTYORIGIN*</b> Pointer to a PROPERTYORIGIN enumerated type that indicates where the property was or
///           was not found.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT GetThemePropertyOrigin(ptrdiff_t hTheme, int iPartId, int iStateId, int iPropId, PROPERTYORIGIN* pOrigin);

///Causes a window to use a different set of visual style information than its class normally uses.
///Params:
///    hwnd = Type: <b>HWND</b> Handle to the window whose visual style information is to be changed.
///    pszSubAppName = Type: <b>LPCWSTR</b> Pointer to a string that contains the application name to use in place of the calling
///                    application's name. If this parameter is <b>NULL</b>, the calling application's name is used.
///    pszSubIdList = Type: <b>LPCWSTR</b> Pointer to a string that contains a semicolon-separated list of CLSID names to use in place
///                   of the actual list passed by the window's class. If this parameter is <b>NULL</b>, the ID list from the calling
///                   class is used.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT SetWindowTheme(HWND hwnd, const(PWSTR) pszSubAppName, const(PWSTR) pszSubIdList);

///Retrieves the value of a filename property.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    iPartId = Type: <b>int</b> Value of type <b>int</b> that specifies the part that contains the filename property. See Parts
///              and States.
///    iStateId = Type: <b>int</b> Value of type <b>int</b> that specifies the state of the part. See Parts and States.
///    iPropId = Type: <b>int</b> Value of type <b>int</b> that specifies the property to retrieve. For a list of possible values,
///              see Property Identifiers.
///    pszThemeFileName = Type: <b>LPWSTR</b> Pointer to a buffer that receives the retrieved file name.
///    cchMaxBuffChars = Type: <b>int</b> Value of type <b>int</b> that receives the maximum number of characters in the file name
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT GetThemeFilename(ptrdiff_t hTheme, int iPartId, int iStateId, int iPropId, PWSTR pszThemeFileName, 
                         int cchMaxBuffChars);

///Retrieves the value of a system color.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to theme data.
///    iColorId = Type: <b>int</b> Value of type <b>int</b> that specifies the color number. May be one of the values listed in
///               GetSysColor for the <i>nIndex</i> parameter.
///Returns:
///    Type: <b>COLORREF</b> The value of the specified system color.
///    
@DllImport("UxTheme")
uint GetThemeSysColor(ptrdiff_t hTheme, int iColorId);

///Retrieves a system color brush.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to theme data.
///    iColorId = Type: <b>int</b> Value of type <b>int</b> that specifies the number of the desired system color. May be one of
///               the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="TMT_SCROLLBAR"></a><a id="tmt_scrollbar"></a><dl> <dt><b>TMT_SCROLLBAR</b></dt> </dl> </td> <td width="60%">
///               The color of scroll bars. </td> </tr> <tr> <td width="40%"><a id="TMT_BACKGROUND"></a><a
///               id="tmt_background"></a><dl> <dt><b>TMT_BACKGROUND</b></dt> </dl> </td> <td width="60%"> The color of the
///               background. </td> </tr> <tr> <td width="40%"><a id="TMT_ACTIVECAPTION"></a><a id="tmt_activecaption"></a><dl>
///               <dt><b>TMT_ACTIVECAPTION</b></dt> </dl> </td> <td width="60%"> The color of the caption area on an active window.
///               </td> </tr> <tr> <td width="40%"><a id="TMT_INACTIVECAPTION"></a><a id="tmt_inactivecaption"></a><dl>
///               <dt><b>TMT_INACTIVECAPTION</b></dt> </dl> </td> <td width="60%"> The color of the caption area on an inactive
///               window. </td> </tr> <tr> <td width="40%"><a id="TMT_WINDOW"></a><a id="tmt_window"></a><dl>
///               <dt><b>TMT_WINDOW</b></dt> </dl> </td> <td width="60%"> The color of a window. </td> </tr> <tr> <td
///               width="40%"><a id="TMT_WINDOWFRAME"></a><a id="tmt_windowframe"></a><dl> <dt><b>TMT_WINDOWFRAME</b></dt> </dl>
///               </td> <td width="60%"> The color of the frame around a window. </td> </tr> <tr> <td width="40%"><a
///               id="TMT_MENUTEXT"></a><a id="tmt_menutext"></a><dl> <dt><b>TMT_MENUTEXT</b></dt> </dl> </td> <td width="60%"> The
///               color of text drawn on a menu. </td> </tr> <tr> <td width="40%"><a id="TMT_WINDOWTEXT"></a><a
///               id="tmt_windowtext"></a><dl> <dt><b>TMT_WINDOWTEXT</b></dt> </dl> </td> <td width="60%"> The color of text drawn
///               in a window. </td> </tr> <tr> <td width="40%"><a id="TMT_CAPTIONTEXT"></a><a id="tmt_captiontext"></a><dl>
///               <dt><b>TMT_CAPTIONTEXT</b></dt> </dl> </td> <td width="60%"> The color of text drawn in the caption area of an
///               active window. </td> </tr> <tr> <td width="40%"><a id="TMT_ACTIVEBORDER"></a><a id="tmt_activeborder"></a><dl>
///               <dt><b>TMT_ACTIVEBORDER</b></dt> </dl> </td> <td width="60%"> The color of the border around an active window.
///               </td> </tr> <tr> <td width="40%"><a id="TMT_INACTIVEBORDER"></a><a id="tmt_inactiveborder"></a><dl>
///               <dt><b>TMT_INACTIVEBORDER</b></dt> </dl> </td> <td width="60%"> The color of the border around an inactive
///               window. </td> </tr> <tr> <td width="40%"><a id="TMT_APPWORKSPACE"></a><a id="tmt_appworkspace"></a><dl>
///               <dt><b>TMT_APPWORKSPACE</b></dt> </dl> </td> <td width="60%"> The color of the application workspace. </td> </tr>
///               <tr> <td width="40%"><a id="TMT_HIGHLIGHT"></a><a id="tmt_highlight"></a><dl> <dt><b>TMT_HIGHLIGHT</b></dt> </dl>
///               </td> <td width="60%"> The color of a highlight. </td> </tr> <tr> <td width="40%"><a
///               id="TMT_HIGHLIGHTTEXT"></a><a id="tmt_highlighttext"></a><dl> <dt><b>TMT_HIGHLIGHTTEXT</b></dt> </dl> </td> <td
///               width="60%"> The color of highlighted text. </td> </tr> <tr> <td width="40%"><a id="TMT_BTNFACE"></a><a
///               id="tmt_btnface"></a><dl> <dt><b>TMT_BTNFACE</b></dt> </dl> </td> <td width="60%"> The color of a button face.
///               </td> </tr> <tr> <td width="40%"><a id="TMT_BTNSHADOW"></a><a id="tmt_btnshadow"></a><dl>
///               <dt><b>TMT_BTNSHADOW</b></dt> </dl> </td> <td width="60%"> The color of the shadow underneath a button. </td>
///               </tr> <tr> <td width="40%"><a id="TMT_GRAYTEXT"></a><a id="tmt_graytext"></a><dl> <dt><b>TMT_GRAYTEXT</b></dt>
///               </dl> </td> <td width="60%"> The color of dimmed text. </td> </tr> <tr> <td width="40%"><a
///               id="TMT_BTNTEXT"></a><a id="tmt_btntext"></a><dl> <dt><b>TMT_BTNTEXT</b></dt> </dl> </td> <td width="60%"> The
///               color of text contained within a button. </td> </tr> <tr> <td width="40%"><a id="TMT_INACTIVECAPTIONTEXT"></a><a
///               id="tmt_inactivecaptiontext"></a><dl> <dt><b>TMT_INACTIVECAPTIONTEXT</b></dt> </dl> </td> <td width="60%"> The
///               color of the text in the caption area of an inactive window. </td> </tr> <tr> <td width="40%"><a
///               id="TMT_BTNHIGHLIGHT"></a><a id="tmt_btnhighlight"></a><dl> <dt><b>TMT_BTNHIGHLIGHT</b></dt> </dl> </td> <td
///               width="60%"> The color of the highlight around a button. </td> </tr> <tr> <td width="40%"><a
///               id="TMT_DKSHADOW3D"></a><a id="tmt_dkshadow3d"></a><dl> <dt><b>TMT_DKSHADOW3D</b></dt> </dl> </td> <td
///               width="60%"> The color of three-dimensional dark shadows. </td> </tr> <tr> <td width="40%"><a
///               id="TMT_LIGHT3D"></a><a id="tmt_light3d"></a><dl> <dt><b>TMT_LIGHT3D</b></dt> </dl> </td> <td width="60%"> The
///               color of three-dimensional light areas. </td> </tr> <tr> <td width="40%"><a id="TMT_INFOTEXT"></a><a
///               id="tmt_infotext"></a><dl> <dt><b>TMT_INFOTEXT</b></dt> </dl> </td> <td width="60%"> The color of informational
///               text. </td> </tr> <tr> <td width="40%"><a id="TMT_INFOBK"></a><a id="tmt_infobk"></a><dl>
///               <dt><b>TMT_INFOBK</b></dt> </dl> </td> <td width="60%"> The color of the background behind informational text.
///               </td> </tr> <tr> <td width="40%"><a id="TMT_BUTTONALTERNATEFACE"></a><a id="tmt_buttonalternateface"></a><dl>
///               <dt><b>TMT_BUTTONALTERNATEFACE</b></dt> </dl> </td> <td width="60%"> The color of the alternate face of a button.
///               </td> </tr> <tr> <td width="40%"><a id="TMT_HOTTRACKING"></a><a id="tmt_hottracking"></a><dl>
///               <dt><b>TMT_HOTTRACKING</b></dt> </dl> </td> <td width="60%"> The color of highlight applied when a user moves the
///               mouse over a control. </td> </tr> <tr> <td width="40%"><a id="TMT_GRADIENTACTIVECAPTION"></a><a
///               id="tmt_gradientactivecaption"></a><dl> <dt><b>TMT_GRADIENTACTIVECAPTION</b></dt> </dl> </td> <td width="60%">
///               The gradient color applied to the caption area of an active window. </td> </tr> <tr> <td width="40%"><a
///               id="TMT_GRADIENTINACTIVECAPTION"></a><a id="tmt_gradientinactivecaption"></a><dl>
///               <dt><b>TMT_GRADIENTINACTIVECAPTION</b></dt> </dl> </td> <td width="60%"> The gradient color applied to the
///               caption area of an inactive window. </td> </tr> <tr> <td width="40%"><a id="TMT_MENUHILIGHT"></a><a
///               id="tmt_menuhilight"></a><dl> <dt><b>TMT_MENUHILIGHT</b></dt> </dl> </td> <td width="60%"> The color of highlight
///               drawn on a menu item when the user moves the mouse over it. </td> </tr> <tr> <td width="40%"><a
///               id="TMT_MENUBAR"></a><a id="tmt_menubar"></a><dl> <dt><b>TMT_MENUBAR</b></dt> </dl> </td> <td width="60%"> The
///               color of the menu bar. </td> </tr> </table>
///Returns:
///    Type: <b>HBRUSH</b> Handle to brush data.
///    
@DllImport("UxTheme")
HBRUSH GetThemeSysColorBrush(ptrdiff_t hTheme, int iColorId);

///Retrieves the Boolean value of a system metric.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to theme data.
///    iBoolId = Type: <b>int</b> Value of type <b>int</b> that specifies the system Boolean metric desired. May be the following
///              value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TMT_FLATMENUS"></a><a
///              id="tmt_flatmenus"></a><dl> <dt><b>TMT_FLATMENUS</b></dt> </dl> </td> <td width="60%"> Describes how menus are
///              drawn. If <b>TRUE</b>, menus are drawn without shadows. If <b>FALSE</b>, menus have shadows underneath them.
///              </td> </tr> </table>
///Returns:
///    Type: <b>BOOL</b> Value of desired system metric.
///    
@DllImport("UxTheme")
BOOL GetThemeSysBool(ptrdiff_t hTheme, int iBoolId);

///Retrieves the value of a system size metric from theme data.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to theme data.
///    iSizeId = Type: <b>int</b> Value of type <b>int</b> that specifies the system size metric desired. The following values are
///              valid: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SM_CXBORDER"></a><a
///              id="sm_cxborder"></a><dl> <dt><b>SM_CXBORDER</b></dt> </dl> </td> <td width="60%"> Specifies the width of a
///              border. </td> </tr> <tr> <td width="40%"><a id="SM_CXVSCROLL"></a><a id="sm_cxvscroll"></a><dl>
///              <dt><b>SM_CXVSCROLL</b></dt> </dl> </td> <td width="60%"> Specifies the width of a scroll bar. </td> </tr> <tr>
///              <td width="40%"><a id="SM_CXHSCROLL"></a><a id="sm_cxhscroll"></a><dl> <dt><b>SM_CXHSCROLL</b></dt> </dl> </td>
///              <td width="60%"> Specifies the height of a scroll bar. </td> </tr> <tr> <td width="40%"><a id="SM_CXSIZE"></a><a
///              id="sm_cxsize"></a><dl> <dt><b>SM_CXSIZE</b></dt> </dl> </td> <td width="60%"> Specifies the width of a caption.
///              </td> </tr> <tr> <td width="40%"><a id="SM_CYSIZE"></a><a id="sm_cysize"></a><dl> <dt><b>SM_CYSIZE</b></dt> </dl>
///              </td> <td width="60%"> Specifies the height of a caption. </td> </tr> <tr> <td width="40%"><a
///              id="SM_CXSMSIZE"></a><a id="sm_cxsmsize"></a><dl> <dt><b>SM_CXSMSIZE</b></dt> </dl> </td> <td width="60%">
///              Specifies the width of a small caption. </td> </tr> <tr> <td width="40%"><a id="SM_CYSMSIZE"></a><a
///              id="sm_cysmsize"></a><dl> <dt><b>SM_CYSMSIZE</b></dt> </dl> </td> <td width="60%"> Specifies the height of a
///              small caption. </td> </tr> <tr> <td width="40%"><a id="SM_CXMENUSIZE"></a><a id="sm_cxmenusize"></a><dl>
///              <dt><b>SM_CXMENUSIZE</b></dt> </dl> </td> <td width="60%"> Specifies the width of a menu bar. </td> </tr> <tr>
///              <td width="40%"><a id="SM_CYMENUSIZE"></a><a id="sm_cymenusize"></a><dl> <dt><b>SM_CYMENUSIZE</b></dt> </dl>
///              </td> <td width="60%"> Specifies the height of a menu bar. </td> </tr> <tr> <td width="40%"><a
///              id="SM_CXPADDEDBORDER"></a><a id="sm_cxpaddedborder"></a><dl> <dt><b>SM_CXPADDEDBORDER</b></dt> </dl> </td> <td
///              width="60%"> Specifies the amount of border padding for captioned windows. </td> </tr> </table>
///Returns:
///    Type: <b>int</b> Returns the size in pixels.
///    
@DllImport("UxTheme")
int GetThemeSysSize(ptrdiff_t hTheme, int iSizeId);

///Retrieves the LOGFONT of a system font.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to theme data.
///    iFontId = Type: <b>int</b> Value of type <b>int</b> that specifies a system font. May be one of the following values.
///              <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TMT_CAPTIONFONT"></a><a
///              id="tmt_captionfont"></a><dl> <dt><b>TMT_CAPTIONFONT</b></dt> </dl> </td> <td width="60%"> The font used by
///              window captions. </td> </tr> <tr> <td width="40%"><a id="TMT_SMALLCAPTIONFONT"></a><a
///              id="tmt_smallcaptionfont"></a><dl> <dt><b>TMT_SMALLCAPTIONFONT</b></dt> </dl> </td> <td width="60%"> The font
///              used by window small captions. </td> </tr> <tr> <td width="40%"><a id="TMT_MENUFONT"></a><a
///              id="tmt_menufont"></a><dl> <dt><b>TMT_MENUFONT</b></dt> </dl> </td> <td width="60%"> The font used by menus.
///              </td> </tr> <tr> <td width="40%"><a id="TMT_STATUSFONT"></a><a id="tmt_statusfont"></a><dl>
///              <dt><b>TMT_STATUSFONT</b></dt> </dl> </td> <td width="60%"> The font used in status messages. </td> </tr> <tr>
///              <td width="40%"><a id="TMT_MSGBOXFONT"></a><a id="tmt_msgboxfont"></a><dl> <dt><b>TMT_MSGBOXFONT</b></dt> </dl>
///              </td> <td width="60%"> The font used to display messages in a message box. </td> </tr> <tr> <td width="40%"><a
///              id="TMT_ICONTITLEFONT"></a><a id="tmt_icontitlefont"></a><dl> <dt><b>TMT_ICONTITLEFONT</b></dt> </dl> </td> <td
///              width="60%"> The font used for icons. </td> </tr> </table>
///    plf = Type: <b>LOGFONTW*</b> Pointer to a LOGFONT structure that receives the font information from this function.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT GetThemeSysFont(ptrdiff_t hTheme, int iFontId, LOGFONTW* plf);

///Retrieves the value of a system string.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to theme data.
///    iStringId = Type: <b>int</b> Value of type <b>int</b> that specifies a system string. May be one of the following values.
///                <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TMT_CSSNAME"></a><a
///                id="tmt_cssname"></a><dl> <dt><b>TMT_CSSNAME</b></dt> </dl> </td> <td width="60%"> The name of the CSS file
///                associated with the theme specified by <i>hTheme</i>. </td> </tr> <tr> <td width="40%"><a id="TMT_XMLNAME"></a><a
///                id="tmt_xmlname"></a><dl> <dt><b>TMT_XMLNAME</b></dt> </dl> </td> <td width="60%"> The name of the XML file
///                associated with the theme specified by <i>hTheme</i>. </td> </tr> </table>
///    pszStringBuff = Type: <b>LPWSTR</b> Pointer to the buffer that receives the string value from this function.
///    cchMaxStringChars = Type: <b>int</b> Value of type <b>int</b> that specifies the maximum number of characters the string buffer can
///                        hold.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT GetThemeSysString(ptrdiff_t hTheme, int iStringId, PWSTR pszStringBuff, int cchMaxStringChars);

///Retrieves the value of a system <b>int</b>.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to theme data.
///    iIntId = Type: <b>int</b> Value of type <b>int</b> that specifies the desired system <b>int</b>. May be the following
///             value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TMT_MINCOLORDEPTH"></a><a
///             id="tmt_mincolordepth"></a><dl> <dt><b>TMT_MINCOLORDEPTH</b></dt> </dl> </td> <td width="60%"> The minimum color
///             depth, in bits, required to properly view this style. </td> </tr> </table>
///    piValue = Type: <b>int*</b> Pointer to an <b>int</b> that receives the system integer value.
@DllImport("UxTheme")
HRESULT GetThemeSysInt(ptrdiff_t hTheme, int iIntId, int* piValue);

///Tests if a visual style for the current application is active.
///Returns:
///    Type: <b>BOOL</b> Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> A visual style is enabled, and
///    windows with visual styles applied should call OpenThemeData to start using theme drawing services. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>FALSE</b></dt> </dl> </td> <td width="60%"> A visual style is not enabled, and
///    the window message handler does not need to make another call to IsThemeActive until it receives a
///    WM_THEMECHANGED message. </td> </tr> </table>
///    
@DllImport("UXTHEME")
BOOL IsThemeActive();

///Reports whether the current application's user interface displays using visual styles.
///Returns:
///    Type: <b>BOOL</b> Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> The application has a visual
///    style applied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>FALSE</b></dt> </dl> </td> <td width="60%"> The
///    application does not have a visual style applied. </td> </tr> </table>
///    
@DllImport("UXTHEME")
BOOL IsAppThemed();

///Retrieves a theme handle to a window that has visual styles applied.
///Params:
///    hwnd = Type: <b>HWND</b> Handle of the window.
///Returns:
///    Type: <b>HTHEME</b> The most recent theme handle from OpenThemeData.
///    
@DllImport("UXTHEME")
ptrdiff_t GetWindowTheme(HWND hwnd);

///Enables or disables the visual style of the background of a dialog window.
///Params:
///    hwnd = Type: <b>HWND</b> Window handle of the target dialog box.
///    dwFlags = Type: <b>DWORD</b> One of the following option flag values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///              <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>ETDT_DISABLE</dt> </dl> </td> <td width="60%">
///              Disables background texturing. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
///              <dt>ETDT_ENABLE</dt> </dl> </td> <td width="60%"> Enables dialog window background texturing. The texturing is
///              defined by a visual style. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
///              <dt>ETDT_USETABTEXTURE</dt> </dl> </td> <td width="60%"> Uses the Tab control texture for the background texture
///              of a dialog window. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
///              <dt>ETDT_USEAEROWIZARDTABTEXTURE</dt> </dl> </td> <td width="60%"> Uses the Aero wizard texture for the
///              background texture of a dialog window. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
///              <dt>ETDT_ENABLETAB</dt> </dl> </td> <td width="60%"> Enables dialog window background texturing. The texture is
///              the Tab control texture defined by the visual style. This flag is equivalent to (ETDT_ENABLE |
///              ETDT_USETABTEXTURE). </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
///              <dt>ETDT_ENABLEAEROWIZARDTAB</dt> </dl> </td> <td width="60%"> ETDT_ENABLE | ETDT_USEAEROWIZARDTABTEXTURE. </td>
///              </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>ETDT_VALIDBITS</dt> </dl> </td> <td
///              width="60%"> ETDT_DISABLE | ETDT_ENABLE | ETDT_USETABTEXTURE | ETDT_USEAEROWIZARDTABTEXTURE. </td> </tr> </table>
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT EnableThemeDialogTexture(HWND hwnd, uint dwFlags);

///Reports whether a specified dialog window supports background texturing.
///Params:
///    hwnd = Type: <b>HWND</b> <b>HWND</b> value that specifies a dialog window.
@DllImport("UxTheme")
BOOL IsThemeDialogTextureEnabled(HWND hwnd);

///Retrieves the property flags that control how visual styles are applied in the current application.
///Returns:
///    Type: <b>DWORD</b> The following return values are bit flags combined with a logical OR operator. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>STAP_ALLOW_NONCLIENT</b></dt>
///    </dl> </td> <td width="60%"> Specifies that the nonclient areas of application windows have visual styles
///    applied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>STAP_ALLOW_CONTROLS</b></dt> </dl> </td> <td width="60%">
///    Specifies that controls in application windows have visual styles applied. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>STAP_ALLOW_WEBCONTENT</b></dt> </dl> </td> <td width="60%"> Specifies that all web content displayed in an
///    application is rendered using visual styles. </td> </tr> </table>
///    
@DllImport("UXTHEME")
uint GetThemeAppProperties();

///Sets the flags that determine how visual styles are implemented in the calling application.
///Params:
///    dwFlags = Type: <b>DWORD</b> <b>DWORD</b> that specifies one or more of the following bit flags, which can be combined with
///              a logical OR. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl>
///              <dt><b></b></dt> <dt>STAP_ALLOW_NONCLIENT</dt> </dl> </td> <td width="60%"> Specifies that the nonclient areas of
///              application windows will have visual styles applied. </td> </tr> <tr> <td width="40%"><a id=""></a><dl>
///              <dt><b></b></dt> <dt>STAP_ALLOW_CONTROLS</dt> </dl> </td> <td width="60%"> Specifies that the common controls
///              used in an application will have visual styles applied. </td> </tr> <tr> <td width="40%"><a id=""></a><dl>
///              <dt><b></b></dt> <dt>STAP_ALLOW_WEBCONTENT</dt> </dl> </td> <td width="60%"> Specifies that web content displayed
///              in an application will have visual styles applied. </td> </tr> </table>
@DllImport("UxTheme")
void SetThemeAppProperties(uint dwFlags);

///Retrieves the name of the current visual style, and optionally retrieves the color scheme name and size name.
///Params:
///    pszThemeFileName = Type: <b>LPWSTR</b> Pointer to a string that receives the theme path and file name.
///    cchMaxNameChars = Type: <b>int</b> Value of type <b>int</b> that contains the maximum number of characters allowed in the theme
///                      file name.
///    pszColorBuff = Type: <b>LPWSTR</b> Pointer to a string that receives the color scheme name. This parameter may be set to
///                   <b>NULL</b>.
///    cchMaxColorChars = Type: <b>int</b> Value of type <b>int</b> that contains the maximum number of characters allowed in the color
///                       scheme name.
///    pszSizeBuff = Type: <b>LPWSTR</b> Pointer to a string that receives the size name. This parameter may be set to <b>NULL</b>.
///    cchMaxSizeChars = Type: <b>int</b> Value of type <b>int</b> that contains the maximum number of characters allowed in the size
///                      name.
@DllImport("UXTHEME")
HRESULT GetCurrentThemeName(PWSTR pszThemeFileName, int cchMaxNameChars, PWSTR pszColorBuff, int cchMaxColorChars, 
                            PWSTR pszSizeBuff, int cchMaxSizeChars);

///Retrieves the value for a theme property from the documentation section of the specified theme file.
///Params:
///    pszThemeName = Type: <b>LPCWSTR</b> Pointer to a string that contains the name of the theme file that will be opened to query
///                   for the property.
///    pszPropertyName = Type: <b>LPCWSTR</b> Pointer to a string that contains the name of the theme property to query. Can be one of the
///                      following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                      id="SZ_THDOCPROP_DISPLAYNAME"></a><a id="sz_thdocprop_displayname"></a><dl>
///                      <dt><b>SZ_THDOCPROP_DISPLAYNAME</b></dt> </dl> </td> <td width="60%"> Retrieves the display name of the theme.
///                      </td> </tr> <tr> <td width="40%"><a id="SZ_THDOCPROP_TOOLTIP"></a><a id="sz_thdocprop_tooltip"></a><dl>
///                      <dt><b>SZ_THDOCPROP_TOOLTIP</b></dt> </dl> </td> <td width="60%"> Retrieves the tooltip associated with this
///                      theme. </td> </tr> <tr> <td width="40%"><a id="SZ_THDOCPROP_AUTHOR"></a><a id="sz_thdocprop_author"></a><dl>
///                      <dt><b>SZ_THDOCPROP_AUTHOR</b></dt> </dl> </td> <td width="60%"> Retrieves the name of the author of the theme.
///                      </td> </tr> <tr> <td width="40%"><a id="SZ_THDOCPROP_CANONICALNAME"></a><a
///                      id="sz_thdocprop_canonicalname"></a><dl> <dt><b>SZ_THDOCPROP_CANONICALNAME</b></dt> </dl> </td> <td width="60%">
///                      Retrieves the name of the theme. </td> </tr> </table>
///    pszValueBuff = Type: <b>LPWSTR</b> Pointer to a string buffer that receives the property string value.
///    cchMaxValChars = Type: <b>int</b> Value of type <b>int</b> that specifies the maximum number of characters that
///                     <i>pszValueBuff</i> can contain.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT GetThemeDocumentationProperty(const(PWSTR) pszThemeName, const(PWSTR) pszPropertyName, PWSTR pszValueBuff, 
                                      int cchMaxValChars);

///Draws the part of a parent control that is covered by a partially-transparent or alpha-blended child control.
///Params:
///    hwnd = Type: <b>HWND</b> The child control.
///    hdc = Type: <b>HDC</b> The child control's DC.
///    prc = Type: <b>const RECT*</b> The area to be drawn. The rectangle is in the child window's coordinates. If this
///          parameter is NULL, the area to be drawn includes the entire area occupied by the child control.
@DllImport("UXTHEME")
HRESULT DrawThemeParentBackground(HWND hwnd, HDC hdc, const(RECT)* prc);

///<b>Windows Vista through Windows 7</b>: Enables or disables visual styles for the current user in the current and
///later sessions. <b>Windows 8 and later</b>: This function does nothing. Visual styles are always enabled in Windows 8
///and later.
///Params:
///    fEnable = Type: <b>BOOL</b> Receives one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///              <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>TRUE</dt> </dl> </td> <td width="60%"> Enables visual
///              styles. If the user previously had an active visual style, it becomes active again. <div
///              class="alert"><b>Note</b> Only clients with trusted computing base (TCB) privileges, where the client acts as
///              part of the operating system, can load or change a global theme.</div> <div> </div> </td> </tr> <tr> <td
///              width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>FALSE</dt> </dl> </td> <td width="60%"> Disables visual styles
///              and turns visual styles off. </td> </tr> </table>
@DllImport("UxTheme")
HRESULT EnableTheming(BOOL fEnable);

///Used by partially-transparent or alpha-blended child controls to draw the part of their parent in front of which they
///appear. Sends a WM_ERASEBKGND message followed by a WM_PRINTCLIENT.
///Params:
///    hwnd = Type: <b>HWND</b> Handle of the child control.
///    hdc = Type: <b>HDC</b> HDC of the child control.
///    dwFlags = Type: <b>DWORD</b> Zero or more of the following values. If this value is zero, this function returns S_OK only
///              if the parent handled WM_PRINTCLIENT. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="DTPB_WINDOWDC"></a><a id="dtpb_windowdc"></a><dl> <dt><b>DTPB_WINDOWDC</b></dt> </dl> </td> <td width="60%">
///              If set, <i>hdc</i> is assumed to be a window DC, not a client DC. </td> </tr> <tr> <td width="40%"><a
///              id="DTPB_USECTLCOLORSTATIC"></a><a id="dtpb_usectlcolorstatic"></a><dl> <dt><b>DTPB_USECTLCOLORSTATIC</b></dt>
///              </dl> </td> <td width="60%"> If set, this function sends a WM_CTLCOLORSTATIC message to the parent and uses the
///              brush if one is provided. Otherwise, it uses COLOR_BTNFACE. </td> </tr> <tr> <td width="40%"><a
///              id="DTPB_USEERASEBKGND"></a><a id="dtpb_useerasebkgnd"></a><dl> <dt><b>DTPB_USEERASEBKGND</b></dt> </dl> </td>
///              <td width="60%"> If set, this function returns S_OK without sending a WM_CTLCOLORSTATIC message if the parent
///              actually painted on WM_ERASEBKGND. </td> </tr> </table>
///    prc = Type: <b>const RECT*</b> Optional. The area to be drawn, in child coordinates. If this parameter is NULL, the
///          area to be drawn includes the entire area occupied by the child control.
@DllImport("UxTheme")
HRESULT DrawThemeParentBackgroundEx(HWND hwnd, HDC hdc, uint dwFlags, const(RECT)* prc);

///Sets attributes to control how visual styles are applied to a specified window.
///Params:
///    hwnd = Type: <b>HWND</b> Handle to a window to apply changes to.
///    arg2 = Type: <b>enum WINDOWTHEMEATTRIBUTETYPE</b> Value of type WINDOWTHEMEATTRIBUTETYPE that specifies the type of
///           attribute to set. The value of this parameter determines the type of data that should be passed in the
///           <i>pvAttribute</i> parameter. Can be the following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///           <td width="40%"><a id="WTA_NONCLIENT"></a><a id="wta_nonclient"></a><dl> <dt><b>WTA_NONCLIENT</b></dt> </dl>
///           </td> <td width="60%"> Specifies non-client related attributes. <i>pvAttribute</i> must be a pointer of type
///           WTA_OPTIONS. </td> </tr> </table>
///    pvAttribute = Type: <b>PVOID</b> A pointer that specifies attributes to set. Type is determined by the value of the
///                  <i>eAttribute</i> value.
///    cbAttribute = Type: <b>DWORD</b> Specifies the size, in bytes, of the data pointed to by <i>pvAttribute</i>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT SetWindowThemeAttribute(HWND hwnd, WINDOWTHEMEATTRIBUTETYPE eAttribute, void* pvAttribute, 
                                uint cbAttribute);

///Draws text using the color and font defined by the visual style. Extends DrawThemeText by allowing additional text
///format options.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to a window's specified theme data. Use OpenThemeData to create an HTHEME.
///    hdc = Type: <b>HDC</b> HDC to use for drawing.
///    iPartId = Type: <b>int</b> The control part that has the desired text appearance. See Parts and States. If this value is 0,
///              the text is drawn in the default font, or a font selected into the device context.
///    iStateId = Type: <b>int</b> The control state that has the desired text appearance. See Parts and States.
///    pszText = Type: <b>LPCWSTR</b> Pointer to a string that contains the text to draw.
///    cchText = Type: <b>int</b> Value of type <b>int</b> that contains the number of characters to draw. If the parameter is set
///              to -1, all the characters in the string are drawn.
///    dwTextFlags = Type: <b>DWORD</b> <b>DWORD</b> that contains one or more values that specify the string's formatting. See Format
///                  Values for possible parameter values.
///    pRect = Type: <b>LPRECT</b> Pointer to a RECT structure that contains the rectangle, in logical coordinates, in which the
///            text is to be drawn.
///    pOptions = Type: <b>const DTTOPTS*</b> A DTTOPTS structure that defines additional formatting options that will be applied
///               to the text being drawn.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT DrawThemeTextEx(ptrdiff_t hTheme, HDC hdc, int iPartId, int iStateId, const(PWSTR) pszText, int cchText, 
                        uint dwTextFlags, RECT* pRect, const(DTTOPTS)* pOptions);

///Retrieves the bitmap associated with a particular theme, part, state, and property.
///Params:
///    hTheme = Type: <b>HTHEME</b> A handle to theme data.
///    iPartId = Type: <b>int</b> The part that contains the bitmap. See Parts and States.
///    iStateId = Type: <b>int</b> The state of the part.
///    iPropId = Type: <b>int</b> The property to retrieve. Pass zero to automatically select the first available bitmap for this
///              part and state, or use one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///              width="40%"><a id="TMT_DIBDATA"></a><a id="tmt_dibdata"></a><dl> <dt><b>TMT_DIBDATA</b></dt> </dl> </td> <td
///              width="60%"> The background image. </td> </tr> <tr> <td width="40%"><a id="TMT_GLYPHDIBDATA"></a><a
///              id="tmt_glyphdibdata"></a><dl> <dt><b>TMT_GLYPHDIBDATA</b></dt> </dl> </td> <td width="60%"> The glyph image
///              drawn on top of the background, if present. </td> </tr> <tr> <td width="40%"><a id="TMT_HBITMAP"></a><a
///              id="tmt_hbitmap"></a><dl> <dt><b>TMT_HBITMAP</b></dt> </dl> </td> <td width="60%"> Not currently supported. </td>
///              </tr> </table>
///    dwFlags = Type: <b>ULONG</b> The flags that specify how the bitmap is to be retrieved. Can be one of the following values.
///              <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="GBF_DIRECT"></a><a
///              id="gbf_direct"></a><dl> <dt><b>GBF_DIRECT</b></dt> </dl> </td> <td width="60%"> Retrieves a handle to the
///              existing bitmap. </td> </tr> <tr> <td width="40%"><a id="GBF_COPY"></a><a id="gbf_copy"></a><dl>
///              <dt><b>GBF_COPY</b></dt> </dl> </td> <td width="60%"> Retrieves a copy of the bitmap. </td> </tr> <tr> <td
///              width="40%"><a id="GBF_VALIDBITS"></a><a id="gbf_validbits"></a><dl> <dt><b>GBF_VALIDBITS</b></dt> </dl> </td>
///              <td width="60%"> <b>GBF_DIRECT</b> | <b>GBF_COPY</b> </td> </tr> </table>
///    phBitmap = Type: <b>HBITMAP*</b> A pointer that receives a handle to the requested bitmap.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT GetThemeBitmap(ptrdiff_t hTheme, int iPartId, int iStateId, int iPropId, uint dwFlags, HBITMAP* phBitmap);

///Retrieves a data stream corresponding to a specified theme, starting from a specified part, state, and property.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle to the theme from which the stream will be retrieved.
///    iPartId = Type: <b>int</b> Specifies the part to retrieve a stream from. See Parts and States.
///    iStateId = Type: <b>int</b> Specifies the state of the part.
///    iPropId = Type: <b>int</b> Specifies the property to retrieve.
///    ppvStream = Type: <b>VOID**</b> Address of a pointer that receives the stream.
///    pcbStream = Type: <b>DWORD*</b> Pointer that receives the length, in bytes, of the stream received by <i>ppvStream</i>.
///    hInst = Type: <b>HINSTANCE</b> If <i>iPropId</i> is TMT_STREAM, this value is <b>NULL</b>. If <i>iPropId</i> is
///            TMT_DISKSTREAM, this value is the HINSTANCE of a loaded styles file.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT GetThemeStream(ptrdiff_t hTheme, int iPartId, int iStateId, int iPropId, void** ppvStream, uint* pcbStream, 
                       HINSTANCE hInst);

///Initialize buffered painting for the current thread.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT BufferedPaintInit();

///Closes down buffered painting for the current thread. Called once for each call to BufferedPaintInit after calls to
///BeginBufferedPaint are no longer needed.
@DllImport("UXTHEME")
HRESULT BufferedPaintUnInit();

///Begins a buffered paint operation.
///Params:
///    hdcTarget = Type: <b>HDC</b> The handle of the target DC on which the buffer will be painted.
///    prcTarget = Type: <b>const RECT*</b> A pointer to a RECT structure that specifies the area of the target DC in which to
///                paint.
///    dwFormat = Type: <b>BP_BUFFERFORMAT</b> A member of the BP_BUFFERFORMAT enumeration that specifies the format of the buffer.
///    pPaintParams = Type: <b>BP_PAINTPARAMS*</b> A pointer to a BP_PAINTPARAMS structure that defines the paint operation parameters.
///                   This value can be <b>NULL</b>.
///    phdc = Type: <b>HDC*</b> When this function returns, points to the handle of the new device context.
@DllImport("UXTHEME")
ptrdiff_t BeginBufferedPaint(HDC hdcTarget, const(RECT)* prcTarget, BP_BUFFERFORMAT dwFormat, 
                             BP_PAINTPARAMS* pPaintParams, HDC* phdc);

///Completes a buffered paint operation and frees the associated buffered paint handle.
///Params:
///    hBufferedPaint = Type: <b>HPAINTBUFFER</b> The handle of the buffered paint context, obtained through BeginBufferedPaint.
///    fUpdateTarget = Type: <b>BOOL</b> <b>TRUE</b> to copy the buffer to the target DC.
@DllImport("UXTHEME")
HRESULT EndBufferedPaint(ptrdiff_t hBufferedPaint, BOOL fUpdateTarget);

///Retrieves the target rectangle specified by BeginBufferedPaint.
///Params:
///    hBufferedPaint = Type: <b>HPAINTBUFFER</b> Handle to the buffered paint context obtained through BeginBufferedPaint.
///    prc = Type: <b>RECT*</b> When this function returns, contains the requested rectangle.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT GetBufferedPaintTargetRect(ptrdiff_t hBufferedPaint, RECT* prc);

///Retrieves the target device context (DC).
///Params:
///    hBufferedPaint = Type: <b>HPAINTBUFFER</b> A handle to the buffered paint context obtained through BeginBufferedPaint.
///Returns:
///    Type: <b>HDC</b> A handle to the requested DC, or <b>NULL</b> otherwise.
///    
@DllImport("UxTheme")
HDC GetBufferedPaintTargetDC(ptrdiff_t hBufferedPaint);

///Gets the paint device context (DC). This is the same value retrieved by BeginBufferedPaint.
///Params:
///    hBufferedPaint = Type: <b>HPAINTBUFFER</b> Handle of the buffered paint context, obtained through BeginBufferedPaint.
@DllImport("UxTheme")
HDC GetBufferedPaintDC(ptrdiff_t hBufferedPaint);

///Retrieves a pointer to the buffer bitmap if the buffer is a device-independent bitmap (DIB).
///Params:
///    hBufferedPaint = Type: <b>HPAINTBUFFER</b> The handle of the buffered paint context, obtained through BeginBufferedPaint.
///    ppbBuffer = Type: <b>RGBQUAD**</b> When this function returns, contains a pointer to the address of the buffer bitmap pixels.
///    pcxRow = Type: <b>int*</b> When this function returns, contains a pointer to the width, in pixels, of the buffer bitmap.
///             This value is not necessarily equal to the buffer width. It may be larger.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. If an error occurs,
///    <i>ppbBuffer</i> is set to <b>NULL</b> and <i>pcxRow</i> is set to zero.
///    
@DllImport("UXTHEME")
HRESULT GetBufferedPaintBits(ptrdiff_t hBufferedPaint, RGBQUAD** ppbBuffer, int* pcxRow);

///Clears a specified rectangle in the buffer to ARGB = {0,0,0,0}.
///Params:
///    hBufferedPaint = Type: <b>HPAINTBUFFER</b> The handle of the buffered paint context, obtained through BeginBufferedPaint.
///    prc = Type: <b>const RECT*</b> A pointer to a RECT structure that specifies the rectangle to clear. Set this parameter
///          to <b>NULL</b> to specify the entire buffer.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UXTHEME")
HRESULT BufferedPaintClear(ptrdiff_t hBufferedPaint, const(RECT)* prc);

///Sets the alpha to a specified value in a given rectangle. The alpha controls the amount of transparency applied when
///blending with the buffer onto the destination target device context (DC).
///Params:
///    hBufferedPaint = Type: <b>HPAINTBUFFER</b> The handle of the buffered paint context, obtained through BeginBufferedPaint.
///    prc = Type: <b>const RECT*</b> A pointer to a RECT structure that specifies the rectangle in which to set the alpha.
///          Set this parameter to <b>NULL</b> to specify the entire buffer.
///    alpha = Type: <b>BYTE</b> The alpha value to set. The alpha value can range from zero (fully transparent) to 255 (fully
///            opaque).
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("UxTheme")
HRESULT BufferedPaintSetAlpha(ptrdiff_t hBufferedPaint, const(RECT)* prc, ubyte alpha);

///Stops all buffered animations for the given window.
///Params:
///    hwnd = Type: <b>HWND</b> The handle of the window in which to stop all animations.
@DllImport("UXTHEME")
HRESULT BufferedPaintStopAllAnimations(HWND hwnd);

///Begins a buffered animation operation. The animation consists of a cross-fade between the contents of two buffers
///over a specified period of time.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to the window in which the animations play.
///    hdcTarget = Type: <b>HDC</b> A handle of the target DC on which the buffer is animated.
///    prcTarget = Type: <b>const RECT*</b> A pointer to a structure that specifies the area of the target DC in which to draw.
///    dwFormat = Type: <b>BP_BUFFERFORMAT</b> The format of the buffer.
///    pPaintParams = Type: <b>BP_PAINTPARAMS*</b> A pointer to a structure that defines the paint operation parameters. This value can
///                   be <b>NULL</b>.
///    pAnimationParams = Type: <b>BP_ANIMATIONPARAMS*</b> A pointer to a structure that defines the animation operation parameters.
///    phdcFrom = Type: <b>HDC*</b> When this function returns, this value points to the handle of the DC where the application
///               should paint the initial state of the animation, if not <b>NULL</b>.
///    phdcTo = Type: <b>HDC*</b> When this function returns, this value points to the handle of the DC where the application
///             should paint the final state of the animation, if not <b>NULL</b>.
///Returns:
///    Type: <b>HANIMATIONBUFFER</b> A handle to the buffered paint animation.
///    
@DllImport("UxTheme")
ptrdiff_t BeginBufferedAnimation(HWND hwnd, HDC hdcTarget, const(RECT)* prcTarget, BP_BUFFERFORMAT dwFormat, 
                                 BP_PAINTPARAMS* pPaintParams, BP_ANIMATIONPARAMS* pAnimationParams, HDC* phdcFrom, 
                                 HDC* phdcTo);

///Renders the first frame of a buffered animation operation and starts the animation timer.
///Params:
///    hbpAnimation = Type: <b>HANIMATIONBUFFER</b> The handle to the buffered animation context that was returned by
///                   BeginBufferedAnimation.
///    fUpdateTarget = Type: <b>BOOL</b> If <b>TRUE</b>, updates the target DC with the animation. If <b>FALSE</b>, the animation is not
///                    started, the target DC is not updated, and the <i>hbpAnimation</i> parameter is freed.
@DllImport("UxTheme")
HRESULT EndBufferedAnimation(ptrdiff_t hbpAnimation, BOOL fUpdateTarget);

///Paints the next frame of a buffered paint animation.
///Params:
///    hwnd = Type: <b>HWND</b> Handle to the window in which the animations play.
///    hdcTarget = Type: <b>HDC</b> Handle of the target DC on which the buffer is animated.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the frame has been painted, or <b>FALSE</b> otherwise.
///    
@DllImport("UxTheme")
BOOL BufferedPaintRenderAnimation(HWND hwnd, HDC hdcTarget);

///Determines whether Desktop Window Manager (DWM) composition effects are available to the theme.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if composition effects are available; otherwise, <b>FALSE</b>.
///    
@DllImport("UXTHEME")
BOOL IsCompositionActive();

///Gets the duration for the specified transition.
///Params:
///    hTheme = Type: <b>HTHEME</b> Handle of the theme data.
///    iPartId = Type: <b>int</b> ID of the part.
///    iStateIdFrom = Type: <b>int</b> State ID of the part before the transition.
///    iStateIdTo = Type: <b>int</b> State ID of the part after the transition.
///    iPropId = Type: <b>int</b> Property ID.
///    pdwDuration = Type: <b>DWORD*</b> Address of a variable that receives the transition duration, in milliseconds.
@DllImport("UxTheme")
HRESULT GetThemeTransitionDuration(ptrdiff_t hTheme, int iPartId, int iStateIdFrom, int iStateIdTo, int iPropId, 
                                   uint* pdwDuration);


// Interfaces

@GUID("7C476BA2-02B1-48F4-8048-B24619DDC058")
struct ImageList;

///The <b>IImageList</b> interface enables the user to insert images to be used as icons for items in the result or
///scope pane of the console. When an image is inserted, an index is passed in and associated with the image. Any time
///the image is to be used, the user can refer to it by the index that he or she assigned. Be aware that because the
///image list is shared among many components, the user-specified index is a "virtual" index that gets mapped internally
///to the actual index.
@GUID("46EB5926-582E-4017-9FDF-E8998DAA0950")
interface IImageList : IUnknown
{
    ///Adds an image or images to an image list.
    ///Params:
    ///    hbmImage = Type: <b>HBITMAP</b> A handle to the bitmap that contains the image or images. The number of images is
    ///               inferred from the width of the bitmap.
    ///    hbmMask = Type: <b>HBITMAP</b> A handle to the bitmap that contains the mask. If no mask is used with the image list,
    ///              this parameter is ignored.
    ///    pi = Type: <b>int*</b> When this method returns, contains a pointer to the index of the first new image. If the
    ///         method fails to successfully add the new image, this value is -1.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Add(HBITMAP hbmImage, HBITMAP hbmMask, int* pi);
    ///Replaces an image with an icon or cursor.
    ///Params:
    ///    i = Type: <b>int</b> A value of type <b>int</b> that contains the index of the image to replace. If i is -1, the
    ///        function adds the image to the end of the list.
    ///    hicon = Type: <b>HICON</b> A handle to the icon or cursor that contains the bitmap and mask for the new image.
    ///    pi = Type: <b>int*</b> A pointer to an <b>int</b> that will contain the index of the image on return if
    ///         successful, or -1 otherwise.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ReplaceIcon(int i, HICON hicon, int* pi);
    ///Adds a specified image to the list of images used as overlay masks. An image list can have up to four overlay
    ///masks in Common Controls version 4.70 and earlier, and up to 15 in version 4.71 or later. The method assigns an
    ///overlay mask index to the specified image.
    ///Params:
    ///    iImage = Type: <b>int</b> A value of type <b>int</b> that contains the zero-based index of an image in the image list.
    ///             This index identifies the image to use as an overlay mask.
    ///    iOverlay = Type: <b>int</b> A value of type <b>int</b> that contains the one-based index of the overlay mask.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOverlayImage(int iImage, int iOverlay);
    ///Replaces an image in an image list with a new image.
    ///Params:
    ///    i = Type: <b>int</b> A value of type <b>int</b> that contains the index of the image to replace.
    ///    hbmImage = Type: <b>HBITMAP</b> A handle to the bitmap that contains the image.
    ///    hbmMask = Type: <b>HBITMAP</b> A handle to the bitmap that contains the mask. If no mask is used with the image list,
    ///              this parameter is ignored.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Replace(int i, HBITMAP hbmImage, HBITMAP hbmMask);
    ///Adds an image or images to an image list, generating a mask from the specified bitmap.
    ///Params:
    ///    hbmImage = Type: <b>HBITMAP</b> A handle to the bitmap that contains one or more images. The number of images is
    ///               inferred from the width of the bitmap.
    ///    crMask = Type: <b>COLORREF</b> The color used to generate the mask. Each pixel of this color in the specified bitmap
    ///             is changed to black, and the corresponding bit in the mask is set to 1.
    ///    pi = Type: <b>int*</b> A pointer to an <b>int</b> that contains the index of the first new image when it returns,
    ///         if successful, or -1 otherwise.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddMasked(HBITMAP hbmImage, uint crMask, int* pi);
    ///Draws an image list item in the specified device context.
    ///Params:
    ///    pimldp = Type: <b>IMAGELISTDRAWPARAMS*</b> A pointer to an IMAGELISTDRAWPARAMS structure that contains the drawing
    ///             parameters.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Draw(IMAGELISTDRAWPARAMS* pimldp);
    ///Removes an image from an image list.
    ///Params:
    ///    i = Type: <b>int</b> A value of type <b>int</b> that contains the index of the image to remove. If this parameter
    ///        is -1, the method removes all images.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Remove(int i);
    ///Creates an icon from an image and a mask in an image list.
    ///Params:
    ///    i = Type: <b>int</b> A value of type <b>int</b> that contains the index of the image.
    ///    flags = Type: <b>UINT</b> A combination of flags that specify the drawing style. For a list of values, see
    ///            IImageList::Draw.
    ///    picon = Type: <b>HICON*</b> A pointer to an <b>int</b> that contains the handle to the icon if successful, or
    ///            <b>NULL</b> if otherwise.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetIcon(int i, uint flags, HICON* picon);
    ///Gets information about an image.
    ///Params:
    ///    i = Type: <b>int</b> A value of type <b>int</b> that contains the index of the image.
    ///    pImageInfo = Type: <b>IMAGEINFO*</b> A pointer to an IMAGEINFO structure that receives information about the image. The
    ///                 information in this structure can directly manipulate the bitmaps of the image.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetImageInfo(int i, IMAGEINFO* pImageInfo);
    ///Copies images from a given image list.
    ///Params:
    ///    iDst = Type: <b>int</b> A value of type <b>int</b> that contains the zero-based index of the destination image for
    ///           the copy operation.
    ///    punkSrc = Type: <b>IUnknown*</b> A pointer to the IUnknown interface for the source image list.
    ///    iSrc = Type: <b>int</b> A value of type <b>int</b> that contains the zero-based index of the source image for the
    ///           copy operation.
    ///    uFlags = Type: <b>UINT</b> A value that specifies the type of copy operation to be made.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Copy(int iDst, IUnknown punkSrc, int iSrc, uint uFlags);
    ///Creates a new image by combining two existing images. This method also creates a new image list in which to store
    ///the image.
    ///Params:
    ///    i1 = Type: <b>int</b> A value of type <b>int</b> that contains the index of the first existing image.
    ///    punk2 = Type: <b>IUnknown*</b> A pointer to the IUnknown interface of the image list that contains the second image.
    ///    i2 = Type: <b>int</b> A value of type <b>int</b> that contains the index of the second existing image.
    ///    dx = Type: <b>int</b> A value of type <b>int</b> that contains the x-component of the offset of the second image
    ///         relative to the first image.
    ///    dy = Type: <b>int</b> A value of type <b>int</b> that contains the y-component of the offset of the second image
    ///         relative to the first image.
    ///    riid = Type: <b>REFIID</b> An IID of the interface for the new image list.
    ///    ppv = Type: <b>PVOID*</b> A raw pointer to the interface for the new image list.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Merge(int i1, IUnknown punk2, int i2, int dx, int dy, const(GUID)* riid, void** ppv);
    ///Clones an existing image list.
    ///Params:
    ///    riid = Type: <b>REFIID</b> An IID for the new image list.
    ///    ppv = Type: <b>PVOID*</b> The address of a pointer to the interface for the new image list.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Clone(const(GUID)* riid, void** ppv);
    ///Gets an image's bounding rectangle.
    ///Params:
    ///    i = Type: <b>int</b> A value of type <b>int</b> that contains the index of the image.
    ///    prc = Type: <b>RECT*</b> A pointer to a <b> RECT</b> that contains the bounding rectangle when the method returns.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetImageRect(int i, RECT* prc);
    ///Gets the dimensions of images in an image list. All images in an image list have the same dimensions.
    ///Params:
    ///    cx = Type: <b>int*</b> A pointer to an <b>int</b> that receives the width, in pixels, of each image.
    ///    cy = Type: <b>int*</b> A pointer to an <b>int</b> that receives the height, in pixels, of each image.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetIconSize(int* cx, int* cy);
    ///Sets the dimensions of images in an image list and removes all images from the list.
    ///Params:
    ///    cx = Type: <b>int</b> A value of type <b>int</b> that contains the width, in pixels, of the images in the image
    ///         list. All images in an image list have the same dimensions.
    ///    cy = Type: <b>int</b> A value of type <b>int</b> that contains the height, in pixels, of the images in the image
    ///         list. All images in an image list have the same dimensions.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetIconSize(int cx, int cy);
    ///Gets the number of images in an image list.
    ///Params:
    ///    pi = Type: <b>int*</b> A pointer to an <b>int</b> that contains the number of images when the method returns.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetImageCount(int* pi);
    ///Resizes an existing image list.
    ///Params:
    ///    uNewCount = Type: <b>UINT</b> A value that specifies the new size of the image list.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetImageCount(uint uNewCount);
    ///Sets the background color for an image list. This method only functions if you add an icon to the image list or
    ///use the IImageList::AddMasked method to add a black and white bitmap. Without a mask, the entire image draws, and
    ///the background color is not visible.
    ///Params:
    ///    clrBk = Type: <b>COLORREF</b> The background color to set. If this parameter is set to CLR_NONE, then images draw
    ///            transparently using the mask.
    ///    pclr = Type: <b>COLORREF*</b> A pointer to a <b>COLORREF</b> that contains the previous background color on return
    ///           if successful, or CLR_NONE otherwise.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetBkColor(uint clrBk, uint* pclr);
    ///Gets the current background color for an image list.
    ///Params:
    ///    pclr = Type: <b>COLORREF*</b> A pointer to a COLORREF that contains the background color when the method returns.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBkColor(uint* pclr);
    ///Begins dragging an image.
    ///Params:
    ///    iTrack = Type: <b>int</b> A value of type <b>int</b> that contains the index of the image to drag.
    ///    dxHotspot = Type: <b>int</b> A value of type <b>int</b> that contains the x-component of the drag position relative to
    ///                the upper-left corner of the image.
    ///    dyHotspot = Type: <b>int</b> A value of type <b>int</b> that contains the y-component of the drag position relative to
    ///                the upper-left corner of the image.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BeginDrag(int iTrack, int dxHotspot, int dyHotspot);
    ///Ends a drag operation.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EndDrag();
    ///Locks updates to the specified window during a drag operation and displays the drag image at the specified
    ///position within the window.
    ///Params:
    ///    hwndLock = Type: <b>HWND</b> A handle to the window that owns the drag image.
    ///    x = Type: <b>int</b> The x-coordinate at which to display the drag image. The coordinate is relative to the
    ///        upper-left corner of the window, not the client area.
    ///    y = Type: <b>int</b> The y-coordinate at which to display the drag image. The coordinate is relative to the
    ///        upper-left corner of the window, not the client area.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DragEnter(HWND hwndLock, int x, int y);
    ///Unlocks the specified window and hides the drag image, which enables the window to update.
    ///Params:
    ///    hwndLock = Type: <b>HWND</b> A handle to the window that contains the drag image.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DragLeave(HWND hwndLock);
    ///Moves the image that is being dragged during a drag-and-drop operation. This function is typically called in
    ///response to a WM_MOUSEMOVE message.
    ///Params:
    ///    x = Type: <b>int</b> A value of type <b>int</b> that contains the x-coordinate where the drag image appears. The
    ///        coordinate is relative to the upper-left corner of the window, not the client area.
    ///    y = Type: <b>int</b> A value of type <b>int</b> that contains the y-coordinate where the drag image appears. The
    ///        coordinate is relative to the upper-left corner of the window, not the client area.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DragMove(int x, int y);
    ///Creates a new drag image by combining the specified image, which is typically a mouse cursor image, with the
    ///current drag image.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to the IUnknown interface that accesses the image list interface, which
    ///           contains the new image to combine with the drag image.
    ///    iDrag = Type: <b>int</b> A value of type <b>int</b> that contains the index of the new image to combine with the drag
    ///            image.
    ///    dxHotspot = Type: <b>int</b> A value of type <b>int</b> that contains the x-component of the hot spot within the new
    ///                image.
    ///    dyHotspot = Type: <b>int</b> A value of type <b>int</b> that contains the x-component of the hot spot within the new
    ///                image.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDragCursorImage(IUnknown punk, int iDrag, int dxHotspot, int dyHotspot);
    ///Shows or hides the image being dragged.
    ///Params:
    ///    fShow = Type: <b>BOOL</b> A value that specifies whether to show or hide the image being dragged. Specify <b>TRUE</b>
    ///            to show the image or <b>FALSE</b> to hide the image.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DragShowNolock(BOOL fShow);
    ///Gets the temporary image list that is used for the drag image. The function also retrieves the current drag
    ///position and the offset of the drag image relative to the drag position.
    ///Params:
    ///    ppt = Type: <b>POINT*</b> A pointer to a POINT structure that receives the current drag position. Can be
    ///          <b>NULL</b>.
    ///    pptHotspot = Type: <b>POINT*</b> A pointer to a POINT structure that receives the offset of the drag image relative to the
    ///                 drag position. Can be <b>NULL</b>.
    ///    riid = Type: <b>REFIID</b> An IID for the image list.
    ///    ppv = Type: <b>PVOID*</b> The address of a pointer to the interface for the image list if successful, <b>NULL</b>
    ///          otherwise.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDragImage(POINT* ppt, POINT* pptHotspot, const(GUID)* riid, void** ppv);
    ///Gets the flags of an image.
    ///Params:
    ///    i = Type: <b>int</b> A value of type <b>int</b> that contains the index of the images whose flags need to be
    ///        retrieved.
    ///    dwFlags = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> that contains the flags when the method returns. One of the
    ///              following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///              id="ILIF_ALPHA"></a><a id="ilif_alpha"></a><dl> <dt><b>ILIF_ALPHA</b></dt> <dt>0x00000001</dt> </dl> </td>
    ///              <td width="60%"> Indicates that the item in the imagelist has an alpha channel. </td> </tr> <tr> <td
    ///              width="40%"><a id="ILIF_LOWQUALITY"></a><a id="ilif_lowquality"></a><dl> <dt><b>ILIF_LOWQUALITY</b></dt>
    ///              <dt>0x00000002</dt> </dl> </td> <td width="60%"> <b>Windows Vista and later.</b> Indicates that the item in
    ///              the imagelist was generated via a StretchBlt function, consequently image quality may have degraded. </td>
    ///              </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetItemFlags(int i, uint* dwFlags);
    ///Retrieves a specified image from the list of images used as overlay masks.
    ///Params:
    ///    iOverlay = Type: <b>int</b> A value of type <b>int</b> that contains the one-based index of the overlay mask.
    ///    piIndex = Type: <b>int*</b> A pointer to an <b>int</b> that receives the zero-based index of an image in the image
    ///              list. This index identifies the image that is used as an overlay mask.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOverlayImage(int iOverlay, int* piIndex);
}

///Extends IImageList by providing additional methods for manipulating and interacting with image lists.
@GUID("192B9D83-50FC-457B-90A0-2B82A8B5DAE1")
interface IImageList2 : IImageList
{
    ///Resizes the current image.
    ///Params:
    ///    cxNewIconSize = Type: <b>int</b> The x-axis count, in pixels, for the new size.
    ///    cyNewIconSize = Type: <b>int</b> The y-axis count, in pixels, for the new size.
    HRESULT Resize(int cxNewIconSize, int cyNewIconSize);
    ///Gets the original size of a specified image.
    ///Params:
    ///    iImage = Type: <b>int</b> The index of desired image.
    ///    dwFlags = Type: <b>DWORD</b> Flags for getting original size. One of the following is valid. <table> <tr>
    ///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ILGOS_ALWAYS"></a><a
    ///              id="ilgos_always"></a><dl> <dt><b>ILGOS_ALWAYS</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%">
    ///              Always get the original size (can be slow). </td> </tr> <tr> <td width="40%"><a id="ILGOS_FROMSTANDBY"></a><a
    ///              id="ilgos_fromstandby"></a><dl> <dt><b>ILGOS_FROMSTANDBY</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///              width="60%"> Only get if present or on standby. </td> </tr> </table>
    ///    pcx = Type: <b>int*</b> A pointer to the x-axis count.
    ///    pcy = Type: <b>int*</b> A pointer to the y-axis count.
    HRESULT GetOriginalSize(int iImage, uint dwFlags, int* pcx, int* pcy);
    ///Sets the original size of a specified image.
    ///Params:
    ///    iImage = Type: <b>int</b> An index of desired image.
    ///    cx = Type: <b>int</b> The x-axis count.
    ///    cy = Type: <b>int</b> The y-axis count.
    HRESULT SetOriginalSize(int iImage, int cx, int cy);
    ///Sets an image list callback.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to the callback interface.
    HRESULT SetCallback(IUnknown punk);
    ///Gets an image list callback object.
    ///Params:
    ///    riid = Type: <b>REFIID</b> Reference to a desired IID.
    ///    ppv = Type: <b>void**</b> Contains the address of a pointer to a callback object.
    HRESULT GetCallback(const(GUID)* riid, void** ppv);
    ///Forces an image present, as specified.
    ///Params:
    ///    iImage = Type: <b>int</b> An index of image to force present.
    ///    dwFlags = Type: <b>DWORD</b> Force image flags. One of the following is valid. <table> <tr> <th>Value</th>
    ///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ILFIP_ALWAYS"></a><a id="ilfip_always"></a><dl>
    ///              <dt><b>ILFIP_ALWAYS</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> Always get the image (can be
    ///              slow). </td> </tr> <tr> <td width="40%"><a id="ILFIP_FROMSTANDBY"></a><a id="ilfip_fromstandby"></a><dl>
    ///              <dt><b>ILFIP_FROMSTANDBY</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Only get if on standby.
    ///              </td> </tr> </table>
    HRESULT ForceImagePresent(int iImage, uint dwFlags);
    ///Discards images from list, as specified.
    ///Params:
    ///    iFirstImage = Type: <b>int</b> An index of first image to discard.
    ///    iLastImage = Type: <b>int</b> An index of last image to discard.
    ///    dwFlags = Type: <b>DWORD</b> Discard images flags. <b>ILDI_STANDBY</b> and <b>ILDI_PURGE</b> are mutually exclusive.
    ///              <b>ILDI_RESETACCESS</b> can be combined with either. One or more of the following are valid. <table> <tr>
    ///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ILDI_PURGE"></a><a id="ildi_purge"></a><dl>
    ///              <dt><b>ILDI_PURGE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Discard and purge. </td> </tr>
    ///              <tr> <td width="40%"><a id="ILDI_STANDBY"></a><a id="ildi_standby"></a><dl> <dt><b>ILDI_STANDBY</b></dt>
    ///              <dt>0x00000002</dt> </dl> </td> <td width="60%"> Discard to standby list. </td> </tr> <tr> <td width="40%"><a
    ///              id="ILDI_RESETACCESS"></a><a id="ildi_resetaccess"></a><dl> <dt><b>ILDI_RESETACCESS</b></dt>
    ///              <dt>0x00000004</dt> </dl> </td> <td width="60%"> Reset the "has been accessed" flag. </td> </tr> <tr> <td
    ///              width="40%"><a id="ILDI_QUERYACCESS"></a><a id="ildi_queryaccess"></a><dl> <dt><b>ILDI_QUERYACCESS</b></dt>
    ///              <dt>0x00000008</dt> </dl> </td> <td width="60%"> Ask whether access flag is set (but do not reset). </td>
    ///              </tr> </table>
    HRESULT DiscardImages(int iFirstImage, int iLastImage, uint dwFlags);
    ///Preloads images, as specified.
    ///Params:
    ///    pimldp = Type: <b>IMAGELISTDRAWPARAMS*</b> A pointer to an IMAGELISTDRAWPARAMS structure containing information about
    ///             an image list draw operation.
    HRESULT PreloadImages(IMAGELISTDRAWPARAMS* pimldp);
    ///Gets an image list statistics structure.
    ///Params:
    ///    pils = Type: <b>IMAGELISTSTATS*</b> A pointer to the IMAGELISTSTATS structure.
    HRESULT GetStatistics(IMAGELISTSTATS* pils);
    ///Initializes an image list.
    ///Params:
    ///    cx = Type: <b>int</b> Width, in pixels, of each image.
    ///    cy = Type: <b>int</b> Height, in pixels, of each image.
    ///    flags = Type: <b>UINT</b> A combination of Image List Creation Flags.
    ///    cInitial = Type: <b>int</b> Number of images that the image list initially contains.
    ///    cGrow = Type: <b>int</b> Number of new images that the image list can contain.
    HRESULT Initialize(int cx, int cy, uint flags, int cInitial, int cGrow);
    ///Replaces an image in an image list.
    ///Params:
    ///    i = Type: <b>int</b> The index of the image to replace.
    ///    hbmImage = Type: <b>HBITMAP</b> A handle to the bitmap that contains the image.
    ///    hbmMask = Type: <b>HBITMAP</b> A handle to the bitmap that contains the mask. If no mask is used with the image list,
    ///              this parameter is ignored.
    ///    punk = Type: <b>IUnknown*</b> A pointer to the IUnknown interface.
    ///    dwFlags = Type: <b>DWORD</b> Specifies how the mask is applied to the image as one or a bitwise combination of the
    ///              following decoration flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///              id="ILR_DEFAULT"></a><a id="ilr_default"></a><dl> <dt><b>ILR_DEFAULT</b></dt> <dt>0x0000</dt> </dl> </td> <td
    ///              width="60%"> Not used. </td> </tr> <tr> <td width="40%"><a id="ILR_HORIZONTAL_LEFT"></a><a
    ///              id="ilr_horizontal_left"></a><dl> <dt><b>ILR_HORIZONTAL_LEFT</b></dt> <dt>0x0000</dt> </dl> </td> <td
    ///              width="60%"> Horizontally align to left. </td> </tr> <tr> <td width="40%"><a
    ///              id="ILR_HORIZONTAL_CENTER"></a><a id="ilr_horizontal_center"></a><dl> <dt><b>ILR_HORIZONTAL_CENTER</b></dt>
    ///              <dt>0x0001</dt> </dl> </td> <td width="60%"> Horizontally center. </td> </tr> <tr> <td width="40%"><a
    ///              id="ILR_HORIZONTAL_RIGHT"></a><a id="ilr_horizontal_right"></a><dl> <dt><b>ILR_HORIZONTAL_RIGHT</b></dt>
    ///              <dt>0x0002</dt> </dl> </td> <td width="60%"> Horizontally align to right. </td> </tr> <tr> <td width="40%"><a
    ///              id="ILR_VERTICAL_TOP"></a><a id="ilr_vertical_top"></a><dl> <dt><b>ILR_VERTICAL_TOP</b></dt> <dt>0x0000</dt>
    ///              </dl> </td> <td width="60%"> Vertically align to top. </td> </tr> <tr> <td width="40%"><a
    ///              id="ILR_VERTICAL_CENTER"></a><a id="ilr_vertical_center"></a><dl> <dt><b>ILR_VERTICAL_CENTER</b></dt>
    ///              <dt>0x0010</dt> </dl> </td> <td width="60%"> Vertically align to center. </td> </tr> <tr> <td width="40%"><a
    ///              id="ILR_VERTICAL_BOTTOM"></a><a id="ilr_vertical_bottom"></a><dl> <dt><b>ILR_VERTICAL_BOTTOM</b></dt>
    ///              <dt>0x0020</dt> </dl> </td> <td width="60%"> Vertically align to bottom. </td> </tr> <tr> <td width="40%"><a
    ///              id="ILR_SCALE_CLIP"></a><a id="ilr_scale_clip"></a><dl> <dt><b>ILR_SCALE_CLIP</b></dt> <dt>0x0000</dt> </dl>
    ///              </td> <td width="60%"> Do nothing. </td> </tr> <tr> <td width="40%"><a id="ILR_SCALE_ASPECTRATIO"></a><a
    ///              id="ilr_scale_aspectratio"></a><dl> <dt><b>ILR_SCALE_ASPECTRATIO</b></dt> <dt>0x0100</dt> </dl> </td> <td
    ///              width="60%"> Scale. </td> </tr> </table>
    HRESULT Replace2(int i, HBITMAP hbmImage, HBITMAP hbmMask, IUnknown punk, uint dwFlags);
    ///Replaces an image in one image list with an image from another image list.
    ///Params:
    ///    i = Type: <b>int</b> The index of the destination image in the image list. This is the image that is overwritten
    ///        by the new image.
    ///    pil = Type: <b>IImageList*</b> A pointer to the source image list.
    ///    iSrc = Type: <b>int</b> The index of the source image in the image list pointed to by <i>pil</i>.
    ///    punk = Type: <b>IUnknown*</b> A pointer to the IUnknown interface.
    ///    dwFlags = Type: <b>DWORD</b> Not used; must be 0.
    HRESULT ReplaceFromImageList(int i, IImageList pil, int iSrc, IUnknown punk, uint dwFlags);
}

///The <b>ITextDocument</b> interface is the Text Object Model (TOM) top-level interface, which retrieves the active
///selection and range objects for any story in the document—whether active or not. It enables the application to:
///<ul> <li>Open and save documents.</li> <li>Control undo behavior and screen updating.</li> <li>Find a range from a
///screen position.</li> <li>Get an ITextStoryRanges story enumerator.</li> </ul><b>When to Implement</b> Applications
///typically do not implement the <b>ITextDocument</b> interface. Microsoft text solutions, such as rich edit controls,
///implement <b>ITextDocument</b> as part of their TOM implementation. <b>When to Use</b> Applications can retrieve an
///<b>ITextDocument</b> pointer from a rich edit control. To do this, send an EM_GETOLEINTERFACE message to retrieve an
///IRichEditOle object from a rich edit control. Then, call the object's IUnknown::QueryInterface method to retrieve an
///<b>ITextDocument</b> pointer.
@GUID("8CC497C0-A1DF-11CE-8098-00AA0047BE5D")
interface ITextDocument : IDispatch
{
    ///Gets the file name of this document. This is the ITextDocument default property.
    ///Params:
    ///    pName = Type: <b>BSTR*</b> The file name.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> No file name associated with this object. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory for output string. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetName(BSTR* pName);
    ///Gets the active selection.
    ///Params:
    ///    ppSel = Type: <b>ITextSelection**</b> The active selection.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> Indicates no active selection. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT GetSelection(ITextSelection* ppSel);
    ///Gets the count of stories in this document.
    ///Params:
    ///    pCount = Type: <b>LONG*</b> The number of stories in the document.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns the
    ///    following COM error code. For more information about COM error codes, see Error Handling in COM. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT GetStoryCount(int* pCount);
    ///Gets the story collection object used to enumerate the stories in a document.
    ///Params:
    ///    ppStories = Type: <b>ITextStoryRanges**</b> The ITextStoryRanges pointer.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns the
    ///    following COM error code. For more information about COM error codes, see Error Handling in COM. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Not implemented; only one story in this document. </td> </tr> </table>
    ///    
    HRESULT GetStoryRanges(ITextStoryRanges* ppStories);
    ///Gets a value that indicates whether changes have been made since the file was last saved.
    ///Params:
    ///    pValue = Type: <b>long*</b> The value <b>tomTrue</b> if no changes have been made since the file was last saved, or
    ///             the value <b>tomFalse</b> if there are unsaved changes.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns the
    ///    following COM error code. For more information about COM error codes, see Error Handling in COM. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT GetSaved(int* pValue);
    ///Sets the document <b>Saved</b> property.
    ///Params:
    ///    Value = Type: <b>long</b> New value of the <b>Saved</b> property. It can be one of the following values. <table> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomTrue"></a><a id="tomtrue"></a><a
    ///            id="TOMTRUE"></a><dl> <dt><b>tomTrue</b></dt> </dl> </td> <td width="60%"> No changes to the file since the
    ///            last time it was saved. </td> </tr> <tr> <td width="40%"><a id="tomFalse"></a><a id="tomfalse"></a><a
    ///            id="TOMFALSE"></a><dl> <dt><b>tomFalse</b></dt> </dl> </td> <td width="60%"> There are changes to the file.
    ///            </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> The return value is <b>S_OK</b>.
    ///    
    HRESULT SetSaved(int Value);
    ///Gets the default tab width.
    ///Params:
    ///    pValue = Type: <b>float*</b> The default tab width.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If <i>pValue</i> is <b>NULL</b>, the
    ///    method fails and it returns <b>E_INVALIDARG</b>. For more information about COM error codes, see Error
    ///    Handling in COM.
    ///    
    HRESULT GetDefaultTabStop(float* pValue);
    ///Sets the default tab stop, which is used when no tab exists beyond the current display position.
    ///Params:
    ///    Value = Type: <b>float</b> New default tab setting, in floating-point points. Default value is 36.0 points, that is,
    ///            0.5 inches.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information on COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetDefaultTabStop(float Value);
    ///Opens a new document.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the <b>ITextDocument::New</b> method succeeds, it returns <b>S_OK</b>.
    ///    
    HRESULT New();
    ///Opens a specified document. There are parameters to specify access and sharing privileges, creation and
    ///conversion of the file, as well as the code page for the file.
    ///Params:
    ///    pVar = Type: <b>VARIANT*</b> A <b>VARIANT</b> that specifies the name of the file to open.
    ///    Flags = Type: <b>long</b> The file creation, open, share, and conversion flags. Default value is zero, which gives
    ///            read/write access and read/write sharing, open always, and automatic recognition of the file format
    ///            (unrecognized file formats are treated as text). Other values are defined in the following groups. Any
    ///            combination of these values may be used. <a id="tomReadOnly"></a> <a id="tomreadonly"></a> <a
    ///            id="TOMREADONLY"></a>
    ///    CodePage = Type: <b>long</b> The code page to use for the file. Zero (the default value) means <b>CP_ACP</b> (ANSI code
    ///               page) unless the file begins with a Unicode BOM 0xfeff, in which case the file is considered to be Unicode.
    ///               Note that code page 1200 is Unicode, <b>CP_UTF8</b> is UTF-8.
    ///Returns:
    ///    Type: <b>HRESULT</b> The return value can be an <b>HRESULT</b> value that corresponds to a system error or
    ///    COM error code, including one of the following values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeds </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Feature not implemented. </td> </tr> </table>
    ///    
    HRESULT Open(VARIANT* pVar, int Flags, int CodePage);
    ///Saves the document.
    ///Params:
    ///    pVar = Type: <b>VARIANT*</b> The save target. This parameter is a <b>VARIANT</b>, which can be a file name, or
    ///           <b>NULL</b>.
    ///    Flags = Type: <b>long</b> File creation, open, share, and conversion flags. For a list of possible values, see
    ///            ITextDocument::Open.
    ///    CodePage = Type: <b>long</b> The specified code page. Common values are CP_ACP (zero: system ANSI code page), 1200
    ///               (Unicode), and 1208 (UTF-8).
    ///Returns:
    ///    Type: <b>HRESULT</b> The return value can be an <b>HRESULT</b> value that corresponds to a system error code
    ///    or a COM error code, including one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Method succeeds. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt>
    ///    </dl> </td> <td width="60%"> Feature not implemented. </td> </tr> </table>
    ///    
    HRESULT Save(VARIANT* pVar, int Flags, int CodePage);
    ///Increments the freeze count.
    ///Params:
    ///    pCount = Type: <b>long*</b> The updated freeze count.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the <b>ITextDocument::Freeze</b> count is nonzero, it returns <b>S_OK</b>. If the
    ///    <b>ITextDocument::Freeze</b> count is zero, it returns <b>FALSE</b>.
    ///    
    HRESULT Freeze(int* pCount);
    ///Decrements the freeze count.
    ///Params:
    ///    pCount = Type: <b>long*</b> The updated freeze count.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the freeze count is zero, the method returns <b>S_OK</b>. If the method fails, it
    ///    returns <b>S_FALSE</b>, indicating that the freeze count is nonzero. For more information about COM error
    ///    codes, see Error Handling in COM.
    ///    
    HRESULT Unfreeze(int* pCount);
    ///Turns on edit collection (also called <i>undo grouping</i>).
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> Undo is not enabled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt>
    ///    </dl> </td> <td width="60%"> This method is not implemented. </td> </tr> </table>
    ///    
    HRESULT BeginEditCollection();
    ///Turns off edit collection (also called <i>undo grouping</i>).
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns the
    ///    following COM error code. For more information about COM error codes, see Error Handling in COM. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> This method is not implemented. </td> </tr> </table>
    ///    
    HRESULT EndEditCollection();
    ///Performs a specified number of undo operations.
    ///Params:
    ///    Count = Type: <b>long</b> The specified number of undo operations. If the value of this parameter is <b>tomFalse</b>,
    ///            undo processing is suspended. If this parameter is <b>tomTrue</b>, undo processing is restored.
    ///    pCount = Type: <b>long*</b> The actual count of undo operations performed. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If all of the <i>Count</i> undo operations were performed, it returns <b>S_OK</b>. If
    ///    the method fails, it returns <b>S_FALSE</b>, indicating that less than <i>Count</i> undo operations were
    ///    performed. For more information on COM error codes, see Error Handling in COM.
    ///    
    HRESULT Undo(int Count, int* pCount);
    ///Performs a specified number of redo operations.
    ///Params:
    ///    Count = Type: <b>long</b> The number of redo operations specified.
    ///    pCount = Type: <b>long*</b> The actual count of redo operations performed. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds it returns <b>S_OK</b>. If the method fails, it returns the
    ///    following COM error code. For more information on COM error codes, see Error Handling in COM. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> Less than <i>Count</i> redo operations were performed. </td> </tr> </table>
    ///    
    HRESULT Redo(int Count, int* pCount);
    ///Retrieves a text range object for a specified range of content in the active story of the document.
    ///Params:
    ///    cpActive = Type: <b>long</b> The start position of new range. The default value is zero, which represents the start of
    ///               the document.
    ///    cpAnchor = Type: <b>long</b> The end position of new range. The default value is zero.
    ///    ppRange = Type: <b>ITextRange**</b> Address of a pointer to a variable of type ITextRange that receives a pointer to
    ///              the specified text range.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information on COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT Range(int cpActive, int cpAnchor, ITextRange* ppRange);
    ///Retrieves a range for the content at or nearest to the specified point on the screen.
    ///Params:
    ///    x = Type: <b>long</b> The horizontal coordinate of the specified point, in screen coordinates.
    ///    y = Type: <b>long</b> The vertical coordinate of the specified point, in screen coordinates.
    ///    ppRange = Type: <b>ITextRange**</b> The text range that corresponds to the specified point.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information on COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT RangeFromPoint(int x, int y, ITextRange* ppRange);
}

///The <b>ITextRange</b> objects are powerful editing and data-binding tools that allow a program to select text in a
///story and then examine or change that text.
@GUID("8CC497C2-A1DF-11CE-8098-00AA0047BE5D")
interface ITextRange : IDispatch
{
    ///Gets the plain text in this range. The Text property is the default property of the ITextRange interface.
    ///Params:
    ///    pbstr = Type: <b>BSTR*</b> The text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> <i>pbstr</i> is null. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory to hold the text. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetText(BSTR* pbstr);
    ///Sets the text in this range.
    ///Params:
    ///    bstr = Type: <b>BSTR</b> Text that replaces the current text in this range. If null, the current text is deleted.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Text is write-protected. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> bstr is null.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Out of
    ///    memory. </td> </tr> </table>
    ///    
    HRESULT SetText(BSTR bstr);
    ///Gets the character at the start position of the range.
    ///Params:
    ///    pChar = Type: <b>long*</b> The start character position of the range.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If <i>pChar</i> is null, the method fails and it returns E_INVALIDARG.
    ///    
    HRESULT GetChar(int* pChar);
    ///Sets the character at the starting position of the range.
    ///Params:
    ///    Char = Type: <b>long</b> New value for character at the starting position.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Text is write-protected. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Out of memory.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetChar(int Char);
    ///Gets a duplicate of this range object.
    ///Params:
    ///    ppRange = Type: <b>ITextRange**</b> The duplicate of the range.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> ppRange is null. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure for some other reason.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetDuplicate(ITextRange* ppRange);
    ///Gets an ITextRange object with the specified range's formatted text.
    ///Params:
    ///    ppRange = Type: <b>ITextRange**</b> The ITextRange object with the formatted text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> <i>ppRange</i> is null. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Out of memory. </td> </tr> </table>
    ///    
    HRESULT GetFormattedText(ITextRange* ppRange);
    ///Sets the formatted text of this range text to the formatted text of the specified range.
    ///Params:
    ///    pRange = Type: <b>ITextRange*</b> The formatted text to replace this range's text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Text is protected. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pRange</i> is null. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Out of memory.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetFormattedText(ITextRange pRange);
    ///Gets the start character position of the range.
    ///Params:
    ///    pcpFirst = Type: <b>long*</b> The start character position.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If <i>pcpFirst</i> is null, the method fails and it returns E_INVALIDARG.
    ///    
    HRESULT GetStart(int* pcpFirst);
    ///Sets the character position for the start of this range.
    ///Params:
    ///    cpFirst = Type: <b>long</b> The new character position for the start of the range.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns S_FALSE.
    ///    
    HRESULT SetStart(int cpFirst);
    ///Gets the end character position of the range.
    ///Params:
    ///    pcpLim = Type: <b>long*</b> The end character position.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If <i>pcpLim</i> is null, the method fails and it returns E_INVALIDARG.
    ///    
    HRESULT GetEnd(int* pcpLim);
    ///Sets the end position of the range.
    ///Params:
    ///    cpLim = Type: <b>long</b> The new end position.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns S_FALSE.
    ///    
    HRESULT SetEnd(int cpLim);
    ///Gets an ITextFont object with the character attributes of the specified range.
    ///Params:
    ///    ppFont = Type: <b>ITextFont**</b> The pointer to an ITextFont object.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If <i>ppFont</i> is null, the method fails and it returns E_INVALIDARG.
    ///    
    HRESULT GetFont(ITextFont* ppFont);
    ///Sets this range's character attributes to those of the specified ITextFont object.
    ///Params:
    ///    pFont = Type: <b>ITextFont*</b> A font object with the desired character format.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Text is protected. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pFont</i> is null.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Out of
    ///    memory. </td> </tr> </table>
    ///    
    HRESULT SetFont(ITextFont pFont);
    ///Gets an ITextPara object with the paragraph attributes of the specified range.
    ///Params:
    ///    ppPara = Type: <b>ITextPara**</b> The pointer to the ITextPara object.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If <i>ppPara</i> is null, the method fails and it returns E_INVALIDARG.
    ///    
    HRESULT GetPara(ITextPara* ppPara);
    ///Sets the paragraph attributes of this range to those of the specified ITextPara object.
    ///Params:
    ///    pPara = Type: <b>ITextPara*</b> The paragraph object with the desired paragraph format.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Text is write-protected. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pPara</i> is
    ///    null. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Out
    ///    of memory. </td> </tr> </table>
    ///    
    HRESULT SetPara(ITextPara pPara);
    ///Gets the count of characters in the range's story.
    ///Params:
    ///    pCount = Type: <b>long*</b> The count of characters in the range's story.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If <i>pCount</i> is null, the method fails and it returns E_INVALIDARG.
    ///    
    HRESULT GetStoryLength(int* pCount);
    ///Get the type of the range's story.
    ///Params:
    ///    pValue = Type: <b>long*</b> The type of the range's story. The <i>pValue</i> value can be one of the following values.
    ///             <table class="clsStd"> <tr> <th>Story type</th> <th>Value</th> <th>Story type</th> <th>Value</th> </tr> <tr>
    ///             <td><b>tomUnknownStory</b></td> <td>0</td> <td><b>tomEvenPagesHeaderStory</b></td> <td>6</td> </tr> <tr>
    ///             <td><b>tomMainTextStory</b></td> <td>1</td> <td><b>tomPrimaryHeaderStory</b></td> <td>7</td> </tr> <tr>
    ///             <td><b>tomFootnotesStory</b></td> <td>2</td> <td><b>tomEvenPagesFooterStory</b></td> <td>8</td> </tr> <tr>
    ///             <td><b>tomEndnotesStory</b></td> <td>3</td> <td><b>tomPrimaryFooterStory</b></td> <td>9</td> </tr> <tr>
    ///             <td><b>tomCommentsStory</b></td> <td>4</td> <td><b>tomFirstPageHeaderStory</b></td> <td>10</td> </tr> <tr>
    ///             <td><b>tomTextFrameStory</b></td> <td>5</td> <td><b>tomFirstPageFooterStory</b></td> <td>11</td> </tr>
    ///             </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If <i>pValue</i> is null, the method fails and it returns E_INVALIDARG.
    ///    
    HRESULT GetStoryType(int* pValue);
    ///Collapses the specified text range into a degenerate point at either the beginning or end of the range.
    ///Params:
    ///    bStart = Type: <b>long</b> Flag specifying the end to collapse at. It can be one of the following. <table> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomStart_or_tomTrue"></a><a
    ///             id="tomstart_or_tomtrue"></a><a id="TOMSTART_OR_TOMTRUE"></a><dl> <dt><b>tomStart or tomTrue</b></dt> </dl>
    ///             </td> <td width="60%"> Range is collapsed to the start of the range. This is the default. </td> </tr> <tr>
    ///             <td width="40%"><a id="tomEnd_or_tomFalse"></a><a id="tomend_or_tomfalse"></a><a
    ///             id="TOMEND_OR_TOMFALSE"></a><dl> <dt><b>tomEnd or tomFalse</b></dt> </dl> </td> <td width="60%"> Range is
    ///             collapsed to the end of the range. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns an <b>HRESULT</b> value. If successful, it returns <b>S_OK</b>.
    ///    Otherwise, it returns S_FALSE.
    ///    
    HRESULT Collapse(int bStart);
    ///Expands this range so that any partial units it contains are completely contained.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit to include, if it is partially within the range. The default value is
    ///           <code>tomWord</code>. For a list of the other <i>Unit</i> values, see the discussion under ITextRange.
    ///    pDelta = Type: <b>long*</b> The count of characters added to the range. The value can be null.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Unit is not supported. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT Expand(int Unit, int* pDelta);
    ///Retrieves the story index of the <i>Unit</i> parameter at the specified range Start character position. The first
    ///<i>Unit</i> in a story has an index value of 1. The index of a <i>Unit</i> is the same for all character
    ///positions from that immediately preceding the <i>Unit</i> up to the last character in the <i>Unit</i>.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit that is indexed. For a list of possible <i>Unit</i> values, see the discussion under
    ///           ITextRange.
    ///    pIndex = Type: <b>long*</b> The index value. The value is zero if <i>Unit</i> does not exist.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pIndex</i> is null. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Unit does not exist.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetIndex(int Unit, int* pIndex);
    ///Changes this range to the specified unit of the story.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit used to index the range. For a list of unit values, see ITextRange.
    ///    Index = Type: <b>long</b> Index for the <i>Unit</i>. This range is relocated to the <i>Unit</i> that has this index
    ///            number. If positive, the numbering of <i>Unit</i>s begins at the start of the story and proceeds forward. If
    ///            negative, the numbering begins at the end of the story and proceeds backward. The start of the story
    ///            corresponds to an <i>Index</i> of 1 for all units that exist, and the last unit in the story corresponds to
    ///            an <i>Index</i> of -1.
    ///    Extend = Type: <b>long</b> Flag that indicates the extent of the range. If zero (the default), the range is collapsed
    ///             to an insertion point at the start position of the specified <i>Unit</i>. If nonzero, the range is set to the
    ///             entire <i>Unit</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Index is not valid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Unit is not supported.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some
    ///    other reason. </td> </tr> </table>
    ///    
    HRESULT SetIndex(int Unit, int Index, int Extend);
    ///Adjusts the range endpoints to the specified values.
    ///Params:
    ///    cpAnchor = Type: <b>long</b> The character position for the anchor end of the range.
    ///    cpActive = Type: <b>long</b> The character position for the active end of the range.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRange(int cpAnchor, int cpActive);
    ///Determines whether this range is within or at the same text as a specified range.
    ///Params:
    ///    pRange = Type: <b>ITextRange*</b> Text that is compared to the current range.
    ///    pValue = Type: <b>long*</b> The comparison result. The pointer can be null. The method returns <i>pB</i> is
    ///             <b>tomTrue</b> only if the range is in or at the same text as <i>pRange</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns S_FALSE.
    ///    
    HRESULT InRange(ITextRange pRange, int* pValue);
    ///Determines whether this range's story is the same as a specified range's story.
    ///Params:
    ///    pRange = Type: <b>ITextRange*</b> The ITextRange object whose story is compared to this range's story.
    ///    pValue = Type: <b>long*</b> The comparison result. The pointer can be null. The <i>pB</i> parameter receives
    ///             <b>tomTrue</b> if this range's story is the same as that of the <i>pRange</i>; otherwise it receives
    ///             <b>tomFalse</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the two stories are the same, the method
    ///    returns <b>S_OK</b>. Otherwise, it returns S_FALSE.
    ///    
    HRESULT InStory(ITextRange pRange, int* pValue);
    ///Determines whether this range has the same character positions and story as those of a specified range.
    ///Params:
    ///    pRange = Type: <b>ITextRange*</b> The ITextRange object that is compared to this range.
    ///    pValue = Type: <b>long*</b> The comparison result. The pointer can be null. The <i>pB</i> parameter receives
    ///             <b>tomTrue</b> if this range points at the same text (has the same start and end character positions and
    ///             story) as <i>pRange</i>; otherwise it returns <b>tomFalse</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the ranges have the same character
    ///    positions and story, the method returns <b>S_OK</b>. Otherwise, it returns S_FALSE.
    ///    
    HRESULT IsEqual(ITextRange pRange, int* pValue);
    ///Sets the start and end positions, and story values of the active selection, to those of this range.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns S_FALSE.
    ///    
    HRESULT Select();
    ///Moves the range ends to the start of the first overlapping <i>Unit</i> in the range.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit to use in the move operation. For a list of <i>Unit</i> values, see the discussion
    ///           under ITextRange.
    ///    Extend = Type: <b>long</b> How to move the ends of the range. It can be one of the following values. <table
    ///             class="clsStd"> <tr> <td>0 (or <b>tomMove</b>)</td> <td>Collapses a nondegenerate range to the start position
    ///             by moving the insertion point. This is the default.</td> </tr> <tr> <td>1 (or <b>tomExtend</b>)</td>
    ///             <td>Moves the start position to the beginning of the overlapping <i>Unit</i>. Does not move the end position.
    ///             </td> </tr> </table>
    ///    pDelta = Type: <b>long*</b> Pointer to a variable that receives the number of characters that the start position is
    ///             moved. It can be null. On return, <i>pDelta</i> is the signed number of characters that the insertion point
    ///             or start position is moved. This value is always less than or equal to zero, because the motion is always
    ///             toward the beginning of the story.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Unit is not supported. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT StartOf(int Unit, int Extend, int* pDelta);
    ///Moves this range's ends to the end of the last overlapping <i>Unit</i> in the range.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit to use. Default value: <i>tomWord</i>. For a list of the other <i>Unit</i> values, see
    ///           the discussion under ITextRange.
    ///    Extend = Type: <b>long</b> Indicator of how the shifting of the range ends is to proceed. It can be one of the
    ///             following. <table class="clsStd"> <tr> <td>0 or <i>tomMove</i></td> <td>Collapses a nondegenerate range to
    ///             the End of the original range by moving the insertion point. This is the default.</td> </tr> <tr> <td>1 (or
    ///             <i>tomExtend</i>)</td> <td>Moves End to the end of the overlapping <i>Unit</i>. Does not move Start.</td>
    ///             </tr> </table>
    ///    pDelta = Type: <b>long*</b> The count of characters that End is moved past. The value of the pointer can be null. On
    ///             return, the value of <i>pDelta</i> is the number of characters the insertion point or End is moved
    ///             <i>plus</i> 1 if a collapse occurs to the entry End. If the range includes the final CR (carriage return) (at
    ///             the end of the story) and <i>Extend</i> = tomMove, then <i>pDelta</i> is set to –1, to indicate that the
    ///             collapse occurred <i>before</i> the end of the range (because an insertion point cannot exist beyond the
    ///             final CR).
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Unit is not supported. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT EndOf(int Unit, int Extend, int* pDelta);
    ///Moves the insertion point forward or backward a specified number of units. If the range is nondegenerate, the
    ///range is collapsed to an insertion point at either end, depending on <i>Count</i>, and then is moved.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit to use. The default value is <b>tomCharacter</b>. For information on other values, see
    ///           the discussion in ITextRange.
    ///    Count = Type: <b>long</b> Number of <i>Unit</i>s to move past. The default value is 1. If <i>Count</i> is greater
    ///            than zero, motion is forward—toward the end of the story—and if <i>Count</i> is less than zero, motion is
    ///            backward—toward the beginning. If <i>Count</i> is zero, the range is unchanged.
    ///    pDelta = Type: <b>long*</b> The actual number of <i>Unit</i>s the insertion point moves past. The pointer can be
    ///             <b>NULL</b>. For more information, see the Remarks section.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds in moving the
    ///    insertion point, it returns <b>S_OK</b>. If the method fails, it returns one of the following error codes.
    ///    For more information about COM error codes, see Error Handling in COM. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%">
    ///    <i>Unit</i> is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> Failure for some other reason. </td> </tr> </table>
    ///    
    HRESULT Move(int Unit, int Count, int* pDelta);
    ///Moves the start postion of the range the specified number of units in the specified direction.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit used in the move. The default value is <b>tomCharacter</b>. For a list of the other
    ///           <i>Unit</i> values, see the discussion under ITextRange.
    ///    Count = Type: <b>long</b> Number of units to move. The default value is 1. If <i>Count</i> is greater than zero,
    ///            motion is forward—toward the end of the story—and if <i>Count</i> is less than zero, motion is
    ///            backward—toward the beginning. If <i>Count</i> is zero, the start position is unchanged.
    ///    pDelta = Type: <b>long*</b> The actual number of units that the end is moved. The value can be null.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Unit is not supported. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT MoveStart(int Unit, int Count, int* pDelta);
    ///Moves the end position of the range.
    ///Params:
    ///    Unit = Type: <b>long</b> The units by which to move the end of the range. The default value is <b>tomCharacter</b>.
    ///           For a list of the other unit values, see ITextRange.
    ///    Count = Type: <b>long</b> The number of units to move past. The default value is 1. If <i>Count</i> is greater than
    ///            zero, motion is forward—toward the end of the story—and if <i>Count</i> is less than zero, motion is
    ///            backward—toward the beginning. If <i>Count</i> is zero, the end position is unchanged.
    ///    pDelta = Type: <b>long*</b> The actual number of units that the end position of the range is moved past. The value can
    ///             be null.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Unit is not supported. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT MoveEnd(int Unit, int Count, int* pDelta);
    ///Starts at a specified end of a range and searches while the characters belong to the set specified by <i>Cset</i>
    ///and while the number of characters is less than or equal to <i>Count</i>. The range is collapsed to an insertion
    ///point when a non-matching character is found.
    ///Params:
    ///    Cset = Type: <b>VARIANT*</b> The character set to use in the match. This could be an explicit string of characters
    ///           or a character-set index. For more information, see Character Match Sets.
    ///    Count = Type: <b>long</b> Maximum number of characters to move past. The default value is <b>tomForward</b>, which
    ///            searches to the end of the story. If <i>Count</i> is less than zero, the search starts at the start position
    ///            and goes backward — toward the beginning of the story. If <i>Count</i> is greater than zero, the search
    ///            starts at the end position and goes forward — toward the end of the story.
    ///    pDelta = Type: <b>long*</b> The actual count of characters end is moved. This parameter can be null.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Cset is not valid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT MoveWhile(VARIANT* Cset, int Count, int* pDelta);
    ///Moves the start position of the range either <i>Count</i> characters, or just past all contiguous characters that
    ///are found in the set of characters specified by <i>Cset</i>, whichever is less.
    ///Params:
    ///    Cset = Type: <b>VARIANT*</b> The character set to use in the match. This could be an explicit string of characters
    ///           or a character-set index. For more information, see Character Match Sets.
    ///    Count = Type: <b>long</b> Maximum number of characters to move past. The default value is <b>tomForward</b>, which
    ///            searches to the end of the story. If <i>Count</i> is greater than zero, the search is forward—toward the
    ///            end of the story—and if <i>Count</i> is less than zero, search is backward—toward the beginning. If
    ///            <i>Count</i> is zero, the start position is unchanged.
    ///    pDelta = Type: <b>long*</b> The actual count of characters that the start position is moved. This parameter can be
    ///             null.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Cset is not valid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT MoveStartWhile(VARIANT* Cset, int Count, int* pDelta);
    ///Moves the end of the range either <i>Count</i> characters or just past all contiguous characters that are found
    ///in the set of characters specified by <i>Cset</i>, whichever is less.
    ///Params:
    ///    Cset = Type: <b>VARIANT*</b> The character set to use in the match. This could be an explicit string of characters
    ///           or a character-set index. For more information, see Character Match Sets.
    ///    Count = Type: <b>long</b> Maximum number of characters to move past. The default value is <b>tomForward</b>, which
    ///            searches to the end of the story. If <i>Count</i> is greater than zero, the search moves forward (toward the
    ///            end of the story). If <i>Count</i> is less than zero, the search moves backward (toward the beginning of the
    ///            story). If <i>Count</i> is zero, the end position is unchanged.
    ///    pDelta = Type: <b>long*</b> The actual number of characters that the end is moved. The value can be null.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Cset is not valid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT MoveEndWhile(VARIANT* Cset, int Count, int* pDelta);
    ///Searches up to <i>Count</i> characters for the first character in the set of characters specified by <i>Cset</i>.
    ///If a character is found, the range is collapsed to that point. The start of the search and the direction are also
    ///specified by <i>Count</i>.
    ///Params:
    ///    Cset = Type: <b>VARIANT*</b> The character set used in the match. This could be an explicit string of characters or
    ///           a character-set index. For more information, see Character Match Sets.
    ///    Count = Type: <b>long</b> Maximum number of characters to move past. The default value is <b>tomForward</b>, which
    ///            searches to the end of the story. If <i>Count</i> is less than zero, the search is backward starting at the
    ///            start position. If <i>Count</i> is greater than zero, the search is forward starting at the end.
    ///    pDelta = Type: <b>long*</b> The number of characters the insertion point is moved, plus 1 for a match if <i>Count</i>
    ///             is greater than zero, and –1 for a match if <i>Count</i> less than zero. The pointer can be null.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>Cset</i> is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT MoveUntil(VARIANT* Cset, int Count, int* pDelta);
    ///Moves the start position of the range the position of the first character found that is in the set of characters
    ///specified by <i>Cset</i>, provided that the character is found within <i>Count</i> characters of the start
    ///position.
    ///Params:
    ///    Cset = Type: <b>VARIANT*</b> The character set to use in the match. This could be an explicit string of characters
    ///           or a character-set index. For more information, see Character Match Sets.
    ///    Count = Type: <b>long</b> Maximum number of characters to move past. The default value is <b>tomForward</b>, which
    ///            searches to the end of the story. If <i>Count</i> is greater than zero, the search is forward—toward the
    ///            end of the story—and if <i>Count</i> is less than zero, search is backward—toward the beginning. If
    ///            <i>Count</i> is zero, the start position is unchanged.
    ///    pDelta = Type: <b>long*</b> The actual number of characters the start of the range is moved, plus 1 for a match if
    ///             <i>Count</i> is greater than zero, and –1 for a match if <i>Count</i> is less than zero. The value can be
    ///             null.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Cset is not valid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT MoveStartUntil(VARIANT* Cset, int Count, int* pDelta);
    ///Moves the range's end to the character position of the first character found that is in the set of characters
    ///specified by <i>Cset</i>, provided that the character is found within <i>Count</i> characters of the range's end.
    ///Params:
    ///    Cset = Type: <b>VARIANT*</b> The character set to use in the match. This could be an explicit string of characters
    ///           or a character-set index. For more information, see Character Match Sets.
    ///    Count = Type: <b>long</b> Maximum number of characters to move past. The default value is <b>tomForward</b>, which
    ///            searches to the end of the story. If <i>Count</i> is greater than zero, the search moves forward (toward the
    ///            end of the story). If <i>Count</i> is less than zero, the search moves backward (toward the beginning of the
    ///            story). If <i>Count</i> is zero, the end position is unchanged.
    ///    pDelta = Type: <b>long*</b> The actual number of characters that the range end is moved, plus 1 for a match if
    ///             <i>Count</i> is greater than zero, and –1 for a match if <i>Count</i> is less than zero. The value can be
    ///             null.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Cset is invalid. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other reason.
    ///    </td> </tr> </table>
    ///    
    HRESULT MoveEndUntil(VARIANT* Cset, int Count, int* pDelta);
    HRESULT FindTextA(BSTR bstr, int Count, int Flags, int* pLength);
    ///Searches up to <i>Count</i> characters for the string, <i>bstr</i>, starting at the range's Start <i>cp</i>
    ///(<i>cpFirst)</i>. The search is subject to the comparison parameter, <i>Flags</i>. If the string is found, the
    ///Start <i>cp</i> is changed to the matched string, and <i>pLength</i> is set equal to the length of the string. If
    ///the string is not found, the range is unchanged, and <i>pLength</i> is set equal to zero.
    ///Params:
    ///    bstr = Type: <b>BSTR</b> The string to search for.
    ///    Count = Type: <b>long</b> Maximum number of characters to search. It can be one of the following. <table
    ///            class="clsStd"> <tr> <td><i>tomForward</i></td> <td>Search to the end of the story. This is the default
    ///            value.</td> </tr> <tr> <td><i>n </i>(greater than 0)</td> <td>Search forward for <i>n</i> chars, starting
    ///            from <i>cpLim.</i></td> </tr> <tr> <td><i>n </i>(less than 0)</td> <td>Search backward for <i>n</i> chars,
    ///            starting from <i>cpLim.</i></td> </tr> </table>
    ///    Flags = Type: <b>long</b> Flags governing the comparisons. It can be zero (the default) or any combination of the
    ///            following values. <table class="clsStd"> <tr> <td><i>tomMatchWord</i></td> <td>2</td> <td>Matches whole
    ///            words.</td> </tr> <tr> <td><i>tomMatchCase</i></td> <td>4</td> <td>Matches case.</td> </tr> <tr>
    ///            <td><i>tomMatchPattern</i></td> <td>8</td> <td>Matches regular expressions.</td> </tr> </table>
    ///    pLength = Type: <b>long*</b> The length of the matched string.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns S_FALSE.
    ///    
    HRESULT FindTextStart(BSTR bstr, int Count, int Flags, int* pLength);
    ///Searches up to <i>Count</i> characters for the string, <i>bstr</i>, starting from the range's End <i>cp</i>. The
    ///search is subject to the comparison parameter, <i>Flags</i>. If the string is found, the End <i>cp</i> is changed
    ///to be the end of the matched string, and <i>pLength</i> is set equal to the length of the string. If the string
    ///is not found, the range is unchanged and <i>pLength</i> is set equal to zero.
    ///Params:
    ///    bstr = Type: <b>BSTR</b> String to search for.
    ///    Count = Type: <b>long</b> Maximum number of characters to search. It can be one of the following. <table
    ///            class="clsStd"> <tr> <td><i>tomForward</i></td> <td>Search to the end of the story. This is the default
    ///            value.</td> </tr> <tr> <td><i>n</i> (greater than 0)</td> <td>Search forward for <i>n</i> chars, starting
    ///            from <i>cpLim.</i></td> </tr> <tr> <td><i>n</i> (less than 0)</td> <td>Search backward for <i>n</i> chars,
    ///            starting from <i>cpLim.</i></td> </tr> </table>
    ///    Flags = Type: <b>long</b> Flags governing comparisons. It can be zero (the default) or any combination of the
    ///            following values. <table class="clsStd"> <tr> <td><i>tomMatchWord</i></td> <td>2</td> <td>Matches whole
    ///            words.</td> </tr> <tr> <td><i>tomMatchCase</i></td> <td>4</td> <td>Matches case.</td> </tr> <tr>
    ///            <td><i>tomMatchPattern</i></td> <td>8</td> <td>Matches regular expressions.</td> </tr> </table>
    ///    pLength = Type: <b>long*</b> The length of string matched.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns S_FALSE.
    ///    
    HRESULT FindTextEnd(BSTR bstr, int Count, int Flags, int* pLength);
    ///Mimics the DELETE and BACKSPACE keys, with and without the CTRL key depressed.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit to use. <i>Unit</i> can be <i>tomCharacter</i> (the default value) or <i>tomWord</i>.
    ///    Count = Type: <b>long</b> Number of <i>Unit</i>s to delete. If <i>Count</i>= zero, it deletes the text in the range
    ///            only. If <i>Count</i> is greater than zero, <b>ITextRange::Delete</b> acts as if the DELETE key was pressed
    ///            <i>Count</i> times. If <i>Count</i> is less than zero, it acts as if the BACKSPACE key was pressed
    ///            <i>Count</i> times. The default value is 1. For more information, see the Remarks.
    ///    pDelta = Type: <b>long*</b> The count of units deleted. It can be null. The <i>pDelta</i> parameter is set equal to
    ///             the number of <i>Unit</i>s deleted. Deleting the text in a nondegenerate range counts as one <i>Unit</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns an <b>HRESULT</b> value. If successful, it returns <b>S_OK</b>.
    ///    Otherwise it returns one of the following values. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Text is write-protected. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other reason. </td>
    ///    </tr> </table>
    ///    
    HRESULT Delete(int Unit, int Count, int* pDelta);
    ///Cuts the plain or rich text to a data object or to the Clipboard, depending on the <i>pVar</i> parameter.
    ///Params:
    ///    pVar = Type: <b>VARIANT*</b> The cut text. <i>pVar</i>-&gt;ppunkVal is the out parameter for an IDataObject object,
    ///           provided that the following conditions exist: <ul> <li>pVar-&gt;vt = (VT_UNKNOWN | VT_BYREF) </li> <li>pVar
    ///           is not null </li> <li>pVar-&gt;ppunkVal is not null </li> </ul> Otherwise, the clipboard is used.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns an <b>HRESULT</b> value. If successful, it returns <b>S_OK</b>.
    ///    Otherwise it returns one of the following values. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Text is write-protected. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Out of memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT Cut(VARIANT* pVar);
    ///Copies the text to a data object.
    ///Params:
    ///    pVar = Type: <b>VARIANT*</b> The copied text. <i>pVar</i>-&gt;ppunkVal is the out parameter for an IDataObject
    ///           provided that the following conditions exist: <ul> <li>pVar-&gt;vt = (VT_UNKNOWN | VT_BYREF) </li> <li>pVar
    ///           is not null </li> <li>pVar-&gt;ppunkVal is not null </li> </ul> Otherwise, the clipboard is used.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns an <b>HRESULT</b> value. If successful, it returns <b>S_OK</b>.
    ///    Otherwise, it returns <b>E_OUTOFMEMORY</b>.
    ///    
    HRESULT Copy(VARIANT* pVar);
    ///Pastes text from a specified data object.
    ///Params:
    ///    pVar = Type: <b>VARIANT*</b> The IDataObject to paste. However, the contents of the clipboard are used if any of the
    ///           following are true. <i>pVar</i> is null <i>pVar</i> punkVal is null <i>pVar</i> is not <b>VT_UNKNOWN</b>
    ///           <i>pVar</i> punkVal does not return an IDataObject when queried for one
    ///    Format = Type: <b>long</b> The clipboard format to use in the paste operation. Zero is best format, which usually is
    ///             RTF, but <b>CF_UNICODETEXT</b> and other formats are also possible. The default value is zero. For more
    ///             information, see Clipboard Formats.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Destination is write-protected. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Destination cannot contain
    ///    the text to be pasted. </td> </tr> </table>
    ///    
    HRESULT Paste(VARIANT* pVar, int Format);
    ///Determines if a data object can be pasted, using a specified format, into the current range.
    ///Params:
    ///    pVar = Type: <b>VARIANT*</b> The IDataObject to be pasted. However, the Clipboard contents are checked for pasting
    ///           if any of the following are true: <ul> <li><i>pVar</i> is null </li> <li><i>pVar</i>-&gt;punkVal is null
    ///           </li> <li><i>pVar</i>-&gt;vt is not <b>VT_UNKNOWN</b></li> <li><i>pVar</i>-&gt;punkVal does not return an
    ///           IDataObject object when queried for one </li> </ul>
    ///    Format = Type: <b>long</b> Clipboard format that is used. Zero represents the best format, which usually is RTF, but
    ///             <b>CF_UNICODETEXT</b> and other formats are also possible. The default value is zero.
    ///    pValue = Type: <b>long*</b> A tomBool value that is <b>tomTrue</b> only if the data object identified by <i>pVar</i>
    ///             can be pasted, using the specified format, into the range. This parameter can null.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns the following COM error codes. For more information on COM error
    ///    codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The clipboard contents or IDataObject can
    ///    be pasted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The
    ///    clipboard contents or IDataObject cannot be pasted. </td> </tr> </table>
    ///    
    HRESULT CanPaste(VARIANT* pVar, int Format, int* pValue);
    ///Determines whether the specified range can be edited.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value indicating whether the range can be edited. It is <b>tomTrue</b> only if
    ///             the specified range can be edited. The pointer can be null.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the range can be edited, the method succeeds and returns <b>S_OK</b>. If the range
    ///    cannot be edited, the method fails and returns <b>S_FALSE</b>. For more information about COM error codes,
    ///    see Error Handling in COM.
    ///    
    HRESULT CanEdit(int* pValue);
    ///Changes the case of letters in this range according to the <i>Type</i> parameter.
    ///Params:
    ///    Type = Type: <b>long</b> Type of case change. The default value is <i>tomLower</i>. <table> <tr> <th>Value</th>
    ///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomLowerCase"></a><a id="tomlowercase"></a><a
    ///           id="TOMLOWERCASE"></a><dl> <dt><b>tomLowerCase</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Sets all text
    ///           to lowercase. </td> </tr> <tr> <td width="40%"><a id="tomUpperCase"></a><a id="tomuppercase"></a><a
    ///           id="TOMUPPERCASE"></a><dl> <dt><b>tomUpperCase</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Sets all text
    ///           to lowercase. </td> </tr> <tr> <td width="40%"><a id="tomTitleCase"></a><a id="tomtitlecase"></a><a
    ///           id="TOMTITLECASE"></a><dl> <dt><b>tomTitleCase</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Capitalizes
    ///           the first letter of each word. </td> </tr> <tr> <td width="40%"><a id="tomSentenceCase"></a><a
    ///           id="tomsentencecase"></a><a id="TOMSENTENCECASE"></a><dl> <dt><b>tomSentenceCase</b></dt> <dt>4</dt> </dl>
    ///           </td> <td width="60%"> Capitalizes the first letter of each sentence. </td> </tr> <tr> <td width="40%"><a
    ///           id="tomToggleCase"></a><a id="tomtogglecase"></a><a id="TOMTOGGLECASE"></a><dl> <dt><b>tomToggleCase</b></dt>
    ///           <dt>5</dt> </dl> </td> <td width="60%"> Toggles the case of each letter. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns an <b>HRESULT</b> value. If successful, it returns <b>S_OK</b>.
    ///    Otherwise, it returns S_FALSE.
    ///    
    HRESULT ChangeCase(int Type);
    ///Retrieves screen coordinates for the start or end character position in the text range, along with the intra-line
    ///position.
    ///Params:
    ///    Type = Type: <b>long</b> Flag that indicates the position to retrieve. This parameter can include one value from
    ///           each of the following tables. The default value is tomStart + TA_BASELINE + TA_LEFT. <a
    ///           id="tomAllowOffClient"></a> <a id="tomallowoffclient"></a> <a id="TOMALLOWOFFCLIENT"></a>
    ///    px = Type: <b>long*</b> The x-coordinate.
    ///    py = Type: <b>long*</b> The y-coordinate.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Either <i>px</i> or <i>py</i> is
    ///    null. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for
    ///    some other reason. </td> </tr> </table>
    ///    
    HRESULT GetPoint(int Type, int* px, int* py);
    ///Changes the range based on a specified point at or up through (depending on <i>Extend</i>) the point (<i>x</i>,
    ///<i>y</i>) aligned according to <i>Type</i>.
    ///Params:
    ///    x = Type: <b>long</b> Horizontal coordinate of the specified point, in absolute screen coordinates.
    ///    y = Type: <b>long</b> Vertical coordinate of the specified point, in absolute screen coordinates.
    ///    Type = Type: <b>long</b> The end to move to the specified point. It can be one of the following. <table
    ///           class="clsStd"> <tr> <td><b>tomStart</b></td> <td>Move the start of range.</td> </tr> <tr>
    ///           <td><b>tomEnd</b></td> <td>Move the end of range.</td> </tr> </table>
    ///    Extend = Type: <b>long</b> How to set the endpoints of the range. If <i>Extend</i> is zero (the default), the range is
    ///             an insertion point at the specified point (or at the nearest point with selectable text). If <i>Extend</i> is
    ///             1, the end specified by <i>Type</i> is moved to the point and the other end is left alone.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns <b>S_OK</b>.
    ///    
    HRESULT SetPoint(int x, int y, int Type, int Extend);
    ///Scrolls the specified range into view.
    ///Params:
    ///    Value = Type: <b>long</b> Flag specifying the end to scroll into view. It can be one of the following. <table> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomEnd"></a><a id="tomend"></a><a
    ///            id="TOMEND"></a><dl> <dt><b>tomEnd</b></dt> </dl> </td> <td width="60%"> Scrolls the end character position
    ///            to appear on the bottom line. </td> </tr> <tr> <td width="40%"><a id="tomStart"></a><a id="tomstart"></a><a
    ///            id="TOMSTART"></a><dl> <dt><b>tomStart</b></dt> </dl> </td> <td width="60%"> Scrolls the start character
    ///            position to appear on the top line. (Default value). </td> </tr> <tr> <td width="40%"><a
    ///            id="tomNoUpScroll"></a><a id="tomnoupscroll"></a><a id="TOMNOUPSCROLL"></a><dl> <dt><b>tomNoUpScroll</b></dt>
    ///            </dl> </td> <td width="60%"></td> </tr> <tr> <td width="40%"><a id="tomNoVpScroll"></a><a
    ///            id="tomnovpscroll"></a><a id="TOMNOVPSCROLL"></a><dl> <dt><b>tomNoVpScroll</b></dt> </dl> </td> <td
    ///            width="60%"></td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns S_FALSE.
    ///    
    HRESULT ScrollIntoView(int Value);
    ///Retrieves a pointer to the embedded object at the start of the specified range, that is, at <i>cpFirst</i>. The
    ///range must either be an insertion point or it must select only the embedded object.
    ///Params:
    ///    ppObject = Type: <b>IUnknown**</b> The pointer to the object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> <i>ppObject</i> is null. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other reason. </td> </tr> </table>
    ///    
    HRESULT GetEmbeddedObject(IUnknown* ppObject);
}

///A text selection is a text range with selection highlighting.
@GUID("8CC497C1-A1DF-11CE-8098-00AA0047BE5D")
interface ITextSelection : ITextRange
{
    ///Gets the text selection flags.
    ///Params:
    ///    pFlags = Type: <b>long*</b> Any combination of the following selection flags. <table class="clsStd"> <tr>
    ///             <th>Selection Flag</th> <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomSelStartActive</b></td>
    ///             <td>1</td> <td>Start end is active.</td> </tr> <tr> <td><b>tomSelAtEOL</b></td> <td>2</td> <td>For degenerate
    ///             selections, the ambiguous character position corresponding to both the beginning of a line and the end of the
    ///             preceding line should have the caret displayed at the end of the preceding line.</td> </tr> <tr>
    ///             <td><b>tomSelOvertype</b></td> <td>4</td> <td>Insert/Overtype mode is set to overtype. </td> </tr> <tr>
    ///             <td><b>tomSelActive</b></td> <td>8</td> <td>Selection is active.</td> </tr> <tr>
    ///             <td><b>tomSelReplace</b></td> <td>16</td> <td>Typing and pasting replaces selection.</td> </tr> </table> Each
    ///             of the table values is binary. Thus, if any value is not set, the text selection has the opposite property.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If <i>pFlags</i> is null, the method fails and it returns E_INVALIDARG.
    ///    
    HRESULT GetFlags(int* pFlags);
    ///Sets the text selection flags.
    ///Params:
    ///    Flags = Type: <b>long</b> New flag values. It can be any combination of the following. <table class="clsStd"> <tr>
    ///            <th>Selection flag</th> <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomSelStartActive</b></td>
    ///            <td>1</td> <td>Start end is active.</td> </tr> <tr> <td><b>tomSelAtEOL</b></td> <td>2</td> <td>For degenerate
    ///            selections, the ambiguous character position corresponding to both the beginning of a line and the end of the
    ///            preceding line should have the caret displayed at the end of the preceding line.</td> </tr> <tr>
    ///            <td><b>tomSelOvertype</b></td> <td>4</td> <td>Insert/Overtype mode is set to overtype. </td> </tr> <tr>
    ///            <td><b>tomSelActive</b></td> <td>8</td> <td>Selection is active.</td> </tr> <tr>
    ///            <td><b>tomSelReplace</b></td> <td>16</td> <td>Typing and pasting replaces selection.</td> </tr> </table> Each
    ///            of the table values is binary. Thus, if any value is not set, the text selection has the opposite property.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns <b>S_OK</b>.
    ///    
    HRESULT SetFlags(int Flags);
    ///Gets the type of text selection.
    ///Params:
    ///    pType = Type: <b>long*</b> The selection type. The method returns <i>pType</i> with one of the values in the
    ///            following table. <table class="clsStd"> <tr> <th>Selection type</th> <th>Value</th> <th>Meaning</th> </tr>
    ///            <tr> <td><b>tomNoSelection</b></td> <td>0</td> <td>No selection and no insertion point.</td> </tr> <tr>
    ///            <td><b>tomSelectionIP</b></td> <td>1</td> <td>Insertion point.</td> </tr> <tr>
    ///            <td><b>tomSelectionNormal</b></td> <td>2</td> <td>Single nondegenerate range.</td> </tr> <tr>
    ///            <td><b>tomSelectionFrame</b></td> <td>3</td> <td>Frame.</td> </tr> <tr> <td><b>tomSelectionColumn</b></td>
    ///            <td>4</td> <td>Table column.</td> </tr> <tr> <td><b>tomSelectionRow</b></td> <td>5</td> <td>Table rows.</td>
    ///            </tr> <tr> <td><b>tomSelectionBlock</b></td> <td>6</td> <td>Block selection.</td> </tr> <tr>
    ///            <td><b>tomSelectionInlineShape</b></td> <td>7</td> <td>Picture.</td> </tr> <tr>
    ///            <td><b>tomSelectionShape</b></td> <td>8</td> <td>Shape.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>StdMETHODIMP</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If <i>pType</i> is null, the method fails and it returns E_INVALIDARG.
    ///    
    HRESULT GetType(int* pType);
    ///Generalizes the functionality of the Left Arrow key.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit to use. It can be one of the following. <table class="clsStd"> <tr> <th>Value</th>
    ///           <th>Corresponding key combination</th> <th>Meaning</th> </tr> <tr> <td><b>tomCharacter</b></td> <td>Left
    ///           Arrow</td> <td>Move one character position to the left. This is the default.</td> </tr> <tr>
    ///           <td><b>tomWord</b></td> <td>Ctrl+Left Arrow</td> <td>Move one word to the left.</td> </tr> </table> Note: If
    ///           <i>Count</i> is less than zero, movement is to the right.
    ///    Count = Type: <b>long</b> Number of Units to move past. The default value is 1. If <i>Count</i> is less than zero,
    ///            movement is to the right.
    ///    Extend = Type: <b>long</b> Flag that indicates how to change the selection. If <i>Extend</i> is zero (or
    ///             <b>tomMove</b>), the method collapses the selection to an insertion point at the active end and then moves
    ///             it. If <i>Extend</i> is 1 (or <b>tomExtend</b>), the method moves the active end and leaves the other end
    ///             alone. The default value is zero. A nonzero <i>Extend</i> value corresponds to the Shift key being pressed in
    ///             addition to the key combination described in <i>Unit</i>.
    ///    pDelta = Type: <b>long*</b> The actual count of units the insertion point or active end is moved left. This parameter
    ///             can be null. Collapsing the selection, when <i>Extend</i> is 0, counts as one unit.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Unit is not valid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT MoveLeft(int Unit, int Count, int Extend, int* pDelta);
    ///Generalizes the functionality of the Right Arrow key.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit to use. It can be one of the following. <table class="clsStd"> <tr> <th>Value</th>
    ///           <th>Corresponding key combination</th> <th>Meaning</th> </tr> <tr> <td><b>tomCharacter</b></td> <td>Right
    ///           Arrow</td> <td>Move one character position to the right. This is the default.</td> </tr> <tr>
    ///           <td><b>tomWord</b></td> <td>Ctrl+Right Arrow</td> <td>Move one word to the right.</td> </tr> </table> Note,
    ///           if <i>Count</i> is less than zero, movement is to the left.
    ///    Count = Type: <b>long</b> Number of Units to move past. The default value is 1. If <i>Count</i> is less than zero,
    ///            movement is to the left.
    ///    Extend = Type: <b>long</b> Flag that indicates how to change the selection. If <i>Extend</i> is zero (or
    ///             <b>tomMove</b>), the method collapses the selection to an insertion point at the active end and then moves
    ///             it. If <i>Extend</i> is 1 (or <b>tomExtend</b>), the method moves the active end and leaves the other end
    ///             alone. The default value is zero. A nonzero <i>Extend</i> value corresponds to the Shift key being pressed in
    ///             addition to the key combination described in <i>Unit</i>.
    ///    pDelta = Type: <b>long*</b> The actual count of units the insertion point or active end is moved left. This parameter
    ///             can be null. Collapsing the selection, when <i>Extend</i> is 0, counts as one unit.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Unit is not valid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT MoveRight(int Unit, int Count, int Extend, int* pDelta);
    ///Mimics the functionality of the Up Arrow and Page Up keys.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit to use in the operation. It can be one of the following. <table class="clsStd"> <tr>
    ///           <th>Value</th> <th>Corresponding key combination</th> <th>Meaning</th> </tr> <tr> <td><b>tomLine</b></td>
    ///           <td>Up Arrow</td> <td>Moves up one line. This is the default.</td> </tr> <tr> <td><b>tomParagraph</b></td>
    ///           <td>Ctrl+Up Arrow</td> <td>Moves up one paragraph.</td> </tr> <tr> <td><b>tomScreen</b></td> <td>Page Up</td>
    ///           <td>Moves up one screen.</td> </tr> <tr> <td><b>tomWindow</b></td> <td>Ctrl+Page Up</td> <td>Moves to first
    ///           character in window.</td> </tr> </table>
    ///    Count = Type: <b>long</b> Number of <i>Units</i> to move past. The default value is 1.
    ///    Extend = Type: <b>long</b> Flag that indicates how to change the selection. If <i>Extend</i> is zero (or
    ///             <b>tomMove</b>), the method collapses the selection to an insertion point and then moves. If <i>Extend</i> is
    ///             1 (or <b>tomExtend</b>), the method moves the active end and leaves the other end alone. The default value is
    ///             zero. A nonzero <i>Extend</i> value corresponds to the Shift key being pressed in addition to the key
    ///             combination described in <i>Unit</i>.
    ///    pDelta = Type: <b>long*</b> The actual count of units the insertion point or active end is moved down. This parameter
    ///             can be null. Collapsing the selection counts as one unit.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Unit is not valid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT MoveUp(int Unit, int Count, int Extend, int* pDelta);
    ///Mimics the functionality of the Down Arrow and Page Down keys.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit to use in the operation. It can be one of the following. <table class="clsStd"> <tr>
    ///           <th>Value</th> <th>Corresponding key combination</th> <th>Meaning</th> </tr> <tr> <td><b>tomLine</b></td>
    ///           <td>Down Arrow</td> <td>Moves down one line. This is the default.</td> </tr> <tr>
    ///           <td><b>tomParagraph</b></td> <td>Ctrl+Down Arrow</td> <td>Moves down one paragraph.</td> </tr> <tr>
    ///           <td><b>tomScreen</b></td> <td>Page Down</td> <td>Moves down one screen.</td> </tr> <tr>
    ///           <td><b>tomWindow</b></td> <td>Ctrl+Page Down</td> <td>Moves to last character in window.</td> </tr> </table>
    ///    Count = Type: <b>long</b> Number of Units to move past. The default value is 1.
    ///    Extend = Type: <b>long</b> Flag that indicates how to change the selection. If <i>Extend</i> is zero (or
    ///             <b>tomMove</b>), the method collapses the selection to an insertion point and then moves. If <i>Extend</i> is
    ///             1 (or <b>tomExtend</b>), the method moves the active end and leaves the other end alone. The default value is
    ///             zero. A nonzero <i>Extend</i> value corresponds to the Shift key being pressed in addition to the key
    ///             combination described in <i>Unit</i>.
    ///    pDelta = Type: <b>long*</b> Pointer to a variable that receives the actual count of units the insertion point or
    ///             active end is moved down. Collapsing the selection counts as one unit. This parameter can be null.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Unit is not valid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Failure for some other
    ///    reason. </td> </tr> </table>
    ///    
    HRESULT MoveDown(int Unit, int Count, int Extend, int* pDelta);
    ///Generalizes the functionality of the Home key.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit to use in the Home key operation. It can take on one of the following values. <table>
    ///           <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomLine"></a><a id="tomline"></a><a
    ///           id="TOMLINE"></a><dl> <dt><b>tomLine</b></dt> </dl> </td> <td width="60%"> Depending on <i>Extend</i>, it
    ///           moves either the insertion point or the active end to the beginning of the first line in the selection. This
    ///           is the default. </td> </tr> <tr> <td width="40%"><a id="tomStory"></a><a id="tomstory"></a><a
    ///           id="TOMSTORY"></a><dl> <dt><b>tomStory</b></dt> </dl> </td> <td width="60%"> Depending on <i>Extend</i>, it
    ///           moves either the insertion point or the active end to the beginning of the first line in the story. </td>
    ///           </tr> <tr> <td width="40%"><a id="tomColumn"></a><a id="tomcolumn"></a><a id="TOMCOLUMN"></a><dl>
    ///           <dt><b>tomColumn</b></dt> </dl> </td> <td width="60%"> Depending on <i>Extend</i>, it moves either the
    ///           insertion point or the active end to the beginning of the first column in the selection. This is available
    ///           only if the TOM engine supports tables. </td> </tr> <tr> <td width="40%"><a id="tomRow"></a><a
    ///           id="tomrow"></a><a id="TOMROW"></a><dl> <dt><b>tomRow</b></dt> </dl> </td> <td width="60%"> Depending on
    ///           <i>Extend</i>, it moves either the insertion point or the active end to the beginning of the first row in the
    ///           selection. This is available only if the TOM engine supports tables. </td> </tr> </table>
    ///    Extend = Type: <b>long</b> Flag that indicates how to change the selection. If <i>Extend</i> is zero (or
    ///             <b>tomMove</b>), the method collapses the selection to an insertion point. If <i>Extend</i> is 1 (or
    ///             <b>tomExtend</b>), the method moves the active end and leaves the other end alone. The default value is zero.
    ///    pDelta = Type: <b>long*</b> Pointer to a variable that receives the count of characters that the insertion point or
    ///             the active end is moved. This parameter can be null.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Unit is neither <b>tomLine</b>
    ///    nor <b>tomStory.</b> </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> Failure for some other reason. </td> </tr> </table>
    ///    
    HRESULT HomeKey(int Unit, int Extend, int* pDelta);
    ///Mimics the functionality of the End key.
    ///Params:
    ///    Unit = Type: <b>long</b> Unit to use. It can be one of the following. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///           </tr> <tr> <td width="40%"><a id="tomLine"></a><a id="tomline"></a><a id="TOMLINE"></a><dl>
    ///           <dt><b>tomLine</b></dt> </dl> </td> <td width="60%"> Depending on <i>Extend</i>, it moves either the
    ///           insertion point or the active end to the end of the last line in the selection. This is the default. </td>
    ///           </tr> <tr> <td width="40%"><a id="tomStory"></a><a id="tomstory"></a><a id="TOMSTORY"></a><dl>
    ///           <dt><b>tomStory</b></dt> </dl> </td> <td width="60%"> Depending on <i>Extend</i>, it moves either the
    ///           insertion point or the active end to the end of the last line in the story. </td> </tr> <tr> <td
    ///           width="40%"><a id="tomColumn"></a><a id="tomcolumn"></a><a id="TOMCOLUMN"></a><dl> <dt><b>tomColumn</b></dt>
    ///           </dl> </td> <td width="60%"> Depending on <i>Extend</i>, it moves either the insertion point or the active
    ///           end to the end of the last column in the selection. This is available only if the TOM engine supports tables.
    ///           </td> </tr> <tr> <td width="40%"><a id="tomRow"></a><a id="tomrow"></a><a id="TOMROW"></a><dl>
    ///           <dt><b>tomRow</b></dt> </dl> </td> <td width="60%"> Depending on <i>Extend</i>, it moves either the insertion
    ///           point or the active end to the end of the last row in the selection. This is available only if the TOM engine
    ///           supports tables. </td> </tr> </table>
    ///    Extend = Type: <b>long</b> Flag that indicates how to change the selection. If <i>Extend</i> is zero (or
    ///             <b>tomMove</b>), the method collapses the selection to an insertion point. If <i>Extend</i> is 1 (or
    ///             <b>tomExtend</b>), the method moves the active end and leaves the other end alone. The default value is zero.
    ///    pDelta = Type: <b>long*</b> Pointer to a variable that receives the count of characters that the insertion point or
    ///             the active end is moved. This parameter can be null.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Unit is neither <b>tomLine</b>
    ///    nor <b>tomStory</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> Failure for some other reason. </td> </tr> </table>
    ///    
    HRESULT EndKey(int Unit, int Extend, int* pDelta);
    ///Types the string given by <i>bstr</i> at this selection as if someone typed it. This is similar to the underlying
    ///SetText method, but is sensitive to the Insert/Overtype key state and UI settings like AutoCorrect and smart
    ///quotes.
    ///Params:
    ///    bstr = Type: <b>BSTR</b> String to type into this selection.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Text is write-protected. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> bstr is null.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Out of
    ///    memory. </td> </tr> </table>
    ///    
    HRESULT TypeText(BSTR bstr);
}

///Text Object Model (TOM) rich text-range attributes are accessed through a pair of dual interfaces, <b>ITextFont</b>
///and ITextPara.
@GUID("8CC497C3-A1DF-11CE-8098-00AA0047BE5D")
interface ITextFont : IDispatch
{
    ///Gets a duplicate of this text font object.
    ///Params:
    ///    ppFont = Type: <b>ITextFont**</b> The duplicate text font object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Memory could not be allocated for the new object. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The method includes an invalid
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%">
    ///    The font object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetDuplicate(ITextFont* ppFont);
    ///Sets the character formatting by copying another text font object.
    ///Params:
    ///    pFont = Type: <b>ITextFont*</b> The text font object to apply to this font object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetDuplicate(ITextFont pFont);
    ///Determines whether the font can be changed.
    ///Params:
    ///    pValue = Type: <b>long*</b> A variable that is <b>tomTrue</b> if the font can be changed or <b>tomFalse</b> if it
    ///             cannot be changed. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the font can change, the method returns <b>S_OK</b>. If the method fails, it returns
    ///    the following COM error code. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The font cannot change. </td> </tr> </table>
    ///    
    HRESULT CanChange(int* pValue);
    ///Determines whether this text font object has the same properties as the specified text font object.
    ///Params:
    ///    pFont = Type: <b>ITextFont*</b> The text font object to compare against.
    ///    pValue = Type: <b>long*</b> A variable that is <b>tomTrue</b> if the font objects have the same properties or
    ///             <b>tomFalse</b> if they do not. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the text font objects have the same properties, the method succeeds and returns
    ///    <b>S_OK</b>. If the text font objects do not have the same properties, the method fails and returns
    ///    <b>S_FALSE</b>. For more information about COM error codes, see Error Handling in COM.
    ///    
    HRESULT IsEqual(ITextFont pFont, int* pValue);
    ///Resets the character formatting to the specified values.
    ///Params:
    ///    Value = Type: <b>long</b> The kind of reset. This parameter can be a combination of the following values. <table>
    ///            <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomDefault"></a><a
    ///            id="tomdefault"></a><a id="TOMDEFAULT"></a><dl> <dt><b>tomDefault</b></dt> </dl> </td> <td width="60%"> Set
    ///            to the document default character format if this font object is attached to a range; otherwise, set the
    ///            defaults to the basic TOM engine defaults. </td> </tr> <tr> <td width="40%"><a id="tomUndefined"></a><a
    ///            id="tomundefined"></a><a id="TOMUNDEFINED"></a><dl> <dt><b>tomUndefined</b></dt> </dl> </td> <td width="60%">
    ///            Sets all properties to undefined values. This value is valid only for a duplicate (clone) font object. </td>
    ///            </tr> <tr> <td width="40%"><a id="tomApplyLater"></a><a id="tomapplylater"></a><a id="TOMAPPLYLATER"></a><dl>
    ///            <dt><b>tomApplyLater</b></dt> </dl> </td> <td width="60%"> Allow property values to be set, but don’t apply
    ///            them to the attached range yet. </td> </tr> <tr> <td width="40%"><a id="tomApplyNow"></a><a
    ///            id="tomapplynow"></a><a id="TOMAPPLYNOW"></a><dl> <dt><b>tomApplyNow</b></dt> </dl> </td> <td width="60%">
    ///            Apply the current properties to attached range. </td> </tr> <tr> <td width="40%"><a id="tomCacheParms"></a><a
    ///            id="tomcacheparms"></a><a id="TOMCACHEPARMS"></a><dl> <dt><b>tomCacheParms</b></dt> </dl> </td> <td
    ///            width="60%"> Do not update the current font with the attached range properties. </td> </tr> <tr> <td
    ///            width="40%"><a id="tomTrackParms"></a><a id="tomtrackparms"></a><a id="TOMTRACKPARMS"></a><dl>
    ///            <dt><b>tomTrackParms</b></dt> </dl> </td> <td width="60%"> Update the current font with the attached range
    ///            properties. </td> </tr> <tr> <td width="40%"><a id="tomApplyTmp"></a><a id="tomapplytmp"></a><a
    ///            id="TOMAPPLYTMP"></a><dl> <dt><b>tomApplyTmp</b></dt> </dl> </td> <td width="60%"> Apply temporary
    ///            formatting. </td> </tr> <tr> <td width="40%"><a id="tomDisableSmartFont"></a><a
    ///            id="tomdisablesmartfont"></a><a id="TOMDISABLESMARTFONT"></a><dl> <dt><b>tomDisableSmartFont</b></dt> </dl>
    ///            </td> <td width="60%"> Do not apply smart fonts. </td> </tr> <tr> <td width="40%"><a
    ///            id="tomEnableSmartFont"></a><a id="tomenablesmartfont"></a><a id="TOMENABLESMARTFONT"></a><dl>
    ///            <dt><b>tomEnableSmartFont</b></dt> </dl> </td> <td width="60%"> Do apply smart fonts. </td> </tr> <tr> <td
    ///            width="40%"><a id="tomUsePoints"></a><a id="tomusepoints"></a><a id="TOMUSEPOINTS"></a><dl>
    ///            <dt><b>tomUsePoints</b></dt> </dl> </td> <td width="60%"> Use points for floating-point measurements. </td>
    ///            </tr> <tr> <td width="40%"><a id="tomUseTwips"></a><a id="tomusetwips"></a><a id="TOMUSETWIPS"></a><dl>
    ///            <dt><b>tomUseTwips</b></dt> </dl> </td> <td width="60%"> Use twips for floating-point measurements. </td>
    ///            </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> Protected from change. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that
    ///    has been deleted. </td> </tr> </table>
    ///    
    HRESULT Reset(int Value);
    ///Gets the character style handle of the characters in a range.
    ///Params:
    ///    pValue = Type: <b>long*</b> The character style handle.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is
    ///    attached to a range that was deleted. </td> </tr> </table> For more information on COM error codes, see Error
    ///    Handling in COM.
    ///    
    HRESULT GetStyle(int* pValue);
    ///Sets the character style handle of the characters in a range.
    ///Params:
    ///    Value = Type: <b>long</b> The new character style handle.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetStyle(int Value);
    ///Gets whether the characters are all uppercase.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are all uppercase.</td>
    ///             </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not all uppercase.</td> </tr> <tr>
    ///             <td><b>tomUndefined</b></td> <td>The AllCaps property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> The method included an invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetAllCaps(int* pValue);
    ///Sets whether the characters are all uppercase.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are all uppercase.</td>
    ///            </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not all uppercase.</td> </tr> <tr>
    ///            <td><b>tomToggle</b></td> <td>Toggle the state of the AllCaps property.</td> </tr> <tr>
    ///            <td><b>tomUndefined</b></td> <td>The AllCaps property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetAllCaps(int Value);
    ///Gets the animation type.
    ///Params:
    ///    pValue = Type: <b>long*</b> One of the following animation types. tomNoAnimation tomLasVegasLights
    ///             tomBlinkingBackground tomSparkleText tomMarchingBlackAnts tomMarchingRedAnts tomShimmer tomWipeDown
    ///             tomWipeRight
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetAnimation(int* pValue);
    ///Sets the animation type.
    ///Params:
    ///    Value = Type: <b>long</b> The animation type. It can be one of the following values. <table class="clsStd"> <tr>
    ///            <th>Animation type</th> <th>Value</th> </tr> <tr> <td><b>tomNoAnimation</b></td> <td>0</td> </tr> <tr>
    ///            <td><b>tomLasVegasLights</b></td> <td>1</td> </tr> <tr> <td><b>tomBlinkingBackground</b></td> <td>2</td>
    ///            </tr> <tr> <td><b>tomSparkleText</b></td> <td>3</td> </tr> <tr> <td><b>tomMarchingBlackAnts</b></td>
    ///            <td>4</td> </tr> <tr> <td><b>tomMarchingRedAnts</b></td> <td>5</td> </tr> <tr> <td><b>tomShimmer</b></td>
    ///            <td>6</td> </tr> <tr> <td><b>tomWipeDown</b></td> <td>7</td> </tr> <tr> <td><b>tomWipeRight</b></td>
    ///            <td>8</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns the
    ///    following COM error code. For more information about COM error codes, see Error Handling in COM. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT SetAnimation(int Value);
    ///Gets the text background (highlight) color.
    ///Params:
    ///    pValue = Type: <b>long*</b> The text background color. It can be one of the following values. <table class="clsStd">
    ///             <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td>A COLORREF value</td> <td>The high-order byte is zero,
    ///             and the three low-order bytes specify an RGB color. </td> </tr> <tr> <td>A value returned by PALETTEINDEX
    ///             </td> <td>The high-order byte is 1, and the LOWORD specifies the index of a logical-color palette entry.</td>
    ///             </tr> <tr> <td><b>tomAutocolor</b> (-9999997)</td> <td>Indicates the range uses the default system background
    ///             color.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetBackColor(int* pValue);
    ///Sets the background color.
    ///Params:
    ///    Value = Type: <b>long</b> The new background color. It can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td>A COLORREF value.</td> <td>An RGB color.</td> </tr> <tr> <td>A
    ///            value returned by PALETTEINDEX </td> <td>A palette index.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>No
    ///            change.</td> </tr> <tr> <td><b>tomAutoColor</b></td> <td>Use the default background color.</td> </tr>
    ///            </table> If <i>Value</i> contains an RGB color, generate the COLORREF by using the RGB macro.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetBackColor(int Value);
    ///Gets whether the characters are bold.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are bold.</td> </tr> <tr>
    ///             <td><b>tomFalse</b></td> <td>Characters are not bold.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The
    ///             Bold property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetBold(int* pValue);
    ///Sets whether characters are bold.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are bold.</td> </tr> <tr>
    ///            <td><b>tomFalse</b></td> <td>Characters are not bold.</td> </tr> <tr> <td><b>tomToggle</b></td> <td>Toggle
    ///            the state of the Bold property.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The Bold property is
    ///            undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetBold(int Value);
    ///Gets whether characters are embossed.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are embossed.</td> </tr>
    ///             <tr> <td><b>tomFalse</b></td> <td>Characters are not embossed.</td> </tr> <tr> <td><b>tomUndefined</b></td>
    ///             <td>The Emboss property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetEmboss(int* pValue);
    ///Sets whether characters are embossed.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are embossed.</td> </tr>
    ///            <tr> <td><b>tomFalse</b></td> <td>Characters are not embossed.</td> </tr> <tr> <td><b>tomToggle</b></td>
    ///            <td>Toggle the state of the Emboss property.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The Emboss
    ///            property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetEmboss(int Value);
    ///Gets the foreground, or text, color.
    ///Params:
    ///    pValue = Type: <b>long*</b> The foreground color. It can be one of the following values. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td>A COLORREF value</td> <td>The high-order byte is zero, and the
    ///             three low-order bytes specify an RGB color. </td> </tr> <tr> <td>A value returned by PALETTEINDEX </td>
    ///             <td>The high-order byte is 1, and the LOWORD specifies the index of a logical-color palette entry.</td> </tr>
    ///             <tr> <td><b>tomAutocolor</b> (-9999997)</td> <td>Indicates that the range uses the default system foreground
    ///             color.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetForeColor(int* pValue);
    ///Sets the foreground (text) color.
    ///Params:
    ///    Value = Type: <b>long</b> The new foreground color. It can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td>A COLORREF value.</td> <td>An RGB color.</td> </tr> <tr> <td>A
    ///            value returned by PALETTEINDEX </td> <td>A palette index.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>No
    ///            change.</td> </tr> <tr> <td><b>tomAutoColor</b></td> <td>Use the default foreground color.</td> </tr>
    ///            </table> If <i>Value</i> contains an RGB color, generate the COLORREF by using the RGB macro.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetForeColor(int Value);
    ///Gets whether characters are hidden.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are hidden.</td> </tr> <tr>
    ///             <td><b>tomFalse</b></td> <td>Characters are not hidden.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The
    ///             Hidden property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetHidden(int* pValue);
    ///Sets whether characters are hidden.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are hidden.</td> </tr> <tr>
    ///            <td><b>tomFalse</b></td> <td>Characters are not hidden.</td> </tr> <tr> <td><b>tomToggle</b></td> <td>Toggle
    ///            the state of the Hidden property.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The Hidden property is
    ///            undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetHidden(int Value);
    ///Gets whether characters are displayed as imprinted characters.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are displayed as imprinted
    ///             characters.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not displayed as imprinted
    ///             characters.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The Engrave property is undefined.</td> </tr>
    ///             </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetEngrave(int* pValue);
    ///Sets whether characters are displayed as imprinted characters.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are imprinted.</td> </tr>
    ///            <tr> <td><b>tomFalse</b></td> <td>Characters are not imprinted.</td> </tr> <tr> <td><b>tomToggle</b></td>
    ///            <td>Toggle the state of the Engrave property.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The Engrave
    ///            property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetEngrave(int Value);
    ///Gets whether characters are in italics.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are in italics.</td> </tr>
    ///             <tr> <td><b>tomFalse</b></td> <td>Characters are not in italics.</td> </tr> <tr> <td><b>tomUndefined</b></td>
    ///             <td>The Italic property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetItalic(int* pValue);
    ///Sets whether characters are in italics.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are in italics.</td> </tr>
    ///            <tr> <td><b>tomFalse</b></td> <td>Characters are not in italics.</td> </tr> <tr> <td><b>tomToggle</b></td>
    ///            <td>Toggle the state of the Italic property.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The Italic
    ///            property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetItalic(int Value);
    ///Gets the minimum font size at which kerning occurs.
    ///Params:
    ///    pValue = Type: <b>float*</b> The minimum font size at which kerning occurs, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetKerning(float* pValue);
    ///Sets the minimum font size at which kerning occurs.
    ///Params:
    ///    Value = Type: <b>float</b> The new value of the minimum kerning size, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetKerning(float Value);
    ///Gets the language ID or language code identifier (LCID).
    ///Params:
    ///    pValue = Type: <b>long*</b> The language ID or LCID. The low word contains the language identifier. The high word is
    ///             either zero or it contains the high word of the LCID. To retrieve the language identifier, mask out the high
    ///             word. For more information, see Locale Identifiers.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetLanguageID(int* pValue);
    ///Sets the language ID or language code identifier (LCID).
    ///Params:
    ///    Value = Type: <b>long</b> The new language identifier. The low word contains the language identifier. The high word
    ///            is either zero or it contains the high word of the locale identifier LCID. For more information, see Locale
    ///            Identifiers.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetLanguageID(int Value);
    ///Gets the font name.
    ///Params:
    ///    pbstr = Type: <b>BSTR*</b> The font name.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Could not allocate memory for string. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is
    ///    attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetName(BSTR* pbstr);
    ///Sets the font name.
    ///Params:
    ///    bstr = Type: <b>BSTR</b> The new font name.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Name too long. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetName(BSTR bstr);
    ///Gets whether characters are displayed as outlined characters.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are displayed as outlined
    ///             characters.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not displayed as outlined
    ///             characters.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The Outline property is undefined.</td> </tr>
    ///             </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetOutline(int* pValue);
    ///Sets whether characters are displayed as outlined characters.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are outlined.</td> </tr>
    ///            <tr> <td><b>tomFalse</b></td> <td>Characters are not outlined.</td> </tr> <tr> <td><b>tomToggle</b></td>
    ///            <td>Toggle the state of the Outline property.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The Outline
    ///            property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetOutline(int Value);
    ///Gets the amount that characters are offset vertically relative to the baseline.
    ///Params:
    ///    pValue = Type: <b>float*</b> The amount of vertical offset, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetPosition(float* pValue);
    ///Sets the amount that characters are offset vertically relative to the baseline.
    ///Params:
    ///    Value = Type: <b>float</b> The new amount of vertical offset, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetPosition(float Value);
    ///Gets whether characters are protected against attempts to modify them.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are protected.</td> </tr>
    ///             <tr> <td><b>tomFalse</b></td> <td>Characters are not protected.</td> </tr> <tr> <td><b>tomUndefined</b></td>
    ///             <td>The Protected property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetProtected(int* pValue);
    ///Sets whether characters are protected against attempts to modify them.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are protected.</td> </tr>
    ///            <tr> <td><b>tomFalse</b></td> <td>Characters are not protected.</td> </tr> <tr> <td><b>tomToggle</b></td>
    ///            <td>Toggle the state of the Protected property.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The
    ///            Protected property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetProtected(int Value);
    ///Gets whether characters are displayed as shadowed characters.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are displayed as shadowed
    ///             characters.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not displayed as shadowed
    ///             characters.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The Shadow property is undefined.</td> </tr>
    ///             </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetShadow(int* pValue);
    ///Sets whether characters are displayed as shadowed characters.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are shadowed.</td> </tr>
    ///            <tr> <td><b>tomFalse</b></td> <td>Characters are not shadowed.</td> </tr> <tr> <td><b>tomToggle</b></td>
    ///            <td>Toggle the state of the Shadow property.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The Shadow
    ///            property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetShadow(int Value);
    ///Gets the font size.
    ///Params:
    ///    pValue = Type: <b>float*</b> The font size, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetSize(float* pValue);
    ///Sets the font size.
    ///Params:
    ///    Value = Type: <b>float</b> The new font size, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetSize(float Value);
    ///Gets whether characters are in small capital letters.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are in small capital
    ///             letters.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not in small capital letters.</td> </tr>
    ///             <tr> <td><b>tomUndefined</b></td> <td>The SmallCaps property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetSmallCaps(int* pValue);
    ///Sets whether characters are in small capital letters.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are in small capital
    ///            letters.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not in small capital letters.</td> </tr>
    ///            <tr> <td><b>tomToggle</b></td> <td>Toggle the state of the SmallCaps property.</td> </tr> <tr>
    ///            <td><b>tomUndefined</b></td> <td>The SmallCaps property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetSmallCaps(int Value);
    ///Gets the amount of horizontal spacing between characters.
    ///Params:
    ///    pValue = Type: <b>float*</b> The amount of horizontal spacing between characters, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetSpacing(float* pValue);
    ///Sets the amount of horizontal spacing between characters.
    ///Params:
    ///    Value = Type: <b>float</b> The new amount of horizontal spacing between characters, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetSpacing(float Value);
    ///Gets whether characters are displayed with a horizontal line through the center.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are displayed with a
    ///             horizontal line through the center.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not displayed
    ///             with a horizontal line through the center.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The StrikeThrough
    ///             property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetStrikeThrough(int* pValue);
    ///Sets whether characters are displayed with a horizontal line through the center.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters have a horizontal line
    ///            through the center.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Characters do not have a horizontal line
    ///            through the center.</td> </tr> <tr> <td><b>tomToggle</b></td> <td>Toggle the state of the StrikeThrough
    ///            property.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The StrikeThrough property is undefined.</td>
    ///            </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetStrikeThrough(int Value);
    ///Gets whether characters are displayed as subscript.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are displayed as
    ///             subscript.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not displayed as subscript.</td> </tr>
    ///             <tr> <td><b>tomUndefined</b></td> <td>The Subscript property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetSubscript(int* pValue);
    ///Sets whether characters are displayed as subscript.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are displayed as
    ///            subscript.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not displayed as subscript.</td> </tr>
    ///            <tr> <td><b>tomToggle</b></td> <td>Toggle the state of the Subscript property.</td> </tr> <tr>
    ///            <td><b>tomUndefined</b></td> <td>The Subscript property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetSubscript(int Value);
    ///Gets whether characters are displayed as superscript.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are displayed as
    ///             superscript.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not displayed as superscript.</td>
    ///             </tr> <tr> <td><b>tomUndefined</b></td> <td>The Superscript property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetSuperscript(int* pValue);
    ///Sets whether characters are displayed as superscript.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are displayed as
    ///            superscript.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not displayed as superscript.</td>
    ///            </tr> <tr> <td><b>tomToggle</b></td> <td>Toggle the state of the Superscript property.</td> </tr> <tr>
    ///            <td><b>tomUndefined</b></td> <td>The Superscript property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetSuperscript(int Value);
    ///Gets the type of underlining for the characters in a range.
    ///Params:
    ///    pValue = Type: <b>long*</b> The type of underlining. It can be one of the following values. <a id="tomNone"></a> <a
    ///             id="tomnone"></a> <a id="TOMNONE"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetUnderline(int* pValue);
    ///Sets the type of underlining for the characters in a range.
    ///Params:
    ///    Value = Type: <b>long</b> The type of underlining. It can be one of the following values. <a id="tomNone"></a> <a
    ///            id="tomnone"></a> <a id="TOMNONE"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetUnderline(int Value);
    ///Gets the font weight for the characters in a range.
    ///Params:
    ///    pValue = Type: <b>long*</b> The font weight. The Bold property is a binary version of the Weight property that sets
    ///             the weight to <b>FW_BOLD</b>. The font weight exists in the LOGFONT structure and the IFont interface.
    ///             Windows defines the following degrees of font weight. <table class="clsStd"> <tr> <th>Font weight</th>
    ///             <th>Value</th> </tr> <tr> <td><b>FW_DONTCARE</b></td> <td>0</td> </tr> <tr> <td><b>FW_THIN</b></td>
    ///             <td>100</td> </tr> <tr> <td><b>FW_EXTRALIGHT</b></td> <td>200</td> </tr> <tr> <td><b>FW_LIGHT</b></td>
    ///             <td>300</td> </tr> <tr> <td><b>FW_NORMAL</b></td> <td>400</td> </tr> <tr> <td><b>FW_MEDIUM</b></td>
    ///             <td>500</td> </tr> <tr> <td><b>FW_SEMIBOLD</b></td> <td>600</td> </tr> <tr> <td><b>FW_BOLD</b></td>
    ///             <td>700</td> </tr> <tr> <td><b>FW_EXTRABOLD</b></td> <td>800</td> </tr> <tr> <td><b>FW_HEAVY</b></td>
    ///             <td>900</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> </table>
    ///    
    HRESULT GetWeight(int* pValue);
    ///Sets the font weight for the characters in a range.
    ///Params:
    ///    Value = Type: <b>long</b> The new font weight. The Bold property is a binary version of the Weight property that sets
    ///            the weight to <b>FW_BOLD</b>. The font weight exists in the LOGFONT structure and the IFont interface.
    ///            Windows defines the following degrees of font weight. <table class="clsStd"> <tr> <th>Font weight</th>
    ///            <th>Value</th> </tr> <tr> <td><b>FW_DONTCARE</b></td> <td>0</td> </tr> <tr> <td><b>FW_THIN</b></td>
    ///            <td>100</td> </tr> <tr> <td><b>FW_EXTRALIGHT</b></td> <td>200</td> </tr> <tr> <td><b>FW_LIGHT</b></td>
    ///            <td>300</td> </tr> <tr> <td><b>FW_NORMAL</b></td> <td>400</td> </tr> <tr> <td><b>FW_MEDIUM</b></td>
    ///            <td>500</td> </tr> <tr> <td><b>FW_SEMIBOLD</b></td> <td>600</td> </tr> <tr> <td><b>FW_BOLD</b></td>
    ///            <td>700</td> </tr> <tr> <td><b>FW_EXTRABOLD</b></td> <td>800</td> </tr> <tr> <td><b>FW_HEAVY</b></td>
    ///            <td>900</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The font object is attached to a range that has
    ///    been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Write access is denied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetWeight(int Value);
}

///Text Object Model (TOM) rich text-range attributes are accessed through a pair of dual interfaces, ITextFont and
///<b>ITextPara</b>.
@GUID("8CC497C4-A1DF-11CE-8098-00AA0047BE5D")
interface ITextPara : IDispatch
{
    ///Creates a duplicate of the specified paragraph format object. The duplicate property is the default property of
    ///an ITextPara object.
    ///Params:
    ///    ppPara = Type: <b>ITextPara**</b> The duplicate ITextPara object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetDuplicate</b> succeeds, it returns <b>S_OK</b>. If the method fails,
    ///    it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Memory could not be allocated for the new object.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%">
    ///    The paragraph formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetDuplicate(ITextPara* ppPara);
    ///Sets the formatting for an existing paragraph by copying a given format.
    ///Params:
    ///    pPara = Type: <b>ITextPara*</b> The ITextPara range that contains the new paragraph formatting.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetDuplicate</b> succeeds, it returns <b>S_OK</b>. If the method fails,
    ///    it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetDuplicate(ITextPara pPara);
    ///Determines whether the paragraph formatting can be changed.
    ///Params:
    ///    pValue = Type: <b>long*</b> A variable that is <b>tomTrue</b> if the paragraph formatting can be changed or
    ///             <b>tomFalse</b> if it cannot be changed. This parameter can be null.
    ///Returns:
    ///    Type: <b>HRESULT</b> If paragraph formatting can change, <b>ITextPara::CanChange</b> succeeds and returns
    ///    <b>S_OK</b>. If paragraph formatting cannot change, the method fails and returns S_FALSE. For more
    ///    information about COM error codes, see Error Handling in COM.
    ///    
    HRESULT CanChange(int* pValue);
    ///Determines if the current range has the same properties as a specified range.
    ///Params:
    ///    pPara = Type: <b>ITextPara*</b> The ITextPara range that is compared to the current range.
    ///    pValue = Type: <b>long*</b> The comparison result. The value can be null.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the objects are equal, <b>ITextPara::IsEqual</b> succeeds and returns <b>S_OK</b>. If
    ///    the objects are not equal, the method fails and returns S_FALSE. For more information about COM error codes,
    ///    see Error Handling in COM.
    ///    
    HRESULT IsEqual(ITextPara pPara, int* pValue);
    ///Resets the paragraph formatting to a choice of default values.
    ///Params:
    ///    Value = Type: <b>long</b> Type of reset. It can be one of the following possible values. <table> <tr> <th>Value</th>
    ///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>tomDefault</dt> </dl>
    ///            </td> <td width="60%"> Used for paragraph formatting that is defined by the RTF \pard, that is, the paragraph
    ///            default control word. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///            <dt>tomUndefined</dt> </dl> </td> <td width="60%"> Used for all undefined values. The tomUndefined value is
    ///            only valid for duplicate (clone) ITextPara objects. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::Reset</b> succeeds, it returns <b>S_OK</b>. If the method fails, it
    ///    returns one of the following COM error codes. For more information about COM error codes, see Error Handling
    ///    in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT Reset(int Value);
    ///Retrieves the style handle to the paragraphs in the specified range.
    ///Params:
    ///    pValue = Type: <b>long*</b> The paragraph style handle. For more information, see the Remarks.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetStyle</b> succeeds, it returns <b>S_OK</b>. If the method fails, it
    ///    returns one of the following COM error codes. For more information about COM error codes, see Error Handling
    ///    in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetStyle(int* pValue);
    ///Sets the paragraph style for the paragraphs in a range.
    ///Params:
    ///    Value = Type: <b>long</b> New paragraph style handle. For a list of styles, see the Remarks section of
    ///            ITextPara::GetStyle.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetStyle</b> succeeds, it returns <b>S_OK</b>. If the method fails, it
    ///    returns one of the following COM error codes. For more information about COM error codes, see Error Handling
    ///    in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetStyle(int Value);
    ///Retrieves the current paragraph alignment value.
    ///Params:
    ///    pValue = Type: <b>long*</b> The paragraph alignment, which can be one of the following values. <a
    ///             id="tomAlignLeft"></a> <a id="tomalignleft"></a> <a id="TOMALIGNLEFT"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetAlignment</b> succeeds, it returns <b>S_OK</b>. If the method fails,
    ///    it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pValue</i> parameter is null. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph format
    ///    object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetAlignment(int* pValue);
    ///Sets the paragraph alignment.
    ///Params:
    ///    Value = Type: <b>long</b> New paragraph alignment. For a list of possible values, see the ITextPara::GetAlignment
    ///            method.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetAlignment</b> succeeds, it returns <b>S_OK</b>. If the method fails,
    ///    it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetAlignment(int Value);
    ///Determines whether automatic hyphenation is enabled for the range.
    ///Params:
    ///    pValue = Type: <b>long*</b> A variable that is one of the following values: <table> <tr> <th>Value</th>
    ///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomTrue"></a><a id="tomtrue"></a><a id="TOMTRUE"></a><dl>
    ///             <dt><b>tomTrue</b></dt> </dl> </td> <td width="60%"> Automatic hyphenation is enabled. </td> </tr> <tr> <td
    ///             width="40%"><a id="tomFalse"></a><a id="tomfalse"></a><a id="TOMFALSE"></a><dl> <dt><b>tomFalse</b></dt>
    ///             </dl> </td> <td width="60%"> Automatic hyphenation is disabled. </td> </tr> <tr> <td width="40%"><a
    ///             id="tomUndefined"></a><a id="tomundefined"></a><a id="TOMUNDEFINED"></a><dl> <dt><b>tomUndefined</b></dt>
    ///             </dl> </td> <td width="60%"> The hyphenation property is undefined. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetHyphenation</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetHyphenation(int* pValue);
    ///Controls hyphenation for the paragraphs in the range.
    ///Params:
    ///    Value = Type: <b>long</b> Indicates how hyphenation is controlled. It can be one of the following possible values.
    ///            <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///            <dt>tomTrue</dt> </dl> </td> <td width="60%"> Automatic hyphenation is enabled. </td> </tr> <tr> <td
    ///            width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>tomFalse</dt> </dl> </td> <td width="60%"> Automatic
    ///            hyphenation is disabled. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///            <dt>tomUndefined</dt> </dl> </td> <td width="60%"> The hyphenation property is undefined. </td> </tr>
    ///            </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetHyphenation</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetHyphenation(int Value);
    ///Retrieves the amount used to indent the first line of a paragraph relative to the left indent. The left indent is
    ///the indent for all lines of the paragraph except the first line.
    ///Params:
    ///    pValue = Type: <b>float*</b> The first-line indentation amount in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetFirstLineIndent</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetFirstLineIndent(float* pValue);
    ///Determines whether page breaks are allowed within paragraphs.
    ///Params:
    ///    pValue = Type: <b>long*</b> A variable that is one of the following values. <table> <tr> <th>Value</th>
    ///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomTrue"></a><a id="tomtrue"></a><a id="TOMTRUE"></a><dl>
    ///             <dt><b>tomTrue</b></dt> </dl> </td> <td width="60%"> Page breaks are not allowed within a paragraph. </td>
    ///             </tr> <tr> <td width="40%"><a id="tomFalse"></a><a id="tomfalse"></a><a id="TOMFALSE"></a><dl>
    ///             <dt><b>tomFalse</b></dt> </dl> </td> <td width="60%"> Page breaks are allowed within a paragraph. </td> </tr>
    ///             <tr> <td width="40%"><a id="tomUndefined"></a><a id="tomundefined"></a><a id="TOMUNDEFINED"></a><dl>
    ///             <dt><b>tomUndefined</b></dt> </dl> </td> <td width="60%"> The property is undefined. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetKeepTogether</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetKeepTogether(int* pValue);
    ///Controls whether page breaks are allowed within a paragraph in a range.
    ///Params:
    ///    Value = Type: <b>long</b> Indicates whether page breaks are allowed within a paragraph in a range. It can be one of
    ///            the following possible values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///            id=""></a><dl> <dt><b></b></dt> <dt>tomTrue</dt> </dl> </td> <td width="60%"> Page breaks are not allowed
    ///            within a paragraph. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>tomFalse</dt>
    ///            </dl> </td> <td width="60%"> Page breaks are allowed within a paragraph. </td> </tr> <tr> <td width="40%"><a
    ///            id=""></a><dl> <dt><b></b></dt> <dt>tomUndefined</dt> </dl> </td> <td width="60%"> The property is undefined.
    ///            </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetKeepTogether</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetKeepTogether(int Value);
    ///Determines whether page breaks are allowed between paragraphs in the range.
    ///Params:
    ///    pValue = Type: <b>long*</b> A variable that is one of the following values: <table> <tr> <th>Value</th>
    ///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomTrue"></a><a id="tomtrue"></a><a id="TOMTRUE"></a><dl>
    ///             <dt><b>tomTrue</b></dt> </dl> </td> <td width="60%"> Page breaks are not allowed between paragraphs. </td>
    ///             </tr> <tr> <td width="40%"><a id="tomFalse"></a><a id="tomfalse"></a><a id="TOMFALSE"></a><dl>
    ///             <dt><b>tomFalse</b></dt> </dl> </td> <td width="60%"> Page breaks are allowed between paragraphs. </td> </tr>
    ///             <tr> <td width="40%"><a id="tomUndefined"></a><a id="tomundefined"></a><a id="TOMUNDEFINED"></a><dl>
    ///             <dt><b>tomUndefined</b></dt> </dl> </td> <td width="60%"> The property is undefined. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetKeepWithNext</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetKeepWithNext(int* pValue);
    ///Controls whether page breaks are allowed between the paragraphs in a range.
    ///Params:
    ///    Value = Type: <b>long</b> Indicates if page breaks can be used between the paragraphs of a range. It can be one of
    ///            the following possible values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///            id=""></a><dl> <dt><b></b></dt> <dt>tomTrue</dt> </dl> </td> <td width="60%"> Page breaks are not allowed
    ///            between paragraphs. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>tomFalse</dt>
    ///            </dl> </td> <td width="60%"> Page breaks are allowed between paragraphs. </td> </tr> <tr> <td width="40%"><a
    ///            id=""></a><dl> <dt><b></b></dt> <dt>tomUndefined</dt> </dl> </td> <td width="60%"> The property is undefined.
    ///            </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetKeepWithNext</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetKeepWithNext(int Value);
    ///Retrieves the distance used to indent all lines except the first line of a paragraph. The distance is relative to
    ///the left margin.
    ///Params:
    ///    pValue = Type: <b>float*</b> The left indentation, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetLeftIndent</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetLeftIndent(float* pValue);
    ///Retrieves the line-spacing value for the text range.
    ///Params:
    ///    pValue = Type: <b>float*</b> The line-spacing value. The following table shows how this value is interpreted for the
    ///             different line-spacing rules. <table class="clsStd"> <tr> <th>Line spacing rule</th> <th>Meaning</th> </tr>
    ///             <tr> <td>tomLineSpaceSingle</td> <td>The line-spacing value is ignored. </td> </tr> <tr>
    ///             <td>tomLineSpace1pt5</td> <td>The line-spacing value is ignored. </td> </tr> <tr> <td>tomLineSpaceDouble</td>
    ///             <td>The line-spacing value is ignored. </td> </tr> <tr> <td>tomLineSpaceAtLeast</td> <td>The line-spacing
    ///             value specifies the spacing, in floating-point points, from one line to the next. However, if the value is
    ///             less than single spacing, the control displays single-spaced text.</td> </tr> <tr>
    ///             <td>tomLineSpaceExactly</td> <td>The line-spacing value specifies the exact spacing, in floating-point
    ///             points, from one line to the next (even if the value is less than single spacing).</td> </tr> <tr>
    ///             <td>tomLineSpaceMultiple</td> <td>The line-spacing value specifies the line spacing, in lines.</td> </tr>
    ///             </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetLineSpacing</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetLineSpacing(float* pValue);
    ///Retrieves the line-spacing rule for the text range.
    ///Params:
    ///    pValue = Type: <b>long*</b> A variable that is one of the following values to indicate the line-spacing rule. <a
    ///             id="tomLineSpaceSingle"></a> <a id="tomlinespacesingle"></a> <a id="TOMLINESPACESINGLE"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetLineSpacingRule</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetLineSpacingRule(int* pValue);
    ///Retrieves the kind of alignment to use for bulleted and numbered lists.
    ///Params:
    ///    pValue = Type: <b>long*</b> A variable that is one of the following values to indicate the kind of bullet and
    ///             numbering alignment. <table class="clsStd"> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///             <td>tomAlignLeft</td> <td>Text is left aligned.</td> </tr> <tr> <td>tomAlignCenter</td> <td>Text is centered
    ///             in the line.</td> </tr> <tr> <td>tomAlignRight</td> <td>Text is right aligned.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetListAlignment</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetListAlignment(int* pValue);
    ///Sets the alignment of bulleted or numbered text used for paragraphs.
    ///Params:
    ///    Value = Type: <b>long</b> New list alignment value. For possible values, see ITextPara::GetListAlignment.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetListAlignment</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetListAlignment(int Value);
    ///Retrieves the list level index used with paragraphs.
    ///Params:
    ///    pValue = Type: <b>long*</b> A variable that is the list level index. The value of <i>pValue</i> can be one of the
    ///             following. <table class="clsStd"> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td>0</td> <td>No
    ///             list.</td> </tr> <tr> <td>1</td> <td>First-level (outermost) list.</td> </tr> <tr> <td>2</td>
    ///             <td>Second-level (nested) list. This is nested under a level 1 list item.</td> </tr> <tr> <td>3</td>
    ///             <td>Third-level (nested) list. This is nested under a level 2 list item.</td> </tr> <tr> <td>and so
    ///             forth</td> <td>Nesting continues similarly.</td> </tr> </table> Up to three levels are common in HTML
    ///             documents.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetListLevelIndex</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetListLevelIndex(int* pValue);
    ///Sets the list level index used for paragraphs.
    ///Params:
    ///    Value = Type: <b>long</b> New list level index value. For possible values, see ITextPara::GetListLevelIndex.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetListLevelIndex</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetListLevelIndex(int Value);
    ///Retrieves the starting value or code of a list numbering sequence.
    ///Params:
    ///    pValue = Type: <b>long*</b> The starting value or code of a list numbering sequence. For the possible values, see the
    ///             ITextPara::GetListType method.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetListStart</b> succeeds, it returns <b>S_OK</b>. If the method fails,
    ///    it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetListStart(int* pValue);
    ///Sets the starting number or Unicode value for a numbered list.
    ///Params:
    ///    Value = Type: <b>long</b> New starting number or Unicode value for a numbered list.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetListStart</b> succeeds, it returns <b>S_OK</b>. If the method fails,
    ///    it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetListStart(int Value);
    ///Retrieves the list tab setting, which is the distance between the first-line indent and the text on the first
    ///line. The numbered or bulleted text is left-justified, centered, or right-justified at the first-line indent
    ///value.
    ///Params:
    ///    pValue = Type: <b>float*</b> The list tab setting. The list tab value is in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetListTab</b> succeeds, it returns <b>S_OK</b>. If the method fails,
    ///    it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetListTab(float* pValue);
    ///Sets the list tab setting, which is the distance between the first indent and the start of the text on the first
    ///line.
    ///Params:
    ///    Value = Type: <b>float</b> New list tab value, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetListTab</b> succeeds, it returns <b>S_OK</b>. If the method fails,
    ///    it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetListTab(float Value);
    ///Retrieves the kind of numbering to use with paragraphs.
    ///Params:
    ///    pValue = Type: <b>long*</b> A variable that is of the following values to indicate the kind of list numbering. <a
    ///             id="tomListNone"></a> <a id="tomlistnone"></a> <a id="TOMLISTNONE"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetListType</b> succeeds, it returns <b>S_OK</b>. If the method fails,
    ///    it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetListType(int* pValue);
    ///Sets the type of list to be used for paragraphs.
    ///Params:
    ///    Value = Type: <b>long</b> New list type. For possible list types, see the ITextPara::GetListType method.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetListType</b> succeeds, it returns <b>S_OK</b>. If the method fails,
    ///    it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetListType(int Value);
    ///Determines whether paragraph numbering is enabled.
    ///Params:
    ///    pValue = Type: <b>long*</b> A variable that is one of the following values: <table class="clsStd"> <tr> <th>Value</th>
    ///             <th>Meaning</th> </tr> <tr> <td>tomTrue</td> <td>Line numbering is disabled.</td> </tr> <tr>
    ///             <td>tomFalse</td> <td>Line numbering is enabled.</td> </tr> <tr> <td>tomUndefined</td> <td>The property is
    ///             undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetNoLineNumber</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetNoLineNumber(int* pValue);
    ///Determines whether to suppress line numbering of paragraphs in a range.
    ///Params:
    ///    Value = Type: <b>long</b> Indicates if line numbering is suppressed. It can be one of the following possible values.
    ///            <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt>
    ///            <dt>tomTrue</dt> </dl> </td> <td width="60%"> Line numbering is disabled. </td> </tr> <tr> <td width="40%"><a
    ///            id=""></a><dl> <dt><b></b></dt> <dt>tomFalse</dt> </dl> </td> <td width="60%"> Line numbering is enabled.
    ///            </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>tomUndefined</dt> </dl> </td> <td
    ///            width="60%"> The property is undefined. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetNoLineNumber</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetNoLineNumber(int Value);
    ///Determines whether each paragraph in the range must begin on a new page.
    ///Params:
    ///    pValue = Type: <b>long*</b> A variable that is one of the following values: <table class="clsStd"> <tr> <th>Value</th>
    ///             <th>Meaning</th> </tr> <tr> <td>tomTrue</td> <td>Each paragraph in this range must begin on a new page.</td>
    ///             </tr> <tr> <td>tomFalse</td> <td>The paragraphs in this range do not need to begin on a new page.</td> </tr>
    ///             <tr> <td>tomUndefined</td> <td>The property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetPageBreakBefore</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetPageBreakBefore(int* pValue);
    ///Controls whether there is a page break before each paragraph in a range.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that controls page breaks before paragraphs. It can be one of the following
    ///            values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>tomTrue</b></dt>
    ///            </dl> </td> <td width="60%"> Paragraphs in this range must begin on a new page. </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt><b>tomFalse</b></dt> </dl> </td> <td width="60%"> Paragraphs in this range do not need
    ///            to begin on a new page. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>tomToggle</b></dt> </dl> </td> <td
    ///            width="60%"> Toggle the property value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>tomUndefined</b></dt>
    ///            </dl> </td> <td width="60%"> The property is undefined. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetPageBreakBefore</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetPageBreakBefore(int Value);
    ///Retrieves the size of the right margin indent of a paragraph.
    ///Params:
    ///    pValue = Type: <b>float*</b> The right indentation, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetRightIndent</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetRightIndent(float* pValue);
    ///Sets the right margin of paragraph.
    ///Params:
    ///    Value = Type: <b>float</b> Right indent, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetRightIndent</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetRightIndent(float Value);
    ///Sets the first-line indent, the left indent, and the right indent for a paragraph.
    ///Params:
    ///    First = Type: <b>float</b> Indent of the first line in a paragraph, relative to the left indent. The value is in
    ///            floating-point points and can be positive or negative.
    ///    Left = Type: <b>float</b> Left indent of all lines except the first line in a paragraph, relative to left margin.
    ///           The value is in floating-point points and can be positive or negative.
    ///    Right = Type: <b>float</b> Right indent of all lines in paragraph, relative to the right margin. The value is in
    ///            floating-point points and can be positive or negative. This value is optional.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetIndents</b> succeeds, it returns <b>S_OK</b>. If the method fails,
    ///    it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetIndents(float First, float Left, float Right);
    ///Sets the paragraph line-spacing rule and the line spacing for a paragraph.
    ///Params:
    ///    Rule = Type: <b>long</b> Value of new line-spacing rule. For a list of possible rule values and further discussion,
    ///           see the ITextPara::GetLineSpacingRule method.
    ///    Spacing = Type: <b>float</b> Value of new line spacing. If the line-spacing rule treats the <i>Spacing</i> value as a
    ///              linear dimension, then <i>Spacing</i> is given in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetLineSpacing</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetLineSpacing(int Rule, float Spacing);
    ///Retrieves the amount of vertical space below a paragraph.
    ///Params:
    ///    pValue = Type: <b>float*</b> The space-after value, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetSpaceAfter</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetSpaceAfter(float* pValue);
    ///Sets the amount of space that follows a paragraph.
    ///Params:
    ///    Value = Type: <b>float</b> New space-after value, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetSpaceAfter</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetSpaceAfter(float Value);
    ///Retrieves the amount of vertical space above a paragraph.
    ///Params:
    ///    pValue = Type: <b>float*</b> The space-before value, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetSpaceBefore</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetSpaceBefore(float* pValue);
    ///Sets the amount of space preceding a paragraph.
    ///Params:
    ///    Value = Type: <b>float</b> New space-before value, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetSpaceBefore</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetSpaceBefore(float Value);
    ///Retrieves the widow and orphan control state for the paragraphs in a range.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that indicates the state of widow and orphan control. It can be one of the
    ///             following values. <table class="clsStd"> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///             <td><b>tomTrue</b></td> <td>Prevents the printing of a widow or orphan</td> </tr> <tr>
    ///             <td><b>tomFalse</b></td> <td>Allows the printing of a widow or orphan.</td> </tr> <tr>
    ///             <td><b>tomUndefined</b></td> <td>The widow-control property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetWidowControl</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetWidowControl(int* pValue);
    ///Controls the suppression of widows and orphans.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that controls the suppression of widows and orphans. It can be one of the
    ///            following possible values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///            id=""></a><dl> <dt><b></b></dt> <dt>tomTrue</dt> </dl> </td> <td width="60%"> Prevents printing of widows and
    ///            orphans. </td> </tr> <tr> <td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>tomFalse</dt> </dl> </td>
    ///            <td width="60%"> Allows printing of widows and orphans. </td> </tr> <tr> <td width="40%"><a id=""></a><dl>
    ///            <dt><b></b></dt> <dt>tomToggle</dt> </dl> </td> <td width="60%"> The value is toggled. </td> </tr> <tr> <td
    ///            width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt>tomUndefined</dt> </dl> </td> <td width="60%"> No change.
    ///            </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::SetWidowControl</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph
    ///    formatting object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT SetWidowControl(int Value);
    ///Retrieves the tab count.
    ///Params:
    ///    pCount = Type: <b>long*</b> The tab count.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetTabCount</b> succeeds, it returns <b>S_OK</b>. If the method fails,
    ///    it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT GetTabCount(int* pCount);
    ///Adds a tab at the displacement <i>tbPos</i>, with type <i>tbAlign</i>, and leader style, <i>tbLeader</i>.
    ///Params:
    ///    tbPos = Type: <b>float</b> New tab displacement, in floating-point points.
    ///    tbAlign = Type: <b>long</b> Alignment options for the tab position. It can be one of the following. <table> <tr>
    ///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomAlignLeft"></a><a
    ///              id="tomalignleft"></a><a id="TOMALIGNLEFT"></a><dl> <dt><b>tomAlignLeft</b></dt> </dl> </td> <td width="60%">
    ///              Text is left justified from the tab position. This is the default. </td> </tr> <tr> <td width="40%"><a
    ///              id="tomAlignCenter"></a><a id="tomaligncenter"></a><a id="TOMALIGNCENTER"></a><dl>
    ///              <dt><b>tomAlignCenter</b></dt> </dl> </td> <td width="60%"> Text is centered on the tab position. </td> </tr>
    ///              <tr> <td width="40%"><a id="tomAlignRight"></a><a id="tomalignright"></a><a id="TOMALIGNRIGHT"></a><dl>
    ///              <dt><b>tomAlignRight</b></dt> </dl> </td> <td width="60%"> Text is right justified from the tab position.
    ///              </td> </tr> <tr> <td width="40%"><a id="tomAlignDecimal"></a><a id="tomaligndecimal"></a><a
    ///              id="TOMALIGNDECIMAL"></a><dl> <dt><b>tomAlignDecimal</b></dt> </dl> </td> <td width="60%"> The decimal point
    ///              is set at the tab position. This is useful for aligning a column of decimal numbers. </td> </tr> <tr> <td
    ///              width="40%"><a id="tomAlignBar"></a><a id="tomalignbar"></a><a id="TOMALIGNBAR"></a><dl>
    ///              <dt><b>tomAlignBar</b></dt> </dl> </td> <td width="60%"> A vertical bar is positioned at the tab position.
    ///              Text is not affected. Alignment bars on nearby lines at the same position form a continuous vertical line.
    ///              </td> </tr> </table>
    ///    tbLeader = Type: <b>long</b> Leader character style. A leader character is the character that is used to fill the space
    ///               taken by a tab character. It can be one of the following. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///               <tr> <td width="40%"><a id="tomSpaces"></a><a id="tomspaces"></a><a id="TOMSPACES"></a><dl>
    ///               <dt><b>tomSpaces</b></dt> </dl> </td> <td width="60%"> Spaces are used. This is the default. </td> </tr> <tr>
    ///               <td width="40%"><a id="tomDots"></a><a id="tomdots"></a><a id="TOMDOTS"></a><dl> <dt><b>tomDots</b></dt>
    ///               </dl> </td> <td width="60%"> Dots are used. </td> </tr> <tr> <td width="40%"><a id="tomDashes"></a><a
    ///               id="tomdashes"></a><a id="TOMDASHES"></a><dl> <dt><b>tomDashes</b></dt> </dl> </td> <td width="60%"> A dashed
    ///               line is used. </td> </tr> <tr> <td width="40%"><a id="tomLines"></a><a id="tomlines"></a><a
    ///               id="TOMLINES"></a><dl> <dt><b>tomLines</b></dt> </dl> </td> <td width="60%"> A solid line is used. </td>
    ///               </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::AddTab</b> succeeds, it returns <b>S_OK</b>. If the method fails, it
    ///    returns one of the following COM error codes. For more information about COM error codes, see Error Handling
    ///    in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph format
    ///    object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT AddTab(float tbPos, int tbAlign, int tbLeader);
    ///Clears all tabs, reverting to equally spaced tabs with the default tab spacing.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::ClearAllTabs</b> succeeds, it returns <b>S_OK</b>. If the method fails,
    ///    it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph format
    ///    object is attached to a range that has been deleted. </td> </tr> </table>
    ///    
    HRESULT ClearAllTabs();
    ///Deletes a tab at a specified displacement.
    ///Params:
    ///    tbPos = Type: <b>float</b> Displacement, in floating-point points, at which a tab should be deleted.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::DeleteTab</b> succeeds, it returns <b>S_OK</b>. If the method fails, it
    ///    returns one of the following COM error codes. For more information about COM error codes, see Error Handling
    ///    in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>tbPos</i> value is less
    ///    than or equal to zero. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_RELEASED</b></dt> </dl>
    ///    </td> <td width="60%"> The paragraph format object is attached to a range that has been deleted. </td> </tr>
    ///    </table>
    ///    
    HRESULT DeleteTab(float tbPos);
    ///Retrieves tab parameters (displacement, alignment, and leader style) for a specified tab.
    ///Params:
    ///    iTab = Type: <b>long</b> Index of tab for which to retrieve info. It can be either a numerical index or a special
    ///           value (see the following table). Since tab indexes are zero-based, <i>iTab</i> = zero gets the first tab
    ///           defined, <i>iTab</i> = 1 gets the second tab defined, and so forth. The following table summarizes all of the
    ///           possible values of <i>iTab</i>. <table class="clsStd"> <tr> <th><i>iTab</i></th> <th>Value</th>
    ///           <th>Meaning</th> </tr> <tr> <td>tomTabBack</td> <td>–3</td> <td>Get tab previous to * <i>ptbPos</i></td>
    ///           </tr> <tr> <td>tomTabNext</td> <td>–2</td> <td>Get tab following * <i>ptbPos</i></td> </tr> <tr>
    ///           <td>tomTabHere </td> <td>–1</td> <td>Get tab at * <i>ptbPos</i></td> </tr> <tr> <td></td> <td>&gt;= 0</td>
    ///           <td>Get tab with index of <i>iTab</i> (and ignore <i>ptbPos</i>).</td> </tr> </table>
    ///    ptbPos = Type: <b>float*</b> The tab displacement, in floating-point points. The value of * <i>ptbPos</i> is zero if
    ///             the tab does not exist and the value of * <i>ptbPos</i> is tomUndefined if there are multiple values in the
    ///             associated range.
    ///    ptbAlign = Type: <b>long*</b> The tab alignment. For more information, see ITextPara::AddTab.
    ///    ptbLeader = Type: <b>long*</b> The tab leader-character style. For more information, see ITextPara::AddTab.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara::GetTab</b> succeeds, it returns <b>S_OK</b>. If the method fails, it
    ///    returns one of the following COM error codes. For more information about COM error codes, see Error Handling
    ///    in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>Value</b></dt> </dl> </td> <td width="60%"> Meaning </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_RELEASED</b></dt> </dl> </td> <td width="60%"> The paragraph formatting object is attached
    ///    to a range that has been deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td>
    ///    <td width="60%"> There is no tab corresponding to iTab. </td> </tr> </table>
    ///    
    HRESULT GetTab(int iTab, float* ptbPos, int* ptbAlign, int* ptbLeader);
}

///The purpose of the <b>ITextStoryRanges</b> interface is to enumerate the stories in an ITextDocument.
@GUID("8CC497C5-A1DF-11CE-8098-00AA0047BE5D")
interface ITextStoryRanges : IDispatch
{
    ///Retrieves an <b>IEnumVARIANT</b> enumerator interface for this collection of stories.
    ///Params:
    ///    ppunkEnum = Type: <b>IUnknown**</b> The pointer to the enumerator interface.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> <i>ppunkEnum</i> is null. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure for some other reason. </td> </tr> </table>
    ///    
    HRESULT _NewEnum(IUnknown* ppunkEnum);
    ///Retrieves an ITextRange object for the <i>Index</i>th story in this story collection.
    ///Params:
    ///    Index = Type: <b>LONG</b> Index of story range that is retrieved. The default value is 1, which indicates the first
    ///            story in the collection. <i>Count</i>, given by ITextStoryRanges::GetCount, indicates the last story in the
    ///            collection. If <i>Index</i> is less than zero, the stories are counted from last to first, with -1 being the
    ///            index of the last story in the collection, and <i>Index</i> = - <i>Count</i> indicating the first story in
    ///            the collection.
    ///    ppRange = Type: <b>ITextRange**</b> The ITextRange object.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method returns an <b>HRESULT</b> value. If the method succeeds, it returns
    ///    <b>S_OK</b>. If the method fails, it returns one of the following error codes. For more information about COM
    ///    error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> ppRange is null or Index is out
    ///    of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure
    ///    for some other reason. </td> </tr> </table>
    ///    
    HRESULT Item(int Index, ITextRange* ppRange);
    ///Retrieves the number of stories in the specified stories collection.
    ///Params:
    ///    pCount = Type: <b>long*</b> The count of stories.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns <b>S_OK</b>.
    ///    
    HRESULT GetCount(int* pCount);
}

///Extends the ITextDocument interface, adding methods that enable the Input Method Editor (IME) to drive the rich edit
///control, and methods to retrieve other interfaces such as ITextDisplays, ITextRange2, ITextFont2, ITextPara2, and so
///on. Some <b>ITextDocument2</b> methods used with the IME need access to the current window handle (<b>HWND</b>). Use
///the ITextDocument2::GetWindow method to retrieve the handle.
@GUID("C241F5E0-7206-11D8-A2C7-00A0D1D6C6B3")
interface ITextDocument2 : ITextDocument
{
    ///Gets the caret type.
    ///Params:
    ///    pValue = Type: <b>long*</b> The caret type. It can be one of the following values: <a id="tomKoreanBlockCaret"></a> <a
    ///             id="tomkoreanblockcaret"></a> <a id="TOMKOREANBLOCKCARET"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCaretType(int* pValue);
    ///Sets the caret type.
    ///Params:
    ///    Value = Type: <b>long</b> The new caret type. It can be one of the following values: <a id="tomKoreanBlockCaret"></a>
    ///            <a id="tomkoreanblockcaret"></a> <a id="TOMKOREANBLOCKCARET"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCaretType(int Value);
    ///Gets the displays collection for this Text Object Model (TOM) engine instance.
    ///Params:
    ///    ppDisplays = Type: <b>ITextDisplays**</b> The displays collection.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetDisplays(ITextDisplays* ppDisplays);
    ///Gets an object that provides the default character format information for this instance of the Text Object Model
    ///(TOM) engine.
    ///Params:
    ///    ppFont = Type: <b>ITextFont2**</b> The object that provides the default character format information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetDocumentFont(ITextFont2* ppFont);
    ///Sets the default character formatting for this instance of the Text Object Model (TOM) engine.
    ///Params:
    ///    pFont = Type: <b>ITextFont2*</b> The font object that provides the default character formatting.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetDocumentFont(ITextFont2 pFont);
    ///Gets an object that provides the default paragraph format information for this instance of the Text Object Model
    ///(TOM) engine.
    ///Params:
    ///    ppPara = Type: <b>ITextPara2**</b> The object that provides the default paragraph format information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetDocumentPara(ITextPara2* ppPara);
    ///Sets the default paragraph formatting for this instance of the Text Object Model (TOM) engine.
    ///Params:
    ///    pPara = Type: <b>ITextPara2*</b> The paragraph object that provides the default paragraph formatting
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetDocumentPara(ITextPara2 pPara);
    ///Gets the East Asian flags.
    ///Params:
    ///    pFlags = Type: <b>long*</b> The East Asian flags. This parameter can be a combination of the following values. <table>
    ///             <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomRE10Mode"></a><a
    ///             id="tomre10mode"></a><a id="TOMRE10MODE"></a><dl> <dt><b>tomRE10Mode</b></dt> </dl> </td> <td width="60%">
    ///             TOM version 1.0 emulation mode. </td> </tr> <tr> <td width="40%"><a id="tomUseAtFont"></a><a
    ///             id="tomuseatfont"></a><a id="TOMUSEATFONT"></a><dl> <dt><b>tomUseAtFont</b></dt> </dl> </td> <td width="60%">
    ///             Use @ fonts for CJK vertical text. </td> </tr> <tr> <td width="40%"><a id="tomTextFlowMask"></a><a
    ///             id="tomtextflowmask"></a><a id="TOMTEXTFLOWMASK"></a><dl> <dt><b>tomTextFlowMask</b></dt> </dl> </td> <td
    ///             width="60%"> A mask for the following four text orientations: <dl> <dt><b>tomTextFlowES</b></dt> <dd>
    ///             Ordinary left-to-right horizontal text. </dd> <dt><b>tomTextFlowSW</b></dt> <dd> Ordinary East Asian vertical
    ///             text. </dd> <dt><b>tomTextFlowWN</b></dt> <dd> An alternative orientation. </dd>
    ///             <dt><b>tomTextFlowNE</b></dt> <dd> An alternative orientation. </dd> </dl> </td> </tr> <tr> <td
    ///             width="40%"><a id="tomUsePassword"></a><a id="tomusepassword"></a><a id="TOMUSEPASSWORD"></a><dl>
    ///             <dt><b>tomUsePassword</b></dt> </dl> </td> <td width="60%"> Use password control. </td> </tr> <tr> <td
    ///             width="40%"><a id="tomNoIME"></a><a id="tomnoime"></a><a id="TOMNOIME"></a><dl> <dt><b>tomNoIME</b></dt>
    ///             </dl> </td> <td width="60%"> Turn off IME operation (see ES_NOIME). </td> </tr> <tr> <td width="40%"><a
    ///             id="tomSelfIME"></a><a id="tomselfime"></a><a id="TOMSELFIME"></a><dl> <dt><b>tomSelfIME</b></dt> </dl> </td>
    ///             <td width="60%"> The rich edit host handles IME operation (see ES_SELFIME) . </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetEastAsianFlags(int* pFlags);
    ///Gets the name of the Text Object Model (TOM) engine.
    ///Params:
    ///    pbstr = Type: <b>BSTR*</b> The name of the TOM engine.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetGenerator(BSTR* pbstr);
    ///Sets the state of the Input Method Editor (IME) in-progress flag.
    ///Params:
    ///    Value = Type: <b>long</b> Use <b>tomTrue</b> to turn on the IME in-progress flag, or <b>tomFalse</b> to turn it off.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetIMEInProgress(int Value);
    ///Gets the notification mode.
    ///Params:
    ///    pValue = Type: <b>long*</b> The notification mode. This parameter is set to <b>tomTrue</b> if notifications are
    ///             active, or <b>tomFalse</b> if not.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetNotificationMode(int* pValue);
    ///Sets the notification mode.
    ///Params:
    ///    Value = Type: <b>long</b> The notification mode. Use <b>tomTrue</b> to turn on notifications, or <b>tomFalse</b> to
    ///            turn them off.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetNotificationMode(int Value);
    ///Gets the active selection.
    ///Params:
    ///    ppSel = Type: <b>ITextSelection2**</b> The active selection. This parameter is <b>NULL</b> if the rich edit control
    ///            is not in-place active.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetSelection2(ITextSelection2* ppSel);
    ///Gets an object for enumerating the stories in a document.
    ///Params:
    ///    ppStories = Type: <b>ITextStoryRanges2**</b> The object for enumerating stories.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetStoryRanges2(ITextStoryRanges2* ppStories);
    ///Gets the typography options.
    ///Params:
    ///    pOptions = Type: <b>long*</b> A combination of the following typography options. <table> <tr> <th>Value</th>
    ///               <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TO_ADVANCEDTYPOGRAPHY"></a><a
    ///               id="to_advancedtypography"></a><dl> <dt><b>TO_ADVANCEDTYPOGRAPHY</b></dt> </dl> </td> <td width="60%">
    ///               Advanced typography (special line breaking and line formatting) is turned on. </td> </tr> <tr> <td
    ///               width="40%"><a id="TO_SIMPLELINEBREAK"></a><a id="to_simplelinebreak"></a><dl>
    ///               <dt><b>TO_SIMPLELINEBREAK</b></dt> </dl> </td> <td width="60%"> Normal line breaking and formatting is used.
    ///               </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetTypographyOptions(int* pOptions);
    ///Gets the version number of the Text Object Model (TOM) engine.
    ///Params:
    ///    pValue = Type: <b>long*</b> The version number. Byte 3 gives the major version number, byte 2 the minor version
    ///             number, and the low-order 16 bits give the build number.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetVersion(int* pValue);
    ///Gets the handle of the window that the Text Object Model (TOM) engine is using to display output.
    ///Params:
    ///    pHwnd = Type: <b>__int64*</b> The handle of the window that the TOM engine is using.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetWindow(long* pHwnd);
    ///Attaches a new message filter to the edit instance. All window messages that the edit instance receives are
    ///forwarded to the message filter.
    ///Params:
    ///    pFilter = Type: <b>IUnknown*</b> The message filter.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT AttachMsgFilter(IUnknown pFilter);
    ///Checks whether the number of characters to be added would exceed the maximum text limit.
    ///Params:
    ///    cch = Type: <b>long</b> The number of characters to be added.
    ///    pcch = Type: <b>long*</b> The number of characters that exceed the maximum text limit. This parameter is 0 if the
    ///           number of characters does not exceed the limit.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT CheckTextLimit(int cch, int* pcch);
    ///Gets the call manager.
    ///Params:
    ///    ppVoid = Type: <b>IUnknown**</b> The call manager object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCallManager(IUnknown* ppVoid);
    ///Retrieves the client rectangle of the rich edit control.
    ///Params:
    ///    Type = Type: <b>long</b> The client rectangle retrieval options. It can be a combination of the following values.
    ///           <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomClientCoord"></a><a
    ///           id="tomclientcoord"></a><a id="TOMCLIENTCOORD"></a><dl> <dt><b>tomClientCoord</b></dt> </dl> </td> <td
    ///           width="60%"> Retrieve the rectangle in client coordinates. If this value isn't specified, the function
    ///           retrieves screen coordinates. </td> </tr> <tr> <td width="40%"><a id="tomIncludeInset"></a><a
    ///           id="tomincludeinset"></a><a id="TOMINCLUDEINSET"></a><dl> <dt><b>tomIncludeInset</b></dt> </dl> </td> <td
    ///           width="60%"> Add left and top insets to the left and top coordinates of the client rectangle, and subtract
    ///           right and bottom insets from the right and bottom coordinates. </td> </tr> <tr> <td width="40%"><a
    ///           id="tomTransform"></a><a id="tomtransform"></a><a id="TOMTRANSFORM"></a><dl> <dt><b>tomTransform</b></dt>
    ///           </dl> </td> <td width="60%"> Use a world transform (XFORM) provided by the host application to transform the
    ///           retrieved rectangle coordinates. </td> </tr> </table>
    ///    pLeft = Type: <b>long*</b> The x-coordinate of the upper-left corner of the rectangle.
    ///    pTop = Type: <b>long*</b> The y-coordinate of the upper-left corner of the rectangle.
    ///    pRight = Type: <b>long*</b> The x-coordinate of the lower-right corner of the rectangle.
    ///    pBottom = Type: <b>long*</b> The y-coordinate of the lower-right corner of the rectangle.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetClientRect(int Type, int* pLeft, int* pTop, int* pRight, int* pBottom);
    ///Retrieves the color used for special text attributes.
    ///Params:
    ///    Index = Type: <b>long</b> The index of the color to retrieve. It can be one of the following values. <table> <tr>
    ///            <th>Index</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Text
    ///            color. </td> </tr> <tr> <td width="40%"> <dl> <dt>1</dt> </dl> </td> <td width="60%"> RGB(0, 0, 0) </td>
    ///            </tr> <tr> <td width="40%"> <dl> <dt>2</dt> </dl> </td> <td width="60%"> RGB(0, 0, 255) </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>3</dt> </dl> </td> <td width="60%"> RGB(0, 255, 255) </td> </tr> <tr> <td width="40%">
    ///            <dl> <dt>4</dt> </dl> </td> <td width="60%"> RGB(0, 255, 0) </td> </tr> <tr> <td width="40%"> <dl> <dt>5</dt>
    ///            </dl> </td> <td width="60%"> RGB(255, 0, 255) </td> </tr> <tr> <td width="40%"> <dl> <dt>6</dt> </dl> </td>
    ///            <td width="60%"> RGB(255, 0, 0) </td> </tr> <tr> <td width="40%"> <dl> <dt>7</dt> </dl> </td> <td
    ///            width="60%"> RGB(255, 255, 0) </td> </tr> <tr> <td width="40%"> <dl> <dt>8</dt> </dl> </td> <td width="60%">
    ///            RGB(255, 255, 255) </td> </tr> <tr> <td width="40%"> <dl> <dt>9</dt> </dl> </td> <td width="60%"> RGB(0, 0,
    ///            128) </td> </tr> <tr> <td width="40%"> <dl> <dt>10</dt> </dl> </td> <td width="60%"> RGB(0, 128, 128) </td>
    ///            </tr> <tr> <td width="40%"> <dl> <dt>11</dt> </dl> </td> <td width="60%"> RGB(0, 128, 0) </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>12</dt> </dl> </td> <td width="60%"> RGB(128, 0, 128) </td> </tr> <tr> <td width="40%">
    ///            <dl> <dt>13</dt> </dl> </td> <td width="60%"> RGB(128, 0, 0) </td> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>14</dt> </dl> </td> <td width="60%"> RGB(128, 128, 0) </td> </tr> <tr> <td width="40%"> <dl> <dt>15</dt>
    ///            </dl> </td> <td width="60%"> RGB(128, 128, 128) </td> </tr> <tr> <td width="40%"> <dl> <dt>16</dt> </dl>
    ///            </td> <td width="60%"> RGB(192, 192, 192) </td> </tr> </table>
    ///    pValue = Type: <b>long*</b> The color that corresponds to the specified index.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetEffectColor(int Index, int* pValue);
    ///Gets the Input Method Manager (IMM) input context from the Text Object Model (TOM) host.
    ///Params:
    ///    pContext = Type: <b>__int64*</b> The IMM input context.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetImmContext(long* pContext);
    ///Retrieves the preferred font for a particular character repertoire and character position.
    ///Params:
    ///    cp = Type: <b>long</b> The character position for the preferred font.
    ///    CharRep = Type: <b>long</b> The character repertoire index for the preferred font. It can be one of the following
    ///              values. <a id="tomAboriginal"></a> <a id="tomaboriginal"></a> <a id="TOMABORIGINAL"></a>
    ///    Options = Type: <b>long</b> The preferred font options. The low-order word can be a combination of the following
    ///              values. <a id="tomIgnoreCurrentFont"></a> <a id="tomignorecurrentfont"></a> <a id="TOMIGNORECURRENTFONT"></a>
    ///    curCharRep = Type: <b>long</b> The index of the current character repertoire.
    ///    curFontSize = Type: <b>long</b> The current font size.
    ///    pbstr = Type: <b>BSTR*</b> The name of the font.
    ///    pPitchAndFamily = Type: <b>long*</b> The font pitch and family.
    ///    pNewFontSize = Type: <b>long*</b> The new font size.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetPreferredFont(int cp, int CharRep, int Options, int curCharRep, int curFontSize, BSTR* pbstr, 
                             int* pPitchAndFamily, int* pNewFontSize);
    ///Retrieves the value of a property.
    ///Params:
    ///    Type = Type: <b>long</b> The identifier of the property to retrieve. It can be one of the following property IDs. <a
    ///           id="tomCanCopy_"></a> <a id="tomcancopy_"></a> <a id="TOMCANCOPY_"></a>
    ///    pValue = Type: <b>long*</b> The value of the property.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetProperty(int Type, int* pValue);
    ///Gets a collection of rich-text strings.
    ///Params:
    ///    ppStrs = Type: <b>ITextStrings**</b> The collection of rich-text strings.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetStrings(ITextStrings* ppStrs);
    ///Notifies the Text Object Model (TOM) engine client of particular Input Method Editor (IME) events.
    ///Params:
    ///    Notify = Type: <b>long</b> An IME notification code.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT Notify(int Notify);
    ///Retrieves a new text range for the active story of the document.
    ///Params:
    ///    cpActive = Type: <b>long</b> The active end of the new text range. The default value is 0; that is, the beginning of the
    ///               story.
    ///    cpAnchor = Type: <b>long</b> The anchor end of the new text range. The default value is 0.
    ///    ppRange = Type: <b>ITextRange2**</b> The new text range.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT Range2(int cpActive, int cpAnchor, ITextRange2* ppRange);
    ///Retrieves the degenerate range at (or nearest to) a particular point on the screen.
    ///Params:
    ///    x = Type: <b>long</b> The x-coordinate of a point, in screen coordinates.
    ///    y = Type: <b>long</b> The y-coordinate of a point, in screen coordinates.
    ///    Type = Type: <b>long</b> The alignment type of the specified point. For a list of valid values, see
    ///           ITextRange::GetPoint.
    ///    ppRange = Type: <b>ITextRange2**</b>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT RangeFromPoint2(int x, int y, int Type, ITextRange2* ppRange);
    ///Releases the call manager.
    ///Params:
    ///    pVoid = Type: <b>IUnknown*</b> The call manager object to release.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT ReleaseCallManager(IUnknown pVoid);
    ///Releases an Input Method Manager (IMM) input context.
    ///Params:
    ///    Context = Type: <b>int64</b> The IMM input context to release.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT ReleaseImmContext(long Context);
    ///Specifies the color to use for special text attributes.
    ///Params:
    ///    Index = Type: <b>long</b> The index of the color to retrieve. For a list of values, see GetEffectColor.
    ///    Value = Type: <b>long</b> The new color for the specified index.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetEffectColor(int Index, int Value);
    ///Specifies a new value for a property.
    ///Params:
    ///    Type = Type: <b>long</b> The identifier of the property. For a list of possible property identifiers, see
    ///           GetProperty.
    ///    Value = Type: <b>long</b> The new property value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetProperty(int Type, int Value);
    ///Specifies the typography options for the document.
    ///Params:
    ///    Options = Type: <b>long</b> The typography options to set. For a list of possible options, see GetTypographyOptions.
    ///    Mask = Type: <b>long</b> A mask identifying the options to set. For example, to turn on
    ///           <b>TO_ADVANCEDTYPOGRAPHY</b>, call <b>ITextDocument2::SetTypographyOptions (TO_ADVANCEDTYPOGRAPHY,
    ///           TO_ADVANCEDTYPOGRAPHY)</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetTypographyOptions(int Options, int Mask);
    ///Generates a system beep.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SysBeep();
    ///Updates the selection and caret.
    ///Params:
    ///    Value = Type: <b>long</b> Scroll flag. Use <b>tomTrue</b> to scroll the caret into view.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT Update(int Value);
    ///Notifies the client that the view has changed and the client should update the view if the Text Object Model
    ///(TOM) engine is in-place active.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT UpdateWindow();
    ///Gets the math properties for the document.
    ///Params:
    ///    pOptions = Type: <b>long*</b> A combination of the following math properties. <table> <tr> <th>Property</th>
    ///               <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomMathDispAlignMask"></a><a
    ///               id="tommathdispalignmask"></a><a id="TOMMATHDISPALIGNMASK"></a><dl> <dt><b>tomMathDispAlignMask</b></dt>
    ///               </dl> </td> <td width="60%"> Display-mode alignment mask. </td> </tr> <tr> <td width="40%"><a
    ///               id="tomMathDispAlignCenter"></a><a id="tommathdispaligncenter"></a><a id="TOMMATHDISPALIGNCENTER"></a><dl>
    ///               <dt><b>tomMathDispAlignCenter</b></dt> </dl> </td> <td width="60%"> Center (default) alignment. </td> </tr>
    ///               <tr> <td width="40%"><a id="tomMathDispAlignLeft"></a><a id="tommathdispalignleft"></a><a
    ///               id="TOMMATHDISPALIGNLEFT"></a><dl> <dt><b>tomMathDispAlignLeft</b></dt> </dl> </td> <td width="60%"> Left
    ///               alignment. </td> </tr> <tr> <td width="40%"><a id="tomMathDispAlignRight"></a><a
    ///               id="tommathdispalignright"></a><a id="TOMMATHDISPALIGNRIGHT"></a><dl> <dt><b>tomMathDispAlignRight</b></dt>
    ///               </dl> </td> <td width="60%"> Right alignment. </td> </tr> <tr> <td width="40%"><a
    ///               id="tomMathDispIntUnderOver"></a><a id="tommathdispintunderover"></a><a id="TOMMATHDISPINTUNDEROVER"></a><dl>
    ///               <dt><b>tomMathDispIntUnderOver</b></dt> </dl> </td> <td width="60%"> Display-mode integral limits location.
    ///               </td> </tr> <tr> <td width="40%"><a id="tomMathDispFracTeX"></a><a id="tommathdispfractex"></a><a
    ///               id="TOMMATHDISPFRACTEX"></a><dl> <dt><b>tomMathDispFracTeX</b></dt> </dl> </td> <td width="60%"> Display-mode
    ///               nested fraction script size. </td> </tr> <tr> <td width="40%"><a id="tomMathDispNaryGrow"></a><a
    ///               id="tommathdispnarygrow"></a><a id="TOMMATHDISPNARYGROW"></a><dl> <dt><b>tomMathDispNaryGrow</b></dt> </dl>
    ///               </td> <td width="60%"> Math-paragraph n-ary grow. </td> </tr> <tr> <td width="40%"><a
    ///               id="tomMathDocEmptyArgMask"></a><a id="tommathdocemptyargmask"></a><a id="TOMMATHDOCEMPTYARGMASK"></a><dl>
    ///               <dt><b>tomMathDocEmptyArgMask</b></dt> </dl> </td> <td width="60%"> Empty arguments display mask. </td> </tr>
    ///               <tr> <td width="40%"><a id="tomMathDocEmptyArgAuto_"></a><a id="tommathdocemptyargauto_"></a><a
    ///               id="TOMMATHDOCEMPTYARGAUTO_"></a><dl> <dt><b>tomMathDocEmptyArgAuto </b></dt> </dl> </td> <td width="60%">
    ///               Automatically use a dotted square to denote empty arguments, if necessary. </td> </tr> <tr> <td
    ///               width="40%"><a id="tomMathDocEmptyArgAlways"></a><a id="tommathdocemptyargalways"></a><a
    ///               id="TOMMATHDOCEMPTYARGALWAYS"></a><dl> <dt><b>tomMathDocEmptyArgAlways</b></dt> </dl> </td> <td width="60%">
    ///               Always use a dotted square to denote empty arguments.. </td> </tr> <tr> <td width="40%"><a
    ///               id="tomMathDocEmptyArgNever"></a><a id="tommathdocemptyargnever"></a><a id="TOMMATHDOCEMPTYARGNEVER"></a><dl>
    ///               <dt><b>tomMathDocEmptyArgNever</b></dt> </dl> </td> <td width="60%"> Don't denote empty arguments. </td>
    ///               </tr> <tr> <td width="40%"><a id="tomMathDocSbSpOpUnchanged"></a><a id="tommathdocsbspopunchanged"></a><a
    ///               id="TOMMATHDOCSBSPOPUNCHANGED"></a><dl> <dt><b>tomMathDocSbSpOpUnchanged</b></dt> </dl> </td> <td
    ///               width="60%"> Display the underscore (_) and caret (^) as themselves. </td> </tr> <tr> <td width="40%"><a
    ///               id="tomMathDocDiffMask"></a><a id="tommathdocdiffmask"></a><a id="TOMMATHDOCDIFFMASK"></a><dl>
    ///               <dt><b>tomMathDocDiffMask</b></dt> </dl> </td> <td width="60%"> Style mask for the
    ///               <b>tomMathDocDiffUpright</b>, <b>tomMathDocDiffItalic</b>, <b>tomMathDocDiffOpenItalic </b>options. </td>
    ///               </tr> <tr> <td width="40%"><a id="tomMathDocDiffItalic"></a><a id="tommathdocdiffitalic"></a><a
    ///               id="TOMMATHDOCDIFFITALIC"></a><dl> <dt><b>tomMathDocDiffItalic</b></dt> </dl> </td> <td width="60%"> Use
    ///               italic (default) for math differentials. </td> </tr> <tr> <td width="40%"><a
    ///               id="tomMathDocDiffUpright"></a><a id="tommathdocdiffupright"></a><a id="TOMMATHDOCDIFFUPRIGHT"></a><dl>
    ///               <dt><b>tomMathDocDiffUpright</b></dt> </dl> </td> <td width="60%"> Use an upright font for math
    ///               differentials. </td> </tr> <tr> <td width="40%"><a id="tomMathDocDiffOpenItalic"></a><a
    ///               id="tommathdocdiffopenitalic"></a><a id="TOMMATHDOCDIFFOPENITALIC"></a><dl>
    ///               <dt><b>tomMathDocDiffOpenItalic</b></dt> </dl> </td> <td width="60%"> Use open italic (default) for math
    ///               differentials. </td> </tr> <tr> <td width="40%"><a id="tomMathDispNarySubSup"></a><a
    ///               id="tommathdispnarysubsup"></a><a id="TOMMATHDISPNARYSUBSUP"></a><dl> <dt><b>tomMathDispNarySubSup</b></dt>
    ///               </dl> </td> <td width="60%"> Math-paragraph non-integral n-ary limits location. </td> </tr> <tr> <td
    ///               width="40%"><a id="tomMathDispDef"></a><a id="tommathdispdef"></a><a id="TOMMATHDISPDEF"></a><dl>
    ///               <dt><b>tomMathDispDef</b></dt> </dl> </td> <td width="60%"> Math-paragraph spacing defaults. </td> </tr> <tr>
    ///               <td width="40%"><a id="tomMathEnableRtl"></a><a id="tommathenablertl"></a><a id="TOMMATHENABLERTL"></a><dl>
    ///               <dt><b>tomMathEnableRtl</b></dt> </dl> </td> <td width="60%"> Enable right-to-left (RTL) math zones in RTL
    ///               paragraphs. </td> </tr> <tr> <td width="40%"><a id="tomMathBrkBinMask"></a><a id="tommathbrkbinmask"></a><a
    ///               id="TOMMATHBRKBINMASK"></a><dl> <dt><b>tomMathBrkBinMask</b></dt> </dl> </td> <td width="60%"> Equation line
    ///               break mask. </td> </tr> <tr> <td width="40%"><a id="tomMathBrkBinBefore"></a><a
    ///               id="tommathbrkbinbefore"></a><a id="TOMMATHBRKBINBEFORE"></a><dl> <dt><b>tomMathBrkBinBefore</b></dt> </dl>
    ///               </td> <td width="60%"> Break before binary/relational operator. </td> </tr> <tr> <td width="40%"><a
    ///               id="tomMathBrkBinAfter"></a><a id="tommathbrkbinafter"></a><a id="TOMMATHBRKBINAFTER"></a><dl>
    ///               <dt><b>tomMathBrkBinAfter</b></dt> </dl> </td> <td width="60%"> Break after binary/relational operator. </td>
    ///               </tr> <tr> <td width="40%"><a id="tomMathBrkBinDup"></a><a id="tommathbrkbindup"></a><a
    ///               id="TOMMATHBRKBINDUP"></a><dl> <dt><b>tomMathBrkBinDup</b></dt> </dl> </td> <td width="60%"> Duplicate
    ///               binary/relational before/after. </td> </tr> <tr> <td width="40%"><a id="tomMathBrkBinSubMask"></a><a
    ///               id="tommathbrkbinsubmask"></a><a id="TOMMATHBRKBINSUBMASK"></a><dl> <dt><b>tomMathBrkBinSubMask</b></dt>
    ///               </dl> </td> <td width="60%"> Duplicate mask for minus operator. </td> </tr> <tr> <td width="40%"><a
    ///               id="tomMathBrkBinSubMM"></a><a id="tommathbrkbinsubmm"></a><a id="TOMMATHBRKBINSUBMM"></a><dl>
    ///               <dt><b>tomMathBrkBinSubMM</b></dt> </dl> </td> <td width="60%"> - - (minus on both lines). </td> </tr> <tr>
    ///               <td width="40%"><a id="tomMathBrkBinSubPM"></a><a id="tommathbrkbinsubpm"></a><a
    ///               id="TOMMATHBRKBINSUBPM"></a><dl> <dt><b>tomMathBrkBinSubPM</b></dt> </dl> </td> <td width="60%"> + - </td>
    ///               </tr> <tr> <td width="40%"><a id="tomMathBrkBinSubMP"></a><a id="tommathbrkbinsubmp"></a><a
    ///               id="TOMMATHBRKBINSUBMP"></a><dl> <dt><b>tomMathBrkBinSubMP</b></dt> </dl> </td> <td width="60%"> - + </td>
    ///               </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetMathProperties(int* pOptions);
    ///Specifies the math properties to use for the document.
    ///Params:
    ///    Options = Type: <b>long</b> The math properties to set. For a list of possible properties, see GetMathProperties.
    ///    Mask = Type: <b>long</b> The math mask. For a list of possible masks, see GetMathProperties
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetMathProperties(int Options, int Mask);
    ///Gets the active story; that is, the story that receives keyboard and mouse input.
    ///Params:
    ///    ppStory = Type: <b>ITextStory**</b> The active story.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetActiveStory(ITextStory* ppStory);
    ///Sets the active story; that is, the story that receives keyboard and mouse input.
    ///Params:
    ///    pStory = Type: <b>ITextStory*</b> The story to set as active.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetActiveStory(ITextStory pStory);
    ///Gets the main story.
    ///Params:
    ///    ppStory = Type: <b>ITextStory**</b> The main story.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMainStory(ITextStory* ppStory);
    ///Not implemented. Gets a new story.
    ///Params:
    ///    ppStory = Type: <b>ITextStory**</b> The new story.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetNewStory(ITextStory* ppStory);
    ///Retrieves the story that corresponds to a particular index.
    ///Params:
    ///    Index = Type: <b>long</b> The index of the story to retrieve.
    ///    ppStory = Type: <b>ITextStory**</b> The story.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetStory(int Index, ITextStory* ppStory);
}

///The <b>ITextRange2</b> interface is derived from ITextRange, and its objects are powerful editing and data-binding
///tools that enable a program to select text in a story and then examine or change that text.
@GUID("C241F5E2-7206-11D8-A2C7-00A0D1D6C6B3")
interface ITextRange2 : ITextSelection
{
    ///Gets the count of characters in a range.
    ///Params:
    ///    pcch = Type: <b>long*</b> The signed count of characters.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCch(int* pcch);
    ///Not implemented. Gets a cells object with the parameters of cells in the currently selected table row or column.
    ///Params:
    ///    ppCells = Type: <b>IUnknown**</b> The cells object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCells(IUnknown* ppCells);
    ///Not implemented. Gets the column properties for the currently selected column.
    ///Params:
    ///    ppColumn = Type: <b>IUnknown**</b> The column properties for the currently selected column.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetColumn(IUnknown* ppColumn);
    ///Gets the count of subranges, including the active subrange in the current range.
    ///Params:
    ///    pCount = Type: <b>long*</b> The count of subranges not including the active one.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCount(int* pCount);
    ///Gets a duplicate of a range object.
    ///Params:
    ///    ppRange = Type: <b>ITextRange2**</b> The duplicate range.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetDuplicate2(ITextRange2* ppRange);
    ///Gets an ITextFont2 object with the character attributes of the current range.
    ///Params:
    ///    ppFont = Type: <b>ITextFont2**</b> The ITextFont2 object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetFont2(ITextFont2* ppFont);
    ///Sets the character formatting attributes of the range.
    ///Params:
    ///    pFont = Type: <b>ITextFont2*</b> The font object with the desired character formatting attributes.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetFont2(ITextFont2 pFont);
    ///Gets an ITextRange2 object with the current range's formatted text.
    ///Params:
    ///    ppRange = Type: <b>ITextRange2**</b> The formatted text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetFormattedText2(ITextRange2* ppRange);
    ///Sets the text of this range to the formatted text of the specified range.
    ///Params:
    ///    pRange = Type: <b>ITextRange2*</b> The range that contains the formatted text that replaces the text of this range.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetFormattedText2(ITextRange2 pRange);
    ///Gets the gravity of this range.
    ///Params:
    ///    pValue = Type: <b>long*</b> The gravity value, which can be one of the following: <a id="tomGravityUI"></a> <a
    ///             id="tomgravityui"></a> <a id="TOMGRAVITYUI"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetGravity(int* pValue);
    ///Sets the gravity of this range.
    ///Params:
    ///    Value = Type: <b>long</b> The new gravity value, which can be one of the following. <a id="tomGravityUI"></a> <a
    ///            id="tomgravityui"></a> <a id="TOMGRAVITYUI"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetGravity(int Value);
    ///Gets an ITextPara2 object with the paragraph attributes of a range.
    ///Params:
    ///    ppPara = Type: <b>ITextPara2**</b> The ITextPara2 object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetPara2(ITextPara2* ppPara);
    ///Sets the paragraph format attributes of a range.
    ///Params:
    ///    pPara = Type: <b>ITextPara2*</b> The desired paragraph format.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetPara2(ITextPara2 pPara);
    ///Gets the row properties in the currently selected row.
    ///Params:
    ///    ppRow = Type: <b>ITextRow**</b> The row properties.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetRow(ITextRow* ppRow);
    ///Gets the character position of the start of the paragraph that contains the range's start character position.
    ///Params:
    ///    pValue = Type: <b>long*</b> The start of the paragraph that contains the range's start character position.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetStartPara(int* pValue);
    ///Not implemented. Gets the table properties in the currently selected table.
    ///Params:
    ///    ppTable = Type: <b>IUnknown**</b> The table properties.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetTable(IUnknown* ppTable);
    ///Returns the URL text associated with a range.
    ///Params:
    ///    pbstr = Type: <b>BSTR*</b> The URL text associated with the range.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT GetURL(BSTR* pbstr);
    ///Sets the text in this range to that of the specified URL.
    ///Params:
    ///    bstr = Type: <b>BSTR</b> The text to use as a URL for the selected friendly name.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetURL(BSTR bstr);
    ///Adds a subrange to this range.
    ///Params:
    ///    cp1 = Type: <b>long</b> The active-end character position of the subrange.
    ///    cp2 = Type: <b>long</b> The anchor-end character position of the subrange.
    ///    Activate = Type: <b>long</b> The activate parameter. If this parameter is <b>tomTrue</b>, the new subrange is the active
    ///               subrange, with <i>cp1</i> as the active end, and <i>cp2</i> the anchor end.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT AddSubrange(int cp1, int cp2, int Activate);
    ///Converts the linear-format math in a range to a built-up form, or modifies the current built-up form.
    ///Params:
    ///    Flags = Type: <b>long</b> A combination of the following flags. <a id="tomChemicalFormula"></a> <a
    ///            id="tomchemicalformula"></a> <a id="TOMCHEMICALFORMULA"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT BuildUpMath(int Flags);
    ///Deletes a subrange from a range.
    ///Params:
    ///    cpFirst = Type: <b>long</b> The start character position of the subrange.
    ///    cpLim = Type: <b>long</b> The end character position of the subrange.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT DeleteSubrange(int cpFirst, int cpLim);
    ///Searchs for math inline functions in text as specified by a source range.
    ///Params:
    ///    pRange = Type: <b>ITextRange2*</b> The formatted text to find in the range's text.
    ///    Count = Type: <b>long</b> The number of characters to search through.
    ///    Flags = Type: <b>long</b> Flags that control the search as defined for ITextRange::FindText.
    ///    pDelta = Type: <b>long*</b> A count of the number of characters bypassed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT Find(ITextRange2 pRange, int Count, int Flags, int* pDelta);
    ///Gets the character at the specified offset from the end of this range.
    ///Params:
    ///    pChar = Type: <b>long*</b> The character value.
    ///    Offset = Type: <b>long</b> The offset from the end of the range. An offset of 0 gets the character at the end of the
    ///             range.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetChar2(int* pChar, int Offset);
    ///Not implemented. Gets the drop-cap parameters of the paragraph that contains this range.
    ///Params:
    ///    pcLine = Type: <b>long*</b> The count of lines for the drop cap. A value of 0 means no drop cap.
    ///    pPosition = Type: <b>long*</b> The position of the drop cap. The position can be one of the following: <ul>
    ///                <li>tomDropMargin</li> <li>tomDropNone</li> <li>tomDropNormal</li> </ul>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetDropCap(int* pcLine, int* pPosition);
    ///Gets the properties of the inline object at the range active end.
    ///Params:
    ///    pType = Type: <b>long*</b> The inline object type can be one of the following: <a id="tomSimpleText"></a> <a
    ///            id="tomsimpletext"></a> <a id="TOMSIMPLETEXT"></a>
    ///    pAlign = Type: <b>long*</b> The inline object alignment, which can be one of these meanings depending on the inline
    ///             object type: <table> <tr> <th>Inline object type</th> <th>Meaning of Align Parameter</th> </tr> <tr>
    ///             <td>tomRuby</td> <td> <dl> <dt>tomRubyBelow</dt> <dt>tomRubyAlignCenter (default)</dt>
    ///             <dt>tomRubyAlign010</dt> <dt>tomRubyAlign121</dt> <dt>tomRubyAlignLeft</dt> <dt>tomRubyAlignRight</dt> </dl>
    ///             </td> </tr> <tr> <td>tomBox</td> <td> <dl> <dt>tomBoxAlignCenter</dt> <dt>tomSpaceMask</dt>
    ///             <dt>tomSpaceDefault</dt> <dt>tomSpaceUnary</dt> <dt>tomSpaceBinary</dt> <dt>tomSpaceRelational</dt>
    ///             <dt>tomSpaceSkip</dt> <dt>tomSpaceOrd</dt> <dt>tomSpaceDifferential</dt> <dt>tomSizeText</dt>
    ///             <dt>tomSizeScript</dt> <dt>tomSizeScriptScript</dt> <dt>tomNoBreak</dt> <dt>tomTransparentForPositioning</dt>
    ///             <dt>tomTransparentForSpacing</dt> </dl> </td> </tr> <tr> <td>tomBoxedFormula</td> <td> <dl>
    ///             <dt>tomBoxHideTop</dt> <dt>tomBoxHideBottom</dt> <dt>tomBoxHideLeft</dt> <dt>tomBoxHideRight</dt>
    ///             <dt>tomBoxStrikeH</dt> <dt>tomBoxStrikeV</dt> <dt>tomBoxStrikeTLBR</dt> <dt>tomBoxStrikeBLTR</dt> </dl> </td>
    ///             </tr> <tr> <td>tomBrackets</td> <td> <dl> <dt>tomAlignDefault</dt> <dt>tomAlignCenter</dt>
    ///             <dt>tomAlignMatchAscentDescent</dt> <dt>tomMathVariant</dt> </dl> </td> </tr> <tr> <td>tomEquationArray</td>
    ///             <td> <dl> <dt>tomEqArrayLayoutWidth</dt> <dt>tomEqArrayAlignMask</dt> <dt>tomEqArrayAlignCenter</dt>
    ///             <dt>tomEqArrayAlignTopRow</dt> <dt>tomEqArrayAlignBottomRow</dt> </dl> </td> </tr> <tr> <td>tomMatrix</td>
    ///             <td> <dl> <dt>tomMatrixAlignMask</dt> <dt>tomMatrixAlignCenter</dt> <dt>tomMatrixAlignTopRow</dt>
    ///             <dt>tomMatrixAlignBottomRow</dt> <dt>tomShowMatPlaceHldr</dt> </dl> </td> </tr> <tr> <td>tomNary</td> <td>
    ///             <dl> <dt>tomLimitsDefault</dt> <dt>tomLimitsUnderOver</dt> <dt>tomLimitsSubSup</dt>
    ///             <dt>tomUpperLimitAsSuperScript</dt> <dt>tomLimitsOpposite</dt> <dt>tomShowLLimPlaceHldr</dt>
    ///             <dt>tomShowULimPlaceHldr</dt> <dt>tomDontGrowWithContent</dt> <dt>tomGrowWithContent</dt> </dl> </td> </tr>
    ///             <tr> <td>tomPhantom</td> <td> <dl> <dt>tomPhantomShow</dt> <dt>tomPhantomZeroWidth</dt>
    ///             <dt>tomPhantomZeroAscent</dt> <dt>tomPhantomZeroDescent</dt> <dt>tomPhantomTransparent</dt> </dl> </td> </tr>
    ///             <tr> <td>tomRadical</td> <td>tomShowDegPlaceHldr</td> </tr> <tr> <td>tomSubSup</td> <td>tomSubSupAlign</td>
    ///             </tr> <tr> <td>tomStretchStack</td> <td> <dl> <dt>tomStretchCharBelow</dt> <dt>tomStretchCharAbove</dt>
    ///             <dt>tomStretchBaseBelow</dt> <dt>tomStretchBaseAbove</dt> </dl> </td> </tr> </table>
    ///    pChar = Type: <b>long*</b> The inline object character. The value for each object type is shown in the following
    ///            table.. <table> <tr> <th>Inline object type</th> <th>Meaning of align parameter</th> </tr> <tr>
    ///            <td>tomAccent</td> <td>Accent (U+0300—U+36F, U+20D0—U+20EF)</td> </tr> <tr> <td>tomBoxedFormula</td>
    ///            <td>U+25AD for rectangle enclosure</td> </tr> <tr> <td>tomBrackets</td> <td>Opening bracket. Default: U+0028.
    ///            </td> </tr> <tr> <td>tomBracketsWithSeps</td> <td>Opening bracket with separators. Default: U+0028</td> </tr>
    ///            <tr> <td>tomEquationArray</td> <td>U+2588</td> </tr> <tr> <td>tomFraction</td> <td>Normal built-up fraction:
    ///            U+002F; small numeric fraction: U+2298</td> </tr> <tr> <td>tomFunctionApply</td> <td>U+2061</td> </tr> <tr>
    ///            <td>tomLeftSubSup</td> <td>U+005E</td> </tr> <tr> <td>tomLowerLimit</td> <td>U+252C</td> </tr> <tr>
    ///            <td>tomMatrix</td> <td> <dl> <dt>U+25A0: no enclosing brackets </dt> <dt>U+24A8: enclosing parentheses
    ///            (\pmatrix) </dt> <dt>U+24B1: enclosing vertical bars (\vmatrix) </dt> <dt>U+24A9: enclosing double vertical
    ///            bars (\Vmatrix) </dt> </dl> </td> </tr> <tr> <td>tomNary</td> <td>n-ary symbol</td> </tr> <tr>
    ///            <td>tomOpChar</td> <td>Internal use for no-build operators</td> </tr> <tr> <td>tomOverbar</td>
    ///            <td>U+00AF</td> </tr> <tr> <td>tomPhantom</td> <td> <dl> <dt>U+27E1: full or custom phantom </dt> <dt>U+2B04:
    ///            horizontal phantom </dt> <dt>U+21F3: vertical phantom </dt> <dt>U+2B06: ascent smash </dt> <dt>U+2B07:
    ///            descent smash </dt> <dt>U+2B0C: horizontal smash </dt> <dt>U+2B0D: full smash </dt> </dl> </td> </tr> <tr>
    ///            <td>tomRadical</td> <td> <dl> <dt>U+221A: square or nth root </dt> <dt>U+221B: cube root </dt> <dt>U+221C:
    ///            fourth root </dt> </dl> </td> </tr> <tr> <td>tomSlashedFraction</td> <td> <dl> <dt>U+2044: skewed
    ///            fraction</dt> <dt>U+2215: built-up linear fraction </dt> </dl> </td> </tr> <tr> <td>tomStack</td> <td>U+00A6
    ///            </td> </tr> <tr> <td>tomStretchStack</td> <td>Horizontal stretch character (see Unicode Technical Note 28
    ///            Appendix B for a list)</td> </tr> <tr> <td>tomSubscript</td> <td>U+005E </td> </tr> <tr> <td>tomSubSup</td>
    ///            <td>U+005E</td> </tr> <tr> <td>tomSuperscript</td> <td>U+005F</td> </tr> <tr> <td>tomUnderbar</td>
    ///            <td>U+2581</td> </tr> <tr> <td>tomUpperLimit</td> <td>U+2534</td> </tr> </table>
    ///    pChar1 = Type: <b>long*</b> The closing <b>tomBrackets</b> character. See Unicode Technical Note 28 Appendix B.
    ///             Character Keywords and Properties for a list.
    ///    pChar2 = Type: <b>long*</b> The separator character for <b>tomBracketsWithSep</b>:
    ///    pCount = Type: <b>long*</b> The inline object count of arguments.
    ///    pTeXStyle = Type: <b>long*</b> The inline object TeX style, which can be one of the following values. <div
    ///                class="alert"><b>Note</b> The <b>tomStyleDefault</b> behavior depends on the context.</div> <div> </div> <a
    ///                id="tomStyleDefault"></a> <a id="tomstyledefault"></a> <a id="TOMSTYLEDEFAULT"></a>
    ///    pcCol = Type: <b>long*</b> The inline object count of columns (<b>tomMatrix</b> only).
    ///    pLevel = Type: <b>long*</b> The inline object 0-based nesting level.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetInlineObject(int* pType, int* pAlign, int* pChar, int* pChar1, int* pChar2, int* pCount, 
                            int* pTeXStyle, int* pcCol, int* pLevel);
    ///Gets the value of a property.
    ///Params:
    ///    Type = Type: <b>long</b> The property ID.
    ///    pValue = Type: <b>long*</b> The property value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetProperty(int Type, int* pValue);
    ///Retrieves a rectangle of the specified type for the current range.
    ///Params:
    ///    Type = Type: <b>long</b> The type of rectangle to return. This parameter can include one value from each of the
    ///           following tables. <a id="tomAllowOffClient"></a> <a id="tomallowoffclient"></a> <a
    ///           id="TOMALLOWOFFCLIENT"></a>
    ///    pLeft = Type: <b>long*</b> The left rectangle coordinate.
    ///    pTop = Type: <b>long*</b> The top rectangle coordinate.
    ///    pRight = Type: <b>long*</b> The right rectangle coordinate.
    ///    pBottom = Type: <b>long*</b> The bottom rectangle coordinate.
    ///    pHit = Type: <b>long*</b> The hit-test value for the range.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetRect(int Type, int* pLeft, int* pTop, int* pRight, int* pBottom, int* pHit);
    ///Retrieves a subrange in a range.
    ///Params:
    ///    iSubrange = Type: <b>long</b> The subrange index.
    ///    pcpFirst = Type: <b>long*</b> The character position for the start of the subrange.
    ///    pcpLim = Type: <b>long*</b> The character position for the end of the subrange.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetSubrange(int iSubrange, int* pcpFirst, int* pcpLim);
    ///Gets the text in this range according to the specified conversion flags.
    ///Params:
    ///    Flags = Type: <b>long</b> The flags controlling how the text is retrieved. The flags can include a combination of the
    ///            following values. Specifying a <i>Flags</i> value of 0 is the same as calling the ITextRange::GetText method.
    ///            <a id="tomAdjustCRLF"></a> <a id="tomadjustcrlf"></a> <a id="TOMADJUSTCRLF"></a>
    ///    pbstr = Type: <b>BSTR*</b> The text in the range.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetText2(int Flags, BSTR* pbstr);
    ///Converts and replaces the hexadecimal number at the end of this range to a Unicode character.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT HexToUnicode();
    ///Inserts a table in a range.
    ///Params:
    ///    cCol = Type: <b>long</b> The number of columns in the table.
    ///    cRow = Type: <b>long</b> The number of rows in the table.
    ///    AutoFit = Type: <b>long</b> Specifies how the cells fit the target space.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT InsertTable(int cCol, int cRow, int AutoFit);
    ///Translates the built-up math, ruby, and other inline objects in this range to linearized form.
    ///Params:
    ///    Flags = Type: <b>long</b> A combination of the following flags. <a id="tomMathAlphabetics"></a> <a
    ///            id="tommathalphabetics"></a> <a id="TOMMATHALPHABETICS"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT Linearize(int Flags);
    ///Makes the specified subrange the active subrange of this range.
    ///Params:
    ///    cpAnchor = Type: <b>long</b> The anchor end character position of the subrange to make active.
    ///    cpActive = Type: <b>long</b> The active end character position of the subrange to make active.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetActiveSubrange(int cpAnchor, int cpActive);
    ///Not implemented. Sets the drop-cap parameters for the paragraph that contains the current range.
    ///Params:
    ///    cLine = Type: <b>long</b> The count of lines for drop cap. Zero means no drop cap.
    ///    Position = Type: <b>long</b> The position of drop cap. It can be one of the following. <dl> <dd>tomDropMargin</dd>
    ///               <dd>tomDropNone</dd> <dd>tomDropNormal</dd> </dl>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT SetDropCap(int cLine, int Position);
    ///Sets the value of the specified property.
    ///Params:
    ///    Type = Type: <b>long</b> The ID of the property to set.
    ///    Value = Type: <b>long</b> The new property value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetProperty(int Type, int Value);
    ///Sets the text of this range.
    ///Params:
    ///    Flags = Type: <b>long</b> Flags controlling how the text is inserted in the range. The flag can be one of the
    ///            following values: <a id="tomUnicodeBiDi"></a> <a id="tomunicodebidi"></a> <a id="TOMUNICODEBIDI"></a>
    ///    bstr = Type: <b>BSTR</b> The new text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetText2(int Flags, BSTR bstr);
    ///Converts the Unicode character(s) preceding the start position of this text range to a hexadecimal number, and
    ///selects it.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT UnicodeToHex();
    ///Sets or inserts the properties of an inline object for a degenerate range.
    ///Params:
    ///    Type = Type: <b>long</b> The object type as defined in ITextRange2::GetInlineObject.
    ///    Align = Type: <b>long</b> The object alignment as defined in ITextRange2::GetInlineObject.
    ///    Char = Type: <b>long</b> The object character as defined in ITextRange2::GetInlineObject.
    ///    Char1 = Type: <b>long</b> The closing bracket (tomBrackets) character. See Unicode Technical Note 28 for a list of
    ///            characters.
    ///    Char2 = Type: <b>long</b> The separator character for tomBracketsWithSeps, which can be one of the following values.
    ///    Count = Type: <b>long</b> The number of arguments in the inline object.
    ///    TeXStyle = Type: <b>long</b> The TeX style, as defined in ITextRange2::GetInlineObject.
    ///    cCol = Type: <b>long</b> The number of columns in the inline object. For tomMatrix only.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetInlineObject(int Type, int Align, int Char, int Char1, int Char2, int Count, int TeXStyle, int cCol);
    ///Retrieves the math function type associated with the specified math function name.
    ///Params:
    ///    bstr = Type: <b>BSTR</b> The math function name that is checked to determine the math function type.
    ///    pValue = Type: <b>long*</b> The math function type of the function name specified by <i>bstr</i>. It can be one of the
    ///             following values. <a id="tomFunctionTypeNone"></a> <a id="tomfunctiontypenone"></a> <a
    ///             id="TOMFUNCTIONTYPENONE"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetMathFunctionType(BSTR bstr, int* pValue);
    ///Inserts an image into this range.
    ///Params:
    ///    width = Type: <b>long</b> The width, in HIMETRIC units (0.01 mm), of the image.
    ///    height = Type: <b>long</b> The height, in HIMETRIC units, of the image.
    ///    ascent = Type: <b>long</b> If <i>Type</i> is TA_BASELINE, this parameter is the distance, in HIMETRIC units, that the
    ///             top of the image extends above the text baseline. If <i>Type</i> is TA_BASELINE and <i>ascent</i> is zero,
    ///             the bottom of the image is placed at the text baseline.
    ///    Type = Type: <b>long</b> The vertical alignment of the image. It can be one of the following values. <table> <tr>
    ///           <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TA_BASELINE"></a><a
    ///           id="ta_baseline"></a><dl> <dt><b>TA_BASELINE</b></dt> </dl> </td> <td width="60%"> Align the image relative
    ///           to the text baseline. </td> </tr> <tr> <td width="40%"><a id="TA_BOTTOM"></a><a id="ta_bottom"></a><dl>
    ///           <dt><b>TA_BOTTOM</b></dt> </dl> </td> <td width="60%"> Align the bottom of the image at the bottom of the
    ///           text line. </td> </tr> <tr> <td width="40%"><a id="TA_TOP"></a><a id="ta_top"></a><dl> <dt><b>TA_TOP</b></dt>
    ///           </dl> </td> <td width="60%"> Align the top of the image at the top of the text line </td> </tr> </table>
    ///    bstrAltText = Type: <b>BSTR</b> The alternate text for the image.
    ///    pStream = Type: <b>IStream</b> The stream that contains the image data.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InsertImage(int width, int height, int ascent, int Type, BSTR bstrAltText, IStream pStream);
}

///Currently, this interface contains no methods other than those inherited from ITextRange2.
@GUID("C241F5E1-7206-11D8-A2C7-00A0D1D6C6B3")
interface ITextSelection2 : ITextRange2
{
}

///In the Text Object Model (TOM), applications access text-range attributes by using a pair of dual interfaces,
///ITextFont and ITextPara. The <b>ITextFont2</b> interface extends ITextFont, providing the programming equivalent of
///the Microsoft Word format-font dialog.
@GUID("C241F5E3-7206-11D8-A2C7-00A0D1D6C6B3")
interface ITextFont2 : ITextFont
{
    ///Gets the count of extra properties in this character formatting collection.
    ///Params:
    ///    pCount = Type: <b>long*</b> The count of extra properties in this collection.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCount(int* pCount);
    ///Gets whether support for automatic ligatures is active.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Automatic ligature support is
    ///             active.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Automatic ligature support is not active.</td> </tr>
    ///             <tr> <td><b>tomUndefined</b></td> <td>The AutoLigatures property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetAutoLigatures(int* pValue);
    ///Sets whether support for automatic ligatures is active.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Automatic ligature support is
    ///            active.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Automatic ligature support is not active.</td> </tr>
    ///            <tr> <td><b>tomToggle</b></td> <td>Toggle the AutoLigatures property.</td> </tr> <tr>
    ///            <td><b>tomUndefined</b></td> <td>The AutoLigatures property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetAutoLigatures(int Value);
    ///Gets the East Asian "autospace alphabetics" state.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Use East Asian autospace
    ///             alphabetics.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Do not use East Asian autospace alphabetics.</td>
    ///             </tr> <tr> <td><b>tomUndefined</b></td> <td>The AutospaceAlpha property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetAutospaceAlpha(int* pValue);
    ///Sets the East Asian "autospace alpha" state.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Use East Asian autospace
    ///            alphabetics.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Do not use East Asian autospace alphabetics.</td>
    ///            </tr> <tr> <td><b>tomToggle</b></td> <td>Toggle the AutospaceAlpha property.</td> </tr> <tr>
    ///            <td><b>tomUndefined</b></td> <td>The AutospaceAlpha property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetAutospaceAlpha(int Value);
    ///Gets the East Asian "autospace numeric" state.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Use East Asian autospace
    ///             numerics.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Do not use East Asian autospace numerics.</td> </tr>
    ///             <tr> <td><b>tomUndefined</b></td> <td>The AutospaceNumeric property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetAutospaceNumeric(int* pValue);
    ///Sets the East Asian "autospace numeric" state.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Use East Asian autospace
    ///            numerics.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Do not use East Asian autospace numerics.</td> </tr>
    ///            <tr> <td><b>tomToggle</b></td> <td>Toggle the AutospaceNumeric property.</td> </tr> <tr>
    ///            <td><b>tomUndefined</b></td> <td>The AutospaceNumeric property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetAutospaceNumeric(int Value);
    ///Gets the East Asian "autospace parentheses" state.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Use East Asian autospace
    ///             parentheses.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Do not use East Asian autospace parentheses.</td>
    ///             </tr> <tr> <td><b>tomUndefined</b></td> <td>The AutospaceParens property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetAutospaceParens(int* pValue);
    ///Sets the East Asian "autospace parentheses" state.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Use East Asian autospace
    ///            parentheses.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Do not use East Asian autospace parentheses.</td>
    ///            </tr> <tr> <td><b>tomToggle</b></td> <td>Toggle the AutospaceParens property.</td> </tr> <tr>
    ///            <td><b>tomUndefined</b></td> <td>The AutospaceParens property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetAutospaceParens(int Value);
    ///Gets the character repertoire (writing system).
    ///Params:
    ///    pValue = Type: <b>long*</b> The character repertoire. It can be one of the following values. <a
    ///             id="tomAboriginal"></a> <a id="tomaboriginal"></a> <a id="TOMABORIGINAL"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCharRep(int* pValue);
    ///Sets the character repertoire (writing system).
    ///Params:
    ///    Value = Type: <b>long</b> The new character repertoire. For a list of possible values, see ITextFont2::GetCharRep.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCharRep(int Value);
    ///Gets the East Asian compression mode.
    ///Params:
    ///    pValue = Type: <b>long*</b> The compression mode, which can be one of these values: <a
    ///             id="tomCompressNone__default_"></a> <a id="tomcompressnone__default_"></a> <a
    ///             id="TOMCOMPRESSNONE__DEFAULT_"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCompressionMode(int* pValue);
    ///Sets the East Asian compression mode.
    ///Params:
    ///    Value = Type: <b>long</b> The compression mode, which can be one of these values: <a
    ///            id="tomCompressNone__default_"></a> <a id="tomcompressnone__default_"></a> <a
    ///            id="TOMCOMPRESSNONE__DEFAULT_"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCompressionMode(int Value);
    ///Gets the client cookie.
    ///Params:
    ///    pValue = Type: <b>long*</b> The client cookie.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCookie(int* pValue);
    ///Sets the client cookie.
    ///Params:
    ///    Value = Type: <b>long</b> The client cookie.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCookie(int Value);
    ///Gets whether characters are displayed with double horizontal lines through the center.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are displayed with double
    ///             horizontal lines.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not displayed with double
    ///             horizontal lines.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The DoubleStrike property is
    ///             undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetDoubleStrike(int* pValue);
    ///Sets whether characters are displayed with double horizontal lines through the center.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Characters are displayed with double
    ///            horizontal lines.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Characters are not displayed with double
    ///            horizontal lines.</td> </tr> <tr> <td><b>tomToggle</b></td> <td>Toggle the DoubleStrike property.</td> </tr>
    ///            <tr> <td><b>tomUndefined</b></td> <td>The DoubleStrike property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetDoubleStrike(int Value);
    ///Gets a duplicate of this character format object.
    ///Params:
    ///    ppFont = Type: <b>ITextFont2**</b> The duplicate character format object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetDuplicate2(ITextFont2* ppFont);
    ///Sets the properties of this object by copying the properties of another text font object.
    ///Params:
    ///    pFont = Type: <b>ITextFont2*</b> The text font object to copy from.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetDuplicate2(ITextFont2 pFont);
    ///Gets the link type.
    ///Params:
    ///    pValue = Type: <b>long*</b> The link type. It can be one of the following values. <a id="tomNoLink"></a> <a
    ///             id="tomnolink"></a> <a id="TOMNOLINK"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetLinkType(int* pValue);
    ///Gets whether a math zone is active.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>A math zone is active.</td> </tr> <tr>
    ///             <td><b>tomFalse</b></td> <td>A math zone is not active.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The
    ///             MathZone property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetMathZone(int* pValue);
    ///Sets whether a math zone is active.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>A math zone is active.</td> </tr> <tr>
    ///            <td><b>tomFalse</b></td> <td>A math zone is not active.</td> </tr> <tr> <td><b>tomToggle</b></td> <td>Toggle
    ///            the MathZone property.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The MathZone property is
    ///            undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetMathZone(int Value);
    ///Gets whether "decrease widths on pairs" is active.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Decrease widths on pairs is
    ///             active.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Decrease widths on pairs is not active.</td> </tr> <tr>
    ///             <td><b>tomUndefined</b></td> <td>The ModWidthPairs property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetModWidthPairs(int* pValue);
    ///Sets whether "decrease widths on pairs" is active.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Decrease widths on pairs is
    ///            active.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Decrease widths on pairs is not active.</td> </tr> <tr>
    ///            <td><b>tomToggle</b></td> <td>Toggle the ModWidthPairs property.</td> </tr> <tr> <td><b>tomUndefined</b></td>
    ///            <td>The ModWidthPairs property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetModWidthPairs(int Value);
    ///Gets whether "increase width of whitespace" is active.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Increase width of whitespace is
    ///             active.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Increase width of whitespace is not active.</td> </tr>
    ///             <tr> <td><b>tomUndefined</b></td> <td>The ModWidthSpace property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetModWidthSpace(int* pValue);
    ///Sets whether "increase width of whitespace" is active.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Increase width of whitespace is
    ///            active.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Increase width of whitespace is not active.</td> </tr>
    ///            <tr> <td><b>tomToggle</b></td> <td>Toggle the ModWidthSpace property.</td> </tr> <tr>
    ///            <td><b>tomUndefined</b></td> <td>The ModWidthSpace property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetModWidthSpace(int Value);
    ///Gets whether old-style numbers are active.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Old-style numbers are active.</td>
    ///             </tr> <tr> <td><b>tomFalse</b></td> <td>Old-style numbers are not active.</td> </tr> <tr>
    ///             <td><b>tomUndefined</b></td> <td>The OldNumbers property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetOldNumbers(int* pValue);
    ///Sets whether old-style numbers are active.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Old-style numbers are active.</td>
    ///            </tr> <tr> <td><b>tomFalse</b></td> <td>Old-style numbers are not active.</td> </tr> <tr>
    ///            <td><b>tomToggle</b></td> <td>Toggle the OldNumbers property.</td> </tr> <tr> <td><b>tomUndefined</b></td>
    ///            <td>The OldNumbers property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetOldNumbers(int Value);
    ///Gets whether overlapping text is active.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Overlapping text is active.</td> </tr>
    ///             <tr> <td><b>tomFalse</b></td> <td>Overlapping text is not active.</td> </tr> <tr>
    ///             <td><b>tomUndefined</b></td> <td>The Overlapping property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetOverlapping(int* pValue);
    ///Sets whether overlapping text is active.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Overlapping text is active.</td> </tr>
    ///            <tr> <td><b>tomFalse</b></td> <td>Overlapping text is not active.</td> </tr> <tr> <td><b>tomToggle</b></td>
    ///            <td>Toggle the Overlapping property.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The Overlapping
    ///            property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetOverlapping(int Value);
    ///Gets the subscript or superscript position relative to the baseline.
    ///Params:
    ///    pValue = Type: <b>long*</b> The subscript or superscript position relative to the baseline.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetPositionSubSuper(int* pValue);
    ///Sets the position of a subscript or superscript relative to the baseline, as a percentage of the font height.
    ///Params:
    ///    Value = Type: <b>long</b> The new subscript or superscript position.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetPositionSubSuper(int Value);
    ///Gets the font horizontal scaling percentage.
    ///Params:
    ///    pValue = Type: <b>long*</b> The scaling percentage.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetScaling(int* pValue);
    ///Sets the font horizontal scaling percentage.
    ///Params:
    ///    Value = Type: <b>long</b> The scaling percentage. Values from 0 through 255 are valid. For example, a value of 200
    ///            doubles the widths of characters while retaining the same height. A value of 0 has the same effect as a value
    ///            of 100; that is, it turns scaling off.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetScaling(int Value);
    ///Gets the East Asian space extension value.
    ///Params:
    ///    pValue = Type: <b>float*</b> The space extension, in floating-point points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetSpaceExtension(float* pValue);
    ///Sets the East Asian space extension value.
    ///Params:
    ///    Value = Type: <b>float</b> The new space extension, in floating-points.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetSpaceExtension(float Value);
    ///Gets the underline position mode.
    ///Params:
    ///    pValue = Type: <b>long*</b> The underline position mode. It can be one of the following values.
    ///             tomUnderlinePositionAuto tomUnderlinePositionBelow tomUnderlinePositionAbove
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetUnderlinePositionMode(int* pValue);
    ///Sets the underline position mode.
    ///Params:
    ///    Value = Type: <b>long</b> The new underline position mode. It can be one of the following values.<ul>
    ///            <li>tomUnderlinePositionAuto (the default)</li> <li>tomUnderlinePositionBelow</li>
    ///            <li>tomUnderlinePositionAbove</li> </ul>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetUnderlinePositionMode(int Value);
    ///Gets the character format effects.
    ///Params:
    ///    pValue = Type: <b>long*</b> A combination of the following character format values. <a id="tomAllCaps"></a> <a
    ///             id="tomallcaps"></a> <a id="TOMALLCAPS"></a>
    ///    pMask = Type: <b>long*</b> The differences in these flags over the range. A value of zero indicates that the
    ///            properties are the same over the range. For an insertion point, this value is always zero.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetEffects(int* pValue, int* pMask);
    ///Gets the additional character format effects.
    ///Params:
    ///    pValue = Type: <b>long*</b> A combination of the following character format flags. <a id="tomAutoSpaceAlpha"></a> <a
    ///             id="tomautospacealpha"></a> <a id="TOMAUTOSPACEALPHA"></a>
    ///    pMask = Type: <b>long*</b> The differences in these flags over the range. Zero values indicate that the properties
    ///            are the same over the range. For an insertion point, this value is always zero.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetEffects2(int* pValue, int* pMask);
    ///Gets the value of the specified property.
    ///Params:
    ///    Type = Type: <b>long</b> The property ID of the value to return. See Remarks.
    ///    pValue = Type: <b>long*</b> The property value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetProperty(int Type, int* pValue);
    ///Gets the property type and value of the specified extra propety.
    ///Params:
    ///    Index = Type: <b>long</b> The collection index of the extra property.
    ///    pType = Type: <b>long*</b> The property ID.
    ///    pValue = Type: <b>long*</b> The property value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetPropertyInfo(int Index, int* pType, int* pValue);
    ///Determines whether this text font object has the same properties as the specified text font object.
    ///Params:
    ///    pFont = Type: <b>ITextFont2*</b> The text font object to compare against.
    ///    pB = Type: <b>long*</b> A tomBool value that is <b>tomTrue</b> if the font objects have the same properties, or
    ///         <b>tomFalse</b> if they don't. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT IsEqual2(ITextFont2 pFont, int* pB);
    ///Sets the character format effects.
    ///Params:
    ///    Value = Type: <b>long</b> A combination of the following character format values. <a id="tomAllCaps"></a> <a
    ///            id="tomallcaps"></a> <a id="TOMALLCAPS"></a>
    ///    Mask = Type: <b>long</b> The desired mask, which can be a combination of the <i>Value</i> flags. Only effects with
    ///           the corresponding mask flag set are modified.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetEffects(int Value, int Mask);
    ///Sets the additional character format effects.
    ///Params:
    ///    Value = Type: <b>long</b> A combination of the following character format flags. <a id="tomAutoSpaceAlpha"></a> <a
    ///            id="tomautospacealpha"></a> <a id="TOMAUTOSPACEALPHA"></a>
    ///    Mask = Type: <b>long</b> The desired mask, which can be a combination of the <i>Value</i> flags. Only effects with
    ///           the corresponding mask flag set are modified.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetEffects2(int Value, int Mask);
    ///Sets the value of the specified property.
    ///Params:
    ///    Type = Type: <b>long</b> The ID of the property value to set. Types are defined by TOM. For a list of types, see
    ///           ITextFont2::GetProperty.
    ///    Value = Type: <b>long</b> The new property value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetProperty(int Type, int Value);
}

///Text Object Model (TOM) rich text-range attributes are accessed through a pair of dual interfaces, ITextFont and
///ITextPara. The <b>ITextPara2</b> interface extends ITextPara, providing the equivalent of the Microsoft Word
///format-paragraph dialog.
@GUID("C241F5E4-7206-11D8-A2C7-00A0D1D6C6B3")
interface ITextPara2 : ITextPara
{
    ///Not implemented. Gets the borders collection.
    ///Params:
    ///    ppBorders = Type: <b>IUnknown**</b> The borders collection.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetBorders(IUnknown* ppBorders);
    ///Gets a duplicate of this text paragraph format object.
    ///Params:
    ///    ppPara = Type: <b>ITextPara2**</b> The duplicate text paragraph format object
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetDuplicate2(ITextPara2* ppPara);
    ///Sets the properties of this object by copying the properties of another text paragraph object.
    ///Params:
    ///    pPara = Type: <b>ITextPara2*</b> The text paragraph object to copy from.
    ///Returns:
    ///    Type: <b>HRESULT</b> If <b>ITextPara2::SetDuplicate2</b> succeeds, it returns <b>S_OK</b>. If the method
    ///    fails, it returns one of the following COM error codes. For more information about COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetDuplicate2(ITextPara2 pPara);
    ///Gets the paragraph font alignment state.
    ///Params:
    ///    pValue = Type: <b>long*</b> The paragraph font alignment state. It can be one of the following values. <table> <tr>
    ///             <th>Font Alignment States</th> </tr> <tr> <td>tomFontAlignmentAuto (default)</td> </tr> <tr>
    ///             <td>tomFontAlignmentTop</td> </tr> <tr> <td>tomFontAlignmentBaseline</td> </tr> <tr>
    ///             <td>tomFontAlignmentBottom</td> </tr> <tr> <td>tomFontAlignmentCenter</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetFontAlignment(int* pValue);
    ///Sets the paragraph font alignment for Chinese, Japanese, Korean text.
    ///Params:
    ///    Value = Type: <b>long</b> The paragraph font alignment. It can be one of the following values. <table> <tr> <th>Font
    ///            Alignment States</th> </tr> <tr> <td>tomFontAlignmentAuto (default)</td> </tr> <tr>
    ///            <td>tomFontAlignmentTop</td> </tr> <tr> <td>tomFontAlignmentBaseline</td> </tr> <tr>
    ///            <td>tomFontAlignmentBottom</td> </tr> <tr> <td>tomFontAlignmentCenter</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetFontAlignment(int Value);
    ///Gets whether to hang punctuation symbols on the right margin when the paragraph is justified.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Hang punctuation symbols on the right
    ///             margin.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Do not hang punctuation symbols on the right
    ///             margin.</td> </tr> <tr> <td><b>tomUndefined</b></td> <td>The HangingPunctuation property is undefined.</td>
    ///             </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetHangingPunctuation(int* pValue);
    ///Sets whether to hang punctuation symbols on the right margin when the paragraph is justified.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Hang punctuation symbols on the right
    ///            margin.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Do not hang punctuation symbols on the right
    ///            margin.</td> </tr> <tr> <td><b>tomToggle</b></td> <td>Toggle the HangingPunctuation property.</td> </tr> <tr>
    ///            <td><b>tomUndefined</b></td> <td>The HangingPunctuation property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetHangingPunctuation(int Value);
    ///Gets whether paragraph lines snap to a vertical grid that could be defined for the whole document.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Paragraph lines snap to a vertical
    ///             grid.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Paragraph lines do not snap to a grid.</td> </tr> <tr>
    ///             <td><b>tomUndefined</b></td> <td>The SnapToGrid property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetSnapToGrid(int* pValue);
    ///Sets whether paragraph lines snap to a vertical grid that could be defined for the whole document.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Paragraph lines snap to a vertical
    ///            grid.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Paragraph lines do not snap to a grid.</td> </tr> <tr>
    ///            <td><b>tomToggle</b></td> <td>Toggle the SnapToGrid property.</td> </tr> <tr> <td><b>tomUndefined</b></td>
    ///            <td>The SnapToGrid property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetSnapToGrid(int Value);
    ///Gets whether to trim the leading space of a punctuation symbol at the start of a line.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that can be one of the following. <table class="clsStd"> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td><b>tomTrue</b></td> <td>Trim the leading space of a
    ///             punctuation symbol at the start of a line.</td> </tr> <tr> <td><b>tomFalse</b></td> <td>Do not trim the
    ///             leading space of a punctuation symbol at the start of a line.</td> </tr> <tr> <td><b>tomUndefined</b></td>
    ///             <td>The TrimPunctuationAtStart property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetTrimPunctuationAtStart(int* pValue);
    ///Sets whether to trim the leading space of a punctuation symbol at the start of a line.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool that indicates whether to trim the leading space of a punctuation symbol. It can
    ///            be one of the following values. <table class="clsStd"> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///            <td><b>tomTrue</b></td> <td>Trim the leading space of a punctuation symbol at the start of a line.</td> </tr>
    ///            <tr> <td><b>tomFalse</b></td> <td>Do not trim the leading space of a punctuation symbol at the start of a
    ///            line.</td> </tr> <tr> <td><b>tomToggle</b></td> <td>Toggle the TrimPunctuationAtStart property.</td> </tr>
    ///            <tr> <td><b>tomUndefined</b></td> <td>The TrimPunctuationAtStart property is undefined.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetTrimPunctuationAtStart(int Value);
    ///Gets the paragraph format effects.
    ///Params:
    ///    pValue = Type: <b>long*</b> The paragraph effects. This value can be a combination of the following flags. <a
    ///             id="tomParaEffectRTL"></a> <a id="tomparaeffectrtl"></a> <a id="TOMPARAEFFECTRTL"></a>
    ///    pMask = Type: <b>long*</b> The differences in the flags over the range. A value of 1 indicates that the corresponding
    ///            effect is the same over the range. For an insertion point, the values equal 1 for all defined effects.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetEffects(int* pValue, int* pMask);
    ///Gets the value of the specified property.
    ///Params:
    ///    Type = Type: <b>long</b> The ID of the property value to retrieve.
    ///    pValue = Type: <b>long*</b> The property value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetProperty(int Type, int* pValue);
    ///Determines whether this text paragraph object has the same properties as the specified text paragraph object.
    ///Params:
    ///    pPara = Type: <b>ITextPara2*</b> The text paragraph object to compare against.
    ///    pB = Type: <b>long*</b> A tomBool value that is <b>tomTrue</b> if the text paragraph objects have the same
    ///         properties, or <b>tomFalse</b> if they don't. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT IsEqual2(ITextPara2 pPara, int* pB);
    ///Sets the paragraph format effects.
    ///Params:
    ///    Value = Type: <b>long</b> The paragraph effects value. This value can be a combination of the flags defined in the
    ///            table for ITextPara2::GetEffects.
    ///    Mask = Type: <b>long</b> The desired mask. This value can be a combination of the flags defined in the table for
    ///           ITextPara2::GetEffects. Only effects with the corresponding mask flag set are modified.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetEffects(int Value, int Mask);
    ///Sets the property value.
    ///Params:
    ///    Type = Type: <b>long</b> The property ID of the property value to set. See ITextPara2::GetProperty for a list of
    ///           defined properties.
    ///    Value = Type: <b>long</b> The property value to set.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetProperty(int Type, int Value);
}

///The <b>ITextStoryRanges2</b> interface enumerates the stories in an ITextDocument. You get a pointer to an
///<b>ITextStoryRanges2</b> collection by using the ITextDocument::GetStoryRanges method. Each story obtained from this
///collection is represented by an ITextRange2 object that covers the whole story. A Text Object Model (TOM)
///implementation that has only a single story doesn't need to implement the <b>ITextStoryRanges2</b> interface. An
///implementation of this interface should only retrieve a stories collection if ITextDocument::GetStoryCount returns a
///story count greater than one.
@GUID("C241F5E5-7206-11D8-A2C7-00A0D1D6C6B3")
interface ITextStoryRanges2 : ITextStoryRanges
{
    ///Gets an ITextRange2 object for a story, by index, in a stories collection.
    ///Params:
    ///    Index = Type: <b>long</b> The index of the story range. The default value is 1.
    ///    ppRange = Type: <b>ITextRange2**</b> The range.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT Item2(int Index, ITextRange2* ppRange);
}

///The <b>ITextStory</b> interface methods are used to access shared data from multiple stories, which is stored in the
///parent ITextServices instance. The stories can be "edited" simultaneously by using individual ITextRange2 methods,
///and displayed independently of one another. In addition, one story at a time can be UI active; that is, it receives
///keyboard and mouse input. The <b>ITextStory</b> is a lightweight interface that does not require an ITextRange2
///object. This allows the client to manipulate a story, which is a faster, smaller object than a complete editing
///instance.
@GUID("C241F5F3-7206-11D8-A2C7-00A0D1D6C6B3")
interface ITextStory : IUnknown
{
    ///Sets the active state of a story.
    ///Params:
    ///    pValue = Type: <b>long*</b> The active state. It can be one of the following values. <table> <tr> <th>Value</th>
    ///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomDisplayActive"></a><a id="tomdisplayactive"></a><a
    ///             id="TOMDISPLAYACTIVE"></a><dl> <dt><b>tomDisplayActive</b></dt> </dl> </td> <td width="60%"> The story has no
    ///             UI or display (fast and lightweight). </td> </tr> <tr> <td width="40%"><a id="tomDisplayUIActive"></a><a
    ///             id="tomdisplayuiactive"></a><a id="TOMDISPLAYUIACTIVE"></a><dl> <dt><b>tomDisplayUIActive</b></dt> </dl>
    ///             </td> <td width="60%"> The story is UI active; that is, gets keyboard and mouse interactions. </td> </tr>
    ///             <tr> <td width="40%"><a id="tomInactive"></a><a id="tominactive"></a><a id="TOMINACTIVE"></a><dl>
    ///             <dt><b>tomInactive</b></dt> </dl> </td> <td width="60%"> The story has display, but no UI. </td> </tr> <tr>
    ///             <td width="40%"><a id="tomUIActive"></a><a id="tomuiactive"></a><a id="TOMUIACTIVE"></a><dl>
    ///             <dt><b>tomUIActive</b></dt> </dl> </td> <td width="60%"> The story has display and UI activity. </td> </tr>
    ///             </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetActive(int* pValue);
    ///Sets the active state of a story.
    ///Params:
    ///    Value = Type: <b>long</b> The active state. For values, see the ITextStory::GetActive method.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetActive(int Value);
    ///Gets a new display for a story.
    ///Params:
    ///    ppDisplay = Type: <b>IUnknown**</b> The IUnknown interface for a display.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetDisplay(IUnknown* ppDisplay);
    ///Gets the index of a story.
    ///Params:
    ///    pValue = Type: <b>long*</b> The index.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetIndex(int* pValue);
    ///Gets this story's type.
    ///Params:
    ///    pValue = Type: <b>long*</b> This story's type. It can be any of the following values, or a custom client value from
    ///             100 to 65535. <a id="tomCommentsStory"></a> <a id="tomcommentsstory"></a> <a id="TOMCOMMENTSSTORY"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetType(int* pValue);
    ///Sets the story type.
    ///Params:
    ///    Value = Type: <b>long</b> The story type. The type values are defined in ITextStory::GetType.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetType(int Value);
    ///Gets the value of the specified property.
    ///Params:
    ///    Type = Type: <b>long</b> The ID of the property. Currently, no extra properties are defined.
    ///    pValue = Type: <b>long*</b> The property value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetProperty(int Type, int* pValue);
    ///Gets a text range object for the story.
    ///Params:
    ///    cpActive = Type: <b>long</b> The active end of the range.
    ///    cpAnchor = Type: <b>long</b> The anchor end of the range.
    ///    ppRange = Type: <b>ITextRange2**</b> The text range object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT GetRange(int cpActive, int cpAnchor, ITextRange2* ppRange);
    ///Gets the text in a story according to the specified conversion flags.
    ///Params:
    ///    Flags = Type: <b>long</b> The conversion flags. A <i>Flags</i> value of 0 retrieves text the same as
    ///            ITextRange::GetText. Other values include the following. <a id="tomAdjustCRLF"></a> <a
    ///            id="tomadjustcrlf"></a> <a id="TOMADJUSTCRLF"></a>
    ///    pbstr = Type: <b>BSTR*</b> The text in the story.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetText(int Flags, BSTR* pbstr);
    ///Replaces a story’s text with specified formatted text.
    ///Params:
    ///    pUnk = Type: <b>IUnknown*</b> The formatted text to replace the story’s text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetFormattedText(IUnknown pUnk);
    ///Sets the value of the specified property.
    ///Params:
    ///    Type = Type: <b>long</b> The Microsoft accountID that identifies the property. Currently, no extra properties are
    ///           defined.
    ///    Value = Type: <b>long</b> The new property value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetProperty(int Type, int Value);
    ///Replaces the text in a story with the specified text.
    ///Params:
    ///    Flags = Type: <b>long</b> Flags controlling how the text is inserted as defined in the following table: <a
    ///            id="tomCheckTextLimit"></a> <a id="tomchecktextlimit"></a> <a id="TOMCHECKTEXTLIMIT"></a>
    ///    bstr = Type: <b>BSTR</b> The new text for this story. If this parameter is <b>NULL</b>, the text in the story is
    ///           deleted.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetText(int Flags, BSTR bstr);
}

///The <b>ITextStrings</b> interface represents a collection of rich-text strings that are useful for manipulating rich
///text. In particular, you can use the collection to convert linearly formatted math expressions into built-up form and
///vice versa. You can also use the collection to collect the concatenation of a set of rich-text strings, or to
///manipulate a string without changing a primary story. The collection is efficiently implemented by concatenating the
///strings in a scratch story and maintaining an array of the string counts that identify the strings.
@GUID("C241F5E7-7206-11D8-A2C7-00A0D1D6C6B3")
interface ITextStrings : IDispatch
{
    ///Gets an ITextRange2 object for a selected index in a string collection.
    ///Params:
    ///    Index = Type: <b>long</b> The index of the string to retrieve. The default value is 1.
    ///    ppRange = Type: <b>ITextRange2**</b> The object to receive the range.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT Item(int Index, ITextRange2* ppRange);
    ///Gets the number of strings in a string collection.
    ///Params:
    ///    pCount = Type: <b>long*</b> The count of strings.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCount(int* pCount);
    ///Adds a string to the end of the collection.
    ///Params:
    ///    bstr = Type: <b>BSTR</b> The string. The value can be <b>NULL</b> for a null string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT Add(BSTR bstr);
    ///Appends a string to the string at the specified index in the collection.
    ///Params:
    ///    pRange = Type: <b>ITextRange2*</b> The string to append.
    ///    iString = Type: <b>long</b> The string index.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT Append(ITextRange2 pRange, int iString);
    ///Concatenates two strings.
    ///Params:
    ///    iString = Type: <b>long</b> The string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT Cat2(int iString);
    ///Inserts text between the top two strings in a collection.
    ///Params:
    ///    bstr = Type: <b>BSTR</b> The text to insert. The value can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT CatTop2(BSTR bstr);
    ///Deletes the contents of a given range.
    ///Params:
    ///    pRange = Type: <b>ITextRange2*</b> The range to delete.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> Range is not degenerate. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT DeleteRange(ITextRange2 pRange);
    ///Encodes an object, given a set of argument strings.
    ///Params:
    ///    Type = Type: <b>long</b> The object type. See ITextRange2::GetInlineObject for a table of definitions.
    ///    Align = Type: <b>long</b> The object alignment. See ITextRange2::GetInlineObject for a table of definitions.
    ///    Char = Type: <b>long</b> The object character.
    ///    Char1 = Type: <b>long</b> The object character.
    ///    Char2 = Type: <b>long</b> The object character.
    ///    Count = Type: <b>long</b> The count of strings (arguments) to concatenate.
    ///    TeXStyle = Type: <b>long</b> The TeX style.
    ///    cCol = Type: <b>long</b> The count of columns (<b>tomArray</b> only).
    ///    pRange = Type: <b>ITextRange2*</b> The specifying range that points at the desired formatting.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT EncodeFunction(int Type, int Align, int Char, int Char1, int Char2, int Count, int TeXStyle, int cCol, 
                           ITextRange2 pRange);
    ///Gets the count of characters for a selected string index.
    ///Params:
    ///    iString = Type: <b>long</b> The string index.
    ///    pcch = Type: <b>long*</b> The string character count.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCch(int iString, int* pcch);
    ///Inserts a <b>NULL</b> string in the collection at a selected string index.
    ///Params:
    ///    iString = Type: <b>long</b> The string index.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT InsertNullStr(int iString);
    ///Moves the start boundary of a string, by index, for a selected number of characters.
    ///Params:
    ///    iString = Type: <b>long</b> The string index.
    ///    cch = Type: <b>long</b> The selected number of characters to move the boundary.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT MoveBoundary(int iString, int cch);
    ///Prefixes a string to the top string in the collection.
    ///Params:
    ///    bstr = Type: <b>BSTR</b> The string to prefix to the collection.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT PrefixTop(BSTR bstr);
    ///Removes a string from a string collection, starting at an index.
    ///Params:
    ///    iString = Type: <b>long</b> The string index.
    ///    cString = Type: <b>long</b> The count of strings to remove.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT Remove(int iString, int cString);
    ///Replaces text with formatted text.
    ///Params:
    ///    pRangeD = Type: <b>ITextRange2*</b> The text to be replaced.
    ///    pRangeS = Type: <b>ITextRange2*</b> The formatted text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetFormattedText(ITextRange2 pRangeD, ITextRange2 pRangeS);
    ///Sets the character position in the source range's story that has desired character formatting attributes. The
    ///ITextStrings::EncodeFunction method applies those character formatting attributes to the operators specified by
    ///the <i>Char</i>, <i>Char1</i>, and <i>Char2</i> parameters.
    ///Params:
    ///    iString = Type: <b>long</b> The index of the string to associate with a character position.
    ///    cp = Type: <b>long</b> The character position in source range's story that has the desired character formatting.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT SetOpCp(int iString, int cp);
    ///Suffixes a string to the top string in the collection.
    ///Params:
    ///    bstr = Type: <b>BSTR</b> The text to suffix to the top string.
    ///    pRange = Type: <b>ITextRange2*</b> The range with the desired character formatting.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SuffixTop(BSTR bstr, ITextRange2 pRange);
    ///Swaps the top two strings in the collection.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT Swap();
}

///The <b>ITextRow</b> interface provides methods to insert one or more identical table rows, and to retrieve and change
///table row properties. To insert nonidentical rows, call ITextRow::Insert for each different row configuration.
@GUID("C241F5EF-7206-11D8-A2C7-00A0D1D6C6B3")
interface ITextRow : IDispatch
{
    ///Gets the horizontal alignment of a row.
    ///Params:
    ///    pValue = Type: <b>long*</b> The horizontal alignment. It can be one of the following values. <p
    ///             class="indent">tomAlignLeft <p class="indent">tomAlignCenter <p class="indent">tomAlignRight
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetAlignment(int* pValue);
    ///Sets the horizontal alignment of a row.
    ///Params:
    ///    Value = Type: <b>long</b> The new horizontal alignment. It can be one of the following values. <p
    ///            class="indent">tomAlignLeft <p class="indent">tomAlignCenter <p class="indent">tomAlignRight
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetAlignment(int Value);
    ///Gets the count of cells in this row.
    ///Params:
    ///    pValue = Type: <b>long*</b> The cell count for this row.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCellCount(int* pValue);
    ///Sets the count of cells in a row.
    ///Params:
    ///    Value = Type: <b>long</b> The row cell count.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCellCount(int Value);
    ///Gets the count of cells cached for this row.
    ///Params:
    ///    pValue = Type: <b>long*</b> The cached cell count.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCellCountCache(int* pValue);
    ///Sets the count of cells cached for a row.
    ///Params:
    ///    Value = Type: <b>long</b> The cell count.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCellCountCache(int Value);
    ///Gets the index of the active cell to get or set parameters for.
    ///Params:
    ///    pValue = Type: <b>long*</b> The cell index.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCellIndex(int* pValue);
    ///Sets the index of the active cell.
    ///Params:
    ///    Value = Type: <b>long</b> The cell index.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCellIndex(int Value);
    ///Gets the cell margin of this row.
    ///Params:
    ///    pValue = Type: <b>long*</b> The cell margin.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCellMargin(int* pValue);
    ///Sets the cell margin of a row.
    ///Params:
    ///    Value = Type: <b>long</b> The cell margin. The cell margin is used for all cells in the row and is typically about
    ///            108 twips or 0.075 inches.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCellMargin(int Value);
    ///Gets the height of the row.
    ///Params:
    ///    pValue = Type: <b>long*</b> The row height. A value of 0 indicates autoheight.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetHeight(int* pValue);
    ///Sets the height of a row.
    ///Params:
    ///    Value = Type: <b>long</b> The row height. A value of 0 indicates autoheight.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetHeight(int Value);
    ///Gets the indent of this row.
    ///Params:
    ///    pValue = Type: <b>long*</b> The indent of the row.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetIndent(int* pValue);
    ///Sets the indent of a row.
    ///Params:
    ///    Value = Type: <b>long</b> The row indent.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetIndent(int Value);
    ///Gets whether this row is allowed to be broken across pages.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that indicates whether this row can be broken across pages.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetKeepTogether(int* pValue);
    ///Sets whether this row is allowed to be broken across pages.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that indicates whether this row can be broken across pages.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetKeepTogether(int Value);
    ///Gets whether this row should appear on the same page as the row that follows it.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that indicates whether this row should be kept on the same page as the
    ///             following row.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetKeepWithNext(int* pValue);
    ///Sets whether a row should appear on the same page as the row that follows it.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that indicates whether a row should appear on the same page as the row that
    ///            follows it.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetKeepWithNext(int Value);
    ///Gets the nest level of a table.
    ///Params:
    ///    pValue = Type: <b>long*</b> The nest level.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetNestLevel(int* pValue);
    ///Gets whether this row has right-to-left orientation.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool value that indicates whether this row has right-to-left orientation.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetRTL(int* pValue);
    ///Sets whether this row has right-to-left orientation.
    ///Params:
    ///    Value = Type: <b>long</b> A tomBool value that can be one of the following. <table> <tr> <th>Value</th>
    ///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="tomTrue"></a><a id="tomtrue"></a><a id="TOMTRUE"></a><dl>
    ///            <dt><b>tomTrue</b></dt> </dl> </td> <td width="60%"> Right-to-left orientation. </td> </tr> <tr> <td
    ///            width="40%"><a id="tomFalse"></a><a id="tomfalse"></a><a id="TOMFALSE"></a><dl> <dt><b>tomFalse</b></dt>
    ///            </dl> </td> <td width="60%"> Left-to-right orientation. </td> </tr> <tr> <td width="40%"><a
    ///            id="tomToggle"></a><a id="tomtoggle"></a><a id="TOMTOGGLE"></a><dl> <dt><b>tomToggle</b></dt> </dl> </td> <td
    ///            width="60%"> Toggles the orientation. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetRTL(int Value);
    ///Gets the vertical alignment of the active cell.
    ///Params:
    ///    pValue = Type: <b>long*</b> The vertical alignment.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCellAlignment(int* pValue);
    ///Sets the vertical alignment of the active cell.
    ///Params:
    ///    Value = Type: <b>long</b> The vertical alignment.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCellAlignment(int Value);
    ///Gets the background color of the active cell.
    ///Params:
    ///    pValue = Type: <b>long*</b> The background color.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCellColorBack(int* pValue);
    ///Sets the background color of the active cell.
    ///Params:
    ///    Value = Type: <b>long</b> The background color.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCellColorBack(int Value);
    ///Gets the foreground color of the active cell.
    ///Params:
    ///    pValue = Type: <b>long*</b> The foreground color.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns the
    ///    following COM error code. For more information about COM error codes, see Error Handling in COM. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT GetCellColorFore(int* pValue);
    ///Sets the foreground color of the active cell.
    ///Params:
    ///    Value = Type: <b>long</b> The foreground color.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCellColorFore(int Value);
    ///Gets the merge flags of the active cell.
    ///Params:
    ///    pValue = Type: <b>long*</b> The merge flag of the active cell. The flag can be one of the following: <a
    ///             id="tomHContCell"></a> <a id="tomhcontcell"></a> <a id="TOMHCONTCELL"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCellMergeFlags(int* pValue);
    ///Sets the merge flags of the active cell.
    ///Params:
    ///    Value = Type: <b>long</b> The merge flag. It can be one of these values. <a id="tomHContCell"></a> <a
    ///            id="tomhcontcell"></a> <a id="TOMHCONTCELL"></a>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCellMergeFlags(int Value);
    ///Gets the shading of the active cell.
    ///Params:
    ///    pValue = Type: <b>long*</b> The shading of the active cell. See Remarks.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCellShading(int* pValue);
    ///Sets the shading of the active cell.
    ///Params:
    ///    Value = Type: <b>long</b> The shading of the active cell.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCellShading(int Value);
    ///Gets the vertical-text setting of the active cell.
    ///Params:
    ///    pValue = Type: <b>long*</b> The vertical-text setting
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCellVerticalText(int* pValue);
    ///Sets the vertical-text setting of the active cell.
    ///Params:
    ///    Value = Type: <b>long</b> The vertical setting.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCellVerticalText(int Value);
    ///Gets the width of the active cell.
    ///Params:
    ///    pValue = Type: <b>long*</b> The width of the active cell, in twips.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCellWidth(int* pValue);
    ///Sets the active cell width in twips.
    ///Params:
    ///    Value = Type: <b>long</b> The width of the active cell.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCellWidth(int Value);
    ///Gets the border colors of the active cell.
    ///Params:
    ///    pcrLeft = Type: <b>long*</b> The active-cell left border color.
    ///    pcrTop = Type: <b>long*</b> The active-cell top border color.
    ///    pcrRight = Type: <b>long*</b> The active-cell right border color.
    ///    pcrBottom = Type: <b>long*</b> The active-cell bottom border color.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCellBorderColors(int* pcrLeft, int* pcrTop, int* pcrRight, int* pcrBottom);
    ///Gets the border widths of the active cell.
    ///Params:
    ///    pduLeft = Type: <b>long*</b> The active-cell left border width.
    ///    pduTop = Type: <b>long*</b> The active-cell top border width.
    ///    pduRight = Type: <b>long*</b> The active-cell right border width.
    ///    pduBottom = Type: <b>long*</b> The active-cell bottom border width.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetCellBorderWidths(int* pduLeft, int* pduTop, int* pduRight, int* pduBottom);
    ///Sets the border colors of the active cell.
    ///Params:
    ///    crLeft = Type: <b>long</b> The left border color.
    ///    crTop = Type: <b>long</b> The top border color.
    ///    crRight = Type: <b>long</b> The right border color.
    ///    crBottom = Type: <b>long</b> The bottom border color.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCellBorderColors(int crLeft, int crTop, int crRight, int crBottom);
    ///Sets the border widths of the active cell.
    ///Params:
    ///    duLeft = Type: <b>long</b> The left border width.
    ///    duTop = Type: <b>long</b> The top border width.
    ///    duRight = Type: <b>long</b> The right border width.
    ///    duBottom = Type: <b>long</b> The bottom border width.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetCellBorderWidths(int duLeft, int duTop, int duRight, int duBottom);
    ///Applies the formatting attributes of this text row object to the specified rows in the associated ITextRange2.
    ///Params:
    ///    cRow = Type: <b>long</b> The number of rows to apply this text row object to.
    ///    Flags = Type: <b>long</b> A flag that controls how the formatting attributes are applied. It can be one of the
    ///            following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///            id="tomCellStructureChangeOnly"></a><a id="tomcellstructurechangeonly"></a><a
    ///            id="TOMCELLSTRUCTURECHANGEONLY"></a><dl> <dt><b>tomCellStructureChangeOnly</b></dt> </dl> </td> <td
    ///            width="60%"> Apply formatting attributes only to cell widths or the cell count (enables you to change column
    ///            widths or insert/delete columns without changing other properties, such as cell borders). </td> </tr> <tr>
    ///            <td width="40%"><a id="tomRowApplyDefault"></a><a id="tomrowapplydefault"></a><a
    ///            id="TOMROWAPPLYDEFAULT"></a><dl> <dt><b>tomRowApplyDefault</b></dt> </dl> </td> <td width="60%"> Apply
    ///            formatting attributes to the full application, not just cell widths and count. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT Apply(int cRow, int Flags);
    ///Determines whether changes can be made to this row.
    ///Params:
    ///    pValue = Type: <b>long*</b> A tomBool indicating whether the row can be edited. It is <b>tomTrue</b> only if the row
    ///             can be edited. The <i>pB</i> paraemeter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT CanChange(int* pValue);
    ///Gets the value of the specified property.
    ///Params:
    ///    Type = Type: <b>long</b> The ID of the property to retrieve.
    ///    pValue = Type: <b>long*</b> The value for the property.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT GetProperty(int Type, int* pValue);
    ///Inserts a row, or rows, at the location identified by the associated ITextRange2 object.
    ///Params:
    ///    cRow = Type: <b>long</b> The number of rows to insert.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT Insert(int cRow);
    ///Compares two table rows to determine if they have the same properties.
    ///Params:
    ///    pRow = Type: <b>ITextRow*</b> The row to compare to.
    ///    pB = Type: <b>long*</b> The comparison result. The value is set to <b>tomTrue</b> if equal, and <b>tomFalse</b> if
    ///         not. The value can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT IsEqual(ITextRow pRow, int* pB);
    ///Resets a row.
    ///Params:
    ///    Value = Type: <b>long</b> The tomRowUpdate reset value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>S_OK</b>. If the method fails, it returns one of
    ///    the following COM error codes. For more information about COM error codes, see Error Handling in COM. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Write access is denied. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT Reset(int Value);
    ///Sets the value of the specified property.
    ///Params:
    ///    Type = Type: <b>long</b> The ID of the property to set.
    ///    Value = Type: <b>long</b> The value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns <b>NOERROR</b>. Otherwise, it returns an
    ///    <b>HRESULT</b> error code.
    ///    
    HRESULT SetProperty(int Type, int Value);
}

///Represents the displays collection for this Text Object Model (TOM) engine instance.
@GUID("C241F5F2-7206-11D8-A2C7-00A0D1D6C6B3")
interface ITextDisplays : IDispatch
{
}

@GUID("01C25500-4268-11D1-883A-3C8B00C10000")
interface ITextDocument2Old : ITextDocument
{
    HRESULT AttachMsgFilter(IUnknown pFilter);
    HRESULT SetEffectColor(int Index, uint cr);
    HRESULT GetEffectColor(int Index, uint* pcr);
    HRESULT GetCaretType(int* pCaretType);
    HRESULT SetCaretType(int CaretType);
    HRESULT GetImmContext(long* pContext);
    HRESULT ReleaseImmContext(long Context);
    HRESULT GetPreferredFont(int cp, int CharRep, int Option, int CharRepCur, int curFontSize, BSTR* pbstr, 
                             int* pPitchAndFamily, int* pNewFontSize);
    HRESULT GetNotificationMode(int* pMode);
    HRESULT SetNotificationMode(int Mode);
    HRESULT GetClientRect(int Type, int* pLeft, int* pTop, int* pRight, int* pBottom);
    HRESULT GetSelection2(ITextSelection* ppSel);
    HRESULT GetWindow(int* phWnd);
    HRESULT GetFEFlags(int* pFlags);
    HRESULT UpdateWindow();
    HRESULT CheckTextLimit(int cch, int* pcch);
    HRESULT IMEInProgress(int Value);
    HRESULT SysBeep();
    HRESULT Update(int Mode);
    HRESULT Notify(int Notify);
    HRESULT GetDocumentFont(ITextFont* ppITextFont);
    HRESULT GetDocumentPara(ITextPara* ppITextPara);
    HRESULT GetCallManager(IUnknown* ppVoid);
    HRESULT ReleaseCallManager(IUnknown pVoid);
}

///The <b>IRichEditOle</b> interface exposes the Component Object Model (COM) functionality of a rich edit control. The
///interface can be obtained by sending the EM_GETOLEINTERFACE message. This interface has the following methods.
interface IRichEditOle : IUnknown
{
    ///Retrieves an IOleClientSite interface to be used when creating a new object. All objects inserted into a rich
    ///edit control must use client site interfaces returned by this function. A client site may be used with exactly
    ///one object.
    ///Params:
    ///    lplpolesite = Type: <b>LPOLECLIENTSITE*</b> The address of the IOleClientSite interface.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success, or a failure code otherwise. <b>E_OUTOFMEMORY</b> is
    ///    returned if memory could not be allocated for the client site.
    ///    
    HRESULT GetClientSite(IOleClientSite* lplpolesite);
    ///Returns the number of objects currently contained in a rich edit control.
    ///Returns:
    ///    Type: <b>LONG</b> This method returns the number of objects.
    ///    
    int     GetObjectCount();
    ///Returns the number of objects in a rich edit control that are links.
    ///Returns:
    ///    Type: <b>LONG</b> This method returns the number of links.
    ///    
    int     GetLinkCount();
    HRESULT GetObjectA(int iob, REOBJECT* lpreobject, uint dwFlags);
    ///Inserts an object into a rich edit control.
    ///Params:
    ///    lpreobject = Type: <b>REOBJECT*</b> The object information and interfaces. The rich edit control automatically increments
    ///                 the reference count for the interfaces if it holds onto them, so the caller can safely release the interfaces
    ///                 if they are not needed.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK on success, or a failure code otherwise. E_OUTOFMEMORY is returned if
    ///    memory could not be allocated to insert the object.
    ///    
    HRESULT InsertObject(REOBJECT* lpreobject);
    ///Converts an object to a new type. This call reloads the object but does not force an update; the caller must do
    ///this.
    ///Params:
    ///    iob = Type: <b>LONG</b> Index of the object to convert. If this parameter is REO_IOB_SELECTION, the selected object
    ///          is to be converted.
    ///    rclsidNew = Type: <b>REFCLSID</b> Class identifier of the class to which the object is converted.
    ///    lpstrUserTypeNew = Type: <b>LPCSTR</b> User-visible type name of the class to which the object is converted.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK on success, or a failure code otherwise. E_INVALIDARG is returned if the
    ///    index is invalid.
    ///    
    HRESULT ConvertObject(int iob, const(GUID)* rclsidNew, const(PSTR) lpstrUserTypeNew);
    ///Handles <b>Activate As</b> behavior by unloading all objects of the old class, telling OLE to treat those objects
    ///as objects of the new class, and reloading the objects. If objects cannot be reloaded, they are deleted.
    ///Params:
    ///    rclsid = Type: <b>REFCLSID</b> Class identifier of the old class.
    ///    rclsidAs = Type: <b>REFCLSID</b> Class identifier of the new class.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK on success, or a failure code otherwise.
    ///    
    HRESULT ActivateAs(const(GUID)* rclsid, const(GUID)* rclsidAs);
    ///Sets the host names to be given to objects as they are inserted to a rich edit control. The host names are used
    ///in the user interface of servers to describe the container context of opened objects.
    ///Params:
    ///    lpstrContainerApp = Type: <b>LPCSTR</b> Null-terminated name of the container application.
    ///    lpstrContainerObj = Type: <b>LPCSTR</b> Null-terminated name of the container document or object.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK on success, or a failure code otherwise. E_OUTOFMEMORY is returned if
    ///    memory could not be allocated to remember the strings.
    ///    
    HRESULT SetHostNames(const(PSTR) lpstrContainerApp, const(PSTR) lpstrContainerObj);
    ///Sets the value of the link-available bit in the object's flags. The link-available bit defaults to <b>TRUE</b>.
    ///It should be set to <b>FALSE</b> if any errors occur on the link which would indicate problems connecting to the
    ///linked object or application. When those problems are repaired, the bit should be set to <b>TRUE</b> again.
    ///Params:
    ///    iob = Type: <b>LONG</b> Index of object whose bit is to be set. If this parameter is REO_IOB_SELECTION, the bit on
    ///          the selected object is to be set.
    ///    fAvailable = Type: <b>BOOL</b> Value used in the set operation. The value can be <b>TRUE</b> or <b>FALSE</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK on success, or a failure code otherwise. E_INVALIDARG is returned if the
    ///    index is invalid.
    ///    
    HRESULT SetLinkAvailable(int iob, BOOL fAvailable);
    ///Sets the aspect that a rich edit control uses to draw an object. This call does not change the drawing
    ///information cached in the object; this must be done by the caller. The call does cause the object to be redrawn.
    ///Params:
    ///    iob = Type: <b>LONG</b> Index of the object whose aspect is to be set. If this parameter is REO_IOB_SELECTION, the
    ///          aspect of the selected object is to be set.
    ///    dvaspect = Type: <b>DWORD</b> Aspect to use when drawing. The values are defined by OLE.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK on success, or a failure code otherwise. E_INVALIDARG is returned if the
    ///    index is invalid.
    ///    
    HRESULT SetDvaspect(int iob, uint dvaspect);
    ///Indicates when a rich edit control is to release its reference to the storage interface associated with the
    ///specified object. This call does not call the object's <b>IRichEditOle::HandsOffStorage</b> method; the caller
    ///must do that.
    ///Params:
    ///    iob = Type: <b>LONG</b> Index of the object whose storage is to be released. If this parameter is
    ///          REO_IOB_SELECTION, the storage of the selected object is to be released.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK on success, or a failure code otherwise. E_INVALIDARG is returned if the
    ///    index is invalid.
    ///    
    HRESULT HandsOffStorage(int iob);
    ///Indicates when the most recent save operation has been completed and that the rich edit control should hold onto
    ///a different storage for the object.
    ///Params:
    ///    iob = Type: <b>LONG</b> Index of the object whose storage is being specified. If this parameter is
    ///          REO_IOB_SELECTION, the selected object is used.
    ///    lpstg = Type: <b>LPSTORAGE</b> New storage for the object. If the storage is not <b>NULL</b>, the rich edit control
    ///            releases any storage it is currently holding for the object and uses this new storage instead.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK on success, or a failure code otherwise. E_INVALIDARG is returned if the
    ///    index is invalid.
    ///    
    HRESULT SaveCompleted(int iob, IStorage lpstg);
    ///Indicates when a rich edit control is to deactivate the currently active in-place object, if any.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK on success, or a failure code otherwise. If there is no active in-place
    ///    object, the method succeeds.
    ///    
    HRESULT InPlaceDeactivate();
    ///Indicates if a rich edit control should transition into or out of context-sensitive help mode. A rich edit
    ///control calls the <b>IRichEditOle::ContextSensitiveHelp</b> method of any in-place object which is currently
    ///active if a state change is occurring.
    ///Params:
    ///    fEnterMode = Type: <b>BOOL</b> Indicator of whether the control is entering context-sensitive help mode (<b>TRUE</b>) or
    ///                 leaving it (<b>FALSE</b>).
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK on success, or a failure code otherwise.
    ///    
    HRESULT ContextSensitiveHelp(BOOL fEnterMode);
    ///Retrieves a clipboard object for a range in an edit control.
    ///Params:
    ///    lpchrg = Type: <b>CHARRANGE*</b> The range for which to create the clipboard object.
    ///    reco = Type: <b>DWORD</b> Unused.
    ///    lplpdataobj = Type: <b>LPDATAOBJECT*</b> The IDataObject interface of the clipboard object representing the range specified
    ///                  in the <i>lpchrg</i> parameter.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success. If the method fails, it can return one of the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> There was an invalid argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There was not enough memory to
    ///    do the operation. </td> </tr> </table>
    ///    
    HRESULT GetClipboardData(CHARRANGE* lpchrg, uint reco, IDataObject* lplpdataobj);
    ///Imports a clipboard object into a rich edit control, replacing the current selection.
    ///Params:
    ///    lpdataobj = Type: <b>LPDATAOBJECT</b> The clipboard object to import.
    ///    cf = Type: <b>CLIPFORMAT</b> Clipboard format to use. A value of zero will use the best available format.
    ///    hMetaPict = Type: <b>HGLOBAL</b> Handle to a metafile containing the icon view of an object. The handle is used only if
    ///                the <b>DVASPECT_ICON</b> display aspect is required by a Paste Special operation.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success. If the method fails, it can return one of the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> There was an invalid argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There was not enough memory to
    ///    do the operation. </td> </tr> </table>
    ///    
    HRESULT ImportDataObject(IDataObject lpdataobj, ushort cf, ptrdiff_t hMetaPict);
}

///The <b>IRichEditOleCallback</b> interface is used by a rich text edit control to retrieve OLE-related information
///from its client. A rich edit control client is responsible for implementing this interface and assigning it to the
///control by using the EM_SETOLECALLBACK message.
interface IRichEditOleCallback : IUnknown
{
    ///Provides storage for a new object pasted from the clipboard or read in from an Rich Text Format (RTF) stream.
    ///Params:
    ///    lplpstg = Type: <b>LPSTORAGE*</b> The address of the IStorage interface created for the new object.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success. If the method fails, it can return one of the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> There was an invalid argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There was not enough memory to
    ///    do the operation. </td> </tr> </table>
    ///    
    HRESULT GetNewStorage(IStorage* lplpstg);
    ///Provides the application and document-level interfaces and information required to support in-place activation.
    ///Params:
    ///    lplpFrame = Type: <b>LPOLEINPLACEFRAME*</b> The address of the IOleInPlaceFrame interface that represents the frame
    ///                window of a rich edit control client. Use the AddRef method to increment the reference count. The rich edit
    ///                control releases the interface when it is no longer needed.
    ///    lplpDoc = Type: <b>LPOLEINPLACEUIWINDOW*</b> The address of the IOleInPlaceUIWindow interface that represents the
    ///              document window of the rich edit control client. An interface need not be returned if the frame and document
    ///              windows are the same. Use the AddRefmethod to increment the reference count. The rich edit control releases
    ///              the interface when it is no longer needed.
    ///    lpFrameInfo = Type: <b>LPOLEINPLACEFRAMEINFO</b> The accelerator information.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success. If the method fails, it can return the following value.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> There was an invalid argument. </td> </tr> </table>
    ///    
    HRESULT GetInPlaceContext(IOleInPlaceFrame* lplpFrame, IOleInPlaceUIWindow* lplpDoc, OIFI* lpFrameInfo);
    ///Indicates whether or not the application is to display its container UI. The rich edit control looks ahead for
    ///double-clicks and defers the call if appropriate. Applications may defer hiding adornments until an
    ///IOleInPlaceUIWindow::SetBorderSpace call is received.
    ///Params:
    ///    fShow = Type: <b>BOOL</b> Show container UI flag. The value is <b>TRUE</b> if the container UI is displayed, and
    ///            <b>FALSE</b> if it is not.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success. If the method fails, it can return the following value.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> There was an invalid argument. </td> </tr> </table>
    ///    
    HRESULT ShowContainerUI(BOOL fShow);
    ///Queries the application as to whether an object should be inserted. The member is called when pasting and when
    ///reading Rich Text Format (RTF).
    ///Params:
    ///    lpclsid = Type: <b>LPCLSID</b> Class identifier of the object to be inserted.
    ///    lpstg = Type: <b>LPSTORAGE</b> Storage containing the object.
    ///    cp = Type: <b>LONG</b> Character position, at which the object will be inserted.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK on success. If the return value is not S_OK, the object was not inserted.
    ///    If the method fails, it can return the following value. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> There was an invalid argument. </td> </tr> </table>
    ///    
    HRESULT QueryInsertObject(GUID* lpclsid, IStorage lpstg, int cp);
    ///Sends notification that an object is about to be deleted from a rich edit control. The object is not necessarily
    ///being released when this member is called.
    ///Params:
    ///    lpoleobj = Type: <b>LPOLEOBJECT</b> The object that is being deleted.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b>.
    ///    
    HRESULT DeleteObject(IOleObject lpoleobj);
    ///During a paste operation or a drag event, determines if the data that is pasted or dragged should be accepted.
    ///Params:
    ///    lpdataobj = Type: <b>LPDATAOBJECT</b> The data object being pasted or dragged.
    ///    lpcfFormat = Type: <b>CLIPFORMAT*</b> The clipboard format that will be used for the paste or drop operation. If the value
    ///                 pointed to by <i>lpcfFormat</i> is zero, the best available format will be used. If the callback changes the
    ///                 value pointed to by <i>lpcfFormat</i>, the rich edit control only uses that format and the operation will
    ///                 fail if the format is not available.
    ///    reco = Type: <b>DWORD</b> A clipboard operation flag, which can be one of these values. <table> <tr> <th>Value</th>
    ///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="RECO_DROP"></a><a id="reco_drop"></a><dl>
    ///           <dt><b>RECO_DROP</b></dt> </dl> </td> <td width="60%"> Drop operation (drag-and-drop). </td> </tr> <tr> <td
    ///           width="40%"><a id="RECO_PASTE"></a><a id="reco_paste"></a><dl> <dt><b>RECO_PASTE</b></dt> </dl> </td> <td
    ///           width="60%"> Paste from the clipboard. </td> </tr> </table>
    ///    fReally = Type: <b>BOOL</b> Indicates whether the drag-drop is actually happening or if it is just a query. A nonzero
    ///              value indicates the paste or drop is actually happening. A zero value indicates the operation is just a
    ///              query, such as for EM_CANPASTE.
    ///    hMetaPict = Type: <b>HGLOBAL</b> Handle to a metafile containing the icon view of an object if <b>DVASPECT_ICON</b> is
    ///                being imposed on an object by a paste special operation.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success. See Remarks.
    ///    
    HRESULT QueryAcceptData(IDataObject lpdataobj, ushort* lpcfFormat, uint reco, BOOL fReally, 
                            ptrdiff_t hMetaPict);
    ///Indicates if the application should transition into or out of context-sensitive help mode. This method should
    ///implement the functionality described for IOleWindow::ContextSensitiveHelp.
    ///Params:
    ///    fEnterMode = Type: <b>BOOL</b> If <b>TRUE</b>, the application should enter context-sensitive help mode. If <b>FALSE</b>,
    ///                 the application should leave context-sensitive help mode.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success. If the method fails, it can be the following value.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> There was an invalid argument. </td> </tr> </table>
    ///    
    HRESULT ContextSensitiveHelp(BOOL fEnterMode);
    ///Allows the client to supply its own clipboard object.
    ///Params:
    ///    lpchrg = Type: <b>CHARRANGE*</b> The clipboard object range.
    ///    reco = Type: <b>DWORD</b> The clipboard operation flag can be one of these values. <table> <tr> <th>Value</th>
    ///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="RECO_COPY"></a><a id="reco_copy"></a><dl>
    ///           <dt><b>RECO_COPY</b></dt> </dl> </td> <td width="60%"> Copy to the clipboard. </td> </tr> <tr> <td
    ///           width="40%"><a id="RECO_CUT"></a><a id="reco_cut"></a><dl> <dt><b>RECO_CUT</b></dt> </dl> </td> <td
    ///           width="60%"> Cut to the clipboard. </td> </tr> </table>
    ///    lplpdataobj = Type: <b>LPDATAOBJECT*</b> Pointer to the pointer variable that receives the address of the IDataObject
    ///                  implementation representing the range specified in the <i>lpchrg</i> parameter. The value of
    ///                  <i>lplpdataobj</i> is ignored if an error is returned.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success. If the return value is <b>E_NOTIMPL</b>, the rich edit
    ///    control created its own clipboard object. If the return value is a failure other than <b>E_NOTIMPL</b>, the
    ///    operation failed.
    ///    
    HRESULT GetClipboardData(CHARRANGE* lpchrg, uint reco, IDataObject* lplpdataobj);
    ///Allows the client to specify the effects of a drop operation.
    ///Params:
    ///    fDrag = Type: <b>BOOL</b> <b>TRUE</b> if the query is for a IDropTarget::DragEnter or IDropTarget::DragOver.
    ///            <b>FALSE</b> if the query is for IDropTarget::Drop.
    ///    grfKeyState = Type: <b>DWORD</b> Key state as defined by OLE.
    ///    pdwEffect = Type: <b>LPDWORD</b> The effect used by a rich edit control. When <i>fDrag</i> is <b>TRUE</b>, on return, its
    ///                content is set to the effect allowable by the rich edit control. When <i>fDrag</i> is <b>FALSE</b>, on
    ///                return, the variable is set to the effect to use.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns <b>S_OK</b>.
    ///    
    HRESULT GetDragDropEffect(BOOL fDrag, uint grfKeyState, uint* pdwEffect);
    ///Queries the application for a context menu to use on a right-click event.
    ///Params:
    ///    seltype = Type: <b>WORD</b> Selection type. The value, which specifies the contents of the new selection, can be one or
    ///              more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///              id="SEL_EMPTY"></a><a id="sel_empty"></a><dl> <dt><b>SEL_EMPTY</b></dt> </dl> </td> <td width="60%"> The
    ///              selection is empty. </td> </tr> <tr> <td width="40%"><a id="SEL_TEXT"></a><a id="sel_text"></a><dl>
    ///              <dt><b>SEL_TEXT</b></dt> </dl> </td> <td width="60%"> Text. </td> </tr> <tr> <td width="40%"><a
    ///              id="SEL_OBJECT"></a><a id="sel_object"></a><dl> <dt><b>SEL_OBJECT</b></dt> </dl> </td> <td width="60%"> At
    ///              least one COM object. </td> </tr> <tr> <td width="40%"><a id="SEL_MULTICHAR"></a><a
    ///              id="sel_multichar"></a><dl> <dt><b>SEL_MULTICHAR</b></dt> </dl> </td> <td width="60%"> More than one
    ///              character of text. </td> </tr> <tr> <td width="40%"><a id="SEL_MULTIOBJECT"></a><a
    ///              id="sel_multiobject"></a><dl> <dt><b>SEL_MULTIOBJECT</b></dt> </dl> </td> <td width="60%"> More than one COM
    ///              object. </td> </tr> <tr> <td width="40%"><a id="GCM_RIGHTMOUSEDROP"></a><a id="gcm_rightmousedrop"></a><dl>
    ///              <dt><b>GCM_RIGHTMOUSEDROP</b></dt> </dl> </td> <td width="60%"> Indicates that a context menu for a
    ///              right-mouse drag drop should be generated. The <i>lpoleobj</i> parameter is a pointer to the IDataObject
    ///              interface for the object being dropped. </td> </tr> </table>
    ///    lpoleobj = Type: <b>LPOLEOBJECT</b> Pointer to an interface. If the <i>seltype</i> parameter includes the
    ///               <b>SEL_OBJECT</b> flag, <i>lpoleobj</i> is a pointer to the IOleObject interface for the first selected COM
    ///               object. If <i>seltype</i> includes the <b>GCM_RIGHTMOUSEDROP</b> flag, <i>lpoleobj</i> is a pointer to an
    ///               IDataObject interface. Otherwise, <i>lpoleobj</i> is <b>NULL</b>. If you hold on to the interface pointer,
    ///               you must call the AddRef method to increment the object's reference count.
    ///    lpchrg = Type: <b>CHARRANGE*</b> Pointer to a CHARRANGE structure containing the current selection.
    ///    lphmenu = Type: <b>HMENU*</b> The handle of a context menu to use. This parameter is ignored if an error is returned. A
    ///              rich edit control destroys the menu when it is finished with it so the client should not.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success. If the method fails, it can be the following value.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> There was an invalid argument. </td> </tr> </table>
    ///    
    HRESULT GetContextMenu(ushort seltype, IOleObject lpoleobj, CHARRANGE* lpchrg, HMENU* lphmenu);
}

///Extends the Text Object Model (TOM) to provide extra functionality for windowless operation.
interface ITextServices : IUnknown
{
    ///Used by the window host to forward messages sent from its window to the text services object.
    ///Params:
    ///    msg = Type: <b>UINT</b> The message identifier.
    ///    wparam = Type: <b>WPARAM</b> The <b>WPARAM</b> from the window's message.
    ///    lparam = Type: <b>LPARAM</b> The <b>LPARAM</b> from the window's message.
    ///    plresult = Type: <b>LRESULT*</b> The message's return <b>LRESULT</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, the return value is <b>S_OK</b>. If the method fails, the return
    ///    value is one of the following <b>HRESULT</b> codes. For more information on COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. NOERROR Message was
    ///    processed, and some action was taken. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> Message was not processed. Typically indicates that the caller should process the
    ///    message itself, potentially by calling DefWindowProc. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_MSG_KEYIGNORED</b></dt> </dl> </td> <td width="60%"> Message processed, but no action was taken for
    ///    the keystroke. </td> </tr> </table>
    ///    
    HRESULT TxSendMessage(uint msg, WPARAM wparam, LPARAM lparam, LRESULT* plresult);
    ///Draws the text services object.
    ///Params:
    ///    dwDrawAspect = Type: <b>DWORD</b> Specifies the aspect to be drawn, that is, how the object is to be represented. Draw
    ///                   aspect can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///                   width="40%"><a id="DVASPECT_CONTENT"></a><a id="dvaspect_content"></a><dl> <dt><b>DVASPECT_CONTENT</b></dt>
    ///                   </dl> </td> <td width="60%"> Renders a screen image of the text content to the <i>hdcDraw</i> device context.
    ///                   The <i>hicTargetDev</i> and <i>ptd</i> parameters give information on the target device context if any
    ///                   (usually a printer). </td> </tr> <tr> <td width="40%"><a id="DVASPECT_DOCPRINT"></a><a
    ///                   id="dvaspect_docprint"></a><dl> <dt><b>DVASPECT_DOCPRINT</b></dt> </dl> </td> <td width="60%"> Renders the
    ///                   object to the <i>hdcDraw</i> device context as though it were printed to a printer. Thus, the text services
    ///                   object can optimize for the printer (for example, not painting the background color, if white). Also, certain
    ///                   screen-specific elements (such as the selection) should not be rendered. <b>ITextServices::TxDraw</b> should
    ///                   render the <i>lprcBounds</i> rectangle, starting at the current scrolling position. </td> </tr> </table>
    ///    lindex = Type: <b>LONG</b> Not supported.
    ///    pvAspect = Type: <b>void*</b> Information for drawing optimizations.
    ///    ptd = Type: <b>DVTARGETDEVICE*</b> The target device.
    ///    hdcDraw = Type: <b>HDC</b> Rendering device context.
    ///    hicTargetDev = Type: <b>HDC</b> Target information context.
    ///    lprcBounds = Type: <b>LPCRECTL</b> The bounding (client) rectangle.
    ///    lprcWBounds = Type: <b>LPCRECTL</b> The clipping rectangle for metafiles.
    ///    lprcUpdate = Type: <b>LPRECT</b> The update region inside <i>lprcBounds</i>.
    ///    pfnContinue = Type: <b>BOOL CALLBACK*</b> Not supported.
    ///    dwContinue = Type: <b>DWORD</b> Parameter to pass to continue function.
    ///    lViewId = Type: <b>LONG</b> Specifies the view to draw. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///              width="40%"><a id="TXTVIEW_ACTIVE"></a><a id="txtview_active"></a><dl> <dt><b>TXTVIEW_ACTIVE</b></dt> </dl>
    ///              </td> <td width="60%"> Draw the inplace active view. </td> </tr> <tr> <td width="40%"><a
    ///              id="TXTVIEW_INACTIVE"></a><a id="txtview_inactive"></a><dl> <dt><b>TXTVIEW_INACTIVE</b></dt> </dl> </td> <td
    ///              width="60%"> Draw a view other than the inplace active view; for example, a print preview. </td> </tr>
    ///              </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> The return value is typically <b>S_OK</b>.
    ///    
    HRESULT TxDraw(uint dwDrawAspect, int lindex, void* pvAspect, DVTARGETDEVICE* ptd, HDC hdcDraw, 
                   HDC hicTargetDev, RECTL* lprcBounds, RECTL* lprcWBounds, RECT* lprcUpdate, 
                   BOOL********** pfnContinue, uint dwContinue, int lViewId);
    ///Returns horizontal scroll bar information.
    ///Params:
    ///    plMin = Type: <b>LONG*</b> The minimum scroll position.
    ///    plMax = Type: <b>LONG*</b> The maximum scroll position.
    ///    plPos = Type: <b>LONG*</b> The current scroll position.
    ///    plPage = Type: <b>LONG*</b> The view width, in pixels.
    ///    pfEnabled = Type: <b>BOOL*</b> Indicates whether horizontal scrolling is enabled. If <b>TRUE</b>, horizontal scrolling is
    ///                enabled.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method always returns <b>S_OK</b>.
    ///    
    HRESULT TxGetHScroll(int* plMin, int* plMax, int* plPos, int* plPage, BOOL* pfEnabled);
    ///Returns vertical scroll bar state information.
    ///Params:
    ///    plMin = Type: <b>LONG*</b> The minimum scroll position.
    ///    plMax = Type: <b>LONG*</b> The maximum scroll position.
    ///    plPos = Type: <b>LONG*</b> The current scroll position.
    ///    plPage = Type: <b>LONG*</b> The height of view in pixels.
    ///    pfEnabled = Type: <b>BOOL*</b> Indicates whether the vertical scroll bar is enabled. If <b>TRUE</b>, the vertical scroll
    ///                bar is enabled; otherwise it is disabled.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, the return value is <b>S_OK</b>. If the method fails, the return
    ///    value is one of the following <b>HRESULT</b> codes. For more information on COM error codes, see Error
    ///    Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more arguments are not valid. </td> </tr>
    ///    </table>
    ///    
    HRESULT TxGetVScroll(int* plMin, int* plMax, int* plPos, int* plPage, BOOL* pfEnabled);
    ///Notifies the text services object to set the cursor.
    ///Params:
    ///    dwDrawAspect = Type: <b>DWORD</b> Draw aspect can be one of the following values. <table> <tr> <th>Value</th>
    ///                   <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DVASPECT_CONTENT"></a><a id="dvaspect_content"></a><dl>
    ///                   <dt><b>DVASPECT_CONTENT</b></dt> </dl> </td> <td width="60%"> Renders a screen image of the text content to
    ///                   the <i>hdcDraw</i> device context. The <i>hicTargetDev</i> and <i>ptd</i> parameters give information on the
    ///                   target device context if any (usually a printer). </td> </tr> <tr> <td width="40%"><a
    ///                   id="DVASPECT_DOCPRINT"></a><a id="dvaspect_docprint"></a><dl> <dt><b>DVASPECT_DOCPRINT</b></dt> </dl> </td>
    ///                   <td width="60%"> Renders the object to the <i>hdcDraw</i> device context as though it were printed to a
    ///                   printer. Thus, the text services object can optimize for the printer (for example, not painting the
    ///                   background color, if white). Also, certain screen-specific elements (such as the selection) should not be
    ///                   rendered. <b>ITextServices::OnTxSetCursor</b> should render the <i>lprcClient</i> rectangle, starting at the
    ///                   current scrolling position. </td> </tr> </table>
    ///    lindex = Type: <b>LONG</b> Not supported.
    ///    pvAspect = Type: <b>void*</b> Information for drawing optimizations.
    ///    ptd = Type: <b>DVTARGETDEVICE*</b> The target device.
    ///    hdcDraw = Type: <b>HDC</b> Rendering device context.
    ///    hicTargetDev = Type: <b>HDC</b> Target information context.
    ///    lprcClient = Type: <b>LPCRECT</b> The control's client rectangle. The coordinates of the rectangle are in client
    ///                 coordinates of the containing window. <b>NULL</b> is a legal value.
    ///    x = Type: <b>INT</b> x position of cursor, in the client coordinates of the containing window.
    ///    y = Type: <b>INT</b> y position of cursor, in the client coordinates of the containing window.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, the return value is <b>S_OK</b>. If the method fails, the return
    ///    value is the following <b>HRESULT</b> code. For more information on COM error codes, see Error Handling in
    ///    COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more illegal parameters. </td> </tr>
    ///    </table>
    ///    
    HRESULT OnTxSetCursor(uint dwDrawAspect, int lindex, void* pvAspect, DVTARGETDEVICE* ptd, HDC hdcDraw, 
                          HDC hicTargetDev, RECT* lprcClient, int x, int y);
    ///Tests whether a specified point is within the rectangle of the text services object.
    ///Params:
    ///    dwDrawAspect = Type: <b>DWORD</b> Draw aspect can be one of the following values. <table> <tr> <th>Value</th>
    ///                   <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DVASPECT_CONTENT"></a><a id="dvaspect_content"></a><dl>
    ///                   <dt><b>DVASPECT_CONTENT</b></dt> </dl> </td> <td width="60%"> Renders a screen image of the text content to
    ///                   the <i>hdcDraw</i> device context. The <i>hicTargetDev</i> and <i>ptd</i> parameters give information on the
    ///                   target device context if any (usually a printer). </td> </tr> <tr> <td width="40%"><a
    ///                   id="DVASPECT_DOCPRINT"></a><a id="dvaspect_docprint"></a><dl> <dt><b>DVASPECT_DOCPRINT</b></dt> </dl> </td>
    ///                   <td width="60%"> Renders the object to the <i>hdcDraw</i> device context as though it were printed to a
    ///                   printer. Thus, the text services object can optimize for the printer (for example, not painting the
    ///                   background color, if white). Also, certain screen-specific elements (such as the selection) should not be
    ///                   rendered. ITextServices::TxGetNaturalSize should render the <i>lprcClient</i> rectangle, starting at the
    ///                   current scrolling position. </td> </tr> </table>
    ///    lindex = Type: <b>LONG</b> Not supported.
    ///    pvAspect = Type: <b>void*</b> Information for drawing optimizations.
    ///    ptd = Type: <b>DVTARGETDEVICE*</b> Information on the target device.
    ///    hdcDraw = Type: <b>HDC</b> Rendering device context.
    ///    hicTargetDev = Type: <b>HDC</b> Target information context.
    ///    lprcClient = Type: <b>LPCRECT</b> The control's client rectangle, in client (device) coordinates of the view in which the
    ///                 hit testing is done.
    ///    x = Type: <b>INT</b> x-coordinate to check, in client coordinates, of the view in which hit testing is done.
    ///    y = Type: <b>INT</b> y-coordinate to check, in client coordinates, of the view in which hit testing is done.
    ///    pHitResult = Type: <b>DWORD*</b> The result of the hit test. It can be any of the following <b>TXTHITRESULT</b>
    ///                 enumeration values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                 id="TXTHITRESULT_CLOSE"></a><a id="txthitresult_close"></a><dl> <dt><b>TXTHITRESULT_CLOSE</b></dt> </dl>
    ///                 </td> <td width="60%"> The point is in the client rectangle and close to a nontransparent area. </td> </tr>
    ///                 <tr> <td width="40%"><a id="TXTHITRESULT_HIT"></a><a id="txthitresult_hit"></a><dl>
    ///                 <dt><b>TXTHITRESULT_HIT</b></dt> </dl> </td> <td width="60%"> The point is in the client rectangle and either
    ///                 over text or the background is not transparent. </td> </tr> <tr> <td width="40%"><a
    ///                 id="TXTHITRESULT_NOHIT"></a><a id="txthitresult_nohit"></a><dl> <dt><b>TXTHITRESULT_NOHIT</b></dt> </dl>
    ///                 </td> <td width="60%"> The point is outside of the client rectangle. </td> </tr> <tr> <td width="40%"><a
    ///                 id="TXTHITRESULT_TRANSPARENT"></a><a id="txthitresult_transparent"></a><dl>
    ///                 <dt><b>TXTHITRESULT_TRANSPARENT</b></dt> </dl> </td> <td width="60%"> The point is in the client rectangle
    ///                 and either not over text or the background was transparent. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> The return value is an <b>HRESULT</b> code.
    ///    
    HRESULT TxQueryHitPoint(uint dwDrawAspect, int lindex, void* pvAspect, DVTARGETDEVICE* ptd, HDC hdcDraw, 
                            HDC hicTargetDev, RECT* lprcClient, int x, int y, uint* pHitResult);
    ///Notifies the text services object that this control is in-place active.
    ///Params:
    ///    prcClient = Type: <b>const RECT*</b> The control's client rectangle.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the object is successfully activated, the return value is <b>S_OK</b>. If the object
    ///    could not be activated due to error, the return value is E_FAIL. For more information on COM error codes, see
    ///    Error Handling in COM.
    ///    
    HRESULT OnTxInPlaceActivate(RECT* prcClient);
    ///Notifies the text services object that this control is no longer in-place active.
    ///Returns:
    ///    Type: <b>HRESULT</b> The return value is always <b>S_OK</b>.
    ///    
    HRESULT OnTxInPlaceDeactivate();
    ///Informs the text services object that the control is now UI active.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method always returns <b>S_OK</b>.
    ///    
    HRESULT OnTxUIActivate();
    ///Informs the text services object that the control is no longer UI active.
    ///Returns:
    ///    Type: <b>HRESULT</b> The method always returns <b>S_OK</b>.
    ///    
    HRESULT OnTxUIDeactivate();
    ///Returns all of the Unicode plain text in the control as a <b>BSTR</b>.
    ///Params:
    ///    pbstrText = Type: <b>BSTR *</b> The Unicode plain text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the text is successfully returned in the output argument, the return value is
    ///    <b>S_OK</b>. If the method fails, the return value is one of the following <b>HRESULT</b> codes. For more
    ///    information on COM error codes, see Error Handling in COM. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid <b>BSTR</b> pointer passed in. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Could not allocate memory for copy of the text.
    ///    </td> </tr> </table>
    ///    
    HRESULT TxGetText(BSTR* pbstrText);
    ///Sets all of the text in the control.
    ///Params:
    ///    pszText = Type: <b>LPCTSTR</b> The string which will replace the current text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, the return value is <b>S_OK</b>. If the method fails, the return
    ///    value is the following <b>HRESULT</b> code. For more information on COM error codes, see Error Handling in
    ///    COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Text could not be updated. </td> </tr> </table>
    ///    
    HRESULT TxSetText(const(PWSTR) pszText);
    ///Gets the target x position, that is, the current horizontal position of the caret.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the x position of the caret is returned, the return value is <b>S_OK</b>. If the
    ///    method fails, the return value is the following <b>HRESULT</b> code. For more information on COM error codes,
    ///    see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> There is no selection. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The input argument is invalid.
    ///    </td> </tr> </table>
    ///    
    HRESULT TxGetCurTargetX(int* param0);
    ///Gets the base line position of the first visible line, in pixels, relative to the text services client rectangle.
    ///This permits aligning controls on their base lines.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, the return value is <b>S_OK</b>. If the method fails, the return
    ///    value is the following <b>HRESULT</b> code. For more information on COM error codes, see Error Handling in
    ///    COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td> </tr> </table>
    ///    
    HRESULT TxGetBaseLinePos(int* param0);
    ///Allows a control to be resized so it fits its content appropriately.
    ///Params:
    ///    dwAspect = Type: <b>DWORD</b> The aspect for the drawing. It can be any of the values from the DVASPECT enumeration.
    ///    hdcDraw = Type: <b>HDC</b> The device context into which drawing occurs.
    ///    hicTargetDev = Type: <b>HDC</b> The device context for which text should be formatted (that is, for WYSIWYG).
    ///    ptd = Type: <b>DVTARGETDEVICE*</b> More information on the target device.
    ///    dwMode = Type: <b>DWORD</b> The type of fitting requested. It can be one of the following. <table> <tr> <th>Value</th>
    ///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TXTNS_EMU"></a><a id="txtns_emu"></a><dl>
    ///             <dt><b>TXTNS_EMU</b></dt> </dl> </td> <td width="60%"> Use English Metric Units (EMUs) instead of pixels as
    ///             the measuring units for this method's parameters. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTNS_FITTOCONTENT"></a><a id="txtns_fittocontent"></a><dl> <dt><b>TXTNS_FITTOCONTENT</b></dt> </dl>
    ///             </td> <td width="60%"> Resize the control to fit the entire text by formatting the text to the width that is
    ///             passed in. The text services object returns the height of the entire text and the width of the widest line.
    ///             For example, this should be done when the user double-clicks one of the control's handles. </td> </tr> <tr>
    ///             <td width="40%"><a id="TXTNS_FITTOCONTENT2"></a><a id="txtns_fittocontent2"></a><dl>
    ///             <dt><b>TXTNS_FITTOCONTENT2</b></dt> </dl> </td> <td width="60%"> Resize the control so that it fits indented
    ///             content. </td> </tr> <tr> <td width="40%"><a id="TXTNS_FITTOCONTENT3"></a><a
    ///             id="txtns_fittocontent3"></a><dl> <dt><b>TXTNS_FITTOCONTENT3</b></dt> </dl> </td> <td width="60%"> Resize the
    ///             control so that it fits indented content and trailing whitespace. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTNS_FITTOCONTENTWSP"></a><a id="txtns_fittocontentwsp"></a><dl> <dt><b>TXTNS_FITTOCONTENTWSP</b></dt>
    ///             </dl> </td> <td width="60%"> Resize the control so that it fits unindented content and trailing whitespace.
    ///             </td> </tr> <tr> <td width="40%"><a id="TXTNS_INCLUDELASTLINE"></a><a id="txtns_includelastline"></a><dl>
    ///             <dt><b>TXTNS_INCLUDELASTLINE</b></dt> </dl> </td> <td width="60%"> For a plain-text control, include the
    ///             height of the final carriage return when calculating the size. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTNS_ROUNDTOLINE"></a><a id="txtns_roundtoline"></a><dl> <dt><b>TXTNS_ROUNDTOLINE</b></dt> </dl> </td>
    ///             <td width="60%"> Resize the control to show an integral number of lines (no line is clipped). Format enough
    ///             text to fill the width and height that is passed in, and then return a height that is rounded to the nearest
    ///             line boundary. <div class="alert"><b>Note</b> The passed and returned width and height correspond to the view
    ///             rectangle. The host should adjust back to the client rectangle as needed. Because these values represent the
    ///             extent of the text object, they are input and output in HIMETRIC coordinates (each HIMETRIC unit is .01
    ///             millimeter), and measuring does not include any zoom factor. For a discussion of the zoom factor, see
    ///             TxGetExtent.</div> <div> </div> </td> </tr> </table>
    ///    psizelExtent = Type: <b>const SIZEL*</b> Not supported.
    ///    pwidth = Type: <b>LONG*</b> The width for the fitting defined by <i>dwMode</i>.
    ///    pheight = Type: <b>LONG*</b> The height for the fitting defined by <i>dwMode</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, the return value is <b>S_OK</b>. If text services could not
    ///    activate the object, the return value is one of the following <b>HRESULT</b> codes. For more information on
    ///    COM error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unable to determine correct size.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more
    ///    arguments are not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT TxGetNaturalSize(uint dwAspect, HDC hdcDraw, HDC hicTargetDev, DVTARGETDEVICE* ptd, uint dwMode, 
                             const(SIZE)* psizelExtent, int* pwidth, int* pheight);
    ///Gets the drop target for the text control.
    ///Params:
    ///    ppDropTarget = Type: <b>IDropTarget**</b> The target of a drag-and-drop operation in a specified window.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method got the drop target successfully, the return value is <b>S_OK</b>. For
    ///    more information on COM error codes, see Error Handling in COM. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Could not create the drop target. </td> </tr> </table>
    ///    
    HRESULT TxGetDropTarget(IDropTarget* ppDropTarget);
    ///Sets properties (represented by bits) for the control.
    ///Params:
    ///    dwMask = Type: <b>DWORD</b> Bits representing properties to be changed. For the possible bit values, see the TXTBIT_*
    ///             values list in <i>dwBits</i>.
    ///    dwBits = Type: <b>DWORD</b> New values for bit properties. It can be any combination of the following. <table> <tr>
    ///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TXTBIT_ALLOWBEEP"></a><a
    ///             id="txtbit_allowbeep"></a><dl> <dt><b>TXTBIT_ALLOWBEEP</b></dt> </dl> </td> <td width="60%"> If <b>TRUE</b>,
    ///             beeping is enabled. </td> </tr> <tr> <td width="40%"><a id="TXTBIT_AUTOWORDSEL"></a><a
    ///             id="txtbit_autowordsel"></a><dl> <dt><b>TXTBIT_AUTOWORDSEL</b></dt> </dl> </td> <td width="60%"> If
    ///             <b>TRUE</b>, the AutoWordSelect feature is enabled. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTBIT_BACKSTYLECHANGE"></a><a id="txtbit_backstylechange"></a><dl>
    ///             <dt><b>TXTBIT_BACKSTYLECHANGE</b></dt> </dl> </td> <td width="60%"> If <b>TRUE</b>, the backstyle changed.
    ///             See TxGetBackStyle. </td> </tr> <tr> <td width="40%"><a id="TXTBIT_CHARFORMATCHANGE"></a><a
    ///             id="txtbit_charformatchange"></a><dl> <dt><b>TXTBIT_CHARFORMATCHANGE</b></dt> </dl> </td> <td width="60%"> If
    ///             <b>TRUE</b>, the character format changed. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTBIT_CLIENTRECTCHANGE"></a><a id="txtbit_clientrectchange"></a><dl>
    ///             <dt><b>TXTBIT_CLIENTRECTCHANGE</b></dt> </dl> </td> <td width="60%"> If <b>TRUE</b>, the client rectangle
    ///             changed. </td> </tr> <tr> <td width="40%"><a id="TXTBIT_DISABLEDRAG"></a><a id="txtbit_disabledrag"></a><dl>
    ///             <dt><b>TXTBIT_DISABLEDRAG</b></dt> </dl> </td> <td width="60%"> If <b>TRUE</b>, dragging is disabled. </td>
    ///             </tr> <tr> <td width="40%"><a id="TXTBIT_D2DDWRITE"></a><a id="txtbit_d2ddwrite"></a><dl>
    ///             <dt><b>TXTBIT_D2DDWRITE</b></dt> </dl> </td> <td width="60%"> Use Direct2D/DirectWrite for this instance, and
    ///             not GDI/Uniscribe. </td> </tr> <tr> <td width="40%"><a id="TXTBIT_D2DPIXELSNAPPED"></a><a
    ///             id="txtbit_d2dpixelsnapped"></a><dl> <dt><b>TXTBIT_D2DPIXELSNAPPED</b></dt> </dl> </td> <td width="60%">
    ///             Render glyphs to the nearest pixel positions. Valid only if D2DDWRITE is set. </td> </tr> <tr> <td
    ///             width="40%"><a id="TXTBIT_D2DSUBPIXELLINES"></a><a id="txtbit_d2dsubpixellines"></a><dl>
    ///             <dt><b>TXTBIT_D2DSUBPIXELLINES</b></dt> </dl> </td> <td width="60%"> Draw lines with subpixel precision.
    ///             Don't pixel-snap text lines, underline, and strikethrough in the secondary text flow direction (usually
    ///             vertical). Valid only if D2DDWRITE is set and D2DPIXELSNAPPED is not set. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTBIT_D2DSIMPLETYPOGRAPHY"></a><a id="txtbit_d2dsimpletypography"></a><dl>
    ///             <dt><b>TXTBIT_D2DSIMPLETYPOGRAPHY</b></dt> </dl> </td> <td width="60%"> Render text using simple typography
    ///             (no glyph rendering). This value is valid only if TXTBIT_D2DDWRITE is also specified. </td> </tr> <tr> <td
    ///             width="40%"><a id="TXTBIT_EXTENTCHANGE"></a><a id="txtbit_extentchange"></a><dl>
    ///             <dt><b>TXTBIT_EXTENTCHANGE</b></dt> </dl> </td> <td width="60%"> If <b>TRUE</b>, the size of the client
    ///             rectangle changed. </td> </tr> <tr> <td width="40%"><a id="TXTBIT_HIDESELECTION"></a><a
    ///             id="txtbit_hideselection"></a><dl> <dt><b>TXTBIT_HIDESELECTION</b></dt> </dl> </td> <td width="60%"> If
    ///             <b>TRUE</b>, the text services object should hide the selection when the control is inactive. If
    ///             <b>FALSE</b>, the selection should be displayed when the control is inactive. Note, this implies
    ///             <b>TXTBIT_SAVESELECTION</b> is <b>TRUE</b>. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTBIT_MAXLENGTHCHANGE"></a><a id="txtbit_maxlengthchange"></a><dl>
    ///             <dt><b>TXTBIT_MAXLENGTHCHANGE</b></dt> </dl> </td> <td width="60%"> If <b>TRUE</b>, the maximum length for
    ///             text in the control changed. </td> </tr> <tr> <td width="40%"><a id="TXTBIT_MULTILINE"></a><a
    ///             id="txtbit_multiline"></a><dl> <dt><b>TXTBIT_MULTILINE</b></dt> </dl> </td> <td width="60%"> If <b>TRUE</b>,
    ///             the text services object should work in multiline mode. Use the <b>TXTBIT_WORDWRAP</b> value to determine
    ///             whether to wrap the lines to the view rectangle or clip them. If <b>FALSE</b>, the text services object
    ///             should not process a carriage return/line feed from the ENTER key and it should truncate incoming text
    ///             containing hard line breaks just before the first line break. It is also acceptable to truncate text that is
    ///             set with ITextServices::TxSetText, because it is the responsibility of the host not to use a single-line
    ///             control when bound to a multiline field. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTBIT_NOTHREADREFCOUNT"></a><a id="txtbit_nothreadrefcount"></a><dl>
    ///             <dt><b>TXTBIT_NOTHREADREFCOUNT</b></dt> </dl> </td> <td width="60%"> Don't reference TLS data on behalf of
    ///             this instance. </td> </tr> <tr> <td width="40%"><a id="TXTBIT_PARAFORMATCHANGE"></a><a
    ///             id="txtbit_paraformatchange"></a><dl> <dt><b>TXTBIT_PARAFORMATCHANGE</b></dt> </dl> </td> <td width="60%"> If
    ///             <b>TRUE</b>, the paragraph format changed. </td> </tr> <tr> <td width="40%"><a id="TXTBIT_READONLY"></a><a
    ///             id="txtbit_readonly"></a><dl> <dt><b>TXTBIT_READONLY</b></dt> </dl> </td> <td width="60%"> If <b>TRUE</b>,
    ///             the text services object should not accept any editing change through the user interface. However, it should
    ///             still accept programmatic changes through EM_SETTEXTEX, EM_REPLACESEL, and ITextServices::TxSetText. Also,
    ///             the user should still be able to move the insertion point, select text, and carry out other operations that
    ///             don't modify content, such as Copy. </td> </tr> <tr> <td width="40%"><a id="TXTBIT_RICHTEXT"></a><a
    ///             id="txtbit_richtext"></a><dl> <dt><b>TXTBIT_RICHTEXT</b></dt> </dl> </td> <td width="60%"> If <b>TRUE</b>,
    ///             the text services object should be in rich-text mode. If <b>FALSE</b>, it is in plain-text mode. Note, this
    ///             affects how editing commands are applied. For example, applying bold to part of the text in a plain-edit
    ///             control makes the entire text bold. However, for a rich-edit control, this makes only the selected text bold.
    ///             </td> </tr> <tr> <td width="40%"><a id="TXTBIT_SAVESELECTION"></a><a id="txtbit_saveselection"></a><dl>
    ///             <dt><b>TXTBIT_SAVESELECTION</b></dt> </dl> </td> <td width="60%"> If <b>TRUE</b>, the boundaries of the
    ///             selection should be saved when the control is inactive. If <b>FALSE</b>, when the control goes active again
    ///             the selection boundaries can be reset to start = 0, length = 0. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTBIT_SCROLLBARCHANGE"></a><a id="txtbit_scrollbarchange"></a><dl>
    ///             <dt><b>TXTBIT_SCROLLBARCHANGE</b></dt> </dl> </td> <td width="60%"> If <b>TRUE</b>, the scroll bar has
    ///             changed. </td> </tr> <tr> <td width="40%"><a id="TXTBIT_SELBARCHANGE"></a><a
    ///             id="txtbit_selbarchange"></a><dl> <dt><b>TXTBIT_SELBARCHANGE</b></dt> </dl> </td> <td width="60%"> If
    ///             <b>TRUE</b>, the selection bar width has changed </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTBIT_SHOWACCELERATOR"></a><a id="txtbit_showaccelerator"></a><dl>
    ///             <dt><b>TXTBIT_SHOWACCELERATOR</b></dt> </dl> </td> <td width="60%"> If set, the accelerator character should
    ///             be underlined. This must be set in order to call TxGetAcceleratorPos. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTBIT_SHOWPASSWORD"></a><a id="txtbit_showpassword"></a><dl> <dt><b>TXTBIT_SHOWPASSWORD</b></dt> </dl>
    ///             </td> <td width="60%"> Show password strings. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTBIT_USECURRENTBKG"></a><a id="txtbit_usecurrentbkg"></a><dl> <dt><b>TXTBIT_USECURRENTBKG</b></dt>
    ///             </dl> </td> <td width="60%"> Not supported. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTBIT_USEPASSWORD"></a><a id="txtbit_usepassword"></a><dl> <dt><b>TXTBIT_USEPASSWORD</b></dt> </dl>
    ///             </td> <td width="60%"> If <b>TRUE</b>, display text using the password character obtained by
    ///             TxGetPasswordChar. The notification on this property can mean either that the password character changed or
    ///             that the password character was not used before but is used now (or vice versa). </td> </tr> <tr> <td
    ///             width="40%"><a id="TXTBIT_VERTICAL"></a><a id="txtbit_vertical"></a><dl> <dt><b>TXTBIT_VERTICAL</b></dt>
    ///             </dl> </td> <td width="60%"> Not supported. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTBIT_VIEWINSETCHANGE"></a><a id="txtbit_viewinsetchange"></a><dl>
    ///             <dt><b>TXTBIT_VIEWINSETCHANGE</b></dt> </dl> </td> <td width="60%"> If <b>TRUE</b>, the inset changed. </td>
    ///             </tr> <tr> <td width="40%"><a id="TXTBIT_WORDWRAP"></a><a id="txtbit_wordwrap"></a><dl>
    ///             <dt><b>TXTBIT_WORDWRAP</b></dt> </dl> </td> <td width="60%"> If <b>TRUE</b> and TXTBIT_MULTILINE is also
    ///             <b>TRUE</b>, multiline controls should wrap the line to the view rectangle. If this property is <b>FALSE</b>
    ///             and <b>TXTBIT_MULTILINE</b> is <b>TRUE</b>, the lines should not be wrapped but clipped. The right side of
    ///             the view rectangle should be ignored. If <b>TXTBIT_MULTILINE</b> is <b>FALSE</b>, this property has no
    ///             effect. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, the return value is <b>S_OK</b>. If the method fails, the return
    ///    value is the following HRESULT code. For more information on COM error codes, see Error Handling in COM.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td> </tr> </table>
    ///    
    HRESULT OnTxPropertyBitsChange(uint dwMask, uint dwBits);
    ///Returns the cached drawing logical size (if any) that text services is using. Typically, this will be the size of
    ///the last client rectangle used in ITextServices::TxDraw, ITextServices::OnTxSetCursor, and so forth, although it
    ///is not guaranteed to be.
    ///Params:
    ///    pdwWidth = Type: <b>DWORD*</b> The width, in client coordinates.
    ///    pdwHeight = Type: <b>DWORD*</b> The height (in client coordinates).
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, the return value is an <b>HRESULT</b> code.
    ///    
    HRESULT TxGetCachedSize(uint* pdwWidth, uint* pdwHeight);
}

///The <b>ITextHost</b> interface is used by a text services object to obtain text host services.
interface ITextHost : IUnknown
{
    ///Requests the device context for the text host window.
    ///Returns:
    ///    Type: <b>HDC</b> If the method succeeds, return the handle of the device context for the client area of the
    ///    text host window. If the method fails, return <b>NULL</b>. For more information on COM error codes, see Error
    ///    Handling in COM.
    ///    
    HDC     TxGetDC();
    ///Releases the device context obtained by the ITextHost::TxGetDC method.
    ///Params:
    ///    hdc = Type: <b>HDC</b> Handle to the device context to release.
    ///Returns:
    ///    Type: <b>INT</b> Returns 1 if <i>hdc</i> was released; otherwise 0. For more information on COM error codes,
    ///    see Error Handling in COM.
    ///    
    int     TxReleaseDC(HDC hdc);
    ///Shows or hides the scroll bar in the text host window.
    ///Params:
    ///    fnBar = Type: <b>INT</b> Specifies the scroll bar(s) to be shown or hidden. This parameter can be one of the
    ///            following values. <table class="clsStd"> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td>SB_BOTH</td>
    ///            <td>Shows or hides a window's standard horizontal and vertical scroll bars.</td> </tr> <tr> <td>SB_HORZ</td>
    ///            <td>Shows or hides a window's standard horizontal scroll bars.</td> </tr> <tr> <td>SB_VERT</td> <td>Shows or
    ///            hides a window's standard vertical scroll bar.</td> </tr> </table>
    ///    fShow = Type: <b>BOOL</b> Flag. If <b>TRUE</b>, the scroll bars indicated by <i>fnBar</i> is visible. If
    ///            <b>FALSE</b>, the scroll bar is hidden.
    ///Returns:
    ///    Type: <b>BOOL</b> Return <b>TRUE</b> if the method succeeds. Return <b>FALSE</b> if the method fails.
    ///    
    BOOL    TxShowScrollBar(int fnBar, BOOL fShow);
    ///Enables or disables one or both scroll bar arrows in the text host window.
    ///Params:
    ///    fuSBFlags = Type: <b>INT</b> Specifies which scroll bar is affected. This parameter can be one of the following values.
    ///                <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SB_BOTH"></a><a
    ///                id="sb_both"></a><dl> <dt><b>SB_BOTH</b></dt> </dl> </td> <td width="60%"> Affects both the horizontal and
    ///                vertical scroll bars. </td> </tr> <tr> <td width="40%"><a id="SB_HORZ"></a><a id="sb_horz"></a><dl>
    ///                <dt><b>SB_HORZ</b></dt> </dl> </td> <td width="60%"> Affects the horizontal scroll bar. </td> </tr> <tr> <td
    ///                width="40%"><a id="SB_VERT"></a><a id="sb_vert"></a><dl> <dt><b>SB_VERT</b></dt> </dl> </td> <td width="60%">
    ///                Affects the vertical scroll bar. </td> </tr> </table>
    ///    fuArrowflags = Type: <b>INT</b> Specifies which scroll bar arrows are enabled or disabled. This parameter can be one of the
    ///                   following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                   id="ESB_DISABLE_BOTH"></a><a id="esb_disable_both"></a><dl> <dt><b>ESB_DISABLE_BOTH</b></dt> </dl> </td> <td
    ///                   width="60%"> Disables both arrows on a scroll bar. </td> </tr> <tr> <td width="40%"><a
    ///                   id="ESB_DISABLE_DOWN"></a><a id="esb_disable_down"></a><dl> <dt><b>ESB_DISABLE_DOWN</b></dt> </dl> </td> <td
    ///                   width="60%"> Disables the down arrow on a vertical scroll bar. </td> </tr> <tr> <td width="40%"><a
    ///                   id="ESB_DISABLE_LEFT"></a><a id="esb_disable_left"></a><dl> <dt><b>ESB_DISABLE_LEFT</b></dt> </dl> </td> <td
    ///                   width="60%"> Disables the left arrow on a horizontal scroll bar. </td> </tr> <tr> <td width="40%"><a
    ///                   id="ESB_DISABLE_LTUP"></a><a id="esb_disable_ltup"></a><dl> <dt><b>ESB_DISABLE_LTUP</b></dt> </dl> </td> <td
    ///                   width="60%"> Disables the left arrow on a horizontal scroll bar or the up arrow of a vertical scroll bar.
    ///                   </td> </tr> <tr> <td width="40%"><a id="ESB_DISABLE_RIGHT"></a><a id="esb_disable_right"></a><dl>
    ///                   <dt><b>ESB_DISABLE_RIGHT</b></dt> </dl> </td> <td width="60%"> Disables the right arrow on a horizontal
    ///                   scroll bar. </td> </tr> <tr> <td width="40%"><a id="ESB_DISABLE_RTDN"></a><a id="esb_disable_rtdn"></a><dl>
    ///                   <dt><b>ESB_DISABLE_RTDN</b></dt> </dl> </td> <td width="60%"> Disables the right arrow on a horizontal scroll
    ///                   bar or the down arrow of a vertical scroll bar. </td> </tr> <tr> <td width="40%"><a
    ///                   id="ESB_DISABLE_UP"></a><a id="esb_disable_up"></a><dl> <dt><b>ESB_DISABLE_UP</b></dt> </dl> </td> <td
    ///                   width="60%"> Disables the up arrow on a vertical scroll bar. </td> </tr> <tr> <td width="40%"><a
    ///                   id="ESB_ENABLE_BOTH"></a><a id="esb_enable_both"></a><dl> <dt><b>ESB_ENABLE_BOTH</b></dt> </dl> </td> <td
    ///                   width="60%"> Enables both arrows on a scroll bar. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>BOOL</b> Return nonzero if the arrows are enabled or disabled as specified. Return zero if the
    ///    arrows are already in the requested state or an error occurs.
    ///    
    BOOL    TxEnableScrollBar(int fuSBFlags, int fuArrowflags);
    ///Sets the minimum and maximum position values for the specified scroll bar in the text host window.
    ///Params:
    ///    fnBar = Type: <b>INT</b> Scroll bar flag. If this is SB_HORZ, horizontal scrolling is done. By default, vertical
    ///            scrolling is done.
    ///    nMinPos = Type: <b>LONG</b> Minimum scrolling position.
    ///    nMaxPos = Type: <b>INT</b> Maximum scrolling position.
    ///    fRedraw = Type: <b>BOOL</b> Redraw flag. If <b>TRUE</b>, the scroll bar is redrawn to reflect the changes. If
    ///              <b>FALSE</b>, the scroll bar is not redrawn.
    ///Returns:
    ///    Type: <b>BOOL</b> Return <b>TRUE</b> if the arrows are enabled or disabled as specified. Return <b>FALSE</b>
    ///    if the arrows are already in the requested state or an error occurs.
    ///    
    BOOL    TxSetScrollRange(int fnBar, int nMinPos, int nMaxPos, BOOL fRedraw);
    ///Sets the position of the scroll box (thumb) in the specified scroll bar and, if requested, redraws the scroll bar
    ///to reflect the new position of the scroll box.
    ///Params:
    ///    fnBar = Type: <b>INT</b> Scroll bar flag. If this is SB_HORZ, horizontal scrolling is done. By default, vertical
    ///            scrolling is done.
    ///    nPos = Type: <b>INT</b> New position in scroll box. This must be within the range of scroll bar values set by
    ///           ITextHost::TxSetScrollRange.
    ///    fRedraw = Type: <b>BOOL</b> Redraw flag. If <b>TRUE</b>, the scroll bar is redrawn with the new position of the scroll
    ///              box. If <b>FALSE</b>, the scroll bar is not redrawn.
    ///Returns:
    ///    Type: <b>BOOL</b> Return <b>TRUE</b> if the method succeeds. Return <b>FALSE</b> if the method fails.
    ///    
    BOOL    TxSetScrollPos(int fnBar, int nPos, BOOL fRedraw);
    ///Specifies a rectangle for the text host to add to the update region of the text host window.
    ///Params:
    ///    prc = Type: <b>LPCRECT</b> The invalid rectangle.
    ///    fMode = Type: <b>BOOL</b> Specifies whether the background within the update region is to be erased when the update
    ///            region is processed. If this parameter is <b>TRUE</b>, the background is erased when the BeginPaint function
    ///            is called. If this parameter is <b>FALSE</b>, the background remains unchanged.
    void    TxInvalidateRect(RECT* prc, BOOL fMode);
    ///Indicates to the text host that the update region has changed.
    ///Params:
    ///    fUpdate = Type: <b>BOOL</b> Update flag. If <b>TRUE</b>, the text host calls UpdateWindow; otherwise it does nothing.
    ///              See the Remarks section.
    void    TxViewChange(BOOL fUpdate);
    ///Creates a new shape for windowless rich edit control's caret.
    ///Params:
    ///    hbmp = Type: <b>HBITMAP</b> Handle to the bitmap for the new caret shape. If the windowless rich edit control has
    ///           the SES_LOGICALCARET style, <i>hbmp</i> is a combination of the following values: <table> <tr> <th>Value</th>
    ///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CARET_CUSTOM"></a><a id="caret_custom"></a><dl>
    ///           <dt><b>CARET_CUSTOM</b></dt> </dl> </td> <td width="60%"> An adorned caret. This value is valid only if
    ///           CARET_RTL is also specified. </td> </tr> <tr> <td width="40%"><a id="CARET_ITALIC"></a><a
    ///           id="caret_italic"></a><dl> <dt><b>CARET_ITALIC</b></dt> </dl> </td> <td width="60%"> An italicized caret.
    ///           </td> </tr> <tr> <td width="40%"><a id="CARET_NONE"></a><a id="caret_none"></a><dl>
    ///           <dt><b>CARET_NONE</b></dt> </dl> </td> <td width="60%"> A blinking vertical bar. </td> </tr> <tr> <td
    ///           width="40%"><a id="CARET_NULL"></a><a id="caret_null"></a><dl> <dt><b>CARET_NULL</b></dt> </dl> </td> <td
    ///           width="60%"> An empty bitmap (for non-degenerate text selection). </td> </tr> <tr> <td width="40%"><a
    ///           id="CARET_ROTATE90"></a><a id="caret_rotate90"></a><dl> <dt><b>CARET_ROTATE90</b></dt> </dl> </td> <td
    ///           width="60%"> A caret that is rotated clockwise by 90 degrees. </td> </tr> <tr> <td width="40%"><a
    ///           id="CARET_RTL"></a><a id="caret_rtl"></a><dl> <dt><b>CARET_RTL</b></dt> </dl> </td> <td width="60%"> The
    ///           caret moves right to left. </td> </tr> </table>
    ///    xWidth = Type: <b>INT</b> Caret width, in logical units.
    ///    yHeight = Type: <b>INT</b> Caret height, in logical units.
    ///Returns:
    ///    Type: <b>BOOL</b> Return <b>TRUE</b> if the method succeeds. Return <b>FALSE</b> if the method fails.
    ///    
    BOOL    TxCreateCaret(HBITMAP hbmp, int xWidth, int yHeight);
    ///Shows or hides the caret at the caret position in the text host window.
    ///Params:
    ///    fShow = Type: <b>BOOL</b> Flag. If <b>TRUE</b>, the caret is visible. If <b>FALSE</b>, the caret is hidden.
    ///Returns:
    ///    Type: <b>BOOL</b> Return <b>TRUE</b> if the method succeeds. Return <b>FALSE</b> if the method fails.
    ///    
    BOOL    TxShowCaret(BOOL fShow);
    ///Moves the caret position to the specified coordinates in the text host window.
    ///Params:
    ///    x = Type: <b>INT</b> Horizontal position (in client coordinates).
    ///    y = Type: <b>INT</b> Vertical position (in client coordinates).
    ///Returns:
    ///    Type: <b>BOOL</b> Return <b>TRUE</b> if the method succeeds. Return <b>FALSE</b> if the method fails.
    ///    
    BOOL    TxSetCaretPos(int x, int y);
    ///Requests the text host to create a timer with a specified time-out.
    ///Params:
    ///    idTimer = Type: <b>UINT</b> Timer identifier.
    ///    uTimeout = Type: <b>UINT</b> Time-out in milliseconds.
    ///Returns:
    ///    Type: <b>BOOL</b> Return <b>TRUE</b> if the method succeeds. Return <b>FALSE</b> if the method fails.
    ///    
    BOOL    TxSetTimer(uint idTimer, uint uTimeout);
    ///Requests the text host to destroy the specified timer.
    ///Params:
    ///    idTimer = Type: <b>UINT</b> Identifier of the timer created by the ITextHost::TxSetTimer method.
    void    TxKillTimer(uint idTimer);
    ///Requests the text host to scroll the content of the specified client area.
    ///Params:
    ///    dx = Type: <b>INT</b> Amount of horizontal scrolling.
    ///    dy = Type: <b>INT</b> Amount of vertical scrolling.
    ///    lprcScroll = Type: <b>LPCRECT</b> The coordinates for the scroll rectangle.
    ///    lprcClip = Type: <b>LPCRECT</b> The coordinates for the clip rectangle.
    ///    hrgnUpdate = Type: <b>HRGN</b> Handle to the update region.
    ///    lprcUpdate = Type: <b>LPRECT</b> The coordinates for the update rectangle.
    ///    fuScroll = Type: <b>UINT</b> Scrolling flags. This parameter can be one of the following values. <table> <tr>
    ///               <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SW_ERASE"></a><a id="sw_erase"></a><dl>
    ///               <dt><b>SW_ERASE</b></dt> </dl> </td> <td width="60%"> Erases the newly invalidated region by sending a
    ///               WM_ERASEBKGND message to the window when specified with the SW_INVALIDATE flag. </td> </tr> <tr> <td
    ///               width="40%"><a id="SW_INVALIDATE"></a><a id="sw_invalidate"></a><dl> <dt><b>SW_INVALIDATE</b></dt> </dl>
    ///               </td> <td width="60%"> Invalidates the region identified by the <i>hrgnUpdate</i> parameter after scrolling.
    ///               </td> </tr> <tr> <td width="40%"><a id="SW_SCROLLCHILDREN"></a><a id="sw_scrollchildren"></a><dl>
    ///               <dt><b>SW_SCROLLCHILDREN</b></dt> </dl> </td> <td width="60%"> Scrolls all child windows that intersect the
    ///               rectangle pointed to by the <i>lprcScroll</i> parameter. The child windows are scrolled by the number of
    ///               pixels specified by the <i>dx</i> and <i>dy</i> parameters. The system sends a WM_MOVE message to all child
    ///               windows that intersect the <i>lprcScroll</i> rectangle, even if they do not move. </td> </tr> <tr> <td
    ///               width="40%"><a id="SW_SMOOTHSCROLL"></a><a id="sw_smoothscroll"></a><dl> <dt><b>SW_SMOOTHSCROLL</b></dt>
    ///               </dl> </td> <td width="60%"> Scrolls using smooth scrolling. Use the HIWORD portion of the <i>fuScroll</i>
    ///               parameter to indicate how much time the smooth-scrolling operation should take. </td> </tr> </table>
    void    TxScrollWindowEx(int dx, int dy, RECT* lprcScroll, RECT* lprcClip, HRGN hrgnUpdate, RECT* lprcUpdate, 
                             uint fuScroll);
    ///Sets the mouse capture in the text host's window.
    ///Params:
    ///    fCapture = Type: <b>BOOL</b> Indicates whether to set or release the mouse capture. If <b>TRUE</b>, the mouse capture is
    ///               set. If <b>FALSE</b>, the mouse capture is released.
    void    TxSetCapture(BOOL fCapture);
    ///Sets the focus to the text host window.
    void    TxSetFocus();
    ///Establishes a new cursor shape (I-beam) in the text host's window.
    ///Params:
    ///    hcur = Type: <b>HCURSOR</b> Handle to the cursor.
    ///    fText = Type: <b>BOOL</b> If <b>TRUE</b>, indicates the caller is trying to set the text cursor. See the Remarks
    ///            section for more information.
    void    TxSetCursor(HCURSOR hcur, BOOL fText);
    ///Converts the screen coordinates to the text host window coordinates.
    ///Params:
    ///    lppt = Type: <b>LPPOINT</b> The screen coordinates to convert.
    ///Returns:
    ///    Type: <b>BOOL</b> Return <b>TRUE</b> if the call succeeds. Return <b>FALSE</b> if the call fails.
    ///    
    BOOL    TxScreenToClient(POINT* lppt);
    ///Converts text host coordinates to screen coordinates.
    ///Params:
    ///    lppt = Type: <b>LPPOINT</b> The client coordinates to convert.
    ///Returns:
    ///    Type: <b>BOOL</b> Return <b>TRUE</b> if the method succeeds. Return <b>FALSE</b> if the method fails.
    ///    
    BOOL    TxClientToScreen(POINT* lppt);
    ///Notifies the text host that the control is active.
    ///Params:
    ///    plOldState = Type: <b>LONG*</b> The previous activation state.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if the method succeeds. Return the following COM error code if the method
    ///    fails. For more information on COM error codes, see Error Handling in COM. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Activation is not possible at this time. </td> </tr> </table>
    ///    
    HRESULT TxActivate(int* plOldState);
    ///Notifies the text host that the control is now inactive.
    ///Params:
    ///    lNewState = Type: <b>LONG</b> New state of the control. Typically it is the value returned by ITextHost::TxActivate.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if the method succeeds. Return the following COM error code if the method
    ///    fails. For more information on COM error codes, see Error Handling in COM. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Unspecified error. </td> </tr> </table>
    ///    
    HRESULT TxDeactivate(int lNewState);
    ///Retrieves the client coordinates of the text host's client area.
    ///Params:
    ///    prc = Type: <b>LPRECT</b> The client coordinates of the text host's client area.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if the method succeeds. Return the following COM error code if the method
    ///    fails. For more information on COM error codes, see Error Handling in COM. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Unspecified error. </td> </tr> </table>
    ///    
    HRESULT TxGetClientRect(RECT* prc);
    ///Requests the dimensions of the white space inset around the text in the text host window.
    ///Params:
    ///    prc = Type: <b>LPRECT</b> The inset size, in client coordinates. The top, bottom, left, and right members of the
    ///          RECT structure indicate how far in each direction the drawing should be inset.
    ///Returns:
    ///    Type: <b>HRESULT</b> The return value is <b>S_OK</b>.
    ///    
    HRESULT TxGetViewInset(RECT* prc);
    ///Requests the text host's default character format.
    ///Params:
    ///    ppCF = Type: <b>const CHARFORMAT**</b> The default character format.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if the method succeeds. Return the following COM error code if the method
    ///    fails. For more information on COM error codes, see Error Handling in COM. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%">
    ///    Not implemented. </td> </tr> </table>
    ///    
    HRESULT TxGetCharFormat(const(CHARFORMATW)** ppCF);
    ///Requests the text host's default paragraph format.
    ///Params:
    ///    ppPF = Type: <b>const PARAFORMAT**</b> The default paragraph format.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if the method succeeds. Return the following COM error code if the method
    ///    fails. For more information on COM error codes, see Error Handling in COM. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%">
    ///    Not implemented. </td> </tr> </table>
    ///    
    HRESULT TxGetParaFormat(const(PARAFORMAT)** ppPF);
    ///Retrieves the text host's color for a specified display element.
    ///Params:
    ///    nIndex = Type: <b>INT</b> The display element whose color is to be retrieved. For a list of possible values for this
    ///             parameter, see the GetSysColor function.
    ///Returns:
    ///    Type: <b>COLORREF</b> The value that identifies the red, green, and blue (RGB) color value of the specified
    ///    element.
    ///    
    uint    TxGetSysColor(int nIndex);
    ///Requests the background style of the text host.
    ///Params:
    ///    pstyle = Type: <b>TXTBACKSTYLE*</b> A variable that the text host sets to indicate the background style. The style is
    ///             one of the following values from the <b>TXTBACKSTYLE</b> enumeration. <table> <tr> <th>Value</th>
    ///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TXTBACK_TRANSPARENT"></a><a
    ///             id="txtback_transparent"></a><dl> <dt><b>TXTBACK_TRANSPARENT</b></dt> </dl> </td> <td width="60%"> Background
    ///             shows through. </td> </tr> <tr> <td width="40%"><a id="TXTBACK_OPAQUE"></a><a id="txtback_opaque"></a><dl>
    ///             <dt><b>TXTBACK_OPAQUE</b></dt> </dl> </td> <td width="60%"> Background does not show through. </td> </tr>
    ///             </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> The return value is <b>S_OK</b>.
    ///    
    HRESULT TxGetBackStyle(TXTBACKSTYLE* pstyle);
    ///Gets the text host's maximum allowed length for the text.
    ///Params:
    ///    plength = Type: <b>DWORD*</b> The maximum allowed text length, in number of characters. If INFINITE is returned, the
    ///              text services object can use as much memory as needed to store any specified text.
    ///Returns:
    ///    Type: <b>HRESULT</b> The return value is <b>S_OK</b>.
    ///    
    HRESULT TxGetMaxLength(uint* plength);
    ///Requests information about the scroll bars supported by the text host.
    ///Params:
    ///    pdwScrollBar = Type: <b>DWORD*</b> The scroll bar. This parameter can be a combination of the following window styles
    ///                   related to scroll bars. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                   id="WS_VSCROLL"></a><a id="ws_vscroll"></a><dl> <dt><b>WS_VSCROLL</b></dt> </dl> </td> <td width="60%">
    ///                   Supports a vertical scroll bar. </td> </tr> <tr> <td width="40%"><a id="WS_HSCROLL"></a><a
    ///                   id="ws_hscroll"></a><dl> <dt><b>WS_HSCROLL</b></dt> </dl> </td> <td width="60%"> Supports a horizontal scroll
    ///                   bar. </td> </tr> <tr> <td width="40%"><a id="ES_AUTOVSCROLL"></a><a id="es_autovscroll"></a><dl>
    ///                   <dt><b>ES_AUTOVSCROLL</b></dt> </dl> </td> <td width="60%"> Automatically scrolls text up one page when the
    ///                   user presses ENTER on the last line. </td> </tr> <tr> <td width="40%"><a id="ES_AUTOHSCROLL"></a><a
    ///                   id="es_autohscroll"></a><dl> <dt><b>ES_AUTOHSCROLL</b></dt> </dl> </td> <td width="60%"> Automatically
    ///                   scrolls text to the right by 10 characters when the user types a character at the end of the line. When the
    ///                   user presses ENTER, the control scrolls all text back to position zero. </td> </tr> <tr> <td width="40%"><a
    ///                   id="ES_DISABLENOSCROLL"></a><a id="es_disablenoscroll"></a><dl> <dt><b>ES_DISABLENOSCROLL</b></dt> </dl>
    ///                   </td> <td width="60%"> Disables scroll bars instead of hiding them when they are not needed. </td> </tr>
    ///                   </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> The return value is <b>S_OK</b>.
    ///    
    HRESULT TxGetScrollBars(uint* pdwScrollBar);
    ///Requests the text host's password character.
    ///Params:
    ///    pch = Type: <b>TCHAR*</b> The password character.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if the password character is enabled. Return S_FALSE if the password
    ///    character is not enabled. For more information on COM error codes, see Error Handling in COM.
    ///    
    HRESULT TxGetPasswordChar(byte* pch);
    ///Requests the special character to use for the underlining accelerator character.
    ///Params:
    ///    pcp = Type: <b>LONG*</b> The character position of the character to underline. This variable is set by the text
    ///          host. A character position of –1 (that is, negative one) indicates that no character should be underlined.
    ///Returns:
    ///    Type: <b>HRESULT</b> The return value is <b>S_OK</b>.
    ///    
    HRESULT TxGetAcceleratorPos(int* pcp);
    ///Requests the native size of the control in HIMETRIC.
    ///Params:
    ///    lpExtent = Type: <b>LPSIZEL</b> The size of the control in HIMETRIC, that is, where the unit is .01 millimeter.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if the method succeeds. Return the following COM error code if the method
    ///    fails. For more information on COM error codes, see Error Handling in COM. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%">
    ///    Not implemented. </td> </tr> </table>
    ///    
    HRESULT TxGetExtent(SIZE* lpExtent);
    ///Sets the default character format for the text host.
    ///Params:
    ///    pCF = Type: <b>const CHARFORMAT*</b> The new default-character format.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if the method succeeds. Return one of the following COM error codes if the
    ///    method fails. For more information on COM error codes, see Error Handling in COM. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more arguments are not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> </table>
    ///    
    HRESULT OnTxCharFormatChange(const(CHARFORMATW)* pCF);
    ///Sets the default paragraph format for the text host.
    ///Params:
    ///    pPF = Type: <b>const PARAFORMAT*</b> The new default paragraph format.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if the method succeeds. Return one of the following COM error codes if the
    ///    method fails. For more information on COM error codes, see Error Handling in COM. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more arguments are not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> </table>
    ///    
    HRESULT OnTxParaFormatChange(const(PARAFORMAT)* pPF);
    ///Requests the bit property settings for the text host.
    ///Params:
    ///    dwMask = Type: <b>DWORD</b> Mask of properties in which the caller is interested. For the possible bit values, see
    ///             <i>dwBits</i> in OnTxPropertyBitsChange.
    ///    pdwBits = Type: <b>DWORD*</b> The current settings for the properties specified by <i>dwMask</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> The return value is <b>S_OK</b>.
    ///    
    HRESULT TxGetPropertyBits(uint dwMask, uint* pdwBits);
    ///Notifies the text host of various events.
    ///Params:
    ///    iNotify = Type: <b>DWORD</b> Event to notify host of. One of the <b>EN_</b> notification codes.
    ///    pv = Type: <b>void*</b> Extra data, dependent on <i>iNotify</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if the method succeeds. Return S_FALSE if the method fails. For more
    ///    information on COM error codes, see Error Handling in COM.
    ///    
    HRESULT TxNotify(uint iNotify, void* pv);
    ///Retrieves the Input Method Editor (IME) input context associated with the text services host. This method is used
    ///only in Asian-language versions of the operating system.
    ///Returns:
    ///    Type: <b>HIMC</b> The handle to the input context.
    ///    
    HIMC__* TxImmGetContext();
    ///Releases an input context returned by the ITextHost::TxImmGetContext method and unlocks the memory associated
    ///with the context. This method is used only in Asian-language versions of the operating system.
    ///Params:
    ///    himc = Type: <b>HIMC</b> The input context.
    void    TxImmReleaseContext(HIMC__* himc);
    ///Returns the size of selection bar in HIMETRIC.
    ///Params:
    ///    lSelBarWidth = Type: <b>LONG*</b> The width, in HIMETRIC (that is, where the units are .01 millimeter), of the selection
    ///                   bar.
    ///Returns:
    ///    Type: <b>HRESULT</b> The return value is <b>S_OK</b>.
    ///    
    HRESULT TxGetSelectionBarWidth(int* lSelBarWidth);
}

///Enables the host container of a windowless rich edit control to obtain the Microsoft UI Automation provider for the
///parent of the control.
interface IRicheditWindowlessAccessibility : IUnknown
{
    ///Obtains a Microsoft UI Automation provider object for the parent of a windowless rich edit control.
    ///Params:
    ///    pSite = Type: <b>IRawElementProviderWindowlessSite*</b> The ActiveX control site that hosts the windowless rich edit
    ///            control.
    ///    ppProvider = Type: <b>IRawElementProviderSimple**</b> The UI Automation provider for the windowless rich edit control's
    ///                 parent.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateProvider(IRawElementProviderWindowlessSite pSite, IRawElementProviderSimple* ppProvider);
}

///Provides Microsoft UI Automation accessibility information about a windowless rich edit control.
interface IRichEditUiaInformation : IUnknown
{
    ///Retrieves the bounding rectangle of a windowless rich edit control.
    ///Params:
    ///    pUiaRect = Type: <b>UiaRect*</b> The bounding rectangle, in screen coordinates.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBoundaryRectangle(UiaRect* pUiaRect);
    ///Indicates whether a windowless rich edit control is currently visible.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the windowless rich edit control is visible, or S_FALSE otherwise.
    ///    
    HRESULT IsVisible();
}

///Enables the host container of a windowless rich edit control to override the control's Microsoft UI Automation
///accessibility properties.
interface IRicheditUiaOverrides : IUnknown
{
    ///Retrieves the host container's override value for the specified Microsoft UI Automation accessibility property of
    ///a windowless rich edit control.
    ///Params:
    ///    propertyId = Type: <b>PROPERTYID </b> The identifier of the property to retrieve.
    ///    pRetValue = Type: <b>VARIANT*</b> The host container's override value for the <i>propertyId</i> property.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPropertyOverrideValue(int propertyId, VARIANT* pRetValue);
}

///The <b>ITextHost2</b> interface extends the ITextHost interface. The purpose of these interfaces, along with
///ITextServices and ITextServices2, is to enable rich edit controls to run without a dedicated window. The rich edit
///client typically has a window (<b>HWND</b>) that it shares with a number of windowless controls.
interface ITextHost2 : ITextHost
{
    ///Discovers whether the message queue contains a WM_LBUTTONDBLCLK message that is pending for the text host window.
    ///Returns:
    ///    Type: <b>BOOL</b> Returns <b>TRUE</b> if a WM_LBUTTONDBLCLK message is pending, or <b>FALSE</b> if not.
    ///    
    BOOL     TxIsDoubleClickPending();
    ///Retrieves the handle of the text host window for the rich edit control.
    ///Params:
    ///    phwnd = Type: <b>HWND*</b> The handle of the text host window.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT  TxGetWindow(HWND* phwnd);
    ///Sets the rich edit control's host window as the foreground window.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT  TxSetForegroundWindow();
    ///Retrieves the color palette of the rich edit control.
    ///Returns:
    ///    Type: <b>HPALETTE</b> Returns the color palette, or <b>NULL</b> if the control uses the system default color
    ///    palette.
    ///    
    HPALETTE TxGetPalette();
    ///Gets whether Input Method Editor (IME) input is allowed and whether the edit styles include ES_SELFIME.
    ///Params:
    ///    pFlags = Type: <b>LONG*</b> The East Asian flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///             width="40%"><a id="ES_NOIME"></a><a id="es_noime"></a><dl> <dt><b>ES_NOIME</b></dt> </dl> </td> <td
    ///             width="60%"> IME input is suppressed. </td> </tr> <tr> <td width="40%"><a id="ES_SELFIME"></a><a
    ///             id="es_selfime"></a><dl> <dt><b>ES_SELFIME</b></dt> </dl> </td> <td width="60%"> The rich edit client handles
    ///             IME imput. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT  TxGetEastAsianFlags(int* pFlags);
    ///Sets the shape of the cursor in the text host window.
    ///Params:
    ///    hcur = Type: <b>HCURSOR</b> The new cursor shape.
    ///    bText = Type: <b>BOOL</b> <b>TRUE</b> if the cursor is used for text, or <b>FALSE</b> if not.
    ///Returns:
    ///    Type: <b>HCURSOR</b> Returns the cursor that <i>hcur</i> is replacing.
    ///    
    HCURSOR  TxSetCursor2(HCURSOR hcur, BOOL bText);
    ///Notifies the text host that text services have been freed.
    void     TxFreeTextServicesNotification();
    ///Gets whether a rich edit control is in a dialog box.
    ///Params:
    ///    dwItem = Type: <b>DWORD</b> Mask that indicates the edit style flags to retrieve. It can be the following value. <a
    ///             id="TXES_ISDIALOG"></a> <a id="txes_isdialog"></a>
    ///    pdwData = Type: <b>DWORD*</b> <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///              id="TXES_ISDIALOG"></a><a id="txes_isdialog"></a><dl> <dt><b>TXES_ISDIALOG</b></dt> </dl> </td> <td
    ///              width="60%"> Indicates that the host of the rich edit control is a dialog box. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT  TxGetEditStyle(uint dwItem, uint* pdwData);
    ///Retrieves the window styles and extended windows styles of the text host window.
    ///Params:
    ///    pdwStyle = Type: <b>DWORD*</b> The window styles. For a description of the possible values, see Window Styles.
    ///    pdwExStyle = Type: <b>DWORD*</b> The extended windows styles. For a description of the possible values, see Extended
    ///                 Window Styles.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT  TxGetWindowStyles(uint* pdwStyle, uint* pdwExStyle);
    ///Shows or hides the caret during the drop portion of a drag-and-drop operation (Direct2D only).
    ///Params:
    ///    fShow = Type: <b>BOOL</b> Show or hide flag. <b>TRUE</b> shows the drop caret, and <b>FALSE</b> hides it.
    ///    hdc = Type: <b>HDC</b> The HDC.
    ///    prc = Type: <b>LPCRECT</b> The drop caret rectangle.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT  TxShowDropCaret(BOOL fShow, HDC hdc, RECT* prc);
    ///Destroys the caret (Direct2D only).
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT  TxDestroyCaret();
    ///Gets the horizontal scroll extent of the text host window.
    ///Params:
    ///    plHorzExtent = Type: <b>LONG*</b> The horizontal scroll extent.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT  TxGetHorzExtent(int* plHorzExtent);
}

///The <b>ITextServices2</b> interface extends the ITextServices interface.
interface ITextServices2 : ITextServices
{
    ///Resizes a control so it fits its content appropriately. This method is similar to TxGetNaturalSize, but also
    ///retrieves the ascent of the top line of text.
    ///Params:
    ///    dwAspect = Type: <b>DWORD</b> The aspect for the drawing. It can be any of the values from the DVASPECT enumeration.
    ///    hdcDraw = Type: <b>HDC</b> The device context into which drawing occurs.
    ///    hicTargetDev = Type: <b>HDC</b> The device context for which text should be formatted (that is, for WYSIWYG).
    ///    ptd = Type: <b>DVTARGETDEVICE*</b> More information on the target device.
    ///    dwMode = Type: <b>DWORD</b> The type of fitting requested. It can be one of the following. <table> <tr> <th>Value</th>
    ///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TXTNS_EMU"></a><a id="txtns_emu"></a><dl>
    ///             <dt><b>TXTNS_EMU</b></dt> </dl> </td> <td width="60%"> Use English Metric Units (EMUs) instead of pixels as
    ///             the measuring units (both ways) for this method's parameters. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTNS_FITTOCONTENT"></a><a id="txtns_fittocontent"></a><dl> <dt><b>TXTNS_FITTOCONTENT</b></dt> </dl>
    ///             </td> <td width="60%"> Resize the control to fit the entire text by formatting the text to the width that is
    ///             passed in. The text services object returns the height of the entire text and the width of the widest line.
    ///             For example, this should be done when the user double-clicks one of the control's handles. </td> </tr> <tr>
    ///             <td width="40%"><a id="TXTNS_FITTOCONTENT2"></a><a id="txtns_fittocontent2"></a><dl>
    ///             <dt><b>TXTNS_FITTOCONTENT2</b></dt> </dl> </td> <td width="60%"> Resize the control so that it fits indented
    ///             content. </td> </tr> <tr> <td width="40%"><a id="TXTNS_FITTOCONTENT3"></a><a
    ///             id="txtns_fittocontent3"></a><dl> <dt><b>TXTNS_FITTOCONTENT3</b></dt> </dl> </td> <td width="60%"> Resize the
    ///             control so that it fits indented content and trailing white space. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTNS_FITTOCONTENTWSP"></a><a id="txtns_fittocontentwsp"></a><dl> <dt><b>TXTNS_FITTOCONTENTWSP</b></dt>
    ///             </dl> </td> <td width="60%"> Resize the control so that it fits unindented content and trailing white space.
    ///             </td> </tr> <tr> <td width="40%"><a id="TXTNS_INCLUDELASTLINE"></a><a id="txtns_includelastline"></a><dl>
    ///             <dt><b>TXTNS_INCLUDELASTLINE</b></dt> </dl> </td> <td width="60%"> For a plain-text control, include the
    ///             height of the final carriage return when calculating the size. </td> </tr> <tr> <td width="40%"><a
    ///             id="TXTNS_ROUNDTOLINE"></a><a id="txtns_roundtoline"></a><dl> <dt><b>TXTNS_ROUNDTOLINE</b></dt> </dl> </td>
    ///             <td width="60%"> Resize the control to show an integral number of lines (no line is clipped). Format enough
    ///             text to fill the width and height that is passed in, and then return a height that is rounded to the nearest
    ///             line boundary. <div class="alert"><b>Note</b> The passed and returned width and height correspond to the view
    ///             rectangle. The host should adjust back to the client rectangle as needed. Because these values represent the
    ///             extent of the text object, they are input and output in HIMETRIC coordinates (each HIMETRIC unit is 0.01
    ///             millimeter), and measuring does not include any zoom factor. For a discussion of the zoom factor, see
    ///             TxGetExtent.</div> <div> </div> </td> </tr> </table>
    ///    psizelExtent = Type: <b>const SIZEL*</b> Sizes of extents (in HIMETRIC units) to use for zooming.
    ///    pwidth = Type: <b>LONG*</b> The width for the fitting defined by <i>dwMode</i>.
    ///    pheight = Type: <b>LONG*</b> The height for the fitting defined by <i>dwMode</i>.
    ///    pascent = Type: <b>LONG*</b> For single-line controls, receives the ascent (units above the baseline) of characters in
    ///              the top line of text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, the return value is <b>S_OK</b>. If text services could not
    ///    activate the object, the return value is one of the following <b>HRESULT</b> codes. For more information on
    ///    COM error codes, see Error Handling in COM. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unable to determine correct size.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more
    ///    arguments are not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT TxGetNaturalSize2(uint dwAspect, HDC hdcDraw, HDC hicTargetDev, DVTARGETDEVICE* ptd, uint dwMode, 
                              const(SIZE)* psizelExtent, int* pwidth, int* pheight, int* pascent);
    ///Draws the text services object by using Direct2D rendering.
    ///Params:
    ///    pRenderTarget = Type: <b>ID2D1RenderTarget*</b> The Direct2D rendering object that draws the text services object.
    ///    lprcBounds = Type: <b>LPCRECTL</b> The bounding (client) rectangle.
    ///    lprcUpdate = Type: <b>LPRECT</b> The rectangle to update inside <i>lprcBounds</i> rectangle, in the logical coordinate
    ///                 system of drawing device context. If this parameter is NULL, the entire client rectangle should be drawn.
    ///    lViewId = Type: <b>LONG</b> The view to draw. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///              width="40%"><a id="TXTVIEW_ACTIVE"></a><a id="txtview_active"></a><dl> <dt><b>TXTVIEW_ACTIVE</b></dt> </dl>
    ///              </td> <td width="60%"> Draw the in-place active view. </td> </tr> <tr> <td width="40%"><a
    ///              id="TXTVIEW_INACTIVE"></a><a id="txtview_inactive"></a><dl> <dt><b>TXTVIEW_INACTIVE</b></dt> </dl> </td> <td
    ///              width="60%"> Draw a view other than the in-place active view, for example, a print preview. </td> </tr>
    ///              </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT TxDrawD2D(ID2D1RenderTarget pRenderTarget, RECTL* lprcBounds, RECT* lprcUpdate, int lViewId);
}


// GUIDs

const GUID CLSID_ImageList = GUIDOF!ImageList;

const GUID IID_IImageList        = GUIDOF!IImageList;
const GUID IID_IImageList2       = GUIDOF!IImageList2;
const GUID IID_ITextDisplays     = GUIDOF!ITextDisplays;
const GUID IID_ITextDocument     = GUIDOF!ITextDocument;
const GUID IID_ITextDocument2    = GUIDOF!ITextDocument2;
const GUID IID_ITextDocument2Old = GUIDOF!ITextDocument2Old;
const GUID IID_ITextFont         = GUIDOF!ITextFont;
const GUID IID_ITextFont2        = GUIDOF!ITextFont2;
const GUID IID_ITextPara         = GUIDOF!ITextPara;
const GUID IID_ITextPara2        = GUIDOF!ITextPara2;
const GUID IID_ITextRange        = GUIDOF!ITextRange;
const GUID IID_ITextRange2       = GUIDOF!ITextRange2;
const GUID IID_ITextRow          = GUIDOF!ITextRow;
const GUID IID_ITextSelection    = GUIDOF!ITextSelection;
const GUID IID_ITextSelection2   = GUIDOF!ITextSelection2;
const GUID IID_ITextStory        = GUIDOF!ITextStory;
const GUID IID_ITextStoryRanges  = GUIDOF!ITextStoryRanges;
const GUID IID_ITextStoryRanges2 = GUIDOF!ITextStoryRanges2;
const GUID IID_ITextStrings      = GUIDOF!ITextStrings;
