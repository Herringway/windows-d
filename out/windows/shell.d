// Written in the D programming language.

module windows.shell;

public import windows.core;
public import windows.activedirectory : BFFCALLBACK;
public import windows.audio : IPropertyStore;
public import windows.automation : BSTR, DISPPARAMS, EXCEPINFO, IDispatch,
                                   IPropertyBag, VARIANT;
public import windows.com : BYTE_BLOB, FORMATETC, HRESULT, IBindCtx, IBindStatusCallback,
                            IConnectionPoint, IDataObject, IDropSource,
                            IDropTarget, IEnumFORMATETC, IEnumGUID,
                            IEnumString, IEnumUnknown, IMalloc, IMoniker,
                            IOleCommandTarget, IOleInPlaceSite, IOleObject,
                            IOleWindow, IPersist, IUnknown, OleMenuGroupWidths;
public import windows.controls : HIMAGELIST, HPROPSHEETPAGE, LPFNADDPROPSHEETPAGE,
                                 NMHDR, TBBUTTON;
public import windows.dbg : IEnumPrivacyRecords;
public import windows.displaydevices : POINT, POINTL, RECT, RECTL, SIZE;
public import windows.filesystem : WIN32_FIND_DATAA, WIN32_FIND_DATAW;
public import windows.gdi : HBITMAP, HDC, HICON, HPALETTE;
public import windows.intl : CANDIDATEFORM, CANDIDATELIST, COMPOSITIONFORM, HIMCC__,
                             HIMC__, IMEMENUITEMINFOA, IMEMENUITEMINFOW,
                             REGISTERWORDA, REGISTERWORDW, STYLEBUFA,
                             STYLEBUFW;
public import windows.iphelper : NET_ADDRESS_INFO;
public import windows.menusandresources : HACCEL, HMENU;
public import windows.search : ICondition;
public import windows.security : NETRESOURCEA, SID_AND_ATTRIBUTES;
public import windows.structuredstorage : IPropertySetStorage, IStorage, IStream, PROPVARIANT;
public import windows.systemservices : BOOL, COORD, HANDLE, HINSTANCE, IServiceProvider,
                                       LARGE_INTEGER, LPTHREAD_START_ROUTINE,
                                       LRESULT, LSTATUS, NTSTATUS, OVERLAPPED,
                                       PROCESS_INFORMATION, SECURITY_ATTRIBUTES,
                                       STARTUPINFOW, ULARGE_INTEGER;
public import windows.windowsandmessaging : CREATESTRUCTW, HWND, LPARAM, MSG, WPARAM;
public import windows.windowsprogramming : FILETIME, HKEY, IWebBrowser2, IXMLDOMDocument,
                                           SYSTEMTIME;
public import windows.windowspropertiessystem : GETPROPERTYSTOREFLAGS, IPropertyChangeArray,
                                                IPropertyDescriptionList,
                                                IPropertyStoreFactory, PDOPSTATUS,
                                                PROPERTYKEY, SERIALIZEDPROPSTORAGE;

extern(Windows):


// Enums


alias ASSOCCLASS = int;
enum : int
{
    ASSOCCLASS_SHELL_KEY        = 0x00000000,
    ASSOCCLASS_PROGID_KEY       = 0x00000001,
    ASSOCCLASS_PROGID_STR       = 0x00000002,
    ASSOCCLASS_CLSID_KEY        = 0x00000003,
    ASSOCCLASS_CLSID_STR        = 0x00000004,
    ASSOCCLASS_APP_KEY          = 0x00000005,
    ASSOCCLASS_APP_STR          = 0x00000006,
    ASSOCCLASS_SYSTEM_STR       = 0x00000007,
    ASSOCCLASS_FOLDER           = 0x00000008,
    ASSOCCLASS_STAR             = 0x00000009,
    ASSOCCLASS_FIXED_PROGID_STR = 0x0000000a,
    ASSOCCLASS_PROTOCOL_STR     = 0x0000000b,
}

///Specifies the state of the machine for the current user in relation to the propriety of sending a notification. Used
///by SHQueryUserNotificationState.
alias QUERY_USER_NOTIFICATION_STATE = int;
enum : int
{
    ///A screen saver is displayed, the machine is locked, or a nonactive Fast User Switching session is in progress.
    QUNS_NOT_PRESENT             = 0x00000001,
    ///A full-screen application is running or Presentation Settings are applied. Presentation Settings allow a user to
    ///put their machine into a state fit for an uninterrupted presentation, such as a set of PowerPoint slides, with a
    ///single click.
    QUNS_BUSY                    = 0x00000002,
    ///A full-screen (exclusive mode) Direct3D application is running.
    QUNS_RUNNING_D3D_FULL_SCREEN = 0x00000003,
    ///The user has activated Windows presentation settings to block notifications and pop-up messages.
    QUNS_PRESENTATION_MODE       = 0x00000004,
    ///None of the other states are found, notifications can be freely sent.
    QUNS_ACCEPTS_NOTIFICATIONS   = 0x00000005,
    ///<b>Introduced in Windows 7</b>. The current user is in "quiet time", which is the first hour after a new user
    ///logs into his or her account for the first time. During this time, most notifications should not be sent or
    ///shown. This lets a user become accustomed to a new computer system without those distractions. Quiet time also
    ///occurs for each user after an operating system upgrade or clean installation. Applications should set the
    ///NIIF_RESPECT_QUIET_TIME flag in their notifications or balloon tooltip, which prevents those items from being
    ///displayed while the current user is in the quiet-time state. Note that during quiet time, if the user is in one
    ///of the other blocked modes (QUNS_NOT_PRESENT, QUNS_BUSY, QUNS_PRESENTATION_MODE, or QUNS_RUNNING_D3D_FULL_SCREEN)
    ///SHQueryUserNotificationState returns only that value, and does not report QUNS_QUIET_TIME.
    QUNS_QUIET_TIME              = 0x00000006,
    QUNS_APP                     = 0x00000007,
}

///Used by SHGetStockIconInfo to identify which stock system icon to retrieve.
alias SHSTOCKICONID = int;
enum : int
{
    ///<img alt="Blank document icon" src="./images/SIID_DOCNOASSOC.png"/> Document of a type with no associated
    ///application.
    SIID_DOCNOASSOC        = 0x00000000,
    ///<img alt="Application-associated document icon" src="./images/SIID_DOCASSOC.jpg"/> Document of a type with an
    ///associated application.
    SIID_DOCASSOC          = 0x00000001,
    ///<img alt="" src="./images/SIID_APPLICATION.jpg"/> Generic application with no custom icon.
    SIID_APPLICATION       = 0x00000002,
    ///<img alt="" src="./images/SIID_FOLDER.jpg"/> Folder (generic, unspecified state).
    SIID_FOLDER            = 0x00000003,
    ///<img alt="" src="./images/SIID_FOLDEROPEN.jpg"/> Folder (open).
    SIID_FOLDEROPEN        = 0x00000004,
    ///<img alt="" src="./images/SIID_DRIVE525.jpg"/> 5.25-inch disk drive.
    SIID_DRIVE525          = 0x00000005,
    ///<img alt="" src="./images/SIID_DRIVE35.jpg"/> 3.5-inch disk drive.
    SIID_DRIVE35           = 0x00000006,
    ///<img alt="" src="./images/SIID_DRIVEREMOVE.png"/> Removable drive.
    SIID_DRIVEREMOVE       = 0x00000007,
    ///<img alt="" src="./images/SIID_DRIVEFIXED.jpg"/> Fixed drive (hard disk).
    SIID_DRIVEFIXED        = 0x00000008,
    ///<img alt="" src="./images/SIID_DRIVENET.jpg"/> Network drive (connected).
    SIID_DRIVENET          = 0x00000009,
    ///<img alt="" src="./images/SIID_DRIVENETDISABLED.jpg"/> Network drive (disconnected).
    SIID_DRIVENETDISABLED  = 0x0000000a,
    ///<img alt="" src="./images/SIID_DRIVECD.jpg"/> CD drive.
    SIID_DRIVECD           = 0x0000000b,
    ///<img alt="" src="./images/SIID_DRIVERAM.jpg"/> RAM disk drive.
    SIID_DRIVERAM          = 0x0000000c,
    ///<img alt="" src="./images/SIID_WORLD.jpg"/> The entire network.
    SIID_WORLD             = 0x0000000d,
    ///<img alt="" src="./images/SIID_SERVER.jpg"/> A computer on the network.
    SIID_SERVER            = 0x0000000f,
    ///<img alt="" src="./images/SIID_PRINTER.jpg"/> A local printer or print destination.
    SIID_PRINTER           = 0x00000010,
    ///<img alt="" src="./images/SIID_MYNETWORK.jpg"/> The <b>Network</b> virtual folder
    ///(FOLDERID_NetworkFolder/CSIDL_NETWORK).
    SIID_MYNETWORK         = 0x00000011,
    ///<img alt="" src="./images/SIID_FIND.jpg"/> The <b>Search</b> feature.
    SIID_FIND              = 0x00000016,
    ///<img alt="" src="./images/SIID_HELP.jpg"/> The <b>Help and Support</b> feature.
    SIID_HELP              = 0x00000017,
    ///<img alt="" src="./images/SIID_SHARE.jpg"/> Overlay for a shared item.
    SIID_SHARE             = 0x0000001c,
    ///<img alt="" src="./images/SIID_LINK.jpg"/> Overlay for a shortcut.
    SIID_LINK              = 0x0000001d,
    ///<img alt="" src="./images/SIID_SLOWFILE.png"/> Overlay for items that are expected to be slow to access.
    SIID_SLOWFILE          = 0x0000001e,
    ///<img alt="" src="./images/SIID_RECYCLER.jpg"/> The Recycle Bin (empty).
    SIID_RECYCLER          = 0x0000001f,
    ///<img alt="" src="./images/SIID_RECYCLERFULL.jpg"/> The Recycle Bin (not empty).
    SIID_RECYCLERFULL      = 0x00000020,
    ///<img alt="" src="./images/SIID_MEDIACDAUDIO.jpg"/> Audio CD media.
    SIID_MEDIACDAUDIO      = 0x00000028,
    ///<img alt="" src="./images/SIID_LOCK.jpg"/> Security lock.
    SIID_LOCK              = 0x0000002f,
    ///<img alt="" src="./images/SIID_AUTOLIST.jpg"/> A virtual folder that contains the results of a search.
    SIID_AUTOLIST          = 0x00000031,
    ///<img alt="" src="./images/SIID_PRINTERNET.jpg"/> A network printer.
    SIID_PRINTERNET        = 0x00000032,
    ///<img alt="" src="./images/SIID_SERVERSHARE.jpg"/> A server shared on a network.
    SIID_SERVERSHARE       = 0x00000033,
    ///<img alt="" src="./images/SIID_PRINTERFAX.jpg"/> A local fax printer.
    SIID_PRINTERFAX        = 0x00000034,
    ///<img alt="" src="./images/SIID_PRINTERFAXNET.jpg"/> A network fax printer.
    SIID_PRINTERFAXNET     = 0x00000035,
    ///<img alt="" src="./images/SIID_PRINTERFILE.jpg"/> A file that receives the output of a <b>Print to file</b>
    ///operation.
    SIID_PRINTERFILE       = 0x00000036,
    ///<img alt="" src="./images/SIID_STACK.jpg"/> A category that results from a <b>Stack by</b> command to organize
    ///the contents of a folder.
    SIID_STACK             = 0x00000037,
    ///<img alt="" src="./images/SIID_MEDIASVCD.jpg"/> Super Video CD (SVCD) media.
    SIID_MEDIASVCD         = 0x00000038,
    ///<img alt="" src="./images/SIID_STUFFEDFOLDER.jpg"/> A folder that contains only subfolders as child items.
    SIID_STUFFEDFOLDER     = 0x00000039,
    ///<img alt="" src="./images/SIID_DRIVEUNKNOWN.jpg"/> Unknown drive type.
    SIID_DRIVEUNKNOWN      = 0x0000003a,
    ///<img alt="" src="./images/SIID_DRIVEDVD.jpg"/> DVD drive.
    SIID_DRIVEDVD          = 0x0000003b,
    ///<img alt="" src="./images/SIID_MEDIADVD.jpg"/> DVD media.
    SIID_MEDIADVD          = 0x0000003c,
    ///<img alt="" src="./images/SIID_MEDIADVDRAM.jpg"/> DVD-RAM media.
    SIID_MEDIADVDRAM       = 0x0000003d,
    ///<img alt="" src="./images/SIID_MEDIADVDRW.jpg"/> DVD-RW media.
    SIID_MEDIADVDRW        = 0x0000003e,
    ///<img alt="" src="./images/SIID_MEDIADVDR.jpg"/> DVD-R media.
    SIID_MEDIADVDR         = 0x0000003f,
    ///<img alt="" src="./images/SIID_MEDIADVDROM.jpg"/> DVD-ROM media.
    SIID_MEDIADVDROM       = 0x00000040,
    ///<img alt="" src="./images/SIID_MEDIACDAUDIOPLUS.jpg"/> CD+ (enhanced audio CD) media.
    SIID_MEDIACDAUDIOPLUS  = 0x00000041,
    ///<img alt="" src="./images/SIID_MEDIACDRW.jpg"/> CD-RW media.
    SIID_MEDIACDRW         = 0x00000042,
    ///<img alt="" src="./images/SIID_MEDIACDR.jpg"/> CD-R media.
    SIID_MEDIACDR          = 0x00000043,
    ///<img alt="" src="./images/SIID_MEDIACDBURN.jpg"/> A writeable CD in the process of being burned.
    SIID_MEDIACDBURN       = 0x00000044,
    ///<img alt="" src="./images/SIID_MEDIABLANKCD.jpg"/> Blank writable CD media.
    SIID_MEDIABLANKCD      = 0x00000045,
    ///<img alt="" src="./images/SIID_MEDIACDROM.jpg"/> CD-ROM media.
    SIID_MEDIACDROM        = 0x00000046,
    ///<img alt="" src="./images/SIID_AUDIOFILES.jpg"/> An audio file.
    SIID_AUDIOFILES        = 0x00000047,
    ///<img alt="" src="./images/SIID_IMAGEFILES.jpg"/> An image file.
    SIID_IMAGEFILES        = 0x00000048,
    ///<img alt="" src="./images/SIID_VIDEOFILES.jpg"/> A video file.
    SIID_VIDEOFILES        = 0x00000049,
    ///<img alt="" src="./images/SIID_MIXEDFILES.jpg"/> A mixed file.
    SIID_MIXEDFILES        = 0x0000004a,
    ///<img alt="" src="./images/SIID_FOLDERBACK.jpg"/> Folder back.
    SIID_FOLDERBACK        = 0x0000004b,
    ///<img alt="" src="./images/SIID_FOLDERFRONT.jpg"/> Folder front.
    SIID_FOLDERFRONT       = 0x0000004c,
    ///<img alt="" src="./images/SIID_SHIELD.jpg"/> Security shield. Use for UAC prompts only.
    SIID_SHIELD            = 0x0000004d,
    ///<img alt="" src="./images/SIID_WARNING.jpg"/> Warning.
    SIID_WARNING           = 0x0000004e,
    ///<img alt="" src="./images/SIID_INFO.jpg"/> Informational.
    SIID_INFO              = 0x0000004f,
    ///<img alt="" src="./images/SIID_ERROR.jpg"/> Error.
    SIID_ERROR             = 0x00000050,
    ///<img alt="" src="./images/SIID_KEY.jpg"/> Key.
    SIID_KEY               = 0x00000051,
    ///<img alt="" src="./images/SIID_SOFTWARE.jpg"/> Software.
    SIID_SOFTWARE          = 0x00000052,
    ///<img alt="" src="./images/SIID_RENAME.jpg"/> A UI item, such as a button, that issues a rename command.
    SIID_RENAME            = 0x00000053,
    ///<img alt="" src="./images/SIID_DELETE.jpg"/> A UI item, such as a button, that issues a delete command.
    SIID_DELETE            = 0x00000054,
    ///<img alt="" src="./images/SIID_MEDIAAUDIODVD.jpg"/> Audio DVD media.
    SIID_MEDIAAUDIODVD     = 0x00000055,
    ///<img alt="" src="./images/SIID_MEDIAMOVIEDVD.jpg"/> Movie DVD media.
    SIID_MEDIAMOVIEDVD     = 0x00000056,
    ///<img alt="" src="./images/SIID_MEDIAENHANCEDCD.jpg"/> Enhanced CD media.
    SIID_MEDIAENHANCEDCD   = 0x00000057,
    ///<img alt="" src="./images/SIID_MEDIAENHANCEDDVD.jpg"/> Enhanced DVD media.
    SIID_MEDIAENHANCEDDVD  = 0x00000058,
    ///<img alt="" src="./images/SIID_MEDIAHDDVD.jpg"/> High definition DVD media in the HD DVD format.
    SIID_MEDIAHDDVD        = 0x00000059,
    ///<img alt="" src="./images/SIID_MEDIABLURAY.jpg"/> High definition DVD media in the Blu-ray Disc™ format.
    SIID_MEDIABLURAY       = 0x0000005a,
    ///<img alt="" src="./images/SIID_MEDIAVCD.jpg"/> Video CD (VCD) media.
    SIID_MEDIAVCD          = 0x0000005b,
    ///<img alt="" src="./images/SIID_MEDIADVDPLUSR.jpg"/> DVD+R media.
    SIID_MEDIADVDPLUSR     = 0x0000005c,
    ///<img alt="" src="./images/SIID_MEDIADVDPLUSRW.jpg"/> DVD+RW media.
    SIID_MEDIADVDPLUSRW    = 0x0000005d,
    ///<img alt="" src="./images/SIID_DESKTOPPC.jpg"/> A desktop computer.
    SIID_DESKTOPPC         = 0x0000005e,
    ///<img alt="" src="./images/SIID_MOBILEPC.jpg"/> A mobile computer (laptop).
    SIID_MOBILEPC          = 0x0000005f,
    ///<img alt="" src="./images/SIID_USERS.jpg"/> The <b>User Accounts</b> Control Panel item.
    SIID_USERS             = 0x00000060,
    ///<img alt="" src="./images/SIID_MEDIASMARTMEDIA.jpg"/> Smart media.
    SIID_MEDIASMARTMEDIA   = 0x00000061,
    ///<img alt="" src="./images/SIID_MEDIACOMPACTFLASH.jpg"/> CompactFlash media.
    SIID_MEDIACOMPACTFLASH = 0x00000062,
    ///<img alt="" src="./images/SIID_DEVICECELLPHONE.jpg"/> A cell phone.
    SIID_DEVICECELLPHONE   = 0x00000063,
    ///<img alt="" src="./images/SIID_DEVICECAMERA.jpg"/> A digital camera.
    SIID_DEVICECAMERA      = 0x00000064,
    ///<img alt="" src="./images/SIID_DEVICEVIDEOCAMERA.jpg"/> A digital video camera.
    SIID_DEVICEVIDEOCAMERA = 0x00000065,
    ///<img alt="" src="./images/SIID_DEVICEAUDIOPLAYER.jpg"/> An audio player.
    SIID_DEVICEAUDIOPLAYER = 0x00000066,
    ///<img alt="" src="./images/SIID_NETWORKCONNECT.jpg"/> Connect to network.
    SIID_NETWORKCONNECT    = 0x00000067,
    ///<img alt="" src="./images/SIID_INTERNET.jpg"/> The <b>Network and Internet</b> Control Panel item.
    SIID_INTERNET          = 0x00000068,
    ///<img alt="" src="./images/SIID_ZIPFILE.jpg"/> A compressed file with a .zip file name extension.
    SIID_ZIPFILE           = 0x00000069,
    ///<img alt="" src="./images/SIID_SETTINGS.jpg"/> The <b>Additional Options</b> Control Panel item.
    SIID_SETTINGS          = 0x0000006a,
    ///<img alt="" src="./images/SIID_DRIVEHDDVD.jpg"/> <b>Windows Vista with Service Pack 1 (SP1) and later</b>. High
    ///definition DVD drive (any type - HD DVD-ROM, HD DVD-R, HD-DVD-RAM) that uses the HD DVD format.
    SIID_DRIVEHDDVD        = 0x00000084,
    ///<img alt="" src="./images/SIID_DRIVEBD.jpg"/> <b>Windows Vista with SP1 and later</b>. High definition DVD drive
    ///(any type - BD-ROM, BD-R, BD-RE) that uses the Blu-ray Disc format.
    SIID_DRIVEBD           = 0x00000085,
    ///<img alt="" src="./images/SIID_MEDIAHDDVDROM.jpg"/> <b>Windows Vista with SP1 and later</b>. High definition
    ///DVD-ROM media in the HD DVD-ROM format.
    SIID_MEDIAHDDVDROM     = 0x00000086,
    ///<img alt="" src="./images/SIID_MEDIAHDDVDR.jpg"/> <b>Windows Vista with SP1 and later</b>. High definition DVD-R
    ///media in the HD DVD-R format.
    SIID_MEDIAHDDVDR       = 0x00000087,
    ///<img alt="" src="./images/SIID_MEDIAHDDVDRAM.jpg"/> <b>Windows Vista with SP1 and later</b>. High definition
    ///DVD-RAM media in the HD DVD-RAM format.
    SIID_MEDIAHDDVDRAM     = 0x00000088,
    ///<img alt="" src="./images/SIID_MEDIABDROM.jpg"/> <b>Windows Vista with SP1 and later</b>. High definition DVD-ROM
    ///media in the Blu-ray Disc BD-ROM format.
    SIID_MEDIABDROM        = 0x00000089,
    ///<img alt="" src="./images/SIID_MEDIABDR.jpg"/> <b>Windows Vista with SP1 and later</b>. High definition
    ///write-once media in the Blu-ray Disc BD-R format.
    SIID_MEDIABDR          = 0x0000008a,
    ///<img alt="" src="./images/SIID_MEDIABDRE.jpg"/> <b>Windows Vista with SP1 and later</b>. High definition
    ///read/write media in the Blu-ray Disc BD-RE format.
    SIID_MEDIABDRE         = 0x0000008b,
    ///<img alt="" src="./images/SIID_CLUSTEREDDRIVE.jpg"/> <b>Windows Vista with SP1 and later</b>. A cluster disk
    ///array.
    SIID_CLUSTEREDDRIVE    = 0x0000008c,
    ///The highest valid value in the enumeration. Values over 160 are Windows 7-only icons.
    SIID_MAX_ICONS         = 0x000000b5,
}

alias STRRET_TYPE = int;
enum : int
{
    STRRET_WSTR   = 0x00000000,
    STRRET_OFFSET = 0x00000001,
    STRRET_CSTR   = 0x00000002,
}

///Specifies a file's perceived type. This set of constants is used in the AssocGetPerceivedType function.
alias PERCEIVED = int;
enum : int
{
    PERCEIVED_TYPE_FIRST       = 0xfffffffd,
    ///The file's perceived type as defined in the registry is not a known type.
    PERCEIVED_TYPE_CUSTOM      = 0xfffffffd,
    ///The file does not have a perceived type.
    PERCEIVED_TYPE_UNSPECIFIED = 0xfffffffe,
    ///Not used.
    PERCEIVED_TYPE_FOLDER      = 0xffffffff,
    ///The file's perceived type hasn't yet been requested. This is the cached type of the object when it is created.
    ///This value is never returned by AssocGetPerceivedType.
    PERCEIVED_TYPE_UNKNOWN     = 0x00000000,
    ///The file's perceived type is "text".
    PERCEIVED_TYPE_TEXT        = 0x00000001,
    ///The file's perceived type is "image".
    PERCEIVED_TYPE_IMAGE       = 0x00000002,
    ///The file's perceived type is "audio".
    PERCEIVED_TYPE_AUDIO       = 0x00000003,
    ///The file's perceived type is "video".
    PERCEIVED_TYPE_VIDEO       = 0x00000004,
    ///The file's perceived type is "compressed".
    PERCEIVED_TYPE_COMPRESSED  = 0x00000005,
    ///The file's perceived type is "document".
    PERCEIVED_TYPE_DOCUMENT    = 0x00000006,
    ///The file's perceived type is "system".
    PERCEIVED_TYPE_SYSTEM      = 0x00000007,
    ///The file's perceived type is "application".
    PERCEIVED_TYPE_APPLICATION = 0x00000008,
    ///<b>Windows Vista and later</b>. The file's perceived type is "gamemedia".
    PERCEIVED_TYPE_GAMEMEDIA   = 0x00000009,
    ///<b>Windows Vista and later</b>.The file's perceived type is "contacts"
    PERCEIVED_TYPE_CONTACTS    = 0x0000000a,
    PERCEIVED_TYPE_LAST        = 0x0000000a,
}

///Describes how a property should be treated. These values are defined in Shtypes.h.
alias SHCOLSTATE = int;
enum : int
{
    ///The value is displayed according to default settings for the column.
    SHCOLSTATE_DEFAULT            = 0x00000000,
    ///The value is displayed as a string.
    SHCOLSTATE_TYPE_STR           = 0x00000001,
    ///The value is displayed as an integer.
    SHCOLSTATE_TYPE_INT           = 0x00000002,
    ///The value is displayed as a date/time.
    SHCOLSTATE_TYPE_DATE          = 0x00000003,
    ///A mask for display type values SHCOLSTATE_TYPE_STR, SHCOLSTATE_TYPE_STR, and SHCOLSTATE_TYPE_DATE.
    SHCOLSTATE_TYPEMASK           = 0x0000000f,
    ///The column should be on by default in Details view.
    SHCOLSTATE_ONBYDEFAULT        = 0x00000010,
    ///Will be slow to compute. Perform on a background thread.
    SHCOLSTATE_SLOW               = 0x00000020,
    ///Provided by a handler, not the folder.
    SHCOLSTATE_EXTENDED           = 0x00000040,
    ///Not displayed in the context menu, but is listed in the <b>More...</b> dialog.
    SHCOLSTATE_SECONDARYUI        = 0x00000080,
    ///Not displayed in the UI.
    SHCOLSTATE_HIDDEN             = 0x00000100,
    ///<b>VarCmp</b> produces same result as IShellFolder::CompareIDs.
    SHCOLSTATE_PREFER_VARCMP      = 0x00000200,
    ///PSFormatForDisplay produces same result as IShellFolder::CompareIDs.
    SHCOLSTATE_PREFER_FMTCMP      = 0x00000400,
    ///Do not sort folders separately.
    SHCOLSTATE_NOSORTBYFOLDERNESS = 0x00000800,
    ///Only displayed in the UI.
    SHCOLSTATE_VIEWONLY           = 0x00010000,
    ///Marks columns with values that should be read in a batch.
    SHCOLSTATE_BATCHREAD          = 0x00020000,
    ///Grouping is disabled for this column.
    SHCOLSTATE_NO_GROUPBY         = 0x00040000,
    ///Can't resize the column.
    SHCOLSTATE_FIXED_WIDTH        = 0x00001000,
    ///The width is the same in all dpi.
    SHCOLSTATE_NODPISCALE         = 0x00002000,
    ///Fixed width and height ratio.
    SHCOLSTATE_FIXED_RATIO        = 0x00004000,
    SHCOLSTATE_DISPLAYMASK        = 0x0000f000,
}

///Indicates a spoofed device scale factor, as a percent. Used by
///IApplicationDesignModeSettings::SetApplicationViewState and
///IApplicationDesignModeSettings::IsApplicationViewStateSupported
alias DEVICE_SCALE_FACTOR = int;
enum : int
{
    DEVICE_SCALE_FACTOR_INVALID = 0x00000000,
    ///100%. The scale factor for the device is 1x.
    SCALE_100_PERCENT           = 0x00000064,
    ///120%. The scale factor for the device is 1.2x.
    SCALE_120_PERCENT           = 0x00000078,
    SCALE_125_PERCENT           = 0x0000007d,
    ///140%. The scale factor for the device is 1.4x.
    SCALE_140_PERCENT           = 0x0000008c,
    ///150%. The scale factor for the device is 1.5x.
    SCALE_150_PERCENT           = 0x00000096,
    ///160%. The scale factor for the device is 1.6x.
    SCALE_160_PERCENT           = 0x000000a0,
    SCALE_175_PERCENT           = 0x000000af,
    ///180%. The scale factor for the device is 1.8x.
    SCALE_180_PERCENT           = 0x000000b4,
    SCALE_200_PERCENT           = 0x000000c8,
    ///225%. The scale factor for the device is 2.25x.
    SCALE_225_PERCENT           = 0x000000e1,
    SCALE_250_PERCENT           = 0x000000fa,
    SCALE_300_PERCENT           = 0x0000012c,
    SCALE_350_PERCENT           = 0x0000015e,
    SCALE_400_PERCENT           = 0x00000190,
    SCALE_450_PERCENT           = 0x000001c2,
    SCALE_500_PERCENT           = 0x000001f4,
}

///Defines the values used with the IShellFolder::GetDisplayNameOf and IShellFolder::SetNameOf methods to specify the
///type of file or folder names used by those methods. <div class="alert"><b>Note</b> Prior to Windows 7, these values
///were packaged as the SHGNO enumeration.</div><div> </div>
alias _SHGDNF = int;
enum : int
{
    ///When not combined with another flag, return the parent-relative name that identifies the item, suitable for
    ///displaying to the user. This name often does not include extra information such as the file name extension and
    ///does not need to be unique. This name might include information that identifies the folder that contains the
    ///item. For instance, this flag could cause IShellFolder::GetDisplayNameOf to return the string "<b>username</b>
    ///(on <b>Machine</b>)" for a particular user's folder.
    SHGDN_NORMAL        = 0x00000000,
    ///The name is relative to the folder from which the request was made. This is the name display to the user when
    ///used in the context of the folder. For example, it is used in the view and in the address bar path segment for
    ///the folder. This name should not include disambiguation information—for instance "<b>username</b>" instead of
    ///"<b>username</b> (on <i>Machine</i>)" for a particular user's folder. Use this flag in combinations with
    ///SHGDN_FORPARSING and SHGDN_FOREDITING.
    SHGDN_INFOLDER      = 0x00000001,
    ///The name is used for in-place editing when the user renames the item.
    SHGDN_FOREDITING    = 0x00001000,
    ///The name is displayed in an address bar combo box.
    SHGDN_FORADDRESSBAR = 0x00004000,
    ///The name is used for parsing. That is, it can be passed to IShellFolder::ParseDisplayName to recover the object's
    ///PIDL. The form this name takes depends on the particular object. When SHGDN_FORPARSING is used alone, the name is
    ///relative to the desktop. When combined with SHGDN_INFOLDER, the name is relative to the folder from which the
    ///request was made.
    SHGDN_FORPARSING    = 0x00008000,
}

///Determines the types of items included in an enumeration. These values are used with the IShellFolder::EnumObjects
///method.
alias _SHCONTF = int;
enum : int
{
    ///0x00010. <b>Windows 7 and later</b>. The calling application is checking for the existence of child items in the
    ///folder.
    SHCONTF_CHECKING_FOR_CHILDREN = 0x00000010,
    ///0x00020. Include items that are folders in the enumeration.
    SHCONTF_FOLDERS               = 0x00000020,
    ///0x00040. Include items that are not folders in the enumeration.
    SHCONTF_NONFOLDERS            = 0x00000040,
    ///0x00080. Include hidden items in the enumeration. This does not include hidden system items. (To include hidden
    ///system items, use SHCONTF_INCLUDESUPERHIDDEN.)
    SHCONTF_INCLUDEHIDDEN         = 0x00000080,
    ///0x00100. No longer used; always assumed. IShellFolder::EnumObjects can return without validating the enumeration
    ///object. Validation can be postponed until the first call to IEnumIDList::Next. Use this flag when a user
    ///interface might be displayed prior to the first <b>IEnumIDList::Next</b> call. For a user interface to be
    ///presented, <i>hwnd</i> must be set to a valid window handle.
    SHCONTF_INIT_ON_FIRST_NEXT    = 0x00000100,
    ///0x00200. The calling application is looking for printer objects.
    SHCONTF_NETPRINTERSRCH        = 0x00000200,
    ///0x00400. The calling application is looking for resources that can be shared.
    SHCONTF_SHAREABLE             = 0x00000400,
    ///0x00800. Include items with accessible storage and their ancestors, including hidden items.
    SHCONTF_STORAGE               = 0x00000800,
    ///0x01000. <b>Windows 7 and later</b>. Child folders should provide a navigation enumeration.
    SHCONTF_NAVIGATION_ENUM       = 0x00001000,
    ///0x02000. <b>Windows Vista and later</b>. The calling application is looking for resources that can be enumerated
    ///quickly.
    SHCONTF_FASTITEMS             = 0x00002000,
    ///0x04000. <b>Windows Vista and later</b>. Enumerate items as a simple list even if the folder itself is not
    ///structured in that way.
    SHCONTF_FLATLIST              = 0x00004000,
    ///0x08000. <b>Windows Vista and later</b>. The calling application is monitoring for change notifications. This
    ///means that the enumerator does not have to return all results. Items can be reported through change
    ///notifications.
    SHCONTF_ENABLE_ASYNC          = 0x00008000,
    ///0x10000. <b>Windows 7 and later</b>. Include hidden system items in the enumeration. This value does not include
    ///hidden non-system items. (To include hidden non-system items, use SHCONTF_INCLUDEHIDDEN.)
    SHCONTF_INCLUDESUPERHIDDEN    = 0x00010000,
}

alias STORAGE_PROVIDER_FILE_FLAGS = int;
enum : int
{
    SPFF_NONE                   = 0x00000000,
    SPFF_DOWNLOAD_BY_DEFAULT    = 0x00000001,
    SPFF_CREATED_ON_THIS_DEVICE = 0x00000002,
}

alias MERGE_UPDATE_STATUS = int;
enum : int
{
    MUS_COMPLETE        = 0x00000000,
    MUS_USERINPUTNEEDED = 0x00000001,
    MUS_FAILED          = 0x00000002,
}

///Used by IObjectWithFolderEnumMode::GetMode and IObjectWithFolderEnumMode::SetMode methods to get and set the display
///modes for the folders.
alias FOLDER_ENUM_MODE = int;
enum : int
{
    ///Display mode to view the contents of a folder.
    FEM_VIEWRESULT = 0x00000000,
    ///Display mode to view the contents of the folders in the navigation pane.
    FEM_NAVIGATION = 0x00000001,
}

///A set of flags that specify folder view options. The flags are independent of each other and can be used in any
///combination.
alias FOLDERFLAGS = int;
enum : int
{
    ///0x00000000. <b>Windows 7 and later</b>. No special view options.
    FWF_NONE                = 0x00000000,
    ///0x00000001. Automatically arrange the elements in the view. This implies LVS_AUTOARRANGE if the list-view control
    ///is used to implement the view.
    FWF_AUTOARRANGE         = 0x00000001,
    ///0x00000002. Not supported.
    FWF_ABBREVIATEDNAMES    = 0x00000002,
    ///0x00000004. Not supported.
    FWF_SNAPTOGRID          = 0x00000004,
    ///0x00000008. Not supported.
    FWF_OWNERDATA           = 0x00000008,
    ///0x00000010. Not supported.
    FWF_BESTFITWINDOW       = 0x00000010,
    ///0x00000020. Make the folder behave like the desktop. This value applies only to the desktop and is not used for
    ///typical Shell folders. This flag implies <b>FWF_NOCLIENTEDGE</b> and <b>FWF_NOSCROLL</b>.
    FWF_DESKTOP             = 0x00000020,
    ///0x00000040. Do not allow more than a single item to be selected. This is used in the common dialog boxes.
    FWF_SINGLESEL           = 0x00000040,
    ///0x00000080. Do not show subfolders.
    FWF_NOSUBFOLDERS        = 0x00000080,
    ///0x00000100. Draw transparently. This is used only for the desktop.
    FWF_TRANSPARENT         = 0x00000100,
    ///0x00000200. Not supported.
    FWF_NOCLIENTEDGE        = 0x00000200,
    ///0x00000400. Do not add scroll bars. This is used only for the desktop.
    FWF_NOSCROLL            = 0x00000400,
    ///0x00000800. The view should be left-aligned. This implies LVS_ALIGNLEFT if the list-view control is used to
    ///implement the view.
    FWF_ALIGNLEFT           = 0x00000800,
    ///0x00001000. The view should not display icons.
    FWF_NOICONS             = 0x00001000,
    ///0x00002000. This flag is deprecated as of Windows XP and has no effect. Always show the selection.
    FWF_SHOWSELALWAYS       = 0x00002000,
    ///0x00004000. Not supported.
    FWF_NOVISIBLE           = 0x00004000,
    ///0x00008000. Not supported.
    FWF_SINGLECLICKACTIVATE = 0x00008000,
    ///0x00010000. The view should not be shown as a web view.
    FWF_NOWEBVIEW           = 0x00010000,
    ///0x00020000. The view should not display file names.
    FWF_HIDEFILENAMES       = 0x00020000,
    ///0x00040000. Turns on the check mode for the view.
    FWF_CHECKSELECT         = 0x00040000,
    ///0x00080000. <b>Windows Vista and later</b>. Do not re-enumerate the view (or drop the current contents of the
    ///view) when the view is refreshed.
    FWF_NOENUMREFRESH       = 0x00080000,
    ///0x00100000. <b>Windows Vista and later</b>. Do not allow grouping in the view
    FWF_NOGROUPING          = 0x00100000,
    ///0x00200000. <b>Windows Vista and later</b>. When an item is selected, the item and all its sub-items are
    ///highlighted.
    FWF_FULLROWSELECT       = 0x00200000,
    ///0x00400000. <b>Windows Vista and later</b>. Do not display filters in the view.
    FWF_NOFILTERS           = 0x00400000,
    ///0x00800000. <b>Windows Vista and later</b>. Do not display a column header in the view in any view mode.
    FWF_NOCOLUMNHEADER      = 0x00800000,
    ///0x01000000. <b>Windows Vista and later</b>. Only show the column header in details view mode.
    FWF_NOHEADERINALLVIEWS  = 0x01000000,
    ///0x02000000. <b>Windows Vista and later</b>. When the view is in "tile view mode" the layout of a single item
    ///should be extended to the width of the view.
    FWF_EXTENDEDTILES       = 0x02000000,
    ///0x04000000. <b>Windows Vista and later</b>. Not supported.
    FWF_TRICHECKSELECT      = 0x04000000,
    ///0x08000000. <b>Windows Vista and later</b>. Items can be selected using checkboxes.
    FWF_AUTOCHECKSELECT     = 0x08000000,
    ///0x10000000. <b>Windows Vista and later</b>. The view should not save view state in the browser.
    FWF_NOBROWSERVIEWSTATE  = 0x10000000,
    ///0x20000000. <b>Windows Vista and later</b>. The view should list the number of items displayed in each group. To
    ///be used with IFolderView2::SetGroupSubsetCount.
    FWF_SUBSETGROUPS        = 0x20000000,
    ///0x40000000. <b>Windows Vista and later</b>. Use the search folder for stacking and searching.
    FWF_USESEARCHFOLDER     = 0x40000000,
    FWF_ALLOWRTLREADING     = 0x80000000,
}

///Specifies the folder view type.
alias FOLDERVIEWMODE = int;
enum : int
{
    ///The view should determine the best option.
    FVM_AUTO       = 0xffffffff,
    ///The minimum constant value in FOLDERVIEWMODE, for validation purposes.
    FVM_FIRST      = 0x00000001,
    ///The view should display medium-size icons.
    FVM_ICON       = 0x00000001,
    ///The view should display small icons.
    FVM_SMALLICON  = 0x00000002,
    ///Object names are displayed in a list view.
    FVM_LIST       = 0x00000003,
    ///Object names and other selected information, such as the size or date last updated, are shown.
    FVM_DETAILS    = 0x00000004,
    ///The view should display thumbnail icons.
    FVM_THUMBNAIL  = 0x00000005,
    ///The view should display large icons.
    FVM_TILE       = 0x00000006,
    ///The view should display icons in a filmstrip format.
    FVM_THUMBSTRIP = 0x00000007,
    ///<b>Windows 7 and later</b>. The view should display content mode.
    FVM_CONTENT    = 0x00000008,
    FVM_LAST       = 0x00000008,
}

///Used by IFolderViewSettings::GetViewMode and ISearchFolderItemFactory::SetFolderLogicalViewMode to describe the view
///mode.
alias FOLDERLOGICALVIEWMODE = int;
enum : int
{
    ///The view is not specified.
    FLVM_UNSPECIFIED = 0xffffffff,
    ///The minimum valid enumeration value. Used for validation purposes only.
    FLVM_FIRST       = 0x00000001,
    ///Details view.
    FLVM_DETAILS     = 0x00000001,
    ///Tiles view.
    FLVM_TILES       = 0x00000002,
    ///Icons view.
    FLVM_ICONS       = 0x00000003,
    ///<b>Windows 7 and later</b>. List view.
    FLVM_LIST        = 0x00000004,
    ///<b>Windows 7 and later</b>. Content view.
    FLVM_CONTENT     = 0x00000005,
    FLVM_LAST        = 0x00000005,
}

///Indicates flags used by IFolderView, IFolderView2, IShellView and IShellView2 to specify a type of selection to
///apply.
alias _SVSIF = int;
enum : int
{
    ///0x00000000. Deselect the item.
    SVSI_DESELECT       = 0x00000000,
    ///0x00000001. Select the item.
    SVSI_SELECT         = 0x00000001,
    ///0x00000003. Put the name of the item into rename mode. This value includes SVSI_SELECT.
    SVSI_EDIT           = 0x00000003,
    ///0x00000004. Deselect all but the selected item. If the item parameter is <b>NULL</b>, deselect all items.
    SVSI_DESELECTOTHERS = 0x00000004,
    ///0x00000008. In the case of a folder that cannot display all of its contents on one screen, display the portion
    ///that contains the selected item.
    SVSI_ENSUREVISIBLE  = 0x00000008,
    ///0x00000010. Give the selected item the focus when multiple items are selected, placing the item first in any list
    ///of the collection returned by a method.
    SVSI_FOCUSED        = 0x00000010,
    ///0x00000020. Convert the input point from screen coordinates to the list-view client coordinates.
    SVSI_TRANSLATEPT    = 0x00000020,
    ///0x00000040. Mark the item so that it can be queried using IFolderView::GetSelectionMarkedItem.
    SVSI_SELECTIONMARK  = 0x00000040,
    ///0x00000080. Allows the window's default view to position the item. In most cases, this will place the item in the
    ///first available position. However, if the call comes during the processing of a mouse-positioned context menu,
    ///the position of the context menu is used to position the item.
    SVSI_POSITIONITEM   = 0x00000080,
    ///0x00000100. The item should be checked. This flag is used with items in views where the checked mode is
    ///supported.
    SVSI_CHECK          = 0x00000100,
    ///0x00000200. The second check state when the view is in tri-check mode, in which there are three values for the
    ///checked state. You can indicate tri-check mode by specifying FWF_TRICHECKSELECT in
    ///IFolderView2::SetCurrentFolderFlags. The 3 states for FWF_TRICHECKSELECT are unchecked, SVSI_CHECK and
    ///SVSI_CHECK2.
    SVSI_CHECK2         = 0x00000200,
    ///0x00000401. Selects the item and marks it as selected by the keyboard. This value includes SVSI_SELECT.
    SVSI_KEYBOARDSELECT = 0x00000401,
    ///0x40000000. An operation to select or focus an item should not also set focus on the view itself.
    SVSI_NOTAKEFOCUS    = 0x40000000,
}

///Used with the IFolderView::Items, IFolderView::ItemCount, and IShellView::GetItemObject methods to restrict or
///control the items in their collections.
alias _SVGIO = int;
enum : int
{
    ///0x00000000. Refers to the background of the view. It is used with IID_IContextMenu to get a shortcut menu for the
    ///view background and with IID_IDispatch to get a dispatch interface that represents the ShellFolderView object for
    ///the view.
    SVGIO_BACKGROUND     = 0x00000000,
    ///0x00000001. Refers to the currently selected items. Used with IID_IDataObject to retrieve a data object that
    ///represents the selected items.
    SVGIO_SELECTION      = 0x00000001,
    ///0x00000002. Used in the same way as SVGIO_SELECTION but refers to all items in the view.
    SVGIO_ALLVIEW        = 0x00000002,
    ///0x00000003. Used in the same way as SVGIO_SELECTION but refers to checked items in views where checked mode is
    ///supported. For more details on checked mode, see FOLDERFLAGS.
    SVGIO_CHECKED        = 0x00000003,
    ///0x0000000F. Masks all bits but those corresponding to the _SVGIO flags.
    SVGIO_TYPE_MASK      = 0x0000000f,
    ///0x80000000. Returns the items in the order they appear in the view. If this flag is not set, the selected item
    ///will be listed first.
    SVGIO_FLAG_VIEWORDER = 0x80000000,
}

///Used with the IBrowserService2::_UIActivateView method to set the state of a browser view.
alias SVUIA_STATUS = int;
enum : int
{
    ///The browser view has been deactivated.
    SVUIA_DEACTIVATE       = 0x00000000,
    ///The browser view is activated and does not have focus.
    SVUIA_ACTIVATE_NOFOCUS = 0x00000001,
    ///The browser view is activated and has focus.
    SVUIA_ACTIVATE_FOCUS   = 0x00000002,
    SVUIA_INPLACEACTIVATE  = 0x00000003,
}

alias tagSORTDIRECTION = int;
enum : int
{
    SORT_DESCENDING = 0xffffffff,
    SORT_ASCENDING  = 0x00000001,
}

alias FVTEXTTYPE = int;
enum : int
{
    FVST_EMPTYTEXT = 0x00000000,
}

///Indicates which values in the CM_COLUMNINFO structure should be set during calls to IColumnManager::SetColumnInfo.
alias CM_MASK = int;
enum : int
{
    ///The <b>uWidth</b> member is specified.
    CM_MASK_WIDTH        = 0x00000001,
    ///The <b>uDefaultWidth</b> member is specified.
    CM_MASK_DEFAULTWIDTH = 0x00000002,
    ///The <b>uIdealWidth</b> member is specified.
    CM_MASK_IDEALWIDTH   = 0x00000004,
    ///The <b>wszName</b> member is specified.
    CM_MASK_NAME         = 0x00000008,
    CM_MASK_STATE        = 0x00000010,
}

///Specifies column state values. Used by members of the IColumnManager interface through the CM_COLUMNINFO structure.
alias CM_STATE = int;
enum : int
{
    ///The column is not currently displayed.
    CM_STATE_NONE               = 0x00000000,
    ///The column is currently displayed.
    CM_STATE_VISIBLE            = 0x00000001,
    ///The column cannot be resized.
    CM_STATE_FIXEDWIDTH         = 0x00000002,
    ///Do not sort folders separately.
    CM_STATE_NOSORTBYFOLDERNESS = 0x00000004,
    CM_STATE_ALWAYSVISIBLE      = 0x00000008,
}

///Used by members of the IColumnManager interface to specify which set of columns are being requested, either all or
///only those currently visible.
alias CM_ENUM_FLAGS = int;
enum : int
{
    ///Enumerate all.
    CM_ENUM_ALL     = 0x00000001,
    CM_ENUM_VISIBLE = 0x00000002,
}

///Specifies width values in pixels and includes special support for default and autosize. Used by members of the
///IColumnManager interface through the CM_COLUMNINFO structure.
alias CM_SET_WIDTH_VALUE = int;
enum : int
{
    ///Use the default width.
    CM_WIDTH_USEDEFAULT = 0xffffffff,
    CM_WIDTH_AUTOSIZE   = 0xfffffffe,
}

///Requests the form of an item's display name to retrieve through IShellItem::GetDisplayName and SHGetNameFromIDList.
alias SIGDN = int;
enum : int
{
    ///0x00000000. Returns the display name relative to the parent folder. In UI this name is generally ideal for
    ///display to the user.
    SIGDN_NORMALDISPLAY               = 0x00000000,
    ///(int)0x80018001. Returns the parsing name relative to the parent folder. This name is not suitable for use in UI.
    SIGDN_PARENTRELATIVEPARSING       = 0x80018001,
    ///(int)0x80028000. Returns the parsing name relative to the desktop. This name is not suitable for use in UI.
    SIGDN_DESKTOPABSOLUTEPARSING      = 0x80028000,
    ///(int)0x80031001. Returns the editing name relative to the parent folder. In UI this name is suitable for display
    ///to the user.
    SIGDN_PARENTRELATIVEEDITING       = 0x80031001,
    ///(int)0x8004c000. Returns the editing name relative to the desktop. In UI this name is suitable for display to the
    ///user.
    SIGDN_DESKTOPABSOLUTEEDITING      = 0x8004c000,
    ///(int)0x80058000. Returns the item's file system path, if it has one. Only items that report SFGAO_FILESYSTEM have
    ///a file system path. When an item does not have a file system path, a call to IShellItem::GetDisplayName on that
    ///item will fail. In UI this name is suitable for display to the user in some cases, but note that it might not be
    ///specified for all items.
    SIGDN_FILESYSPATH                 = 0x80058000,
    ///(int)0x80068000. Returns the item's URL, if it has one. Some items do not have a URL, and in those cases a call
    ///to IShellItem::GetDisplayName will fail. This name is suitable for display to the user in some cases, but note
    ///that it might not be specified for all items.
    SIGDN_URL                         = 0x80068000,
    ///(int)0x8007c001. Returns the path relative to the parent folder in a friendly format as displayed in an address
    ///bar. This name is suitable for display to the user.
    SIGDN_PARENTRELATIVEFORADDRESSBAR = 0x8007c001,
    ///(int)0x80080001. Returns the path relative to the parent folder.
    SIGDN_PARENTRELATIVE              = 0x80080001,
    ///(int)0x80094001. <b>Introduced in Windows 8</b>.
    SIGDN_PARENTRELATIVEFORUI         = 0x80094001,
}

///Used to determine how to compare two Shell items. IShellItem::Compare uses this enumerated type.
alias _SICHINTF = int;
enum : int
{
    ///0x00000000. This relates to the <i>iOrder</i> parameter of the IShellItem::Compare interface and indicates that
    ///the comparison is based on the display in a folder view.
    SICHINT_DISPLAY                       = 0x00000000,
    ///(int)0x80000000. Exact comparison of two instances of a Shell item.
    SICHINT_ALLFIELDS                     = 0x80000000,
    ///0x10000000. This relates to the <i>iOrder</i> parameter of the IShellItem::Compare interface and indicates that
    ///the comparison is based on a canonical name.
    SICHINT_CANONICAL                     = 0x10000000,
    SICHINT_TEST_FILESYSPATH_IF_NOT_EQUAL = 0x20000000,
}

///Values used by the SHGetItemFromDataObject function to specify options concerning the processing of the source
///object.
alias DATAOBJ_GET_ITEM_FLAGS = int;
enum : int
{
    ///0x0000. No special options.
    DOGIF_DEFAULT       = 0x00000000,
    ///0x0001. If the source object is a link, base the IShellItem on the link's target rather than the link file
    ///itself.
    DOGIF_TRAVERSE_LINK = 0x00000001,
    ///0x0002. If the source data object does not contain data in the CFSTR_SHELLIDLIST format, which identifies the
    ///object through an IDList, do not revert to the CF_HDROP format, which uses a file path, as an alternative in the
    ///transfer.
    DOGIF_NO_HDROP      = 0x00000002,
    ///0x0004. If the source data object does not contain data in the CFSTR_SHELLIDLIST format, which identifies the
    ///object through an IDList, do not revert to the CFSTR_INETURL clipboard format, which uses a URL, as an
    ///alternative in the transfer.
    DOGIF_NO_URL        = 0x00000004,
    DOGIF_ONLY_IF_ONE   = 0x00000008,
}

alias _SIIGBF = int;
enum : int
{
    SIIGBF_RESIZETOFIT    = 0x00000000,
    SIIGBF_BIGGERSIZEOK   = 0x00000001,
    SIIGBF_MEMORYONLY     = 0x00000002,
    SIIGBF_ICONONLY       = 0x00000004,
    SIIGBF_THUMBNAILONLY  = 0x00000008,
    SIIGBF_INCACHEONLY    = 0x00000010,
    SIIGBF_CROPTOSQUARE   = 0x00000020,
    SIIGBF_WIDETHUMBNAILS = 0x00000040,
    SIIGBF_ICONBACKGROUND = 0x00000080,
    SIIGBF_SCALEUP        = 0x00000100,
}

alias STGOP = int;
enum : int
{
    STGOP_MOVE            = 0x00000001,
    STGOP_COPY            = 0x00000002,
    STGOP_SYNC            = 0x00000003,
    STGOP_REMOVE          = 0x00000005,
    STGOP_RENAME          = 0x00000006,
    STGOP_APPLYPROPERTIES = 0x00000008,
    STGOP_NEW             = 0x0000000a,
}

///Used by methods of the ITransferSource and ITransferDestination interfaces to control their file operations.
alias _TRANSFER_SOURCE_FLAGS = int;
enum : int
{
    ///Fail if the destination already exists, unless TSF_OVERWRITE_EXIST is specified. This is a default behavior.
    TSF_NORMAL                     = 0x00000000,
    ///Fail if the destination already exists, unless TSF_OVERWRITE_EXIST is specified. This is a default behavior.
    TSF_FAIL_EXIST                 = 0x00000000,
    ///Rename with auto-name generation if the destination already exists.
    TSF_RENAME_EXIST               = 0x00000001,
    ///Overwrite or merge with the destination.
    TSF_OVERWRITE_EXIST            = 0x00000002,
    ///Allow creation of a decrypted destination.
    TSF_ALLOW_DECRYPTION           = 0x00000004,
    ///No discretionary access control list (DACL), system access control list (SACL), or owner.
    TSF_NO_SECURITY                = 0x00000008,
    ///Copy the creation time as part of the copy. This can be useful for a move operation that is being used as a copy
    ///and delete operation (TSF_MOVE_AS_COPY_DELETE).
    TSF_COPY_CREATION_TIME         = 0x00000010,
    ///Copy the last write time as part of the copy.
    TSF_COPY_WRITE_TIME            = 0x00000020,
    ///Assign write, read, and delete permissions as share mode.
    TSF_USE_FULL_ACCESS            = 0x00000040,
    ///Recycle on file delete, if possible.
    TSF_DELETE_RECYCLE_IF_POSSIBLE = 0x00000080,
    ///Hard link to the desired source (not required). This avoids a normal copy operation.
    TSF_COPY_HARD_LINK             = 0x00000100,
    ///Copy the localized name.
    TSF_COPY_LOCALIZED_NAME        = 0x00000200,
    ///Move as a copy and delete operation.
    TSF_MOVE_AS_COPY_DELETE        = 0x00000400,
    ///Suspend Shell events.
    TSF_SUSPEND_SHELLEVENTS        = 0x00000800,
}

alias _TRANSFER_ADVISE_STATE = int;
enum : int
{
    TS_NONE          = 0x00000000,
    TS_PERFORMING    = 0x00000001,
    TS_PREPARING     = 0x00000002,
    TS_INDETERMINATE = 0x00000004,
}

alias SIATTRIBFLAGS = int;
enum : int
{
    SIATTRIBFLAGS_AND       = 0x00000001,
    SIATTRIBFLAGS_OR        = 0x00000002,
    SIATTRIBFLAGS_APPCOMPAT = 0x00000003,
    SIATTRIBFLAGS_MASK      = 0x00000003,
    SIATTRIBFLAGS_ALLITEMS  = 0x00004000,
}

alias _PROPERTYUI_NAME_FLAGS = int;
enum : int
{
    PUIFNF_DEFAULT  = 0x00000000,
    PUIFNF_MNEMONIC = 0x00000001,
}

alias _PROPERTYUI_FORMAT_FLAGS = int;
enum : int
{
    PUIFFDF_DEFAULT      = 0x00000000,
    PUIFFDF_RIGHTTOLEFT  = 0x00000001,
    PUIFFDF_SHORTFORMAT  = 0x00000002,
    PUIFFDF_NOTIME       = 0x00000004,
    PUIFFDF_FRIENDLYDATE = 0x00000008,
}

///Provides a set of flags for use with the CATEGORY_INFO structure.
alias CATEGORYINFO_FLAGS = int;
enum : int
{
    ///0x00000000. Applies default properties for the category.
    CATINFO_NORMAL          = 0x00000000,
    ///0x00000001. The category should appear as collapsed
    CATINFO_COLLAPSED       = 0x00000001,
    ///0x00000002. The category should appear as hidden.
    CATINFO_HIDDEN          = 0x00000002,
    ///0x00000004. The category should appear as expanded.
    CATINFO_EXPANDED        = 0x00000004,
    ///0x00000008. The category has no header.
    CATINFO_NOHEADER        = 0x00000008,
    ///0x00000010. The category cannot be collapsed.
    CATINFO_NOTCOLLAPSIBLE  = 0x00000010,
    ///0x00000020. The count of items in the category should not be displayed in the header.
    CATINFO_NOHEADERCOUNT   = 0x00000020,
    ///0x00000040. <b>Windows 7 and later</b>. The category should appear subsetted.
    CATINFO_SUBSETTED       = 0x00000040,
    CATINFO_SEPARATE_IMAGES = 0x00000080,
    CATINFO_SHOWEMPTY       = 0x00000100,
}

///Specifies methods for sorting category data.
alias CATSORT_FLAGS = int;
enum : int
{
    ///Use the default sort order.
    CATSORT_DEFAULT = 0x00000000,
    CATSORT_NAME    = 0x00000001,
}

alias SLR_FLAGS = int;
enum : int
{
    SLR_NONE                      = 0x00000000,
    SLR_NO_UI                     = 0x00000001,
    SLR_ANY_MATCH                 = 0x00000002,
    SLR_UPDATE                    = 0x00000004,
    SLR_NOUPDATE                  = 0x00000008,
    SLR_NOSEARCH                  = 0x00000010,
    SLR_NOTRACK                   = 0x00000020,
    SLR_NOLINKINFO                = 0x00000040,
    SLR_INVOKE_MSI                = 0x00000080,
    SLR_NO_UI_WITH_MSG_PUMP       = 0x00000101,
    SLR_OFFER_DELETE_WITHOUT_FILE = 0x00000200,
    SLR_KNOWNFOLDER               = 0x00000400,
    SLR_MACHINE_IN_LOCAL_TARGET   = 0x00000800,
    SLR_UPDATE_MACHINE_AND_SID    = 0x00001000,
    SLR_NO_OBJECT_ID              = 0x00002000,
}

alias SLGP_FLAGS = int;
enum : int
{
    SLGP_SHORTPATH        = 0x00000001,
    SLGP_UNCPRIORITY      = 0x00000002,
    SLGP_RAWPATH          = 0x00000004,
    SLGP_RELATIVEPRIORITY = 0x00000008,
}

alias _SPINITF = int;
enum : int
{
    SPINITF_NORMAL     = 0x00000000,
    SPINITF_MODAL      = 0x00000001,
    SPINITF_NOMINIMIZE = 0x00000008,
}

///Used by IActionProgress::Begin, these constants specify certain UI operations that are to be enabled or disabled.
alias _SPBEGINF = int;
enum : int
{
    ///Indicates default progress behavior.
    SPBEGINF_NORMAL          = 0x00000000,
    ///Indicates that the progress UI should automatically update a text field with the amount of time remaining until
    ///the action completes.
    SPBEGINF_AUTOTIME        = 0x00000002,
    ///Indicates that the UI should not display a progress bar.
    SPBEGINF_NOPROGRESSBAR   = 0x00000010,
    ///Indicates that the UI should use a marquee-style progress bar.
    SPBEGINF_MARQUEEPROGRESS = 0x00000020,
    ///Indicates that the UI should not include a <b>Cancel</b> button.
    SPBEGINF_NOCANCELBUTTON  = 0x00000040,
}

///Describes an action being performed that requires progress to be shown to the user using an IActionProgress
///interface.
alias SPACTION = int;
enum : int
{
    ///No action is being performed.
    SPACTION_NONE               = 0x00000000,
    ///Files are being moved.
    SPACTION_MOVING             = 0x00000001,
    ///Files are being copied.
    SPACTION_COPYING            = 0x00000002,
    ///Files are being deleted.
    SPACTION_RECYCLING          = 0x00000003,
    ///A set of attributes are being applied to files.
    SPACTION_APPLYINGATTRIBS    = 0x00000004,
    ///A file is being downloaded from a remote source.
    SPACTION_DOWNLOADING        = 0x00000005,
    ///An Internet search is being performed.
    SPACTION_SEARCHING_INTERNET = 0x00000006,
    ///A calculation is being performed.
    SPACTION_CALCULATING        = 0x00000007,
    ///A file is being uploaded to a remote source.
    SPACTION_UPLOADING          = 0x00000008,
    ///A local search is being performed.
    SPACTION_SEARCHING_FILES    = 0x00000009,
    ///<b>Windows Vista and later</b>. A deletion is being performed.
    SPACTION_DELETING           = 0x0000000a,
    ///<b>Windows Vista and later</b>. A renaming action is being performed.
    SPACTION_RENAMING           = 0x0000000b,
    ///<b>Windows Vista and later</b>. A formatting action is being performed.
    SPACTION_FORMATTING         = 0x0000000c,
    ///<b>Windows 7 and later</b>. A copy or move action is being performed.
    SPACTION_COPY_MOVING        = 0x0000000d,
}

///Specifies the type of descriptive text being provided to an IActionProgress interface.
alias SPTEXT = int;
enum : int
{
    ///The text is a high level, short description.
    SPTEXT_ACTIONDESCRIPTION = 0x00000001,
    ///The text is a detailed description.
    SPTEXT_ACTIONDETAIL      = 0x00000002,
}

alias _EXPPS = int;
enum : int
{
    EXPPS_FILETYPES = 0x00000001,
}

///These command IDs can be sent to the band object's container with IOleCommandTarget::Exec.
alias tagDESKBANDCID = int;
enum : int
{
    ///Updates all bands or a specific band. <ul> <li><b>To update all bands:</b> Set <i>pvaIn</i> to <b>NULL</b>.</li>
    ///<li><b>To update a specific band:</b> Set <i>pvaIn-&gt;lVal</i> to the ID of the band to be updated, and
    ///<i>pvaIn-&gt;vt</i> to VT_I4.</li> </ul>
    DBID_BANDINFOCHANGED = 0x00000000,
    ///Turns other bands in the container on or off. Set <i>pvaIn-&gt;vt</i> to VT_UNKNOWN, and set
    ///<i>pvaIn-&gt;punkVal</i> to one of the following values. <table class="clsStd"> <tr> <th>Value</th>
    ///<th>Result</th> </tr> <tr> <td>pUnk</td> <td>A pointer to the band object's IUnknown interface. The desk band
    ///pointed to is shown; all other desk bands are hidden.</td> </tr> <tr> <td>0</td> <td>Hides all desk bands.</td>
    ///</tr> <tr> <td>1</td> <td>Shows all desk bands.</td> </tr> </table>
    DBID_SHOWONLY        = 0x00000001,
    ///Maximize the band. Set <i>pvaIn-&gt;ulVal</i> to the ID of the band to be maximized, and set <i>pvaIn-&gt;vt</i>
    ///to VT_UI4.
    DBID_MAXIMIZEBAND    = 0x00000002,
    ///Version 5. Displays a push chevron on a desk band. Set <i>pvaIn-&gt;vt</i> to VT_I4, set <i>pvaIn-&gt;lVal</i> to
    ///the ID of the desk band, and set the IOleCommandTarget::Exec method's <i>nCmdExecOpt</i> parameter to the band
    ///identifier received in the most recent call to IDeskBand::GetBandInfo. The container sends an RB_PUSHCHEVRON
    ///message, and the band object receives an RBN_CHEVRONPUSHED notification that prompts it to display the chevron.
    ///The band ID is passed back to the band object in the lParam parameter of the RBN_CHEVRONPUSHED message.
    DBID_PUSHCHEVRON     = 0x00000003,
    DBID_DELAYINIT       = 0x00000004,
    DBID_FINISHINIT      = 0x00000005,
    DBID_SETWINDOWTHEME  = 0x00000006,
    DBID_PERMITAUTOHIDE  = 0x00000007,
}

///Used by THUMBBUTTON to control specific states and behaviors of the button.
alias THUMBBUTTONFLAGS = int;
enum : int
{
    ///The button is active and available to the user.
    THBF_ENABLED        = 0x00000000,
    ///The button is disabled. It is present, but has a visual state that indicates that it will not respond to user
    ///action.
    THBF_DISABLED       = 0x00000001,
    ///When the button is clicked, the taskbar button's flyout closes immediately.
    THBF_DISMISSONCLICK = 0x00000002,
    ///Do not draw a button border, use only the image.
    THBF_NOBACKGROUND   = 0x00000004,
    ///The button is not shown to the user.
    THBF_HIDDEN         = 0x00000008,
    ///The button is enabled but not interactive; no pressed button state is drawn. This value is intended for instances
    ///where the button is used in a notification.
    THBF_NONINTERACTIVE = 0x00000010,
}

///Used by the THUMBBUTTON structure to specify which members of that structure contain valid data.
alias THUMBBUTTONMASK = int;
enum : int
{
    ///The <b>iBitmap</b> member contains valid information.
    THB_BITMAP  = 0x00000001,
    ///The <b>hIcon</b> member contains valid information.
    THB_ICON    = 0x00000002,
    ///The <b>szTip</b> member contains valid information.
    THB_TOOLTIP = 0x00000004,
    ///The <b>dwFlags</b> member contains valid information.
    THB_FLAGS   = 0x00000008,
}

alias TBPFLAG = int;
enum : int
{
    TBPF_NOPROGRESS    = 0x00000000,
    TBPF_INDETERMINATE = 0x00000001,
    TBPF_NORMAL        = 0x00000002,
    TBPF_ERROR         = 0x00000004,
    TBPF_PAUSED        = 0x00000008,
}

///Used by the ITaskbarList4::SetTabProperties method to specify tab properties.
alias STPFLAG = int;
enum : int
{
    ///No specific property values are specified. The default behavior is used: the tab window provides a thumbnail and
    ///peek image, either live or static as appropriate.
    STPF_NONE                      = 0x00000000,
    ///Always use the thumbnail provided by the main application frame window rather than a thumbnail provided by the
    ///individual tab window. Do not combine this value with STPF_USEAPPTHUMBNAILWHENACTIVE; doing so will result in an
    ///error.
    STPF_USEAPPTHUMBNAILALWAYS     = 0x00000001,
    ///When the application tab is active and a live representation of its window is available, use the main
    ///application's frame window thumbnail. At other times, use the tab window thumbnail. Do not combine this value
    ///with STPF_USEAPPTHUMBNAILALWAYS; doing so will result in an error.
    STPF_USEAPPTHUMBNAILWHENACTIVE = 0x00000002,
    ///Always use the peek image provided by the main application frame window rather than a peek image provided by the
    ///individual tab window. Do not combine this value with STPF_USEAPPPEEKWHENACTIVE; doing so will result in an
    ///error.
    STPF_USEAPPPEEKALWAYS          = 0x00000004,
    STPF_USEAPPPEEKWHENACTIVE      = 0x00000008,
}

///These flags are used with IExplorerBrowser::GetOptions and IExplorerBrowser::SetOptions.
alias EXPLORER_BROWSER_OPTIONS = int;
enum : int
{
    ///No options.
    EBO_NONE               = 0x00000000,
    ///Do not navigate further than the initial navigation.
    EBO_NAVIGATEONCE       = 0x00000001,
    ///Use the following standard panes: Commands Module pane, Navigation pane, Details pane, and Preview pane. An
    ///implementer of IExplorerPaneVisibility can modify the components of the Commands Module that are shown. For more
    ///information see, IExplorerPaneVisibility::GetPaneState. If EBO_SHOWFRAMES is not set, Explorer browser uses a
    ///single view object.
    EBO_SHOWFRAMES         = 0x00000002,
    ///Always navigate, even if you are attempting to navigate to the current folder.
    EBO_ALWAYSNAVIGATE     = 0x00000004,
    ///Do not update the travel log.
    EBO_NOTRAVELLOG        = 0x00000008,
    ///Do not use a wrapper window. This flag is used with legacy clients that need the browser parented directly on
    ///themselves.
    EBO_NOWRAPPERWINDOW    = 0x00000010,
    ///Show WebView for sharepoint sites.
    EBO_HTMLSHAREPOINTVIEW = 0x00000020,
    ///<b>Introduced in Windows Vista</b>. Do not draw a border around the browser window.
    EBO_NOBORDER           = 0x00000040,
    EBO_NOPERSISTVIEWSTATE = 0x00000080,
}

///These flags are used with IExplorerBrowser::FillFromObject.
alias EXPLORER_BROWSER_FILL_FLAGS = int;
enum : int
{
    ///No flags.
    EBF_NONE                 = 0x00000000,
    ///Causes IExplorerBrowser::FillFromObject to first populate the results folder with the contents of the parent
    ///folders of the items in the data object, and then select only the items that are in the data object.
    EBF_SELECTFROMDATAOBJECT = 0x00000100,
    EBF_NODROPTARGET         = 0x00000200,
}

alias _OPPROGDLGF = int;
enum : int
{
    OPPROGDLG_DEFAULT               = 0x00000000,
    OPPROGDLG_ENABLEPAUSE           = 0x00000080,
    OPPROGDLG_ALLOWUNDO             = 0x00000100,
    OPPROGDLG_DONTDISPLAYSOURCEPATH = 0x00000200,
    OPPROGDLG_DONTDISPLAYDESTPATH   = 0x00000400,
    OPPROGDLG_NOMULTIDAYESTIMATES   = 0x00000800,
    OPPROGDLG_DONTDISPLAYLOCATIONS  = 0x00001000,
}

alias _PDMODE = int;
enum : int
{
    PDM_DEFAULT        = 0x00000000,
    PDM_RUN            = 0x00000001,
    PDM_PREFLIGHT      = 0x00000002,
    PDM_UNDOING        = 0x00000004,
    PDM_ERRORSBLOCKING = 0x00000008,
    PDM_INDETERMINATE  = 0x00000010,
}

alias FILE_OPERATION_FLAGS2 = int;
enum : int
{
    FOF2_NONE                    = 0x00000000,
    FOF2_MERGEFOLDERSONCOLLISION = 0x00000001,
}

alias NAMESPACEWALKFLAG = int;
enum : int
{
    NSWF_DEFAULT                        = 0x00000000,
    NSWF_NONE_IMPLIES_ALL               = 0x00000001,
    NSWF_ONE_IMPLIES_ALL                = 0x00000002,
    NSWF_DONT_TRAVERSE_LINKS            = 0x00000004,
    NSWF_DONT_ACCUMULATE_RESULT         = 0x00000008,
    NSWF_TRAVERSE_STREAM_JUNCTIONS      = 0x00000010,
    NSWF_FILESYSTEM_ONLY                = 0x00000020,
    NSWF_SHOW_PROGRESS                  = 0x00000040,
    NSWF_FLAG_VIEWORDER                 = 0x00000080,
    NSWF_IGNORE_AUTOPLAY_HIDA           = 0x00000100,
    NSWF_ASYNC                          = 0x00000200,
    NSWF_DONT_RESOLVE_LINKS             = 0x00000400,
    NSWF_ACCUMULATE_FOLDERS             = 0x00000800,
    NSWF_DONT_SORT                      = 0x00001000,
    NSWF_USE_TRANSFER_MEDIUM            = 0x00002000,
    NSWF_DONT_TRAVERSE_STREAM_JUNCTIONS = 0x00004000,
    NSWF_ANY_IMPLIES_ALL                = 0x00008000,
}

alias tagBANDSITECID = int;
enum : int
{
    BSID_BANDADDED   = 0x00000000,
    BSID_BANDREMOVED = 0x00000001,
}

alias tagMENUBANDHANDLERCID = int;
enum : int
{
    MBHANDCID_PIDLSELECT = 0x00000000,
}

alias tagMENUPOPUPSELECT = int;
enum : int
{
    MPOS_EXECUTE       = 0x00000000,
    MPOS_FULLCANCEL    = 0x00000001,
    MPOS_CANCELLEVEL   = 0x00000002,
    MPOS_SELECTLEFT    = 0x00000003,
    MPOS_SELECTRIGHT   = 0x00000004,
    MPOS_CHILDTRACKING = 0x00000005,
}

alias tagMENUPOPUPPOPUPFLAGS = int;
enum : int
{
    MPPF_SETFOCUS      = 0x00000001,
    MPPF_INITIALSELECT = 0x00000002,
    MPPF_NOANIMATE     = 0x00000004,
    MPPF_KEYBOARD      = 0x00000010,
    MPPF_REPOSITION    = 0x00000020,
    MPPF_FORCEZORDER   = 0x00000040,
    MPPF_FINALSELECT   = 0x00000080,
    MPPF_TOP           = 0x20000000,
    MPPF_LEFT          = 0x40000000,
    MPPF_RIGHT         = 0x60000000,
    MPPF_BOTTOM        = 0x80000000,
    MPPF_POS_MASK      = 0xe0000000,
    MPPF_ALIGN_LEFT    = 0x02000000,
    MPPF_ALIGN_RIGHT   = 0x04000000,
}

///Constants used by IFileIsInUse::GetUsage to indicate how a file in use is being used.
alias FILE_USAGE_TYPE = int;
enum : int
{
    ///The file is being played by the process that has it open.
    FUT_PLAYING = 0x00000000,
    ///The file is being edited by the process that has it open.
    FUT_EDITING = 0x00000001,
    ///The file is open in the process for an unspecified action or an action that does not readily fit into the other
    ///two categories.
    FUT_GENERIC = 0x00000002,
}

///Specifies the values used by the IFileDialogEvents::OnOverwrite method to indicate an application's response to an
///overwrite request during a save operation using the common file dialog.
alias FDE_OVERWRITE_RESPONSE = int;
enum : int
{
    ///The application has not handled the event. The dialog displays a UI asking the user whether the file should be
    ///overwritten and returned from the dialog.
    FDEOR_DEFAULT = 0x00000000,
    ///The application has determined that the file should be returned from the dialog.
    FDEOR_ACCEPT  = 0x00000001,
    FDEOR_REFUSE  = 0x00000002,
}

///Specifies the values used by the IFileDialogEvents::OnShareViolation method to indicate an application's response to
///a sharing violation that occurs when a file is opened or saved.
alias FDE_SHAREVIOLATION_RESPONSE = int;
enum : int
{
    ///The application has not handled the event. The dialog displays a UI that indicates that the file is in use and a
    ///different file must be chosen.
    FDESVR_DEFAULT = 0x00000000,
    ///The application has determined that the file should be returned from the dialog.
    FDESVR_ACCEPT  = 0x00000001,
    FDESVR_REFUSE  = 0x00000002,
}

///Specifies list placement.
alias FDAP = int;
enum : int
{
    ///The place is added to the bottom of the default list.
    FDAP_BOTTOM = 0x00000000,
    FDAP_TOP    = 0x00000001,
}

///Defines the set of options available to an Open or Save dialog.
alias _FILEOPENDIALOGOPTIONS = int;
enum : int
{
    ///When saving a file, prompt before overwriting an existing file of the same name. This is a default value for the
    ///Save dialog.
    FOS_OVERWRITEPROMPT          = 0x00000002,
    ///In the Save dialog, only allow the user to choose a file that has one of the file name extensions specified
    ///through IFileDialog::SetFileTypes.
    FOS_STRICTFILETYPES          = 0x00000004,
    ///Don't change the current working directory.
    FOS_NOCHANGEDIR              = 0x00000008,
    ///Present an Open dialog that offers a choice of folders rather than files.
    FOS_PICKFOLDERS              = 0x00000020,
    ///Ensures that returned items are file system items (SFGAO_FILESYSTEM). Note that this does not apply to items
    ///returned by IFileDialog::GetCurrentSelection.
    FOS_FORCEFILESYSTEM          = 0x00000040,
    ///Enables the user to choose any item in the Shell namespace, not just those with SFGAO_STREAM or SFAGO_FILESYSTEM
    ///attributes. This flag cannot be combined with FOS_FORCEFILESYSTEM.
    FOS_ALLNONSTORAGEITEMS       = 0x00000080,
    ///Do not check for situations that would prevent an application from opening the selected file, such as sharing
    ///violations or access denied errors.
    FOS_NOVALIDATE               = 0x00000100,
    ///Enables the user to select multiple items in the open dialog. Note that when this flag is set, the
    ///IFileOpenDialog interface must be used to retrieve those items.
    FOS_ALLOWMULTISELECT         = 0x00000200,
    ///The item returned must be in an existing folder. This is a default value.
    FOS_PATHMUSTEXIST            = 0x00000800,
    ///The item returned must exist. This is a default value for the Open dialog.
    FOS_FILEMUSTEXIST            = 0x00001000,
    ///Prompt for creation if the item returned in the save dialog does not exist. Note that this does not actually
    ///create the item.
    FOS_CREATEPROMPT             = 0x00002000,
    ///In the case of a sharing violation when an application is opening a file, call the application back through
    ///OnShareViolation for guidance. This flag is overridden by FOS_NOVALIDATE.
    FOS_SHAREAWARE               = 0x00004000,
    ///Do not return read-only items. This is a default value for the Save dialog.
    FOS_NOREADONLYRETURN         = 0x00008000,
    ///Do not test whether creation of the item as specified in the Save dialog will be successful. If this flag is not
    ///set, the calling application must handle errors, such as denial of access, discovered when the item is created.
    FOS_NOTESTFILECREATE         = 0x00010000,
    ///Hide the list of places from which the user has recently opened or saved items. This value is not supported as of
    ///Windows 7.
    FOS_HIDEMRUPLACES            = 0x00020000,
    ///Hide items shown by default in the view's navigation pane. This flag is often used in conjunction with the
    ///IFileDialog::AddPlace method, to hide standard locations and replace them with custom locations. <b>Windows 7 and
    ///later</b>. Hide all of the standard namespace locations (such as Favorites, Libraries, Computer, and Network)
    ///shown in the navigation pane. <b>Windows Vista</b>. Hide the contents of the <b>Favorite Links</b> tree in the
    ///navigation pane. Note that the category itself is still displayed, but shown as empty.
    FOS_HIDEPINNEDPLACES         = 0x00040000,
    ///Shortcuts should not be treated as their target items. This allows an application to open a .lnk file rather than
    ///what that file is a shortcut to.
    FOS_NODEREFERENCELINKS       = 0x00100000,
    FOS_OKBUTTONNEEDSINTERACTION = 0x00200000,
    ///Do not add the item being opened or saved to the recent documents list (SHAddToRecentDocs).
    FOS_DONTADDTORECENT          = 0x02000000,
    ///Include hidden and system items.
    FOS_FORCESHOWHIDDEN          = 0x10000000,
    ///Indicates to the <b>Save As</b> dialog box that it should open in expanded mode. Expanded mode is the mode that
    ///is set and unset by clicking the button in the lower-left corner of the <b>Save As</b> dialog box that switches
    ///between <b>Browse Folders</b> and <b>Hide Folders</b> when clicked. This value is not supported as of Windows 7.
    FOS_DEFAULTNOMINIMODE        = 0x20000000,
    ///Indicates to the <b>Open</b> dialog box that the preview pane should always be displayed.
    FOS_FORCEPREVIEWPANEON       = 0x40000000,
    ///Indicates that the caller is opening a file as a stream (BHID_Stream), so there is no need to download that file.
    FOS_SUPPORTSTREAMABLEITEMS   = 0x80000000,
}

alias CDCONTROLSTATEF = int;
enum : int
{
    CDCS_INACTIVE       = 0x00000000,
    CDCS_ENABLED        = 0x00000001,
    CDCS_VISIBLE        = 0x00000002,
    CDCS_ENABLEDVISIBLE = 0x00000003,
}

///Specifies the source of the default association for a file name extension. Used by methods of the
///IApplicationAssociationRegistration interface.
alias ASSOCIATIONLEVEL = int;
enum : int
{
    ///The machine-level default application association.
    AL_MACHINE   = 0x00000000,
    ///The effective default for the current user. This value should be used by most applications.
    AL_EFFECTIVE = 0x00000001,
    ///The per-user default application association. If this value is used and no per-user default is declared, the
    ///calling method fails with a value of <code>HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION)</code>.
    AL_USER      = 0x00000002,
}

///Specifies the type of association for an application. Used by methods of the IApplicationAssociationRegistration
///interface.
alias ASSOCIATIONTYPE = int;
enum : int
{
    ///Indicates a file name extension, such as <code>.htm</code> or <code>.mp3</code>.
    AT_FILEEXTENSION   = 0x00000000,
    ///Indicates a protocol, such as <code>http</code> or <code>mailto</code>.
    AT_URLPROTOCOL     = 0x00000001,
    ///Indicates the owner of the startmenu client for a mail or Internet hyperlink. As of Windows 7, this value is used
    ///only for the MAPI sendmail client.
    AT_STARTMENUCLIENT = 0x00000002,
    AT_MIMETYPE        = 0x00000003,
}

///Used with method IBrowserFrameOptions::GetFrameOptions.
alias _BROWSERFRAMEOPTIONS = int;
enum : int
{
    ///Do nothing.
    BFO_NONE                             = 0x00000000,
    ///Use the browser stream for this item. (Same window position as IE browser windows.)
    BFO_BROWSER_PERSIST_SETTINGS         = 0x00000001,
    ///Rename <b>Folder Options</b> to <b>Internet Options</b> in the Tools or View menu.
    BFO_RENAME_FOLDER_OPTIONS_TOINTERNET = 0x00000002,
    ///Keep both <b>Folder Options</b> and <b>Internet Options</b> in the Tools or View menu.
    BFO_BOTH_OPTIONS                     = 0x00000004,
    ///This namespace extension prefers a .url shortcut over a .lnk shortcut.
    BIF_PREFER_INTERNET_SHORTCUT         = 0x00000008,
    ///Do not use "Browse in New Process" by invoking a shortcut.
    BFO_BROWSE_NO_IN_NEW_PROCESS         = 0x00000010,
    ///Track display name to determine when hyperlinks should be tagged as previously used.
    BFO_ENABLE_HYPERLINK_TRACKING        = 0x00000020,
    ///Use Internet Explorer's offline support.
    BFO_USE_IE_OFFLINE_SUPPORT           = 0x00000040,
    ///Use Start Page support for this namespace extension.
    BFO_SUBSTITUE_INTERNET_START_PAGE    = 0x00000080,
    ///Use the Brand block in the Toolbar.
    BFO_USE_IE_LOGOBANDING               = 0x00000100,
    ///Append <code>" - Internet Explorer"</code> to display name in the caption bar.
    BFO_ADD_IE_TOCAPTIONBAR              = 0x00000200,
    ///Reference the DialUp reference count while the browser is navigated to this location. This will also enable the
    ///ICW and Software update.
    BFO_USE_DIALUP_REF                   = 0x00000400,
    ///Use the Internet Explorer toolbar.
    BFO_USE_IE_TOOLBAR                   = 0x00000800,
    ///Disable navigation to parent folders. Used for the button that navigates to parent folder or the
    ///View.GoTo.ParentFolder feature.
    BFO_NO_PARENT_FOLDER_SUPPORT         = 0x00001000,
    ///Browser windows are not reopened after a reboot of the system, regardless of whether they were open before the
    ///reboot. Use the same behavior for the namespace extension.
    BFO_NO_REOPEN_NEXT_RESTART           = 0x00002000,
    ///Add <b>Home Page</b> to menu (Go).
    BFO_GO_HOME_PAGE                     = 0x00004000,
    ///Prefer use of Iexplore.exe over Explorer.exe.
    BFO_PREFER_IEPROCESS                 = 0x00008000,
    ///If navigation is terminated, show the <b>Action Canceled</b> HTML page.
    BFO_SHOW_NAVIGATION_CANCELLED        = 0x00010000,
    ///Use the persisted Internet Explorer status bar settings.
    BFO_USE_IE_STATUSBAR                 = 0x00020000,
    ///Return all values.
    BFO_QUERY_ALL                        = 0xffffffff,
}

///Flags used by INewWindowManager::EvaluateNewWindow. These values are factors in the decision of whether to display a
///pop-up window.
alias NWMF = int;
enum : int
{
    ///The page is unloading. This flag is set in response to the onbeforeunload and onunload events. Some pages load
    ///pop-up windows when you leave them, not when you enter. This flag is used to identify those situations.
    NWMF_UNLOADING       = 0x00000001,
    ///The call to INewWindowManager::EvaluateNewWindow is the result of a user-initiated action (a mouse click or key
    ///press). Use this flag in conjunction with the NWMF_FIRST_USERINITED flag to determine whether the call is a
    ///direct or indirect result of the user-initiated action.
    NWMF_USERINITED      = 0x00000002,
    ///When NWMF_USERINITED is present, this flag indicates that the call to INewWindowManager::EvaluateNewWindow is the
    ///first query that results from this user-initiated action. Always use this flag in conjunction with
    ///NWMF_USERINITED.
    NWMF_FIRST           = 0x00000004,
    ///The override key (ALT) was pressed. The override key is used to bypass the pop-up manager—allowing all pop-up
    ///windows to display—and must be held down at the time that INewWindowManager::EvaluateNewWindow is called. <div
    ///class="alert"><b>Note</b> When INewWindowManager::EvaluateNewWindow is implemented for a WebBrowser control host,
    ///the implementer can choose to ignore the override key.</div> <div> </div>
    NWMF_OVERRIDEKEY     = 0x00000008,
    ///The new window attempting to load is the result of a call to the showHelp method. Help is sometimes displayed in
    ///a separate window, and this flag is valuable in those cases.
    NWMF_SHOWHELP        = 0x00000010,
    ///The new window is a dialog box that displays HTML content.
    NWMF_HTMLDIALOG      = 0x00000020,
    ///The EvaluateNewWindow method is being called from an HTML dialog. The new window should not show the UI in the
    ///parent window.
    NWMF_FROMDIALOGCHILD = 0x00000040,
    ///The new windows was definitely requested by the user, either by selecting Open in New Window from a context menu
    ///or pressing Shift and clicking a link.
    NWMF_USERREQUESTED   = 0x00000080,
    ///The call to the EvaluateNewWindow method is the result of the user requesting a replay that resulted in a
    ///refresh.
    NWMF_USERALLOWED     = 0x00000100,
    ///The new window should be forced to open in a new window rather than a tab.
    NWMF_FORCEWINDOW     = 0x00010000,
    ///The new window should be forced to open in a new tab.
    NWMF_FORCETAB        = 0x00020000,
    ///The new window should open in a new tab unless NWMF_FORCEtab is also present, indicating that user wants the
    ///window to open as a window.
    NWMF_SUGGESTWINDOW   = 0x00040000,
    ///The new window should open in a new tab unless NWMF_FORCEWINDOW is also present, indicating that user wants the
    ///window to open as a window.
    NWMF_SUGGESTTAB      = 0x00080000,
    NWMF_INACTIVETAB     = 0x00100000,
}

///Provides a set of flags to be used with IAttachmentExecute::Prompt to indicate the type of prompt UI to display.
alias ATTACHMENT_PROMPT = int;
enum : int
{
    ///Do not use.
    ATTACHMENT_PROMPT_NONE         = 0x00000000,
    ///Displays a prompt asking whether the user would like to save the attachment.
    ATTACHMENT_PROMPT_SAVE         = 0x00000001,
    ///Displays a prompt asking whether the user would like to execute the attachment.
    ATTACHMENT_PROMPT_EXEC         = 0x00000002,
    ATTACHMENT_PROMPT_EXEC_OR_SAVE = 0x00000003,
}

///Provides a set of flags to be used with IAttachmentExecute::Prompt to indicate the action to be performed upon user
///confirmation.
alias ATTACHMENT_ACTION = int;
enum : int
{
    ///Cancel
    ATTACHMENT_ACTION_CANCEL = 0x00000000,
    ///Save
    ATTACHMENT_ACTION_SAVE   = 0x00000001,
    ATTACHMENT_ACTION_EXEC   = 0x00000002,
}

alias tagSMINFOMASK = int;
enum : int
{
    SMIM_TYPE  = 0x00000001,
    SMIM_FLAGS = 0x00000002,
    SMIM_ICON  = 0x00000004,
}

alias tagSMINFOTYPE = int;
enum : int
{
    SMIT_SEPARATOR = 0x00000001,
    SMIT_STRING    = 0x00000002,
}

alias tagSMINFOFLAGS = int;
enum : int
{
    SMIF_ICON        = 0x00000001,
    SMIF_ACCELERATOR = 0x00000002,
    SMIF_DROPTARGET  = 0x00000004,
    SMIF_SUBMENU     = 0x00000008,
    SMIF_CHECKED     = 0x00000020,
    SMIF_DROPCASCADE = 0x00000040,
    SMIF_HIDDEN      = 0x00000080,
    SMIF_DISABLED    = 0x00000100,
    SMIF_TRACKPOPUP  = 0x00000200,
    SMIF_DEMOTED     = 0x00000400,
    SMIF_ALTSTATE    = 0x00000800,
    SMIF_DRAGNDROP   = 0x00001000,
    SMIF_NEW         = 0x00002000,
}

///Value that represent a category by which a folder registered with the Known Folder system can be classified.
alias KF_CATEGORY = int;
enum : int
{
    ///Virtual folders are not part of the file system, which is to say that they have no path. For example, <b>Control
    ///Panel</b> and <b>Printers</b> are virtual folders. A number of features such as folder path and redirection do
    ///not apply to this category.
    KF_CATEGORY_VIRTUAL = 0x00000001,
    ///Fixed file system folders are not managed by the Shell and are usually given a permanent path when the system is
    ///installed. For example, the <b>Windows</b> and <b>Program Files</b> folders are fixed folders. A number of
    ///features such as redirection do not apply to this category.
    KF_CATEGORY_FIXED   = 0x00000002,
    ///Common folders are those file system folders used for sharing data and settings, accessible by all users of a
    ///system. For example, all users share a common <b>Documents</b> folder as well as their per-user <b>Documents</b>
    ///folder.
    KF_CATEGORY_COMMON  = 0x00000003,
    ///Per-user folders are those stored under each user's profile and accessible only by that user. For example,
    ///<code>%USERPROFILE%\Pictures</code>. This category of folder usually supports many features including aliasing,
    ///redirection and customization. <div class="alert"><b>Note</b> The user profile root folder (FOLDERID_Profile)
    ///does not support redirection.</div> <div> </div>
    KF_CATEGORY_PERUSER = 0x00000004,
}

///Flags that specify certain known folder behaviors. Used with the KNOWNFOLDER_DEFINITION structure.
alias _KF_DEFINITION_FLAGS = int;
enum : int
{
    ///Prevent a per-user known folder from being redirected to a network location. Note that if the known folder has
    ///been flagged with KFDF_LOCAL_REDIRECT_ONLY but it is a subfolder of a known folder that is redirected to a
    ///network location, this subfolder is redirected also.
    KFDF_LOCAL_REDIRECT_ONLY = 0x00000002,
    ///Can be roamed through a PC-to-PC synchronization.
    KFDF_ROAMABLE            = 0x00000004,
    ///Create the folder when the user first logs on. Normally a known folder is not created until it is first called.
    ///At that time, an API such as SHCreateItemInKnownFolder or IKnownFolder::GetShellItem is called with the
    ///KF_FLAG_CREATE flag. However, some known folders need to exist immediately. An example is those known folders
    ///under %USERPROFILE%, which must exist to provide a proper view. In those cases, KFDF_PRECREATE is set and Windows
    ///Explorer calls the creation API during its user initialization.
    KFDF_PRECREATE           = 0x00000008,
    ///<b>Introduced in Windows 7</b>. The known folder is a file rather than a folder.
    KFDF_STREAM              = 0x00000010,
    ///<b>Introduced in Windows 7</b>. The full path of the known folder, with any environment variables fully expanded,
    ///is stored in the registry under HKEY_CURRENT_USER.
    KFDF_PUBLISHEXPANDEDPATH = 0x00000020,
    ///<b>Introduced in Windows 8.1</b>. Prevent showing the <b>Locations</b> tab in the property dialog of the known
    ///folder. <b>Introduced in Windows 8.1</b>. Prevent showing the <b>Locations</b> tab in the property dialog of the
    ///known folder.
    KFDF_NO_REDIRECT_UI      = 0x00000040,
}

///Flags used by IKnownFolderManager::Redirect to specify details of a known folder redirection such as permissions and
///ownership for the redirected folder.
alias _KF_REDIRECT_FLAGS = int;
enum : int
{
    ///Ensure that only the user has permission to access the redirected folder.
    KF_REDIRECT_USER_EXCLUSIVE               = 0x00000001,
    ///Copy the DACL of the source folder to the target to maintain current access permissions.
    KF_REDIRECT_COPY_SOURCE_DACL             = 0x00000002,
    ///Sets the user as the owner of a newly created target folder unless the user is a member of the Administrator
    ///group, in which case Administrator is set as the owner. Must be called with KF_REDIRECT_SET_OWNER_EXPLICIT.
    KF_REDIRECT_OWNER_USER                   = 0x00000004,
    ///Set the owner of a newly created target folder. If the user belongs to the Administrators group, Administrators
    ///is assigned as the owner. Must be called with KF_REDIRECT_OWNER_USER.
    KF_REDIRECT_SET_OWNER_EXPLICIT           = 0x00000008,
    ///Do not perform a redirection, simply check whether redirection has occurred. If so, IKnownFolderManager::Redirect
    ///returns S_OK; if not, or if some actions remain to be completed, it returns S_FALSE.
    KF_REDIRECT_CHECK_ONLY                   = 0x00000010,
    ///Display UI during the redirection.
    KF_REDIRECT_WITH_UI                      = 0x00000020,
    ///Unpin the source folder.
    KF_REDIRECT_UNPIN                        = 0x00000040,
    ///Pin the target folder.
    KF_REDIRECT_PIN                          = 0x00000080,
    ///Copy the existing contents—both files and subfolders—of the known folder to the redirected folder.
    KF_REDIRECT_COPY_CONTENTS                = 0x00000200,
    ///Delete the contents of the source folder after they have been copied to the redirected folder. This flag is valid
    ///only if KF_REDIRECT_COPY_CONTENTS is set.
    KF_REDIRECT_DEL_SOURCE_CONTENTS          = 0x00000400,
    ///Reserved. Do not use.
    KF_REDIRECT_EXCLUDE_ALL_KNOWN_SUBFOLDERS = 0x00000800,
}

///Flags that specify the current redirection capabilities of a known folder. Used by
///IKnownFolder::GetRedirectionCapabilities.
alias _KF_REDIRECTION_CAPABILITIES = int;
enum : int
{
    ///The folder can be redirected if any of the bits in the lower byte of the value are set but no DENY flag is set.
    ///DENY flags are found in the upper byte of the value.
    KF_REDIRECTION_CAPABILITIES_ALLOW_ALL              = 0x000000ff,
    ///The folder can be redirected. Currently, redirection exists for only common and user folders; fixed and virtual
    ///folders cannot be redirected.
    KF_REDIRECTION_CAPABILITIES_REDIRECTABLE           = 0x00000001,
    ///Redirection is not allowed.
    KF_REDIRECTION_CAPABILITIES_DENY_ALL               = 0x000fff00,
    ///The folder cannot be redirected because it is already redirected by group policy.
    KF_REDIRECTION_CAPABILITIES_DENY_POLICY_REDIRECTED = 0x00000100,
    ///The folder cannot be redirected because the policy prohibits redirecting this folder.
    KF_REDIRECTION_CAPABILITIES_DENY_POLICY            = 0x00000200,
    ///The folder cannot be redirected because the calling application does not have sufficient permissions.
    KF_REDIRECTION_CAPABILITIES_DENY_PERMISSIONS       = 0x00000400,
}

///Describes match criteria. Used by methods of the IKnownFolderManager interface.
alias FFFP_MODE = int;
enum : int
{
    ///Exact match.
    FFFP_EXACTMATCH         = 0x00000000,
    FFFP_NEARESTPARENTMATCH = 0x00000001,
}

///Specifies the access permissions assigned to the <b>Users</b> or <b>Public</b> folder. Used in CreateShare and
///GetSharePermissions.
alias SHARE_ROLE = int;
enum : int
{
    ///The folder is not shared.
    SHARE_ROLE_INVALID     = 0xffffffff,
    ///The contents of the folder can be read, but not altered or added to.
    SHARE_ROLE_READER      = 0x00000000,
    ///The contents of the folder can be read and altered. New items can be added, however items can be deleted only by
    ///the user that contributed them.
    SHARE_ROLE_CONTRIBUTOR = 0x00000001,
    ///The contents of the folder can be read, changed, or added to.
    SHARE_ROLE_CO_OWNER    = 0x00000002,
    ///Not normally used in the context of this interface.
    SHARE_ROLE_OWNER       = 0x00000003,
    ///The folder is shared, but the share role is neither SHARE_ROLE_READER, SHARE_ROLE_CONTRIBUTOR, or
    ///SHARE_ROLE_CO_OWNER.
    SHARE_ROLE_CUSTOM      = 0x00000004,
    ///Not used in the context of this interface.
    SHARE_ROLE_MIXED       = 0x00000005,
}

///Values that specify the folder being acted on by methods of the ISharingConfigurationManager interface.
alias DEF_SHARE_ID = int;
enum : int
{
    ///The <b>Users</b> folder (FOLDERID_UserProfiles). This folder is usually found at C:\Users.
    DEFSHAREID_USERS  = 0x00000001,
    ///The <b>Public</b> folder (FOLDERID_Public). This folder is usually found at C:\Users\Public.
    DEFSHAREID_PUBLIC = 0x00000002,
}

alias _NMCII_FLAGS = int;
enum : int
{
    NMCII_NONE    = 0x00000000,
    NMCII_ITEMS   = 0x00000001,
    NMCII_FOLDERS = 0x00000002,
}

alias _NMCSAEI_FLAGS = int;
enum : int
{
    NMCSAEI_SELECT = 0x00000000,
    NMCSAEI_EDIT   = 0x00000001,
}

///Describes the characteristics of a given namespace tree control.
alias _NSTCSTYLE = int;
enum : int
{
    ///The control displays a triangle—known as an expando—on the leftmost edge of those items that have child
    ///items. Clicking on the expando expands the item to reveal the children of the item. Has no effect when combined
    ///with NSTCS_SHOWTABSBUTTON, NSTCS_SHOWDELETEBUTTON, or NSTCS_SHOWREFRESHBUTTON. Maps to the TVS_HASBUTTONS tree
    ///view control style.
    NSTCS_HASEXPANDOS         = 0x00000001,
    ///The control draws lines to the left of the tree items that lead to their individual parent items. Has no effect
    ///when combined with NSTCS_SHOWTABSBUTTON, NSTCS_SHOWDELETEBUTTON, or NSTCS_SHOWREFRESHBUTTON. Maps to the
    ///TVS_HASLINES tree view control style.
    NSTCS_HASLINES            = 0x00000002,
    ///An item expands to show its child items in response to a single mouse click. Maps to the TVS_SINGLEEXPAND tree
    ///view control style.
    NSTCS_SINGLECLICKEXPAND   = 0x00000004,
    ///The selection of an item fills the row with inverse text to the end of the window area, regardless of the length
    ///of the text. When this option is not declared, only the area behind text is inverted. This value cannot be
    ///combined with NSTCS_HASLINES. Maps to the TVS_FULLROWSELECT tree view control style.
    NSTCS_FULLROWSELECT       = 0x00000008,
    ///When one item is selected and expanded and you select a second item, the first selection automatically collapses.
    ///This is the opposite of the TVS_EX_NOSINGLECOLLAPSE tree view control style.
    NSTCS_SPRINGEXPAND        = 0x00000010,
    ///The area of the window that contains the tree of namespace items has a horizontal scroll bar. Maps to the
    ///WS_HSCROLL Windows style.
    NSTCS_HORIZONTALSCROLL    = 0x00000020,
    ///The root item is preceded by an expando that allows expansion of the root item. Maps to the TVS_LINESATROOT tree
    ///view control style.
    NSTCS_ROOTHASEXPANDO      = 0x00000040,
    ///The node of an item is outlined when the control does not have the focus. Maps to the TVS_SHOWSELALWAYS tree view
    ///control style.
    NSTCS_SHOWSELECTIONALWAYS = 0x00000080,
    ///Do not display infotips when the mouse cursor is over an item. This is the opposite of the TVS_INFOTIP tree view
    ///control style.
    NSTCS_NOINFOTIP           = 0x00000200,
    ///Sets the height of the items to an even height. By default, the height of items can be even or odd. This is the
    ///opposite of the TVS_NONEVENHEIGHT tree view control style.
    NSTCS_EVENHEIGHT          = 0x00000400,
    ///Do not replace the <b>Open</b> command in the shortcut menu with a user-defined function.
    NSTCS_NOREPLACEOPEN       = 0x00000800,
    ///Do not allow drag-and-drop operations within the control. Note that you can still drag an item from outside of
    ///the control and drop it onto the control. Maps to the TVS_DISABLEDRAGDROP tree view control style.
    NSTCS_DISABLEDRAGDROP     = 0x00001000,
    ///Do not persist reordering changes. Used with NSTCS_FAVORITESMODE. If favorites mode is not specified, this flag
    ///has no effect.
    NSTCS_NOORDERSTREAM       = 0x00002000,
    ///Use a rich tooltip. Rich tooltips display the item's icon in addition to the item's text. A standard tooltip
    ///displays only the item's text. The tree view displays tooltips only for items in the tree that are partially
    ///visible. Maps to the TVS_EX_RICHTOOLTIP tree view control style. NSTCS_RICHTOOLTIP has no effect unless it is
    ///combined with NSTCS_NOINFOTIP and/or NSTCS_FAVORITESMODE. If NSTCS_NOINFOTIP is not specified, the tree view
    ///displays an infotip instead of a tooltip. If NSTCS_FAVORITESMODE is not specified, the namespace tree control
    ///always sets the TVS_EX_RICHTOOLTIP style.
    NSTCS_RICHTOOLTIP         = 0x00004000,
    ///Draw a thin border around the control. Corresponds to WS_BORDER.
    NSTCS_BORDER              = 0x00008000,
    ///Do not allow creation of an in-place edit box, which would allow the user to rename the given item. This is the
    ///opposite of the TVS_EDITLABELS tree view control style.
    NSTCS_NOEDITLABELS        = 0x00010000,
    ///If the control is hosted, you can tabstop into the control. Corresponds to WS_EX_CONTROLPARENT.
    NSTCS_TABSTOP             = 0x00020000,
    ///The control has the appearance of the favorites band in Windows XP.
    NSTCS_FAVORITESMODE       = 0x00080000,
    ///When you hover the mouse pointer over an item that extends past the end of the control window, the control
    ///automatically scrolls horizontally so that the item appears more fully in the window area. Maps to the
    ///TVS_EX_AUTOHSCROLL tree view control style.
    NSTCS_AUTOHSCROLL         = 0x00100000,
    ///If the control does not have the focus and there are items that are preceded by expandos, then these expandos are
    ///visible only when the mouse pointer is near to the control. Maps to the TVS_EX_FADEINOUTEXPANDOS tree view
    ///control style.
    NSTCS_FADEINOUTEXPANDOS   = 0x00200000,
    ///If an item has no children and is not expanded, then that item contains a line of text at the child level that
    ///says "empty".
    NSTCS_EMPTYTEXT           = 0x00400000,
    ///Items have check boxes on their leftmost side. These check boxes can be of types partial, exclusion or dimmed,
    ///which correspond to the flags NSTCS_PARTIALCHECKBOXES, NSTCS_EXCLUSIONCHECKBOXES, and NSTCS_DIMMEDCHECKBOXES.
    ///Maps to the TVS_CHECKBOXES tree view control style.
    NSTCS_CHECKBOXES          = 0x00800000,
    ///Adds a checkbox icon on the leftmost side of a given item with a square in the center, that indicates that the
    ///node is partially selected. Must be combined with NSTCS_CHECKBOXES. Maps to the TVS_EX_PARTIALCHECKBOXES tree
    ///view control style.
    NSTCS_PARTIALCHECKBOXES   = 0x01000000,
    ///Adds a checkbox icon on the leftmost side of a given item that contains a red <b>X</b>, which indicates that the
    ///item is excluded from the current selection. Without this exclusion icon, selection of a parent item includes
    ///selection of its child items. Must be combined with NSTCS_CHECKBOXES. Maps to the TVS_EX_EXCLUSIONCHECKBOXES tree
    ///view control style.
    NSTCS_EXCLUSIONCHECKBOXES = 0x02000000,
    ///Adds a checkbox on the leftmost side of a given item that contains an icon of a dimmed check mark, that indicates
    ///that a node is selected because its parent is selected. Must be combined with NSTCS_CHECKBOXES. Maps to the
    ///TVS_EX_DIMMEDCHECKBOXES tree view control style.
    NSTCS_DIMMEDCHECKBOXES    = 0x04000000,
    ///Check boxes are located at the far left edge of the window area instead of being indented. Maps to the
    ///TVS_EX_NOINDENTSTATE tree view control style.
    NSTCS_NOINDENTCHECKS      = 0x08000000,
    ///Allow junctions. A junction point, or just junction, is a root of a namespace extension that is normally
    ///displayed by Windows Explorer as a folder in both tree and folder views. For Windows Explorer to display your
    ///extension's files and subfolders, you must specify where the root folder is located in the Shell namespace
    ///hierarchy. Junctions exist in the file system as files, but are not treated as files. An example is a compressed
    ///file with a .zip file name extension, which to the file system is just a file. However, if this file is treated
    ///as a junction, it can represent an entire namespace. This allows the namespace tree control to treat compressed
    ///files and similar junctions as folders rather than as files.
    NSTCS_ALLOWJUNCTIONS      = 0x10000000,
    ///Displays an arrow on the right side of an item if the item is a folder. The action associated with the arrow is
    ///implementation specific. Cannot be combined with NSTCS_SHOWDELETEBUTTON or NSTCS_SHOWREFRESHBUTTON.
    NSTCS_SHOWTABSBUTTON      = 0x20000000,
    ///Displays a red <b>X</b> on the right side of an item. The action associated with the <b>X</b> is implementation
    ///specific. Cannot be combined with NSTCS_SHOWTABSBUTTON or NSTCS_SHOWREFRESHBUTTON.
    NSTCS_SHOWDELETEBUTTON    = 0x40000000,
    ///Displays a refresh button on the right side of an item. The action associated with the button is implementation
    ///specific. Cannot be combined with NSTCS_SHOWTABSBUTTON or NSTCS_SHOWDELETEBUTTON.
    NSTCS_SHOWREFRESHBUTTON   = 0x80000000,
}

alias _NSTCROOTSTYLE = int;
enum : int
{
    NSTCRS_VISIBLE  = 0x00000000,
    NSTCRS_HIDDEN   = 0x00000001,
    NSTCRS_EXPANDED = 0x00000002,
}

///Specifies the state of a tree item. These values are used by methods of the INameSpaceTreeControl interface.
alias _NSTCITEMSTATE = int;
enum : int
{
    ///The item has default state; it is not selected, expanded, bolded or disabled.
    NSTCIS_NONE             = 0x00000000,
    ///The item is selected.
    NSTCIS_SELECTED         = 0x00000001,
    ///The item is expanded.
    NSTCIS_EXPANDED         = 0x00000002,
    ///The item is bold.
    NSTCIS_BOLD             = 0x00000004,
    ///The item is disabled.
    NSTCIS_DISABLED         = 0x00000008,
    ///<b>Windows 7 and later</b>. The item is selected, but not expanded.
    NSTCIS_SELECTEDNOEXPAND = 0x00000010,
}

alias NSTCGNI = int;
enum : int
{
    NSTCGNI_NEXT         = 0x00000000,
    NSTCGNI_NEXTVISIBLE  = 0x00000001,
    NSTCGNI_PREV         = 0x00000002,
    NSTCGNI_PREVVISIBLE  = 0x00000003,
    NSTCGNI_PARENT       = 0x00000004,
    NSTCGNI_CHILD        = 0x00000005,
    NSTCGNI_FIRSTVISIBLE = 0x00000006,
    NSTCGNI_LASTVISIBLE  = 0x00000007,
}

///Specifies the state of a tree item. These values are used by methods of the INameSpaceTreeControlFolderCapabilities
///interface.
alias NSTCFOLDERCAPABILITIES = int;
enum : int
{
    ///The property does not exist. Filtering is not supported.
    NSTCFC_NONE                  = 0x00000000,
    ///Property exists. Supports filtering based on the value specified in System.IsPinnedToNameSpaceTree.
    NSTCFC_PINNEDITEMFILTERING   = 0x00000001,
    ///Delays registration for change notifications until the tree is expanded in the navigation pane.
    NSTCFC_DELAY_REGISTER_NOTIFY = 0x00000002,
}

///Indicate flags used by IExplorerPaneVisibility::GetPaneState to get the current state of the given Windows Explorer
///pane.
alias _EXPLORERPANESTATE = int;
enum : int
{
    ///Do not make any modifications to the pane.
    EPS_DONTCARE     = 0x00000000,
    ///Set the default state of the pane to "on", but respect any user-modified persisted state.
    EPS_DEFAULT_ON   = 0x00000001,
    ///Set the default state of the pane to "off".
    EPS_DEFAULT_OFF  = 0x00000002,
    ///Unused.
    EPS_STATEMASK    = 0x0000ffff,
    ///Ignore any persisted state from the user, but the user can still modify the state.
    EPS_INITIALSTATE = 0x00010000,
    EPS_FORCE        = 0x00020000,
}

///<b>EXPCMDSTATE</b> values represent the command state of a Shell item.
alias _EXPCMDSTATE = int;
enum : int
{
    ///The item is enabled.
    ECS_ENABLED    = 0x00000000,
    ///The item is unavailable. It might be displayed to the user as a dimmed, inaccessible item.
    ECS_DISABLED   = 0x00000001,
    ///The item is hidden.
    ECS_HIDDEN     = 0x00000002,
    ///The item is displayed with a check box and that check box is not checked.
    ECS_CHECKBOX   = 0x00000004,
    ///The item is displayed with a check box and that check box is checked. <b>ECS_CHECKED</b> is always returned with
    ///ECS_CHECKBOX.
    ECS_CHECKED    = 0x00000008,
    ///<b>Windows 7 and later</b>. The item is one of a group of mutually exclusive options selected through a radio
    ///button. ECS_RADIOCHECK does not imply that the item is the selected option, though it might be.
    ECS_RADIOCHECK = 0x00000010,
}

alias _EXPCMDFLAGS = int;
enum : int
{
    ECF_DEFAULT         = 0x00000000,
    ECF_HASSUBCOMMANDS  = 0x00000001,
    ECF_HASSPLITBUTTON  = 0x00000002,
    ECF_HIDELABEL       = 0x00000004,
    ECF_ISSEPARATOR     = 0x00000008,
    ECF_HASLUASHIELD    = 0x00000010,
    ECF_SEPARATORBEFORE = 0x00000020,
    ECF_SEPARATORAFTER  = 0x00000040,
    ECF_ISDROPDOWN      = 0x00000080,
    ECF_TOGGLEABLE      = 0x00000100,
    ECF_AUTOMENUICONS   = 0x00000200,
}

alias CPVIEW = int;
enum : int
{
    CPVIEW_CLASSIC  = 0x00000000,
    CPVIEW_ALLITEMS = 0x00000000,
    CPVIEW_CATEGORY = 0x00000001,
    CPVIEW_HOME     = 0x00000001,
}

alias KNOWNDESTCATEGORY = int;
enum : int
{
    KDC_FREQUENT = 0x00000001,
    KDC_RECENT   = 0x00000002,
}

alias APPDOCLISTTYPE = int;
enum : int
{
    ADLT_RECENT   = 0x00000000,
    ADLT_FREQUENT = 0x00000001,
}

alias DESKTOP_SLIDESHOW_OPTIONS = int;
enum : int
{
    DSO_SHUFFLEIMAGES = 0x00000001,
}

alias DESKTOP_SLIDESHOW_STATE = int;
enum : int
{
    DSS_ENABLED                    = 0x00000001,
    DSS_SLIDESHOW                  = 0x00000002,
    DSS_DISABLED_BY_REMOTE_SESSION = 0x00000004,
}

alias DESKTOP_SLIDESHOW_DIRECTION = int;
enum : int
{
    DSD_FORWARD  = 0x00000000,
    DSD_BACKWARD = 0x00000001,
}

///Specifies how the desktop wallpaper should be displayed.
alias DESKTOP_WALLPAPER_POSITION = int;
enum : int
{
    ///Center the image; do not stretch. This is equivalent to the WPSTYLE_CENTER style in IActiveDesktop.
    DWPOS_CENTER  = 0x00000000,
    ///Tile the image across all monitors. This is equivalent to the WPSTYLE_TILE style in IActiveDesktop.
    DWPOS_TILE    = 0x00000001,
    ///Stretch the image to exactly fit on the monitor. This is equivalent to the WPSTYLE_STRETCH style in
    ///IActiveDesktop.
    DWPOS_STRETCH = 0x00000002,
    ///Stretch the image to exactly the height or width of the monitor without changing its aspect ratio or cropping the
    ///image. This can result in colored letterbox bars on either side or on above and below of the image. This is
    ///equivalent to the WPSTYLE_KEEPASPECT style in IActiveDesktop.
    DWPOS_FIT     = 0x00000003,
    ///Stretch the image to fill the screen, cropping the image as necessary to avoid letterbox bars. This is equivalent
    ///to the WPSTYLE_CROPTOFIT style in IActiveDesktop.
    DWPOS_FILL    = 0x00000004,
    ///Spans a single image across all monitors attached to the system. This flag has no IActiveDesktop equivalent.
    DWPOS_SPAN    = 0x00000005,
}

alias HOMEGROUPSHARINGCHOICES = int;
enum : int
{
    HGSC_NONE             = 0x00000000,
    HGSC_MUSICLIBRARY     = 0x00000001,
    HGSC_PICTURESLIBRARY  = 0x00000002,
    HGSC_VIDEOSLIBRARY    = 0x00000004,
    HGSC_DOCUMENTSLIBRARY = 0x00000008,
    HGSC_PRINTERS         = 0x00000010,
}

///Defines options for filtering folder items.
alias LIBRARYFOLDERFILTER = int;
enum : int
{
    ///Return only file system items.
    LFF_FORCEFILESYSTEM = 0x00000001,
    ///Return items that can be bound to an IStorage object.
    LFF_STORAGEITEMS    = 0x00000002,
    ///Return all items.
    LFF_ALLITEMS        = 0x00000003,
}

///Specifies the library options.
alias LIBRARYOPTIONFLAGS = int;
enum : int
{
    ///No library options are set.
    LOF_DEFAULT         = 0x00000000,
    ///Pin the library to the navigation pane.
    LOF_PINNEDTONAVPANE = 0x00000001,
    ///All valid library options flags.
    LOF_MASK_ALL        = 0x00000001,
}

///Specifies the default save location.
alias DEFAULTSAVEFOLDERTYPE = int;
enum : int
{
    ///The current user determines the save folder. If the current user is the library's owner, use the private save
    ///location (DSFT_PRIVATE). If the current user is not the library's owner, use the public save location
    ///(DSFT_PUBLIC).
    DSFT_DETECT  = 0x00000001,
    ///The library's private save location, which can only be accessed by the library's owner.
    DSFT_PRIVATE = 0x00000002,
    ///The library's public save location, which can be accessed by all users.
    DSFT_PUBLIC  = 0x00000003,
}

///Specifies the options for handling a name collision when saving a library.
alias LIBRARYSAVEFLAGS = int;
enum : int
{
    ///If a library with the same name already exists, the save operation fails.
    LSF_FAILIFTHERE      = 0x00000000,
    ///If a library with the same name already exists, the save operation overwrites the existing library.
    LSF_OVERRIDEEXISTING = 0x00000001,
    ///If a library with the same name already exists, the save operation generates a new, unique name for the library.
    LSF_MAKEUNIQUENAME   = 0x00000002,
}

///Defines shortcut menu restrictions used by
///[IDefaultFolderMenuInitialize::GetMenuRestrictions](nf-shobjidl_core-idefaultfoldermenuinitialize-getmenurestrictions.md)
///and
///[IDefaultFolderMenuInitialize::SetMenuRestrictions](nf-shobjidl_core-idefaultfoldermenuinitialize-setmenurestrictions.md).
alias DEFAULT_FOLDER_MENU_RESTRICTIONS = int;
enum : int
{
    ///0x0000. No restrictions.
    DFMR_DEFAULT                        = 0x00000000,
    ///0x0008. Don't use the handler for static verbs.
    DFMR_NO_STATIC_VERBS                = 0x00000008,
    ///0x0010. Static verbs only. No dynamic **IContextMenu** verbs allowed.
    DFMR_STATIC_VERBS_ONLY              = 0x00000010,
    ///0x0020. Don't add verbs for cut, copy, paste, link, delete, rename, or properties.
    DFMR_NO_RESOURCE_VERBS              = 0x00000020,
    ///0x0040. Opt-in to load handler for partial cloud files. Only used for handlers that will not cause implicit
    ///hydration. Opt-in handlers must have the registry value "ContextMenuOptIn" under HKCR\CLSID\<handler clsid>
    DFMR_OPTIN_HANDLERS_ONLY            = 0x00000040,
    ///0x0080. Only load resource verbs (cut, copy, paste, link, delete, rename, and properties) and folder verbs added
    ///by [IContextMenuCB](nn-shobjidl_core-icontextmenucb.md).
    DFMR_RESOURCE_AND_FOLDER_VERBS_ONLY = 0x00000080,
    ///0x0100. Use handlers with CLSID values that were added through
    ///[IDefaultFolderMenuInitialize::SetHandlerClsid](nf-shobjidl_core-idefaultfoldermenuinitialize-sethandlerclsid.md)
    DFMR_USE_SPECIFIED_HANDLERS         = 0x00000100,
    ///0x0200. Only load handlers that support the specified verbs.
    DFMR_USE_SPECIFIED_VERBS            = 0x00000200,
    ///0x0400. Ignore async verbs.
    DFMR_NO_ASYNC_VERBS                 = 0x00000400,
    ///0x0800. Ignore verbs that are registered for the native CPU architecture.
    DFMR_NO_NATIVECPU_VERBS             = 0x00000800,
}

alias ACTIVATEOPTIONS = int;
enum : int
{
    AO_NONE           = 0x00000000,
    AO_DESIGNMODE     = 0x00000001,
    AO_NOERRORUI      = 0x00000002,
    AO_NOSPLASHSCREEN = 0x00000004,
    AO_PRELAUNCH      = 0x02000000,
}

///Used by SHShowManageLibraryUI to define options for handling a name collision when saving a library.
alias LIBRARYMANAGEDIALOGOPTIONS = int;
enum : int
{
    ///Show default warning UI to the user.
    LMD_DEFAULT                          = 0x00000000,
    LMD_ALLOWUNINDEXABLENETWORKLOCATIONS = 0x00000001,
}

alias AHTYPE = int;
enum : int
{
    AHTYPE_UNDEFINED         = 0x00000000,
    AHTYPE_USER_APPLICATION  = 0x00000008,
    AHTYPE_ANY_APPLICATION   = 0x00000010,
    AHTYPE_MACHINEDEFAULT    = 0x00000020,
    AHTYPE_PROGID            = 0x00000040,
    AHTYPE_APPLICATION       = 0x00000080,
    AHTYPE_CLASS_APPLICATION = 0x00000100,
    AHTYPE_ANY_PROGID        = 0x00000200,
}

alias ASSOC_FILTER = int;
enum : int
{
    ASSOC_FILTER_NONE        = 0x00000000,
    ASSOC_FILTER_RECOMMENDED = 0x00000001,
}

///Specifies whether a display is showing desktop windows instead of Windows Store apps.
alias MONITOR_APP_VISIBILITY = int;
enum : int
{
    ///The display state is not known.
    MAV_UNKNOWN        = 0x00000000,
    ///The display is showing desktop windows.
    MAV_NO_APP_VISIBLE = 0x00000001,
    ///The display is not showing desktop windows.
    MAV_APP_VISIBLE    = 0x00000002,
}

///Represents the state of a Windows app package.
alias PACKAGE_EXECUTION_STATE = int;
enum : int
{
    ///The package is in an unknown state.
    PES_UNKNOWN    = 0x00000000,
    ///The package is running.
    PES_RUNNING    = 0x00000001,
    ///The package is being suspended.
    PES_SUSPENDING = 0x00000002,
    ///The package is suspended.
    PES_SUSPENDED  = 0x00000003,
    ///The package was terminated.
    PES_TERMINATED = 0x00000004,
}

alias AHE_TYPE = int;
enum : int
{
    AHE_DESKTOP   = 0x00000000,
    AHE_IMMERSIVE = 0x00000001,
}

alias EC_HOST_UI_MODE = int;
enum : int
{
    ECHUIM_DESKTOP         = 0x00000000,
    ECHUIM_IMMERSIVE       = 0x00000001,
    ECHUIM_SYSTEM_LAUNCHER = 0x00000002,
}

///Indicates the current view state of a Windows Store app. Used by
///IApplicationDesignModeSettings::SetApplicationViewState and
///IApplicationDesignModeSettings::IsApplicationViewStateSupported.
alias APPLICATION_VIEW_STATE = int;
enum : int
{
    ///The current app's view is full-screen (has no snapped app adjacent to it), and is in landscape orientation.
    AVS_FULLSCREEN_LANDSCAPE = 0x00000000,
    ///The current app's view has been reduced to a partial screen view as the result of another app snapping (being
    ///docked at one side of the screen in a narrow view).
    AVS_FILLED               = 0x00000001,
    ///The current app's view has been snapped (docked at one side of the screen in a narrow view).
    AVS_SNAPPED              = 0x00000002,
    ///The current app's view is full-screen (has no snapped app adjacent to it), and is in portrait orientation.
    AVS_FULLSCREEN_PORTRAIT  = 0x00000003,
}

alias EDGE_GESTURE_KIND = int;
enum : int
{
    EGK_TOUCH    = 0x00000000,
    EGK_KEYBOARD = 0x00000001,
    EGK_MOUSE    = 0x00000002,
}

alias NATIVE_DISPLAY_ORIENTATION = int;
enum : int
{
    NDO_LANDSCAPE = 0x00000000,
    NDO_PORTRAIT  = 0x00000001,
}

///Defines the set of display orientation modes for a window (app view). Used by
///IApplicationDesignModeSettings2::GetApplicationViewOrientation and
///IApplicationDesignModeSettings2::SetApplicationViewOrientation.
alias APPLICATION_VIEW_ORIENTATION = int;
enum : int
{
    ///The window is in landscape orientation, with the display width greater than the height.
    AVO_LANDSCAPE = 0x00000000,
    ///The window is in portrait orientation, with the display height greater than the width.
    AVO_PORTRAIT  = 0x00000001,
}

alias ADJACENT_DISPLAY_EDGES = int;
enum : int
{
    ADE_NONE  = 0x00000000,
    ADE_LEFT  = 0x00000001,
    ADE_RIGHT = 0x00000002,
}

alias APPLICATION_VIEW_MIN_WIDTH = int;
enum : int
{
    AVMW_DEFAULT = 0x00000000,
    AVMW_320     = 0x00000001,
    AVMW_500     = 0x00000002,
}

///Defines the set of possible general window (app view) size preferences. Used by
///ILaunchSourceViewSizePreference::GetSourceViewSizePreference and
///ILaunchTargetViewSizePreference::GetTargetViewSizePreference.
alias APPLICATION_VIEW_SIZE_PREFERENCE = int;
enum : int
{
    ///The app does not specify a window size preference. Windows, rather than the app, sets the size preference, which
    ///defaults to <b>AVSP_USE_HALF</b>.
    AVSP_DEFAULT     = 0x00000000,
    ///Prefers to use less than 50% of the available horizontal screen pixels.
    AVSP_USE_LESS    = 0x00000001,
    ///Prefers to use 50% (half) of the available horizontal screen pixels.
    AVSP_USE_HALF    = 0x00000002,
    ///Prefers to use more than 50% of the available horizontal screen pixels.
    AVSP_USE_MORE    = 0x00000003,
    ///Prefers to use the minimum horizontal pixel width (either 320 or 500 pixels) specified in the app's manifest.
    AVSP_USE_MINIMUM = 0x00000004,
    ///The window has no visible component.
    AVSP_USE_NONE    = 0x00000005,
    AVSP_CUSTOM      = 0x00000006,
}

alias FLYOUT_PLACEMENT = int;
enum : int
{
    FP_DEFAULT = 0x00000000,
    FP_ABOVE   = 0x00000001,
    FP_BELOW   = 0x00000002,
    FP_LEFT    = 0x00000003,
    FP_RIGHT   = 0x00000004,
}

alias BANNER_NOTIFICATION_EVENT = int;
enum : int
{
    BNE_Rendered       = 0x00000000,
    BNE_Hovered        = 0x00000001,
    BNE_Closed         = 0x00000002,
    BNE_Dismissed      = 0x00000003,
    BNE_Button1Clicked = 0x00000004,
    BNE_Button2Clicked = 0x00000005,
}

alias SORT_ORDER_TYPE = int;
enum : int
{
    SOT_DEFAULT           = 0x00000000,
    SOT_IGNORE_FOLDERNESS = 0x00000001,
}

///Used by methods of the IFolderViewOptions interface to activate Windows Vista options not supported by default in
///Windows 7 and later systems as well as deactivating new Windows 7 options.
alias FOLDERVIEWOPTIONS = int;
enum : int
{
    ///0x00000000. Do not use any special options.
    FVO_DEFAULT           = 0x00000000,
    ///0x00000001. Use the Windows Vista list view. This can be used to maintain continuity between systems so that
    ///users are presented with an expected view. At this time, setting this flag has the effective, though not literal,
    ///result of the application of the FVO_CUSTOMPOSITION and FVO_CUSTOMORDERING flags. However, this could change.
    ///Applications should be specific about the behaviors that they require. For instance, if an application requires
    ///custom positioning of its items, it should not rely on FVO_VISTALAYOUT to provide it, but instead explicitly
    ///apply the FVO_CUSTOMPOSITION flag.
    FVO_VISTALAYOUT       = 0x00000001,
    ///0x00000002. Items require custom positioning within the space of the view. Those items are positioned to specific
    ///coordinates. This option is not active by default in the Windows 7 view.
    FVO_CUSTOMPOSITION    = 0x00000002,
    ///0x00000004. Items require custom ordering within the view. This option is not active by default in the Windows 7
    ///view. When it is active, the user can reorder the view by dragging items to their desired locations.
    FVO_CUSTOMORDERING    = 0x00000004,
    ///0x00000008. Tiles and Details displays can contain hyperlinks. This option is not active by default in the
    ///Windows 7 view. When hyperlinks are displayed, they are updated to the Windows 7 view.
    FVO_SUPPORTHYPERLINKS = 0x00000008,
    ///0x00000010. Do not display animations in the view. This option was introduced in Windows 7 and is active by
    ///default in the Windows 7 view.
    FVO_NOANIMATIONS      = 0x00000010,
    FVO_NOSCROLLTIPS      = 0x00000020,
}

alias _SV3CVW3_FLAGS = int;
enum : int
{
    SV3CVW3_DEFAULT          = 0x00000000,
    SV3CVW3_NONINTERACTIVE   = 0x00000001,
    SV3CVW3_FORCEVIEWMODE    = 0x00000002,
    SV3CVW3_FORCEFOLDERFLAGS = 0x00000004,
}

///Specifies watermark flags. Used by IVisualProperties::SetWatermark.
alias VPWATERMARKFLAGS = int;
enum : int
{
    ///Default Windows XP behavior.
    VPWF_DEFAULT    = 0x00000000,
    VPWF_ALPHABLEND = 0x00000001,
}

///Specifies the use of a color. Used by IVisualProperties methods.
alias VPCOLORFLAGS = int;
enum : int
{
    ///A text color.
    VPCF_TEXT           = 0x00000001,
    ///A background color.
    VPCF_BACKGROUND     = 0x00000002,
    ///A sort-column color.
    VPCF_SORTCOLUMN     = 0x00000003,
    ///A subtext color.
    VPCF_SUBTEXT        = 0x00000004,
    VPCF_TEXTBACKGROUND = 0x00000005,
}

alias DSH_FLAGS = int;
enum : int
{
    DSH_ALLOWDROPDESCRIPTIONTEXT = 0x00000001,
}

alias tagCDBURNINGEXTENSIONRET = int;
enum : int
{
    CDBE_RET_DEFAULT          = 0x00000000,
    CDBE_RET_DONTRUNOTHEREXTS = 0x00000001,
    CDBE_RET_STOPWIZARD       = 0x00000002,
}

alias _CDBE_ACTIONS = int;
enum : int
{
    CDBE_TYPE_MUSIC = 0x00000001,
    CDBE_TYPE_DATA  = 0x00000002,
    CDBE_TYPE_ALL   = 0xffffffff,
}

///Used by methods of the INameSpaceTreeControl2 to specify extended display styles in a Shell namespace treeview.
alias NSTCSTYLE2 = int;
enum : int
{
    ///Displays the tree nodes in default mode, which includes none of the following values.
    NSTCS2_DEFAULT                  = 0x00000000,
    ///Displays interrupt notifications.
    NSTCS2_INTERRUPTNOTIFICATIONS   = 0x00000001,
    ///Displays the context menu in the padding space.
    NSTCS2_SHOWNULLSPACEMENU        = 0x00000002,
    ///Inserts spacing (padding) between top-level nodes.
    NSTCS2_DISPLAYPADDING           = 0x00000004,
    ///Filters items based on the System.IsPinnedToNameSpaceTree value when INameSpaceTreeControlFolderCapabilities is
    ///implemented.
    NSTCS2_DISPLAYPINNEDONLY        = 0x00000008,
    NTSCS2_NOSINGLETONAUTOEXPAND    = 0x00000010,
    ///Do not insert nonenumerated (SFGAO_NONENUMERATED) items in the tree.
    NTSCS2_NEVERINSERTNONENUMERATED = 0x00000020,
}

alias _NSTCEHITTEST = int;
enum : int
{
    NSTCEHT_NOWHERE         = 0x00000001,
    NSTCEHT_ONITEMICON      = 0x00000002,
    NSTCEHT_ONITEMLABEL     = 0x00000004,
    NSTCEHT_ONITEMINDENT    = 0x00000008,
    NSTCEHT_ONITEMBUTTON    = 0x00000010,
    NSTCEHT_ONITEMRIGHT     = 0x00000020,
    NSTCEHT_ONITEMSTATEICON = 0x00000040,
    NSTCEHT_ONITEM          = 0x00000046,
    NSTCEHT_ONITEMTABBUTTON = 0x00001000,
}

alias _NSTCECLICKTYPE = int;
enum : int
{
    NSTCECT_LBUTTON  = 0x00000001,
    NSTCECT_MBUTTON  = 0x00000002,
    NSTCECT_RBUTTON  = 0x00000003,
    NSTCECT_BUTTON   = 0x00000003,
    NSTCECT_DBLCLICK = 0x00000004,
}

///Values that indicate the reason that a docked accessibility app window has been undocked. Used by
///IAccessibilityDockingServiceCallback::Undocked.
alias UNDOCK_REASON = int;
enum : int
{
    ///The accessibility window was undocked because the screen resolution has changed.
    UR_RESOLUTION_CHANGE  = 0x00000000,
    UR_MONITOR_DISCONNECT = 0x00000001,
}

enum OfflineFolderStatus : int
{
    OFS_INACTIVE   = 0xffffffff,
    OFS_ONLINE     = 0x00000000,
    OFS_OFFLINE    = 0x00000001,
    OFS_SERVERBACK = 0x00000002,
    OFS_DIRTYCACHE = 0x00000003,
}

///Specifies the view options returned by the ViewOptions property.
enum ShellFolderViewOptions : int
{
    ///0x0001. The <b>Show All Files</b> option is enabled.
    SFVVO_SHOWALLOBJECTS       = 0x00000001,
    ///0x0002. The <b>Hide extensions for known file types</b> option is disabled.
    SFVVO_SHOWEXTENSIONS       = 0x00000002,
    ///0x0008. The <b>Display Compressed Files and Folders with Alternate Color</b> option is enabled.
    SFVVO_SHOWCOMPCOLOR        = 0x00000008,
    ///0x0020. The <b>Do Not Show Hidden Files</b> option is enabled.
    SFVVO_SHOWSYSFILES         = 0x00000020,
    ///0x0040. The <b>Classic Style</b> option is enabled.
    SFVVO_WIN95CLASSIC         = 0x00000040,
    ///0x0080. The <b>Double-Click to Open an Item</b> option is enabled.
    SFVVO_DOUBLECLICKINWEBVIEW = 0x00000080,
    SFVVO_DESKTOPHTML          = 0x00000200,
}

///Specifies unique, system-independent values that identify special folders. These folders are frequently used by
///applications but which may not have the same name or location on any given system. For example, the system folder can
///be "C:\Windows" on one system and "C:\Winnt" on another.
enum ShellSpecialFolderConstants : int
{
    ///0x00 (0). Windows desktop—the virtual folder that is the root of the namespace.
    ssfDESKTOP          = 0x00000000,
    ///0x02 (2). File system directory that contains the user's program groups (which are also file system directories).
    ///A typical path is C:\Users&
    ssfPROGRAMS         = 0x00000002,
    ///0x03 (3). Virtual folder that contains icons for the Control Panel applications.
    ssfCONTROLS         = 0x00000003,
    ///0x04 (4). Virtual folder that contains installed printers.
    ssfPRINTERS         = 0x00000004,
    ///0x05 (5). File system directory that serves as a common repository for a user's documents. A typical path is
    ///C:\Users&
    ssfPERSONAL         = 0x00000005,
    ///0x06 (6). File system directory that serves as a common repository for the user's favorite URLs. A typical path
    ///is C:\Documents and Settings&
    ssfFAVORITES        = 0x00000006,
    ///0x07 (7). File system directory that corresponds to the user's Startup program group. The system starts these
    ///programs whenever any user first logs into their profile after a reboot. A typical path is C:\Users&
    ssfSTARTUP          = 0x00000007,
    ///0x08 (8). File system directory that contains the user's most recently used documents. A typical path is
    ///C:\Users&
    ssfRECENT           = 0x00000008,
    ///0x09 (9). File system directory that contains <b>Send To</b> menu items. A typical path is C:\Users&
    ssfSENDTO           = 0x00000009,
    ///0x0a (10). Virtual folder that contains the objects in the user's Recycle Bin.
    ssfBITBUCKET        = 0x0000000a,
    ///0x0b (11). File system directory that contains <b>Start</b> menu items. A typical path is C:\Users&
    ssfSTARTMENU        = 0x0000000b,
    ///0x10 (16). File system directory used to physically store the file objects that are displayed on the desktop. It
    ///is not to be confused with the desktop folder itself, which is a virtual folder. A typical path is C:\Documents
    ///and Settings&
    ssfDESKTOPDIRECTORY = 0x00000010,
    ///0x11 (17). My Computer—the virtual folder that contains everything on the local computer: storage devices,
    ///printers, and Control Panel. This folder can also contain mapped network drives.
    ssfDRIVES           = 0x00000011,
    ///0x12 (18). Network Neighborhood—the virtual folder that represents the root of the network namespace hierarchy.
    ssfNETWORK          = 0x00000012,
    ///0x13 (19). A file system folder that contains any link objects in the <b>My Network Places</b> virtual folder. It
    ///is not the same as ssfNETWORK, which represents the network namespace root. A typical path is C:\Users&
    ssfNETHOOD          = 0x00000013,
    ///0x14 (20). Virtual folder that contains installed fonts. A typical path is C:\Windows\Fonts.
    ssfFONTS            = 0x00000014,
    ///0x15 (21). File system directory that serves as a common repository for document templates.
    ssfTEMPLATES        = 0x00000015,
    ///0x16 (22). File system directory that contains the programs and folders that appear on the <b>Start</b> menu for
    ///all users. A typical path is C:\Documents and Settings\All Users\Start Menu. Valid only for Windows NT systems.
    ssfCOMMONSTARTMENU  = 0x00000016,
    ///0x17 (23). File system directory that contains the directories for the common program groups that appear on the
    ///<b>Start</b> menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs. Valid
    ///only for Windows NT systems.
    ssfCOMMONPROGRAMS   = 0x00000017,
    ///0x18 (24). File system directory that contains the programs that appear in the Startup folder for all users. A
    ///typical path is C:\Documents and Settings\All Users\Microsoft\Windows\Start Menu\Programs\StartUp. Valid only for
    ///Windows NT systems.
    ssfCOMMONSTARTUP    = 0x00000018,
    ///0x19 (25). File system directory that contains files and folders that appear on the desktop for all users. A
    ///typical path is C:\Documents and Settings\All Users\Desktop. Valid only for Windows NT systems.
    ssfCOMMONDESKTOPDIR = 0x00000019,
    ///0x1a (26). Version 4.71. File system directory that serves as a common repository for application-specific data.
    ///A typical path is C:\Documents and Settings&
    ssfAPPDATA          = 0x0000001a,
    ///0x1b (27). File system directory that contains any link objects in the Printers virtual folder. A typical path is
    ///C:\Users&
    ssfPRINTHOOD        = 0x0000001b,
    ///0x1c (28). Version 5.0. File system directory that serves as a data repository for local (non-roaming)
    ///applications. A typical path is C:\Users&
    ssfLOCALAPPDATA     = 0x0000001c,
    ///0x1d (29). File system directory that corresponds to the user's non-localized Startup program group.
    ssfALTSTARTUP       = 0x0000001d,
    ///0x1e (30). File system directory that corresponds to the non-localized Startup program group for all users. Valid
    ///only for Windows NT systems.
    ssfCOMMONALTSTARTUP = 0x0000001e,
    ///0x1f (31). File system directory that serves as a common repository for the favorite URLs shared by all users.
    ///Valid only for Windows NT systems.
    ssfCOMMONFAVORITES  = 0x0000001f,
    ///0x20 (32). File system directory that serves as a common repository for temporary Internet files. A typical path
    ///is C:\Users&
    ssfINTERNETCACHE    = 0x00000020,
    ///0x21 (33). File system directory that serves as a common repository for Internet cookies. A typical path is
    ///C:\Documents and Settings&
    ssfCOOKIES          = 0x00000021,
    ///0x22 (34). File system directory that serves as a common repository for Internet history items.
    ssfHISTORY          = 0x00000022,
    ///0x23 (35). Version 5.0. Application data for all users. A typical path is C:\Documents and Settings\All
    ///Users\Application Data.
    ssfCOMMONAPPDATA    = 0x00000023,
    ///0x24 (36). Version 5.0. Windows directory. This corresponds to the %windir% or %SystemRoot% environment
    ///variables. A typical path is C:\Windows.
    ssfWINDOWS          = 0x00000024,
    ///0x25 (37). Version 5.0. The System folder. A typical path is C:\Windows\System32.
    ssfSYSTEM           = 0x00000025,
    ///0x26 (38). Version 5.0. Program Files folder. A typical path is C:\Program Files.
    ssfPROGRAMFILES     = 0x00000026,
    ///0x27 (39). My Pictures folder. A typical path is C:\Users&
    ssfMYPICTURES       = 0x00000027,
    ///0x28 (40). Version 5.0. User's profile folder.
    ssfPROFILE          = 0x00000028,
    ///0x29 (41). Version 5.0. System folder. A typical path is C:\Windows\System32, or C:\Windows\Syswow32 on a 64-bit
    ///computer.
    ssfSYSTEMx86        = 0x00000029,
    ///Do not use this field. Use the value 0x2a (42) in your code instead to specify the Program Files (x86) folder. A
    ///typical path is C:\Program Files, or C:\Program Files (x86) on a 64-bit computer. **Note:** In the shldisp.h
    ///header, the **ssfPROGRAMFILESx86** field is erroneously assigned to the value 0x30 (48). This value specifies the
    ///folder for the Administrative Tools folder instead of the Program Files folder.
    ssfPROGRAMFILESx86  = 0x00000030,
}

///Specifies values used by IAutoComplete2::GetOptions and IAutoComplete2::SetOptions for options surrounding
///autocomplete.
alias AUTOCOMPLETEOPTIONS = int;
enum : int
{
    ///0x0000. Do not autocomplete.
    ACO_NONE               = 0x00000000,
    ///0x0001. Enable the autosuggest drop-down list.
    ACO_AUTOSUGGEST        = 0x00000001,
    ///0x0002. Enable autoappend.
    ACO_AUTOAPPEND         = 0x00000002,
    ///0x0004. Add a search item to the list of completed strings. When the user selects this item, it launches a search
    ///engine.
    ACO_SEARCH             = 0x00000004,
    ///0x0008. Do not match common prefixes, such as "www." or "http://".
    ACO_FILTERPREFIXES     = 0x00000008,
    ///0x0010. Use the TAB key to select an item from the drop-down list.
    ACO_USETAB             = 0x00000010,
    ///0x0020. Use the UP ARROW and DOWN ARROW keys to display the autosuggest drop-down list.
    ACO_UPDOWNKEYDROPSLIST = 0x00000020,
    ///0x0040. Normal windows display text left-to-right (LTR). Windows can be mirrored to display languages such as
    ///Hebrew or Arabic that read right-to-left (RTL). Typically, control text is displayed in the same direction as the
    ///text in its parent window. If ACO_RTLREADING is set, the text reads in the opposite direction from the text in
    ///the parent window.
    ACO_RTLREADING         = 0x00000040,
    ///0x0080. <b>Windows Vista and later</b>. If set, the autocompleted suggestion is treated as a phrase for search
    ///purposes. The suggestion, <i>Microsoft Office</i>, would be treated as <i>"Microsoft Office"</i> (where both
    ///<i>Microsoft</i> AND <i>Office</i> must appear in the search results).
    ACO_WORD_FILTER        = 0x00000080,
    ACO_NOPREFIXFILTERING  = 0x00000100,
}

alias ACENUMOPTION = int;
enum : int
{
    ACEO_NONE            = 0x00000000,
    ACEO_MOSTRECENTFIRST = 0x00000001,
    ACEO_FIRSTUNUSED     = 0x00010000,
}

///Specifies option settings. Used with IShellLinkDataList::GetFlags and IShellLinkDataList::SetFlags.
alias SHELL_LINK_DATA_FLAGS = int;
enum : int
{
    ///0x00000000. Default value used when no other flag is explicitly set.
    SLDF_DEFAULT                               = 0x00000000,
    ///0x00000001. The Shell link was saved with an ID list.
    SLDF_HAS_ID_LIST                           = 0x00000001,
    ///0x00000002. The Shell link was saved with link information to enable distributed tracking. This information is
    ///used by .lnk files to locate the target if the targets's path has changed. It includes information such as volume
    ///label and serial number, although the specific stored information can change from release to release.
    SLDF_HAS_LINK_INFO                         = 0x00000002,
    ///0x00000004. The link has a name.
    SLDF_HAS_NAME                              = 0x00000004,
    ///0x00000008. The link has a relative path.
    SLDF_HAS_RELPATH                           = 0x00000008,
    ///0x00000010. The link has a working directory.
    SLDF_HAS_WORKINGDIR                        = 0x00000010,
    ///0x00000020. The link has arguments.
    SLDF_HAS_ARGS                              = 0x00000020,
    ///0x00000040. The link has an icon location.
    SLDF_HAS_ICONLOCATION                      = 0x00000040,
    ///0x00000080. Stored strings are Unicode.
    SLDF_UNICODE                               = 0x00000080,
    ///0x00000100. Prevents the storage of link tracking information. If this flag is set, it is less likely, though not
    ///impossible, that a target can be found by the link if that target is moved.
    SLDF_FORCE_NO_LINKINFO                     = 0x00000100,
    ///0x00000200. The link contains expandable environment strings such as <code>%windir%</code>.
    SLDF_HAS_EXP_SZ                            = 0x00000200,
    ///0x00000400. Causes a 16-bit target application to run in a separate Virtual DOS Machine (VDM)/Windows on Windows
    ///(WOW).
    SLDF_RUN_IN_SEPARATE                       = 0x00000400,
    ///0x00001000. The link is a special Windows Installer link.
    SLDF_HAS_DARWINID                          = 0x00001000,
    ///0x00002000. Causes the target application to run as a different user.
    SLDF_RUNAS_USER                            = 0x00002000,
    ///0x00004000. The icon path in the link contains an expandable environment string such as such as
    ///<code>%windir%</code>.
    SLDF_HAS_EXP_ICON_SZ                       = 0x00004000,
    ///0x00008000. Prevents the use of ID list alias mapping when parsing the ID list from the path.
    SLDF_NO_PIDL_ALIAS                         = 0x00008000,
    ///0x00010000. Forces the use of the UNC name (a full network resource name), rather than the local name.
    SLDF_FORCE_UNCNAME                         = 0x00010000,
    ///0x00020000. Causes the target of this link to launch with a shim layer active. A shim is an intermediate DLL that
    ///facilitates compatibility between otherwise incompatible software services. Shims are typically used to provide
    ///version compatibility.
    SLDF_RUN_WITH_SHIMLAYER                    = 0x00020000,
    ///0x00040000. <b>Introduced in Windows Vista</b>. Disable object ID distributed tracking information.
    SLDF_FORCE_NO_LINKTRACK                    = 0x00040000,
    ///0x00080000. <b>Introduced in Windows Vista</b>. Enable the caching of target metadata into the link file.
    SLDF_ENABLE_TARGET_METADATA                = 0x00080000,
    ///0x00100000. <b>Introduced in Windows 7</b>. Disable shell link tracking.
    SLDF_DISABLE_LINK_PATH_TRACKING            = 0x00100000,
    ///0x00200000. <b>Introduced in Windows Vista</b>. Disable known folder tracking information.
    SLDF_DISABLE_KNOWNFOLDER_RELATIVE_TRACKING = 0x00200000,
    ///0x00400000. <b>Introduced in Windows 7</b>. Disable known folder alias mapping when loading the IDList during
    ///deserialization.
    SLDF_NO_KF_ALIAS                           = 0x00400000,
    ///0x00800000. <b>Introduced in Windows 7</b>. Allow link to point to another shell link as long as this does not
    ///create cycles.
    SLDF_ALLOW_LINK_TO_LINK                    = 0x00800000,
    ///0x01000000. <b>Introduced in Windows 7</b>. Remove alias when saving the IDList.
    SLDF_UNALIAS_ON_SAVE                       = 0x01000000,
    ///0x02000000. <b>Introduced in Windows 7</b>. Recalculate the IDList from the path with the environmental variables
    ///at load time, rather than persisting the IDList.
    SLDF_PREFER_ENVIRONMENT_PATH               = 0x02000000,
    ///0x04000000. <b>Introduced in Windows 7</b>. If the target is a UNC location on a local machine, keep the local
    ///IDList target in addition to the remote target.
    SLDF_KEEP_LOCAL_IDLIST_FOR_UNC_TARGET      = 0x04000000,
    ///0x08000000. <b>Introduced in Windows 8</b>. Persist the target IDlist in its volume-ID-relative form to avoid a
    ///dependency on drive letters.
    SLDF_PERSIST_VOLUME_ID_RELATIVE            = 0x08000000,
    ///<b>Introduced in Windows Vista</b>. A mask for valid SHELL_LINK_DATA_FLAGS bits. <table class="clsStd"> <tr>
    ///<th>OS</th> <th>Value</th> </tr> <tr> <td>Windows 8</td> <td>0x0FFFF7FF</td> </tr> <tr> <td>Windows 7</td>
    ///<td>0x07FFF7FF</td> </tr> <tr> <td>Windows Vista</td> <td>0x003FF7FF</td> </tr> </table>
    SLDF_VALID                                 = 0x0ffff7ff,
    SLDF_RESERVED                              = 0x80000000,
}

alias SHGFP_TYPE = int;
enum : int
{
    SHGFP_TYPE_CURRENT = 0x00000000,
    SHGFP_TYPE_DEFAULT = 0x00000001,
}

///Specify special retrieval options for known folders. These values supersede CSIDL values, which have parallel
///meanings.
alias KNOWN_FOLDER_FLAG = int;
enum : int
{
    ///0x00000000. No flags.
    KF_FLAG_DEFAULT                          = 0x00000000,
    ///0x00080000. Introduced in Windows 10, version 1709. When called from a packaged app,
    ///<b>LocalAppData/RoamingAppData</b> folders are redirected to private app locations that match the paths returned
    ///from Windows.Storage.ApplicationData.Current{LocalFolder|RoamingFolder}. Other folders are redirected to
    ///subdirectories of <b>LocalAppData</b> This flag is used with <b>FOLDERID_AppDataDesktop</b>,
    ///<b>FOLDERID_AppDataDocuments</b>, <b>FOLDERID_AppDataFavorites</b>, and <b>FOLDERID_AppDataProgramData</b>. It is
    ///also intended for compatibility with .NET applications, and not meant to be used directly from an application.
    KF_FLAG_FORCE_APP_DATA_REDIRECTION       = 0x00080000,
    ///0x00040000. <b>Introduced in Windows 10, version 1703</b>. When running in a Desktop Bridge process, some file
    ///system locations are redirected to package-specific locations by the file system. This flag will cause the target
    ///of the direction to be returned for those locations. This is useful in cases where the real location within the
    ///file system needs to be known.
    KF_FLAG_RETURN_FILTER_REDIRECTION_TARGET = 0x00040000,
    ///0x00020000. <b>Introduced in Windows 10, version 1703</b>. When running inside an AppContainer process, or when
    ///providing an AppContainer token, some folders are redirected to AppContainer-specific locations within the
    ///package. This flag will force with redirection for folders that are not normally redirected for the purposes of
    ///Desktop Bridge processes, and can be used for sharing files between UWA and Desktop Bridge apps within the same
    ///package. This flag is functionally identical to <b>KF_FLAG_FORCE_APPCONTAINER_REDIRECTION</b>.
    KF_FLAG_FORCE_PACKAGE_REDIRECTION        = 0x00020000,
    ///0x00010000. <b>Introduced in Windows 10, version 1703</b>. When running inside a packaged process (such as a
    ///Desktop Bridge app or an AppContainer), or when providing a packaged process token, some folders are redirected
    ///to package-specific locations. This flag disables redirection on locations where it is applied, and instead
    ///returns the path that would be returned were it not running inside a packaged process. This flag is functionally
    ///identical to <b>KF_FLAG_NO_APPCONTAINER_REDIRECTION</b>.
    KF_FLAG_NO_PACKAGE_REDIRECTION           = 0x00010000,
    ///0x00020000. Introduced in Windows 8. This flag is functionally identical to
    ///<b>KF_FLAG_FORCE_PACKAGE_REDIRECTION</b>, and was deprecated in Windows 10, version 1703.
    KF_FLAG_FORCE_APPCONTAINER_REDIRECTION   = 0x00020000,
    ///0x00010000. <b>Introduced in Windows 8</b>. This flag is functionally identical to
    ///<b>KF_FLAG_NO_PACKAGE_REDIRECTION</b> and was deprecated in Windows 10, version 1703.
    KF_FLAG_NO_APPCONTAINER_REDIRECTION      = 0x00010000,
    ///0x00008000. Forces the creation of the specified folder if that folder does not already exist. The security
    ///provisions predefined for that folder are applied. If the folder does not exist and cannot be created, the
    ///function returns a failure code and no path is returned. This value can be used only with the following functions
    ///and methods: <ul> <li> SHGetKnownFolderPath </li> <li> SHGetKnownFolderIDList </li> <li> IKnownFolder::GetIDList
    ///</li> <li> IKnownFolder::GetPath </li> <li> IKnownFolder::GetShellItem </li> </ul>
    KF_FLAG_CREATE                           = 0x00008000,
    ///0x00004000. Do not verify the folder's existence before attempting to retrieve the path or IDList. If this flag
    ///is not set, an attempt is made to verify that the folder is truly present at the path. If that verification fails
    ///due to the folder being absent or inaccessible, the function returns a failure code and no path is returned. If
    ///the folder is located on a network, the function might take a longer time to execute. Setting this flag can
    ///reduce that lag time.
    KF_FLAG_DONT_VERIFY                      = 0x00004000,
    ///0x00002000. Stores the full path in the registry without using environment strings. If this flag is not set,
    ///portions of the path may be represented by environment strings such as %USERPROFILE%. This flag can only be used
    ///with SHSetKnownFolderPath and IKnownFolder::SetPath.
    KF_FLAG_DONT_UNEXPAND                    = 0x00002000,
    ///0x00001000. Gets the true system path for the folder, free of any aliased placeholders such as %USERPROFILE%,
    ///returned by SHGetKnownFolderIDList and IKnownFolder::GetIDList. This flag has no effect on paths returned by
    ///SHGetKnownFolderPath and IKnownFolder::GetPath. By default, known folder retrieval functions and methods return
    ///the aliased path if an alias exists.
    KF_FLAG_NO_ALIAS                         = 0x00001000,
    ///0x00000800. Initializes the folder using its Desktop.ini settings. If the folder cannot be initialized, the
    ///function returns a failure code and no path is returned. This flag should always be combined with KF_FLAG_CREATE.
    ///If the folder is located on a network, the function might take a longer time to execute.
    KF_FLAG_INIT                             = 0x00000800,
    ///0x00000400. Gets the default path for a known folder. If this flag is not set, the function retrieves the
    ///current—and possibly redirected—path of the folder. The execution of this flag includes a verification of the
    ///folder's existence unless KF_FLAG_DONT_VERIFY is set.
    KF_FLAG_DEFAULT_PATH                     = 0x00000400,
    ///0x00000200. Gets the folder's default path independent of the current location of its parent.
    ///KF_FLAG_DEFAULT_PATH must also be set.
    KF_FLAG_NOT_PARENT_RELATIVE              = 0x00000200,
    ///0x00000100. Build a simple IDList (PIDL) This value can be used when you want to retrieve the file system path
    ///but do not specify this value if you are retrieving the localized display name of the folder because it might not
    ///resolve correctly.
    KF_FLAG_SIMPLE_IDLIST                    = 0x00000100,
    ///0x80000000. <b>Introduced in Windows 7</b>. Return only aliased PIDLs. Do not use the file system path.
    KF_FLAG_ALIAS_ONLY                       = 0x80000000,
}

///Specifies which objects are enumerated for autocompletion lists.
alias AUTOCOMPLETELISTOPTIONS = int;
enum : int
{
    ///No enumeration should take place.
    ACLO_NONE             = 0x00000000,
    ///Only the current directory should be enumerated.
    ACLO_CURRENTDIR       = 0x00000001,
    ///Only MyComputer should be enumerated.
    ACLO_MYCOMPUTER       = 0x00000002,
    ///Only the Desktop Folder should be enumerated.
    ACLO_DESKTOP          = 0x00000004,
    ///Only the Favorites Folder should be enumerated.
    ACLO_FAVORITES        = 0x00000008,
    ///Only the file system should be enumerated.
    ACLO_FILESYSONLY      = 0x00000010,
    ///<b>Internet Explorer 6 or greater:</b> The file system dirs, UNC shares, and UNC servers should be enumerated.
    ACLO_FILESYSDIRS      = 0x00000020,
    ACLO_VIRTUALNAMESPACE = 0x00000040,
}

alias FD_FLAGS = int;
enum : int
{
    FD_CLSID      = 0x00000001,
    FD_SIZEPOINT  = 0x00000002,
    FD_ATTRIBUTES = 0x00000004,
    FD_CREATETIME = 0x00000008,
    FD_ACCESSTIME = 0x00000010,
    FD_WRITESTIME = 0x00000020,
    FD_FILESIZE   = 0x00000040,
    FD_PROGRESSUI = 0x00004000,
    FD_LINKUI     = 0x00008000,
    FD_UNICODE    = 0x80000000,
}

///Values used with the DROPDESCRIPTION structure to specify the drop image.
alias DROPIMAGETYPE = int;
enum : int
{
    ///No drop image preference; use the default image.
    DROPIMAGE_INVALID = 0xffffffff,
    ///A red bisected circle such as that found on a "no smoking" sign.
    DROPIMAGE_NONE    = 0x00000000,
    ///A plus sign (+) that indicates a copy operation.
    DROPIMAGE_COPY    = 0x00000001,
    ///An arrow that indicates a move operation.
    DROPIMAGE_MOVE    = 0x00000002,
    ///An arrow that indicates a link.
    DROPIMAGE_LINK    = 0x00000004,
    ///A tag icon that indicates that the metadata will be changed.
    DROPIMAGE_LABEL   = 0x00000006,
    ///A yellow exclamation mark that indicates that a problem has been encountered in the operation.
    DROPIMAGE_WARNING = 0x00000007,
    DROPIMAGE_NOIMAGE = 0x00000008,
}

///Indicates the interpretation of the data passed by SHAddToRecentDocs in its <i>pv</i> parameter to identify the item
///whose usage statistics are being tracked.
alias SHARD = int;
enum : int
{
    ///The <i>pv</i> parameter points to a PIDL that identifies the document's file object. PIDLs that identify non-file
    ///objects are not accepted.
    SHARD_PIDL            = 0x00000001,
    ///The <i>pv</i> parameter points to a null-terminated ANSI string with the path and file name of the object.
    SHARD_PATHA           = 0x00000002,
    ///The <i>pv</i> parameter points to a null-terminated Unicode string with the path and file name of the object.
    SHARD_PATHW           = 0x00000003,
    ///<b>Windows 7 and later</b>. The <i>pv</i> parameter points to a SHARDAPPIDINFO structure that pairs an IShellItem
    ///that identifies the item with an AppUserModelID that associates it with a particular process or application.
    SHARD_APPIDINFO       = 0x00000004,
    ///<b>Windows 7 and later</b>. The <i>pv</i> parameter points to a SHARDAPPIDINFOIDLIST structure that pairs an
    ///absolute PIDL that identifies the item with an AppUserModelID that associates it with a particular process or
    ///application.
    SHARD_APPIDINFOIDLIST = 0x00000005,
    ///<b>Windows 7 and later</b>. The <i>pv</i> parameter is an interface pointer to an IShellLink object.
    SHARD_LINK            = 0x00000006,
    ///<b>Windows 7 and later</b>. The <i>pv</i> parameter points to a SHARDAPPIDINFOLINK structure that pairs an
    ///IShellLink that identifies the item with an AppUserModelID that associates it with a particular process or
    ///application.
    SHARD_APPIDINFOLINK   = 0x00000007,
    ///<b>Windows 7 and later</b>. The <i>pv</i> parameter is an interface pointer to an IShellItem object.
    SHARD_SHELLITEM       = 0x00000008,
}

///Indicates whether to enable or disable Async Register and Deregister for SHChangeNotifyRegisterThread.
alias SCNRT_STATUS = int;
enum : int
{
    ///Enable Async Register and Deregister for SHChangeNotifyRegisterThread.
    SCNRT_ENABLE  = 0x00000000,
    ///Disable Async Register and Deregister for SHChangeNotifyRegisterThread.
    SCNRT_DISABLE = 0x00000001,
}

///These flags are used with the SHRestricted function. <b>SHRestricted</b> is used to determine whether a specified
///administrator policy is in effect. In many cases, applications need to modify certain behaviors in order to comply
///with the policies enacted by system administrators.
alias RESTRICTIONS = int;
enum : int
{
    ///Not used.
    REST_NONE                       = 0x00000000,
    ///If nonzero, the system administrator has forbidden access to the <b>Run</b> command on the <b>Start</b> menu.
    ///Applications should remove similar functionality. For example, a browser with an address bar should deny attempts
    ///by the user to type the path of a local file into the address bar.
    REST_NORUN                      = 0x00000001,
    ///If nonzero, the system administrator has forbidden access to the <b>Shut Down</b> command on the <b>Start</b>
    ///menu. Applications should remove the ability to shut down or restart the computer.
    REST_NOCLOSE                    = 0x00000002,
    ///If nonzero, the system administrator has requested that applications do not save their state at exit for
    ///restoration the next time they are run. Applications should disable saving their window position and settings.
    REST_NOSAVESET                  = 0x00000004,
    ///If nonzero, the system administrator has forbidden access to the Windows Explorer <b>File</b> menu. Applications
    ///should remove similar functionality.
    REST_NOFILEMENU                 = 0x00000008,
    ///If nonzero, the system administrator has forbidden access to <b>Control Panel</b>, <b>Printers</b>, and
    ///<b>Network and Dial up Connections</b>. Applications should prevent users from viewing those folders.
    REST_NOSETFOLDERS               = 0x00000010,
    ///If nonzero, the system administrator has forbidden access to taskbar settings. Applications should prevent users
    ///from changing those settings.
    REST_NOSETTASKBAR               = 0x00000020,
    ///If nonzero, the system administrator has specified that all icons on the desktop should be hidden. Applications
    ///do not need to perform any special actions.
    REST_NODESKTOP                  = 0x00000040,
    ///If nonzero, the system administrator has indicated that the user should not be enabled to search for files.
    ///Applications should remove similar functionality.
    REST_NOFIND                     = 0x00000080,
    ///A 32-bit value that specifies the drives that should not be displayed to the user. Bit 0 corresponds to drive A,
    ///up to bit 25 which corresponds to drive Z. Applications that display a list of drives should remove drives that
    ///have their corresponding bits set.
    REST_NODRIVES                   = 0x00000100,
    ///A 32-bit value that specifies the drives for which AutoRun should be disabled. Bit 0 corresponds to drive A, up
    ///to bit 25 which corresponds to drive Z. Applications should not offer to AutoRun any drive that has its
    ///corresponding bit set.
    REST_NODRIVEAUTORUN             = 0x00000200,
    ///A 32-bit value that specifies the drive types for which AutoRun should be disabled. The bits are numbered
    ///according to the return value of GetDriveType. For example, bit <b>DRIVE_CDROM</b> disables AutoRun on CD-ROM
    ///drives. Applications should not offer to AutoRun any drive whose type has its corresponding bit set.
    REST_NODRIVETYPEAUTORUN         = 0x00000400,
    ///If nonzero, the system administrator has removed <b>Network Neighborhood</b> (also known as <b>My Network
    ///Places</b>) from the Shell namespace. Applications should disable functionality that enables the user to browse
    ///the network.
    REST_NONETHOOD                  = 0x00000800,
    ///Not used.
    REST_STARTBANNER                = 0x00001000,
    ///If nonzero, the system administrator has restricted the programs the user can run. Only programs listed under the
    ///registry key <b>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer</b> can be run
    ///either from the <b>Run</b> dialog box, by double-clicking, or by selecting from the <b>File</b> menu.
    ///Applications should prevent users from running programs not listed under that key. Applications that use the
    ///ShellExecute or ShellExecuteEx functions to run programs do not need to take any special action because those
    ///functions check the policy.
    REST_RESTRICTRUN                = 0x00002000,
    ///Not used.
    REST_NOPRINTERTABS              = 0x00004000,
    ///If nonzero, the system administrator has disabled the user's ability to delete printers. Applications should
    ///remove the ability to delete printers.
    REST_NOPRINTERDELETE            = 0x00008000,
    ///If nonzero, the system administrator has disabled the user's ability to add printers. Applications should remove
    ///the ability to add printers.
    REST_NOPRINTERADD               = 0x00010000,
    ///If nonzero, subfolders of the <b>Start</b> menu and <b>Programs</b> menu are not shown on the top of the classic
    ///<b>Start</b> menu, the <b>Programs</b> list on the classic <b>Start</b> menu, or the <b>All Programs</b> list on
    ///the <b>Start</b> menu. Applications that enumerate the contents of the <b>Start</b> menu should avoid subfolders.
    ///If nonzero, this flag does not restrict any menus other than those listed here; in particular, <b>My Computer</b>
    ///can still expand.
    REST_NOSTARTMENUSUBFOLDERS      = 0x00020000,
    ///Not used.
    REST_MYDOCSONNET                = 0x00040000,
    ///Not used.
    REST_NOEXITTODOS                = 0x00080000,
    ///If nonzero, the system administrator has forbidden the use of unapproved Shell extensions. Applications should
    ///not instantiate Shell extensions unless they are marked as approved by the system administrator. For more
    ///information, see Creating Shell Extension Handlers.
    REST_ENFORCESHELLEXTSECURITY    = 0x00100000,
    ///If nonzero, the system does not attempt to reconnect mapped network drives when resolving a broken shortcut to a
    ///file or folder on a mapped network drive. Applications do not need to perform any special actions.
    REST_LINKRESOLVEIGNORELINKINFO  = 0x00200000,
    ///If nonzero, indicates the system administrator has forbidden access to the <b>CSIDL_COMMON_STARTMENU</b> or
    ///<b>CSIDL_COMMON_PROGRAMS</b> folders on the <b>Start</b> menu. Applications that enumerate the contents of the
    ///<b>Start</b> menu should avoid those folders.
    REST_NOCOMMONGROUPS             = 0x00400000,
    ///If nonzero, the administrator has required that folders be opened in a separate process. This overrides and
    ///disables the corresponding setting in the <b>Folder Options</b> dialog box. Applications do not need to perform
    ///any special actions.
    REST_SEPARATEDESKTOPPROCESS     = 0x00800000,
    ///If nonzero, the system administrator has removed the <b>Web</b> tab from the desktop <b>Properties</b> dialog
    ///box. Applications do not need to perform any special actions. <b>Windows XP and later</b>: Not used.
    REST_NOWEB                      = 0x01000000,
    ///If nonzero, the system administrator has forbidden access to context menus for the taskbar. Applications do not
    ///need to perform any special actions.
    REST_NOTRAYCONTEXTMENU          = 0x02000000,
    ///If nonzero, the system administrator has forbidden access to context menus for Shell objects. Applications should
    ///disable context menus for Shell objects.
    REST_NOVIEWCONTEXTMENU          = 0x04000000,
    ///If nonzero, the system administrator has denied users the ability to map or disconnect network drives.
    ///Applications should remove the ability to map or disconnect network drives.
    REST_NONETCONNECTDISCONNECT     = 0x08000000,
    ///If 1, the system administrator has removed the <b>Log Off</b> option from the <b>Start</b> menu. If 2, the system
    ///administrator has forced the <b>Log Off</b> option to be shown. Applications do not need to perform any special
    ///actions.
    REST_STARTMENULOGOFF            = 0x10000000,
    ///Not used.
    REST_NOSETTINGSASSIST           = 0x20000000,
    ///If nonzero, the system administrator has removed the Internet Explorer icon from the desktop. Applications do not
    ///need to perform any special actions.
    REST_NOINTERNETICON             = 0x40000001,
    ///If nonzero, the system administrator has disabled recent document history. Applications must disable all MRU
    ///lists, such as those that are often displayed on the <b>File</b> menu. Adherence to this setting is mandatory for
    ///Windows logo compliance.
    REST_NORECENTDOCSHISTORY        = 0x40000002,
    ///If nonzero, the system administrator has removed the <b>Recent Documents</b> menu from the <b>Start</b> menu.
    ///Applications do not need to perform any special actions.
    REST_NORECENTDOCSMENU           = 0x40000003,
    ///If nonzero, the system administrator has disabled the ability to create web content on the desktop. Applications
    ///do not need to perform any special actions. <b>Windows Vista or later</b>: Not used.
    REST_NOACTIVEDESKTOP            = 0x40000004,
    ///If nonzero, the system administrator has disabled the ability to change web content on the desktop. Applications
    ///do not need to perform any special actions. <b>Windows Vista or later</b>: Not used.
    REST_NOACTIVEDESKTOPCHANGES     = 0x40000005,
    ///If nonzero, the system administrator has removed the <b>Favorites</b> menu from the <b>Start</b> menu.
    ///Applications do not need to perform any special actions.
    REST_NOFAVORITESMENU            = 0x40000006,
    ///If nonzero, the system administrator has required that recent document history and related history information be
    ///deleted when the user logs off. Applications should erase recent document history when they exit.
    REST_CLEARRECENTDOCSONEXIT      = 0x40000007,
    ///Not used.
    REST_CLASSICSHELL               = 0x40000008,
    ///If nonzero, the system administrator has disabled the ability to customize the appearance of Windows Explorer
    ///folders. Applications do not need to perform any special actions.
    REST_NOCUSTOMIZEWEBVIEW         = 0x40000009,
    ///If nonzero, the system administrator has disabled the ability to set the wallpaper to any image that is not a
    ///bitmap (*.bmp) image. Applications that enable the user to change desktop wallpaper should disable web content.
    ///<b>Windows Vista or later</b>: Not used.
    REST_NOHTMLWALLPAPER            = 0x40000010,
    ///If nonzero, the system administrator has disabled the ability to change the desktop wallpaper. Applications
    ///should disable corresponding functionality.
    REST_NOCHANGINGWALLPAPER        = 0x40000011,
    ///If nonzero, the system administrator has disabled desktop components. Applications that create or modify desktop
    ///components should disable this functionality. <b>Windows Vista or later</b>: Not used.
    REST_NODESKCOMP                 = 0x40000012,
    ///If nonzero, the system administrator has disabled the ability to create desktop components. Applications that
    ///create desktop components should disable this functionality.
    REST_NOADDDESKCOMP              = 0x40000013,
    ///If nonzero, the system administrator has disabled the ability to delete desktop components. Applications that
    ///delete desktop components should disable this functionality. <b>Windows Vista or later</b>: Not used.
    REST_NODELDESKCOMP              = 0x40000014,
    ///If nonzero, the system administrator has disabled the ability to close desktop components. Applications do not
    ///need to perform any special actions. <b>Windows Vista or later</b>: Not used.
    REST_NOCLOSEDESKCOMP            = 0x40000015,
    ///If nonzero, the system administrator has disabled the ability to drag, drop, or close desktop bands. Applications
    ///do not need to perform any special actions.
    REST_NOCLOSE_DRAGDROPBAND       = 0x40000016,
    ///If nonzero, the system administrator has disabled the ability to move a desktop band. Applications do not need to
    ///perform any special actions.
    REST_NOMOVINGBAND               = 0x40000017,
    ///If nonzero, indicates the system administrator has disabled the ability to modify desktop components.
    ///Applications that modify desktop components should disable this functionality. <b>Windows Vista or later</b>: Not
    ///used.
    REST_NOEDITDESKCOMP             = 0x40000018,
    ///If nonzero, the system administrator has disabled heuristic file searching when resolving broken shortcuts.
    ///Applications do not need to perform any special actions.
    REST_NORESOLVESEARCH            = 0x40000019,
    ///If nonzero, the system administrator has disabled the use of the link tracking service when resolving broken
    ///shortcuts. Applications do not need to perform any special actions.
    REST_NORESOLVETRACK             = 0x4000001a,
    ///If nonzero, the system administrator has forced Shell file copy operations to copy the ACL with the file rather
    ///than inheriting the ACL from the target folder. Applications that use the SHFileOperation function do not need to
    ///perform any special actions. Applications that copy files manually should ensure that the source ACL is copied.
    REST_FORCECOPYACLWITHFILE       = 0x4000001b,
    ///If nonzero, the system administrator has disabled the ability to uncheck the <b>Remind me until I update the
    ///current version</b> checkbox in the SoftwareUpdateMessageBox function. Applications do not need to perform any
    ///special actions.
    REST_NOFORGETSOFTWAREUPDATE     = 0x4000001d,
    ///If nonzero, the system administrator has disabled the ability to change settings for web content on the desktop.
    ///Applications do not need to perform any special actions. <b>Windows Vista or later</b>: Not used.
    REST_NOSETACTIVEDESKTOP         = 0x4000001e,
    ///If nonzero, the system administrator has hidden the <b>Windows Update</b> shortcut on the <b>Start</b> menu.
    ///Applications that enumerate the contents of the <b>Start</b> menu should not show the <b>Windows Update</b>
    ///shortcut to the user.
    REST_NOUPDATEWINDOWS            = 0x4000001f,
    ///If nonzero, the system administrator has disabled the ability to make changes to the <b>Start</b> menu.
    ///Applications should disable any feature that enables the user to reorganize their <b>Start</b> menu.
    REST_NOCHANGESTARMENU           = 0x40000020,
    ///If nonzero, the system administrator has denied access to the <b>Folder Options</b> dialog box. Applications that
    ///display <b>Folder Options</b> in <b>Control Panel</b> should disable this functionality.
    REST_NOFOLDEROPTIONS            = 0x40000021,
    ///If nonzero, the system administrator has disabled the ability to search for computers on the network.
    ///Applications should remove the ability to search for computers on the network.
    REST_HASFINDCOMPUTERS           = 0x40000022,
    ///If nonzero, the system administrator has disabled personalized menus. Applications should not hide
    ///infrequently-used menu commands.
    REST_INTELLIMENUS               = 0x40000023,
    ///If nonzero, the system administrator has disabled the <b>Run in separate memory space</b> option in the
    ///<b>Run</b> dialog. Applications that provide similar functionality should remove the corresponding checkbox.
    REST_RUNDLGMEMCHECKBOX          = 0x40000024,
    ///If nonzero, the system administrator has removed the list of incomplete setup operations from the "Add/Remove
    ///Windows Components" section of the <b>Add/Remove Programs</b> dialog box. Applications do not need to perform any
    ///special actions. <b>Windows Vista or later</b>: Not used.
    REST_ARP_ShowPostSetup          = 0x40000025,
    ///If nonzero, the system administrator has removed <b>Synchronize All</b> from the <b>Start</b> menu. Applications
    ///do not need to perform any special actions.
    REST_NOCSC                      = 0x40000026,
    ///If nonzero, the system administrator has denied access to <b>Control Panel</b>. Applications should disable any
    ///functionality that runs <code>Control Panel</code>.
    REST_NOCONTROLPANEL             = 0x40000027,
    ///If nonzero, the system administrator has indicated that the <b>Network Neighborhood</b> should include the
    ///computer workgroup. Applications do not need to perform any special actions. <b>Windows Vista or later</b>: Not
    ///used.
    REST_ENUMWORKGROUP              = 0x40000028,
    ///If nonzero, the system administrator has denied access to the <b>Add/Remove Programs</b> dialog box. Applications
    ///should disable any functionality that runs the <b>Add/Remove Programs</b> dialog box. <b>Windows Vista or
    ///later</b>: Not used.
    REST_ARP_NOARP                  = 0x40000029,
    ///If nonzero, the system administrator has denied access to the <b>Change or Remove Programs</b> section of the
    ///<b>Add/Remove Programs</b> dialog box. Applications do not need to perform any special actions. <b>Windows Vista
    ///or later</b>: Not used.
    REST_ARP_NOREMOVEPAGE           = 0x4000002a,
    ///If nonzero, the system administrator has denied access to the <b>Add Programs</b> section of the <b>Add/Remove
    ///Programs</b> dialog box. Applications do not need to perform any special actions. <b>Windows Vista or later</b>:
    ///Not used.
    REST_ARP_NOADDPAGE              = 0x4000002b,
    ///If nonzero, the system administrator has denied access to the <b>Add/Remove Windows Components</b> section of the
    ///<b>Add/Remove Programs</b> dialog box. Applications do not need to perform any special actions. <b>Windows Vista
    ///or later</b>: Not used.
    REST_ARP_NOWINSETUPPAGE         = 0x4000002c,
    ///If nonzero, the system administrator has specified that Windows Installer shortcuts that refer to applications
    ///that are available but not yet installed should be displayed on the <b>Start</b> menu in gray. Applications do
    ///not need to perform any special actions.
    REST_GREYMSIADS                 = 0x4000002d,
    ///Not used.
    REST_NOCHANGEMAPPEDDRIVELABEL   = 0x4000002e,
    ///Not used.
    REST_NOCHANGEMAPPEDDRIVECOMMENT = 0x4000002f,
    ///A 32-bit value that specifies the maximum number of documents to be retained in the <b>Recent Documents</b> menu.
    ///If this value is zero, then the system administrator has not specified any maximum, and applications can choose a
    ///default. If this value is nonzero, applications should restrict their <b>Recent Documents</b> list to the
    ///specified number of items.
    REST_MaxRecentDocs              = 0x40000030,
    ///If nonzero, the system administrator has removed the <b>Network Connections</b> menu from the <b>Start</b> menu.
    ///Applications should hide lists of network and dial-up connections.
    REST_NONETWORKCONNECTIONS       = 0x40000031,
    ///If nonzero, the system administrator has forced the <b>Log Off</b> command onto the <b>Start</b> menu.
    ///Applications do not need to perform any special actions.
    REST_FORCESTARTMENULOGOFF       = 0x40000032,
    ///If nonzero, the system administrator has disabled folder HTML templates (Windows 2000) or folder tasks (Windows
    ///XP) in Windows Explorer. Applications do not need to perform any special actions. <b>Windows Vista or later</b>:
    ///Not used.
    REST_NOWEBVIEW                  = 0x40000033,
    ///If nonzero, the system administrator has disabled the ability to customize the appearance of Windows Explorer
    ///folders. Applications do not need to perform any special actions.
    REST_NOCUSTOMIZETHISFOLDER      = 0x40000034,
    ///If nonzero, the system administrator has disabled the ability to encrypt and decrypt files and folders.
    ///Applications should not call EncryptFile or DecryptFile.
    REST_NOENCRYPTION               = 0x40000035,
    ///If nonzero, the system administrator has disabled the ability to view files marked System and Hidden
    ///("super-hidden files"), overriding the <b>fShowSuperHidden</b> member of the SHELLSTATE structure. Applications
    ///should not show files that have both the FILE_ATTRIBUTE_SYSTEM and FILE_ATTRIBUTE_HIDDEN attributes to the user.
    REST_DONTSHOWSUPERHIDDEN        = 0x40000037,
    ///If nonzero, the system administrator has disabled the <b>Search</b> button in the Windows Explorer toolbar.
    ///Applications do not need to perform any special actions.
    REST_NOSHELLSEARCHBUTTON        = 0x40000038,
    ///If nonzero, the system administrator has disabled the <b>Hardware</b> tab in the <b>Drive</b>, <b>Mouse</b>,
    ///<b>Keyboard</b>, and <b>Multimedia</b> property sheets. Applications do not need to perform any special actions.
    REST_NOHARDWARETAB              = 0x40000039,
    ///If nonzero, the system administrator has disabled the automatic prompt for automatic credentials when installing
    ///an application. Applications do not need to perform any special actions. <b>Windows Vista or later</b>: Not used.
    REST_NORUNASINSTALLPROMPT       = 0x4000003a,
    ///If nonzero, the system administrator has disabled the automatic prompt for automatic credentials when installing
    ///an application from a network path. Applications do not need to perform any special actions. <b>Windows Vista or
    ///later</b>: Not used.
    REST_PROMPTRUNASINSTALLNETPATH  = 0x4000003b,
    ///If nonzero, the system administrator has removed the <b>Manage</b> command from the <b>My Computer</b> context
    ///menu. Applications do not need to perform any special actions.
    REST_NOMANAGEMYCOMPUTERVERB     = 0x4000003c,
    ///If nonzero, the system administrator has restricted the programs the user can run. Programs listed under the
    ///registry key <b>HKEY_CURRENT_USER</b>&
    REST_DISALLOWRUN                = 0x4000003e,
    ///If nonzero, the system administrator has disabled the <b>Welcome to Windows</b> program that is run when a user
    ///logs on. Applications do not need to perform any special actions. <b>Windows Vista or later</b>: Not used.
    REST_NOWELCOMESCREEN            = 0x4000003f,
    ///If nonzero, the system administrator has restricted the control panel applications the user can run. In order to
    ///be run, a control panel application must be listed under the registry key <b>HKEY_CURRENT_USER</b>&
    REST_RESTRICTCPL                = 0x40000040,
    ///If nonzero, the system administrator has restricted the control panel applications the user can run. In order to
    ///be run, a control panel application must not be listed under the registry key <b>HKEY_CURRENT_USER</b>&
    REST_DISALLOWCPL                = 0x40000041,
    ///If nonzero, the system administrator has disabled balloon tips that are displayed by the <b>Start</b> menu.
    ///Applications do not need to perform any special actions.
    REST_NOSMBALLOONTIP             = 0x40000042,
    ///If nonzero, the system administrator has removed the <b>Help</b> option from the <b>Start</b> menu. Applications
    ///do not need to perform any special actions.
    REST_NOSMHELP                   = 0x40000043,
    ///If nonzero, the system administrator has disabled the keyboard shortcut associated with the Windows logo key.
    ///Applications do not need to perform any special actions.
    REST_NOWINKEYS                  = 0x40000044,
    ///If nonzero, the system administrator has specified that unencrypted files and folders moved into an encrypted
    ///folder should remain unencrypted instead of inheriting the encryption attribute from the enclosing folder.
    ///Applications that move files and folders should unencrypt them if they were originally unencrypted and are moved
    ///into an encrypted folder. Applications that use the SHFileOperation function to move files do not need to perform
    ///any special actions because the <b>SHFileOperation</b> function respects this policy.
    REST_NOENCRYPTONMOVE            = 0x40000045,
    ///If nonzero, the system administrator has disabled the execution of programs listed in the
    ///<b>HKEY_LOCAL_MACHINE</b>&
    REST_NOLOCALMACHINERUN          = 0x40000046,
    ///If nonzero, the system administrator has disabled the execution of programs listed in the
    ///<b>HKEY_CURRENT_USER</b>&
    REST_NOCURRENTUSERRUN           = 0x40000047,
    ///If nonzero, the system administrator has disabled the execution of programs listed in the
    ///<b>HKEY_LOCAL_MACHINE</b>&
    REST_NOLOCALMACHINERUNONCE      = 0x40000048,
    ///If nonzero, the system administrator has disabled the execution of programs listed in the
    ///<b>HKEY_CURRENT_USER</b>&
    REST_NOCURRENTUSERRUNONCE       = 0x40000049,
    ///If nonzero, the system administrator has forced web content to be enabled on the desktop. Applications do not
    ///need to perform any special actions. <b>Windows Vista or later</b>: Not used.
    REST_FORCEACTIVEDESKTOPON       = 0x4000004a,
    ///A 32-bit value that specifies the drives the user cannot open or drop files into. Bit 0 corresponds to drive A,
    ///up to bit 25 which corresponds to drive Z. Applications that enable the user to open folders or drop files should
    ///prevent the user from opening a folder on a restricted drive or dropping files onto a restricted drive.
    REST_NOVIEWONDRIVE              = 0x4000004c,
    ///Windows XP, Windows<b>2003, or IE_BACKCOMPAT_VERSION defined.</b> If nonzero, the system administrator has
    ///disabled automatic searching for network folders and printers, overriding the <i>fNoNetCrawling</i> member of the
    ///<b>SHELLSTATE</b> structure. Applications do not need to perform any special actions. <b>Windows Vista or
    ///later</b>: Not used.
    REST_NONETCRAWL                 = 0x4000004d,
    ///Windows XP, Windows<b>2003 or IE_BACKCOMPAT_VERSION defined.</b> If nonzero, the system administrator has hidden
    ///the <b>Shared Documents</b> icon in <b>My Computer</b>. Applications should hide access to
    ///CSIDL_COMMON_DOCUMENTS. <b>Windows Vista or later</b>: Not used.
    REST_NOSHAREDDOCUMENTS          = 0x4000004e,
    ///If nonzero, the system administrator has hidden the <b>My Documents</b> icon on the <b>Start</b> menu.
    ///Applications do not need to perform any special actions.
    REST_NOSMMYDOCS                 = 0x4000004f,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has hidden the <b>My Pictures</b> icon on the
    ///<b>Start</b> menu. Applications do not need to perform any special actions.
    REST_NOSMMYPICS                 = 0x40000050,
    ///<b>Windows XP or later.</b> A 32-bit value that specifies the drives for which the <b>Recycle Bin</b> should be
    ///forced to be enabled. The system typically disables the <b>Recycle Bin</b> on drives that are not local fixed
    ///drives. Bit 0 corresponds to drive A, up to bit 25 which corresponds to drive Z. Applications do not need to
    ///perform any special actions.
    REST_ALLOWBITBUCKDRIVES         = 0x40000051,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has hidden the <b>Back</b> and <b>Forward</b>
    ///buttons in the Internet Explorer toolbar. Applications do not need to perform any special actions. <b>Windows
    ///Vista or later</b>: Not used.
    REST_NONLEGACYSHELLMODE         = 0x40000052,
    ///<b>Windows XP or later.</b> Ignored.
    REST_NOCONTROLPANELBARRICADE    = 0x40000053,
    ///<b>Windows XP or later.</b> Ignored.
    REST_NOSTARTPAGE                = 0x40000054,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has forced all taskbar icons to be visible, even
    ///if they are inactive, overriding the user's decision to hide inactive taskbar icons. Applications do not need to
    ///perform any special actions.
    REST_NOAUTOTRAYNOTIFY           = 0x40000055,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled grouping of similar taskbar
    ///buttons, overriding the user's decision to enable taskbar button grouping. Applications do not need to perform
    ///any special actions.
    REST_NOTASKGROUPING             = 0x40000056,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled CD burning. Applications should
    ///disable any CD-burning capabilities.
    REST_NOCDBURNING                = 0x40000057,
    ///<b> Windows 2000 SP3 or later.</b> If nonzero, the system administrator has disabled the <b>System Properties</b>
    ///dialog box. Applications should not launch the <b>System Properties</b> dialog box.
    REST_MYCOMPNOPROP               = 0x40000058,
    ///<b> Windows 2000 SP3 or later.</b> If nonzero, the system administrator has disabled the ability to view
    ///properties of the <b>My Documents</b> folder. Applications should not redirect the <b>My Documents</b> folder.
    REST_MYDOCSNOPROP               = 0x40000059,
    ///<b> Windows XP or later.</b> If nonzero, the system administrator has disabled the Windows XP <b>Start</b> menu.
    ///Applications do not need to perform any special actions.
    REST_NOSTARTPANEL               = 0x4000005a,
    ///<b>Windows XP or later.</b> If 1, the system administrator has disabled the <b>Themes</b> and <b>Appearance</b>
    ///pages from the <b>Desktop Properties</b> dialog box. Applications should not change system colors and appearance.
    REST_NODISPLAYAPPEARANCEPAGE    = 0x4000005b,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled the <b>Themes</b> page from the
    ///<b>Desktop Properties</b> dialog. Applications should not change visual styles.
    REST_NOTHEMESTAB                = 0x4000005c,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled the ability to change visual
    ///styles. Applications should not change visual styles.
    REST_NOVISUALSTYLECHOICE        = 0x4000005d,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled the ability to change font sizes
    ///from the <b>Appearance</b> page on the Desktop Properties dialog box. Applications should not change system
    ///metrics.
    REST_NOSIZECHOICE               = 0x4000005e,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled the ability to change system colors
    ///from the <b>Appearance</b> page on the <b>Desktop Properties</b> dialog box. Applications should not change
    ///system colors.
    REST_NOCOLORCHOICE              = 0x4000005f,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has forced a specific visual style. Applications
    ///should not change visual styles.
    REST_SETVISUALSTYLE             = 0x40000060,
    ///<b> Windows 2000 SP3 or later.</b> If nonzero, the default working directory for programs run from the Run dialog
    ///is not forced to the user's home directory. Applications do not need to perform any special actions.
    REST_STARTRUNNOHOMEPATH         = 0x40000061,
    ///Windows XP, Windows <b>2003.</b> If nonzero, the system administrator has hidden the user name on the Windows XP
    ///<b>Start</b> menu. Applications do not need to perform any special actions. <b>Windows Vista or later</b>: Not
    ///used.
    REST_NOUSERNAMEINSTARTPANEL     = 0x40000062,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has hidden the <b>My Computer</b> icon.
    ///Applications should not permit access to the <b>My Computer</b> icon.
    REST_NOMYCOMPUTERICON           = 0x40000063,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has hidden the <b>Network Places</b> icon on the
    ///<b>Start</b> menu. Applications do not need to perform any special actions.
    REST_NOSMNETWORKPLACES          = 0x40000064,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has hidden the list of "pinned" items on the
    ///<b>Start</b> menu. Applications do not need to perform any special actions.
    REST_NOSMPINNEDLIST             = 0x40000065,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has hidden the <b>My Music</b> icon on the
    ///<b>Start</b> menu. Applications do not need to perform any special actions.
    REST_NOSMMYMUSIC                = 0x40000066,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has hidden the <b>Eject</b> command on the
    ///<b>Start</b> menu. Applications should not enable the user to eject the computer.
    REST_NOSMEJECTPC                = 0x40000067,
    ///<b> Windows XP or later.</b> If nonzero, the system administrator has hidden the <b>All Programs</b> item on the
    ///Windows XP <b>Start</b> menu. Applications should not show the contents of the <b>Start</b> menu folder to the
    ///user.
    REST_NOSMMOREPROGRAMS           = 0x40000068,
    ///<b> Windows XP or later.</b> If nonzero, the system administrator has hidden the list of most frequently used
    ///programs on the Windows XP <b>Start</b> menu. Applications do not need to perform any special actions.
    REST_NOSMMFUPROGRAMS            = 0x40000069,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has hidden all taskbar notification icons,
    ///regardless of activity. Applications do not need to perform any special actions.
    REST_NOTRAYITEMSDISPLAY         = 0x4000006a,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has hidden all taskbar toolbars, such as
    ///<b>Quick Launch</b>. Applications do not need to perform any special actions.
    REST_NOTOOLBARSONTASKBAR        = 0x4000006b,
    ///<b> Windows 2000 SP3 or later.</b> If nonzero, the system administrator has hidden the <b>Set Program Access</b>
    ///and <b>Defaults</b> shortcut on the <b>Start</b> menu. Applications that enumerate the contents of the
    ///<b>Start</b> menu should not show the <b>Set Program Access</b> and <b>Defaults</b> shortcut to the user.
    REST_NOSMCONFIGUREPROGRAMS      = 0x4000006f,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has hidden the clock on the taskbar, overriding
    ///any user preference. Applications do not need to perform any special actions.
    REST_HIDECLOCK                  = 0x40000070,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled taskbar warnings when disk space
    ///has become low. Applications do not need to perform any special actions.
    REST_NOLOWDISKSPACECHECKS       = 0x40000071,
    ///<b>Windows 2000 Service Pack 4 (SP4) or later.</b> If nonzero, the system administrator has disabled the
    ///<b>Entire Network</b> icon in <b>Network Places</b>. Applications should remove the ability to browse domain
    ///resources.
    REST_NOENTIRENETWORK            = 0x40000072,
    ///Windows XP, Windows<b>2003.</b> If nonzero, the system administrator has disabled the desktop cleaner.
    ///Applications do not need to perform any special actions. <b>Windows Vista or later</b>: Not used.
    REST_NODESKTOPCLEANUP           = 0x40000073,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has required that deleted files be removed
    ///immediately instead of being placed in the <b>Recycle Bin</b>, overriding any user preference. Applications do
    ///not need to perform any special actions.
    REST_BITBUCKNUKEONDELETE        = 0x40000074,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled the user's ability to specify
    ///whether confirmation dialogs should be displayed when files are moved to the <b>Recycle Bin</b>. Applications do
    ///not need to perform any special actions.
    REST_BITBUCKCONFIRMDELETE       = 0x40000075,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled the user's ability to view or
    ///modify <b>Recycle Bin</b> properties. Applications do not need to perform any special actions.
    REST_BITBUCKNOPROP              = 0x40000076,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled the user's ability to view or
    ///modify the desktop wallpaper. Applications should remove the ability to change the desktop wallpaper.
    REST_NODISPBACKGROUND           = 0x40000077,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled the user's ability to view or
    ///modify screensaver settings. Applications should remove the ability to change the screensaver or screensaver
    ///settings.
    REST_NODISPSCREENSAVEPG         = 0x40000078,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled the user's ability to view or
    ///modify screen color depth and resolution settings. Applications should remove the ability to change display color
    ///depth and resolution.
    REST_NODISPSETTINGSPG           = 0x40000079,
    ///<b>Windows XP or later.</b> Ignored.
    REST_NODISPSCREENSAVEPREVIEW    = 0x4000007a,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled the <b>Display Properties</b>
    ///dialog box in <b>Control Panel</b>. Applications should remove the ability to change system colors, metrics,
    ///visual styles, font size, desktop wallpaper, screensaver, screensaver settings, screen color depth, or display
    ///resolution.
    REST_NODISPLAYCPL               = 0x4000007b,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled the "Run As" command for Shell
    ///objects. Applications should remove corresponding functionality.
    REST_HIDERUNASVERB              = 0x4000007c,
    ///<b>Windows XP or later.</b> If nonzero, the system administrator has disabled caching of thumbnails. Applications
    ///do not need to perform any special actions.
    REST_NOTHUMBNAILCACHE           = 0x4000007d,
    ///<b> Windows XP SP1 or later, or IE_BACKCOMPAT_VERSION defined.</b> If nonzero, the system administrator has
    ///specified that filenames should be sorted with the <b>StringCompare</b> function instead of the
    ///<b>StrCmpLogical</b> function. Applications that sort filenames should sort accordingly. (This policy does not
    ///apply to Windows 2000.)
    REST_NOSTRCMPLOGICAL            = 0x4000007e,
    ///<b> Windows XP SP1 or later service pack, Windows Server 2003 or IE_BACKCOMPAT_VERSION defined.</b> Disables the
    ///Windows Publishing Wizard (WPW).<b>Windows Vista or later</b>: Not used.
    REST_NOPUBLISHWIZARD            = 0x4000007f,
    ///<b> Windows XP SP1 or later, or IE_BACKCOMPAT_VERSION defined.</b> Disables the Online Prints Wizard (OPW).
    ///<b>Windows Vista or later</b>: Not used.
    REST_NOONLINEPRINTSWIZARD       = 0x40000080,
    ///<b> Windows XP SP1 or later, or IE_BACKCOMPAT_VERSION defined.</b> Disables the web specified services for both
    ///the Online Prints Wizard (OPW) and the Windows Publishing Wizard (WPW).
    REST_NOWEBSERVICES              = 0x40000081,
    ///<b> Windows 2000 SP3 or later, Windows XP, or Windows Server 2003.</b> If nonzero, the system administrator has
    ///granted permission for unregistered web view templates to be displayed. Applications do not need to perform any
    ///special actions. <b>Windows Vista or later</b>: Not used.
    REST_ALLOWUNHASHEDWEBVIEW       = 0x40000082,
    ///If nonzero, the system administrator has granted permission for old web view templates (created prior to Windows
    ///XP) to be converted to Windows XP templates. Applications do not need to perform any special actions. <b>Windows
    ///Vista or later</b>: Not used.
    REST_ALLOWLEGACYWEBVIEW         = 0x40000083,
    ///<b> Windows 2000 SP3 or later, Windows XP, or Windows Server 2003.</b> If nonzero, the system administrator has
    ///reduced web view security to the level that existed in Windows 2000 SP2 or earlier. Applications do not need to
    ///perform any special actions. (This policy does not apply to Windows 2000 SP2 or earlier.) <b>Windows Vista or
    ///later</b>: Not used.
    REST_REVERTWEBVIEWSECURITY      = 0x40000084,
    ///<b>Windows 2000 Service Pack 4 (SP4) or later.</b> If nonzero, the ShellExec function checks if the current
    ///process and target process are console processes that can inherit handles.
    REST_INHERITCONSOLEHANDLES      = 0x40000086,
    ///<b> Windows XP SP2 or later.</b> Do not register network change events recursively. This helps to avoid network
    ///traffic.
    REST_NOREMOTERECURSIVEEVENTS    = 0x40000089,
    ///<b> Windows XP SP2 or later.</b> Do not notify for remote change notifications.
    REST_NOREMOTECHANGENOTIFY       = 0x40000091,
    ///<b> Windows XP SP2 or later.</b> Do not enumerate the entire network.
    REST_NOENUMENTIRENETWORK        = 0x40000093,
    ///<b> Windows XP SP2 or later.</b> If nonzero, the system administrator has removed the ability to resolve file
    ///associations using the Internet. The option <b>Use the web service to find the appropriate program</b> is
    ///unavailable in the dialog displayed when the user selects <b>Open With</b> or double-clicks an unassociated file
    ///type.
    REST_NOINTERNETOPENWITH         = 0x40000095,
    ///<b> Windows XP SP2 or later.</b> In <b>Network Places</b>, if the provider returns ERROR_BAD_NET_NAME, do not
    ///retry.
    REST_DONTRETRYBADNETNAME        = 0x4000009b,
    ///<b> Windows XP SP2 or later, Windows Server 2003.</b> Re-enable legacy support for file.{guid} junctions in file
    ///system folders.
    REST_ALLOWFILECLSIDJUNCTIONS    = 0x4000009c,
    ///<b> Windows XP SP2 or later.</b> Disable the <b>Install Universal Plug and Play (UPnP)</b> task in <b>My Network
    ///Places</b>.
    REST_NOUPNPINSTALL              = 0x4000009d,
    ///If nonzero, the system administrator has removed the option to list individual patches in Add/Remove Programs.
    ///<b>Windows Vista or later</b>: Not used.
    REST_ARP_DONTGROUPPATCHES       = 0x400000ac,
    ///If nonzero, the system administrator has removed the option to choose the programs page. <b>Windows Vista or
    ///later</b>: Not used.
    REST_ARP_NOCHOOSEPROGRAMSPAGE   = 0x400000ad,
    ///<b>Not supported under Windows Vista or later</b>. If nonzero, the system administrator has removed the
    ///<b>Disconnect</b> option from the <b>Start</b> menu and <b>Task Manager</b>. Applications should remove the
    ///ability to disconnect users from a Terminal Server session.
    REST_NODISCONNECT               = 0x41000001,
    ///<b>Not supported under Windows Vista and later</b>. If nonzero, the system administrator has removed the
    ///<b>Windows Security</b> option from the <b>Start</b> menu and <b>Task Manager</b>. Applications do not need to
    ///perform any special actions.
    REST_NOSECURITY                 = 0x41000002,
    ///<b>Not supported under Windows Vista and later</b>. If nonzero, the system administrator has removed the ability
    ///to change file associations. Applications should not enable users to change file associations arbitrarily.
    REST_NOFILEASSOCIATE            = 0x41000003,
    ///<b> Windows XP SP2 only. Not supported under Windows Vista or later.</b> Allows the user to toggle the position
    ///of the Comment and the Computer Name.
    REST_ALLOWCOMMENTTOGGLE         = 0x41000004,
}

alias tagOPEN_AS_INFO_FLAGS = int;
enum : int
{
    OAIF_ALLOW_REGISTRATION = 0x00000001,
    OAIF_REGISTER_EXT       = 0x00000002,
    OAIF_EXEC               = 0x00000004,
    OAIF_FORCE_REGISTRATION = 0x00000008,
    OAIF_HIDE_REGISTRATION  = 0x00000020,
    OAIF_URL_PROTOCOL       = 0x00000040,
    OAIF_FILE_IS_URI        = 0x00000080,
}

///Specifies how a shortcut should be handled by the browser.
alias IESHORTCUTFLAGS = int;
enum : int
{
    ///A new browser window should be opened for each shortcut.
    IESHORTCUT_NEWBROWSER    = 0x00000001,
    ///The current or topmost browser window should open the link in a new foreground tab.
    IESHORTCUT_OPENNEWTAB    = 0x00000002,
    ///The current or topmost browser window should open the link.
    IESHORTCUT_FORCENAVIGATE = 0x00000004,
    IESHORTCUT_BACKGROUNDTAB = 0x00000008,
}

///Indicates whether the device is a primary or immersive type of display. <div class="alert"><b>Note</b> The functions
///that use these enumeration values are no longer supported as of Windows 8.1.</div><div> </div>
alias DISPLAY_DEVICE_TYPE = int;
enum : int
{
    ///The device is a primary display device.
    DEVICE_PRIMARY   = 0x00000000,
    ///The device is an immersive display device.
    DEVICE_IMMERSIVE = 0x00000001,
}

///Flags that are used to indicate the scaling change that occurred.
alias SCALE_CHANGE_FLAGS = int;
enum : int
{
    ///No change.
    SCF_VALUE_NONE = 0x00000000,
    ///The scale factor has changed.
    SCF_SCALE      = 0x00000001,
    SCF_PHYSICAL   = 0x00000002,
}

///<p class="CCE_Message">[Some information relates to pre-released product which may be substantially modified before
///it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information
///provided here.] Identifies the type of UI component that is needed in the shell.
alias SHELL_UI_COMPONENT = int;
enum : int
{
    ///This UI component is a taskbar icon.
    SHELL_UI_COMPONENT_TASKBARS         = 0x00000000,
    ///This UI component is an icon in the notification area.
    SHELL_UI_COMPONENT_NOTIFICATIONAREA = 0x00000001,
    SHELL_UI_COMPONENT_DESKBAND         = 0x00000002,
}

///Specifies how the StrFormatByteSizeEx function should handle rounding of undisplayed digits.
alias tagSFBS_FLAGS = int;
enum : int
{
    ///Round to the nearest displayed digit.
    SFBS_FLAGS_ROUND_TO_NEAREST_DISPLAYED_DIGIT    = 0x00000001,
    SFBS_FLAGS_TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS = 0x00000002,
}

///Used to specify URL schemes.
alias URL_SCHEME = int;
enum : int
{
    ///An invalid scheme.
    URL_SCHEME_INVALID       = 0xffffffff,
    ///An unknown scheme.
    URL_SCHEME_UNKNOWN       = 0x00000000,
    ///FTP (ftp:).
    URL_SCHEME_FTP           = 0x00000001,
    ///HTTP (http:).
    URL_SCHEME_HTTP          = 0x00000002,
    ///Gopher (gopher:).
    URL_SCHEME_GOPHER        = 0x00000003,
    ///Mail-to (mailto:).
    URL_SCHEME_MAILTO        = 0x00000004,
    ///Usenet news (news:).
    URL_SCHEME_NEWS          = 0x00000005,
    ///Usenet news with NNTP (nntp:).
    URL_SCHEME_NNTP          = 0x00000006,
    ///Telnet (telnet:).
    URL_SCHEME_TELNET        = 0x00000007,
    ///Wide Area Information Server (wais:).
    URL_SCHEME_WAIS          = 0x00000008,
    ///File (file:).
    URL_SCHEME_FILE          = 0x00000009,
    ///URL moniker (mk:).
    URL_SCHEME_MK            = 0x0000000a,
    ///URL HTTPS (https:).
    URL_SCHEME_HTTPS         = 0x0000000b,
    ///Shell (shell:).
    URL_SCHEME_SHELL         = 0x0000000c,
    ///NNTP news postings with SSL (snews:).
    URL_SCHEME_SNEWS         = 0x0000000d,
    ///Local (local:).
    URL_SCHEME_LOCAL         = 0x0000000e,
    ///JavaScript (javascript:).
    URL_SCHEME_JAVASCRIPT    = 0x0000000f,
    ///VBScript (vbscript:).
    URL_SCHEME_VBSCRIPT      = 0x00000010,
    ///About (about:).
    URL_SCHEME_ABOUT         = 0x00000011,
    ///Res (res:).
    URL_SCHEME_RES           = 0x00000012,
    ///Internet Explorer 6 and later only. Shell-rooted (ms-shell-rooted:)
    URL_SCHEME_MSSHELLROOTED = 0x00000013,
    ///Internet Explorer 6 and later only. Shell ID-list (ms-shell-idlist:).
    URL_SCHEME_MSSHELLIDLIST = 0x00000014,
    ///Internet Explorer 6 and later only. MSHelp (hcp:).
    URL_SCHEME_MSHELP        = 0x00000015,
    ///Not supported.
    URL_SCHEME_MSSHELLDEVICE = 0x00000016,
    ///Internet Explorer 7 and later only. Wildcard (*:).
    URL_SCHEME_WILDCARD      = 0x00000017,
    ///Windows Vista and later only. Search-MS (search-ms:).
    URL_SCHEME_SEARCH_MS     = 0x00000018,
    ///Windows Vista with SP1 and later only. Search (search:).
    URL_SCHEME_SEARCH        = 0x00000019,
    ///<b>Windows 7 and later</b>. Known folder (knownfolder:).
    URL_SCHEME_KNOWNFOLDER   = 0x0000001a,
    URL_SCHEME_MAXVALUE      = 0x0000001b,
}

alias URL_PART = int;
enum : int
{
    URL_PART_NONE     = 0x00000000,
    URL_PART_SCHEME   = 0x00000001,
    URL_PART_HOSTNAME = 0x00000002,
    URL_PART_USERNAME = 0x00000003,
    URL_PART_PASSWORD = 0x00000004,
    URL_PART_PORT     = 0x00000005,
    URL_PART_QUERY    = 0x00000006,
}

alias URLIS = int;
enum : int
{
    URLIS_URL       = 0x00000000,
    URLIS_OPAQUE    = 0x00000001,
    URLIS_NOHISTORY = 0x00000002,
    URLIS_FILEURL   = 0x00000003,
    URLIS_APPLIABLE = 0x00000004,
    URLIS_DIRECTORY = 0x00000005,
    URLIS_HASQUERY  = 0x00000006,
}

///Provides a set of values that indicate from which base key an item will be deleted.
alias SHREGDEL_FLAGS = int;
enum : int
{
    ///Deletes from <b>HKEY_CURRENT_USER</b>. If the specified item is not found under <b>HKEY_CURRENT_USER</b>, deletes
    ///from <b>HKEY_LOCAL_MACHINE</b>.
    SHREGDEL_DEFAULT = 0x00000000,
    ///Enumerates from <b>HKEY_CURRENT_USER</b> only.
    SHREGDEL_HKCU    = 0x00000001,
    ///Enumerates under <b>HKEY_LOCAL_MACHINE</b> only.
    SHREGDEL_HKLM    = 0x00000010,
    SHREGDEL_BOTH    = 0x00000011,
}

///Provides a set of values that indicate the base key that will be used for an enumeration.
alias SHREGENUM_FLAGS = int;
enum : int
{
    ///Enumerates under <b>HKEY_CURRENT_USER</b>, or, if the specified item is not found in <b>HKEY_CURRENT_USER</b>,
    ///enumerates under <b>HKEY_LOCAL_MACHINE</b>.
    SHREGENUM_DEFAULT = 0x00000000,
    ///Enumerates under <b>HKEY_CURRENT_USER</b> only.
    SHREGENUM_HKCU    = 0x00000001,
    ///Enumerates under <b>HKEY_LOCAL_MACHINE</b> only.
    SHREGENUM_HKLM    = 0x00000010,
    SHREGENUM_BOTH    = 0x00000011,
}

///Used by IQueryAssociations::GetString to define the type of string that is to be returned.
alias ASSOCSTR = int;
enum : int
{
    ///A command string associated with a Shell verb.
    ASSOCSTR_COMMAND                 = 0x00000001,
    ///An executable from a Shell verb command string. For example, this string is found as the (Default) value for a
    ///subkey such as <b>HKEY_CLASSES_ROOT</b>&
    ASSOCSTR_EXECUTABLE              = 0x00000002,
    ///The friendly name of a document type.
    ASSOCSTR_FRIENDLYDOCNAME         = 0x00000003,
    ///The friendly name of an executable file.
    ASSOCSTR_FRIENDLYAPPNAME         = 0x00000004,
    ///Ignore the information associated with the <b>open</b> subkey.
    ASSOCSTR_NOOPEN                  = 0x00000005,
    ///Look under the <b>ShellNew</b> subkey.
    ASSOCSTR_SHELLNEWVALUE           = 0x00000006,
    ///A template for DDE commands.
    ASSOCSTR_DDECOMMAND              = 0x00000007,
    ///The DDE command to use to create a process.
    ASSOCSTR_DDEIFEXEC               = 0x00000008,
    ///The application name in a DDE broadcast.
    ASSOCSTR_DDEAPPLICATION          = 0x00000009,
    ///The topic name in a DDE broadcast.
    ASSOCSTR_DDETOPIC                = 0x0000000a,
    ///Corresponds to the InfoTip registry value. Returns an info tip for an item, or list of properties in the form of
    ///an IPropertyDescriptionList from which to create an info tip, such as when hovering the cursor over a file name.
    ///The list of properties can be parsed with PSGetPropertyDescriptionListFromString.
    ASSOCSTR_INFOTIP                 = 0x0000000b,
    ///<b>Introduced in Internet Explorer 6</b>. Corresponds to the QuickTip registry value. Same as ASSOCSTR_INFOTIP,
    ///except that it always returns a list of property names in the form of an IPropertyDescriptionList. The difference
    ///between this value and ASSOCSTR_INFOTIP is that this returns properties that are safe for any scenario that
    ///causes slow property retrieval, such as offline or slow networks. Some of the properties returned from
    ///ASSOCSTR_INFOTIP might not be appropriate for slow property retrieval scenarios. The list of properties can be
    ///parsed with PSGetPropertyDescriptionListFromString.
    ASSOCSTR_QUICKTIP                = 0x0000000c,
    ///<b>Introduced in Internet Explorer 6</b>. Corresponds to the TileInfo registry value. Contains a list of
    ///properties to be displayed for a particular file type in a Windows Explorer window that is in tile view. This is
    ///the same as ASSOCSTR_INFOTIP, but, like ASSOCSTR_QUICKTIP, it also returns a list of property names in the form
    ///of an IPropertyDescriptionList. The list of properties can be parsed with PSGetPropertyDescriptionListFromString.
    ASSOCSTR_TILEINFO                = 0x0000000d,
    ///<b>Introduced in Internet Explorer 6</b>. Describes a general type of MIME file association, such as image and
    ///bmp, so that applications can make general assumptions about a specific file type.
    ASSOCSTR_CONTENTTYPE             = 0x0000000e,
    ///<b>Introduced in Internet Explorer 6</b>. Returns the path to the icon resources to use by default for this
    ///association. Positive numbers indicate an index into the dll's resource table, while negative numbers indicate a
    ///resource ID. An example of the syntax for the resource is "c:\myfolder\myfile.dll,-1".
    ASSOCSTR_DEFAULTICON             = 0x0000000f,
    ///<b>Introduced in Internet Explorer 6</b>. For an object that has a Shell extension associated with it, you can
    ///use this to retrieve the CLSID of that Shell extension object by passing a string representation of the IID of
    ///the interface you want to retrieve as the <i>pwszExtra</i> parameter of IQueryAssociations::GetString. For
    ///example, if you want to retrieve a handler that implements the IExtractImage interface, you would specify
    ///"{BB2E617C-0920-11d1-9A0B-00C04FC2D6C1}", which is the IID of <b>IExtractImage</b>.
    ASSOCSTR_SHELLEXTENSION          = 0x00000010,
    ///<b>Introduced in Internet Explorer 8</b>.. For a verb invoked through COM and the IDropTarget interface, you can
    ///use this flag to retrieve the <b>IDropTarget</b> object's CLSID. This CLSID is registered in the
    ///<b>DropTarget</b> subkey. The verb is specified in the <i>pwszExtra</i> parameter in the call to
    ///IQueryAssociations::GetString. This type of string will identify the code that will be invoked in the
    ///implementation of the verb.
    ASSOCSTR_DROPTARGET              = 0x00000011,
    ///<b>Introduced in Internet Explorer 8</b>.. For a verb invoked through COM and the IExecuteCommand interface, you
    ///can use this flag to retrieve the <b>IExecuteCommand</b> object's CLSID. This CLSID is registered in the verb's
    ///<b>command</b> subkey as the DelegateExecute entry. The verb is specified in the <i>pwszExtra</i> parameter in
    ///the call to IQueryAssociations::GetString. This type of string will identify the code that will be invoked in the
    ///implementation of the verb.
    ASSOCSTR_DELEGATEEXECUTE         = 0x00000012,
    ///<b>Introduced in Windows 8</b>.
    ASSOCSTR_SUPPORTED_URI_PROTOCOLS = 0x00000013,
    ///The ProgID provided by the app associated with the file type or URI scheme. This if configured by users in their
    ///default program settings.
    ASSOCSTR_PROGID                  = 0x00000014,
    ///The AppUserModelID of the app associated with the file type or URI scheme. This is configured by users in their
    ///default program settings.
    ASSOCSTR_APPID                   = 0x00000015,
    ///The publisher of the app associated with the file type or URI scheme. This is configured by users in their
    ///default program settings.
    ASSOCSTR_APPPUBLISHER            = 0x00000016,
    ///The icon reference of the app associated with the file type or URI scheme. This is configured by users in their
    ///default program settings.
    ASSOCSTR_APPICONREFERENCE        = 0x00000017,
    ASSOCSTR_MAX                     = 0x00000018,
}

///Specifies the type of key to be returned by IQueryAssociations::GetKey.
alias ASSOCKEY = int;
enum : int
{
    ///A key that is passed to ShellExecuteEx through a SHELLEXECUTEINFO structure.
    ASSOCKEY_SHELLEXECCLASS = 0x00000001,
    ///An <b>Application</b> key for the file type.
    ASSOCKEY_APP            = 0x00000002,
    ///A ProgID or class key.
    ASSOCKEY_CLASS          = 0x00000003,
    ///A BaseClass value.
    ASSOCKEY_BASECLASS      = 0x00000004,
    ASSOCKEY_MAX            = 0x00000005,
}

///Used by IQueryAssociations::GetData to define the type of data that is to be returned.
alias ASSOCDATA = int;
enum : int
{
    ///The component descriptor to pass to the Windows Installer API.
    ASSOCDATA_MSIDESCRIPTOR     = 0x00000001,
    ///Attempts to activate a window are restricted. There is no data associated with this value.
    ASSOCDATA_NOACTIVATEHANDLER = 0x00000002,
    ASSOCDATA_UNUSED1           = 0x00000003,
    ///Defaults to user specified association.
    ASSOCDATA_HASPERUSERASSOC   = 0x00000004,
    ///<b>Internet Explorer version 6 or later</b>. Gets the data stored in the EditFlags value of a file association
    ///PROGID registry key. This value consists of one or more FILETYPEATTRIBUTEFLAGS. Compare against those values to
    ///determine which attributes have been set.
    ASSOCDATA_EDITFLAGS         = 0x00000005,
    ///<b>Internet Explorer version 6 or later</b>. Uses the <i>pwszExtra</i> parameter from the
    ///IQueryAssociations::GetData method as the value name.
    ASSOCDATA_VALUE             = 0x00000006,
    ASSOCDATA_MAX               = 0x00000007,
}

alias ASSOCENUM = int;
enum : int
{
    ASSOCENUM_NONE = 0x00000000,
}

///Indicates <b>FILETYPEATTRIBUTEFLAGS</b> constants that are used in the EditFlags value of a file association PROGID
///registry key.
alias FILETYPEATTRIBUTEFLAGS = int;
enum : int
{
    ///No FILETYPEATTRIBUTEFLAGS options set.
    FTA_None                  = 0x00000000,
    ///Excludes the file type.
    FTA_Exclude               = 0x00000001,
    ///Shows file types, such as folders, that are not associated with a file name extension.
    FTA_Show                  = 0x00000002,
    ///Indicates that the file type has a file name extension.
    FTA_HasExtension          = 0x00000004,
    ///Prohibits editing of the registry entries associated with this file type, the addition of new entries, and the
    ///deletion or modification of existing entries.
    FTA_NoEdit                = 0x00000008,
    ///Prohibits deletion of the registry entries associated with this file type.
    FTA_NoRemove              = 0x00000010,
    ///Prohibits the addition of new verbs to the file type.
    FTA_NoNewVerb             = 0x00000020,
    ///Prohibits the modification or deletion of canonical verbs such as <b>open</b> and <b>print</b>.
    FTA_NoEditVerb            = 0x00000040,
    ///Prohibits the deletion of canonical verbs such as <b>open</b> and <b>print</b>.
    FTA_NoRemoveVerb          = 0x00000080,
    ///Prohibits the modification or deletion of the description of the file type.
    FTA_NoEditDesc            = 0x00000100,
    ///Prohibits the modification or deletion of the icon assigned to the file type.
    FTA_NoEditIcon            = 0x00000200,
    ///Prohibits the modification of the default verb.
    FTA_NoEditDflt            = 0x00000400,
    ///Prohibits the modification of the commands associated with verbs.
    FTA_NoEditVerbCmd         = 0x00000800,
    ///Prohibits the modification or deletion of verbs.
    FTA_NoEditVerbExe         = 0x00001000,
    ///Prohibits the modification or deletion of the entries related to DDE.
    FTA_NoDDE                 = 0x00002000,
    ///Prohibits the modification or deletion of the content type and default extension entries.
    FTA_NoEditMIME            = 0x00008000,
    ///Indicates that the file type's <b>open</b> verb can be safely invoked for downloaded files. This flag applies
    ///only to safe file types, as identified by AssocIsDangerous. To improve the user experience and reduce unnecessary
    ///user prompts when downloading and activating items, file type owners should specify this flag and applications
    ///that download and activate files should respect this flag.
    FTA_OpenIsSafe            = 0x00010000,
    ///Prevents the <b>Never ask me</b> check box from being enabled. Use of this flag means <b>FTA_OpenIsSafe</b> is
    ///not respected and AssocIsDangerous always returns TRUE. If your file type can execute code, you should always use
    ///this flag or ensure that the file type handlers mitigate risks, for example, by producing warning prompts before
    ///running the code. The user can override this attribute through the <b>File Type</b> dialog box.
    FTA_AlwaysUnsafe          = 0x00020000,
    ///Prohibits the addition of members of this file type to the Recent Documents folder. Additionally, in Windows 7
    ///and later, prohibits the addition of members of this file type to the automatic <b>Recent</b> or <b>Frequent</b>
    ///category of an application's Jump List. This flag does not restrict members of this file type from being added to
    ///a custom Jump List. It also places no restriction on the file type being added to the automatic Jump Lists of
    ///other applications in the case that other applications use this file type.
    FTA_NoRecentDocs          = 0x00100000,
    ///<b>Introduced in Windows 8</b>. Marks the file as safe to be passed from a low trust application to a full trust
    ///application. Files that originate from the Internet or an app container are examples where the file is considered
    ///untrusted. Untrusted files that contain code are especially dangerous, and appropriate security mitigations must
    ///be applied if the file is to be opened by a full trust application. File type owners for file formats that have
    ///the ability to execute code should specify this flag only if their program mitigates elevation-of-privilege
    ///threats that are associated with running code at a higher integrity level. Mitigations include prompting the user
    ///before code is executed or executing the code with reduced privileges. By specifying this flag for an entire file
    ///type, an app running within an app container can pass files of this type to a program running at full trust. Some
    ///file types are recognized as inherently dangerous due to their ability to execute code and will be blocked if you
    ///don't specify this value.
    FTA_SafeForElevation      = 0x00200000,
    ///<b>Introduced in Windows 8</b>. Ensures that the verbs for the file type are invoked with a URI instead of a
    ///downloaded version of the file. Use this flag only if you've registered the file type's verb to support
    ///DirectInvoke through the SupportedProtocols or UseUrl registration.
    FTA_AlwaysUseDirectInvoke = 0x00400000,
}

///Identifiers for various global counters, or shared variables. Each global counter can be incremented or decremented
///using SHGlobalCounterIncrement and SHGlobalCounterDecrement.
alias SHGLOBALCOUNTER = int;
enum : int
{
    ///The global counter for use with the ISearchManager.
    GLOBALCOUNTER_SEARCHMANAGER                                      = 0x00000000,
    ///The global counter for use with ISearchQueryHelper to identify whether a query parser's settings have changed.
    GLOBALCOUNTER_SEARCHOPTIONS                                      = 0x00000001,
    ///The global counter used to identify whether folder settings have changed.
    GLOBALCOUNTER_FOLDERSETTINGSCHANGE                               = 0x00000002,
    ///The global counter used to identify whether ratings have changed.
    GLOBALCOUNTER_RATINGS                                            = 0x00000003,
    ///The global counter used to identify whether approved sites have changed.
    GLOBALCOUNTER_APPROVEDSITES                                      = 0x00000004,
    ///The global counter used to identify whether restrictions have changed.
    GLOBALCOUNTER_RESTRICTIONS                                       = 0x00000005,
    ///The global counter used to identify whether Shell settings have changed.
    GLOBALCOUNTER_SHELLSETTINGSCHANGED                               = 0x00000006,
    ///The global counter used to identify whether a system PIDL has changed.
    GLOBALCOUNTER_SYSTEMPIDLCHANGE                                   = 0x00000007,
    ///The global counter used to identify whether the overlay manager state has changed.
    GLOBALCOUNTER_OVERLAYMANAGER                                     = 0x00000008,
    ///The global counter used to identify whether query associations have changed.
    GLOBALCOUNTER_QUERYASSOCIATIONS                                  = 0x00000009,
    ///The global counter used to identify whether the number of IE sessions has changed.
    GLOBALCOUNTER_IESESSIONS                                         = 0x0000000a,
    ///The global counter used to identify whether the number of IE sessions has changed.
    GLOBALCOUNTER_IEONLY_SESSIONS                                    = 0x0000000b,
    ///Identifies The global counter used to identify whether applications have been added or removed from the system.
    GLOBALCOUNTER_APPLICATION_DESTINATIONS                           = 0x0000000c,
    ///Unused.
    __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_CSCSYNCINPROGRESS             = 0x0000000d,
    ///The global counter used to identify deletions to the Recycle Bin.
    GLOBALCOUNTER_BITBUCKETNUMDELETERS                               = 0x0000000e,
    ///The global counter used to identify whether settings have changed on a share.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SHARES                           = 0x0000000f,
    ///The global counter used to identify whether settings have changed on drive A.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_A                          = 0x00000010,
    ///The global counter used to identify whether settings have changed on drive B.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_B                          = 0x00000011,
    ///The global counter used to identify whether settings have changed on drive C.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_C                          = 0x00000012,
    ///The global counter used to identify whether settings have changed on drive D.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_D                          = 0x00000013,
    ///The global counter used to identify whether settings have changed on drive E.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_E                          = 0x00000014,
    ///The global counter used to identify whether settings have changed on drive F.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_F                          = 0x00000015,
    ///The global counter used to identify whether settings have changed on drive G.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_G                          = 0x00000016,
    ///The global counter used to identify whether settings have changed on drive H.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_H                          = 0x00000017,
    ///The global counter used to identify whether settings have changed on drive I.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_I                          = 0x00000018,
    ///The global counter used to identify whether settings have changed on drive J.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_J                          = 0x00000019,
    ///The global counter used to identify whether settings have changed on drive K.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_K                          = 0x0000001a,
    ///The global counter used to identify whether settings have changed on drive L.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_L                          = 0x0000001b,
    ///The global counter used to identify whether settings have changed on drive M.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_M                          = 0x0000001c,
    ///The global counter used to identify whether settings have changed on drive N.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_N                          = 0x0000001d,
    ///The global counter used to identify whether settings have changed on drive O.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_O                          = 0x0000001e,
    ///The global counter used to identify whether settings have changed on drive P.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_P                          = 0x0000001f,
    ///The global counter used to identify whether settings have changed on drive Q.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Q                          = 0x00000020,
    ///The global counter used to identify whether settings have changed on drive R.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_R                          = 0x00000021,
    ///The global counter used to identify whether settings have changed on drive S.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_S                          = 0x00000022,
    ///The global counter used to identify whether settings have changed on drive T.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_T                          = 0x00000023,
    ///The global counter used to identify whether settings have changed on drive U.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_U                          = 0x00000024,
    ///The global counter used to identify whether settings have changed on drive V.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_V                          = 0x00000025,
    ///The global counter used to identify whether settings have changed on drive W.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_W                          = 0x00000026,
    ///The global counter used to identify whether settings have changed on drive X.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_X                          = 0x00000027,
    ///The global counter used to identify whether settings have changed on drive Y.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Y                          = 0x00000028,
    ///The global counter used to identify whether settings have changed on drive Z.
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Z                          = 0x00000029,
    ///Unused.
    __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SERVERDRIVE = 0x0000002a,
    ///Unused.
    __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEGLOBALDIRTYCOUNT       = 0x0000002b,
    ///The global counter used to identify whether the Recycle Bin settings have changed.
    GLOBALCOUNTER_RECYCLEBINENUM                                     = 0x0000002c,
    ///The global counter used to identify whether a Recycle Bin has been deleted.
    GLOBALCOUNTER_RECYCLEBINCORRUPTED                                = 0x0000002d,
    ///The global counter used to identify whether ratings have changed.
    GLOBALCOUNTER_RATINGS_STATECOUNTER                               = 0x0000002e,
    ///The global counter state.
    GLOBALCOUNTER_PRIVATE_PROFILE_CACHE                              = 0x0000002f,
    ///The global counter used to identify whether the Internet toolbar layout has changed.
    GLOBALCOUNTER_INTERNETTOOLBAR_LAYOUT                             = 0x00000030,
    ///The global counter used to identify changes to the folder definition cache.
    GLOBALCOUNTER_FOLDERDEFINITION_CACHE                             = 0x00000031,
    ///The global counter used to identify state changes for the commonplaces list cache.
    GLOBALCOUNTER_COMMONPLACES_LIST_CACHE                            = 0x00000032,
    ///The global counter state, machine-wide.
    GLOBALCOUNTER_PRIVATE_PROFILE_CACHE_MACHINEWIDE                  = 0x00000033,
    ///The global counter used to identify the current GlobalAssocChangedCounter registry value for
    ///HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer.
    GLOBALCOUNTER_ASSOCCHANGED                                       = 0x00000034,
    ///<b>Introduced in Windows 8</b>. The global counter used to identify whether the Store is current.
    GLOBALCOUNTER_APP_ITEMS_STATE_STORE_CACHE                        = 0x00000035,
    ///<b>Introduced in Windows 8</b>. The global counter used to determine whether sync is enabled or disabled.
    GLOBALCOUNTER_SETTINGSYNC_ENABLED                                = 0x00000036,
    ///<b>Introduced in Windows 8</b>. The global counter used to identify the current FTACounter registry value for
    ///HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\ImmersiveShell\StateStore.
    GLOBALCOUNTER_APPSFOLDER_FILETYPEASSOCIATION_COUNTER             = 0x00000037,
    ///<b>Introduced in Windows 8</b>. The global counter used to identify user info change state.
    GLOBALCOUNTER_USERINFOCHANGED                                    = 0x00000038,
    ///<b>Introduced in Windows 8.1</b>. The global counter used to identify sync engine counter state, machine wide..
    GLOBALCOUNTER_SYNC_ENGINE_INFORMATION_CACHE_MACHINEWIDE          = 0x00000039,
    GLOBALCOUNTER_BANNERS_DATAMODEL_CACHE_MACHINEWIDE                = 0x0000003a,
    ///The maximum value any shared variable can have.
    GLOBALCOUNTER_MAXIMUMVALUE                                       = 0x0000003b,
}

///Specifies application information to return from IShellApp::GetAppInfo. These flags are bitmasks used in the dwMask
///member of the <b>APPINFODATA</b> structure.
alias APPINFODATAFLAGS = int;
enum : int
{
    ///Returns the display name.
    AIM_DISPLAYNAME       = 0x00000001,
    ///Returns the version.
    AIM_VERSION           = 0x00000002,
    ///Returns the application publisher.
    AIM_PUBLISHER         = 0x00000004,
    ///Returns the application's product ID.
    AIM_PRODUCTID         = 0x00000008,
    ///Returns the application's registered owner.
    AIM_REGISTEREDOWNER   = 0x00000010,
    ///Returns the application's registered company.
    AIM_REGISTEREDCOMPANY = 0x00000020,
    ///Returns the language.
    AIM_LANGUAGE          = 0x00000040,
    ///Returns the support URL.
    AIM_SUPPORTURL        = 0x00000080,
    ///Returns the support telephone number.
    AIM_SUPPORTTELEPHONE  = 0x00000100,
    ///Returns the Help link.
    AIM_HELPLINK          = 0x00000200,
    ///Returns the application's install location.
    AIM_INSTALLLOCATION   = 0x00000400,
    ///Returns the install source.
    AIM_INSTALLSOURCE     = 0x00000800,
    ///Returns the application's install date.
    AIM_INSTALLDATE       = 0x00001000,
    ///Returns the application's contact information.
    AIM_CONTACT           = 0x00004000,
    ///Returns application comments.
    AIM_COMMENTS          = 0x00008000,
    ///Returns the application image.
    AIM_IMAGE             = 0x00020000,
    ///Returns the URL of the application's ReadMe file.
    AIM_READMEURL         = 0x00040000,
    ///Returns the URL of the application's update information.
    AIM_UPDATEINFOURL     = 0x00080000,
}

///Specifies application management actions supported by an application publisher. These flags are bitmasks passed to
///IShellApp::GetPossibleActions.
alias APPACTIONFLAGS = int;
enum : int
{
    ///Indicates that the application can be installed. Published applications always set this bit.
    APPACTION_INSTALL      = 0x00000001,
    ///Not applicable to published applications.
    APPACTION_UNINSTALL    = 0x00000002,
    ///Not applicable to published applications.
    APPACTION_MODIFY       = 0x00000004,
    ///Not applicable to published applications.
    APPACTION_REPAIR       = 0x00000008,
    ///Not applicable to published applications.
    APPACTION_UPGRADE      = 0x00000010,
    ///Not applicable to published applications.
    APPACTION_CANGETSIZE   = 0x00000020,
    ///Not applicable to published applications.
    APPACTION_MODIFYREMOVE = 0x00000080,
    ///Indicates that the application supports scheduled installation. If this bit is set, then the Control Panel's Add
    ///or Remove Programs application presents the user an <b>Add Later</b> button. If you select <b>Add Later</b>, you
    ///are prompted to select the desired time of installation. The IPublishedApp::Install method is then called with
    ///the installation time.
    APPACTION_ADDLATER     = 0x00000100,
    ///Obsolete.
    APPACTION_UNSCHEDULE   = 0x00000200,
}

///Specifies which members in the PUBAPPINFO structure are valid. These flags are bitmasks set in the <b>dwMask</b>
///member and passed to IPublishedApp::GetPublishedAppInfo.
alias PUBAPPINFOFLAGS = int;
enum : int
{
    ///The pszSource string is valid and contains the display name of the publishing source. If multiple sources publish
    ///an application of the same name, Add/Remove Programs identifies them by "&lt;application name&gt; :
    ///&lt;publishing source&gt;".
    PAI_SOURCE        = 0x00000001,
    ///The stAssigned member is valid and contains the time that the application should be installed as assigned by an
    ///application administrator.
    PAI_ASSIGNEDTIME  = 0x00000002,
    ///Not used.
    PAI_PUBLISHEDTIME = 0x00000004,
    ///The stScheduled member is valid and contains the time that the application should be installed as assigned by the
    ///user.
    PAI_SCHEDULEDTIME = 0x00000008,
    ///The stExpired member is valid and contains the time after which Add/Remove Programs should no longer install the
    ///program.
    PAI_EXPIRETIME    = 0x00000010,
}

///Declares the scenarios in which a credential provider is supported. A credential provider usage scenario (CPUS)
///enables the credential provider to provide distinct enumeration behavior and UI field setup across scenarios. When an
///ICredentialProvider is initialized, it calls ICredentialProvider::SetUsageScenario to set what usage scenario is
///supported. That scenario is maintained for the entire lifetime of the credential provider.
alias CREDENTIAL_PROVIDER_USAGE_SCENARIO = int;
enum : int
{
    ///No usage scenario has been set for the credential provider. The scenario is not passed to
    ///ICredentialProvider::SetUsageScenario. If a credential provider stores its current usage scenario as a class
    ///member, this provides an initialization value before the first call to
    ///<b>ICredentialProvider::SetUsageScenario</b>.
    CPUS_INVALID            = 0x00000000,
    ///Workstation logon or unlock. See the remarks for more details. Credential providers that implement this scenario
    ///should be prepared to serialize credentials to the local authority for authentication.
    CPUS_LOGON              = 0x00000001,
    ///Workstation unlock. Credential providers that implement this scenario should be prepared to serialize credentials
    ///to the local authority for authentication. These credential providers also need to enumerate the currently
    ///logged-in user as the default tile.
    CPUS_UNLOCK_WORKSTATION = 0x00000002,
    ///Password change. This enables a credential provider to enumerate tiles in response to a user's request to change
    ///the password. Do not implement this scenario if you do not require some secret information from the user such as
    ///a password or PIN. These credential providers also need to enumerate the currently logged-in user as the default
    ///tile.
    CPUS_CHANGE_PASSWORD    = 0x00000003,
    ///Credential UI. This scenario enables you to use credentials serialized by the credential provider to be used as
    ///authentication on remote machines. This is also the scenario used for over-the-shoulder prompting in User Access
    ///Control. This scenario uses a different instance of the credential provider than the one used for
    ///<b>CPUS_LOGON</b>, <b>CPUS_UNLOCK_WORKSTATION</b>, and <b>CPUS_CHANGE_PASSWORD</b>, so the state of the
    ///credential provider cannot be maintained across the different scenarios.
    CPUS_CREDUI             = 0x00000004,
    ///Pre-Logon-Access Provider. Credential providers responding to this usage scenario must register under:
    ///<b>HKLM</b>&
    CPUS_PLAP               = 0x00000005,
}

///Specifies a type of credential field. Used by CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR.
alias CREDENTIAL_PROVIDER_FIELD_TYPE = int;
enum : int
{
    ///The value is invalid. This is a safe initialization value, as fields do not default to any given type.
    CPFT_INVALID       = 0x00000000,
    ///A stand-alone text label is drawn in the larger of two font sizes.
    CPFT_LARGE_TEXT    = 0x00000001,
    ///A stand-alone text label is drawn in the smaller of two font sizes.
    CPFT_SMALL_TEXT    = 0x00000002,
    ///An uneditable string that a user may click to perform an action. The credential provider is informed of the
    ///user's click, and then performs the requested action. Use CommandLinkClicked in your credential provider to
    ///respond to the click.
    CPFT_COMMAND_LINK  = 0x00000003,
    ///An edit box. Users may provide credential information by typing in this box.
    CPFT_EDIT_TEXT     = 0x00000004,
    ///A special edit control that displays its string as a series of password characters, such as the asterisk
    ///character (*). Otherwise this functions the same as <b>CPFT_EDIT_TEXT</b>.
    CPFT_PASSWORD_TEXT = 0x00000005,
    ///A bitmap that is shown as the user tile image. This bitmap cannot be edited. All credential providers must
    ///contain no more than one <b>CPFT_TILE_IMAGE</b>. If no image is specified, Logon UI and Credential UI will supply
    ///a default tile image.
    CPFT_TILE_IMAGE    = 0x00000006,
    ///A checkbox control that allows for checked and unchecked states.
    CPFT_CHECKBOX      = 0x00000007,
    ///A combobox control that allows users to select an option from a defined set of choices.
    CPFT_COMBOBOX      = 0x00000008,
    ///This field appears as a button on the credential tile. Pressing the button lets the user submit their
    ///credentials. There is exactly one <b>CPFT_SUBMIT_BUTTON</b> on any credential tile. Unlike Logon UI, which draws
    ///a special submit button in the tile layout, Credential UI hides this field and renders a single submit button for
    ///all credentials.
    CPFT_SUBMIT_BUTTON = 0x00000009,
}

///Specifies the state of a single field in the Credential UI. Used by CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR and
///ICredentialProviderCredentialEvents::SetFieldState. The behavior of fields may vary depending on the current field
///state.
alias CREDENTIAL_PROVIDER_FIELD_STATE = int;
enum : int
{
    ///Do not show the field in any state. One example of this would be a password edit control that should not be
    ///displayed until the user authenticates a thumb print. Until the thumb print has been authenticated, the state of
    ///the password field would be <b>CPFS_HIDDEN</b>.
    CPFS_HIDDEN                     = 0x00000000,
    ///Show the field when in the selected state.
    CPFS_DISPLAY_IN_SELECTED_TILE   = 0x00000001,
    ///Show the field when in the deselected state. This value is only valid for a CREDENTIAL_PROVIDER_USAGE_SCENARIO is
    ///set to <b>CPUS_CREDUI</b>.
    CPFS_DISPLAY_IN_DESELECTED_TILE = 0x00000002,
    CPFS_DISPLAY_IN_BOTH            = 0x00000003,
}

///Describes the state of a field and how it a user can interact with it. Fields can be displayed by a credential
///provider in a variety of different interactive states. Used by ICredentialProviderCredential::GetFieldState and
///ICredentialProviderCredentialEvents::SetFieldInteractiveState.
alias CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE = int;
enum : int
{
    ///The field can be edited if the field type supports editing. It also contains none of the other available
    ///interactive states.
    CPFIS_NONE     = 0x00000000,
    ///Reserved and not used.
    CPFIS_READONLY = 0x00000001,
    ///The field is disabled. The user can see it but not interact with it. This support was added starting with Windows
    ///10.
    CPFIS_DISABLED = 0x00000002,
    ///Credential providers use this field interactive state to indicate that the field should receive initial keyboard
    ///focus. This interactive state may not be specified for field types that the user cannot edit. If several editable
    ///fields specify this state, the last of them based on <i>dwIndex</i> order receives focus. On systems before
    ///Windows 10, it was the first of editable fields based on <i>dwIndex</i> order. This field interactive state is
    ///obeyed only during initial enumeration.
    CPFIS_FOCUSED  = 0x00000003,
}

///Describes the response when a credential provider attempts to serialize credentials. Used by
///ICredentialProviderCredential::GetSerialization.
alias CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE = int;
enum : int
{
    ///No credential was serialized because more information is needed. One example of this would be if a credential
    ///requires both a PIN and an answer to a secret question, but the user has only provided the PIN. This signals the
    ///caller should be given a chance to alter its response.
    CPGSR_NO_CREDENTIAL_NOT_FINISHED    = 0x00000000,
    ///The credential provider has not serialized a credential but has completed its work. This response has multiple
    ///meanings. It can mean that no credential was serialized and that the user should not try again. This response can
    ///also mean that no credential was submitted but the credential's work is complete. For example, in the Change
    ///Password scenario, this response implies success.
    CPGSR_NO_CREDENTIAL_FINISHED        = 0x00000001,
    ///A credential was serialized. This response implies that a serialization structure was passed back.
    CPGSR_RETURN_CREDENTIAL_FINISHED    = 0x00000002,
    ///The credential provider has not serialized a credential, but has completed its work. The difference between this
    ///value and <b>CPGSR_NO_CREDENTIAL_FINISHED</b> is that this flag will force the logon UI to return, which will
    ///call UnAdvise for all the credential providers.
    CPGSR_RETURN_NO_CREDENTIAL_FINISHED = 0x00000003,
}

///Indicates which status icon should be displayed.
alias CREDENTIAL_PROVIDER_STATUS_ICON = int;
enum : int
{
    ///No icon indicated.
    CPSI_NONE    = 0x00000000,
    ///Display the error icon.
    CPSI_ERROR   = 0x00000001,
    ///Display the warning icon.
    CPSI_WARNING = 0x00000002,
    ///Reserved.
    CPSI_SUCCESS = 0x00000003,
}

///Indicates the type of credential that a credential provider should return to associate with the "Other user" tile.
///Used by ICredentialProviderUserArray_GetAccountOptions.
alias CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS = int;
enum : int
{
    ///Default. Do not return a credential to associate with the "Other user" tile.
    CPAO_NONE            = 0x00000000,
    ///Return a credential to associate with the "Other user" tile. This credential can only be used for a local
    ///account.
    CPAO_EMPTY_LOCAL     = 0x00000001,
    ///Return a credential to associate with the "Other user" tile. This credential can only be used for a Microsoft
    ///account.
    CPAO_EMPTY_CONNECTED = 0x00000002,
}

///Provides customization options for a single field in a logon or credential UI. Used by
///ICredentialProviderCredentialEvents2::SetFieldOptions and
///ICredentialProviderCredentialWithFieldOptions::GetFieldOptions.
alias CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS = int;
enum : int
{
    ///Default. Don't show the "password reveal" glyph, and use the standard on-screen keyboard layout.
    CPCFO_NONE                              = 0x00000000,
    ///Display the "password reveal" glyph in a password entry box. When this glyph is held down by the user, the entry
    ///in the password box is shown in plain text. The glyph is shown here: <img alt="Password reveal glyph"
    ///src="./images/PasswordReveal.png"/>
    CPCFO_ENABLE_PASSWORD_REVEAL            = 0x00000001,
    ///The field will contain an e-mail address. The on-screen keyboard should be optimized for that input (showing the
    ///.com and @ keys on the primary keyboard layout). This option is used with Microsoft account credentials.
    CPCFO_IS_EMAIL_ADDRESS                  = 0x00000002,
    ///When enabled, the touch keyboard will be automatically invoked. This should be set only on the
    ///<b>CPFG_CREDENTIAL_PROVIDER_LOGO</b> field.
    CPCFO_ENABLE_TOUCH_KEYBOARD_AUTO_INVOKE = 0x00000004,
    ///The field will only allow numerals to be entered. The on-screen keyboard should be optimized for that input
    ///(showing only a number keypad on the primary keyboard layout). This should be set only on the
    ///<b>CPFT_PASSWORD_TEXT</b> field
    CPCFO_NUMBERS_ONLY                      = 0x00000008,
    ///Show the English keyboard.
    CPCFO_SHOW_ENGLISH_KEYBOARD             = 0x00000010,
}

///Specifies the capabilities of a handler regarding the actions that can be performed against it.
alias SYNCMGR_HANDLER_CAPABILITIES = int;
enum : int
{
    ///No capability flags are set.
    SYNCMGR_HCM_NONE                         = 0x00000000,
    ///The handler returns a valid object from ISyncMgrHandler::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_Icon flag. The object returned from <b>ISyncMgrHandler::GetObject</b> must implement
    ///IExtractIcon. Generally, this value should not be returned if possible.
    SYNCMGR_HCM_PROVIDES_ICON                = 0x00000001,
    ///The handler returns a valid object from ISyncMgrHandler::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_EventStore flag. The object returned from <b>ISyncMgrHandler::GetObject</b> must implement
    ///ISyncMgrEventStore.
    SYNCMGR_HCM_EVENT_STORE                  = 0x00000002,
    ///The handler returns a valid object from ISyncMgrHandler::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_ConflictStore flag. The object returned from <b>ISyncMgrHandler::GetObject</b> must implement
    ///ISyncMgrConflictStore.
    SYNCMGR_HCM_CONFLICT_STORE               = 0x00000004,
    ///If a handler sets this flag in the mask returned from the handler's ISyncMgrHandler::GetCapabilities method, it
    ///indicates that the handler plans to create multiple simultaneous synchronization sessions using
    ///ISyncMgrSessionCreator::CreateSession. This is useful for handlers that implement a background synchronization
    ///architecture in which the handler simply signals another process to perform the synchronization rather than
    ///performing the synchronization in its ISyncMgrHandler::Synchronize method directly. This allows synchronization
    ///engines to report progress, conflicts, and events (through ISyncMgrSyncCallback) when synchronization requests
    ///come from sources other than Sync Center. For example, this could be the result of a data change notification or
    ///through application-specific UI. If more than one session is synchronizing the same item, then the progress for
    ///that item will be reported as indeterminate.
    SYNCMGR_HCM_SUPPORTS_CONCURRENT_SESSIONS = 0x00000010,
    ///The handler returns a valid object from ISyncMgrHandler::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_BrowseContent flag. If this value is set, the <b>Browse Content</b> task is added to the
    ///handler's shortcut menu. The object returned from <b>ISyncMgrHandler::GetObject</b> must implement
    ///ISyncMgrUIOperation.
    SYNCMGR_HCM_CAN_BROWSE_CONTENT           = 0x00010000,
    ///The handler returns a valid object from ISyncMgrHandler::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_ShowSchedule flag. If this value is set, the <b>Show Schedule</b> task is added to the handler's
    ///shortcut menu. The object returned from <b>ISyncMgrHandler::GetObject</b> must implement ISyncMgrUIOperation.
    ///This value is used by ISyncMgrScheduleWizardUIOperation.
    SYNCMGR_HCM_CAN_SHOW_SCHEDULE            = 0x00020000,
    ///The handler returns a valid object from ISyncMgrHandler::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_QueryBeforeActivate flag. The object returned from <b>ISyncMgrHandler::GetObject</b> must
    ///implement ISyncMgrUIOperation.
    SYNCMGR_HCM_QUERY_BEFORE_ACTIVATE        = 0x00100000,
    ///The handler returns a valid object from ISyncMgrHandler::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_QueryBeforeDeactivate flag. The object returned from <b>ISyncMgrHandler::GetObject</b> must
    ///implement ISyncMgrUIOperation.
    SYNCMGR_HCM_QUERY_BEFORE_DEACTIVATE      = 0x00200000,
    ///The handler returns a valid object from ISyncMgrHandler::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_QueryBeforeEnable flag. The object returned from <b>ISyncMgrHandler::GetObject</b> must
    ///implement ISyncMgrUIOperation.
    SYNCMGR_HCM_QUERY_BEFORE_ENABLE          = 0x00400000,
    ///The handler returns a valid object from ISyncMgrHandler::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_QueryBeforeDisable flag. The object returned from <b>ISyncMgrHandler::GetObject</b> must
    ///implement ISyncMgrUIOperation.
    SYNCMGR_HCM_QUERY_BEFORE_DISABLE         = 0x00800000,
    ///A mask used to determine valid SYNCMGR_HANDLER_CAPABILITIES flags. Compare against the value retrieved by
    ///ISyncMgrHandler::GetCapabilities to verify valid results.
    SYNCMGR_HCM_VALID_MASK                   = 0x00f30017,
}

///Enumerates policies specified by a sync handler that deviate from the default policy.
alias SYNCMGR_HANDLER_POLICIES = int;
enum : int
{
    ///No handler policy flags are set.
    SYNCMGR_HPM_NONE                 = 0x00000000,
    ///Activation of the handler is not supported at the time of the call. This value can be used by a handler to
    ///implement support for group policy that prevents the handler from being activated. If this value is set, the
    ///<b>Setup</b> task is not be shown in the Setup Sync folder when this handler is selected. The handler should
    ///provide a comment—returned from its implementation of ISyncMgrHandlerInfo::GetComment—to let the user know
    ///why the <b>Setup</b> task is not available. Most handlers should not set this value.
    SYNCMGR_HPM_PREVENT_ACTIVATE     = 0x00000001,
    ///Deactivation of the handler is not supported at the time of the call. This value can be used by a handler to
    ///implement support for group policy that prevents the handler from being deactivated. If this value is set, the
    ///<b>Delete</b> task is not shown in the Sync Center folder when this handler is selected. The handler should
    ///provide a comment—returned from its implementation of ISyncMgrHandlerInfo::GetComment—to let the user know
    ///why the <b>Setup</b> task is not available. Most handlers should not set this value.
    SYNCMGR_HPM_PREVENT_DEACTIVATE   = 0x00000002,
    ///The handler normally supports enable, but cannot be enabled because of handler policy. If this flag is set, the
    ///<b>Enable</b> option will not be displayed on the context menu.
    SYNCMGR_HPM_PREVENT_ENABLE       = 0x00000004,
    ///The handler normally supports disable, but cannot be enabled because of handler policy. If this flag is set, the
    ///<b>Disable</b> option will not be displayed on the context menu.
    SYNCMGR_HPM_PREVENT_DISABLE      = 0x00000008,
    ///The handler normally supports sync, but cannot be synchronized because of handler policy. If this flag is set,
    ///the <b>Start Sync</b> option will not be displayed on the context menu or the command bar.
    SYNCMGR_HPM_PREVENT_START_SYNC   = 0x00000010,
    ///The handler normally supports sync, but cannot be synchronized because of handler policy. If this flag is set,
    ///the <b>Stop Sync</b> option will not be displayed on the context menu or the command bar.
    SYNCMGR_HPM_PREVENT_STOP_SYNC    = 0x00000020,
    ///The handler normally supports enable, but cannot be enabled at the time of the call. The <b>Enable</b> option
    ///will be displayed but will be disabled.
    SYNCMGR_HPM_DISABLE_ENABLE       = 0x00000100,
    ///The handler normally supports disable, but cannot be disabled at the time of the call. The <b>Disable</b> option
    ///will be displayed but will be disabled.
    SYNCMGR_HPM_DISABLE_DISABLE      = 0x00000200,
    ///The handler normally supports syncing, but cannot be synchronized at the time of the call. The <b>Start Sync</b>
    ///option will be displayed but will be disabled.
    SYNCMGR_HPM_DISABLE_START_SYNC   = 0x00000400,
    ///The handler normally supports cancel, but cannot be canceled at the time of the call. The <b>Stop Sync</b> option
    ///will be displayed but will be disabled.
    SYNCMGR_HPM_DISABLE_STOP_SYNC    = 0x00000800,
    ///The handler normally supports cancel, but cannot be canceled at the time of the call. The <b>Browse</b> option
    ///will be displayed but will be disabled.
    SYNCMGR_HPM_DISABLE_BROWSE       = 0x00001000,
    ///The handler normally supports cancel, but cannot be canceled at the time of the call. The <b>Show Schedule</b>
    ///option will be displayed but will be disabled.
    SYNCMGR_HPM_DISABLE_SCHEDULE     = 0x00002000,
    ///The handler should be hidden from the user unless the <b>Show Hidden Files</b> option has been enabled. This
    ///policy only applies the first time that the handler is loaded. After that, the hidden state is maintained by Sync
    ///Center and can be changed by the user through the property sheet. The hidden state is available in the folder UI
    ///as the System.Sync.Hidden (PKEY_Sync_Hidden) property.
    SYNCMGR_HPM_HIDDEN_BY_DEFAULT    = 0x00010000,
    ///The user is not offered <b>Sync</b> and <b>Stop</b> tasks in the UI. This is equivalent to
    ///<code>SYNCMGR_HPM_PREVENT_START_SYNC | SYNCMGR_HPM_PREVENT_STOP_SYNC</code>.
    SYNCMGR_HPM_BACKGROUND_SYNC_ONLY = 0x00000030,
    SYNCMGR_HPM_VALID_MASK           = 0x00012f3f,
}

///Specifies the type of a handler. Used by ISyncMgrHandlerInfo::GetType.
alias SYNCMGR_HANDLER_TYPE = int;
enum : int
{
    ///The handler type is unknown. This value is also used if ISyncMgrHandlerInfo::GetType fails.
    SYNCMGR_HT_UNSPECIFIED = 0x00000000,
    ///The handler is an application.
    SYNCMGR_HT_APPLICATION = 0x00000001,
    ///The handler syncs with a device such as a phone or PDA.
    SYNCMGR_HT_DEVICE      = 0x00000002,
    ///The handler syncs with local or remote folders.
    SYNCMGR_HT_FOLDER      = 0x00000003,
    ///The handler syncs with a web service.
    SYNCMGR_HT_SERVICE     = 0x00000004,
    ///The handler syncs with a computer.
    SYNCMGR_HT_COMPUTER    = 0x00000005,
    ///Indicates the minimum SYNCMGR_HANDLER_TYPE value.
    SYNCMGR_HT_MIN         = 0x00000000,
    SYNCMGR_HT_MAX         = 0x00000005,
}

///Specifies the actions that can be performed against an item.
alias SYNCMGR_ITEM_CAPABILITIES = int;
enum : int
{
    ///No capability flags are set.
    SYNCMGR_ICM_NONE                 = 0x00000000,
    ///The item returns a valid object from ISyncMgrSyncItem::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_Icon flag.
    SYNCMGR_ICM_PROVIDES_ICON        = 0x00000001,
    ///The item returns a valid object from ISyncMgrSyncItem::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_EventStore flag.
    SYNCMGR_ICM_EVENT_STORE          = 0x00000002,
    ///The item returns a valid object from ISyncMgrSyncItem::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_ConflictStore flag.
    SYNCMGR_ICM_CONFLICT_STORE       = 0x00000004,
    ///The user is allowed to delete the item from the handler's folder. This can be used by an item to remove itself
    ///from the handler's sync set (for instance, remove a folder from the set of Offline Files). If this value is set,
    ///the <b>Delete</b> task is shown in the handler's folder when this item is selected.
    SYNCMGR_ICM_CAN_DELETE           = 0x00000010,
    ///The item returns a valid object from ISyncMgrSyncItem::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_BrowseContent flag. If this value is set, the <b>Browse Content</b> task is added to the item's
    ///shortcut menu.
    SYNCMGR_ICM_CAN_BROWSE_CONTENT   = 0x00010000,
    ///The item returns a valid object from ISyncMgrSyncItem::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_QueryBeforeEnable flag.
    SYNCMGR_ICM_QUERY_BEFORE_ENABLE  = 0x00100000,
    ///The item returns a valid object from ISyncMgrSyncItem::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_QueryBeforeDisable flag.
    SYNCMGR_ICM_QUERY_BEFORE_DISABLE = 0x00200000,
    ///The item returns a valid object from ISyncMgrSyncItem::GetObject when that method is called with the
    ///SYNCMGR_OBJECTID_QueryBeforeDelete flag.
    SYNCMGR_ICM_QUERY_BEFORE_DELETE  = 0x00400000,
    ///A mask used to retrieve valid SYNCMGR_ITEM_CAPABILITIES flags.
    SYNCMGR_ICM_VALID_MASK           = 0x00710017,
}

///Specifies an item's policies to control how they can be enabled or disabled by group policy.
alias SYNCMGR_ITEM_POLICIES = int;
enum : int
{
    ///No policy flags are set.
    SYNCMGR_IPM_NONE               = 0x00000000,
    ///Enabling of the item is not supported at the time of the call. This value can be used by an item to implement
    ///support for group policy that prevents the item from being enabled. If this value is set, the <b>Enable</b> task
    ///is not shown in the handler's folder when this item is selected. The item should provide a comment—returned
    ///from its implementation of ISyncMgrSyncItemInfo::GetComment—to let the user know why the <b>Enable</b> task is
    ///not available. Most items should not set this value.
    SYNCMGR_IPM_PREVENT_ENABLE     = 0x00000001,
    ///Disabling of the item is not supported at the time of the call. This value can be used by an item to implement
    ///support for group policy that prevents the item from being disabled. If this value is set, the <b>Disable</b>
    ///task is not shown in the handler's folder when this item is selected. The item should provide a
    ///comment—returned from its implementation of ISyncMgrSyncItemInfo::GetComment—to let the user know why the
    ///<b>Disable</b> task is not available. Most items should not set this value.
    SYNCMGR_IPM_PREVENT_DISABLE    = 0x00000002,
    ///Starting a sync through the user interface or through the APIs is not supported. Sync can be started only by an
    ///external application that creates a session creator to report progress. If this value is set, then the Start Sync
    ///task will not be shown in the handler's folder when the sync item is selected. Note that Start Sync must be
    ///supported on a handler in order for it to be supported on a sync item. Most sync items should not set this value.
    SYNCMGR_IPM_PREVENT_START_SYNC = 0x00000004,
    ///Stopping a sync through the user interface or through the APIs is not supported. If this value is set, the Stop
    ///Sync task is not shown in the handler's folder when the sync item is selected. Note that Stop Sync must be
    ///supported on a handler in order for it to be supported on a sync item. Most sync items should not set this value.
    SYNCMGR_IPM_PREVENT_STOP_SYNC  = 0x00000008,
    ///The enable task should be disabled when it is shown for this sync item. With this policy set, the <b>Enable</b>
    ///option appears in the context menu, if SYNCMGR_IPM_PREVENT_ENABLE is not set, but is disabled.
    SYNCMGR_IPM_DISABLE_ENABLE     = 0x00000010,
    ///The disable task should be disabled when it is shown for this sync item. With this policy set, the <b>Disable</b>
    ///option appears in the context menu, if SYNCMGR_IPM_PREVENT_DISABLE is not set, but is disabled.
    SYNCMGR_IPM_DISABLE_DISABLE    = 0x00000020,
    ///The Start Sync task should be disabled when it is shown for this sync item. With this policy set, the <b>Start
    ///Sync</b> option appears in the context menu, if SYNCMGR_IPM_PREVENT_START_SYNC is not set and if
    ///SYNCMGR_HPM_PREVENT_START_SYNC is not set on the handle, but is disabled.
    SYNCMGR_IPM_DISABLE_START_SYNC = 0x00000040,
    ///The <b>Stop Sync</b> task should be disabled when it is shown for this sync item. With this policy set, the
    ///<b>Stop Sync</b> option appears in the context menu, if SYNCMGR_IPM_PREVENT_STOP_SYNC is not set and if
    ///SYNCMGR_HPM_PREVENT_STOP_SYNC is not set on the handler, but is disabled.
    SYNCMGR_IPM_DISABLE_STOP_SYNC  = 0x00000080,
    ///The <b>Browse</b> task should be disabled when it is shown for this sync item. The <b>Browse</b> task is shown
    ///only if the SYNCMGR_ICM_CAN_BROWSE_CONTENT value is returned from the ISyncMgrSyncItem::GetCapabilities method.
    SYNCMGR_IPM_DISABLE_BROWSE     = 0x00000100,
    ///The handler normally supports deleting items, but that this item cannot be deleted at the time of the call. With
    ///this policy set, the <b>Delete</b> option appears as disabled in the context menu for the sync item.
    SYNCMGR_IPM_DISABLE_DELETE     = 0x00000200,
    ///The item should be hidden from the user unless the <b>Show Hidden Files</b> option has been enabled. This policy
    ///only applies the first time the item is loaded. After that, the hidden state is maintained by Sync Center and can
    ///be changed by the user through the property sheet.
    SYNCMGR_IPM_HIDDEN_BY_DEFAULT  = 0x00010000,
    SYNCMGR_IPM_VALID_MASK         = 0x000102ff,
}

///Specifies the current progress status of a synchronization process. Used by ISyncMgrSyncCallback::ReportProgress.
alias SYNCMGR_PROGRESS_STATUS = int;
enum : int
{
    ///The progress status is currently being updated by the handler.
    SYNCMGR_PS_UPDATING               = 0x00000001,
    ///Ignore step parameters. The progress bar cycles from left to right on a timer internal to the sync folder. This
    ///is known as marquee mode.
    SYNCMGR_PS_UPDATING_INDETERMINATE = 0x00000002,
    ///The synchronization is complete.
    SYNCMGR_PS_SUCCEEDED              = 0x00000003,
    ///Indicates something went wrong during the synchronization.
    SYNCMGR_PS_FAILED                 = 0x00000004,
    ///The user canceled the synchronization before it completed. Upon receipt of this value, Sync Center updates the UI
    ///and enables the option to restart the sync for that item.
    SYNCMGR_PS_CANCELED               = 0x00000005,
    ///The device being synchronized was disconnected before the sync completed..
    SYNCMGR_PS_DISCONNECTED           = 0x00000006,
    SYNCMGR_PS_MAX                    = 0x00000006,
}

///Describes a request by the user to cancel a synchronization.
alias SYNCMGR_CANCEL_REQUEST = int;
enum : int
{
    ///No cancelation request has been made.
    SYNCMGR_CR_NONE        = 0x00000000,
    ///Stop the synchronization of the current item, but continue the synchronization of other items.
    SYNCMGR_CR_CANCEL_ITEM = 0x00000001,
    ///Stop the synchronization entirely.
    SYNCMGR_CR_CANCEL_ALL  = 0x00000002,
    SYNCMGR_CR_MAX         = 0x00000002,
}

///Specifies the type of event being reported to Sync Center.
alias SYNCMGR_EVENT_LEVEL = int;
enum : int
{
    ///The event is informational in nature and will be displayed with the appropriate icon.
    SYNCMGR_EL_INFORMATION = 0x00000001,
    ///The event is a warning and will be displayed with the appropriate icon.
    SYNCMGR_EL_WARNING     = 0x00000002,
    ///The event is an error and will be displayed with the appropriate icon. Additionally, this event will be included
    ///in the count of errors reported to the handler or item when it is displayed in the folder as well as to the sync
    ///tray icon.
    SYNCMGR_EL_ERROR       = 0x00000003,
    SYNCMGR_EL_MAX         = 0x00000003,
}

///Specifies flags for a synchronization event.
alias SYNCMGR_EVENT_FLAGS = int;
enum : int
{
    ///No flags specified.
    SYNCMGR_EF_NONE  = 0x00000000,
    SYNCMGR_EF_VALID = 0x00000000,
}

///Specifies how an operation requested on certain methods of ISyncMgrControl should be performed.
alias SYNCMGR_CONTROL_FLAGS = int;
enum : int
{
    ///Perform the operation not using any of the other flags in this enumeration.
    SYNCMGR_CF_NONE   = 0x00000000,
    ///Perform the operation asynchronously.
    SYNCMGR_CF_NOWAIT = 0x00000000,
    ///Perform the operation synchronously.
    SYNCMGR_CF_WAIT   = 0x00000001,
    ///Perform the operation without asking the sync handler to display the UI during the operation.
    SYNCMGR_CF_NOUI   = 0x00000002,
    SYNCMGR_CF_VALID  = 0x00000003,
}

///Indicates flags used by ISyncMgrControl::StartHandlerSync and ISyncMgrControl::StartItemSync.
alias SYNCMGR_SYNC_CONTROL_FLAGS = int;
enum : int
{
    ///Sync all items, regardless of whether they were just synced.
    SYNCMGR_SCF_NONE                      = 0x00000000,
    ///Sync only items that are not currently syncing.
    SYNCMGR_SCF_IGNORE_IF_ALREADY_SYNCING = 0x00000001,
    ///A mask used to retrieve or verify valid SYNCMGR_SYNC_CONTROL_FLAGS flags.
    SYNCMGR_SCF_VALID                     = 0x00000001,
}

alias SYNCMGR_UPDATE_REASON = int;
enum : int
{
    SYNCMGR_UR_ADDED   = 0x00000000,
    SYNCMGR_UR_CHANGED = 0x00000001,
    SYNCMGR_UR_REMOVED = 0x00000002,
    SYNCMGR_UR_MAX     = 0x00000002,
}

///Describes conflict item type.
alias SYNCMGR_CONFLICT_ITEM_TYPE = int;
enum : int
{
    ///The conflict item was updated.
    SYNCMGR_CIT_UPDATED = 0x00000001,
    SYNCMGR_CIT_DELETED = 0x00000002,
}

///Indicates abilities and the conflict resolution activity to follow. Used with
///ISyncMgrResolutionHandler::QueryAbilities.
alias SYNCMGR_RESOLUTION_ABILITIES = int;
enum : int
{
    ///The resolution handler supports merging items and will produce a merged file to keep.
    SYNCMGR_RA_KEEPOTHER         = 0x00000001,
    ///Enables methods ISyncMgrResolutionHandler::KeepRecent and ISyncMgrResolutionHandler::KeepOther to be called.
    SYNCMGR_RA_KEEPRECENT        = 0x00000002,
    ///Enables method ISyncMgrResolutionHandler::RemoveFromSyncSet to be called.
    SYNCMGR_RA_REMOVEFROMSYNCSET = 0x00000004,
    ///Not used.
    SYNCMGR_RA_KEEP_SINGLE       = 0x00000008,
    ///Enables method ISyncMgrResolutionHandler::KeepItems to be called with more than one item in <i>pArray</i>.
    SYNCMGR_RA_KEEP_MULTIPLE     = 0x00000010,
    SYNCMGR_RA_VALID             = 0x0000001f,
}

///Describes Sync Manager resolution feedback. Used by ISyncMgrResolutionHandler.
alias SYNCMGR_RESOLUTION_FEEDBACK = int;
enum : int
{
    ///Proceed to the next conflict.
    SYNCMGR_RF_CONTINUE = 0x00000000,
    ///<b>Apply to All</b> is stopped and the dialog will be displayed for this conflict.
    SYNCMGR_RF_REFRESH  = 0x00000001,
    SYNCMGR_RF_CANCEL   = 0x00000002,
}

///Describes the next step that is to occur in sync manager conflict resolution. Used by ISyncMgrConflictPresenter.
alias SYNCMGR_PRESENTER_NEXT_STEP = int;
enum : int
{
    ///The conflict has been resolved and subsequent selected conflicts should continue to be resolved.
    SYNCMGR_PNS_CONTINUE = 0x00000000,
    ///The default conflict presenter should be used.
    SYNCMGR_PNS_DEFAULT  = 0x00000001,
    ///All conflict resolution should be canceled.
    SYNCMGR_PNS_CANCEL   = 0x00000002,
}

///Describes what choice a user makes about a sync manager conflict resolution. Used by ISyncMgrConflictPresenter.
alias SYNCMGR_PRESENTER_CHOICE = int;
enum : int
{
    ///The user is skipping this conflict, or conflict resolution is being canceled.
    SYNCMGR_PC_NO_CHOICE            = 0x00000000,
    ///The user chooses to keep only one item.
    SYNCMGR_PC_KEEP_ONE             = 0x00000001,
    ///The user chooses to keep multiple items.
    SYNCMGR_PC_KEEP_MULTIPLE        = 0x00000002,
    ///The user chooses to keep the most recent item.
    SYNCMGR_PC_KEEP_RECENT          = 0x00000003,
    ///The item is to be removed from the sync set.
    SYNCMGR_PC_REMOVE_FROM_SYNC_SET = 0x00000004,
    ///The item is not being resolved now but is instead being skipped so that it can be resolved later.
    SYNCMGR_PC_SKIP                 = 0x00000005,
}

///Values used by IThumbnailCache::GetThumbnail to specify options for the extraction and display of the thumbnail
///image.
alias WTS_FLAGS = int;
enum : int
{
    ///0x00000000. <b>Introduced in Windows 8</b>. None of the following options are set.
    WTS_NONE                 = 0x00000000,
    ///Default. 0x00000000. Extract the thumbnail if it is not cached.
    WTS_EXTRACT              = 0x00000000,
    ///0x00000001. Only return the thumbnail if it is cached.
    WTS_INCACHEONLY          = 0x00000001,
    ///0x00000002. If not cached, only extract the thumbnail if it is embedded in EXIF format, typically 96x96.
    WTS_FASTEXTRACT          = 0x00000002,
    ///0x00000004. Ignore cache and extract thumbnail from source file.
    WTS_FORCEEXTRACTION      = 0x00000004,
    ///0x00000008. The thumbnail has an extended lifetime. Use for volumes that might go offline, like non-fixed disks.
    WTS_SLOWRECLAIM          = 0x00000008,
    ///0x00000020. Extract but do not add the thumbnail to the cache.
    WTS_EXTRACTDONOTCACHE    = 0x00000020,
    ///0x00000040. <b>Introduced in Windows 7</b>. If the specific thumbnail size requested in the
    ///<i>cxyRequestedThumbSize</i> parameter is not available, resize the thumbnail to the requested size. If possible,
    ///a larger bitmap is reduced in scale, preserving its aspect ratio, to the width and height required. If the only
    ///available cached thumbnail is smaller than the requested size, then it is scaled up using the nearest-neighbor
    ///algorithm.
    WTS_SCALETOREQUESTEDSIZE = 0x00000040,
    ///0x00000080. <b>Introduced in Windows 7</b>. Do not extract a thumbnail embedded in the metadata of an EXIF image.
    WTS_SKIPFASTEXTRACT      = 0x00000080,
    ///0x00000100. <b>Introduced in Windows 7</b>. Ensures that the thumbnail handler is loaded in the same process as
    ///the caller. When this flag is not specified, the handler is loaded into a surrogate process to protect the caller
    ///from unexpected crashes caused by the processing of the target file. Use this value when debugging thumbnail
    ///extractors.
    WTS_EXTRACTINPROC        = 0x00000100,
    ///0x00000200. <b>Introduced in Windows 8</b>. If necessary, crop the bitmap's dimensions so that is square. The
    ///length of the shortest side becomes the length of all sides.
    WTS_CROPTOSQUARE         = 0x00000200,
    ///0x00000400. <b>Introduced in Windows 8</b>. Create a surrogate for this instance of the cache rather than using
    ///the shared DLLHost surrogate.
    WTS_INSTANCESURROGATE    = 0x00000400,
    ///0x00000800. <b>Introduced in Windows 8</b>. Require extractions to take place in the surrogate.
    WTS_REQUIRESURROGATE     = 0x00000800,
    ///0x00002000. <b>Windows 8 and later</b>. Pass the WTSCF_APPSTYLE flag to IThumbnailSettings::SetContext, if the
    ///provider supports it.
    WTS_APPSTYLE             = 0x00002000,
    ///0x00004000. <b>Windows 8 and later</b>. Stretch and crop the bitmap so that its height is 0.7 times its width.
    WTS_WIDETHUMBNAILS       = 0x00004000,
    ///0x00008000. <b>Windows 8 and later</b>. Return from the ideal cache snap size only. The returned image might be
    ///larger, but it will be pulled from the correct cache entry.
    WTS_IDEALCACHESIZEONLY   = 0x00008000,
    ///0x00010000. <b>Windows 8 and later</b>. If necessary, stretch the image so that the height and width fit the
    ///given size.
    WTS_SCALEUP              = 0x00010000,
}

alias WTS_CACHEFLAGS = int;
enum : int
{
    WTS_DEFAULT    = 0x00000000,
    WTS_LOWQUALITY = 0x00000001,
    WTS_CACHED     = 0x00000002,
}

///Specifies the context of a thumbnail extraction. Used by IThumbnailSettings::SetContext. Your thumbnail provider will
///set this flag based on the WTS_FLAGS values that it received through the IThumbnailProvider::GetThumbnail request.
alias WTS_CONTEXTFLAGS = int;
enum : int
{
    ///None of the following options are set. Set in response to WTS_NONE.
    WTSCF_DEFAULT  = 0x00000000,
    ///Provide a thumbnail suitable to the Windows Store app UX guidelines. Set in response to WTS_APPSTYLE.
    WTSCF_APPSTYLE = 0x00000001,
    ///If necessary, crop the bitmap's dimensions so that is square. The length of the shortest side becomes the length
    ///of all sides. Set in response to WTS_CROPTOSQUARE.
    WTSCF_SQUARE   = 0x00000002,
    ///Stretch and crop the bitmap so that its height is 0.7 times its width. Set in response to WTS_WIDETHUMBNAILS.
    WTSCF_WIDE     = 0x00000004,
    WTSCF_FAST     = 0x00000008,
}

alias WTS_ALPHATYPE = int;
enum : int
{
    WTSAT_UNKNOWN = 0x00000000,
    WTSAT_RGB     = 0x00000001,
    WTSAT_ARGB    = 0x00000002,
}

///Used in the ISyncMgrSynchronize::SetItemStatus method to specify the updated status for the item.
alias SYNCMGRSTATUS = int;
enum : int
{
    ///Synchronization has been stopped.
    SYNCMGRSTATUS_STOPPED                = 0x00000000,
    ///Indicates that this item should be skipped.
    SYNCMGRSTATUS_SKIPPED                = 0x00000001,
    ///Synchronization for the item is pending.
    SYNCMGRSTATUS_PENDING                = 0x00000002,
    ///The item is currently being synchronized.
    SYNCMGRSTATUS_UPDATING               = 0x00000003,
    ///The synchronization for the item succeeded.
    SYNCMGRSTATUS_SUCCEEDED              = 0x00000004,
    ///Synchronization for the item failed.
    SYNCMGRSTATUS_FAILED                 = 0x00000005,
    ///Synchronization for the item paused.
    SYNCMGRSTATUS_PAUSED                 = 0x00000006,
    ///Synchronization for the item is resuming.
    SYNCMGRSTATUS_RESUMING               = 0x00000007,
    ///<b>Windows Vista and later</b>. Shows marquee progress for the synchronized item. Sets the progress bar in the
    ///folder to marquee the synchronization progress.
    SYNCMGRSTATUS_UPDATING_INDETERMINATE = 0x00000008,
    ///The item has been deleted. This value has been deprecated for Windows Vista and later.
    SYNCMGRSTATUS_DELETED                = 0x00000100,
}

///The <b>SYNCMGRLOGLEVEL</b> enumeration values specify an error level for use in the
///ISyncMgrSynchronizeCallback::LogError method.
alias SYNCMGRLOGLEVEL = int;
enum : int
{
    ///An information message was logged.
    SYNCMGRLOGLEVEL_INFORMATION = 0x00000001,
    ///A warning message was logged.
    SYNCMGRLOGLEVEL_WARNING     = 0x00000002,
    ///An error message was logged.
    SYNCMGRLOGLEVEL_ERROR       = 0x00000003,
    ///The largest valid SYNCMGRLOGLEVEL value.
    SYNCMGRLOGLEVEL_LOGLEVELMAX = 0x00000003,
}

alias SYNCMGRERRORFLAGS = int;
enum : int
{
    SYNCMGRERRORFLAG_ENABLEJUMPTEXT = 0x00000001,
}

///Specifies information for the current item in the SYNCMGRITEM structure.
alias SYNCMGRITEMFLAGS = int;
enum : int
{
    ///The item has a properties dialog.
    SYNCMGRITEM_HASPROPERTIES  = 0x00000001,
    ///The item is temporary and any stored preferences can be removed. This value is defined but not used in Windows
    ///Vista.
    SYNCMGRITEM_TEMPORARY      = 0x00000002,
    ///The item roams with the user and is not specific to a machine. This value is defined but is ignored by both
    ///Windows XP and Windows Vista.
    SYNCMGRITEM_ROAMINGUSER    = 0x00000004,
    ///The LastUpdateTime field is valid.
    SYNCMGRITEM_LASTUPDATETIME = 0x00000008,
    ///The item may be deleted. This value has been deprecated for Windows Vista and later. This value is defined but is
    ///ignored by both Windows XP and Windows Vista.
    SYNCMGRITEM_MAYDELETEITEM  = 0x00000010,
    ///<b>Windows Vista and later</b>. Not supported.
    SYNCMGRITEM_HIDDEN         = 0x00000020,
}

///The <b>SYNCMGRFLAG</b> enumeration values are used in the ISyncMgrSynchronize::Initialize method to indicate how the
///synchronization event was initiated.
alias SYNCMGRFLAG = int;
enum : int
{
    ///Synchronization was initiated by a network connect event.
    SYNCMGRFLAG_CONNECT           = 0x00000001,
    ///Synchronization was initiated by a pending network disconnect event.
    SYNCMGRFLAG_PENDINGDISCONNECT = 0x00000002,
    ///Synchronization was initiated manually by the end user.
    SYNCMGRFLAG_MANUAL            = 0x00000003,
    ///Synchronization was programmatically invoked.
    SYNCMGRFLAG_IDLE              = 0x00000004,
    ///Synchronization was programmatically invoked.
    SYNCMGRFLAG_INVOKE            = 0x00000005,
    ///Synchronization was initiated by a scheduled update event.
    SYNCMGRFLAG_SCHEDULED         = 0x00000006,
    ///Synchronization mask value.
    SYNCMGRFLAG_EVENTMASK         = 0x000000ff,
    ///Synchronization was initiated for configuration purposes only in the <b>System Properties</b> dialog box.
    SYNCMGRFLAG_SETTINGS          = 0x00000100,
    ///Interaction with the user is permitted. The application is allowed to show user interface elements and interact
    ///with the user. If this flag is not set, the application must not display any user interface elements other than
    ///using the ISyncMgrSynchronizeCallback interface. If an application cannot complete the synchronization without
    ///displaying user interface elements and this flag is not set, the application fails the synchronization.
    SYNCMGRFLAG_MAYBOTHERUSER     = 0x00000200,
}

///Used in the SYNCMGRHANDLERINFO structure as flags that apply to the current handler.
alias SYNCMGRHANDLERFLAGS = int;
enum : int
{
    ///The current handler provides a property sheet dialog.
    SYNCMGRHANDLER_HASPROPERTIES          = 0x00000001,
    ///May call back the ISyncMgrSynchronizeCallback::EstablishConnection method. This value is ignored in <b>Windows
    ///Vista and later</b>.
    SYNCMGRHANDLER_MAYESTABLISHCONNECTION = 0x00000002,
    ///Indicates Show Handler in Choice even if items are not shown. This value is ignored in <b>Windows Vista and
    ///later</b>.
    SYNCMGRHANDLER_ALWAYSLISTHANDLER      = 0x00000004,
    ///<b>Windows Vista and later</b>. Do not display handler or item. This value is ignored by <b>Windows Vista</b>.
    SYNCMGRHANDLER_HIDDEN                 = 0x00000008,
}

alias SYNCMGRITEMSTATE = int;
enum : int
{
    SYNCMGRITEMSTATE_UNCHECKED = 0x00000000,
    SYNCMGRITEMSTATE_CHECKED   = 0x00000001,
}

///The <b>SYNCMGRINVOKEFLAGS</b> enumeration value specifies how the Sync Manager is to be invoked in the
///ISyncMgrSynchronizeInvoke::UpdateItems method.
alias SYNCMGRINVOKEFLAGS = int;
enum : int
{
    ///Immediately start the synchronization without displaying the <b>Choice</b> dialog box.
    SYNCMGRINVOKE_STARTSYNC = 0x00000002,
    ///Indicates that the <b>Choice</b> dialog should be minimized by default.
    SYNCMGRINVOKE_MINIMIZED = 0x00000004,
}

///The <b>SYNCMGRREGISTERFLAGS</b> enumeration values are used in methods of the ISyncMgrRegister interface to identify
///events for which the handler is registered to be notified.
alias SYNCMGRREGISTERFLAGS = int;
enum : int
{
    ///Network connect events.
    SYNCMGRREGISTERFLAG_CONNECT           = 0x00000001,
    ///Pending network disconnect event.
    SYNCMGRREGISTERFLAG_PENDINGDISCONNECT = 0x00000002,
    ///Idle events.
    SYNCMGRREGISTERFLAG_IDLE              = 0x00000004,
}

///Defines the cache options used by the IThumbnailStreamCache interface.
enum ThumbnailStreamCacheOptions : int
{
    ///Return the cached thumbnail if it is already cached, otherwise extract the thumbnail to the cache.
    ExtractIfNotCached = 0x00000000,
    ///Return the thumbnail only if it is already cached.
    ReturnOnlyIfCached = 0x00000001,
    ///Resize the thumbnail to match the requested size.
    ResizeThumbnail    = 0x00000002,
    ///Can return a cached thumbnail that is smaller than the requested size.
    AllowSmallerSize   = 0x00000004,
}

alias tagTLENUMF = int;
enum : int
{
    TLEF_RELATIVE_INCLUDE_CURRENT = 0x00000001,
    TLEF_RELATIVE_BACK            = 0x00000010,
    TLEF_RELATIVE_FORE            = 0x00000020,
    TLEF_INCLUDE_UNINVOKEABLE     = 0x00000040,
    TLEF_ABSOLUTE                 = 0x00000031,
    TLEF_EXCLUDE_SUBFRAME_ENTRIES = 0x00000080,
    TLEF_EXCLUDE_ABOUT_PAGES      = 0x00000100,
}

alias _HLSR_NOREDEF10 = int;
enum : int
{
    HLSR_HOME          = 0x00000000,
    HLSR_SEARCHPAGE    = 0x00000001,
    HLSR_HISTORYFOLDER = 0x00000002,
}

alias _HLSHORTCUTF__NOREDEF10 = int;
enum : int
{
    HLSHORTCUTF_DEFAULT                     = 0x00000000,
    HLSHORTCUTF_DONTACTUALLYCREATE          = 0x00000001,
    HLSHORTCUTF_USEFILENAMEFROMFRIENDLYNAME = 0x00000002,
    HLSHORTCUTF_USEUNIQUEFILENAME           = 0x00000004,
    HLSHORTCUTF_MAYUSEEXISTINGSHORTCUT      = 0x00000008,
}

alias _HLTRANSLATEF_NOREDEF10 = int;
enum : int
{
    HLTRANSLATEF_DEFAULT                = 0x00000000,
    HLTRANSLATEF_DONTAPPLYDEFAULTPREFIX = 0x00000001,
}

alias __MIDL_IHlink_0001 = int;
enum : int
{
    HLNF_INTERNALJUMP          = 0x00000001,
    HLNF_OPENINNEWWINDOW       = 0x00000002,
    HLNF_NAVIGATINGBACK        = 0x00000004,
    HLNF_NAVIGATINGFORWARD     = 0x00000008,
    HLNF_NAVIGATINGTOSTACKITEM = 0x00000010,
    HLNF_CREATENOHISTORY       = 0x00000020,
}

alias __MIDL_IHlink_0002 = int;
enum : int
{
    HLINKGETREF_DEFAULT  = 0x00000000,
    HLINKGETREF_ABSOLUTE = 0x00000001,
    HLINKGETREF_RELATIVE = 0x00000002,
}

alias __MIDL_IHlink_0003 = int;
enum : int
{
    HLFNAMEF_DEFAULT          = 0x00000000,
    HLFNAMEF_TRYCACHE         = 0x00000001,
    HLFNAMEF_TRYPRETTYTARGET  = 0x00000002,
    HLFNAMEF_TRYFULLTARGET    = 0x00000004,
    HLFNAMEF_TRYWIN95SHORTCUT = 0x00000008,
}

alias __MIDL_IHlink_0004 = int;
enum : int
{
    HLINKMISC_RELATIVE = 0x00000001,
}

alias __MIDL_IHlink_0005 = int;
enum : int
{
    HLINKSETF_TARGET   = 0x00000001,
    HLINKSETF_LOCATION = 0x00000002,
}

alias __MIDL_IHlinkSite_0001 = int;
enum : int
{
    HLINKWHICHMK_CONTAINER = 0x00000001,
    HLINKWHICHMK_BASE      = 0x00000002,
}

alias __MIDL_IHlinkBrowseContext_0001 = int;
enum : int
{
    HLTB_DOCKEDLEFT   = 0x00000000,
    HLTB_DOCKEDTOP    = 0x00000001,
    HLTB_DOCKEDRIGHT  = 0x00000002,
    HLTB_DOCKEDBOTTOM = 0x00000003,
    HLTB_FLOATING     = 0x00000004,
}

alias __MIDL_IHlinkBrowseContext_0002 = int;
enum : int
{
    HLBWIF_HASFRAMEWNDINFO   = 0x00000001,
    HLBWIF_HASDOCWNDINFO     = 0x00000002,
    HLBWIF_FRAMEWNDMAXIMIZED = 0x00000004,
    HLBWIF_DOCWNDMAXIMIZED   = 0x00000008,
    HLBWIF_HASWEBTOOLBARINFO = 0x00000010,
    HLBWIF_WEBTOOLBARHIDDEN  = 0x00000020,
}

alias __MIDL_IHlinkBrowseContext_0003 = int;
enum : int
{
    HLID_INVALID     = 0x00000000,
    HLID_PREVIOUS    = 0xffffffff,
    HLID_NEXT        = 0xfffffffe,
    HLID_CURRENT     = 0xfffffffd,
    HLID_STACKBOTTOM = 0xfffffffc,
    HLID_STACKTOP    = 0xfffffffb,
}

alias __MIDL_IHlinkBrowseContext_0004 = int;
enum : int
{
    HLQF_ISVALID   = 0x00000001,
    HLQF_ISCURRENT = 0x00000002,
}

///Deprecated. Used by IBrowserService::SetNavigateState and IBrowserService::GetNavigateState to specify navigation
///states.
alias BNSTATE = int;
enum : int
{
    ///Indicates the normal state.
    BNS_NORMAL         = 0x00000000,
    ///A begin navigation event has occurred.
    BNS_BEGIN_NAVIGATE = 0x00000001,
    BNS_NAVIGATE       = 0x00000002,
}

alias SHELLBROWSERSHOWCONTROL = int;
enum : int
{
    SBSC_HIDE   = 0x00000000,
    SBSC_SHOW   = 0x00000001,
    SBSC_TOGGLE = 0x00000002,
    SBSC_QUERY  = 0x00000003,
}

///Deprecated. This enumeration is used by the BASEBROWSERDATA structure to indicate the base browser's lock icon
///status.
alias SECURELOCKCODE = int;
enum : int
{
    ///No change in security encryption status.
    SECURELOCK_NOCHANGE                 = 0xffffffff,
    ///There is no security encryption present.
    SECURELOCK_SET_UNSECURE             = 0x00000000,
    ///There are multiple security encryption methods present.
    SECURELOCK_SET_MIXED                = 0x00000001,
    ///The security encryption level is not known.
    SECURELOCK_SET_SECUREUNKNOWNBIT     = 0x00000002,
    ///There is 40-bit security encryption present.
    SECURELOCK_SET_SECURE40BIT          = 0x00000003,
    ///There is 56-bit security encryption present.
    SECURELOCK_SET_SECURE56BIT          = 0x00000004,
    ///There is Fortezza security encryption present.
    SECURELOCK_SET_FORTEZZA             = 0x00000005,
    ///There is 128-bit security encryption present.
    SECURELOCK_SET_SECURE128BIT         = 0x00000006,
    ///Suggest a security encryption setting.
    SECURELOCK_FIRSTSUGGEST             = 0x00000007,
    ///No security encryption has been suggested.
    SECURELOCK_SUGGEST_UNSECURE         = 0x00000007,
    ///Mixed security encryption methods have been suggested.
    SECURELOCK_SUGGEST_MIXED            = 0x00000008,
    ///An unknown security encryption method has been suggested.
    SECURELOCK_SUGGEST_SECUREUNKNOWNBIT = 0x00000009,
    ///A 40-bit security encryption has been suggested.
    SECURELOCK_SUGGEST_SECURE40BIT      = 0x0000000a,
    ///A 56-bit security encryption has been suggested.
    SECURELOCK_SUGGEST_SECURE56BIT      = 0x0000000b,
    ///A Fortezza security encryption has been suggested.
    SECURELOCK_SUGGEST_FORTEZZA         = 0x0000000c,
    SECURELOCK_SUGGEST_SECURE128BIT     = 0x0000000d,
}

alias IEPDNFLAGS = int;
enum : int
{
    IEPDN_BINDINGUI = 0x00000001,
}

alias TI_FLAGS = int;
enum : int
{
    TI_BITMAP = 0x00000001,
    TI_JPEG   = 0x00000002,
}

alias PATHCCH_OPTIONS = int;
enum : int
{
    PATHCCH_NONE                            = 0x00000000,
    PATHCCH_ALLOW_LONG_PATHS                = 0x00000001,
    PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS  = 0x00000002,
    PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS = 0x00000004,
    PATHCCH_DO_NOT_NORMALIZE_SEGMENTS       = 0x00000008,
    PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH  = 0x00000010,
    PATHCCH_ENSURE_TRAILING_SLASH           = 0x00000020,
}

alias iurl_seturl_flags = int;
enum : int
{
    IURL_SETURL_FL_GUESS_PROTOCOL       = 0x00000001,
    IURL_SETURL_FL_USE_DEFAULT_PROTOCOL = 0x00000002,
}

alias iurl_invokecommand_flags = int;
enum : int
{
    IURL_INVOKECOMMAND_FL_ALLOW_UI         = 0x00000001,
    IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB = 0x00000002,
    IURL_INVOKECOMMAND_FL_DDEWAIT          = 0x00000004,
    IURL_INVOKECOMMAND_FL_ASYNCOK          = 0x00000008,
    IURL_INVOKECOMMAND_FL_LOG_USAGE        = 0x00000010,
}

///The <b>TRANSLATEURL_IN_FLAGS</b> enumerated values are used with the TranslateURL function to determine how it will
///execute.
alias translateurl_in_flags = int;
enum : int
{
    ///If the protocol scheme is not specified in the <i>pcszURL</i> parameter to TranslateURL, the system automatically
    ///chooses a scheme and adds it to the URL.
    TRANSLATEURL_FL_GUESS_PROTOCOL       = 0x00000001,
    TRANSLATEURL_FL_USE_DEFAULT_PROTOCOL = 0x00000002,
}

///The <b>URLASSOCIATIONDIALOG_IN_FLAGS</b> enumerated values are used with URLAssociationDialog to determine how it
///executes.
alias urlassociationdialog_in_flags = int;
enum : int
{
    ///Use the default file name (that is, "Internet Shortcut").
    URLASSOCDLG_FL_USE_DEFAULT_NAME = 0x00000001,
    URLASSOCDLG_FL_REGISTER_ASSOC   = 0x00000002,
}

///Used with the MIMEAssociationDialog function to determine how it executes.
alias mimeassociationdialog_in_flags = int;
enum : int
{
    ///If this bit is set, the selected application is registered as the handler for the given MIME type. If this bit is
    ///clear, no association is registered.
    MIMEASSOCDLG_FL_REGISTER_ASSOC = 0x00000001,
}

///Specifies types of Shell windows.
enum ShellWindowTypeConstants : int
{
    ///An Windows Explorer (Explorer.exe) window.
    SWC_EXPLORER = 0x00000000,
    ///An Internet Explorer (Iexplore.exe) browser window.
    SWC_BROWSER  = 0x00000001,
    ///A non-Microsoft browser window.
    SWC_3RDPARTY = 0x00000002,
    ///A creation callback window.
    SWC_CALLBACK = 0x00000004,
    ///<b>Windows Vista and later</b>. The Windows desktop.
    SWC_DESKTOP  = 0x00000008,
}

///Specifies options for finding window in the Shell windows collection.
enum ShellWindowFindWindowOptions : int
{
    ///The window must have an IDispatch interface.
    SWFO_NEEDDISPATCH   = 0x00000001,
    ///Include windows that were registered with IShellWindows::RegisterPending.
    SWFO_INCLUDEPENDING = 0x00000002,
    ///Causes IShellWindows::FindWindowSW to interpret <i>pvarLoc</i> as a cookie rather than a PIDL.
    SWFO_COOKIEPASSED   = 0x00000004,
}

// Constants


enum : int
{
    GPFIDL_DEFAULT    = 0x00000000,
    GPFIDL_ALTNAME    = 0x00000001,
    GPFIDL_UNCPRINTER = 0x00000002,
}

enum : int
{
    ISHCUTCMDID_INTSHORTCUTCREATE = 0x00000001,
    ISHCUTCMDID_COMMITHISTORY     = 0x00000002,
    ISHCUTCMDID_SETUSERAWURL      = 0x00000003,
}

enum : int
{
    DBCID_EMPTY      = 0x00000000,
    DBCID_ONDRAG     = 0x00000001,
    DBCID_CLSIDOFBAR = 0x00000002,
}

enum int DBCID_GETBAR = 0x00000004;
enum int BMICON_SMALL = 0x00000001;

enum : int
{
    ASSOCF_INIT_NOREMAPCLSID = 0x00000001,
    ASSOCF_INIT_BYEXENAME    = 0x00000002,
}

enum : int
{
    ASSOCF_INIT_DEFAULTTOSTAR   = 0x00000004,
    ASSOCF_INIT_DEFAULTTOFOLDER = 0x00000008,
}

enum : int
{
    ASSOCF_NOTRUNCATE  = 0x00000020,
    ASSOCF_VERIFY      = 0x00000040,
    ASSOCF_REMAPRUNDLL = 0x00000080,
}

enum int ASSOCF_IGNOREBASECLASS = 0x00000200;
enum int ASSOCF_INIT_FIXED_PROGID = 0x00000800;
enum int ASSOCF_INIT_FOR_FILE = 0x00002000;
enum int ASSOCF_PER_MACHINE_ONLY = 0x00008000;
enum int CTF_INSIST = 0x00000001;
enum int CTF_PROCESS_REF = 0x00000004;
enum int CTF_COINIT = 0x00000008;
enum int CTF_REF_COUNTED = 0x00000020;
enum int CTF_UNUSED = 0x00000080;
enum int CTF_WAIT_NO_REENTRANCY = 0x00000200;
enum int CTF_OLEINITIALIZE = 0x00000800;
enum int CTF_NOADDREFLIB = 0x00002000;

// Callbacks

///Defines the prototype for the callback function used by RemoveWindowSubclass and SetWindowSubclass.
///Params:
///    hWnd = Type: <b>HWND</b> The handle to the subclassed window.
///    uMsg = Type: <b>UINT</b> The message being passed.
///    wParam = Type: <b>WPARAM</b> Additional message information. The contents of this parameter depend on the value of
///             <i>uMsg</i>.
///    lParam = Type: <b>LPARAM</b> Additional message information. The contents of this parameter depend on the value of
///             <i>uMsg</i>.
///    uIdSubclass = Type: <b>UINT_PTR</b> The subclass ID.
///    dwRefData = Type: <b>DWORD_PTR</b> The reference data provided to the SetWindowSubclass function. This can be used to
///                associate the subclass instance with a "this" pointer.
alias SUBCLASSPROC = LRESULT function(HWND hWnd, uint uMsg, WPARAM wParam, LPARAM lParam, size_t uIdSubclass, 
                                      size_t dwRefData);
alias PFNCANSHAREFOLDERW = HRESULT function(const(wchar)* pszPath);
alias PFNSHOWSHAREFOLDERUIW = HRESULT function(HWND hwndParent, const(wchar)* pszPath);
alias LPFNSVADDPROPSHEETPAGE = BOOL function();
///<p class="CCE_Message">[<b>LPFNDFMCALLBACK</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Defines the prototype for the
///callback function that receives messages from the Shell's default context menu implementation.
///Params:
///    psf = Type: <b>IShellFolder*</b> A pointer to the IShellFolder object the message applies to. This value can be
///          <b>NULL</b>.
///    hwnd = Type: <b>HWND</b> The handle of the window that contains the view. This value can be <b>NULL</b>.
///    pdtobj = Type: <b>IDataObject*</b> IDataObject that represents the selection the context menu is based on. This value can
///             be <b>NULL</b>.
///    uMsg = Type: <b>UINT</b> One of the following notifications. <table class="clsStd"> <tr> <th>Notification</th>
///           <th>Usage</th> </tr> <tr> <td> DFM_MERGECONTEXTMENU </td> <td>Sent by the default context menu implementation to
///           allow <b>LPFNDFMCALLBACK</b> to add items to the menu.</td> </tr> <tr> <td> DFM_INVOKECOMMAND </td> <td>Sent by
///           the default context menu implementation to request <b>LPFNDFMCALLBACK</b> to invoke a menu command.</td> </tr>
///           <tr> <td> DFM_GETDEFSTATICID </td> <td>Sent by the default context menu implementation when the default menu
///           command is being created, allowing an alternate choice to be made.</td> </tr> </table>
///    wParam = Type: <b>WPARAM</b> Additional information. See the individual notification pages for specific requirements.
///    lParam = Type: <b>LPARAM</b> Additional information. See the individual notification pages for specific requirements.
alias LPFNDFMCALLBACK = HRESULT function(IShellFolder psf, HWND hwnd, IDataObject pdtobj, uint uMsg, WPARAM wParam, 
                                         LPARAM lParam);
///<p class="CCE_Message">[This interface is supported through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be unsupported in subsequent versions of Windows.] Defines the prototype for the callback function used by
///the system folder view object. This function essentially duplicates the functionality of IShellFolderViewCB.
///Params:
///    psvOuter = Type: <b>IShellView*</b> A pointer to the owning instance of IShellView, if applicable. This parameter can be
///               <b>NULL</b>.
///    psf = Type: <b>IShellFolder*</b> A pointer to the instance of IShellFolder the message applies to.
///    hwndMain = Type: <b>HWND</b> The handle of the window that contains the view that receives the message.
///    uMsg = Type: <b>UINT</b> One of the following notifications.
///    wParam = Type: <b>WPARAM</b> Additional information dependent on the value in <i>uMsg</i>. See the individual notification
///             pages for specific requirements.
///    lParam = Type: <b>LPARAM</b> Additional information dependent on the value in <i>uMsg</i>. See the individual notification
///             pages for specific requirements.
///Returns:
///    Type: <b>HRESULT</b> If this callback function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias LPFNVIEWCALLBACK = HRESULT function(IShellView psvOuter, IShellFolder psf, HWND hwndMain, uint uMsg, 
                                          WPARAM wParam, LPARAM lParam);
///Implemented by many of the Windows Shell DLLs to allow applications to obtain DLL-specific version information.
///Params:
///     = 
///Returns:
///    Type: <b>HRESULT</b> If this callback function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias DLLGETVERSIONPROC = HRESULT function(DLLVERSIONINFO* param0);
///Serves as the entry point for a Control Panel application. This is a library-defined callback function.
///Params:
///    hwndCpl = Type: <b>HWND</b> The identifier of the main window of the controlling application. Use the <i>hwndCPl</i>
///              parameter for dialog boxes or other windows that require a handle to a parent window.
///    msg = Type: <b>UINT</b> The message being sent to the Control Panel application.
///    lParam1 = Type: <b>LPARAM</b> Additional message-specific information.
///    lParam2 = Type: <b>LPARAM</b> Additional message-specific information.
///Returns:
///    Type: <b>LONG</b> The return value depends on the message. For more information, see the descriptions of the
///    individual Control Panel messages.
///    
alias APPLET_PROC = int function(HWND hwndCpl, uint msg, LPARAM lParam1, LPARAM lParam2);
///Specifies an app-defined callback function that notifies the app when the app is entering or leaving a suspended
///state.
///Params:
///    Quiesced = Type: <b>BOOLEAN</b> <b>TRUE</b> if the app is entering the suspended state; <b>FALSE</b> if the app is leaving
///               the suspended state.
alias PAPPSTATE_CHANGE_ROUTINE = void function(ubyte Quiesced, void* Context);
alias PAPPCONSTRAIN_CHANGE_ROUTINE = void function(ubyte Constrained, void* Context);

// Structs


///The <b>LOGFONT</b> structure defines the attributes of a font.
struct LOGFONTA
{
    ///The height, in logical units, of the font's character cell or character. The character height value (also known
    ///as the em height) is the character cell height value minus the internal-leading value. The font mapper interprets
    ///the value specified in <b>lfHeight</b> in the following manner. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td>&gt; 0</td> <td>The font mapper transforms this value into device units and matches it against the
    ///cell height of the available fonts.</td> </tr> <tr> <td>0</td> <td>The font mapper uses a default height value
    ///when it searches for a match.</td> </tr> <tr> <td>&lt; 0</td> <td>The font mapper transforms this value into
    ///device units and matches its absolute value against the character height of the available fonts.</td> </tr>
    ///</table> For all height comparisons, the font mapper looks for the largest font that does not exceed the
    ///requested size. This mapping occurs when the font is used for the first time. For the MM_TEXT mapping mode, you
    ///can use the following formula to specify a height for a font with a specified point size: ```cpp lfHeight =
    ///-MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72); ```
    int      lfHeight;
    ///The average width, in logical units, of characters in the font. If <b>lfWidth</b> is zero, the aspect ratio of
    ///the device is matched against the digitization aspect ratio of the available fonts to find the closest match,
    ///determined by the absolute value of the difference.
    int      lfWidth;
    ///The angle, in tenths of degrees, between the escapement vector and the x-axis of the device. The escapement
    ///vector is parallel to the base line of a row of text. When the graphics mode is set to GM_ADVANCED, you can
    ///specify the escapement angle of the string independently of the orientation angle of the string's characters.
    ///When the graphics mode is set to GM_COMPATIBLE, <b>lfEscapement</b> specifies both the escapement and
    ///orientation. You should set <b>lfEscapement</b> and <b>lfOrientation</b> to the same value.
    int      lfEscapement;
    ///The angle, in tenths of degrees, between each character's base line and the x-axis of the device.
    int      lfOrientation;
    ///The weight of the font in the range 0 through 1000. For example, 400 is normal and 700 is bold. If this value is
    ///zero, a default weight is used. The following values are defined for convenience. <table> <tr> <th>Value</th>
    ///<th>Weight</th> </tr> <tr> <td>FW_DONTCARE</td> <td>0</td> </tr> <tr> <td>FW_THIN</td> <td>100</td> </tr> <tr>
    ///<td>FW_EXTRALIGHT</td> <td>200</td> </tr> <tr> <td>FW_ULTRALIGHT</td> <td>200</td> </tr> <tr> <td>FW_LIGHT</td>
    ///<td>300</td> </tr> <tr> <td>FW_NORMAL</td> <td>400</td> </tr> <tr> <td>FW_REGULAR</td> <td>400</td> </tr> <tr>
    ///<td>FW_MEDIUM</td> <td>500</td> </tr> <tr> <td>FW_SEMIBOLD</td> <td>600</td> </tr> <tr> <td>FW_DEMIBOLD</td>
    ///<td>600</td> </tr> <tr> <td>FW_BOLD</td> <td>700</td> </tr> <tr> <td>FW_EXTRABOLD</td> <td>800</td> </tr> <tr>
    ///<td>FW_ULTRABOLD</td> <td>800</td> </tr> <tr> <td>FW_HEAVY</td> <td>900</td> </tr> <tr> <td>FW_BLACK</td>
    ///<td>900</td> </tr> </table>
    int      lfWeight;
    ///An italic font if set to <b>TRUE</b>.
    ubyte    lfItalic;
    ///An underlined font if set to <b>TRUE</b>.
    ubyte    lfUnderline;
    ///A strikeout font if set to <b>TRUE</b>.
    ubyte    lfStrikeOut;
    ///The character set. The following values are predefined. <dl> <dd>ANSI_CHARSET</dd> <dd>BALTIC_CHARSET</dd>
    ///<dd>CHINESEBIG5_CHARSET</dd> <dd>DEFAULT_CHARSET</dd> <dd>EASTEUROPE_CHARSET</dd> <dd>GB2312_CHARSET</dd>
    ///<dd>GREEK_CHARSET</dd> <dd>HANGUL_CHARSET</dd> <dd>MAC_CHARSET</dd> <dd>OEM_CHARSET</dd> <dd>RUSSIAN_CHARSET</dd>
    ///<dd>SHIFTJIS_CHARSET</dd> <dd>SYMBOL_CHARSET</dd> <dd>TURKISH_CHARSET</dd> <dd>VIETNAMESE_CHARSET</dd> </dl>
    ///<b>Korean language edition of Windows:</b> <dl> <dd>JOHAB_CHARSET</dd> </dl> <b>Middle East language edition of
    ///Windows:</b> <dl> <dd>ARABIC_CHARSET</dd> <dd>HEBREW_CHARSET</dd> </dl> <b>Thai language edition of Windows:</b>
    ///<dl> <dd>THAI_CHARSET</dd> </dl> The OEM_CHARSET value specifies a character set that is operating-system
    ///dependent. DEFAULT_CHARSET is set to a value based on the current system locale. For example, when the system
    ///locale is English (United States), it is set as ANSI_CHARSET. Fonts with other character sets may exist in the
    ///operating system. If an application uses a font with an unknown character set, it should not attempt to translate
    ///or interpret strings that are rendered with that font. This parameter is important in the font mapping process.
    ///To ensure consistent results, specify a specific character set. If you specify a typeface name in the
    ///<b>lfFaceName</b> member, make sure that the <b>lfCharSet</b> value matches the character set of the typeface
    ///specified in <b>lfFaceName</b>.
    ubyte    lfCharSet;
    ///The output precision. The output precision defines how closely the output must match the requested font's height,
    ///width, character orientation, escapement, pitch, and font type. It can be one of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td>OUT_CHARACTER_PRECIS</td> <td>Not used.</td> </tr> <tr>
    ///<td>OUT_DEFAULT_PRECIS</td> <td>Specifies the default font mapper behavior.</td> </tr> <tr>
    ///<td>OUT_DEVICE_PRECIS</td> <td>Instructs the font mapper to choose a Device font when the system contains
    ///multiple fonts with the same name.</td> </tr> <tr> <td>OUT_OUTLINE_PRECIS</td> <td> This value instructs the font
    ///mapper to choose from TrueType and other outline-based fonts.</td> </tr> <tr> <td>OUT_PS_ONLY_PRECIS</td> <td>
    ///Instructs the font mapper to choose from only PostScript fonts. If there are no PostScript fonts installed in the
    ///system, the font mapper returns to default behavior.</td> </tr> <tr> <td>OUT_RASTER_PRECIS</td> <td>Instructs the
    ///font mapper to choose a raster font when the system contains multiple fonts with the same name.</td> </tr> <tr>
    ///<td>OUT_STRING_PRECIS</td> <td>This value is not used by the font mapper, but it is returned when raster fonts
    ///are enumerated.</td> </tr> <tr> <td>OUT_STROKE_PRECIS</td> <td> This value is not used by the font mapper, but it
    ///is returned when TrueType, other outline-based fonts, and vector fonts are enumerated.</td> </tr> <tr>
    ///<td>OUT_TT_ONLY_PRECIS</td> <td>Instructs the font mapper to choose from only TrueType fonts. If there are no
    ///TrueType fonts installed in the system, the font mapper returns to default behavior.</td> </tr> <tr>
    ///<td>OUT_TT_PRECIS</td> <td>Instructs the font mapper to choose a TrueType font when the system contains multiple
    ///fonts with the same name.</td> </tr> </table> Applications can use the OUT_DEVICE_PRECIS, OUT_RASTER_PRECIS,
    ///OUT_TT_PRECIS, and OUT_PS_ONLY_PRECIS values to control how the font mapper chooses a font when the operating
    ///system contains more than one font with a specified name. For example, if an operating system contains a font
    ///named Symbol in raster and TrueType form, specifying OUT_TT_PRECIS forces the font mapper to choose the TrueType
    ///version. Specifying OUT_TT_ONLY_PRECIS forces the font mapper to choose a TrueType font, even if it must
    ///substitute a TrueType font of another name.
    ubyte    lfOutPrecision;
    ///The clipping precision. The clipping precision defines how to clip characters that are partially outside the
    ///clipping region. It can be one or more of the following values. For more information about the orientation of
    ///coordinate systems, see the description of the <i>nOrientation</i> parameter. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td>CLIP_CHARACTER_PRECIS</td> <td>Not used.</td> </tr> <tr>
    ///<td>CLIP_DEFAULT_PRECIS</td> <td>Specifies default clipping behavior.</td> </tr> <tr> <td>CLIP_DFA_DISABLE</td>
    ///<td><b>Windows XP SP1:</b> Turns off font association for the font. Note that this flag is not guaranteed to have
    ///any effect on any platform after Windows Server 2003.</td> </tr> <tr> <td>CLIP_EMBEDDED</td> <td>You must specify
    ///this flag to use an embedded read-only font.</td> </tr> <tr> <td>CLIP_LH_ANGLES</td> <td>When this value is used,
    ///the rotation for all fonts depends on whether the orientation of the coordinate system is left-handed or
    ///right-handed.If not used, device fonts always rotate counterclockwise, but the rotation of other fonts is
    ///dependent on the orientation of the coordinate system. </td> </tr> <tr> <td>CLIP_MASK</td> <td>Not used.</td>
    ///</tr> <tr> <td>CLIP_DFA_OVERRIDE</td> <td> Turns off font association for the font. This is identical to
    ///CLIP_DFA_DISABLE, but it can have problems in some situations; the recommended flag to use is
    ///CLIP_DFA_DISABLE.</td> </tr> <tr> <td>CLIP_STROKE_PRECIS</td> <td>Not used by the font mapper, but is returned
    ///when raster, vector, or TrueType fonts are enumerated. For compatibility, this value is always returned when
    ///enumerating fonts. </td> </tr> <tr> <td>CLIP_TT_ALWAYS</td> <td>Not used.</td> </tr> </table>
    ubyte    lfClipPrecision;
    ///The output quality. The output quality defines how carefully the graphics device interface (GDI) must attempt to
    ///match the logical-font attributes to those of an actual physical font. It can be one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td>ANTIALIASED_QUALITY</td> <td> Font is always
    ///antialiased if the font supports it and the size of the font is not too small or too large.</td> </tr> <tr>
    ///<td>CLEARTYPE_QUALITY</td> <td> If set, text is rendered (when possible) using ClearType antialiasing method. See
    ///Remarks for more information.</td> </tr> <tr> <td>DEFAULT_QUALITY</td> <td>Appearance of the font does not
    ///matter.</td> </tr> <tr> <td>DRAFT_QUALITY</td> <td>Appearance of the font is less important than when
    ///PROOF_QUALITY is used. For GDI raster fonts, scaling is enabled, which means that more font sizes are available,
    ///but the quality may be lower. Bold, italic, underline, and strikeout fonts are synthesized if necessary.</td>
    ///</tr> <tr> <td>NONANTIALIASED_QUALITY</td> <td> Font is never antialiased.</td> </tr> <tr> <td>PROOF_QUALITY</td>
    ///<td>Character quality of the font is more important than exact matching of the logical-font attributes. For GDI
    ///raster fonts, scaling is disabled and the font closest in size is chosen. Although the chosen font size may not
    ///be mapped exactly when PROOF_QUALITY is used, the quality of the font is high and there is no distortion of
    ///appearance. Bold, italic, underline, and strikeout fonts are synthesized if necessary.</td> </tr> </table> If
    ///neither ANTIALIASED_QUALITY nor NONANTIALIASED_QUALITY is selected, the font is antialiased only if the user
    ///chooses smooth screen fonts in Control Panel.
    ubyte    lfQuality;
    ///The pitch and family of the font. The two low-order bits specify the pitch of the font and can be one of the
    ///following values. <ul> <li>DEFAULT_PITCH</li> <li>FIXED_PITCH</li> <li>VARIABLE_PITCH</li> </ul> Bits 4 through 7
    ///of the member specify the font family and can be one of the following values. <ul> <li>FF_DECORATIVE</li>
    ///<li>FF_DONTCARE</li> <li>FF_MODERN</li> <li>FF_ROMAN</li> <li>FF_SCRIPT</li> <li>FF_SWISS</li> </ul> The proper
    ///value can be obtained by using the Boolean OR operator to join one pitch constant with one family constant. Font
    ///families describe the look of a font in a general way. They are intended for specifying fonts when the exact
    ///typeface desired is not available. The values for font families are as follows. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td>FF_DECORATIVE</td> <td>Novelty fonts. Old English is an example.</td> </tr> <tr>
    ///<td>FF_DONTCARE</td> <td>Use default font.</td> </tr> <tr> <td>FF_MODERN</td> <td>Fonts with constant stroke
    ///width (monospace), with or without serifs. Monospace fonts are usually modern. Pica, Elite, and CourierNew are
    ///examples.</td> </tr> <tr> <td>FF_ROMAN</td> <td>Fonts with variable stroke width (proportional) and with serifs.
    ///MS Serif is an example.</td> </tr> <tr> <td>FF_SCRIPT</td> <td>Fonts designed to look like handwriting. Script
    ///and Cursive are examples.</td> </tr> <tr> <td>FF_SWISS</td> <td>Fonts with variable stroke width (proportional)
    ///and without serifs. MS Sans Serif is an example.</td> </tr> </table>
    ubyte    lfPitchAndFamily;
    ///A null-terminated string that specifies the typeface name of the font. The length of this string must not exceed
    ///32 <b>TCHAR</b> values, including the terminating <b>NULL</b>. The EnumFontFamiliesEx function can be used to
    ///enumerate the typeface names of all currently available fonts. If <b>lfFaceName</b> is an empty string, GDI uses
    ///the first font that matches the other specified attributes.
    byte[32] lfFaceName;
}

///The <b>LOGFONT</b> structure defines the attributes of a font.
struct LOGFONTW
{
    ///The height, in logical units, of the font's character cell or character. The character height value (also known
    ///as the em height) is the character cell height value minus the internal-leading value. The font mapper interprets
    ///the value specified in <b>lfHeight</b> in the following manner. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td>&gt; 0</td> <td>The font mapper transforms this value into device units and matches it against the
    ///cell height of the available fonts.</td> </tr> <tr> <td>0</td> <td>The font mapper uses a default height value
    ///when it searches for a match.</td> </tr> <tr> <td>&lt; 0</td> <td>The font mapper transforms this value into
    ///device units and matches its absolute value against the character height of the available fonts.</td> </tr>
    ///</table> For all height comparisons, the font mapper looks for the largest font that does not exceed the
    ///requested size. This mapping occurs when the font is used for the first time. For the MM_TEXT mapping mode, you
    ///can use the following formula to specify a height for a font with a specified point size: ```cpp lfHeight =
    ///-MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72); ```
    int        lfHeight;
    ///The average width, in logical units, of characters in the font. If <b>lfWidth</b> is zero, the aspect ratio of
    ///the device is matched against the digitization aspect ratio of the available fonts to find the closest match,
    ///determined by the absolute value of the difference.
    int        lfWidth;
    ///The angle, in tenths of degrees, between the escapement vector and the x-axis of the device. The escapement
    ///vector is parallel to the base line of a row of text. When the graphics mode is set to GM_ADVANCED, you can
    ///specify the escapement angle of the string independently of the orientation angle of the string's characters.
    ///When the graphics mode is set to GM_COMPATIBLE, <b>lfEscapement</b> specifies both the escapement and
    ///orientation. You should set <b>lfEscapement</b> and <b>lfOrientation</b> to the same value.
    int        lfEscapement;
    ///The angle, in tenths of degrees, between each character's base line and the x-axis of the device.
    int        lfOrientation;
    ///The weight of the font in the range 0 through 1000. For example, 400 is normal and 700 is bold. If this value is
    ///zero, a default weight is used. The following values are defined for convenience. <table> <tr> <th>Value</th>
    ///<th>Weight</th> </tr> <tr> <td>FW_DONTCARE</td> <td>0</td> </tr> <tr> <td>FW_THIN</td> <td>100</td> </tr> <tr>
    ///<td>FW_EXTRALIGHT</td> <td>200</td> </tr> <tr> <td>FW_ULTRALIGHT</td> <td>200</td> </tr> <tr> <td>FW_LIGHT</td>
    ///<td>300</td> </tr> <tr> <td>FW_NORMAL</td> <td>400</td> </tr> <tr> <td>FW_REGULAR</td> <td>400</td> </tr> <tr>
    ///<td>FW_MEDIUM</td> <td>500</td> </tr> <tr> <td>FW_SEMIBOLD</td> <td>600</td> </tr> <tr> <td>FW_DEMIBOLD</td>
    ///<td>600</td> </tr> <tr> <td>FW_BOLD</td> <td>700</td> </tr> <tr> <td>FW_EXTRABOLD</td> <td>800</td> </tr> <tr>
    ///<td>FW_ULTRABOLD</td> <td>800</td> </tr> <tr> <td>FW_HEAVY</td> <td>900</td> </tr> <tr> <td>FW_BLACK</td>
    ///<td>900</td> </tr> </table>
    int        lfWeight;
    ///An italic font if set to <b>TRUE</b>.
    ubyte      lfItalic;
    ///An underlined font if set to <b>TRUE</b>.
    ubyte      lfUnderline;
    ///A strikeout font if set to <b>TRUE</b>.
    ubyte      lfStrikeOut;
    ///The character set. The following values are predefined. <dl> <dd>ANSI_CHARSET</dd> <dd>BALTIC_CHARSET</dd>
    ///<dd>CHINESEBIG5_CHARSET</dd> <dd>DEFAULT_CHARSET</dd> <dd>EASTEUROPE_CHARSET</dd> <dd>GB2312_CHARSET</dd>
    ///<dd>GREEK_CHARSET</dd> <dd>HANGUL_CHARSET</dd> <dd>MAC_CHARSET</dd> <dd>OEM_CHARSET</dd> <dd>RUSSIAN_CHARSET</dd>
    ///<dd>SHIFTJIS_CHARSET</dd> <dd>SYMBOL_CHARSET</dd> <dd>TURKISH_CHARSET</dd> <dd>VIETNAMESE_CHARSET</dd> </dl>
    ///<b>Korean language edition of Windows:</b> <dl> <dd>JOHAB_CHARSET</dd> </dl> <b>Middle East language edition of
    ///Windows:</b> <dl> <dd>ARABIC_CHARSET</dd> <dd>HEBREW_CHARSET</dd> </dl> <b>Thai language edition of Windows:</b>
    ///<dl> <dd>THAI_CHARSET</dd> </dl> The OEM_CHARSET value specifies a character set that is operating-system
    ///dependent. DEFAULT_CHARSET is set to a value based on the current system locale. For example, when the system
    ///locale is English (United States), it is set as ANSI_CHARSET. Fonts with other character sets may exist in the
    ///operating system. If an application uses a font with an unknown character set, it should not attempt to translate
    ///or interpret strings that are rendered with that font. This parameter is important in the font mapping process.
    ///To ensure consistent results, specify a specific character set. If you specify a typeface name in the
    ///<b>lfFaceName</b> member, make sure that the <b>lfCharSet</b> value matches the character set of the typeface
    ///specified in <b>lfFaceName</b>.
    ubyte      lfCharSet;
    ///The output precision. The output precision defines how closely the output must match the requested font's height,
    ///width, character orientation, escapement, pitch, and font type. It can be one of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td>OUT_CHARACTER_PRECIS</td> <td>Not used.</td> </tr> <tr>
    ///<td>OUT_DEFAULT_PRECIS</td> <td>Specifies the default font mapper behavior.</td> </tr> <tr>
    ///<td>OUT_DEVICE_PRECIS</td> <td>Instructs the font mapper to choose a Device font when the system contains
    ///multiple fonts with the same name.</td> </tr> <tr> <td>OUT_OUTLINE_PRECIS</td> <td> This value instructs the font
    ///mapper to choose from TrueType and other outline-based fonts.</td> </tr> <tr> <td>OUT_PS_ONLY_PRECIS</td> <td>
    ///Instructs the font mapper to choose from only PostScript fonts. If there are no PostScript fonts installed in the
    ///system, the font mapper returns to default behavior.</td> </tr> <tr> <td>OUT_RASTER_PRECIS</td> <td>Instructs the
    ///font mapper to choose a raster font when the system contains multiple fonts with the same name.</td> </tr> <tr>
    ///<td>OUT_STRING_PRECIS</td> <td>This value is not used by the font mapper, but it is returned when raster fonts
    ///are enumerated.</td> </tr> <tr> <td>OUT_STROKE_PRECIS</td> <td> This value is not used by the font mapper, but it
    ///is returned when TrueType, other outline-based fonts, and vector fonts are enumerated.</td> </tr> <tr>
    ///<td>OUT_TT_ONLY_PRECIS</td> <td>Instructs the font mapper to choose from only TrueType fonts. If there are no
    ///TrueType fonts installed in the system, the font mapper returns to default behavior.</td> </tr> <tr>
    ///<td>OUT_TT_PRECIS</td> <td>Instructs the font mapper to choose a TrueType font when the system contains multiple
    ///fonts with the same name.</td> </tr> </table> Applications can use the OUT_DEVICE_PRECIS, OUT_RASTER_PRECIS,
    ///OUT_TT_PRECIS, and OUT_PS_ONLY_PRECIS values to control how the font mapper chooses a font when the operating
    ///system contains more than one font with a specified name. For example, if an operating system contains a font
    ///named Symbol in raster and TrueType form, specifying OUT_TT_PRECIS forces the font mapper to choose the TrueType
    ///version. Specifying OUT_TT_ONLY_PRECIS forces the font mapper to choose a TrueType font, even if it must
    ///substitute a TrueType font of another name.
    ubyte      lfOutPrecision;
    ///The clipping precision. The clipping precision defines how to clip characters that are partially outside the
    ///clipping region. It can be one or more of the following values. For more information about the orientation of
    ///coordinate systems, see the description of the <i>nOrientation</i> parameter. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td>CLIP_CHARACTER_PRECIS</td> <td>Not used.</td> </tr> <tr>
    ///<td>CLIP_DEFAULT_PRECIS</td> <td>Specifies default clipping behavior.</td> </tr> <tr> <td>CLIP_DFA_DISABLE</td>
    ///<td><b>Windows XP SP1:</b> Turns off font association for the font. Note that this flag is not guaranteed to have
    ///any effect on any platform after Windows Server 2003.</td> </tr> <tr> <td>CLIP_EMBEDDED</td> <td>You must specify
    ///this flag to use an embedded read-only font.</td> </tr> <tr> <td>CLIP_LH_ANGLES</td> <td>When this value is used,
    ///the rotation for all fonts depends on whether the orientation of the coordinate system is left-handed or
    ///right-handed.If not used, device fonts always rotate counterclockwise, but the rotation of other fonts is
    ///dependent on the orientation of the coordinate system. </td> </tr> <tr> <td>CLIP_MASK</td> <td>Not used.</td>
    ///</tr> <tr> <td>CLIP_DFA_OVERRIDE</td> <td> Turns off font association for the font. This is identical to
    ///CLIP_DFA_DISABLE, but it can have problems in some situations; the recommended flag to use is
    ///CLIP_DFA_DISABLE.</td> </tr> <tr> <td>CLIP_STROKE_PRECIS</td> <td>Not used by the font mapper, but is returned
    ///when raster, vector, or TrueType fonts are enumerated. For compatibility, this value is always returned when
    ///enumerating fonts. </td> </tr> <tr> <td>CLIP_TT_ALWAYS</td> <td>Not used.</td> </tr> </table>
    ubyte      lfClipPrecision;
    ///The output quality. The output quality defines how carefully the graphics device interface (GDI) must attempt to
    ///match the logical-font attributes to those of an actual physical font. It can be one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td>ANTIALIASED_QUALITY</td> <td> Font is always
    ///antialiased if the font supports it and the size of the font is not too small or too large.</td> </tr> <tr>
    ///<td>CLEARTYPE_QUALITY</td> <td> If set, text is rendered (when possible) using ClearType antialiasing method. See
    ///Remarks for more information.</td> </tr> <tr> <td>DEFAULT_QUALITY</td> <td>Appearance of the font does not
    ///matter.</td> </tr> <tr> <td>DRAFT_QUALITY</td> <td>Appearance of the font is less important than when
    ///PROOF_QUALITY is used. For GDI raster fonts, scaling is enabled, which means that more font sizes are available,
    ///but the quality may be lower. Bold, italic, underline, and strikeout fonts are synthesized if necessary.</td>
    ///</tr> <tr> <td>NONANTIALIASED_QUALITY</td> <td> Font is never antialiased.</td> </tr> <tr> <td>PROOF_QUALITY</td>
    ///<td>Character quality of the font is more important than exact matching of the logical-font attributes. For GDI
    ///raster fonts, scaling is disabled and the font closest in size is chosen. Although the chosen font size may not
    ///be mapped exactly when PROOF_QUALITY is used, the quality of the font is high and there is no distortion of
    ///appearance. Bold, italic, underline, and strikeout fonts are synthesized if necessary.</td> </tr> </table> If
    ///neither ANTIALIASED_QUALITY nor NONANTIALIASED_QUALITY is selected, the font is antialiased only if the user
    ///chooses smooth screen fonts in Control Panel.
    ubyte      lfQuality;
    ///The pitch and family of the font. The two low-order bits specify the pitch of the font and can be one of the
    ///following values. <ul> <li>DEFAULT_PITCH</li> <li>FIXED_PITCH</li> <li>VARIABLE_PITCH</li> </ul> Bits 4 through 7
    ///of the member specify the font family and can be one of the following values. <ul> <li>FF_DECORATIVE</li>
    ///<li>FF_DONTCARE</li> <li>FF_MODERN</li> <li>FF_ROMAN</li> <li>FF_SCRIPT</li> <li>FF_SWISS</li> </ul> The proper
    ///value can be obtained by using the Boolean OR operator to join one pitch constant with one family constant. Font
    ///families describe the look of a font in a general way. They are intended for specifying fonts when the exact
    ///typeface desired is not available. The values for font families are as follows. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td>FF_DECORATIVE</td> <td>Novelty fonts. Old English is an example.</td> </tr> <tr>
    ///<td>FF_DONTCARE</td> <td>Use default font.</td> </tr> <tr> <td>FF_MODERN</td> <td>Fonts with constant stroke
    ///width (monospace), with or without serifs. Monospace fonts are usually modern. Pica, Elite, and CourierNew are
    ///examples.</td> </tr> <tr> <td>FF_ROMAN</td> <td>Fonts with variable stroke width (proportional) and with serifs.
    ///MS Serif is an example.</td> </tr> <tr> <td>FF_SCRIPT</td> <td>Fonts designed to look like handwriting. Script
    ///and Cursive are examples.</td> </tr> <tr> <td>FF_SWISS</td> <td>Fonts with variable stroke width (proportional)
    ///and without serifs. MS Sans Serif is an example.</td> </tr> </table>
    ubyte      lfPitchAndFamily;
    ///A null-terminated string that specifies the typeface name of the font. The length of this string must not exceed
    ///32 <b>TCHAR</b> values, including the terminating <b>NULL</b>. The EnumFontFamiliesEx function can be used to
    ///enumerate the typeface names of all currently available fonts. If <b>lfFaceName</b> is an empty string, GDI uses
    ///the first font that matches the other specified attributes.
    ushort[32] lfFaceName;
}

///Contains information about a software update.
struct SOFTDISTINFO
{
    ///Type: <b>ULONG</b> The size of the structure, in bytes.
    uint          cbSize;
    ///Type: <b>DWORD</b> This parameter can take one of the following values.
    uint          dwFlags;
    ///Type: <b>DWORD</b> The advertised state. It can take one of the following values.
    uint          dwAdState;
    ///Type: <b>LPWSTR</b> A string that contains the contents of the TITLE flag from the associated .cdf file.
    const(wchar)* szTitle;
    ///Type: <b>LPWSTR</b> A string that contains the contents of the ABSTRACT flag from the associated .cdf file.
    const(wchar)* szAbstract;
    ///Type: <b>LPWSTR</b> A string that contains the URL of the webpage to advertise or install the update.
    const(wchar)* szHREF;
    ///Type: <b>DWORD</b> The most-significant unsigned long integer value of the installed version number.
    uint          dwInstalledVersionMS;
    ///Type: <b>DWORD</b> The least-significant unsigned long integer value of the installed version number.
    uint          dwInstalledVersionLS;
    ///Type: <b>DWORD</b> The most-significant unsigned long integer value of the update version number.
    uint          dwUpdateVersionMS;
    ///Type: <b>DWORD</b> The least-significant unsigned long integer value of the update version number.
    uint          dwUpdateVersionLS;
    ///Type: <b>DWORD</b> The most-significant unsigned long integer value of the advertised version number.
    uint          dwAdvertisedVersionMS;
    ///Type: <b>DWORD</b> The least-significant unsigned long integer value of the advertised version number.
    uint          dwAdvertisedVersionLS;
    ///Type: <b>DWORD</b> Reserved. Must be set to zero.
    uint          dwReserved;
}

alias ShFindChangeNotifcationHandle = ptrdiff_t;

///Contains information about an item for which context-sensitive help has been requested.
struct HELPINFO
{
    ///Type: <b>UINT</b> The structure size, in bytes.
    uint   cbSize;
    ///Type: <b>int</b> The type of context for which help is requested. This member can be one of the following values.
    ///- <b>HELPINFO_MENUITEM</b>: Help requested for a menu item. - <b>HELPINFO_WINDOW</b>: Help requested for a
    ///control or window.
    int    iContextType;
    ///Type: <b>int</b> The identifier of the window or control if <b>iContextType</b> is <b>HELPINFO_WINDOW</b>, or
    ///identifier of the menu item if <b>iContextType</b> is <b>HELPINFO_MENUITEM</b>.
    int    iCtrlId;
    ///Type: <b>HANDLE</b> The identifier of the child window or control if <b>iContextType</b> is
    ///<b>HELPINFO_WINDOW</b>, or identifier of the associated menu if <b>iContextType</b> is <b>HELPINFO_MENUITEM</b>.
    HANDLE hItemHandle;
    ///Type: <b>DWORD</b> The help context identifier of the window or control.
    size_t dwContextId;
    POINT  MousePos;
}

///Specifies a keyword to search for and the keyword table to be searched by Windows Help.
struct MULTIKEYHELPA
{
    ///Type: <b>DWORD</b> The structure size, in bytes.
    uint    mkSize;
    ///Type: <b>TCHAR</b> A single character that identifies the keyword table to search.
    byte    mkKeylist;
    ///Type: <b>TCHAR[1]</b> A null-terminated text string that specifies the keyword to locate in the keyword table.
    byte[1] szKeyphrase;
}

///Specifies a keyword to search for and the keyword table to be searched by Windows Help.
struct MULTIKEYHELPW
{
    ///Type: <b>DWORD</b> The structure size, in bytes.
    uint      mkSize;
    ///Type: <b>TCHAR</b> A single character that identifies the keyword table to search.
    ushort    mkKeylist;
    ///Type: <b>TCHAR[1]</b> A null-terminated text string that specifies the keyword to locate in the keyword table.
    ushort[1] szKeyphrase;
}

///Contains the size and position of either a primary or secondary Help window. An application can set this information
///by calling the WinHelp function with the HELP_SETWINPOS value.
struct HELPWININFOA
{
    ///Type: <b>int</b> The size of this structure, in bytes.
    int     wStructSize;
    ///Type: <b>int</b> X-coordinate of the upper-left corner of the window, in screen coordinates.
    int     x;
    ///Type: <b>int</b> Y-coordinate of the upper-left corner of the window, in screen coordinates.
    int     y;
    ///Type: <b>int</b> The width of the window, in pixels.
    int     dx;
    ///Type: <b>int</b> The height of the window, in pixels.
    int     dy;
    ///Type: <b>int</b> Options for display of the window. Several values also determine the activation (focus) state of
    ///the window or other windows. This member must be one of the following values.
    int     wMax;
    ///Type: <b>TCHAR[2]</b> The name of the window.
    byte[2] rgchMember;
}

///Contains the size and position of either a primary or secondary Help window. An application can set this information
///by calling the WinHelp function with the HELP_SETWINPOS value.
struct HELPWININFOW
{
    ///Type: <b>int</b> The size of this structure, in bytes.
    int       wStructSize;
    ///Type: <b>int</b> X-coordinate of the upper-left corner of the window, in screen coordinates.
    int       x;
    ///Type: <b>int</b> Y-coordinate of the upper-left corner of the window, in screen coordinates.
    int       y;
    ///Type: <b>int</b> The width of the window, in pixels.
    int       dx;
    ///Type: <b>int</b> The height of the window, in pixels.
    int       dy;
    ///Type: <b>int</b> Options for display of the window. Several values also determine the activation (focus) state of
    ///the window or other windows. This member must be one of the following values.
    int       wMax;
    ///Type: <b>TCHAR[2]</b> The name of the window.
    ushort[2] rgchMember;
}

///Provides application category information to Add/Remove Programs in Control Panel. The APPCATEGORYINFOLIST structure
///is used create a complete list of categories for an application publisher.
struct APPCATEGORYINFO
{
    ///Type: <b>LCID</b> Unused.
    uint          Locale;
    ///Type: <b>LPWSTR</b> A pointer to a string containing the display name of the category. This string displays in
    ///the <b>Category</b> list in Add/Remove Programs. This string buffer must be allocated using CoTaskMemAlloc and
    ///freed using CoTaskMemFree.
    const(wchar)* pszDescription;
    ///Type: <b>GUID</b> A GUID identifying the application category.
    GUID          AppCategoryId;
}

///Provides a list of supported application categories from an application publisher to Add/Remove Programs in Control
///Panel.
struct APPCATEGORYINFOLIST
{
    ///Type: <b>DWORD</b> A value of type <b>DWORD</b> that specifies the count of APPCATEGORYINFO elements in the array
    ///pointed to by <b>pCategoryInfo</b>.
    uint             cCategory;
    ///Type: <b>APPCATEGORYINFO*</b> A pointer to an array of APPCATEGORYINFO structures. This array contains all the
    ///categories an application publisher supports and must be allocated using CoTaskMemAlloc and freed using
    ///CoTaskMemFree.
    APPCATEGORYINFO* pCategoryInfo;
}

struct HDROP__
{
align (1):
    int unused;
}

struct DRAGINFOA
{
align (1):
    uint         uSize;
    POINT        pt;
    BOOL         fNC;
    const(char)* lpFileList;
    uint         grfKeyState;
}

struct DRAGINFOW
{
align (1):
    uint          uSize;
    POINT         pt;
    BOOL          fNC;
    const(wchar)* lpFileList;
    uint          grfKeyState;
}

///Contains information about a system appbar message.
struct APPBARDATA
{
align (1):
    ///Type: <b>DWORD</b> The size of the structure, in bytes.
    uint   cbSize;
    ///Type: <b>HWND</b> The handle to the appbar window. Not all messages use this member. See the individual message
    ///page to see if you need to provide an <b>hWind</b> value.
    HWND   hWnd;
    ///Type: <b>UINT</b> An application-defined message identifier. The application uses the specified identifier for
    ///notification messages that it sends to the appbar identified by the <b>hWnd</b> member. This member is used when
    ///sending the ABM_NEW message.
    uint   uCallbackMessage;
    ///Type: <b>UINT</b> A value that specifies an edge of the screen. This member is used when sending one of these
    ///messages: <ul> <li> ABM_GETAUTOHIDEBAR </li> <li> ABM_SETAUTOHIDEBAR </li> <li> ABM_GETAUTOHIDEBAREX </li> <li>
    ///ABM_SETAUTOHIDEBAREX </li> <li> ABM_QUERYPOS </li> <li> ABM_SETPOS </li> </ul> This member can be one of the
    ///following values.
    uint   uEdge;
    ///Type: <b>RECT</b> A RECT structure whose use varies depending on the message: <ul> <li> ABM_GETTASKBARPOS,
    ///ABM_QUERYPOS, ABM_SETPOS: The bounding rectangle, in screen coordinates, of an appbar or the Windows
    ///taskbar.</li> <li> ABM_GETAUTOHIDEBAREX, ABM_SETAUTOHIDEBAREX: The monitor on which the operation is being
    ///performed. This information can be retrieved through the GetMonitorInfo function.</li> </ul>
    RECT   rc;
    LPARAM lParam;
}

///Contains information that the SHFileOperation function uses to perform file operations. <div
///class="alert"><b>Note</b> As of Windows Vista, the use of the IFileOperation interface is recommended over this
///function.</div><div> </div>
struct SHFILEOPSTRUCTA
{
align (1):
    ///Type: <b>HWND</b> A window handle to the dialog box to display information about the status of the file
    ///operation.
    HWND         hwnd;
    ///Type: <b>UINT</b> A value that indicates which operation to perform. One of the following values:
    uint         wFunc;
    ///Type: <b>PCZZTSTR</b> <div class="alert"><b>Note</b> This string must be double-null terminated.</div> <div>
    ///</div> A pointer to one or more source file names. These names should be fully qualified paths to prevent
    ///unexpected results. Standard MS-DOS wildcard characters, such as "*", are permitted <i>only</i> in the file-name
    ///position. Using a wildcard character elsewhere in the string will lead to unpredictable results. Although this
    ///member is declared as a single null-terminated string, it is actually a buffer that can hold multiple
    ///null-delimited file names. Each file name is terminated by a single <b>NULL</b> character. The last file name is
    ///terminated with a double <b>NULL</b> character ("\0\0") to indicate the end of the buffer.
    byte*        pFrom;
    ///Type: <b>PCZZTSTR</b> <div class="alert"><b>Note</b> This string must be double-null terminated.</div> <div>
    ///</div> A pointer to the destination file or directory name. This parameter must be set to <b>NULL</b> if it is
    ///not used. Wildcard characters are not allowed. Their use will lead to unpredictable results. Like <b>pFrom</b>,
    ///the <b>pTo</b> member is also a double-null terminated string and is handled in much the same way. However,
    ///<b>pTo</b> must meet the following specifications: <ul> <li>Wildcard characters are not supported.</li> <li>Copy
    ///and Move operations can specify destination directories that do not exist. In those cases, the system attempts to
    ///create them and normally displays a dialog box to ask the user if they want to create the new directory. To
    ///suppress this dialog box and have the directories created silently, set the <b>FOF_NOCONFIRMMKDIR</b> flag in
    ///<b>fFlags</b>.</li> <li>For Copy and Move operations, the buffer can contain multiple destination file names if
    ///the <b>fFlags</b> member specifies <b>FOF_MULTIDESTFILES</b>.</li> <li>Pack multiple names into the <b>pTo</b>
    ///string in the same way as for <b>pFrom</b>.</li> <li>Use fully qualified paths. Using relative paths is not
    ///prohibited, but can have unpredictable results.</li> </ul>
    byte*        pTo;
    ///Type: <b>FILEOP_FLAGS</b> Flags that control the file operation. This member can take a combination of the
    ///following flags.
    ushort       fFlags;
    ///Type: <b>BOOL</b> When the function returns, this member contains <b>TRUE</b> if any file operations were aborted
    ///before they were completed; otherwise, <b>FALSE</b>. An operation can be manually aborted by the user through UI
    ///or it can be silently aborted by the system if the FOF_NOERRORUI or FOF_NOCONFIRMATION flags were set.
    BOOL         fAnyOperationsAborted;
    ///Type: <b>LPVOID</b> When the function returns, this member contains a handle to a name mapping object that
    ///contains the old and new names of the renamed files. This member is used only if the <b>fFlags</b> member
    ///includes the <b>FOF_WANTMAPPINGHANDLE</b> flag. See Remarks for more details.
    void*        hNameMappings;
    ///Type: <b>PCTSTR</b> A pointer to the title of a progress dialog box. This is a null-terminated string. This
    ///member is used only if <b>fFlags</b> includes the <b>FOF_SIMPLEPROGRESS</b> flag.
    const(char)* lpszProgressTitle;
}

///Contains information that the SHFileOperation function uses to perform file operations. <div
///class="alert"><b>Note</b> As of Windows Vista, the use of the IFileOperation interface is recommended over this
///function.</div><div> </div>
struct SHFILEOPSTRUCTW
{
align (1):
    ///Type: <b>HWND</b> A window handle to the dialog box to display information about the status of the file
    ///operation.
    HWND          hwnd;
    ///Type: <b>UINT</b> A value that indicates which operation to perform. One of the following values:
    uint          wFunc;
    ///Type: <b>PCZZTSTR</b> <div class="alert"><b>Note</b> This string must be double-null terminated.</div> <div>
    ///</div> A pointer to one or more source file names. These names should be fully qualified paths to prevent
    ///unexpected results. Standard MS-DOS wildcard characters, such as "*", are permitted <i>only</i> in the file-name
    ///position. Using a wildcard character elsewhere in the string will lead to unpredictable results. Although this
    ///member is declared as a single null-terminated string, it is actually a buffer that can hold multiple
    ///null-delimited file names. Each file name is terminated by a single <b>NULL</b> character. The last file name is
    ///terminated with a double <b>NULL</b> character ("\0\0") to indicate the end of the buffer.
    const(wchar)* pFrom;
    ///Type: <b>PCZZTSTR</b> <div class="alert"><b>Note</b> This string must be double-null terminated.</div> <div>
    ///</div> A pointer to the destination file or directory name. This parameter must be set to <b>NULL</b> if it is
    ///not used. Wildcard characters are not allowed. Their use will lead to unpredictable results. Like <b>pFrom</b>,
    ///the <b>pTo</b> member is also a double-null terminated string and is handled in much the same way. However,
    ///<b>pTo</b> must meet the following specifications: <ul> <li>Wildcard characters are not supported.</li> <li>Copy
    ///and Move operations can specify destination directories that do not exist. In those cases, the system attempts to
    ///create them and normally displays a dialog box to ask the user if they want to create the new directory. To
    ///suppress this dialog box and have the directories created silently, set the <b>FOF_NOCONFIRMMKDIR</b> flag in
    ///<b>fFlags</b>.</li> <li>For Copy and Move operations, the buffer can contain multiple destination file names if
    ///the <b>fFlags</b> member specifies <b>FOF_MULTIDESTFILES</b>.</li> <li>Pack multiple names into the <b>pTo</b>
    ///string in the same way as for <b>pFrom</b>.</li> <li>Use fully qualified paths. Using relative paths is not
    ///prohibited, but can have unpredictable results.</li> </ul>
    const(wchar)* pTo;
    ///Type: <b>FILEOP_FLAGS</b> Flags that control the file operation. This member can take a combination of the
    ///following flags.
    ushort        fFlags;
    ///Type: <b>BOOL</b> When the function returns, this member contains <b>TRUE</b> if any file operations were aborted
    ///before they were completed; otherwise, <b>FALSE</b>. An operation can be manually aborted by the user through UI
    ///or it can be silently aborted by the system if the FOF_NOERRORUI or FOF_NOCONFIRMATION flags were set.
    BOOL          fAnyOperationsAborted;
    ///Type: <b>LPVOID</b> When the function returns, this member contains a handle to a name mapping object that
    ///contains the old and new names of the renamed files. This member is used only if the <b>fFlags</b> member
    ///includes the <b>FOF_WANTMAPPINGHANDLE</b> flag. See Remarks for more details.
    void*         hNameMappings;
    ///Type: <b>PCTSTR</b> A pointer to the title of a progress dialog box. This is a null-terminated string. This
    ///member is used only if <b>fFlags</b> includes the <b>FOF_SIMPLEPROGRESS</b> flag.
    const(wchar)* lpszProgressTitle;
}

///Contains the old and new path names for each file that was moved, copied, or renamed by the SHFileOperation function.
struct SHNAMEMAPPINGA
{
align (1):
    ///Type: <b>LPTSTR</b> The address of a character buffer that contains the old path name.
    const(char)* pszOldPath;
    ///Type: <b>LPTSTR</b> The address of a character buffer that contains the new path name.
    const(char)* pszNewPath;
    ///Type: <b>int</b> The number of characters in <b>pszOldPath</b>.
    int          cchOldPath;
    ///Type: <b>int</b> The number of characters in <b>pszNewPath</b>.
    int          cchNewPath;
}

///Contains the old and new path names for each file that was moved, copied, or renamed by the SHFileOperation function.
struct SHNAMEMAPPINGW
{
align (1):
    ///Type: <b>LPTSTR</b> The address of a character buffer that contains the old path name.
    const(wchar)* pszOldPath;
    ///Type: <b>LPTSTR</b> The address of a character buffer that contains the new path name.
    const(wchar)* pszNewPath;
    ///Type: <b>int</b> The number of characters in <b>pszOldPath</b>.
    int           cchOldPath;
    ///Type: <b>int</b> The number of characters in <b>pszNewPath</b>.
    int           cchNewPath;
}

///Contains information used by ShellExecuteEx.
struct SHELLEXECUTEINFOA
{
align (1):
    ///Type: <b>DWORD</b> Required. The size of this structure, in bytes.
    uint         cbSize;
    ///Type: <b>ULONG</b> A combination of one or more of the following values that indicate the content and validity of
    ///the other structure members: <table> <colgroup> <col span="1" style="width: 40%;"> <col span="1" style="width:
    ///60%;"> </colgroup> <tr valign="top"> <td>SEE_MASK_DEFAULT (0x00000000)</td> <td>Use default values.</td> </tr>
    ///<tr valign="top"> <td>SEE_MASK_CLASSNAME (0x00000001)</td> <td>Use the class name given by the <b>lpClass</b>
    ///member. If both SEE_MASK_CLASSKEY and SEE_MASK_CLASSNAME are set, the class key is used.</td> </tr> <tr
    ///valign="top"> <td>SEE_MASK_CLASSKEY (0x00000003) </td> <td>Use the class key given by the <b>hkeyClass</b>
    ///member. If both SEE_MASK_CLASSKEY and SEE_MASK_CLASSNAME are set, the class key is used.</td> </tr> <tr
    ///valign="top"> <td>SEE_MASK_IDLIST (0x00000004)</td> <td>Use the item identifier list given by the <b>lpIDList</b>
    ///member. The <b>lpIDList</b> member must point to an ITEMIDLIST structure.</td> </tr> <tr valign="top">
    ///<td>SEE_MASK_INVOKEIDLIST (0x0000000C)</td> <td>Use the IContextMenu interface of the selected item's shortcut
    ///menu handler. Use either <b>lpFile</b> to identify the item by its file system path or <b>lpIDList</b> to
    ///identify the item by its PIDL. This flag allows applications to use ShellExecuteEx to invoke verbs from shortcut
    ///menu extensions instead of the static verbs listed in the registry. <div class="alert"><b>Note:</b>
    ///SEE_MASK_INVOKEIDLIST overrides and implies SEE_MASK_IDLIST.</div> <div> </div> </td> </tr> <tr valign="top">
    ///<td>SEE_MASK_ICON (0x00000010)</td> <td>Use the icon given by the <b>hIcon</b> member. This flag cannot be
    ///combined with SEE_MASK_HMONITOR. <div class="alert"><b>Note:</b> This flag is used only in Windows XP and
    ///earlier. It is ignored as of Windows Vista.</div> </td> </tr> <tr valign="top"> <td>SEE_MASK_HOTKEY
    ///(0x00000020)</td> <td>Use the keyboard shortcut given by the <b>dwHotKey</b> member.</td> </tr> <tr valign="top">
    ///<td>SEE_MASK_NOCLOSEPROCESS (0x00000040)</td> <td>Use to indicate that the <b>hProcess</b> member receives the
    ///process handle. This handle is typically used to allow an application to find out when a process created with
    ///ShellExecuteEx terminates. In some cases, such as when execution is satisfied through a DDE conversation, no
    ///handle will be returned. The calling application is responsible for closing the handle when it is no longer
    ///needed.</td> </tr> <tr valign="top"> <td>SEE_MASK_CONNECTNETDRV (0x00000080)</td> <td>Validate the share and
    ///connect to a drive letter. This enables reconnection of disconnected network drives. The <b>lpFile</b> member is
    ///a UNC path of a file on a network.</td> </tr> <tr valign="top"> <td>SEE_MASK_NOASYNC (0x00000100)</td> <td>Wait
    ///for the execute operation to complete before returning. This flag should be used by callers that are using
    ///ShellExecute forms that might result in an async activation, for example DDE, and create a process that might be
    ///run on a background thread. (Note: ShellExecuteEx runs on a background thread by default if the caller's
    ///threading model is not Apartment.) Calls to <b>ShellExecuteEx</b> from processes already running on background
    ///threads should always pass this flag. Also, applications that exit immediately after calling
    ///<b>ShellExecuteEx</b> should specify this flag. If the execute operation is performed on a background thread and
    ///the caller did not specify the SEE_MASK_ASYNCOK flag, then the calling thread waits until the new process has
    ///started before returning. This typically means that either CreateProcess has been called, the DDE communication
    ///has completed, or that the custom execution delegate has notified ShellExecuteEx that it is done. If the
    ///SEE_MASK_WAITFORINPUTIDLE flag is specified, then <b>ShellExecuteEx</b> calls WaitForInputIdle and waits for the
    ///new process to idle before returning, with a maximum timeout of 1 minute. For further discussion on when this
    ///flag is necessary, see the Remarks section.</td> </tr> <tr valign="top"> <td>SEE_MASK_FLAG_DDEWAIT
    ///(0x00000100)</td> <td>The same as SEE_MASK_NOASYNC, use of that option is preferred.</td> </tr> <tr valign="top">
    ///<td>SEE_MASK_DOENVSUBST (0x00000200)</td> <td>Expand any environment variables specified in the string given by
    ///the <b>lpDirectory</b> or <b>lpFile</b> member.</td> </tr> <tr valign="top"> <td>SEE_MASK_FLAG_NO_UI
    ///(0x00000400)</td> <td>Do not display an error message box if an error occurs.</td> </tr> <tr valign="top">
    ///<td>SEE_MASK_UNICODE (0x00004000) </td> <td>Use this flag to indicate a Unicode application.</td> </tr> <tr
    ///valign="top"> <td>SEE_MASK_NO_CONSOLE (0x00008000)</td> <td>Use to inherit the parent's console for the new
    ///process instead of having it create a new console. It is the opposite of using a CREATE_NEW_CONSOLE flag with
    ///CreateProcess.</td> </tr> <tr valign="top"> <td>SEE_MASK_ASYNCOK (0x00100000) </td> <td>The execution can be
    ///performed on a background thread and the call should return immediately without waiting for the background thread
    ///to finish. Note that in certain cases ShellExecuteEx ignores this flag and waits for the process to finish before
    ///returning.</td> </tr> <tr valign="top"> <td>SEE_MASK_NOQUERYCLASSSTORE (0x01000000)</td> <td>Not used.</td> </tr>
    ///<tr valign="top"> <td>SEE_MASK_HMONITOR (0x00200000)</td> <td>Use this flag when specifying a monitor on
    ///multi-monitor systems. The monitor is specified in the <b>hMonitor</b> member. This flag cannot be combined with
    ///SEE_MASK_ICON.</td> </tr> <tr valign="top"> <td>SEE_MASK_NOZONECHECKS (0x00800000)</td> <td>Do not perform a zone
    ///check. This flag allows ShellExecuteEx to bypass zone checking put into place by IAttachmentExecute.</td> </tr>
    ///<tr valign="top"> <td>SEE_MASK_WAITFORINPUTIDLE (0x02000000)</td> <td>After the new process is created, wait for
    ///the process to become idle before returning, with a one minute timeout. See WaitForInputIdle for more
    ///details.</td> </tr> <tr valign="top"> <td>SEE_MASK_FLAG_LOG_USAGE (0x04000000)</td> <td>Indicates a user
    ///initiated launch that enables tracking of frequently used programs and other behaviors.</td> </tr> <tr
    ///valign="top"> <td>SEE_MASK_FLAG_HINST_IS_SITE` (0x08000000)</td> <td>The <b>hInstApp</b> member is used to
    ///specify the IUnknown of an object that implements IServiceProvider. This object will be used as a site pointer.
    ///The site pointer is used to provide services to the ShellExecute function, the handler binding process, and
    ///invoked verb handlers. To use <b>SEE_MASK_FLAG_HINST_IS_SITE</b> in operating systems prior to Windows 8, define
    ///it manually in your program:
    uint         fMask;
    ///Type: <b>HWND</b> Optional. A handle to the parent window, used to display any message boxes that the system
    ///might produce while executing this function. This value can be <b>NULL</b>.
    HWND         hwnd;
    ///Type: <b>LPCTSTR</b> A string, referred to as a <i>verb</i>, that specifies the action to be performed. The set
    ///of available verbs depends on the particular file or folder. Generally, the actions available from an object's
    ///shortcut menu are available verbs. This parameter can be <b>NULL</b>, in which case the default verb is used if
    ///available. If not, the "open" verb is used. If neither verb is available, the system uses the first verb listed
    ///in the registry. The following verbs are commonly used: - **edit**: Launches an editor and opens the document for
    ///editing. If <b>lpFile</b> is not a document file, the function will fail. - **explore**: Explores the folder
    ///specified by <b>lpFile</b>. - **find**: Initiates a search starting from the specified directory. - **open**:
    ///Opens the file specified by the <b>lpFile</b> parameter. The file can be an executable file, a document file, or
    ///a folder. - **print**: Prints the document file specified by <b>lpFile</b>. If <b>lpFile</b> is not a document
    ///file, the function will fail. - **properties**: Displays the file or folder's properties. - **runas**: Launches
    ///an application as Administrator. User Account Control (UAC) will prompt the user for consent to run the
    ///application elevated or enter the credentials of an administrator account used to run the application.
    const(char)* lpVerb;
    ///Type: <b>LPCTSTR</b> The address of a null-terminated string that specifies the name of the file or object on
    ///which ShellExecuteEx will perform the action specified by the <b>lpVerb</b> parameter. The system registry verbs
    ///that are supported by the <b>ShellExecuteEx</b> function include "open" for executable files and document files
    ///and "print" for document files for which a print handler has been registered. Other applications might have added
    ///Shell verbs through the system registry, such as "play" for .avi and .wav files. To specify a Shell namespace
    ///object, pass the fully qualified parse name and set the <b>SEE_MASK_INVOKEIDLIST</b> flag in the <b>fMask</b>
    ///parameter. <div class="alert"><b>Note:</b> If the <b>SEE_MASK_INVOKEIDLIST</b> flag is set, you can use either
    ///<b>lpFile</b> or <b>lpIDList</b> to identify the item by its file system path or its PIDL respectively. One of
    ///the two values—<b>lpFile</b> or <b>lpIDList</b>—must be set.</div> <div class="alert"><b>Note:</b> If the
    ///path is not included with the name, the current directory is assumed.</div>
    const(char)* lpFile;
    ///Type: <b>LPCTSTR</b> Optional. The address of a null-terminated string that contains the application parameters.
    ///The parameters must be separated by spaces. If the <b>lpFile</b> member specifies a document file,
    ///<b>lpParameters</b> should be <b>NULL</b>.
    const(char)* lpParameters;
    ///Type: <b>LPCTSTR</b> Optional. The address of a null-terminated string that specifies the name of the working
    ///directory. If this member is <b>NULL</b>, the current directory is used as the working directory.
    const(char)* lpDirectory;
    ///Type: <b>int</b> Required. Flags that specify how an application is to be shown when it is opened; one of the SW_
    ///values listed for the ShellExecute function. If <b>lpFile</b> specifies a document file, the flag is simply
    ///passed to the associated application. It is up to the application to decide how to handle it.
    int          nShow;
    ///Type: <b>HINSTANCE</b> [out] If SEE_MASK_NOCLOSEPROCESS is set and the ShellExecuteEx call succeeds, it sets this
    ///member to a value greater than 32. If the function fails, it is set to an SE_ERR_XXX error value that indicates
    ///the cause of the failure. Although <b>hInstApp</b> is declared as an HINSTANCE for compatibility with 16-bit
    ///Windows applications, it is not a true HINSTANCE. It can be cast only to an <b>int</b> and compared to either 32
    ///or the following SE_ERR_XXX error codes. <br/> | Error Code | Reason | | ---------- | ------ | | SE_ERR_FNF (2) |
    ///File not found. | | SE_ERR_PNF (3) | Path not found. | | SE_ERR_ACCESSDENIED (5) | Access denied. | | SE_ERR_OOM
    ///(8) | Out of memory. | | SE_ERR_DLLNOTFOUND (32) | Dynamic-link library not found. | | SE_ERR_SHARE (26) | Cannot
    ///share an open file. | | SE_ERR_ASSOCINCOMPLETE (27) | File association information not complete. | |
    ///SE_ERR_DDETIMEOUT (28) | DDE operation timed out. | | SE_ERR_DDEFAIL (29) | DDE operation failed. | |
    ///SE_ERR_DDEBUSY (30) | DDE operation is busy. | | SE_ERR_NOASSOC (31) | File association not available. |
    HINSTANCE    hInstApp;
    ///Type: <b>LPVOID</b> The address of an absolute ITEMIDLIST structure (PCIDLIST_ABSOLUTE) to contain an item
    ///identifier list that uniquely identifies the file to execute. This member is ignored if the <b>fMask</b> member
    ///does not include <b>SEE_MASK_IDLIST</b> or <b>SEE_MASK_INVOKEIDLIST</b>.
    void*        lpIDList;
    ///Type: <b>LPCTSTR</b> The address of a null-terminated string that specifies one of the following: - A ProgId. For
    ///example, "Paint.Picture".</li> - A URI protocol scheme. For example, "http".</li> - A file extension. For
    ///example, ".txt".</li> - A registry path under HKEY_CLASSES_ROOT that names a subkey that contains one or more
    ///Shell verbs. This key will have a subkey that conforms to the Shell verb registry schema, such as <b>shell</b>&
    const(char)* lpClass;
    ///Type: <b>HKEY</b> A handle to the registry key for the file type. The access rights for this registry key should
    ///be set to KEY_READ. This member is ignored if <b>fMask</b> does not include <b>SEE_MASK_CLASSKEY</b>.
    HKEY         hkeyClass;
    ///Type: <b>DWORD</b> A keyboard shortcut to associate with the application. The low-order word is the virtual key
    ///code, and the high-order word is a modifier flag (HOTKEYF_). For a list of modifier flags, see the description of
    ///the WM_SETHOTKEY message. This member is ignored if <b>fMask</b> does not include <b>SEE_MASK_HOTKEY</b>.
    uint         dwHotKey;
    union
    {
    align (1):
        HANDLE hIcon;
        HANDLE hMonitor;
    }
    ///Type: <b>HANDLE</b> A handle to the newly started application. This member is set on return and is always
    ///<b>NULL</b> unless <b>fMask</b> is set to <b>SEE_MASK_NOCLOSEPROCESS</b>. Even if <b>fMask</b> is set to
    ///<b>SEE_MASK_NOCLOSEPROCESS</b>, <b>hProcess</b> will be <b>NULL</b> if no process was launched. For example, if a
    ///document to be launched is a URL and an instance of Internet Explorer is already running, it will display the
    ///document. No new process is launched, and <b>hProcess</b> will be <b>NULL</b>. <div class="alert"><b>Note:</b>
    ///ShellExecuteEx does not always return an <b>hProcess</b>, even if a process is launched as the result of the
    ///call. For example, an <b>hProcess</b> does not return when you use <b>SEE_MASK_INVOKEIDLIST</b> to invoke
    ///IContextMenu.</div>
    HANDLE       hProcess;
}

///Contains information used by ShellExecuteEx.
struct SHELLEXECUTEINFOW
{
align (1):
    ///Type: <b>DWORD</b> Required. The size of this structure, in bytes.
    uint          cbSize;
    ///Type: <b>ULONG</b> A combination of one or more of the following values that indicate the content and validity of
    ///the other structure members: <table> <colgroup> <col span="1" style="width: 40%;"> <col span="1" style="width:
    ///60%;"> </colgroup> <tr valign="top"> <td>SEE_MASK_DEFAULT (0x00000000)</td> <td>Use default values.</td> </tr>
    ///<tr valign="top"> <td>SEE_MASK_CLASSNAME (0x00000001)</td> <td>Use the class name given by the <b>lpClass</b>
    ///member. If both SEE_MASK_CLASSKEY and SEE_MASK_CLASSNAME are set, the class key is used.</td> </tr> <tr
    ///valign="top"> <td>SEE_MASK_CLASSKEY (0x00000003) </td> <td>Use the class key given by the <b>hkeyClass</b>
    ///member. If both SEE_MASK_CLASSKEY and SEE_MASK_CLASSNAME are set, the class key is used.</td> </tr> <tr
    ///valign="top"> <td>SEE_MASK_IDLIST (0x00000004)</td> <td>Use the item identifier list given by the <b>lpIDList</b>
    ///member. The <b>lpIDList</b> member must point to an ITEMIDLIST structure.</td> </tr> <tr valign="top">
    ///<td>SEE_MASK_INVOKEIDLIST (0x0000000C)</td> <td>Use the IContextMenu interface of the selected item's shortcut
    ///menu handler. Use either <b>lpFile</b> to identify the item by its file system path or <b>lpIDList</b> to
    ///identify the item by its PIDL. This flag allows applications to use ShellExecuteEx to invoke verbs from shortcut
    ///menu extensions instead of the static verbs listed in the registry. <div class="alert"><b>Note:</b>
    ///SEE_MASK_INVOKEIDLIST overrides and implies SEE_MASK_IDLIST.</div> <div> </div> </td> </tr> <tr valign="top">
    ///<td>SEE_MASK_ICON (0x00000010)</td> <td>Use the icon given by the <b>hIcon</b> member. This flag cannot be
    ///combined with SEE_MASK_HMONITOR. <div class="alert"><b>Note:</b> This flag is used only in Windows XP and
    ///earlier. It is ignored as of Windows Vista.</div> </td> </tr> <tr valign="top"> <td>SEE_MASK_HOTKEY
    ///(0x00000020)</td> <td>Use the keyboard shortcut given by the <b>dwHotKey</b> member.</td> </tr> <tr valign="top">
    ///<td>SEE_MASK_NOCLOSEPROCESS (0x00000040)</td> <td>Use to indicate that the <b>hProcess</b> member receives the
    ///process handle. This handle is typically used to allow an application to find out when a process created with
    ///ShellExecuteEx terminates. In some cases, such as when execution is satisfied through a DDE conversation, no
    ///handle will be returned. The calling application is responsible for closing the handle when it is no longer
    ///needed.</td> </tr> <tr valign="top"> <td>SEE_MASK_CONNECTNETDRV (0x00000080)</td> <td>Validate the share and
    ///connect to a drive letter. This enables reconnection of disconnected network drives. The <b>lpFile</b> member is
    ///a UNC path of a file on a network.</td> </tr> <tr valign="top"> <td>SEE_MASK_NOASYNC (0x00000100)</td> <td>Wait
    ///for the execute operation to complete before returning. This flag should be used by callers that are using
    ///ShellExecute forms that might result in an async activation, for example DDE, and create a process that might be
    ///run on a background thread. (Note: ShellExecuteEx runs on a background thread by default if the caller's
    ///threading model is not Apartment.) Calls to <b>ShellExecuteEx</b> from processes already running on background
    ///threads should always pass this flag. Also, applications that exit immediately after calling
    ///<b>ShellExecuteEx</b> should specify this flag. If the execute operation is performed on a background thread and
    ///the caller did not specify the SEE_MASK_ASYNCOK flag, then the calling thread waits until the new process has
    ///started before returning. This typically means that either CreateProcess has been called, the DDE communication
    ///has completed, or that the custom execution delegate has notified ShellExecuteEx that it is done. If the
    ///SEE_MASK_WAITFORINPUTIDLE flag is specified, then <b>ShellExecuteEx</b> calls WaitForInputIdle and waits for the
    ///new process to idle before returning, with a maximum timeout of 1 minute. For further discussion on when this
    ///flag is necessary, see the Remarks section.</td> </tr> <tr valign="top"> <td>SEE_MASK_FLAG_DDEWAIT
    ///(0x00000100)</td> <td>The same as SEE_MASK_NOASYNC, use of that option is preferred.</td> </tr> <tr valign="top">
    ///<td>SEE_MASK_DOENVSUBST (0x00000200)</td> <td>Expand any environment variables specified in the string given by
    ///the <b>lpDirectory</b> or <b>lpFile</b> member.</td> </tr> <tr valign="top"> <td>SEE_MASK_FLAG_NO_UI
    ///(0x00000400)</td> <td>Do not display an error message box if an error occurs.</td> </tr> <tr valign="top">
    ///<td>SEE_MASK_UNICODE (0x00004000) </td> <td>Use this flag to indicate a Unicode application.</td> </tr> <tr
    ///valign="top"> <td>SEE_MASK_NO_CONSOLE (0x00008000)</td> <td>Use to inherit the parent's console for the new
    ///process instead of having it create a new console. It is the opposite of using a CREATE_NEW_CONSOLE flag with
    ///CreateProcess.</td> </tr> <tr valign="top"> <td>SEE_MASK_ASYNCOK (0x00100000) </td> <td>The execution can be
    ///performed on a background thread and the call should return immediately without waiting for the background thread
    ///to finish. Note that in certain cases ShellExecuteEx ignores this flag and waits for the process to finish before
    ///returning.</td> </tr> <tr valign="top"> <td>SEE_MASK_NOQUERYCLASSSTORE (0x01000000)</td> <td>Not used.</td> </tr>
    ///<tr valign="top"> <td>SEE_MASK_HMONITOR (0x00200000)</td> <td>Use this flag when specifying a monitor on
    ///multi-monitor systems. The monitor is specified in the <b>hMonitor</b> member. This flag cannot be combined with
    ///SEE_MASK_ICON.</td> </tr> <tr valign="top"> <td>SEE_MASK_NOZONECHECKS (0x00800000)</td> <td>Do not perform a zone
    ///check. This flag allows ShellExecuteEx to bypass zone checking put into place by IAttachmentExecute.</td> </tr>
    ///<tr valign="top"> <td>SEE_MASK_WAITFORINPUTIDLE (0x02000000)</td> <td>After the new process is created, wait for
    ///the process to become idle before returning, with a one minute timeout. See WaitForInputIdle for more
    ///details.</td> </tr> <tr valign="top"> <td>SEE_MASK_FLAG_LOG_USAGE (0x04000000)</td> <td>Indicates a user
    ///initiated launch that enables tracking of frequently used programs and other behaviors.</td> </tr> <tr
    ///valign="top"> <td>SEE_MASK_FLAG_HINST_IS_SITE` (0x08000000)</td> <td>The <b>hInstApp</b> member is used to
    ///specify the IUnknown of an object that implements IServiceProvider. This object will be used as a site pointer.
    ///The site pointer is used to provide services to the ShellExecute function, the handler binding process, and
    ///invoked verb handlers. To use <b>SEE_MASK_FLAG_HINST_IS_SITE</b> in operating systems prior to Windows 8, define
    ///it manually in your program:
    uint          fMask;
    ///Type: <b>HWND</b> Optional. A handle to the parent window, used to display any message boxes that the system
    ///might produce while executing this function. This value can be <b>NULL</b>.
    HWND          hwnd;
    ///Type: <b>LPCTSTR</b> A string, referred to as a <i>verb</i>, that specifies the action to be performed. The set
    ///of available verbs depends on the particular file or folder. Generally, the actions available from an object's
    ///shortcut menu are available verbs. This parameter can be <b>NULL</b>, in which case the default verb is used if
    ///available. If not, the "open" verb is used. If neither verb is available, the system uses the first verb listed
    ///in the registry. The following verbs are commonly used: - **edit**: Launches an editor and opens the document for
    ///editing. If <b>lpFile</b> is not a document file, the function will fail. - **explore**: Explores the folder
    ///specified by <b>lpFile</b>. - **find**: Initiates a search starting from the specified directory. - **open**:
    ///Opens the file specified by the <b>lpFile</b> parameter. The file can be an executable file, a document file, or
    ///a folder. - **print**: Prints the document file specified by <b>lpFile</b>. If <b>lpFile</b> is not a document
    ///file, the function will fail. - **properties**: Displays the file or folder's properties. - **runas**: Launches
    ///an application as Administrator. User Account Control (UAC) will prompt the user for consent to run the
    ///application elevated or enter the credentials of an administrator account used to run the application.
    const(wchar)* lpVerb;
    ///Type: <b>LPCTSTR</b> The address of a null-terminated string that specifies the name of the file or object on
    ///which ShellExecuteEx will perform the action specified by the <b>lpVerb</b> parameter. The system registry verbs
    ///that are supported by the <b>ShellExecuteEx</b> function include "open" for executable files and document files
    ///and "print" for document files for which a print handler has been registered. Other applications might have added
    ///Shell verbs through the system registry, such as "play" for .avi and .wav files. To specify a Shell namespace
    ///object, pass the fully qualified parse name and set the <b>SEE_MASK_INVOKEIDLIST</b> flag in the <b>fMask</b>
    ///parameter. <div class="alert"><b>Note:</b> If the <b>SEE_MASK_INVOKEIDLIST</b> flag is set, you can use either
    ///<b>lpFile</b> or <b>lpIDList</b> to identify the item by its file system path or its PIDL respectively. One of
    ///the two values—<b>lpFile</b> or <b>lpIDList</b>—must be set.</div> <div class="alert"><b>Note:</b> If the
    ///path is not included with the name, the current directory is assumed.</div>
    const(wchar)* lpFile;
    ///Type: <b>LPCTSTR</b> Optional. The address of a null-terminated string that contains the application parameters.
    ///The parameters must be separated by spaces. If the <b>lpFile</b> member specifies a document file,
    ///<b>lpParameters</b> should be <b>NULL</b>.
    const(wchar)* lpParameters;
    ///Type: <b>LPCTSTR</b> Optional. The address of a null-terminated string that specifies the name of the working
    ///directory. If this member is <b>NULL</b>, the current directory is used as the working directory.
    const(wchar)* lpDirectory;
    ///Type: <b>int</b> Required. Flags that specify how an application is to be shown when it is opened; one of the SW_
    ///values listed for the ShellExecute function. If <b>lpFile</b> specifies a document file, the flag is simply
    ///passed to the associated application. It is up to the application to decide how to handle it.
    int           nShow;
    ///Type: <b>HINSTANCE</b> [out] If SEE_MASK_NOCLOSEPROCESS is set and the ShellExecuteEx call succeeds, it sets this
    ///member to a value greater than 32. If the function fails, it is set to an SE_ERR_XXX error value that indicates
    ///the cause of the failure. Although <b>hInstApp</b> is declared as an HINSTANCE for compatibility with 16-bit
    ///Windows applications, it is not a true HINSTANCE. It can be cast only to an <b>int</b> and compared to either 32
    ///or the following SE_ERR_XXX error codes. <br/> | Error Code | Reason | | ---------- | ------ | | SE_ERR_FNF (2) |
    ///File not found. | | SE_ERR_PNF (3) | Path not found. | | SE_ERR_ACCESSDENIED (5) | Access denied. | | SE_ERR_OOM
    ///(8) | Out of memory. | | SE_ERR_DLLNOTFOUND (32) | Dynamic-link library not found. | | SE_ERR_SHARE (26) | Cannot
    ///share an open file. | | SE_ERR_ASSOCINCOMPLETE (27) | File association information not complete. | |
    ///SE_ERR_DDETIMEOUT (28) | DDE operation timed out. | | SE_ERR_DDEFAIL (29) | DDE operation failed. | |
    ///SE_ERR_DDEBUSY (30) | DDE operation is busy. | | SE_ERR_NOASSOC (31) | File association not available. |
    HINSTANCE     hInstApp;
    ///Type: <b>LPVOID</b> The address of an absolute ITEMIDLIST structure (PCIDLIST_ABSOLUTE) to contain an item
    ///identifier list that uniquely identifies the file to execute. This member is ignored if the <b>fMask</b> member
    ///does not include <b>SEE_MASK_IDLIST</b> or <b>SEE_MASK_INVOKEIDLIST</b>.
    void*         lpIDList;
    ///Type: <b>LPCTSTR</b> The address of a null-terminated string that specifies one of the following: - A ProgId. For
    ///example, "Paint.Picture".</li> - A URI protocol scheme. For example, "http".</li> - A file extension. For
    ///example, ".txt".</li> - A registry path under HKEY_CLASSES_ROOT that names a subkey that contains one or more
    ///Shell verbs. This key will have a subkey that conforms to the Shell verb registry schema, such as <b>shell</b>&
    const(wchar)* lpClass;
    ///Type: <b>HKEY</b> A handle to the registry key for the file type. The access rights for this registry key should
    ///be set to KEY_READ. This member is ignored if <b>fMask</b> does not include <b>SEE_MASK_CLASSKEY</b>.
    HKEY          hkeyClass;
    ///Type: <b>DWORD</b> A keyboard shortcut to associate with the application. The low-order word is the virtual key
    ///code, and the high-order word is a modifier flag (HOTKEYF_). For a list of modifier flags, see the description of
    ///the WM_SETHOTKEY message. This member is ignored if <b>fMask</b> does not include <b>SEE_MASK_HOTKEY</b>.
    uint          dwHotKey;
    union
    {
    align (1):
        HANDLE hIcon;
        HANDLE hMonitor;
    }
    ///Type: <b>HANDLE</b> A handle to the newly started application. This member is set on return and is always
    ///<b>NULL</b> unless <b>fMask</b> is set to <b>SEE_MASK_NOCLOSEPROCESS</b>. Even if <b>fMask</b> is set to
    ///<b>SEE_MASK_NOCLOSEPROCESS</b>, <b>hProcess</b> will be <b>NULL</b> if no process was launched. For example, if a
    ///document to be launched is a URL and an instance of Internet Explorer is already running, it will display the
    ///document. No new process is launched, and <b>hProcess</b> will be <b>NULL</b>. <div class="alert"><b>Note:</b>
    ///ShellExecuteEx does not always return an <b>hProcess</b>, even if a process is launched as the result of the
    ///call. For example, an <b>hProcess</b> does not return when you use <b>SEE_MASK_INVOKEIDLIST</b> to invoke
    ///IContextMenu.</div>
    HANDLE        hProcess;
}

///<p class="CCE_Message">[SHCreateProcessAsUserW is no longer implemented in Windows XP or later versions.] Contains
///the information needed by SHCreateProcessAsUserW to create a process.
struct SHCREATEPROCESSINFOW
{
align (1):
    ///Type: <b>DWORD</b> The size, in bytes, of this structure.
    uint                 cbSize;
    ///Type: <b>ULONG</b> An array of flags that indicates the content and validity of the other structure members. This
    ///can be a combination of the following values.
    uint                 fMask;
    ///Type: <b>HWND</b> A parent window handle.
    HWND                 hwnd;
    ///Type: <b>LPCWSTR</b> A pointer to a null-terminated Unicode string that specifies the executable file on which
    ///SHCreateProcessAsUserW will perform the action specified by the <b>runas</b> verb. The <b>runas</b> verb must be
    ///supported by the file's class. <div class="alert"><b>Note</b> If the path is not included with the file name, the
    ///current directory is assumed.</div> <div> </div>
    const(wchar)*        pszFile;
    ///Type: <b>LPCWSTR</b> A pointer to a null-terminated Unicode string containing the application parameters. The
    ///parameters must be separated by spaces.
    const(wchar)*        pszParameters;
    ///Type: <b>LPCWSTR</b> A null-terminated Unicode string that contains the current directory.
    const(wchar)*        pszCurrentDirectory;
    ///Type: <b>HANDLE</b> An Access token that can be used to represent a particular user. It is needed when there are
    ///multiple users for those folders that are treated as belonging to a single user. The calling application must
    ///have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and
    ///the user's registry hive must be currently mounted. For further discussion of access control issues, see Access
    ///Control.
    HANDLE               hUserToken;
    ///Type: <b>LPSECURITY_ATTRIBUTES</b> A pointer to a SECURITY_ATTRIBUTES structure with the security descriptor for
    ///the new process. It also specifies whether a child process can be inherited. If this parameter is set to
    ///<b>NULL</b>, the process will have a default security descriptor and the handle cannot be inherited. <b>Security
    ///Warning: </b>Using a security descriptor incorrectly can compromise the security of your application. For more
    ///information, see SECURITY_ATTRIBUTES.
    SECURITY_ATTRIBUTES* lpProcessAttributes;
    ///Type: <b>LPSECURITY_ATTRIBUTES</b> A pointer to a SECURITY_ATTRIBUTES structure with the security descriptor for
    ///the new thread. It also specifies whether a child process can be inherited. If this parameter is set to
    ///<b>NULL</b>, the process will have a default security descriptor and the handle cannot be inherited. <b>Security
    ///Warning: </b>Using a security descriptor incorrectly can compromise the security of your application. For more
    ///information, see SECURITY_ATTRIBUTES.
    SECURITY_ATTRIBUTES* lpThreadAttributes;
    ///Type: <b>BOOL</b> An indicator for whether the new process inherits handles from the calling process. If set to
    ///<b>TRUE</b>, each inheritable open handle in the calling process is inherited by the new process. Inherited
    ///handles have the same value and access privileges as the original handles.
    BOOL                 bInheritHandles;
    ///Type: <b>DWORD</b> Flags that control the creation of the process and the priority class. For a list of the
    ///available flags, see CreateProcessAsUser.
    uint                 dwCreationFlags;
    ///Type: <b>LPSTARTUPINFOW</b> A pointer to a STARTUPINFO structure that specifies how the main window for the new
    ///process should appear.
    STARTUPINFOW*        lpStartupInfo;
    ///Type: <b>LPPROCESS_INFORMATION</b> A pointer to a PROCESS_INFORMATION structure that receives information about
    ///the new process. Set this member to a valid structure pointer, and set the SEE_MASK_NOCLOSEPROCESS flag in the
    ///<b>fMask</b> member, and the process will remain open when the function returns. The <b>PROCESS_INFORMATION</b>
    ///structure's <b>hProcess</b> and <b>hThread</b> members will then hold the process and thread handles,
    ///respectively. Set this member to <b>NULL</b>, and the process will be closed before the function returns.
    PROCESS_INFORMATION* lpProcessInformation;
}

///Defines information used by AssocCreateForClasses to retrieve an IQueryAssociations interface for a given file
///association.
struct ASSOCIATIONELEMENT
{
align (1):
    ///Type: <b>ASSOCCLASS</b> Where to obtain association data and the form the data is stored in. One of the following
    ///values from the <b>ASSOCCLASS</b> enumeration.
    ASSOCCLASS    ac;
    ///Type: <b>HKEY</b> A registry key that specifies a class that contains association information.
    HKEY          hkClass;
    ///Type: <b>PCWSTR</b> A pointer to the name of a class that contains association information.
    const(wchar)* pszClass;
}

///Contains the size and item count information retrieved by the SHQueryRecycleBin function.
struct SHQUERYRBINFO
{
align (1):
    ///Type: <b>DWORD</b> The size of the structure, in bytes. This member must be filled in prior to calling the
    ///function.
    uint cbSize;
    ///Type: <b>__int64</b> The total size of all the objects in the specified Recycle Bin, in bytes.
    long i64Size;
    long i64NumItems;
}

///Contains information that the system needs to display notifications in the notification area. Used by
///Shell_NotifyIcon.
struct NOTIFYICONDATAA
{
align (1):
    ///Type: <b>DWORD</b> The size of this structure, in bytes.
    uint      cbSize;
    ///Type: <b>HWND</b> A handle to the window that receives notifications associated with an icon in the notification
    ///area.
    HWND      hWnd;
    ///Type: <b>UINT</b> The application-defined identifier of the taskbar icon. The Shell uses either (<b>hWnd</b> plus
    ///<b>uID</b>) or <b>guidItem</b> to identify which icon to operate on when Shell_NotifyIcon is invoked. You can
    ///have multiple icons associated with a single <b>hWnd</b> by assigning each a different <b>uID</b>. If
    ///<b>guidItem</b> is specified, <b>uID</b> is ignored.
    uint      uID;
    ///Type: <b>UINT</b> Flags that either indicate which of the other members of the structure contain valid data or
    ///provide additional information to the tooltip as to how it should display. This member can be a combination of
    ///the following values:
    uint      uFlags;
    ///Type: <b>UINT</b> An application-defined message identifier. The system uses this identifier to send notification
    ///messages to the window identified in <b>hWnd</b>. These notification messages are sent when a mouse event or
    ///hover occurs in the bounding rectangle of the icon, when the icon is selected or activated with the keyboard, or
    ///when those actions occur in the balloon notification. When the <b>uVersion</b> member is either 0 or
    ///NOTIFYICON_VERSION, the <i>wParam</i> parameter of the message contains the identifier of the taskbar icon in
    ///which the event occurred. This identifier can be 32 bits in length. The <i>lParam</i> parameter holds the mouse
    ///or keyboard message associated with the event. For example, when the pointer moves over a taskbar icon,
    ///<i>lParam</i> is set to WM_MOUSEMOVE. When the <b>uVersion</b> member is NOTIFYICON_VERSION_4, applications
    ///continue to receive notification events in the form of application-defined messages through the
    ///<b>uCallbackMessage</b> member, but the interpretation of the <i>lParam</i> and <i>wParam</i> parameters of that
    ///message is changed as follows: <ul> <li> LOWORD(lParam) contains notification events, such as NIN_BALLOONSHOW,
    ///NIN_POPUPOPEN, or WM_CONTEXTMENU.</li> <li> HIWORD(lParam) contains the icon ID. Icon IDs are restricted to a
    ///length of 16 bits.</li> <li> GET_X_LPARAM(wParam) returns the X anchor coordinate for notification events
    ///NIN_POPUPOPEN, NIN_SELECT, NIN_KEYSELECT, and all mouse messages between WM_MOUSEFIRST and WM_MOUSELAST. If any
    ///of those messages are generated by the keyboard, <i>wParam</i> is set to the upper-left corner of the target
    ///icon. For all other messages, <i>wParam</i> is undefined.</li> <li> GET_Y_LPARAM(wParam) returns the Y anchor
    ///coordinate for notification events and messages as defined for the X anchor.</li> </ul>
    uint      uCallbackMessage;
    ///Type: <b>HICON</b> A handle to the icon to be added, modified, or deleted. Windows XP and later support icons of
    ///up to 32 BPP. If only a 16x16 pixel icon is provided, it is scaled to a larger size in a system set to a high dpi
    ///value. This can lead to an unattractive result. It is recommended that you provide both a 16x16 pixel icon and a
    ///32x32 icon in your resource file. Use LoadIconMetric to ensure that the correct icon is loaded and scaled
    ///appropriately. See Remarks for a code example.
    HICON     hIcon;
    ///Type: <b>TCHAR[64]</b> A null-terminated string that specifies the text for a standard tooltip. It can have a
    ///maximum of 64 characters, including the terminating null character. For Windows 2000 and later, <b>szTip</b> can
    ///have a maximum of 128 characters, including the terminating null character.
    byte[128] szTip;
    ///Type: <b>DWORD</b> <b>Windows 2000 and later</b>. The state of the icon. One or both of the following values:
    uint      dwState;
    ///Type: <b>DWORD</b> <b>Windows 2000 and later</b>. A value that specifies which bits of the <b>dwState</b> member
    ///are retrieved or modified. The possible values are the same as those for <b>dwState</b>. For example, setting
    ///this member to <b>NIS_HIDDEN</b> causes only the item's hidden state to be modified while the icon sharing bit is
    ///ignored regardless of its value.
    uint      dwStateMask;
    ///Type: <b>TCHAR[256]</b> <b>Windows 2000 and later</b>. A null-terminated string that specifies the text to
    ///display in a balloon notification. It can have a maximum of 256 characters, including the terminating null
    ///character, but should be restricted to 200 characters in English to accommodate localization. To remove the
    ///balloon notification from the UI, either delete the icon (with NIM_DELETE) or set the <b>NIF_INFO</b> flag in
    ///<b>uFlags</b> and set <b>szInfo</b> to an empty string.
    byte[256] szInfo;
    union
    {
    align (1):
        uint uTimeout;
        uint uVersion;
    }
    ///Type: <b>TCHAR[64]</b> <b>Windows 2000 and later</b>. A null-terminated string that specifies a title for a
    ///balloon notification. This title appears in a larger font immediately above the text. It can have a maximum of 64
    ///characters, including the terminating null character, but should be restricted to 48 characters in English to
    ///accommodate localization.
    byte[64]  szInfoTitle;
    ///Type: <b>DWORD</b> <b>Windows 2000 and later</b>. Flags that can be set to modify the behavior and appearance of
    ///a balloon notification. The icon is placed to the left of the title. If the <b>szInfoTitle</b> member is
    ///zero-length, the icon is not shown.
    uint      dwInfoFlags;
    ///Type: <b>GUID</b> <b>Windows XP and later</b>. <ul> <li><b>Windows 7 and later</b>: A registered GUID that
    ///identifies the icon. This value overrides <b>uID</b> and is the recommended method of identifying the icon. The
    ///NIF_GUID flag must be set in the <b>uFlags</b> member.</li> <li><b>Windows XP and Windows Vista</b>: Reserved;
    ///must be set to 0.</li> </ul> If your application is intended to run on both Windows Vista and Windows 7, it is
    ///imperative that you check the version of Windows and only specify a nonzero <b>guidItem</b> if on Windows 7 or
    ///later. If you identify the notification icon with a GUID in one call to Shell_NotifyIcon, you must use that same
    ///GUID to identify the icon in any subsequent <b>Shell_NotifyIcon</b> calls that deal with that same icon. To
    ///generate a GUID for use in this member, use a GUID-generating tool such as Guidgen.exe.
    GUID      guidItem;
    ///Type: <b>HICON</b> <b>Windows Vista and later</b>. The handle of a customized notification icon provided by the
    ///application that should be used independently of the notification area icon. If this member is non-NULL and the
    ///NIIF_USER flag is set in the <b>dwInfoFlags</b> member, this icon is used as the notification icon. If this
    ///member is <b>NULL</b>, the legacy behavior is carried out.
    HICON     hBalloonIcon;
}

///Contains information that the system needs to display notifications in the notification area. Used by
///Shell_NotifyIcon.
struct NOTIFYICONDATAW
{
align (1):
    ///Type: <b>DWORD</b> The size of this structure, in bytes.
    uint        cbSize;
    ///Type: <b>HWND</b> A handle to the window that receives notifications associated with an icon in the notification
    ///area.
    HWND        hWnd;
    ///Type: <b>UINT</b> The application-defined identifier of the taskbar icon. The Shell uses either (<b>hWnd</b> plus
    ///<b>uID</b>) or <b>guidItem</b> to identify which icon to operate on when Shell_NotifyIcon is invoked. You can
    ///have multiple icons associated with a single <b>hWnd</b> by assigning each a different <b>uID</b>. If
    ///<b>guidItem</b> is specified, <b>uID</b> is ignored.
    uint        uID;
    ///Type: <b>UINT</b> Flags that either indicate which of the other members of the structure contain valid data or
    ///provide additional information to the tooltip as to how it should display. This member can be a combination of
    ///the following values:
    uint        uFlags;
    ///Type: <b>UINT</b> An application-defined message identifier. The system uses this identifier to send notification
    ///messages to the window identified in <b>hWnd</b>. These notification messages are sent when a mouse event or
    ///hover occurs in the bounding rectangle of the icon, when the icon is selected or activated with the keyboard, or
    ///when those actions occur in the balloon notification. When the <b>uVersion</b> member is either 0 or
    ///NOTIFYICON_VERSION, the <i>wParam</i> parameter of the message contains the identifier of the taskbar icon in
    ///which the event occurred. This identifier can be 32 bits in length. The <i>lParam</i> parameter holds the mouse
    ///or keyboard message associated with the event. For example, when the pointer moves over a taskbar icon,
    ///<i>lParam</i> is set to WM_MOUSEMOVE. When the <b>uVersion</b> member is NOTIFYICON_VERSION_4, applications
    ///continue to receive notification events in the form of application-defined messages through the
    ///<b>uCallbackMessage</b> member, but the interpretation of the <i>lParam</i> and <i>wParam</i> parameters of that
    ///message is changed as follows: <ul> <li> LOWORD(lParam) contains notification events, such as NIN_BALLOONSHOW,
    ///NIN_POPUPOPEN, or WM_CONTEXTMENU.</li> <li> HIWORD(lParam) contains the icon ID. Icon IDs are restricted to a
    ///length of 16 bits.</li> <li> GET_X_LPARAM(wParam) returns the X anchor coordinate for notification events
    ///NIN_POPUPOPEN, NIN_SELECT, NIN_KEYSELECT, and all mouse messages between WM_MOUSEFIRST and WM_MOUSELAST. If any
    ///of those messages are generated by the keyboard, <i>wParam</i> is set to the upper-left corner of the target
    ///icon. For all other messages, <i>wParam</i> is undefined.</li> <li> GET_Y_LPARAM(wParam) returns the Y anchor
    ///coordinate for notification events and messages as defined for the X anchor.</li> </ul>
    uint        uCallbackMessage;
    ///Type: <b>HICON</b> A handle to the icon to be added, modified, or deleted. Windows XP and later support icons of
    ///up to 32 BPP. If only a 16x16 pixel icon is provided, it is scaled to a larger size in a system set to a high dpi
    ///value. This can lead to an unattractive result. It is recommended that you provide both a 16x16 pixel icon and a
    ///32x32 icon in your resource file. Use LoadIconMetric to ensure that the correct icon is loaded and scaled
    ///appropriately. See Remarks for a code example.
    HICON       hIcon;
    ///Type: <b>TCHAR[64]</b> A null-terminated string that specifies the text for a standard tooltip. It can have a
    ///maximum of 64 characters, including the terminating null character. For Windows 2000 and later, <b>szTip</b> can
    ///have a maximum of 128 characters, including the terminating null character.
    ushort[128] szTip;
    ///Type: <b>DWORD</b> <b>Windows 2000 and later</b>. The state of the icon. One or both of the following values:
    uint        dwState;
    ///Type: <b>DWORD</b> <b>Windows 2000 and later</b>. A value that specifies which bits of the <b>dwState</b> member
    ///are retrieved or modified. The possible values are the same as those for <b>dwState</b>. For example, setting
    ///this member to <b>NIS_HIDDEN</b> causes only the item's hidden state to be modified while the icon sharing bit is
    ///ignored regardless of its value.
    uint        dwStateMask;
    ///Type: <b>TCHAR[256]</b> <b>Windows 2000 and later</b>. A null-terminated string that specifies the text to
    ///display in a balloon notification. It can have a maximum of 256 characters, including the terminating null
    ///character, but should be restricted to 200 characters in English to accommodate localization. To remove the
    ///balloon notification from the UI, either delete the icon (with NIM_DELETE) or set the <b>NIF_INFO</b> flag in
    ///<b>uFlags</b> and set <b>szInfo</b> to an empty string.
    ushort[256] szInfo;
    union
    {
    align (1):
        uint uTimeout;
        uint uVersion;
    }
    ///Type: <b>TCHAR[64]</b> <b>Windows 2000 and later</b>. A null-terminated string that specifies a title for a
    ///balloon notification. This title appears in a larger font immediately above the text. It can have a maximum of 64
    ///characters, including the terminating null character, but should be restricted to 48 characters in English to
    ///accommodate localization.
    ushort[64]  szInfoTitle;
    ///Type: <b>DWORD</b> <b>Windows 2000 and later</b>. Flags that can be set to modify the behavior and appearance of
    ///a balloon notification. The icon is placed to the left of the title. If the <b>szInfoTitle</b> member is
    ///zero-length, the icon is not shown.
    uint        dwInfoFlags;
    ///Type: <b>GUID</b> <b>Windows XP and later</b>. <ul> <li><b>Windows 7 and later</b>: A registered GUID that
    ///identifies the icon. This value overrides <b>uID</b> and is the recommended method of identifying the icon. The
    ///NIF_GUID flag must be set in the <b>uFlags</b> member.</li> <li><b>Windows XP and Windows Vista</b>: Reserved;
    ///must be set to 0.</li> </ul> If your application is intended to run on both Windows Vista and Windows 7, it is
    ///imperative that you check the version of Windows and only specify a nonzero <b>guidItem</b> if on Windows 7 or
    ///later. If you identify the notification icon with a GUID in one call to Shell_NotifyIcon, you must use that same
    ///GUID to identify the icon in any subsequent <b>Shell_NotifyIcon</b> calls that deal with that same icon. To
    ///generate a GUID for use in this member, use a GUID-generating tool such as Guidgen.exe.
    GUID        guidItem;
    ///Type: <b>HICON</b> <b>Windows Vista and later</b>. The handle of a customized notification icon provided by the
    ///application that should be used independently of the notification area icon. If this member is non-NULL and the
    ///NIIF_USER flag is set in the <b>dwInfoFlags</b> member, this icon is used as the notification icon. If this
    ///member is <b>NULL</b>, the legacy behavior is carried out.
    HICON       hBalloonIcon;
}

///Contains information used by Shell_NotifyIconGetRect to identify the icon for which to retrieve the bounding
///rectangle.
struct NOTIFYICONIDENTIFIER
{
align (1):
    ///Type: <b>DWORD</b> The size of this structure, in bytes.
    uint cbSize;
    ///Type: <b>HWND</b> A handle to the parent window used by the notification's callback function. For more
    ///information, see the <i>hWnd</i> member of the NOTIFYICONDATA structure.
    HWND hWnd;
    ///Type: <b>UINT</b> The application-defined identifier of the notification icon. Multiple icons can be associated
    ///with a single <i>hWnd</i>, each with their own <i>uID</i>.
    uint uID;
    ///Type: <b>GUID</b> A registered GUID that identifies the icon. Use <b>GUID_NULL</b> if the icon is not identified
    ///by a GUID.
    GUID guidItem;
}

///Contains information about a file object.
struct SHFILEINFOA
{
align (1):
    ///Type: <b>HICON</b> A handle to the icon that represents the file. You are responsible for destroying this handle
    ///with DestroyIcon when you no longer need it.
    HICON     hIcon;
    ///Type: <b>int</b> The index of the icon image within the system image list.
    int       iIcon;
    ///Type: <b>DWORD</b> An array of values that indicates the attributes of the file object. For information about
    ///these values, see the IShellFolder::GetAttributesOf method.
    uint      dwAttributes;
    ///Type: <b>TCHAR[MAX_PATH]</b> A string that contains the name of the file as it appears in the Windows Shell, or
    ///the path and file name of the file that contains the icon representing the file.
    byte[260] szDisplayName;
    ///Type: <b>TCHAR[80]</b> A string that describes the type of file.
    byte[80]  szTypeName;
}

///Contains information about a file object.
struct SHFILEINFOW
{
align (1):
    ///Type: <b>HICON</b> A handle to the icon that represents the file. You are responsible for destroying this handle
    ///with DestroyIcon when you no longer need it.
    HICON       hIcon;
    ///Type: <b>int</b> The index of the icon image within the system image list.
    int         iIcon;
    ///Type: <b>DWORD</b> An array of values that indicates the attributes of the file object. For information about
    ///these values, see the IShellFolder::GetAttributesOf method.
    uint        dwAttributes;
    ///Type: <b>TCHAR[MAX_PATH]</b> A string that contains the name of the file as it appears in the Windows Shell, or
    ///the path and file name of the file that contains the icon representing the file.
    ushort[260] szDisplayName;
    ///Type: <b>TCHAR[80]</b> A string that describes the type of file.
    ushort[80]  szTypeName;
}

///Receives information used to retrieve a stock Shell icon. This structure is used in a call SHGetStockIconInfo.
struct SHSTOCKICONINFO
{
align (1):
    ///Type: <b>DWORD</b> The size of this structure, in bytes.
    uint        cbSize;
    ///Type: <b>HICON</b> When SHGetStockIconInfo is called with the SHGSI_ICON flag, this member receives a handle to
    ///the icon.
    HICON       hIcon;
    ///Type: <b>int</b> When SHGetStockIconInfo is called with the SHGSI_SYSICONINDEX flag, this member receives the
    ///index of the image in the system icon cache.
    int         iSysImageIndex;
    ///Type: <b>int</b> When SHGetStockIconInfo is called with the SHGSI_ICONLOCATION flag, this member receives the
    ///index of the icon in the resource whose path is received in <b>szPath</b>.
    int         iIcon;
    ///Type: <b>WCHAR[MAX_PATH]</b> When SHGetStockIconInfo is called with the SHGSI_ICONLOCATION flag, this member
    ///receives the path of the resource that contains the icon. The index of the icon within the resource is received
    ///in <b>iIcon</b>.
    ushort[260] szPath;
}

///Identifies a particular property sheet in a printer's property pages and whether that property sheet should be modal.
///Optionally used with the SHInvokePrinterCommand function.
struct OPEN_PRINTER_PROPS_INFOA
{
align (1):
    ///Type: <b>DWORD</b> The size of the structure.
    uint         dwSize;
    ///Type: <b>LPSTR</b> The name of the property sheet. If the specified sheet is not found, the property sheet still
    ///appears with the default first page.
    const(char)* pszSheetName;
    ///Type: <b>UINT</b> The index of the property sheet in the array of property sheets that makes up the window. If
    ///empty or invalid, the default first page is displayed.
    uint         uSheetIndex;
    ///Type: <b>DWORD</b> Not used.
    uint         dwFlags;
    ///Type: <b>BOOL</b> <b>TRUE</b> if the property sheet should be modal; otherwise, <b>FALSE</b>.
    BOOL         bModal;
}

///Identifies a particular property sheet in a printer's property pages and whether that property sheet should be modal.
///Optionally used with the SHInvokePrinterCommand function.
struct OPEN_PRINTER_PROPS_INFOW
{
align (1):
    ///Type: <b>DWORD</b> The size of the structure.
    uint          dwSize;
    ///Type: <b>LPSTR</b> The name of the property sheet. If the specified sheet is not found, the property sheet still
    ///appears with the default first page.
    const(wchar)* pszSheetName;
    ///Type: <b>UINT</b> The index of the property sheet in the array of property sheets that makes up the window. If
    ///empty or invalid, the default first page is displayed.
    uint          uSheetIndex;
    ///Type: <b>DWORD</b> Not used.
    uint          dwFlags;
    ///Type: <b>BOOL</b> <b>TRUE</b> if the property sheet should be modal; otherwise, <b>FALSE</b>.
    BOOL          bModal;
}

struct IMarkupCallback
{
}

struct IControlMarkup
{
}

///Defines an item identifier.
struct SHITEMID
{
align (1):
    ///Type: <b>USHORT</b> The size of identifier, in bytes, including <b>cb</b> itself.
    ushort   cb;
    ubyte[1] abID;
}

///Contains a list of item identifiers.
struct ITEMIDLIST
{
    ///Type: <b>SHITEMID</b> A list of item identifiers.
    SHITEMID mkid;
}

///Contains strings returned from the IShellFolder interface methods.
struct STRRET
{
    ///Type: <b>UINT</b> A value that specifies the desired format of the string. This can be one of the following
    ///values.
    uint uType;
    union
    {
        const(wchar)* pOleStr;
        uint          uOffset;
        byte[260]     cStr;
    }
}

///Reports detailed information on an item in a Shell folder.
struct SHELLDETAILS
{
align (1):
    ///Type: <b>int</b> The alignment of the column heading and the subitem text in the column. This member can be one
    ///of the following values.
    int    fmt;
    ///Type: <b>int</b> The number of average-sized characters in the header.
    int    cxChar;
    ///Type: <b>STRRET</b> An STRRET structure that includes a string with the requested information. To convert this
    ///structure to a string, use StrRetToBuf or StrRetToStr.
    STRRET str;
}

///Used generically to filter elements.
struct COMDLG_FILTERSPEC
{
    ///Type: <b>LPCWSTR</b> A pointer to a buffer that contains the friendly name of the filter.
    const(wchar)* pszName;
    const(wchar)* pszSpec;
}

///Contains information needed by IContextMenu::InvokeCommand to invoke a shortcut menu command.
struct CMINVOKECOMMANDINFO
{
    ///Type: <b>DWORD</b> The size of this structure, in bytes.
    uint         cbSize;
    ///Type: <b>DWORD</b> Zero, or one or more of the following flags.
    uint         fMask;
    ///Type: <b>HWND</b> A handle to the window that is the owner of the shortcut menu. An extension can also use this
    ///handle as the owner of any message boxes or dialog boxes it displays.
    HWND         hwnd;
    ///Type: <b>LPCSTR</b> The address of a null-terminated string that specifies the language-independent name of the
    ///command to carry out. This member is typically a string when a command is being activated by an application. The
    ///system provides predefined constant values for the following command strings. <table class="clsStd"> <tr>
    ///<th>Constant</th> <th>Command string</th> </tr> <tr> <td>CMDSTR_RUNAS</td> <td>"RunAs"</td> </tr> <tr>
    ///<td>CMDSTR_PRINT</td> <td>"Print"</td> </tr> <tr> <td>CMDSTR_PREVIEW</td> <td>"Preview"</td> </tr> <tr>
    ///<td>CMDSTR_OPEN</td> <td>"Open"</td> </tr> </table> This is not a fixed set; new canonical verbs can be invented
    ///by context menu handlers and applications can invoke them. If a canonical verb exists and a menu handler does not
    ///implement the canonical verb, it must return a failure code to enable the next handler to be able to handle this
    ///verb. Failing to do this will break functionality in the system including ShellExecute. Alternatively, rather
    ///than a pointer, this parameter can be MAKEINTRESOURCE(offset) where <i>offset</i> is the menu-identifier offset
    ///of the command to carry out. Implementations can use the IS_INTRESOURCE macro to detect that this alternative is
    ///being employed. The Shell uses this alternative when the user chooses a menu command.
    const(char)* lpVerb;
    ///Type: <b>LPCSTR</b> An optional string containing parameters that are passed to the command. The format of this
    ///string is determined by the command that is to be invoked. This member is always <b>NULL</b> for menu items
    ///inserted by a Shell extension.
    const(char)* lpParameters;
    ///Type: <b>LPCSTR</b> An optional working directory name. This member is always <b>NULL</b> for menu items inserted
    ///by a Shell extension.
    const(char)* lpDirectory;
    ///Type: <b>int</b> A set of SW_ values to pass to the ShowWindow function if the command displays a window or
    ///starts an application.
    int          nShow;
    ///Type: <b>DWORD</b> An optional keyboard shortcut to assign to any application activated by the command. If the
    ///<b>fMask</b> parameter does not specify <b>CMIC_MASK_HOTKEY</b>, this member is ignored.
    uint         dwHotKey;
    ///Type: <b>HANDLE</b> An icon to use for any application activated by the command. If the <b>fMask</b> member does
    ///not specify <b>CMIC_MASK_ICON</b>, this member is ignored.
    HANDLE       hIcon;
}

///Contains extended information about a shortcut menu command. This structure is an extended version of
///CMINVOKECOMMANDINFO that allows the use of Unicode values.
struct CMINVOKECOMMANDINFOEX
{
    ///Type: <b>DWORD</b> The size of this structure, in bytes. This member should be filled in by callers of
    ///IContextMenu::InvokeCommand and tested by the implementations to know that the structure is a
    ///<b>CMINVOKECOMMANDINFOEX</b> structure rather than CMINVOKECOMMANDINFO.
    uint          cbSize;
    ///Type: <b>DWORD</b> Zero, or one or more of the following flags are set to indicate desired behavior and indicate
    ///that other fields in the structure are to be used.
    uint          fMask;
    ///Type: <b>HWND</b> A handle to the window that is the owner of the shortcut menu. An extension can also use this
    ///handle as the owner of any message boxes or dialog boxes it displays. Callers must specify a legitimate HWND that
    ///can be used as the owner window for any UI that may be displayed. Failing to specify an HWND when calling from a
    ///UI thread (one with windows already created) will result in reentrancy and possible bugs in the implementation of
    ///a IContextMenu::InvokeCommand call.
    HWND          hwnd;
    ///Type: <b>LPCSTR</b> The address of a null-terminated string that specifies the language-independent name of the
    ///command to carry out. This member is typically a string when a command is being activated by an application. The
    ///system provides predefined constant values for the following command strings. <table class="clsStd"> <tr>
    ///<th>Constant</th> <th>Command string</th> </tr> <tr> <td>CMDSTR_RUNAS</td> <td>"RunAs"</td> </tr> <tr>
    ///<td>CMDSTR_PRINT</td> <td>"Print"</td> </tr> <tr> <td>CMDSTR_PREVIEW</td> <td>"Preview"</td> </tr> <tr>
    ///<td>CMDSTR_OPEN</td> <td>"Open"</td> </tr> </table> This is not a fixed set; new canonical verbs can be invented
    ///by context menu handlers and applications can invoke them. If a canonical verb exists and a menu handler does not
    ///implement the canonical verb, it must return a failure code to enable the next handler to be able to handle this
    ///verb. Failing to do this will break functionality in the system including ShellExecute. Alternatively, rather
    ///than a pointer, this parameter can be MAKEINTRESOURCE(offset) where <i>offset</i> is the menu-identifier offset
    ///of the command to carry out. Implementations can use the IS_INTRESOURCE macro to detect that this alternative is
    ///being employed. The Shell uses this alternative when the user chooses a menu command.
    const(char)*  lpVerb;
    ///Type: <b>LPCSTR</b> Optional parameters. This member is always <b>NULL</b> for menu items inserted by a Shell
    ///extension.
    const(char)*  lpParameters;
    ///Type: <b>LPCSTR</b> An optional working directory name. This member is always <b>NULL</b> for menu items inserted
    ///by a Shell extension.
    const(char)*  lpDirectory;
    ///Type: <b>int</b> A set of SW_ values to pass to the ShowWindow function if the command displays a window or
    ///starts an application.
    int           nShow;
    ///Type: <b>DWORD</b> An optional keyboard shortcut to assign to any application activated by the command. If the
    ///<b>fMask</b> member does not specify <b>CMIC_MASK_HOTKEY</b>, this member is ignored.
    uint          dwHotKey;
    ///Type: <b>HANDLE</b> An icon to use for any application activated by the command. If the <b>fMask</b> member does
    ///not specify <b>CMIC_MASK_ICON</b>, this member is ignored.
    HANDLE        hIcon;
    ///Type: <b>LPCSTR</b> An ASCII title.
    const(char)*  lpTitle;
    ///Type: <b>LPCWSTR</b> A Unicode verb, for those commands that can use it.
    const(wchar)* lpVerbW;
    ///Type: <b>LPCWSTR</b> A Unicode parameters, for those commands that can use it.
    const(wchar)* lpParametersW;
    ///Type: <b>LPCWSTR</b> A Unicode directory, for those commands that can use it.
    const(wchar)* lpDirectoryW;
    ///Type: <b>LPCWSTR</b> A Unicode title.
    const(wchar)* lpTitleW;
    ///Type: <b>POINT</b> The point where the command is invoked. If the <b>fMask</b> member does not specify
    ///<b>CMIC_MASK_PTINVOKE</b>, this member is ignored. This member is not valid prior to Internet Explorer 4.0.
    POINT         ptInvoke;
}

///Specifies a folder shortcut's target folder and its attributes. This structure is used by
///IPersistFolder3::GetFolderTargetInfo and IPersistFolder3::InitializeEx.
struct PERSIST_FOLDER_TARGET_INFO
{
    ///Type: <b>PIDLIST_ABSOLUTE</b> A fully qualified PIDL of the target folder. Set <b>pidlTargetFolder</b> to
    ///<b>NULL</b> if not specified.
    ITEMIDLIST* pidlTargetFolder;
    ///Type: <b>WCHAR[MAX_PATH]</b> A null-terminated Unicode string with the target folder's parsing name. Set
    ///<b>szTargetParsingName</b> to an empty string if not specified.
    ushort[260] szTargetParsingName;
    ///Type: <b>WCHAR[MAX_PATH]</b> A null-terminated Unicode string that specifies the type of network provider that
    ///will be used when binding to the target folder. The format is the same as that used by the WNet API. Set
    ///<b>szNetworkProvider</b> to an empty string if not specified.
    ushort[260] szNetworkProvider;
    ///Type: <b>DWORD</b> A <b>DWORD</b> value that contains FILE_ATTRIBUTE_* flags as defined in Winnt.h. Set
    ///<b>dwAttributes</b> to -1 if not specified.
    uint        dwAttributes;
    ///Type: <b>int</b> The target folder's CSIDL value, if it has one. Set <b>csidl</b> to -1 if the target folder does
    ///not have a CSIDL. In addition to the CSIDL value, you can also set the following two flags.
    int         csidl;
}

///Used by an IEnumExtraSearch enumerator object to return information on the search objects supported by a Shell Folder
///object.
struct EXTRASEARCH
{
    ///Type: <b>GUID</b> A search object's GUID.
    GUID         guidSearch;
    ///Type: <b>WCHAR[80]</b> A Unicode string containing the search object's friendly name. It will be used to identify
    ///the search engine on the Search Assistant menu.
    ushort[80]   wszFriendlyName;
    ushort[2084] wszUrl;
}

///Contains folder view information.
struct FOLDERSETTINGS
{
    ///Type: <b>UINT</b> Folder view mode. One of the FOLDERVIEWMODE values.
    uint ViewMode;
    ///Type: <b>UINT</b> A set of flags that indicate the options for the folder. This can be zero or a combination of
    ///the FOLDERFLAGS values.
    uint fFlags;
}

///Holds the parameters for the IShellView2::CreateViewWindow2 method.
struct SV2CVW2_PARAMS
{
    ///Type: <b>DWORD</b> The size of the structure.
    uint            cbSize;
    ///Type: <b>IShellView*</b> A pointer to the IShellView interface of the previous view. A Shell view can use this
    ///parameter to communicate with a previous view with the same implementation. It can also be used to optimize
    ///browsing between like views. This parameter may be <b>NULL</b>.
    IShellView      psvPrev;
    ///Type: <b>LPFOLDERSETTINGS</b> A FOLDERSETTINGS structure with information needed to create the view.
    FOLDERSETTINGS* pfs;
    ///Type: <b>IShellBrowser*</b> A pointer to the current instance of the IShellBrowser interface of the parent Shell
    ///browser. IShellView2::CreateViewWindow2 should call this interface's AddRef method and store the interface
    ///pointer. It can be used for communication with the Windows Explorer window.
    IShellBrowser   psbOwner;
    ///Type: <b>RECT*</b> A <b>RECT</b> structure that defines the view's display area.
    RECT*           prcView;
    ///Type: <b>const SHELLVIEWID*</b> A pointer to a view ID. The view ID can be one of the Windows-defined VIDs or a
    ///custom, view-defined VID. This value takes precedence over the view mode designated in the FOLDERSETTINGS
    ///structure pointed to by <b>pfs</b>.
    const(GUID)*    pvid;
    HWND            hwndView;
}

///Stores information about how to sort a column that is displayed in the folder view.
struct SORTCOLUMN
{
    ///Type: <b>PROPERTYKEY</b> The ID of the column by which the user will sort. A PROPERTYKEY structure. For example,
    ///for the "Name" column, the property key is PKEY_ItemNameDisplay.
    PROPERTYKEY propkey;
    ///Type: <b>SORTDIRECTION</b> The direction in which the items are sorted. One of the following values.
    int         direction;
}

///Defines column information. Used by members of the IColumnManager interface.
struct CM_COLUMNINFO
{
    ///Type: <b>DWORD</b> The size of the structure, in bytes.
    uint       cbSize;
    ///Type: <b>DWORD</b> One or more values from the CM_MASK enumeration that specify which members of this structure
    ///are valid.
    uint       dwMask;
    ///Type: <b>DWORD</b> One or more values from the CM_STATE enumeration that specify the state of the column.
    uint       dwState;
    ///Type: <b>UINT</b> One of the members of the CM_SET_WIDTH_VALUE enumeration that specifies the column width.
    uint       uWidth;
    ///Type: <b>UINT</b> The default width of the column.
    uint       uDefaultWidth;
    ///Type: <b>UINT</b> The ideal width of the column.
    uint       uIdealWidth;
    ushort[80] wszName;
}

///Defines Shell item resource.
struct SHELL_ITEM_RESOURCE
{
    ///Type: <b>GUID</b> The <b>GUID</b> that identifies the item.
    GUID        guidType;
    ushort[260] szName;
}

///Contains category information. A component category is a group of logically-related Component Object Model (COM)
///classes that share a common category identifier (CATID).
struct CATEGORY_INFO
{
    ///Type: <b>CATEGORYINFO_FLAGS</b> A flag from CATEGORYINFO_FLAGS that specifies the type of information to
    ///retrieve.
    CATEGORYINFO_FLAGS cif;
    ushort[260]        wszName;
}

///Contains the information needed to create a drag image.
struct SHDRAGIMAGE
{
    ///Type: <b>SIZE</b> A SIZE structure with the length and width of the drag image.
    SIZE    sizeDragImage;
    ///Type: <b>POINT</b> A POINT structure that specifies the location of the cursor within the drag image. The
    ///structure should contain the offset from the upper-left corner of the drag image to the location of the cursor.
    POINT   ptOffset;
    ///Type: <b>HBITMAP</b> The drag image's bitmap handle.
    HBITMAP hbmpDragImage;
    ///Type: <b>COLORREF</b> The color used by the control to fill the background of the drag image.
    uint    crColorKey;
}

///Receives information about a band object. This structure is used with the deprecated IDeskBand::GetBandInfo method.
struct DESKBANDINFO
{
    ///Type: <b>DWORD</b> The set of flags that determine which members of this structure are being requested by the
    ///caller. One or more of the following values:
    uint        dwMask;
    ///Type: <b>POINTL</b> A POINTL structure that receives the minimum size of the band object. The minimum width is
    ///given in the <b>POINTL</b> structure's <b>x</b> member and the minimum height is given in the <b>y</b> member.
    POINTL      ptMinSize;
    ///Type: <b>POINTL</b> A POINTL structure that receives the maximum size of the band object. The maximum height is
    ///given in the <b>POINTL</b> structure's <b>y</b> member and the <b>x</b> member is ignored. If the band object has
    ///no limit for its maximum height, (LONG)-1 should be used.
    POINTL      ptMaxSize;
    ///Type: <b>POINTL</b> A POINTL structure that receives the sizing step value (increment) in which the band object
    ///is resized. The vertical step value is given in the <b>POINTL</b> structure's <b>y</b> member and the <b>x</b>
    ///member is ignored. The <b>dwModeFlags</b> member must contain the DBIMF_VARIABLEHEIGHT flag; otherwise,
    ///<b>ptIntegral</b> is ignored.
    POINTL      ptIntegral;
    ///Type: <b>POINTL</b> A POINTL structure that receives the ideal size of the band object. The ideal width is given
    ///in the <b>POINTL</b> structure's <b>x</b> member and the ideal height is given in the <b>y</b> member. The band
    ///container attempts to use these values, but the band is not guaranteed to be this size.
    POINTL      ptActual;
    ///Type: <b>WCHAR[256]</b> A <b>WCHAR</b> buffer that receives the title of the band.
    ushort[256] wszTitle;
    ///Type: <b>DWORD</b> A value that receives a set of flags that specify the mode of operation for the band object.
    ///One or more of the following values:
    uint        dwModeFlags;
    uint        crBkgnd;
}

///Used by methods of the ITaskbarList3 interface to define buttons used in a toolbar embedded in a window's thumbnail
///representation.
struct THUMBBUTTON
{
    ///Type: <b>THUMBBUTTONMASK</b> A combination of THUMBBUTTONMASK values that specify which members of this structure
    ///contain valid data; other members are ignored, with the exception of <b>iId</b>, which is always required.
    THUMBBUTTONMASK  dwMask;
    ///Type: <b>UINT</b> The application-defined identifier of the button, unique within the toolbar.
    uint             iId;
    ///Type: <b>UINT</b> The zero-based index of the button image within the image list set through
    ///ITaskbarList3::ThumbBarSetImageList.
    uint             iBitmap;
    ///Type: <b>HICON</b> The handle of an icon to use as the button image.
    HICON            hIcon;
    ///Type: <b>WCHAR[260]</b> A wide character array that contains the text of the button's tooltip, displayed when the
    ///mouse pointer hovers over the button.
    ushort[260]      szTip;
    ///Type: <b>THUMBBUTTONFLAGS</b> A combination of THUMBBUTTONFLAGS values that control specific states and behaviors
    ///of the button.
    THUMBBUTTONFLAGS dwFlags;
}

///Contains information about a band site. This structure is used with the IBandSite::GetBandSiteInfo and
///IBandSite::SetBandSiteInfo methods.
struct BANDSITEINFO
{
    ///Type: <b>DWORD</b> The mask values that determine the other fields in this structure that are being requested or
    ///set.
    uint dwMask;
    ///Type: <b>DWORD</b> Bits that specify the state of the band.
    uint dwState;
    ///Type: <b>DWORD</b> Bit flags that specify the style of the band.
    uint dwStyle;
}

///Used by delegate folders in place of a standard ITEMIDLIST structure.
struct DELEGATEITEMID
{
align (1):
    ///Type: <b>WORD</b> The size, in bytes, of this structure.
    ushort   cbSize;
    ///Type: <b>WORD</b> Private data owned by the delegating (outer) folder.
    ushort   wOuter;
    ///Type: <b>WORD</b> The size, in bytes, of the delegate's data. The first <b>cbInner</b> bytes of the <b>rgb</b>
    ///array contain this data. The remaining data in <b>rgb</b> belongs to the outer folder.
    ushort   cbInner;
    ubyte[1] rgb;
}

///Contains information from a menu band.
struct SMDATA
{
    ///Type: <b>DWORD</b> A mask that is always set to SMDM_HMENU.
    uint         dwMask;
    ///Type: <b>DWORD</b>
    uint         dwFlags;
    ///Type: <b>HMENU</b> The static menu portion of the menu band.
    HMENU        hmenu;
    ///Type: <b>HWND</b> The HWND value of the owner window.
    HWND         hwnd;
    ///Type: <b>UINT</b> The identifier of the menu item. This value is -1 for the menu itself.
    uint         uId;
    ///Type: <b>UINT</b> The identifier of the parent menu.
    uint         uIdParent;
    ///Type: <b>UINT</b>
    uint         uIdAncestor;
    ///Type: <b>IUknown*</b> A pointer to the IUnknown interface of the MenuBand object.
    IUnknown     punk;
    ///Type: <b>PIDLIST_ABSOLUTE</b> The ITEMIDLIST of the shell folder portion of the menu.
    ITEMIDLIST*  pidlFolder;
    ///Type: <b>PUITEMID_CHILD</b> The ITEMIDLIST of the selected item in the shell folder portion of the menu.
    ITEMIDLIST*  pidlItem;
    ///Type: <b>IShellFolder*</b> A pointer to the IShellFolder interface for the folder associated with the shell
    ///folder portion of the menu.
    IShellFolder psf;
    void*        pvUserData;
}

///Contains information about an item from a menu band.
struct SMINFO
{
    ///Type: <b>DWORD</b> Flags that specify which of the other three members are valid.
    uint dwMask;
    ///Type: <b>DWORD</b> A flag that indicates whether the item is a string or a separator.
    uint dwType;
    ///Type: <b>DWORD</b> Flags that contain information about the item and how it should be displayed.
    uint dwFlags;
    int  iIcon;
}

///Contains information about change notification. It is used by IShellMenuCallback::CallbackSM.
struct SMCSHCHANGENOTIFYSTRUCT
{
    ///Type: <b>long</b> An SHCNE value that specifies the type of change that took place. See SHChangeNotify for a
    ///complete list of these values.
    int         lEvent;
    ///Type: <b>PCIDLIST_ABSOLUTE</b> PIDL provided by the change notification. The target of this PIDL varies depending
    ///on the value of <b>lEvent</b>.
    ITEMIDLIST* pidl1;
    ITEMIDLIST* pidl2;
}

///Defines the specifics of a known folder.
struct KNOWNFOLDER_DEFINITION
{
    ///Type: <b>KF_CATEGORY</b> A single value from the KF_CATEGORY constants that classifies the folder as virtual,
    ///fixed, common, or per-user.
    KF_CATEGORY   category;
    ///Type: <b>LPWSTR</b> A pointer to the non-localized, canonical name for the known folder, stored as a
    ///null-terminated Unicode string. If this folder is a common or per-user folder, this value is also used as the
    ///value name of the "User Shell Folders" registry settings. This name is meant to be a unique, human-readable name.
    ///Third parties are recommended to follow the format <code>Company.Application.Name</code>. The name given here
    ///should not be confused with the display name.
    const(wchar)* pszName;
    ///Type: <b>LPWSTR</b> A pointer to a short description of the known folder, stored as a null-terminated Unicode
    ///string. This description should include the folder's purpose and usage.
    const(wchar)* pszDescription;
    ///Type: <b>KNOWNFOLDERID</b> A KNOWNFOLDERID value that names another known folder to serve as the parent folder.
    ///Applies to common and per-user folders only. This value is used in conjunction with <b>pszRelativePath</b>. See
    ///<b>Remarks</b> for more details. This value is optional if no value is provided for <b>pszRelativePath</b>.
    GUID          fidParent;
    ///Type: <b>LPWSTR</b> Optional. A pointer to a path relative to the parent folder specified in <b>fidParent</b>.
    ///This is a null-terminated Unicode string, refers to the physical file system path, and is not localized. Applies
    ///to common and per-user folders only. See <b>Remarks</b> for more details.
    const(wchar)* pszRelativePath;
    ///Type: <b>LPWSTR</b> A pointer to the Shell namespace folder path of the folder, stored as a null-terminated
    ///Unicode string. Applies to virtual folders only. For example, <code>Control Panel</code> has a parsing name of
    ///<code>::%CLSID_MyComputer%\::%CLSID_ControlPanel%</code>.
    const(wchar)* pszParsingName;
    ///Type: <b>LPWSTR</b> Optional. A pointer to the default tooltip resource used for this known folder when it is
    ///created. This is a null-terminated Unicode string in this form: <b>Module name, Resource ID</b> For example,
    ///<code>@%_SYS_MOD_PATH%,-12688</code> is the tooltip for Common Pictures. When the folder is created, this string
    ///is stored in that folder's copy of Desktop.ini. It can be changed later by other Shell APIs. This resource might
    ///be localized. This information is not required for virtual folders.
    const(wchar)* pszTooltip;
    ///Type: <b>LPWSTR</b> Optional. A pointer to the default localized name resource used when the folder is created.
    ///This is a null-terminated Unicode string in this form: <b>Module name, Resource ID</b> When the folder is
    ///created, this string is stored in that folder's copy of Desktop.ini. It can be changed later by other Shell APIs.
    ///This information is not required for virtual folders.
    const(wchar)* pszLocalizedName;
    ///Type: <b>LPWSTR</b> Optional. A pointer to the default icon resource used when the folder is created. This is a
    ///null-terminated Unicode string in this form: <b>Module name, Resource ID</b> When the folder is created, this
    ///string is stored in that folder's copy of Desktop.ini. It can be changed later by other Shell APIs. This
    ///information is not required for virtual folders.
    const(wchar)* pszIcon;
    ///Type: <b>LPWSTR</b> Optional. A pointer to a Security Descriptor Definition Language format string. This is a
    ///null-terminated Unicode string that describes the default security descriptor that the folder receives when it is
    ///created. If this parameter is <b>NULL</b>, the new folder inherits the security descriptor of its parent. This is
    ///particularly useful for common folders that are accessed by all users.
    const(wchar)* pszSecurity;
    ///Type: <b>DWORD</b> Optional. Default file system attributes given to the folder when it is created. For example,
    ///the file could be hidden and read-only (FILE_ATTRIBUTE_HIDDEN and FILE_ATTRIBUTE_READONLY). For a complete list
    ///of possible values, see the <i>dwFlagsAndAttributes</i> parameter of the CreateFile function. Set to -1 if not
    ///needed.
    uint          dwAttributes;
    ///Type: <b>KF_DEFINITION_FLAGS</b> Optional. One of more values from the KF_DEFINITION_FLAGS enumeration that allow
    ///you to restrict redirection, allow PC-to-PC roaming, and control the time at which the known folder is created.
    ///Set to 0 if not needed.
    uint          kfdFlags;
    ///Type: <b>FOLDERTYPEID</b> One of the FOLDERTYPEID values that identifies the known folder type based on its
    ///contents (such as documents, music, or photographs). This value is a GUID.
    GUID          ftidType;
}

///Accelerator table structure. Used by IPreviewHandlerFrame::GetWindowContext.
struct PREVIEWHANDLERFRAMEINFO
{
    ///Type: <b>HACCEL</b> A handle to the accelerator table.
    HACCEL haccel;
    uint   cAccelEntries;
}

struct BANNER_NOTIFICATION
{
    BANNER_NOTIFICATION_EVENT event;
    const(wchar)* providerIdentity;
    const(wchar)* contentId;
}

///Custom draw structure used by INameSpaceTreeControlCustomDraw methods.
struct NSTCCUSTOMDRAW
{
    ///Type: <b>IShellItem*</b> A pointer to a Shell item.
    IShellItem    psi;
    ///Type: <b>UINT</b> The current item state. See NMCUSTOMDRAW for more detail.
    uint          uItemState;
    ///Type: <b>NSTCITEMSTATE</b> The state of a tree item. See NSTCITEMSTATE.
    uint          nstcis;
    ///Type: <b>LPCWSTR</b> A pointer to a null-terminated Unicode string that contains the item text, if the structure
    ///specifies item attributes.
    const(wchar)* pszText;
    ///Type: <b>int</b> The index in the tree-view control's image list.
    int           iImage;
    ///Type: <b>HIMAGELIST</b> A handle to an image list.
    HIMAGELIST    himl;
    ///Type: <b>int</b> The zero-based level of the item being drawn.
    int           iLevel;
    int           iIndent;
}

///Serves as the header for some of the extra data structures used by IShellLinkDataList.
struct DATABLOCK_HEADER
{
align (1):
    ///Type: <b>DWORD</b> The size of the extra data block.
    uint cbSize;
    ///Type: <b>DWORD</b> A signature that identifies the type of data block that follows the header.
    uint dwSignature;
}

///Holds an extra data block used by IShellLinkDataList. It holds console properties.
struct NT_CONSOLE_PROPS
{
align (1):
    ///Type: <b>DATABLOCK_HEADER</b> The DATABLOCK_HEADER structure with the <b>NT_CONSOLE_PROPS</b> structure's size
    ///and signature. The signature for an <b>NT_CONSOLE_PROPS</b> structure is NT_CONSOLE_PROPS_SIG.
    DATABLOCK_HEADER dbh;
    ///Type: <b>WORD</b> Fill attribute for the console.
    ushort           wFillAttribute;
    ///Type: <b>WORD</b> Fill attribute for console pop-ups.
    ushort           wPopupFillAttribute;
    ///Type: <b>COORD</b> A COORD structure with the console's screen buffer size.
    COORD            dwScreenBufferSize;
    ///Type: <b>COORD</b> A COORD structure with the console's window size.
    COORD            dwWindowSize;
    ///Type: <b>COORD</b> A COORD structure with the console's window origin.
    COORD            dwWindowOrigin;
    ///Type: <b>DWORD</b> The font.
    uint             nFont;
    ///Type: <b>DWORD</b> The input buffer size.
    uint             nInputBufferSize;
    ///Type: <b>COORD</b> A COORD structure with the font size.
    COORD            dwFontSize;
    ///Type: <b>UINT</b> The font family.
    uint             uFontFamily;
    ///Type: <b>UINT</b> The font weight.
    uint             uFontWeight;
    ///Type: <b>WCHAR[LF_FACESIZE]</b> A character array that contains the font's face name.
    ushort[32]       FaceName;
    ///Type: <b>UINT</b> The cursor size.
    uint             uCursorSize;
    ///Type: <b>BOOL</b> A boolean value that is set to <b>TRUE</b> if the console is in full-screen mode, or
    ///<b>FALSE</b> otherwise.
    BOOL             bFullScreen;
    ///Type: <b>BOOL</b> A boolean value that is set to <b>TRUE</b> if the console is in quick-edit mode, or
    ///<b>FALSE</b> otherwise.
    BOOL             bQuickEdit;
    ///Type: <b>BOOL</b> A boolean value that is set to <b>TRUE</b> if the console is in insert mode, or <b>FALSE</b>
    ///otherwise.
    BOOL             bInsertMode;
    ///Type: <b>BOOL</b> A boolean value that is set to <b>TRUE</b> if the console is in auto-position mode, or
    ///<b>FALSE</b> otherwise.
    BOOL             bAutoPosition;
    ///Type: <b>UINT</b> The size of the history buffer.
    uint             uHistoryBufferSize;
    ///Type: <b>UINT</b> The number of history buffers.
    uint             uNumberOfHistoryBuffers;
    ///Type: <b>BOOL</b> A boolean value that is set to <b>TRUE</b> if old duplicate history lists should be discarded,
    ///or <b>FALSE</b> otherwise.
    BOOL             bHistoryNoDup;
    uint[16]         ColorTable;
}

///Holds an extra data block used by IShellLinkDataList. It holds the console's code page.
struct NT_FE_CONSOLE_PROPS
{
align (1):
    ///Type: <b>DATABLOCK_HEADER</b> The DATABLOCK_HEADER structure with the <b>NT_FE_CONSOLE_PROPS</b> structure's size
    ///and signature. The signature for an <b>NT_FE_CONSOLE_PROPS</b> structure is NT_FE_CONSOLE_PROPS_SIG.
    DATABLOCK_HEADER dbh;
    uint             uCodePage;
}

///Holds an extra data block used by IShellLinkDataList. It holds the link's Windows Installer ID.
struct EXP_DARWIN_LINK
{
align (1):
    ///Type: <b>DATABLOCK_HEADER</b> DATABLOCK_HEADER structure stating the size and signature of the
    ///<b>EXP_DARWIN_LINK</b> structure. The following is the only recognized signature value.
    DATABLOCK_HEADER dbh;
    ///Type: <b>__wchar_t[MAX_PATH]</b> The link's ID in the form of an ANSI string.
    byte[260]        szDarwinID;
    ///Type: <b>WCHAR[MAX_PATH]</b> The link's ID in the form of an Unicode string.
    ushort[260]      szwDarwinID;
}

///Holds an extra data block used by IShellLinkDataList. It holds special folder information.
struct EXP_SPECIAL_FOLDER
{
align (1):
    ///Type: <b>DWORD</b> The size of the <b>EXP_SPECIAL_FOLDER</b> structure.
    uint cbSize;
    ///Type: <b>DWORD</b> The structure's signature. It should be set to EXP_SPECIAL_FOLDER_SIG.
    uint dwSignature;
    ///Type: <b>DWORD</b> The ID of the special folder that the link points into.
    uint idSpecialFolder;
    uint cbOffset;
}

///Holds an extra data block used by IShellLinkDataList. It holds expandable environment strings for the icon or target.
struct EXP_SZ_LINK
{
align (1):
    ///Type: <b>DWORD</b> The size of the <b>EXP_SZ_LINK</b> structure.
    uint        cbSize;
    ///Type: <b>DWORD</b> The structure's signature. It can have one of the following values.
    uint        dwSignature;
    ///Type: <b>__wchar_t[MAX_PATH]</b> The null-terminated ANSI string with the path of the target or icon.
    byte[260]   szTarget;
    ushort[260] swzTarget;
}

///Stores information about the Shell link state. This structure is used for extra data sections that are tagged with
///EXP_PROPERTYSTORAGE_SIG.
struct EXP_PROPERTYSTORAGE
{
align (1):
    ///Type: <b>DWORD</b> The size of this structure, in bytes.
    uint     cbSize;
    ///Type: <b>DWORD</b> Identifies the type of block and is the value EXP_PROPERTYSTORAGE_SIG.
    uint     dwSignature;
    ///Type: <b>BYTE[1]</b> A serialized property store in the format defined by SERIALIZEDPROPSTORAGE.
    ubyte[1] abPropertyStorage;
}

///Holds custom folder settings. This structure is used with the SHGetSetFolderCustomSettings function.
struct SHFOLDERCUSTOMSETTINGS
{
    ///Type: <b>DWORD</b> The size of the structure, in bytes.
    uint          dwSize;
    ///Type: <b>DWORD</b> A <b>DWORD</b> value specifying which folder attributes to read or write from this structure.
    ///Use one or more of the following values to indicate which structure members are valid:
    uint          dwMask;
    ///Type: <b>SHELLVIEWID*</b> The folder's GUID.
    GUID*         pvid;
    ///Type: <b>LPTSTR</b> A pointer to a null-terminated string containing the path to the folder's WebView template.
    const(wchar)* pszWebViewTemplate;
    ///Type: <b>DWORD</b> If the SHGetSetFolderCustomSettings parameter <i>dwReadWrite</i> is <b>FCS_READ</b>, this is
    ///the size of the <b>pszWebViewTemplate</b> buffer, in characters. If not, this is the number of characters to
    ///write from that buffer. Set this parameter to 0 to write the entire string.
    uint          cchWebViewTemplate;
    ///Type: <b>LPTSTR</b> A pointer to a null-terminated buffer containing the WebView template version.
    const(wchar)* pszWebViewTemplateVersion;
    ///Type: <b>LPTSTR</b> A pointer to a null-terminated buffer containing the text of the folder's infotip.
    const(wchar)* pszInfoTip;
    ///Type: <b>DWORD</b> If the SHGetSetFolderCustomSettings parameter <i>dwReadWrite</i> is <b>FCS_READ</b>, this is
    ///the size of the <b>pszInfoTip</b> buffer, in characters. If not, this is the number of characters to write from
    ///that buffer. Set this parameter to 0 to write the entire string.
    uint          cchInfoTip;
    ///Type: <b>CLSID*</b> A pointer to a CLSID used to identify the folder in the Windows registry. Further folder
    ///information is stored in the registry under that CLSID entry.
    GUID*         pclsid;
    ///Type: <b>DWORD</b> Not used.
    uint          dwFlags;
    ///Type: <b>LPTSTR</b> A pointer to a null-terminated buffer containing the path to file containing the folder's
    ///icon.
    const(wchar)* pszIconFile;
    ///Type: <b>DWORD</b> If the SHGetSetFolderCustomSettings parameter <i>dwReadWrite</i> is <b>FCS_READ</b>, this is
    ///the size of the <b>pszIconFile</b> buffer, in characters. If not, this is the number of characters to write from
    ///that buffer. Set this parameter to 0 to write the entire string.
    uint          cchIconFile;
    ///Type: <b>int</b> The index of the icon within the file named in <b>pszIconFile</b>.
    int           iIconIndex;
    ///Type: <b>LPTSTR</b> A pointer to a null-terminated buffer containing the path to the file containing the folder's
    ///logo image. This is the image used in thumbnail views.
    const(wchar)* pszLogo;
    ///Type: <b>DWORD</b> If the SHGetSetFolderCustomSettings parameter <i>dwReadWrite</i> is <b>FCS_READ</b>, this is
    ///the size of the <b>pszLogo</b> buffer, in characters. If not, this is the number of characters to write from that
    ///buffer. Set this parameter to 0 to write the entire string.
    uint          cchLogo;
}

///Contains parameters for the SHBrowseForFolder function and receives information about the folder selected by the
///user.
struct BROWSEINFOA
{
    ///Type: <b>HWND</b> A handle to the owner window for the dialog box.
    HWND         hwndOwner;
    ///Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL that specifies the location of the root folder from which to start
    ///browsing. Only the specified folder and its subfolders in the namespace hierarchy appear in the dialog box. This
    ///member can be <b>NULL</b>; in that case, a default location is used.
    ITEMIDLIST*  pidlRoot;
    ///Type: <b>LPTSTR</b> Pointer to a buffer to receive the display name of the folder selected by the user. The size
    ///of this buffer is assumed to be MAX_PATH characters.
    const(char)* pszDisplayName;
    ///Type: <b>LPCTSTR</b> Pointer to a null-terminated string that is displayed above the tree view control in the
    ///dialog box. This string can be used to specify instructions to the user.
    const(char)* lpszTitle;
    ///Type: <b>UINT</b> Flags that specify the options for the dialog box. This member can be 0 or a combination of the
    ///following values. Version numbers refer to the minimum version of Shell32.dll required for SHBrowseForFolder to
    ///recognize flags added in later releases. See Shell and Common Controls Versions for more information.
    uint         ulFlags;
    ///Type: <b>BFFCALLBACK</b> Pointer to an application-defined function that the dialog box calls when an event
    ///occurs. For more information, see the BrowseCallbackProc function. This member can be <b>NULL</b>.
    BFFCALLBACK  lpfn;
    ///Type: <b>LPARAM</b> An application-defined value that the dialog box passes to the callback function, if one is
    ///specified in <b>lpfn</b>.
    LPARAM       lParam;
    ///Type: <b>int</b> An integer value that receives the index of the image associated with the selected folder,
    ///stored in the system image list.
    int          iImage;
}

///Contains parameters for the SHBrowseForFolder function and receives information about the folder selected by the
///user.
struct BROWSEINFOW
{
    ///Type: <b>HWND</b> A handle to the owner window for the dialog box.
    HWND          hwndOwner;
    ///Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL that specifies the location of the root folder from which to start
    ///browsing. Only the specified folder and its subfolders in the namespace hierarchy appear in the dialog box. This
    ///member can be <b>NULL</b>; in that case, a default location is used.
    ITEMIDLIST*   pidlRoot;
    ///Type: <b>LPTSTR</b> Pointer to a buffer to receive the display name of the folder selected by the user. The size
    ///of this buffer is assumed to be MAX_PATH characters.
    const(wchar)* pszDisplayName;
    ///Type: <b>LPCTSTR</b> Pointer to a null-terminated string that is displayed above the tree view control in the
    ///dialog box. This string can be used to specify instructions to the user.
    const(wchar)* lpszTitle;
    ///Type: <b>UINT</b> Flags that specify the options for the dialog box. This member can be 0 or a combination of the
    ///following values. Version numbers refer to the minimum version of Shell32.dll required for SHBrowseForFolder to
    ///recognize flags added in later releases. See Shell and Common Controls Versions for more information.
    uint          ulFlags;
    ///Type: <b>BFFCALLBACK</b> Pointer to an application-defined function that the dialog box calls when an event
    ///occurs. For more information, see the BrowseCallbackProc function. This member can be <b>NULL</b>.
    BFFCALLBACK   lpfn;
    ///Type: <b>LPARAM</b> An application-defined value that the dialog box passes to the callback function, if one is
    ///specified in <b>lpfn</b>.
    LPARAM        lParam;
    ///Type: <b>int</b> An integer value that receives the index of the image associated with the selected folder,
    ///stored in the system image list.
    int           iImage;
}

///Defines the CF_NETRESOURCE clipboard format.
struct NRESARRAY
{
    ///Type: <b>UINT</b> The number of elements in the <b>nr</b> array.
    uint            cItems;
    NETRESOURCEA[1] nr;
}

///Used with the CFSTR_SHELLIDLIST clipboard format to transfer the pointer to an item identifier list (PIDL) of one or
///more Shell namespace objects.
struct CIDA
{
align (1):
    ///Type: <b>UINT</b> The number of PIDLs that are being transferred, not including the parent folder.
    uint    cidl;
    ///Type: <b>UINT[1]</b> An array of offsets, relative to the beginning of this structure. The array contains
    ///<b>cidl</b>+1 elements. The first element of <b>aoffset</b> contains an offset to the fully qualified PIDL of a
    ///parent folder. If this PIDL is empty, the parent folder is the desktop. Each of the remaining elements of the
    ///array contains an offset to one of the PIDLs to be transferred. All of these PIDLs are relative to the PIDL of
    ///the parent folder.
    uint[1] aoffset;
}

///Describes the properties of a file that is being copied by means of the clipboard during a Microsoft ActiveX
///drag-and-drop operation.
struct FILEDESCRIPTORA
{
align (1):
    ///Type: <b>DWORD</b> An array of flags that indicate which of the other structure members contain valid data. This
    ///member can be a combination of the following values.
    uint      dwFlags;
    ///Type: <b>CLSID</b> The file type identifier.
    GUID      clsid;
    ///Type: <b>SIZEL</b> The width and height of the file icon.
    SIZE      sizel;
    ///Type: <b>POINTL</b> The screen coordinates of the file object.
    POINTL    pointl;
    ///Type: <b>DWORD</b> File attribute flags. This will be a combination of the FILE_ATTRIBUTE_ values described in
    ///GetFileAttributes.
    uint      dwFileAttributes;
    ///Type: <b>FILETIME</b> The FILETIME structure that contains the time of file creation.
    FILETIME  ftCreationTime;
    ///Type: <b>FILETIME</b> The FILETIME structure that contains the time that the file was last accessed.
    FILETIME  ftLastAccessTime;
    ///Type: <b>FILETIME</b> The FILETIME structure that contains the time of the last write operation.
    FILETIME  ftLastWriteTime;
    ///Type: <b>DWORD</b> The high-order <b>DWORD</b> of the file size, in bytes.
    uint      nFileSizeHigh;
    ///Type: <b>DWORD</b> The low-order <b>DWORD</b> of the file size, in bytes.
    uint      nFileSizeLow;
    ///Type: <b>TCHAR[MAX_PATH]</b> The null-terminated string that contains the name of the file.
    byte[260] cFileName;
}

///Describes the properties of a file that is being copied by means of the clipboard during a Microsoft ActiveX
///drag-and-drop operation.
struct FILEDESCRIPTORW
{
align (1):
    ///Type: <b>DWORD</b> An array of flags that indicate which of the other structure members contain valid data. This
    ///member can be a combination of the following values.
    uint        dwFlags;
    ///Type: <b>CLSID</b> The file type identifier.
    GUID        clsid;
    ///Type: <b>SIZEL</b> The width and height of the file icon.
    SIZE        sizel;
    ///Type: <b>POINTL</b> The screen coordinates of the file object.
    POINTL      pointl;
    ///Type: <b>DWORD</b> File attribute flags. This will be a combination of the FILE_ATTRIBUTE_ values described in
    ///GetFileAttributes.
    uint        dwFileAttributes;
    ///Type: <b>FILETIME</b> The FILETIME structure that contains the time of file creation.
    FILETIME    ftCreationTime;
    ///Type: <b>FILETIME</b> The FILETIME structure that contains the time that the file was last accessed.
    FILETIME    ftLastAccessTime;
    ///Type: <b>FILETIME</b> The FILETIME structure that contains the time of the last write operation.
    FILETIME    ftLastWriteTime;
    ///Type: <b>DWORD</b> The high-order <b>DWORD</b> of the file size, in bytes.
    uint        nFileSizeHigh;
    ///Type: <b>DWORD</b> The low-order <b>DWORD</b> of the file size, in bytes.
    uint        nFileSizeLow;
    ///Type: <b>TCHAR[MAX_PATH]</b> The null-terminated string that contains the name of the file.
    ushort[260] cFileName;
}

///Defines the CF_FILEGROUPDESCRIPTOR clipboard format.
struct FILEGROUPDESCRIPTORA
{
align (1):
    ///Type: <b>UINT</b> The number of elements in <b>fgd</b>.
    uint               cItems;
    ///Type: <b>FILEDESCRIPTOR[1]</b> An array of FILEDESCRIPTOR structures that contain the file information.
    FILEDESCRIPTORA[1] fgd;
}

///Defines the CF_FILEGROUPDESCRIPTOR clipboard format.
struct FILEGROUPDESCRIPTORW
{
align (1):
    ///Type: <b>UINT</b> The number of elements in <b>fgd</b>.
    uint               cItems;
    ///Type: <b>FILEDESCRIPTOR[1]</b> An array of FILEDESCRIPTOR structures that contain the file information.
    FILEDESCRIPTORW[1] fgd;
}

///Defines the CF_HDROP clipboard format. The data that follows is a double null-terminated list of file names.
struct DROPFILES
{
align (1):
    ///Type: <b>DWORD</b> The offset of the file list from the beginning of this structure, in bytes.
    uint  pFiles;
    ///Type: <b>POINT</b> The drop point. The coordinates depend on <b>fNC</b>.
    POINT pt;
    ///Type: <b>BOOL</b> A nonclient area flag. If this member is <b>TRUE</b>, <b>pt</b> specifies the screen
    ///coordinates of a point in a window's nonclient area. If it is <b>FALSE</b>, <b>pt</b> specifies the client
    ///coordinates of a point in the client area.
    BOOL  fNC;
    BOOL  fWide;
}

///Contains the clipboard format definition for CFSTR_FILE_ATTRIBUTES_ARRAY.
struct FILE_ATTRIBUTES_ARRAY
{
align (1):
    ///Type: <b>UINT</b> The number of items in the <b>rgdwFileAttributes</b> array.
    uint    cItems;
    ///Type: <b>DWORD</b> All of the attributes combined using OR.
    uint    dwSumFileAttributes;
    ///Type: <b>DWORD</b> All of the attributes combined using AND.
    uint    dwProductFileAttributes;
    uint[1] rgdwFileAttributes;
}

///Describes the image and accompanying text for a drop object.
struct DROPDESCRIPTION
{
align (1):
    ///Type: <b>DROPIMAGETYPE</b> A DROPIMAGETYPE indicating the stock image to use.
    DROPIMAGETYPE type;
    ///Type: <b>WCHAR[MAX_PATH]</b> Text such as "Move to %1".
    ushort[260]   szMessage;
    ///Type: <b>WCHAR[MAX_PATH]</b> Text such as "Documents", inserted as specified by <b>szMessage</b>.
    ushort[260]   szInsert;
}

///Contains and receives information for change notifications. This structure is used with the SHChangeNotifyRegister
///function and the SFVM_QUERYFSNOTIFY notification.
struct SHChangeNotifyEntry
{
align (1):
    ///Type: <b>PCIDLIST_ABSOLUTE</b> PIDL for which to receive notifications.
    ITEMIDLIST* pidl;
    BOOL        fRecursive;
}

///Contains data used by SHAddToRecentDocs to identify both an item—in this case as an IShellItem—and the process
///that it is associated with.
struct SHARDAPPIDINFO
{
align (1):
    ///Type: <b>IShellItem*</b> Pointer to an IShellItem object that represents the object in the Shell namespace.
    IShellItem    psi;
    ///Type: <b>PCWSTR</b> The application-defined AppUserModelID associated with the item.
    const(wchar)* pszAppID;
}

///Contains data used by SHAddToRecentDocs to identify both an item—in this case by an absolute pointer to an item
///identifier list (PIDL)—and the process that it is associated with.
struct SHARDAPPIDINFOIDLIST
{
align (1):
    ///Type: <b>PCIDLIST_ABSOLUTE</b> An absolute PIDL that gives the full path of the item in the Shell namespace.
    ITEMIDLIST*   pidl;
    ///Type: <b>PCWSTR</b> The application-defined AppUserModelID associated with the item.
    const(wchar)* pszAppID;
}

///Contains data used by SHAddToRecentDocs to identify both an item, in this case through an IShellLink, and the process
///that it is associated with.
struct SHARDAPPIDINFOLINK
{
align (1):
    ///Type: <b>IShellLink*</b> Pointer to an IShellLink instance that, when launched, opens the item. The shortcut is
    ///not added by SHAddToRecentDocs to the user's <b>Recent</b> folder (CSIDL_RECENT, FOLDERID_Recent), but it is
    ///added to the <b>Recent</b> category in the specified application's Jump List.
    IShellLinkA   psl;
    ///Type: <b>PCWSTR</b> The application-defined AppUserModelID associated with the item.
    const(wchar)* pszAppID;
}

///<p class="CCE_Message">[<b>SHChangeDWORDAsIDList</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Stores two <b>DWORD</b> values in a
///form mimicking an ITEMIDLIST so that they can be used by SHChangeNotify.
struct SHChangeDWORDAsIDList
{
align (1):
    ///Type: <b>USHORT</b> The size of the structure, in bytes.
    ushort cb;
    ///Type: <b>DWORD</b> First <b>DWORD</b> value.
    uint   dwItem1;
    ///Type: <b>DWORD</b> Second <b>DWORD</b> value.
    uint   dwItem2;
    ///Type: <b>USHORT</b>
    ushort cbZero;
}

///<p class="CCE_Message">[<b>SHChangeUpdateImageIDList</b> is available for use in the operating systems specified in
///the Requirements section. It may be altered or unavailable in subsequent versions.] Stores the information used as
///parameters to SHUpdateImage in a form mimicking an ITEMIDLIST so that they can be used by SHChangeNotify.
struct SHChangeUpdateImageIDList
{
align (1):
    ///Type: <b>USHORT</b> The size of the structure, in bytes.
    ushort      cb;
    ///Type: <b>int</b> The zero-based index of the icon in the file specified by <b>szName</b>. Obtain this value by
    ///calling IExtractIcon::GetIconLocation and retrieving the value pointed to by <i>piIndex</i>.
    int         iIconIndex;
    ///Type: <b>int</b> The zero-based index in the system image list of the icon being updated.
    int         iCurIndex;
    ///Type: <b>UINT</b> Flags that determine the icon attributes. Obtain this value by calling
    ///IExtractIcon::GetIconLocation and retrieving the value pointed to by <i>pwFlags</i>. These two flags are relevant
    ///to SHUpdateImage.
    uint        uFlags;
    uint        dwProcessID;
    ///Type: <b>WCHAR[MAX_PATH]</b> A null-terminated Unicode string that specifies the fully qualified path of the file
    ///that contains the icon. Obtain this value by calling IExtractIcon::GetIconLocation and retrieving the value
    ///pointed to by <i>szIconFile</i>.
    ushort[260] szName;
    ///Type: <b>USHORT</b>
    ushort      cbZero;
}

///Receives item data in response to a call to SHGetDataFromIDList.
struct SHDESCRIPTIONID
{
    ///Type: <b>DWORD</b> Receives a value that determines what type the item is. One of the following values.
    uint dwDescriptionId;
    GUID clsid;
}

///<p class="CCE_Message">[<b>AUTO_SCROLL_DATA</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Specifies scrolling parameters and
///keeps track of the last scroll operation.
struct AUTO_SCROLL_DATA
{
align (1):
    ///Type: <b>int</b> A value that indicates the number of times the DAD_AutoScroll function has stored data in the
    ///structure. The parameter is reset to <code>0</code> after it equals 2.
    int      iNextSample;
    ///Type: <b>DWORD</b> A <b>DWORD</b> that indicates the time of the last scroll. The scroll time is also stored in
    ///the <b>dwTimes</b> parameter indexed by the current value of <b>iNextSample</b>.
    uint     dwLastScroll;
    ///Type: <b>BOOL</b> A value that is used to determine whether the DAD_AutoScroll function should succeed. This
    ///parameter is set to <b>TRUE</b> when the <b>iNextSample</b> parameter is equal to NUM_POINTS.
    BOOL     bFull;
    ///Type: <b>POINT[NUM_POINTS]</b> A pointer to the current scroll coordinates. The index of this array is
    ///<b>iNextSample</b>.
    POINT[3] pts;
    ///Type: <b>DWORD[NUM_POINTS]</b> A <b>DWORD</b> that indicates the current scroll time. The index of this array is
    ///<b>iNextSample</b>.
    uint[3]  dwTimes;
}

///<p class="CCE_Message">[<b>CABINETSTATE</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Holds the global configuration for
///Windows Explorer and Windows Internet Explorer. This structure is used in the ReadCabinetState and WriteCabinetState
///functions.
struct CABINETSTATE
{
align (1):
    ///Type: <b>WORD</b> The size of the structure, in bytes.
    ushort cLength;
    ///Type: <b>WORD</b>
    ushort nVersion;
    int    _bitfield101;
    ///Type: <b>UINT</b> One or both of the following flags.
    uint   fMenuEnumFilter;
}

struct HPSXA__
{
align (1):
    int unused;
}

///Stores information for the SHOpenWithDialog function.
struct OPENASINFO
{
    ///Type: <b>LPCWSTR</b> A pointer to the file name.
    const(wchar)* pcszFile;
    ///Type: <b>LPCWSTR</b> A pointer to the file type description. Set this parameter to <b>NULL</b> to use the file
    ///name extension of <b>pcszFile</b>.
    const(wchar)* pcszClass;
    ///Type: <b>OPEN_AS_INFO_FLAGS</b> The characteristics of the SHOpenWithDialog dialog box. One or more of the
    ///following values.
    int           oaifInFlags;
}

struct QCMINFO_IDMAP_PLACEMENT
{
    uint id;
    uint fFlags;
}

struct QCMINFO_IDMAP
{
    uint nMaxIds;
    QCMINFO_IDMAP_PLACEMENT[1] pIdList;
}

///Contains information for merging menu items into Windows Explorer menus.
struct QCMINFO
{
    ///Type: <b>HMENU</b> [in] The handle of the menu where the new commands are to be added.
    HMENU hmenu;
    ///Type: <b>UINT</b> [in] The zero-based index where the first menu item are to be inserted.
    uint  indexMenu;
    ///Type: <b>UINT</b> [in, out] On entry, this member contains the first available ID to be used for the context
    ///menu. On exit, it contains the last ID added plus one.
    uint  idCmdFirst;
    ///Type: <b>UINT</b> [in] The maximum value for a menu item identifier. The difference between the input value of
    ///<b>idCmdFirst</b> and <b>idCmdLast</b> is the maximum number of menu items that can be added.
    uint  idCmdLast;
    ///Type: <b>QCMINFO_IDMAP*</b> Not used, must be <b>NULL</b>.
    const(QCMINFO_IDMAP)* pIdMap;
}

///Contains detail information for a Shell folder item. Used with the SFVM_GETDETAILSOF notification.
struct DETAILSINFO
{
    ///Type: <b>PCUITEMID_CHILD</b> PIDL of the item whose details are being retrieved.
    ITEMIDLIST* pidl;
    ///Type: <b>int</b> The alignment of the column heading and the subitem text in the column. This member can be one
    ///of the following values. Note that the alignment of the leftmost column is always left-justified and cannot be
    ///changed.
    int         fmt;
    ///Type: <b>int</b> The number of average-sized characters in the heading.
    int         cxChar;
    ///Type: <b>STRRET</b> An STRRET structure that includes a string containing the requested detail. To convert this
    ///structure to a string, use StrRetToBuf or StrRetToStr.
    STRRET      str;
    int         iImage;
}

///Contains the details of a page to be added to an object's <b>Properties</b> sheet.
struct SFVM_PROPPAGE_DATA
{
    ///Type: <b>DWORD</b>
    uint                 dwReserved;
    ///Type: <b>LPFNADDPROPSHEETPAGE</b> A pointer to a AddPropSheetPageProc callback function used to add property
    ///pages. When this function is used by Windows Explorer, it provides <b>pfn</b> through the system folder view
    ///object's IShellView::AddPropertySheetPages method. The callback function can then pass the information to
    ///IShellPropSheetExt::AddPages.
    LPFNADDPROPSHEETPAGE pfn;
    LPARAM               lParam;
}

///Contains the name of an HTML Help file and a topic in that file. Used with the SFVM_GETHELPTOPIC notification. This
///structure requires Unicode strings.
struct SFVM_HELPTOPIC_DATA
{
    ///Type: <b>WCHAR[MAX_PATH]</b> A null-terminated Unicode string containing the fully qualified path to the help
    ///file.
    ushort[260] wszHelpFile;
    ushort[260] wszHelpTopic;
}

///Stores the dimensions of the two possible sizes of icon spacing that are available for display: small and large. Used
///by IShellFolderView::GetItemSpacing.
struct ITEMSPACING
{
    ///Type: <b>int</b> The width of the spacing between icons in small icon mode, in pixels.
    int cxSmall;
    ///Type: <b>int</b> The height of the spacing between icons in small icon mode, in pixels.
    int cySmall;
    ///Type: <b>int</b> The width of the spacing between icons in large icon mode, in pixels.
    int cxLarge;
    int cyLarge;
}

///This structure is used with the SHCreateShellFolderView function.
struct SFV_CREATE
{
    ///Type: <b>UINT</b> The size of the <b>SFV_CREATE</b> structure, in bytes.
    uint               cbSize;
    ///Type: <b>IShellFolder*</b> The IShellFolder interface of the folder for which to create the view.
    IShellFolder       pshf;
    ///Type: <b>IShellView*</b> A pointer to the parent IShellView interface. This parameter may be <b>NULL</b>. This
    ///parameter is used only when the view created by SHCreateShellFolderView is hosted in a common dialog box.
    IShellView         psvOuter;
    ///Type: <b>IShellFolderViewCB*</b> A pointer to the IShellFolderViewCB interface that handles the view's callbacks
    ///when various events occur. This parameter may be <b>NULL</b>.
    IShellFolderViewCB psfvcb;
}

///Contains context menu information used by SHCreateDefaultContextMenu.
struct DEFCONTEXTMENU
{
    ///Type: <b>HWND</b> A handle to the context menu. Set this member to the handle returned from CreateMenu.
    HWND              hwnd;
    ///Type: <b>IContextMenuCB*</b> A pointer to the IContextMenuCB interface supported by the callback object. This
    ///value is optional and can be <b>NULL</b>.
    IContextMenuCB    pcmcb;
    ///Type: <b>PCIDLIST_ABSOLUTE</b> The PIDL of the folder that contains the selected file object(s) or the folder of
    ///the context menu if no file objects are selected. This value is optional and can be <b>NULL</b>, in which case
    ///the PIDL is computed from the <b>psf</b> member.
    ITEMIDLIST*       pidlFolder;
    ///Type: <b>IShellFolder*</b> A pointer to the IShellFolder interface of the folder object that contains the
    ///selected file objects, or the folder that contains the context menu if no file objects are selected.
    IShellFolder      psf;
    ///Type: <b>UINT</b> The count of items in member <b>apidl</b>.
    uint              cidl;
    ///Type: <b>PCUITEMID_CHILD_ARRAY</b> A pointer to a constant array of ITEMIDLIST structures. Each entry in the
    ///array describes a child item to which the context menu applies, for instance, a selected file the user wants to
    ///<b>Open</b>.
    ITEMIDLIST**      apidl;
    ///Type: <b>IUnknown*</b> A pointer to the IQueryAssociations interface on the object from which to load extensions.
    ///This parameter is optional and thus can be <b>NULL</b>. If this value is <b>NULL</b> and members <b>aKeys</b> and
    ///<b>cKeys</b> are also <b>NULL</b> (see Remarks), <b>punkAssociationInfo</b> is computed from the <b>apidl</b>
    ///member and <b>cidl</b> via a request for <b>IQueryAssociations</b> through IShellFolder::GetUIObjectOf. If
    ///IShellFolder::GetUIObjectOf returns <b>E_NOTIMPL</b>, a default implementation is provided based on the
    ///<i>SFGAO_FOLDER</i> and <i>SFGAO_FILESYSTEM</i> attributes returned from IShellFolder::GetAttributesOf.
    IUnknown          punkAssociationInfo;
    ///Type: <b>UINT</b> The count of items in member <b>aKeys</b>. This value can be zero. If the value is zero, the
    ///extensions are loaded based on the object that supports interface IQueryAssociations as specified by member
    ///<b>punkAssociationInfo</b>. If the value is non-NULL, the extensions are loaded based only on member <b>aKeys</b>
    ///and not member <b>punkAssociationInfo</b>. <div class="alert"><b>Note</b> The maximum number of keys is 16.
    ///Callers must enforce this limit as the API does not. Failing to do so can result in memory corruption.</div>
    ///<div> </div>
    uint              cKeys;
    ///Type: <b>const HKEY*</b> A pointer to an HKEY that specifies the registry key from which to load extensions. This
    ///parameter is optional and can be <b>NULL</b>. If the value is <b>NULL</b>, the extensions are loaded based on the
    ///object that supports interface IQueryAssociations as specified in <b>punkAssociationInfo</b>.
    const(ptrdiff_t)* aKeys;
}

///Contains additional arguments used by DFM_INVOKECOMMANDEX.
struct DFMICS
{
    ///Type: <b>DWORD</b> The size of this structure, in bytes.
    uint                 cbSize;
    ///Type: <b>DWORD</b> Zero, or one or more of the following flags that specify how to handle the data in the
    ///CMINVOKECOMMANDINFO or CMINVOKECOMMANDINFOEX structure pointed to by <b>pici</b>.
    uint                 fMask;
    ///Type: <b>LPARAM</b> A pointer to a null-terminated string that contains additional arguments to the selected menu
    ///command. This member can be <b>NULL</b>.
    LPARAM               lParam;
    ///Type: <b>UINT</b> The minimum value that the handler can specify for a menu item identifier.
    uint                 idCmdFirst;
    ///Type: <b>UINT</b> The maximum value that the handler can specify for a menu item identifier.
    uint                 idDefMax;
    ///Type: <b>LPCMINVOKECOMMANDINFO</b> A pointer to a CMINVOKECOMMANDINFO or <b>CMINVOKECOMMANDINFO</b> structure.
    CMINVOKECOMMANDINFO* pici;
    IUnknown             punkSite;
}

///Used with the SHCreateShellFolderViewEx function.
struct CSFV
{
    ///Type: <b>UINT</b> The size of the <b>CSFV</b> structure, in bytes.
    uint             cbSize;
    ///Type: <b>IShellFolder*</b> A pointer to the IShellFolder object for which to create the view.
    IShellFolder     pshf;
    ///Type: <b>IShellView*</b> A pointer to the parent IShellView interface. This parameter can be <b>NULL</b>.
    IShellView       psvOuter;
    ///Type: <b>PCIDLIST_ABSOLUTE</b> Ignored.
    ITEMIDLIST*      pidl;
    ///Type: <b>LONG</b>
    int              lEvents;
    ///Type: <b>LPFNVIEWCALLBACK</b> A pointer to the LPFNVIEWCALLBACK function used by this folder view to handle
    ///callback messages. This parameter can be <b>NULL</b>.
    LPFNVIEWCALLBACK pfnCallback;
    FOLDERVIEWMODE   fvm;
}

///Contains settings for the Shell's state. This structure is used with the SHGetSetSettings function.
struct SHELLSTATEA
{
align (1):
    int  _bitfield1;
    ///Type: <b>DWORD</b> Not used.
    uint dwWin95Unused;
    ///Type: <b>UINT</b> Not used.
    uint uWin95Unused;
    ///Type: <b>LONG</b> The column to sort by.
    int  lParamSort;
    ///Type: <b>int</b> Alphabetical sort direction for the column specified by <b>lParamSort</b>. Use 1 for an
    ///ascending sort, -1 for a descending sort.
    int  iSortDirection;
    ///Type: <b>UINT</b> Not used.
    uint version_;
    ///Type: <b>UINT</b> Not used.
    uint uNotUsed;
    int  _bitfield2;
}

///Contains settings for the Shell's state. This structure is used with the SHGetSetSettings function.
struct SHELLSTATEW
{
align (1):
    int  _bitfield1;
    ///Type: <b>DWORD</b> Not used.
    uint dwWin95Unused;
    ///Type: <b>UINT</b> Not used.
    uint uWin95Unused;
    ///Type: <b>LONG</b> The column to sort by.
    int  lParamSort;
    ///Type: <b>int</b> Alphabetical sort direction for the column specified by <b>lParamSort</b>. Use 1 for an
    ///ascending sort, -1 for a descending sort.
    int  iSortDirection;
    ///Type: <b>UINT</b> Not used.
    uint version_;
    ///Type: <b>UINT</b> Not used.
    uint uNotUsed;
    int  _bitfield2;
}

///Contains a set of flags that indicate the current Shell settings. This structure is used with the SHGetSettings
///function.
struct SHELLFLAGSTATE
{
align (1):
    int _bitfield102;
}

///Contains information about a folder band. This structure is used with the IShellFolderBand::GetBandInfoSFB and
///IShellFolderBand::SetBandInfoSFB methods.
struct BANDINFOSFB
{
    ///Type: <b>DWORD</b> A mask that indicates which members of this <b>BANDINFOSFB</b> structure are valid. One or
    ///more of the following values.
    uint         dwMask;
    ///Type: <b>DWORD</b> A mask that indicates which of the <b>dwState</b> bits are valid to be set or queried. One or
    ///more of the following values.
    uint         dwStateMask;
    ///Type: <b>DWORD</b> State bits. One of the values listed for <b>dwStateMask</b>.
    uint         dwState;
    ///Type: <b>COLORREF</b> A COLORREF that contains the background color of the band.
    uint         crBkgnd;
    ///Type: <b>COLORREF</b> COLORREF that contains the light button color.
    uint         crBtnLt;
    ///Type: <b>COLORREF</b> COLORREF that contains the dark button color.
    uint         crBtnDk;
    ///Type: <b>WORD</b> View mode of the band. One of the following values.
    ushort       wViewMode;
    ///Type: <b>WORD</b>
    ushort       wAlign;
    ///Type: <b>IShellFolder*</b> A pointer to an IShellFolder object.
    IShellFolder psf;
    ITEMIDLIST*  pidl;
}

///Contains information about the properties of a column. It is used by IColumnProvider::GetColumnInfo.
struct SHCOLUMNINFO
{
align (1):
    ///Type: <b>SHCOLUMNID</b> A SHCOLUMNID structure that uniquely identifies the column.
    PROPERTYKEY scid;
    ///Type: <b>VARTYPE</b> The native VARIANT type of the column's data.
    ushort      vt;
    ///Type: <b>DWORD</b> List view format. This member is normally set to LVCFMT_LEFT.
    uint        fmt;
    ///Type: <b>UINT</b> The default width of the column, in characters.
    uint        cChars;
    ///Type: <b>DWORD</b> Flags indicating the default column state. It can be a combination of the following flags.
    uint        csFlags;
    ///Type: <b>WCHAR[MAX_COLUMN_NAME_LEN]</b> A null-terminated Unicode string with the column's title. It must contain
    ///no more than MAX_COLUMN_NAME_LEN characters, including the terminating <b>NULL</b>.
    ushort[80]  wszTitle;
    ///Type: <b>WCHAR[MAX_COLUMN_DESC_LEN]</b> A null-terminated Unicode string with the column's description. It must
    ///contain no more than MAX_COLUMN_DESC_LEN characters, including the terminating <b>NULL</b>.
    ushort[128] wszDescription;
}

///Passes initialization information to IColumnProvider::Initialize.
struct SHCOLUMNINIT
{
    ///Type: <b>ULONG</b> Initialization flags. Reserved. Set to <b>NULL</b>
    uint        dwFlags;
    ///Type: <b>ULONG</b> Reserved. Set to <b>NULL</b>.
    uint        dwReserved;
    ushort[260] wszFolder;
}

///Contains information that identifies a particular file. It is used by IColumnProvider::GetItemData when requesting
///data for a particular file.
struct SHCOLUMNDATA
{
    ///Type: <b>ULONG</b> Flags used to specify the nature of the request.
    uint        dwFlags;
    ///Type: <b>DWORD</b> File attribute flags. It will be one or more of the following values.
    uint        dwFileAttributes;
    ///Type: <b>ULONG</b> Reserved. Set to <b>NULL</b>.
    uint        dwReserved;
    ///Type: <b>WCHAR*</b> A pointer to a null-terminated Unicode string with a file name extension.
    ushort*     pwszExt;
    ///Type: <b>WCHAR[MAX_PATH]</b> A null-terminated Unicode string containing a fully qualified file path.
    ushort[260] wszFile;
}

///<p class="CCE_Message">[This structure is not supported.]
struct SHChangeProductKeyAsIDList
{
align (1):
    ushort     cb;
    ushort[39] wszProductKey;
    ushort     cbZero;
}

///Used with the SFVM_GETBUTTONINFO notification to specify the number of buttons to add to the toolbar, as well as how
///they're added.
struct TBINFO
{
    ///Type: <b>UINT</b> The number of buttons.
    uint cbuttons;
    ///Type: <b>UINT</b> One of the following flags.
    uint uFlags;
}

///Stores position information for an item. Used with message SFVM_SETITEMPOS.
struct SFV_SETITEMPOS
{
    ///Type: <b>PCUITEMID_CHILD</b> A pointer to an ITEMIDLIST for the item.
    ITEMIDLIST* pidl;
    POINT       pt;
}

///A variable-size structure that contains information about a menu file name.
struct AASHELLMENUFILENAME
{
    ///Type: <b>SHORT</b> The size of the structure, in bytes.
    short     cbTotal;
    ///Type: <b>BYTE[12]</b> Reserved. Applications should ignore this value.
    ubyte[12] rgbReserved;
    ///Type: <b>TCHAR[1]</b> The menu file name. This string is in Unicode on Windows 2000.
    ushort[1] szFileName;
}

///Contains information about a menu item.
struct AASHELLMENUITEM
{
    ///Type: <b>VOID</b> Reserved. Applications should ignore this value.
    void*                lpReserved1;
    ///Type: <b>int</b> Reserved. Applications should ignore this value.
    int                  iReserved;
    ///Type: <b>UINT</b> Reserved. Applications should ignore this value.
    uint                 uiReserved;
    ///Type: <b>LPAASHELLMENUFILENAME</b> If the selected menu item represents a file, this member is a pointer to an
    ///AASHELLMENUFILENAME structure that contains the name of the file. Otherwise this member is <b>NULL</b>.
    AASHELLMENUFILENAME* lpName;
    ///Type: <b>LPTSTR</b> A pointer to the string that contains the text to use if there is no file.
    const(wchar)*        psz;
}

///Used by the ParseURL function to return the parsed URL.
struct PARSEDURLA
{
    ///Type: <b>DWORD</b> [in] The size of the structure, in bytes. The calling application must set this member before
    ///calling the ParseURL function.
    uint         cbSize;
    ///Type: <b>LPCTSTR</b> [out] A pointer to the beginning of the protocol part of the URL.
    const(char)* pszProtocol;
    ///Type: <b>UINT</b> The number of characters in the URL's protocol section.
    uint         cchProtocol;
    ///Type: <b>LPCTSTR</b> [out] A pointer to the section of the URL that follows the protocol and colon (':'). For
    ///file URLs, the function also skips the leading "//" characters.
    const(char)* pszSuffix;
    ///Type: <b>UINT</b> [out] The number of characters in the URL's suffix.
    uint         cchSuffix;
    ///Type: <b>UINT</b> [out] A value from the URL_SCHEME enumeration that specifies the URL's scheme.
    uint         nScheme;
}

///Used by the ParseURL function to return the parsed URL.
struct PARSEDURLW
{
    ///Type: <b>DWORD</b> [in] The size of the structure, in bytes. The calling application must set this member before
    ///calling the ParseURL function.
    uint          cbSize;
    ///Type: <b>LPCTSTR</b> [out] A pointer to the beginning of the protocol part of the URL.
    const(wchar)* pszProtocol;
    ///Type: <b>UINT</b> The number of characters in the URL's protocol section.
    uint          cchProtocol;
    ///Type: <b>LPCTSTR</b> [out] A pointer to the section of the URL that follows the protocol and colon (':'). For
    ///file URLs, the function also skips the leading "//" characters.
    const(wchar)* pszSuffix;
    ///Type: <b>UINT</b> [out] The number of characters in the URL's suffix.
    uint          cchSuffix;
    ///Type: <b>UINT</b> [out] A value from the URL_SCHEME enumeration that specifies the URL's scheme.
    uint          nScheme;
}

///Used by the QISearch function to describe a single interface.
struct QITAB
{
    ///Type: <b>const IID*</b> A pointer to the IID of the interface represented by this structure.
    const(GUID)* piid;
    ///Type: <b>int</b> The offset, in bytes, from the base of the object to the start of the interface.
    uint         dwOffset;
}

///Receives DLL-specific version information. It is used with the DllGetVersion function. <div class="alert"><b>Note</b>
///In place of this structure, you can use the DLLVERSIONINFO2 structure.</div><div> </div>
struct DLLVERSIONINFO
{
    ///Type: <b>DWORD</b> The size of the structure, in bytes. This member must be filled in before calling the
    ///function.
    uint cbSize;
    ///Type: <b>DWORD</b> The major version of the DLL. For instance, if the DLL's version is 4.0.950, this value will
    ///be 4.
    uint dwMajorVersion;
    ///Type: <b>DWORD</b> The minor version of the DLL. For instance, if the DLL's version is 4.0.950, this value will
    ///be 0.
    uint dwMinorVersion;
    ///Type: <b>DWORD</b> The build number of the DLL. For instance, if the DLL's version is 4.0.950, this value will be
    ///950.
    uint dwBuildNumber;
    ///Type: <b>DWORD</b> Identifies the platform for which the DLL was built. This can be one of the following values.
    uint dwPlatformID;
}

///Receives DLL-specific version information. It is used with the DllGetVersion function.
struct DLLVERSIONINFO2
{
    ///Type: <b>DLLVERSIONINFO</b> A DLLVERSIONINFO structure. This member is included to provide backward compatibility
    ///with applications that are not expecting a <b>DLLVERSIONINFO2</b> structure.
    DLLVERSIONINFO info1;
    ///Type: <b>DWORD</b> Reserved.
    uint           dwFlags;
    ///Type: <b>ULONGLONG</b> A value that contains the version information. It is divided into four 16-bitfields
    ///containing the major and minor version numbers, the build number, and the hotfix version, in that order. Use the
    ///MAKEDLLVERULL macro to construct this value.
    ulong          ullVersion;
}

///Provides information about a published application to the Add/Remove Programs Control Panel utility.
struct APPINFODATA
{
    ///Type: <b>DWORD</b> A value of type <b>DWORD</b> that specifies the size of the <b>APPINFODATA</b> data structure.
    ///This field is set by the Add/Remove Program executable code.
    uint          cbSize;
    ///Type: <b>DWORD</b> A value of type <b>DWORD</b> that specifies the bitmask that indicates which items in the
    ///structure are desired or valid. Implementations of GetAppInfo should inspect this value for bits that are set and
    ///attempt to provide values corresponding to those bits. Implementations should also return with bits set for only
    ///those members that are being returned.
    uint          dwMask;
    ///Type: <b>LPWSTR</b> A pointer to a string that contains the application display name. Memory for this string must
    ///be allocated using CoTaskMemAlloc and freed using CoTaskMemFree.
    const(wchar)* pszDisplayName;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszVersion;
    const(wchar)* pszPublisher;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszProductID;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszRegisteredOwner;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszRegisteredCompany;
    ///Type: <b>LPWSTR</b> Not applicable to published applications. Type: <b>LPWSTR</b> Not applicable to published
    ///applications.
    const(wchar)* pszLanguage;
    ///Type: <b>LPWSTR</b> A URL to support information. This string is displayed as a link with the application name in
    ///Control Panel Add/Remove Programs. Memory for this string must be allocated using CoTaskMemAlloc and freed using
    ///CoTaskMemFree.
    const(wchar)* pszSupportUrl;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszSupportTelephone;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszHelpLink;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszInstallLocation;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszInstallSource;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszInstallDate;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszContact;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszComments;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszImage;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszReadmeUrl;
    ///Type: <b>LPWSTR</b> Not applicable to published applications.
    const(wchar)* pszUpdateInfoUrl;
}

///Provides specialized application information to <b>Add/Remove Programs</b> in Control Panel. This structure is not
///applicable to published applications.
struct SLOWAPPINFO
{
    ///Type: <b>ULONGLONG</b> The size of the application in bytes.
    ulong         ullSize;
    ///Type: <b>FILETIME</b> The time the application was last used.
    FILETIME      ftLastUsed;
    ///Type: <b>int</b> The count of times the application has been used.
    int           iTimesUsed;
    ///Type: <b>LPWSTR</b> A pointer to a string containing the path to the image that represents the application. The
    ///string buffer must be allocated using CoTaskMemAlloc and freed using CoTaskMemFree.
    const(wchar)* pszImage;
}

///Provides information about a published application from an application publisher to <b>Add/Remove Programs</b> in
///Control Panel.
struct PUBAPPINFO
{
    ///Type: <b>DWORD</b> A value of type <b>DWORD</b> that specifies the size of the structure. This member is set by
    ///the <b>Add/Remove Programs</b> utility.
    uint          cbSize;
    ///Type: <b>DWORD</b> A bitmask that indicates which items in the structure are valid. This member can contain one
    ///or more PUBAPPINFOFLAGS.
    uint          dwMask;
    ///Type: <b>LPWSTR</b> A pointer to a string containing the display name of the publisher. This name appears in
    ///<b>Add/Remove Programs</b> if duplicate application names are encountered. The string buffer must be allocated
    ///using the Shell task allocator.
    const(wchar)* pszSource;
    ///Type: <b>SYSTEMTIME</b> The time when an application manager schedules the application installation.
    ///<b>Add/Remove Programs</b> does not allow the user to schedule an installation time later than the value in this
    ///member. This member is ignored if it describes a time prior to the current time.
    SYSTEMTIME    stAssigned;
    ///Type: <b>SYSTEMTIME</b>
    SYSTEMTIME    stPublished;
    ///Type: <b>SYSTEMTIME</b> The installation time that the user sets by clicking <b>Add Later</b>. <b>Add/Remove
    ///Programs</b> calls the IPublishedApp::Install method with the <i>pInstallTime</i> parameter pointing to a
    ///SYSTEMTIME structure that contains the time the user entered. The application publisher maintains this value for
    ///installation scheduling. IPublishedApp::GetPublishedAppInfo returns the scheduled installation time in this
    ///member if the scheduled time has not been canceled using IPublishedApp::Unschedule.
    SYSTEMTIME    stScheduled;
    ///Type: <b>SYSTEMTIME</b> The time after which you cannot install the published application using <b>Add/Remove
    ///Programs</b>.
    SYSTEMTIME    stExpire;
}

///Describes a single field in a credential. For example, a string or a user image.
struct CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR
{
    ///Type: <b>DWORD</b> The unique ID of the field. Fields should have a unique identifier compared to all other
    ///fields on a given credential provider. This is true regardless of whether the fields are displayed or hidden.
    uint          dwFieldID;
    ///Type: <b>CREDENTIAL_PROVIDER_FIELD_TYPE</b> The field type.
    CREDENTIAL_PROVIDER_FIELD_TYPE cpft;
    ///Type: <b>LPWSTR</b> A pointer to a buffer containing the friendly name of the field as a null-terminated Unicode
    ///string. This is used for accessibility and queuing purposes. For example, some standard fields would have friend
    ///names of "Username", "Password", and "Log On To".
    const(wchar)* pszLabel;
    ///Type: <b>GUID</b> A GUID that uniquely identifies a type of field. This member enables you to wrap functionality
    ///provided by existing credential providers in their own providers. Wrapping credential providers is not
    ///recommended as it can lead to unexpected behavior that disables in-box credential providers. The following table
    ///lists the <i>guidFieldType</i> values supported by Windows. These are defined in Shlguid.h. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CPFG_LOGON_USERNAME"></a><a
    ///id="cpfg_logon_username"></a><dl> <dt><b>CPFG_LOGON_USERNAME</b></dt>
    ///<dt>da15bbe8-954sd-4fd3-b0f4-1fb5b90b174b</dt> </dl> </td> <td width="60%"> The user name entered into a text
    ///box. </td> </tr> <tr> <td width="40%"><a id="CPFG_LOGON_PASSWORD"></a><a id="cpfg_logon_password"></a><dl>
    ///<dt><b>CPFG_LOGON_PASSWORD</b></dt> <dt>60624cfa-a477-47b1-8a8e-3a4a19981827</dt> </dl> </td> <td width="60%">
    ///The password entered into a text box. </td> </tr> <tr> <td width="40%"><a id="CPFG_SMARTCARD_USERNAME"></a><a
    ///id="cpfg_smartcard_username"></a><dl> <dt><b>CPFG_SMARTCARD_USERNAME</b></dt>
    ///<dt>3e1ecf69-568c-4d96-9d59-46444174e2d6</dt> </dl> </td> <td width="60%"> The user name obtained from an
    ///inserted smart card. </td> </tr> <tr> <td width="40%"><a id="CPFG_SMARTCARD_PIN"></a><a
    ///id="cpfg_smartcard_pin"></a><dl> <dt><b>CPFG_SMARTCARD_PIN</b></dt> <dt>4fe5263b-9181-46c1-b0a4-9dedd4db7dea</dt>
    ///</dl> </td> <td width="60%"> The PIN obtained from an inserted smart card. </td> </tr> <tr> <td width="40%"><a
    ///id="CPFG_CREDENTIAL_PROVIDER_LOGO"></a><a id="cpfg_credential_provider_logo"></a><dl>
    ///<dt><b>CPFG_CREDENTIAL_PROVIDER_LOGO</b></dt> <dt>2d837775-f6cd-464e-a745-482fd0b47493</dt> </dl> </td> <td
    ///width="60%"> <b>Introduced in Windows 8</b>: The image used to represent a credential provider on the logon page.
    ///</td> </tr> <tr> <td width="40%"><a id="CPFG_CREDENTIAL_PROVIDER_LABEL"></a><a
    ///id="cpfg_credential_provider_label"></a><dl> <dt><b>CPFG_CREDENTIAL_PROVIDER_LABEL</b></dt>
    ///<dt>286BBFF3-BAD4-438F-B007-79B7267C3D48</dt> </dl> </td> <td width="60%"> <b>Introduced in Windows 8</b>: The
    ///label associated with a credential provider on the logon page. </td> </tr> </table>
    GUID          guidFieldType;
}

///Contains details about a credential.
struct CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION
{
    ///Type: <b>ULONG</b> The unique identifier of the authentication package. This parameter is required when calling
    ///LsaLogonUser. In a Credential UI scenario, this value is set before a serialization is sent through
    ///SetSerialization. This is the same as the authentication package value returned by
    ///LsaLookupAuthenticationPackage. Content providers can use this parameter to determine if they are able to return
    ///credentials for this authentication package. Developers who write their own authentication package may supply
    ///their own value.
    uint   ulAuthenticationPackage;
    ///Type: <b>GUID</b> The CLSID of the credential provider. Credential providers assign their own CLSID to this
    ///member during serialization. Credential UI ignores this member.
    GUID   clsidCredentialProvider;
    ///Type: <b>ULONG</b> The size, in bytes, of the credential pointed to by <b>rgbSerialization</b>.
    uint   cbSerialization;
    ///Type: <b>byte*</b> An array of bytes containing serialized credential information. The exact format of this data
    ///depends on the authentication package targeted by a credential provider.
    ubyte* rgbSerialization;
}

///Describes conflict ID information structure.
struct SYNCMGR_CONFLICT_ID_INFO
{
    ///Type: <b>BYTE_BLOB*</b> A pointer to a blob used for comparison.
    BYTE_BLOB* pblobID;
    BYTE_BLOB* pblobExtra;
}

///Defines conflict item structure.
struct CONFIRM_CONFLICT_ITEM
{
    ///Type: <b>IShellItem2*</b> A pointer to IShellItem2 interface.
    IShellItem2   pShellItem;
    ///Type: <b>LPWSTR</b> A pointer to the original name. If set to <b>NULL</b> then IShellItem's display name will be
    ///used.
    const(wchar)* pszOriginalName;
    ///Type: <b>LPWSTR</b> A pointer to the alternate name. If multiple items are kept, then item must be renamed to
    ///this name. User may or may not have an ability to change the name.
    const(wchar)* pszAlternateName;
    ///Type: <b>LPWSTR</b> A pointer to the short location.
    const(wchar)* pszLocationShort;
    ///Type: <b>LPWSTR</b> A pointer to the full location.
    const(wchar)* pszLocationFull;
    SYNCMGR_CONFLICT_ITEM_TYPE nType;
}

///Defines conflict result information structure.
struct CONFIRM_CONFLICT_RESULT_INFO
{
    ///Type: <b>LPWSTR</b> The new item name.
    const(wchar)* pszNewName;
    uint          iItemIndex;
}

///Contains a unique identifier for a thumbnail in the system thumbnail cache.
struct WTS_THUMBNAILID
{
    ///Type: <b>BYTE[16]</b> An array of 16 bytes that make up a unique identifier for a thumbnail in the system
    ///thumbnail cache.
    ubyte[16] rgbKey;
}

///Provides status information while a synchronization is in progress. This structure is used with the
///ISyncMgrSynchronizeCallback::Progress method and corresponds to a single synchronization item.
struct SYNCMGRPROGRESSITEM
{
    ///Type: <b>DWORD</b> The size of the structure, in bytes.
    uint          cbSize;
    ///Type: <b>UINT</b> Flags from the SYNCMGRSTATUS enumeration that specify which members of this structure are used.
    uint          mask;
    ///Type: <b>LPCWSTR</b> Status text.
    const(wchar)* lpcStatusText;
    ///Type: <b>DWORD</b> One of the values from the SYNCMGRSTATUS enumeration.
    uint          dwStatusType;
    ///Type: <b>int</b> An integer that indicates the progress value.
    int           iProgValue;
    ///Type: <b>int</b> An integer that indicates the maximum progress value.
    int           iMaxValue;
}

///Provides error information for use in the ISyncMgrSynchronizeCallback::LogError method.
struct SYNCMGRLOGERRORINFO
{
    ///Type: <b>DWORD</b> The size of the structure.
    uint cbSize;
    ///Type: <b>DWORD</b> The mask value. The synchronization manager handler implemented by your application can set
    ///any combination of the following bits to indicate which fields of <b>SYNCMGRLOGERRORINFO</b> it has filled in
    ///when calling ISyncMgrSynchronizeCallback::LogError.
    uint mask;
    ///Type: <b>DWORD</b> Error flags. At this time only the following value is recognized.
    uint dwSyncMgrErrorFlags;
    ///Type: <b>GUID</b> An error identifier.
    GUID ErrorID;
    ///Type: <b>GUID</b> The item where the error occurred.
    GUID ItemID;
}

///Provides information about items being enumerated by the ISyncMgrEnumItems interface.
struct SYNCMGRITEM
{
    ///Type: <b>DWORD</b> The size of the structure.
    uint        cbSize;
    ///Type: <b>DWORD</b> One or more values from the SYNCMGRITEMFLAGS enumeration.
    uint        dwFlags;
    ///Type: <b>GUID</b> The identifier for this item.
    GUID        ItemID;
    ///Type: <b>DWORD</b> Indicates whether this item is included in synchronization operations. This member can have
    ///one of the following values.
    uint        dwItemState;
    ///Type: <b>HICON</b> The icon for this item.
    HICON       hIcon;
    ///Type: <b>WCHAR[MAX_SYNCMGRITEMNAME]</b> The name of this item.
    ushort[128] wszItemName;
    ///Type: <b>FILETIME</b> The time of the last synchronization for this item.
    FILETIME    ftLastUpdate;
}

///Provides information about the handler for use in the ISyncMgrSynchronize::GetHandlerInfo method.
struct SYNCMGRHANDLERINFO
{
    ///Type: <b>DWORD</b> The size of the structure in bytes.
    uint       cbSize;
    ///Type: <b>HICON</b> The icon for the handler.
    HICON      hIcon;
    ///Type: <b>DWORD</b> The value of the SYNCMGRHANDLERFLAGS enumeration.
    uint       SyncMgrHandlerFlags;
    ///Type: <b>WCHAR[MAX_SYNCMGRHANDLERNAME]</b> The name to use for the handler.
    ushort[32] wszHandlerName;
}

///Stores window data.
struct WINDOWDATA
{
    ///Type: <b>DWORD</b> The window ID.
    uint          dwWindowID;
    ///Type: <b>UINT</b> The codepage of the current entry.
    uint          uiCP;
    ///Type: <b>PIDLIST_ABSOLUTE</b> The current PIDL.
    ITEMIDLIST*   pidl;
    ///Type: <b>LPWSTR</b> A pointer to a buffer to hold the window URL.
    const(wchar)* lpszUrl;
    ///Type: <b>LPWSTR</b> A pointer to a buffer to hold the window URL Location (local anchor).
    const(wchar)* lpszUrlLocation;
    const(wchar)* lpszTitle;
}

struct HLITEM
{
    uint          uHLID;
    const(wchar)* pwzFriendlyName;
}

struct HLTBINFO
{
    uint uDockType;
    RECT rcTbPos;
}

struct HLBWINFO
{
    uint     cbSize;
    uint     grfHLBWIF;
    RECT     rcFramePos;
    RECT     rcDocPos;
    HLTBINFO hltbinfo;
}

///Contains protected members of the base class. <b>BASEBROWSERDATA</b> defines the browser state and is used with
///IBrowserService2::GetBaseBrowserData and IBrowserService2::PutBaseBrowserData.
struct BASEBROWSERDATAXP
{
    ///Type: <b>HWND</b> The handle of the browser's top-level window.
    HWND              _hwnd;
    ///Type: <b>ITravelLog*</b> A pointer to the browser's ITravelLog.
    ITravelLog        _ptl;
    ///Type: <b>IHlinkFrame*</b> A pointer to the browser's IHlinkFrame. <div class="alert"><b>Note</b> This member is
    ///only valid on first navigation from an hlink element-compatible application such as Word.</div> <div> </div>
    IHlinkFrame       _phlf;
    ///Type: <b>IWebBrowser2*</b> A pointer to the browser's IWebBrowser2 object.
    IWebBrowser2      _pautoWB2;
    ///Type: <b>IExpDispSupport*</b> A pointer to the browser's IExpDispSupport object.
    IExpDispSupportXP _pautoEDS;
    ///Type: <b>IShellService*</b> A pointer to the browser's IShellService object.
    IShellService     _pautoSS;
    ///Type: <b>int</b> One of the following values to indicate the security lock icon.
    int               _eSecureLockIcon;
    uint              _bitfield103;
    ///Type: <b>UINT</b> The browser view is in an activated state.
    uint              _uActivateState;
    ITEMIDLIST*       _pidlViewState;
    ///Type: <b>IOleCommandTarget*</b> A cached pointer to the IOleCommandTarget object associated with the IShellFolder
    ///object pointed to by <b>_psv</b>.
    IOleCommandTarget _pctView;
    ///Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL of the current navigated location of the browser. This value is the same
    ///retrieved by IBrowserService::GetPidl.
    ITEMIDLIST*       _pidlCur;
    ///Type: <b>IShellView*</b> A pointer to the IShellView of the current location. This <b>IShellView</b> is bound to
    ///<b>_pidlCur</b> through IShellFolder::CreateViewObject.
    IShellView        _psv;
    ///Type: <b>IShellFolder*</b> A pointer to the IShellFolder of the current location. This <b>IShellFolder</b> is
    ///bound to <b>_pidlCur</b>.
    IShellFolder      _psf;
    ///Type: <b>HWND</b> A handle to the window returned by _psv->CreateViewWindow.
    HWND              _hwndView;
    ///Type: <b>LPWSTR</b> A pointer to a buffer containing the Unicode title text for the current location.
    const(wchar)*     _pszTitleCur;
    ///Type: <b>PCIDLIST_ABSOLUTE</b> The PIDL of the pending target location. Once navigation is complete, this value
    ///moves to <b>_pidlCur</b>.
    ITEMIDLIST*       _pidlPending;
    ///Type: <b>IShellView*</b> The IShellView of the pending target location. Once navigation is complete, this value
    ///moves to <b>_psv</b>.
    IShellView        _psvPending;
    ///Type: <b>IShellFolder*</b> The IShellFolder of the pending target location. Once navigation is complete, this
    ///value moves to <b>_psf</b>.
    IShellFolder      _psfPending;
    ///Type: <b>HWND</b> A handle to the pending target location's view window. Once navigation is complete, this value
    ///moves to <b>_hwndView</b>.
    HWND              _hwndViewPending;
    ///Type: <b>LPWSTR</b> A pointer to a buffer containing the Unicode title text for the pending target location. Once
    ///navigation is complete, this value moves to <b>_pszTitleCur</b>.
    const(wchar)*     _pszTitlePending;
    ///Type: <b>BOOL</b> A value of type <b>BOOL</b> that indicates whether the browser is hosting folder content or web
    ///content.
    BOOL              _fIsViewMSHTML;
    ///Type: <b>BOOL</b> A value of type <b>BOOL</b> that indicates whether there is a privacy concern with the
    ///browser's content.
    BOOL              _fPrivacyImpacted;
    ///Type: <b>CLSID</b>
    GUID              _clsidView;
    ///Type: <b>CLSID</b>
    GUID              _clsidViewPending;
    ///Type: <b>HWND</b>
    HWND              _hwndFrame;
}

///Contains protected members of the base class. <b>BASEBROWSERDATA</b> defines the browser state and is used with
///IBrowserService2::GetBaseBrowserData and IBrowserService2::PutBaseBrowserData.
struct BASEBROWSERDATALH
{
    ///Type: <b>HWND</b> The handle of the browser's top-level window.
    HWND              _hwnd;
    ///Type: <b>ITravelLog*</b> A pointer to the browser's ITravelLog.
    ITravelLog        _ptl;
    ///Type: <b>IHlinkFrame*</b> A pointer to the browser's IHlinkFrame. <div class="alert"><b>Note</b> This member is
    ///only valid on first navigation from an hlink element-compatible application such as Word.</div> <div> </div>
    IHlinkFrame       _phlf;
    ///Type: <b>IWebBrowser2*</b> A pointer to the browser's IWebBrowser2 object.
    IWebBrowser2      _pautoWB2;
    ///Type: <b>IExpDispSupport*</b> A pointer to the browser's IExpDispSupport object.
    IExpDispSupport   _pautoEDS;
    ///Type: <b>IShellService*</b> A pointer to the browser's IShellService object.
    IShellService     _pautoSS;
    ///Type: <b>int</b> One of the following values to indicate the security lock icon.
    int               _eSecureLockIcon;
    uint              _bitfield104;
    ///Type: <b>UINT</b> The browser view is in an activated state.
    uint              _uActivateState;
    ITEMIDLIST*       _pidlViewState;
    ///Type: <b>IOleCommandTarget*</b> A cached pointer to the IOleCommandTarget object associated with the IShellFolder
    ///object pointed to by <b>_psv</b>.
    IOleCommandTarget _pctView;
    ///Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL of the current navigated location of the browser. This value is the same
    ///retrieved by IBrowserService::GetPidl.
    ITEMIDLIST*       _pidlCur;
    ///Type: <b>IShellView*</b> A pointer to the IShellView of the current location. This <b>IShellView</b> is bound to
    ///<b>_pidlCur</b> through IShellFolder::CreateViewObject.
    IShellView        _psv;
    ///Type: <b>IShellFolder*</b> A pointer to the IShellFolder of the current location. This <b>IShellFolder</b> is
    ///bound to <b>_pidlCur</b>.
    IShellFolder      _psf;
    ///Type: <b>HWND</b> A handle to the window returned by _psv->CreateViewWindow.
    HWND              _hwndView;
    ///Type: <b>LPWSTR</b> A pointer to a buffer containing the Unicode title text for the current location.
    const(wchar)*     _pszTitleCur;
    ///Type: <b>PCIDLIST_ABSOLUTE</b> The PIDL of the pending target location. Once navigation is complete, this value
    ///moves to <b>_pidlCur</b>.
    ITEMIDLIST*       _pidlPending;
    ///Type: <b>IShellView*</b> The IShellView of the pending target location. Once navigation is complete, this value
    ///moves to <b>_psv</b>.
    IShellView        _psvPending;
    ///Type: <b>IShellFolder*</b> The IShellFolder of the pending target location. Once navigation is complete, this
    ///value moves to <b>_psf</b>.
    IShellFolder      _psfPending;
    ///Type: <b>HWND</b> A handle to the pending target location's view window. Once navigation is complete, this value
    ///moves to <b>_hwndView</b>.
    HWND              _hwndViewPending;
    ///Type: <b>LPWSTR</b> A pointer to a buffer containing the Unicode title text for the pending target location. Once
    ///navigation is complete, this value moves to <b>_pszTitleCur</b>.
    const(wchar)*     _pszTitlePending;
    ///Type: <b>BOOL</b> A value of type <b>BOOL</b> that indicates whether the browser is hosting folder content or web
    ///content.
    BOOL              _fIsViewMSHTML;
    ///Type: <b>BOOL</b> A value of type <b>BOOL</b> that indicates whether there is a privacy concern with the
    ///browser's content.
    BOOL              _fPrivacyImpacted;
    ///Type: <b>CLSID</b>
    GUID              _clsidView;
    ///Type: <b>CLSID</b>
    GUID              _clsidViewPending;
    ///Type: <b>HWND</b>
    HWND              _hwndFrame;
    ///Type: <b>LONG</b> <b>Windows Vista with Service Pack 1 (SP1) and later or Windows Internet Explorer 7 and later
    ///only</b>. 0 if the phishing filter is off; 1 if it is on.
    int               _lPhishingFilterStatus;
}

///<p class="CCE_Message">[<b>FOLDERSETDATA</b> may be altered or unavailable in subsequent versions of the operating
///system or product.] Deprecated. Data used in IBrowserService2::GetFolderSetData.
struct FOLDERSETDATA
{
    ///Type: <b>FOLDERSETTINGS</b> The FOLDERSETTINGS structure containing folder view informtion.
    FOLDERSETTINGS _fs;
    ///Type: <b>SHELLVIEWID</b> The last view used for this folder, used as a suggestion for this visit.
    GUID           _vidRestore;
    ///Type: <b>DWORD</b> One of the following values indicating the priority used in choosing the view, listed from
    ///highest priority to lowest.
    uint           _dwViewPriority;
}

///Deprecated. Data used in IBrowserService2::_GetToolbarItem, IBrowserService2::v_MayGetNextToolbarFocus, and
///IBrowserService2::_SetFocus to define a toolbar item.
struct TOOLBARITEM
{
    ///Type: <b>IDockingWindow*</b> The IDockingWindow of the item's particular toolbar.
    IDockingWindow ptbar;
    ///Type: <b>BORDERWIDTHS</b> A BORDERWIDTHS structure that contains the dimensions of the item, including its
    ///borders.
    RECT           rcBorderTool;
    ///Type: <b>LPWSTR</b> A pointer to a buffer that contains the name of the toolbar item as a Unicode string.
    const(wchar)*  pwszItem;
    ///Type: <b>BOOL</b> <b>TRUE</b> if the toolbar item is currently visible; otherwise, <b>FALSE</b>.
    BOOL           fShow;
    ptrdiff_t      hMon;
}

///Contains resource information and an application-defined value for a dialog box supported by a Control Panel
///application. The CPlApplet function of the Control Panel application returns this information to the Control Panel in
///response to a CPL_INQUIRE message.
struct CPLINFO
{
align (1):
    ///Type: <b>int</b> The resource identifier of the icon that represents the dialog box.
    int       idIcon;
    ///Type: <b>int</b> The resource identifier of the string containing the short name for the dialog box. This name is
    ///intended to be displayed below the icon.
    int       idName;
    ///Type: <b>int</b> The resource identifier of the string containing the description for the dialog box that is
    ///intended to be displayed when the application icon is selected.
    int       idInfo;
    ///Type: <b>LONG_PTR</b> A pointer to data defined by the application. When the Control Panel sends the CPL_DBLCLK
    ///and CPL_STOP messages, it passes this value back to your application.
    ptrdiff_t lData;
}

///Contains resource information and an application-defined value for a dialog box supported by a Control Panel
///application.
struct NEWCPLINFOA
{
align (1):
    ///Type: <b>DWORD</b> The length of the structure, in bytes.
    uint      dwSize;
    ///Type: <b>DWORD</b> This member is ignored.
    uint      dwFlags;
    ///Type: <b>DWORD</b> This member is ignored.
    uint      dwHelpContext;
    ///Type: <b>LONG_PTR</b> A pointer to data defined by the application. When the Control Panel sends the CPL_DBLCLK
    ///and CPL_STOP messages, it passes this value back to your application.
    ptrdiff_t lData;
    ///Type: <b>HICON</b> The identifier of the icon that represents the dialog box. This icon is intended to be
    ///displayed by the application that controls the Control Panel application.
    HICON     hIcon;
    ///Type: <b>TCHAR[32]</b> A null-terminated string that contains the dialog box name. The name is intended to be
    ///displayed below the icon.
    byte[32]  szName;
    ///Type: <b>TCHAR[64]</b> A null-terminated string containing the dialog box description. The description is
    ///intended to be displayed when the icon for the dialog box is selected.
    byte[64]  szInfo;
    ///Type: <b>TCHAR[128]</b> This member is ignored.
    byte[128] szHelpFile;
}

///Contains resource information and an application-defined value for a dialog box supported by a Control Panel
///application.
struct NEWCPLINFOW
{
align (1):
    ///Type: <b>DWORD</b> The length of the structure, in bytes.
    uint        dwSize;
    ///Type: <b>DWORD</b> This member is ignored.
    uint        dwFlags;
    ///Type: <b>DWORD</b> This member is ignored.
    uint        dwHelpContext;
    ///Type: <b>LONG_PTR</b> A pointer to data defined by the application. When the Control Panel sends the CPL_DBLCLK
    ///and CPL_STOP messages, it passes this value back to your application.
    ptrdiff_t   lData;
    ///Type: <b>HICON</b> The identifier of the icon that represents the dialog box. This icon is intended to be
    ///displayed by the application that controls the Control Panel application.
    HICON       hIcon;
    ///Type: <b>TCHAR[32]</b> A null-terminated string that contains the dialog box name. The name is intended to be
    ///displayed below the icon.
    ushort[32]  szName;
    ///Type: <b>TCHAR[64]</b> A null-terminated string containing the dialog box description. The description is
    ///intended to be displayed when the icon for the dialog box is selected.
    ushort[64]  szInfo;
    ///Type: <b>TCHAR[128]</b> This member is ignored.
    ushort[128] szHelpFile;
}

///Contains information used when loading or unloading a user profile.
struct PROFILEINFOA
{
    ///Type: <b>DWORD</b> The size of this structure, in bytes.
    uint         dwSize;
    ///Type: <b>DWORD</b> This member can be one of the following flags:
    uint         dwFlags;
    ///Type: <b>LPTSTR</b> A pointer to the name of the user. This member is used as the base name of the directory in
    ///which to store a new profile.
    const(char)* lpUserName;
    ///Type: <b>LPTSTR</b> A pointer to the roaming user profile path. If the user does not have a roaming profile, this
    ///member can be <b>NULL</b>. To retrieve the user's roaming profile path, call the NetUserGetInfo function,
    ///specifying information level 3 or 4. For more information, see Remarks.
    const(char)* lpProfilePath;
    ///Type: <b>LPTSTR</b> A pointer to the default user profile path. This member can be <b>NULL</b>.
    const(char)* lpDefaultPath;
    ///Type: <b>LPTSTR</b> A pointer to the name of the validating domain controller, in NetBIOS format.
    const(char)* lpServerName;
    ///Type: <b>LPTSTR</b> Not used, set to <b>NULL</b>.
    const(char)* lpPolicyPath;
    ///Type: <b>HANDLE</b> A handle to the <b>HKEY_CURRENT_USER</b> registry subtree. For more information, see Remarks.
    HANDLE       hProfile;
}

///Contains information used when loading or unloading a user profile.
struct PROFILEINFOW
{
    ///Type: <b>DWORD</b> The size of this structure, in bytes.
    uint          dwSize;
    ///Type: <b>DWORD</b> This member can be one of the following flags:
    uint          dwFlags;
    ///Type: <b>LPTSTR</b> A pointer to the name of the user. This member is used as the base name of the directory in
    ///which to store a new profile.
    const(wchar)* lpUserName;
    ///Type: <b>LPTSTR</b> A pointer to the roaming user profile path. If the user does not have a roaming profile, this
    ///member can be <b>NULL</b>. To retrieve the user's roaming profile path, call the NetUserGetInfo function,
    ///specifying information level 3 or 4. For more information, see Remarks.
    const(wchar)* lpProfilePath;
    ///Type: <b>LPTSTR</b> A pointer to the default user profile path. This member can be <b>NULL</b>.
    const(wchar)* lpDefaultPath;
    ///Type: <b>LPTSTR</b> A pointer to the name of the validating domain controller, in NetBIOS format.
    const(wchar)* lpServerName;
    ///Type: <b>LPTSTR</b> Not used, set to <b>NULL</b>.
    const(wchar)* lpPolicyPath;
    ///Type: <b>HANDLE</b> A handle to the <b>HKEY_CURRENT_USER</b> registry subtree. For more information, see Remarks.
    HANDLE        hProfile;
}

struct urlinvokecommandinfoA
{
    uint         dwcbSize;
    uint         dwFlags;
    HWND         hwndParent;
    const(char)* pcszVerb;
}

struct urlinvokecommandinfoW
{
    uint          dwcbSize;
    uint          dwFlags;
    HWND          hwndParent;
    const(wchar)* pcszVerb;
}

struct _APPSTATE_REGISTRATION
{
}

struct _APPCONSTRAIN_REGISTRATION
{
}

struct __MIDL___MIDL_itf_dimm_0000_0000_0012
{
    HWND             hWnd;
    BOOL             fOpen;
    POINT            ptStatusWndPos;
    POINT            ptSoftKbdPos;
    uint             fdwConversion;
    uint             fdwSentence;
    union lfFont
    {
        LOGFONTA A;
        LOGFONTW W;
    }
    COMPOSITIONFORM  cfCompForm;
    CANDIDATEFORM[4] cfCandForm;
    HIMCC__*         hCompStr;
    HIMCC__*         hCandInfo;
    HIMCC__*         hGuideLine;
    HIMCC__*         hPrivate;
    uint             dwNumMsgBuf;
    HIMCC__*         hMsgBuf;
    uint             fdwInit;
    uint[3]          dwReserve;
}

struct __MIDL___MIDL_itf_dimm_0000_0000_0014
{
    uint dwPrivateDataSize;
    uint fdwProperty;
    uint fdwConversionCaps;
    uint fdwSentenceCaps;
    uint fdwUICaps;
    uint fdwSCSCaps;
    uint fdwSelectCaps;
}

///Contains information that describes a network address.
struct NC_ADDRESS
{
    ///Type: <b>NET_ADDRESS_INFO*</b> A pointer to a NET_ADDRESS_INFO structure that describes the network address,
    ///either a named address or an IP address.
    NET_ADDRESS_INFO* pAddrInfo;
    ///Type: <b>USHORT</b> The network port number, if the address described by <b>pAddrInfo</b> is an IP address.
    ushort            PortNumber;
    ///Type: <b>BYTE</b> The prefix length corresponding to the address, if the address described by <b>pAddrInfo</b> is
    ///an IP address.
    ubyte             PrefixLength;
}

///A range of memory of arbitrary type that represents a serialized PROPVARIANT structure. Programs should not inspect
///the contents of a <b>SERIALIZEDPROPERTYVALUE</b>; instead, they should manipulate it with the StgSerializePropVariant
///and StgDeserializePropVariant functions.
struct SERIALIZEDPROPERTYVALUE
{
    ///Type: <b>DWORD</b> Encodes type information about the serialized PROPVARIANT structure. Programs should not
    ///inspect this member directly; instead, they should use the StgDeserializePropVariant function and inspect the
    ///<b>vt</b> member of the resulting <b>PROPVARIANT</b> structure.
    uint     dwType;
    ubyte[1] rgb;
}

// Functions

///Installs or updates a window subclass callback.
///Params:
///    hWnd = Type: <b>HWND</b> The handle of the window being subclassed.
///    pfnSubclass = Type: <b>SUBCLASSPROC</b> A pointer to a window procedure. This pointer and the subclass ID uniquely identify
///                  this subclass callback. For the callback function prototype, see SUBCLASSPROC.
///    uIdSubclass = Type: <b>UINT_PTR</b> The subclass ID. This ID together with the subclass procedure uniquely identify a subclass.
///                  To remove a subclass, pass the subclass procedure and this value to the RemoveWindowSubclass function. This value
///                  is passed to the subclass procedure in the uIdSubclass parameter.
///    dwRefData = Type: <b>DWORD_PTR</b> <b>DWORD_PTR</b> to reference data. The meaning of this value is determined by the calling
///                application. This value is passed to the subclass procedure in the dwRefData parameter. A different dwRefData is
///                associated with each combination of window handle, subclass procedure and uIdSubclass.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if the subclass callback was successfully installed; otherwise, <b>FALSE</b>.
///    
@DllImport("COMCTL32")
BOOL SetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, size_t uIdSubclass, size_t dwRefData);

///Retrieves the reference data for the specified window subclass callback.
///Params:
///    hWnd = Type: <b>HWND</b> The handle of the window being subclassed.
///    pfnSubclass = Type: <b>SUBCLASSPROC</b> A pointer to a window procedure. This pointer and the subclass ID uniquely identify
///                  this subclass callback.
///    uIdSubclass = Type: <b>UINT_PTR</b> <b>UINT_PTR</b> subclass ID. This ID and the callback pointer uniquely identify this
///                  subclass callback. Note: On 64-bit versions of Windows this is a 64-bit value.
///    pdwRefData = Type: <b>DWORD_PTR*</b> A pointer to a <b>DWORD</b> which will return the reference data. Note: On 64-bit
///                 versions of Windows, pointers are 64-bit values.
///Returns:
///    Type: <b>BOOL</b> <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> The subclass callback was successfully installed. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>FALSE</b></dt> </dl> </td> <td width="60%"> The subclass callback was not
///    installed. </td> </tr> </table>
///    
@DllImport("COMCTL32")
BOOL GetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, size_t uIdSubclass, size_t* pdwRefData);

///Removes a subclass callback from a window.
///Params:
///    hWnd = Type: <b>HWND</b> The handle of the window being subclassed.
///    pfnSubclass = Type: <b>SUBCLASSPROC</b> A pointer to a window procedure. This pointer and the subclass ID uniquely identify
///                  this subclass callback. For the callback function prototype, see SUBCLASSPROC.
///    uIdSubclass = Type: <b>UINT_PTR</b> The <b>UINT_PTR</b> subclass ID. This ID and the callback pointer uniquely identify this
///                  subclass callback. Note: On 64-bit versions of Windows this is a 64-bit value.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if the subclass callback was successfully removed; otherwise, <b>FALSE</b>.
///    
@DllImport("COMCTL32")
BOOL RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, size_t uIdSubclass);

///Calls the next handler in a window's subclass chain. The last handler in the subclass chain calls the original window
///procedure for the window.
///Params:
///    hWnd = Type: <b>HWND</b> A handle to the window being subclassed.
///    uMsg = Type: <b>UINT</b> A value of type unsigned <b>int</b> that specifies a window message.
///    wParam = Type: <b>WPARAM</b> Specifies additional message information. The contents of this parameter depend on the value
///             of the window message.
///    lParam = Type: <b>LPARAM</b> Specifies additional message information. The contents of this parameter depend on the value
///             of the window message. Note: On 64-bit versions of Windows LPARAM is a 64-bit value.
///Returns:
///    Type: <b>LRESULT</b> The returned value is specific to the message sent. This value should be ignored.
///    
@DllImport("COMCTL32")
LRESULT DefSubclassProc(HWND hWnd, uint uMsg, WPARAM wParam, LPARAM lParam);

///Associates a Help context identifier with the specified window.
///Params:
///    arg1 = Type: <b>HWND</b> A handle to the window with which to associate the Help context identifier.
///    arg2 = Type: <b>DWORD</b> The Help context identifier.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise. To retrieve extended error information, call
///    GetLastError.
///    
@DllImport("USER32")
BOOL SetWindowContextHelpId(HWND param0, uint param1);

///Retrieves the Help context identifier, if any, associated with the specified window.
///Params:
///    Arg1 = Type: <b>HWND</b> A handle to the window for which the Help context identifier is to be retrieved.
///Returns:
///    Type: <b>DWORD</b> Returns the Help context identifier if the window has one, or zero otherwise.
///    
@DllImport("USER32")
uint GetWindowContextHelpId(HWND param0);

///Associates a Help context identifier with a menu.
///Params:
///    arg1 = Type: <b>HMENU</b> A handle to the menu with which to associate the Help context identifier.
///    arg2 = Type: <b>DWORD</b> The help context identifier.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise. To retrieve extended error information, call
///    GetLastError.
///    
@DllImport("USER32")
BOOL SetMenuContextHelpId(HMENU param0, uint param1);

///Retrieves the Help context identifier associated with the specified menu.
///Params:
///    Arg1 = Type: <b>HMENU</b> A handle to the menu for which the Help context identifier is to be retrieved.
///Returns:
///    Type: <b>DWORD</b> Returns the Help context identifier if the menu has one, or zero otherwise.
///    
@DllImport("USER32")
uint GetMenuContextHelpId(HMENU param0);

///Launches Windows Help (Winhelp.exe) and passes additional data that indicates the nature of the help requested by the
///application.
///Params:
///    hWndMain = Type: <b>HWND</b> A handle to the window requesting help. The <b>WinHelp</b> function uses this handle to keep
///               track of which applications have requested help. If the <i>uCommand</i> parameter specifies
///               <b>HELP_CONTEXTMENU</b> or <b>HELP_WM_HELP</b>, <i>hWndMain</i> identifies the control requesting help.
///    lpszHelp = Type: <b>LPCTSTR</b> The address of a null-terminated string containing the path, if necessary, and the name of
///               the Help file that <b>WinHelp</b> is to display. The file name can be followed by an angle bracket (&gt;) and the
///               name of a secondary window if the topic is to be displayed in a secondary window rather than in the primary
///               window. You must define the name of the secondary window in the [WINDOWS] section of the Help project (.hpj)
///               file.
///    uCommand = Type: <b>UINT</b> The type of help requested. For a list of possible values and how they affect the value to
///               place in the <i>dwData</i> parameter, see the Remarks section.
///    dwData = Type: <b>ULONG_PTR</b> Additional data. The value used depends on the value of the <i>uCommand</i> parameter. For
///             a list of possible <i>dwData</i> values, see the Remarks section.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise. To retrieve extended error information, call
///    GetLastError.
///    
@DllImport("USER32")
BOOL WinHelpA(HWND hWndMain, const(char)* lpszHelp, uint uCommand, size_t dwData);

///Launches Windows Help (Winhelp.exe) and passes additional data that indicates the nature of the help requested by the
///application.
///Params:
///    hWndMain = Type: <b>HWND</b> A handle to the window requesting help. The <b>WinHelp</b> function uses this handle to keep
///               track of which applications have requested help. If the <i>uCommand</i> parameter specifies
///               <b>HELP_CONTEXTMENU</b> or <b>HELP_WM_HELP</b>, <i>hWndMain</i> identifies the control requesting help.
///    lpszHelp = Type: <b>LPCTSTR</b> The address of a null-terminated string containing the path, if necessary, and the name of
///               the Help file that <b>WinHelp</b> is to display. The file name can be followed by an angle bracket (&gt;) and the
///               name of a secondary window if the topic is to be displayed in a secondary window rather than in the primary
///               window. You must define the name of the secondary window in the [WINDOWS] section of the Help project (.hpj)
///               file.
///    uCommand = Type: <b>UINT</b> The type of help requested. For a list of possible values and how they affect the value to
///               place in the <i>dwData</i> parameter, see the Remarks section.
///    dwData = Type: <b>ULONG_PTR</b> Additional data. The value used depends on the value of the <i>uCommand</i> parameter. For
///             a list of possible <i>dwData</i> values, see the Remarks section.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise. To retrieve extended error information, call
///    GetLastError.
///    
@DllImport("USER32")
BOOL WinHelpW(HWND hWndMain, const(wchar)* lpszHelp, uint uCommand, size_t dwData);

///Loads the specified user's profile. The profile can be a local user profile or a roaming user profile.
///Params:
///    hToken = Type: <b>HANDLE</b> Token for the user, which is returned by the LogonUser, CreateRestrictedToken,
///             DuplicateToken, OpenProcessToken, or OpenThreadToken function. The token must have <b>TOKEN_QUERY</b>,
///             <b>TOKEN_IMPERSONATE</b>, and <b>TOKEN_DUPLICATE</b> access. For more information, see Access Rights for
///             Access-Token Objects.
///    lpProfileInfo = Type: <b>LPPROFILEINFO</b> Pointer to a PROFILEINFO structure. <b>LoadUserProfile</b> fails and returns
///                    <b>ERROR_INVALID_PARAMETER</b> if the <b>dwSize</b> member of the structure is not set to
///                    <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>. For more information, see
///                    Remarks.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError. The function fails and returns ERROR_INVALID_PARAMETER if the <b>dwSize</b> member of the structure
///    at <i>lpProfileInfo</i> is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is
///    <b>NULL</b>.
///    
@DllImport("USERENV")
BOOL LoadUserProfileA(HANDLE hToken, PROFILEINFOA* lpProfileInfo);

///Loads the specified user's profile. The profile can be a local user profile or a roaming user profile.
///Params:
///    hToken = Type: <b>HANDLE</b> Token for the user, which is returned by the LogonUser, CreateRestrictedToken,
///             DuplicateToken, OpenProcessToken, or OpenThreadToken function. The token must have <b>TOKEN_QUERY</b>,
///             <b>TOKEN_IMPERSONATE</b>, and <b>TOKEN_DUPLICATE</b> access. For more information, see Access Rights for
///             Access-Token Objects.
///    lpProfileInfo = Type: <b>LPPROFILEINFO</b> Pointer to a PROFILEINFO structure. <b>LoadUserProfile</b> fails and returns
///                    <b>ERROR_INVALID_PARAMETER</b> if the <b>dwSize</b> member of the structure is not set to
///                    <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>. For more information, see
///                    Remarks.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError. The function fails and returns ERROR_INVALID_PARAMETER if the <b>dwSize</b> member of the structure
///    at <i>lpProfileInfo</i> is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is
///    <b>NULL</b>.
///    
@DllImport("USERENV")
BOOL LoadUserProfileW(HANDLE hToken, PROFILEINFOW* lpProfileInfo);

///Unloads a user's profile that was loaded by the LoadUserProfile function. The caller must have administrative
///privileges on the computer. For more information, see the Remarks section of the <b>LoadUserProfile</b> function.
///Params:
///    hToken = Type: <b>HANDLE</b> Token for the user, returned from the LogonUser, CreateRestrictedToken, DuplicateToken,
///             OpenProcessToken, or OpenThreadToken function. The token must have <b>TOKEN_IMPERSONATE</b> and
///             <b>TOKEN_DUPLICATE</b> access. For more information, see Access Rights for Access-Token Objects.
///    hProfile = Type: <b>HANDLE</b> Handle to the registry key. This value is the <b>hProfile</b> member of the PROFILEINFO
///               structure. For more information see the Remarks section of LoadUserProfile and Registry Key Security and Access
///               Rights.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL UnloadUserProfile(HANDLE hToken, HANDLE hProfile);

///Retrieves the path to the root directory where user profiles are stored.
///Params:
///    lpProfileDir = Type: <b>LPTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the path to the
///                   profiles directory. Set this value to <b>NULL</b> to determine the required size of the buffer.
///    lpcchSize = Type: <b>LPDWORD</b> Specifies the size of the <i>lpProfilesDir</i> buffer, in <b>TCHARs</b>. If the buffer
///                specified by <i>lpProfilesDir</i> is not large enough or <i>lpProfilesDir</i> is <b>NULL</b>, the function fails
///                and this parameter receives the necessary buffer size, including the terminating null character.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL GetProfilesDirectoryA(const(char)* lpProfileDir, uint* lpcchSize);

///Retrieves the path to the root directory where user profiles are stored.
///Params:
///    lpProfileDir = Type: <b>LPTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the path to the
///                   profiles directory. Set this value to <b>NULL</b> to determine the required size of the buffer.
///    lpcchSize = Type: <b>LPDWORD</b> Specifies the size of the <i>lpProfilesDir</i> buffer, in <b>TCHARs</b>. If the buffer
///                specified by <i>lpProfilesDir</i> is not large enough or <i>lpProfilesDir</i> is <b>NULL</b>, the function fails
///                and this parameter receives the necessary buffer size, including the terminating null character.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL GetProfilesDirectoryW(const(wchar)* lpProfileDir, uint* lpcchSize);

///Retrieves the type of profile loaded for the current user.
///Params:
///    dwFlags = Type: <b>DWORD*</b> Pointer to a variable that receives the profile type. If the function succeeds, it sets one
///              or more of the following values:
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL GetProfileType(uint* dwFlags);

///Deletes the user profile and all user-related settings from the specified computer. The caller must have
///administrative privileges to delete a user's profile.
///Params:
///    lpSidString = Type: <b>LPCTSTR</b> Pointer to a string that specifies the user SID.
///    lpProfilePath = Type: <b>LPCTSTR</b> Pointer to a string that specifies the profile path. If this parameter is <b>NULL</b>, the
///                    function obtains the path from the registry.
///    lpComputerName = Type: <b>LPCTSTR</b> Pointer to a string that specifies the name of the computer from which the profile is to be
///                     deleted. If this parameter is <b>NULL</b>, the local computer name is used. <div class="alert"><b>Note</b> As of
///                     Windows Vista, this parameter must be <b>NULL</b>. If it is not, this function fails with the error code
///                     ERROR_INVALID_PARAMETER.</div> <div> </div>
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL DeleteProfileA(const(char)* lpSidString, const(char)* lpProfilePath, const(char)* lpComputerName);

///Deletes the user profile and all user-related settings from the specified computer. The caller must have
///administrative privileges to delete a user's profile.
///Params:
///    lpSidString = Type: <b>LPCTSTR</b> Pointer to a string that specifies the user SID.
///    lpProfilePath = Type: <b>LPCTSTR</b> Pointer to a string that specifies the profile path. If this parameter is <b>NULL</b>, the
///                    function obtains the path from the registry.
///    lpComputerName = Type: <b>LPCTSTR</b> Pointer to a string that specifies the name of the computer from which the profile is to be
///                     deleted. If this parameter is <b>NULL</b>, the local computer name is used. <div class="alert"><b>Note</b> As of
///                     Windows Vista, this parameter must be <b>NULL</b>. If it is not, this function fails with the error code
///                     ERROR_INVALID_PARAMETER.</div> <div> </div>
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL DeleteProfileW(const(wchar)* lpSidString, const(wchar)* lpProfilePath, const(wchar)* lpComputerName);

///Creates a new user profile.
///Params:
///    pszUserSid = Type: <b>LPCWSTR</b> Pointer to the SID of the user as a string.
///    pszUserName = Type: <b>LPCWSTR</b> The user name of the new user. This name is used as the base name for the profile directory.
///    pszProfilePath = Type: <b>LPWSTR</b> When this function returns, contains a pointer to the full path of the profile.
///    cchProfilePath = Type: <b>DWORD</b> Size of the buffer pointed to by <i>pszProfilePath</i>, in characters.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following: <table>
///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
///    </dl> </td> <td width="60%"> The caller does not have a sufficient permission level to create the profile. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)</b></dt> </dl> </td> <td
///    width="60%"> A profile already exists for the specified user. </td> </tr> </table>
///    
@DllImport("USERENV")
HRESULT CreateProfile(const(wchar)* pszUserSid, const(wchar)* pszUserName, const(wchar)* pszProfilePath, 
                      uint cchProfilePath);

///Retrieves the path to the root of the default user's profile.
///Params:
///    lpProfileDir = Type: <b>LPTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the path to the
///                   default user's profile directory. Set this value to <b>NULL</b> to determine the required size of the buffer.
///    lpcchSize = Type: <b>LPDWORD</b> Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>. If the buffer
///                specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails
///                and this parameter receives the necessary buffer size, including the terminating null character.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL GetDefaultUserProfileDirectoryA(const(char)* lpProfileDir, uint* lpcchSize);

///Retrieves the path to the root of the default user's profile.
///Params:
///    lpProfileDir = Type: <b>LPTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the path to the
///                   default user's profile directory. Set this value to <b>NULL</b> to determine the required size of the buffer.
///    lpcchSize = Type: <b>LPDWORD</b> Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>. If the buffer
///                specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails
///                and this parameter receives the necessary buffer size, including the terminating null character.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL GetDefaultUserProfileDirectoryW(const(wchar)* lpProfileDir, uint* lpcchSize);

///Retrieves the path to the root of the directory that contains program data shared by all users.
///Params:
///    lpProfileDir = Type: <b>LPTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the path. Set
///                   this value to <b>NULL</b> to determine the required size of the buffer, including the terminating null character.
///    lpcchSize = Type: <b>LPDWORD</b> A pointer to the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>. If the buffer
///                specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails
///                and this parameter receives the necessary buffer size, including the terminating null character.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL GetAllUsersProfileDirectoryA(const(char)* lpProfileDir, uint* lpcchSize);

///Retrieves the path to the root of the directory that contains program data shared by all users.
///Params:
///    lpProfileDir = Type: <b>LPTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the path. Set
///                   this value to <b>NULL</b> to determine the required size of the buffer, including the terminating null character.
///    lpcchSize = Type: <b>LPDWORD</b> A pointer to the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>. If the buffer
///                specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails
///                and this parameter receives the necessary buffer size, including the terminating null character.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL GetAllUsersProfileDirectoryW(const(wchar)* lpProfileDir, uint* lpcchSize);

///Retrieves the path to the root directory of the specified user's profile.
///Params:
///    hToken = Type: <b>HANDLE</b> A token for the user, which is returned by the LogonUser, CreateRestrictedToken,
///             DuplicateToken, OpenProcessToken, or OpenThreadToken function. The token must have TOKEN_QUERY access. For more
///             information, see Access Rights for Access-Token Objects.
///    lpProfileDir = Type: <b>LPTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the path to the
///                   specified user's profile directory.
///    lpcchSize = Type: <b>LPDWORD</b> Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>. If the buffer
///                specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails
///                and this parameter receives the necessary buffer size, including the terminating null character.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL GetUserProfileDirectoryA(HANDLE hToken, const(char)* lpProfileDir, uint* lpcchSize);

///Retrieves the path to the root directory of the specified user's profile.
///Params:
///    hToken = Type: <b>HANDLE</b> A token for the user, which is returned by the LogonUser, CreateRestrictedToken,
///             DuplicateToken, OpenProcessToken, or OpenThreadToken function. The token must have TOKEN_QUERY access. For more
///             information, see Access Rights for Access-Token Objects.
///    lpProfileDir = Type: <b>LPTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the path to the
///                   specified user's profile directory.
///    lpcchSize = Type: <b>LPDWORD</b> Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>. If the buffer
///                specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails
///                and this parameter receives the necessary buffer size, including the terminating null character.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL GetUserProfileDirectoryW(HANDLE hToken, const(wchar)* lpProfileDir, uint* lpcchSize);

///Retrieves the environment variables for the specified user. This block can then be passed to the CreateProcessAsUser
///function.
///Params:
///    lpEnvironment = Type: <b>LPVOID*</b> When this function returns, receives a pointer to the new environment block. The environment
///                    block is an array of null-terminated Unicode strings. The list ends with two nulls (\0\0).
///    hToken = Type: <b>HANDLE</b> Token for the user, returned from the LogonUser function. If this is a primary token, the
///             token must have <b>TOKEN_QUERY</b> and <b>TOKEN_DUPLICATE</b> access. If the token is an impersonation token, it
///             must have <b>TOKEN_QUERY</b> access. For more information, see Access Rights for Access-Token Objects. If this
///             parameter is <b>NULL</b>, the returned environment block contains system variables only.
///    bInherit = Type: <b>BOOL</b> Specifies whether to inherit from the current process' environment. If this value is
///               <b>TRUE</b>, the process inherits the current process' environment. If this value is <b>FALSE</b>, the process
///               does not inherit the current process' environment.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL CreateEnvironmentBlock(void** lpEnvironment, HANDLE hToken, BOOL bInherit);

///Frees environment variables created by the CreateEnvironmentBlock function.
///Params:
///    lpEnvironment = Type: <b>LPVOID</b> Pointer to the environment block created by CreateEnvironmentBlock. The environment block is
///                    an array of null-terminated Unicode strings. The list ends with two nulls (\0\0).
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL DestroyEnvironmentBlock(void* lpEnvironment);

///Expands the source string by using the environment block established for the specified user.
///Params:
///    hToken = Type: <b>HANDLE</b> Token for the user, returned from the LogonUser, CreateRestrictedToken, DuplicateToken,
///             OpenProcessToken, or OpenThreadToken function. The token must have TOKEN_IMPERSONATE and TOKEN_QUERY access. In
///             addition, as of Windows 7 the token must also have TOKEN_DUPLICATE access. For more information, see Access
///             Rights for Access-Token Objects. If <i>hToken</i> is <b>NULL</b>, the environment block contains system variables
///             only.
///    lpSrc = Type: <b>LPCTSTR</b> Pointer to the null-terminated source string to be expanded.
///    lpDest = Type: <b>LPTSTR</b> Pointer to a buffer that receives the expanded strings.
///    dwSize = Type: <b>DWORD</b> Specifies the size of the <i>lpDest</i> buffer, in <b>TCHARs</b>.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL ExpandEnvironmentStringsForUserA(HANDLE hToken, const(char)* lpSrc, const(char)* lpDest, uint dwSize);

///Expands the source string by using the environment block established for the specified user.
///Params:
///    hToken = Type: <b>HANDLE</b> Token for the user, returned from the LogonUser, CreateRestrictedToken, DuplicateToken,
///             OpenProcessToken, or OpenThreadToken function. The token must have TOKEN_IMPERSONATE and TOKEN_QUERY access. In
///             addition, as of Windows 7 the token must also have TOKEN_DUPLICATE access. For more information, see Access
///             Rights for Access-Token Objects. If <i>hToken</i> is <b>NULL</b>, the environment block contains system variables
///             only.
///    lpSrc = Type: <b>LPCTSTR</b> Pointer to the null-terminated source string to be expanded.
///    lpDest = Type: <b>LPTSTR</b> Pointer to a buffer that receives the expanded strings.
///    dwSize = Type: <b>DWORD</b> Specifies the size of the <i>lpDest</i> buffer, in <b>TCHARs</b>.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("USERENV")
BOOL ExpandEnvironmentStringsForUserW(HANDLE hToken, const(wchar)* lpSrc, const(wchar)* lpDest, uint dwSize);

///Creates a per-user, per-app profile for Windows Store apps.
///Params:
///    pszAppContainerName = The name of the app container. To ensure uniqueness, it is recommended that this string contains the app name as
///                          well as the publisher. This string can be up to 64 characters in length. Further, it must fit into the pattern
///                          described by the regular expression "[-_. A-Za-z0-9]+".
///    pszDisplayName = The display name. This string can be up to 512 characters in length.
///    pszDescription = A description for the app container. This string can be up to 2048 characters in length.
///    pCapabilities = The SIDs that define the requested capabilities.
///    dwCapabilityCount = The number of SIDs in <i>pCapabilities</i>.
///    ppSidAppContainerSid = The SID for the profile. This buffer must be freed using the FreeSid function.
///Returns:
///    If this function succeeds, it returns a standard HRESULT code, including the following: <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
///    The data store was created successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
///    </dl> </td> <td width="60%"> The caller does not have permission to create the profile. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)</b></dt> </dl> </td> <td width="60%"> The
///    application data store already exists. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
///    </td> <td width="60%"> The container name is <b>NULL</b>, or the container name, the display name, or the
///    description strings exceed their specified respective limits for length. </td> </tr> </table>
///    
@DllImport("USERENV")
HRESULT CreateAppContainerProfile(const(wchar)* pszAppContainerName, const(wchar)* pszDisplayName, 
                                  const(wchar)* pszDescription, char* pCapabilities, uint dwCapabilityCount, 
                                  void** ppSidAppContainerSid);

///Deletes the specified per-user, per-app profile.<div class="alert"><b>Note</b> Deleting a non-existent profile
///returns success.</div> <div> </div>
///Params:
///    pszAppContainerName = The name given to the profile in the call to the CreateAppContainerProfile function. This string is at most 64
///                          characters in length, and fits into the pattern described by the regular expression "[-_. A-Za-z0-9]+".
///Returns:
///    If this function succeeds, it returns a standard HRESULT code, including the following: <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED)</b></dt> </dl> </td> <td width="60%"> If the method is called from
///    within an app container. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
///    The profile was deleted successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
///    </td> <td width="60%"> If the container name is <b>NULL</b>, or if it exceeds its specified limit for length.
///    </td> </tr> </table>
///    
@DllImport("USERENV")
HRESULT DeleteAppContainerProfile(const(wchar)* pszAppContainerName);

///Gets the location of the registry storage associated with an app container.
///Params:
///    desiredAccess = Type: <b>REGSAM</b> The desired registry access.
///    phAppContainerKey = Type: <b>PHKEY</b> A pointer to an HKEY that, when this function returns successfully, receives the registry
///                        storage location for the current profile.
///Returns:
///    Type: <b>HRESULT</b> This function returns an <b>HRESULT</b> code, including but not limited to the following:
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
///    </dl> </td> <td width="60%"> The operation completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The caller is not running as or impersonating a user
///    who can access this profile. </td> </tr> </table>
///    
@DllImport("USERENV")
HRESULT GetAppContainerRegistryLocation(uint desiredAccess, HKEY* phAppContainerKey);

///Gets the path of the local app data folder for the specified app container.
///Params:
///    pszAppContainerSid = A pointer to the SID of the app container.
///    ppszPath = The address of a pointer to a string that, when this function returns successfully, receives the path of the
///               local folder. It is the responsibility of the caller to free this string when it is no longer needed by calling
///               the CoTaskMemFree function.
///Returns:
///    This function returns an <b>HRESULT</b> code, including but not limited to the following: <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
///    The operation completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
///    </td> <td width="60%"> The <i>pszAppContainerSid</i> or <i>ppszPath</i> parameter is <b>NULL</b>. </td> </tr>
///    </table>
///    
@DllImport("USERENV")
HRESULT GetAppContainerFolderPath(const(wchar)* pszAppContainerSid, ushort** ppszPath);

///Gets the SID of the specified profile.
///Params:
///    pszAppContainerName = The name of the profile.
///    ppsidAppContainerSid = The SID for the profile. This buffer must be freed using the FreeSid function.
@DllImport("USERENV")
HRESULT DeriveAppContainerSidFromAppContainerName(const(wchar)* pszAppContainerName, void** ppsidAppContainerSid);

///<p class="CCE_Message">[DeriveRestrictedAppContainerSidFromAppContainerSidAndRestrictedName is reserved for future
///use.] DeriveRestrictedAppContainerSidFromAppContainerSidAndRestrictedName is reserved for future use.
///Params:
///    psidAppContainerSid = Reserved.
///    pszRestrictedAppContainerName = Reserved.
///    ppsidRestrictedAppContainerSid = Reserved.
@DllImport("USERENV")
HRESULT DeriveRestrictedAppContainerSidFromAppContainerSidAndRestrictedName(void* psidAppContainerSid, 
                                                                            const(wchar)* pszRestrictedAppContainerName, 
                                                                            void** ppsidRestrictedAppContainerSid);

///Parses a Unicode command line string and returns an array of pointers to the command line arguments, along with a
///count of such arguments, in a way that is similar to the standard C run-time <i>argv</i> and <i>argc</i> values.
///Params:
///    lpCmdLine = Type: <b>LPCWSTR</b> Pointer to a <b>null</b>-terminated Unicode string that contains the full command line. If
///                this parameter is an empty string the function returns the path to the current executable file.
///    pNumArgs = Type: <b>int*</b> Pointer to an <b>int</b> that receives the number of array elements returned, similar to
///               <i>argc</i>.
///Returns:
///    Type: <b>LPWSTR*</b> A pointer to an array of <b>LPWSTR</b> values, similar to <i>argv</i>. If the function
///    fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("SHELL32")
ushort** CommandLineToArgvW(const(wchar)* lpCmdLine, int* pNumArgs);

///Retrieves the names of dropped files that result from a successful drag-and-drop operation.
///Params:
///    hDrop = Type: <b>HDROP</b> Identifier of the structure that contains the file names of the dropped files.
///    iFile = Type: <b>UINT</b> Index of the file to query. If the value of this parameter is 0xFFFFFFFF, <b>DragQueryFile</b>
///            returns a count of the files dropped. If the value of this parameter is between zero and the total number of
///            files dropped, <b>DragQueryFile</b> copies the file name with the corresponding value to the buffer pointed to by
///            the <i>lpszFile</i> parameter.
///    lpszFile = Type: <b>LPTSTR</b> The address of a buffer that receives the file name of a dropped file when the function
///               returns. This file name is a null-terminated string. If this parameter is <b>NULL</b>, <b>DragQueryFile</b>
///               returns the required size, in characters, of this buffer.
///    cch = Type: <b>UINT</b> The size, in characters, of the <i>lpszFile</i> buffer.
///Returns:
///    Type: <b>UINT</b> A nonzero value indicates a successful call. When the function copies a file name to the
///    buffer, the return value is a count of the characters copied, not including the terminating null character. If
///    the index value is 0xFFFFFFFF, the return value is a count of the dropped files. Note that the index variable
///    itself returns unchanged, and therefore remains 0xFFFFFFFF. If the index value is between zero and the total
///    number of dropped files, and the <i>lpszFile</i> buffer address is <b>NULL</b>, the return value is the required
///    size, in characters, of the buffer, <i>not including</i> the terminating null character.
///    
@DllImport("SHELL32")
uint DragQueryFileA(HDROP__* hDrop, uint iFile, const(char)* lpszFile, uint cch);

///Retrieves the names of dropped files that result from a successful drag-and-drop operation.
///Params:
///    hDrop = Type: <b>HDROP</b> Identifier of the structure that contains the file names of the dropped files.
///    iFile = Type: <b>UINT</b> Index of the file to query. If the value of this parameter is 0xFFFFFFFF, <b>DragQueryFile</b>
///            returns a count of the files dropped. If the value of this parameter is between zero and the total number of
///            files dropped, <b>DragQueryFile</b> copies the file name with the corresponding value to the buffer pointed to by
///            the <i>lpszFile</i> parameter.
///    lpszFile = Type: <b>LPTSTR</b> The address of a buffer that receives the file name of a dropped file when the function
///               returns. This file name is a null-terminated string. If this parameter is <b>NULL</b>, <b>DragQueryFile</b>
///               returns the required size, in characters, of this buffer.
///    cch = Type: <b>UINT</b> The size, in characters, of the <i>lpszFile</i> buffer.
///Returns:
///    Type: <b>UINT</b> A nonzero value indicates a successful call. When the function copies a file name to the
///    buffer, the return value is a count of the characters copied, not including the terminating null character. If
///    the index value is 0xFFFFFFFF, the return value is a count of the dropped files. Note that the index variable
///    itself returns unchanged, and therefore remains 0xFFFFFFFF. If the index value is between zero and the total
///    number of dropped files, and the <i>lpszFile</i> buffer address is <b>NULL</b>, the return value is the required
///    size, in characters, of the buffer, <i>not including</i> the terminating null character.
///    
@DllImport("SHELL32")
uint DragQueryFileW(HDROP__* hDrop, uint iFile, const(wchar)* lpszFile, uint cch);

///Retrieves the position of the mouse pointer at the time a file was dropped during a drag-and-drop operation.
///Params:
///    hDrop = Type: <b>HDROP</b> Handle of the drop structure that describes the dropped file.
///    ppt = Type: <b>POINT*</b> Pointer to a POINT structure that, when this function returns successfully, receives the
///          coordinates of the mouse pointer at the time the file was dropped.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if the drop occurred in the client area of the window; otherwise <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL DragQueryPoint(HDROP__* hDrop, POINT* ppt);

///Releases memory that the system allocated for use in transferring file names to the application.
@DllImport("SHELL32")
void DragFinish(HDROP__* hDrop);

///Registers whether a window accepts dropped files.
///Params:
///    hWnd = Type: <b>HWND</b> The identifier of the window that is registering whether it will accept dropped files.
///    fAccept = Type: <b>BOOL</b> A value that indicates if the window identified by the <i>hWnd</i> parameter accepts dropped
///              files. This value is <b>TRUE</b> to accept dropped files or <b>FALSE</b> to discontinue accepting dropped files.
@DllImport("SHELL32")
void DragAcceptFiles(HWND hWnd, BOOL fAccept);

///Performs an operation on a specified file.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to the parent window used for displaying a UI or error messages. This value can be
///           <b>NULL</b> if the operation is not associated with a window.
///    lpOperation = Type: <b>LPCTSTR</b> A pointer to a <b>null</b>-terminated string, referred to in this case as a <i>verb</i>,
///                  that specifies the action to be performed. The set of available verbs depends on the particular file or folder.
///                  Generally, the actions available from an object's shortcut menu are available verbs. The following verbs are
///                  commonly used:
///    lpFile = Type: <b>LPCTSTR</b> A pointer to a <b>null</b>-terminated string that specifies the file or object on which to
///             execute the specified verb. To specify a Shell namespace object, pass the fully qualified parse name. Note that
///             not all verbs are supported on all objects. For example, not all document types support the "print" verb. If a
///             relative path is used for the <i>lpDirectory</i> parameter do not use a relative path for <i>lpFile</i>.
///    lpParameters = Type: <b>LPCTSTR</b> If <i>lpFile</i> specifies an executable file, this parameter is a pointer to a
///                   <b>null</b>-terminated string that specifies the parameters to be passed to the application. The format of this
///                   string is determined by the verb that is to be invoked. If <i>lpFile</i> specifies a document file,
///                   <i>lpParameters</i> should be <b>NULL</b>.
///    lpDirectory = Type: <b>LPCTSTR</b> A pointer to a <b>null</b>-terminated string that specifies the default (working) directory
///                  for the action. If this value is <b>NULL</b>, the current working directory is used. If a relative path is
///                  provided at <i>lpFile</i>, do not use a relative path for <i>lpDirectory</i>.
///    nShowCmd = Type: <b>INT</b> The flags that specify how an application is to be displayed when it is opened. If <i>lpFile</i>
///               specifies a document file, the flag is simply passed to the associated application. It is up to the application
///               to decide how to handle it. These values are defined in Winuser.h.
///Returns:
///    Type: <b>HINSTANCE</b> If the function succeeds, it returns a value greater than 32. If the function fails, it
///    returns an error value that indicates the cause of the failure. The return value is cast as an HINSTANCE for
///    backward compatibility with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only
///    to an <b>int</b> and compared to either 32 or the following error codes below. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> The
///    operating system is out of memory or resources. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified file was not found. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified path
///    was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_FORMAT</b></dt> </dl> </td> <td
///    width="60%"> The .exe file is invalid (non-Win32 .exe or error in .exe image). </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>SE_ERR_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> The operating system denied access to the
///    specified file. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SE_ERR_ASSOCINCOMPLETE</b></dt> </dl> </td> <td
///    width="60%"> The file name association is incomplete or invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>SE_ERR_DDEBUSY</b></dt> </dl> </td> <td width="60%"> The DDE transaction could not be completed because
///    other DDE transactions were being processed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>SE_ERR_DDEFAIL</b></dt> </dl> </td> <td width="60%"> The DDE transaction failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>SE_ERR_DDETIMEOUT</b></dt> </dl> </td> <td width="60%"> The DDE transaction could not be
///    completed because the request timed out. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>SE_ERR_DLLNOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified DLL was not found. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>SE_ERR_FNF</b></dt> </dl> </td> <td width="60%"> The specified file was not found.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SE_ERR_NOASSOC</b></dt> </dl> </td> <td width="60%"> There is no
///    application associated with the given file name extension. This error will also be returned if you attempt to
///    print a file that is not printable. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SE_ERR_OOM</b></dt> </dl> </td>
///    <td width="60%"> There was not enough memory to complete the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>SE_ERR_PNF</b></dt> </dl> </td> <td width="60%"> The specified path was not found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>SE_ERR_SHARE</b></dt> </dl> </td> <td width="60%"> A sharing violation occurred. </td>
///    </tr> </table>
///    
@DllImport("SHELL32")
HINSTANCE ShellExecuteA(HWND hwnd, const(char)* lpOperation, const(char)* lpFile, const(char)* lpParameters, 
                        const(char)* lpDirectory, int nShowCmd);

///Performs an operation on a specified file.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to the parent window used for displaying a UI or error messages. This value can be
///           <b>NULL</b> if the operation is not associated with a window.
///    lpOperation = Type: <b>LPCTSTR</b> A pointer to a <b>null</b>-terminated string, referred to in this case as a <i>verb</i>,
///                  that specifies the action to be performed. The set of available verbs depends on the particular file or folder.
///                  Generally, the actions available from an object's shortcut menu are available verbs. The following verbs are
///                  commonly used:
///    lpFile = Type: <b>LPCTSTR</b> A pointer to a <b>null</b>-terminated string that specifies the file or object on which to
///             execute the specified verb. To specify a Shell namespace object, pass the fully qualified parse name. Note that
///             not all verbs are supported on all objects. For example, not all document types support the "print" verb. If a
///             relative path is used for the <i>lpDirectory</i> parameter do not use a relative path for <i>lpFile</i>.
///    lpParameters = Type: <b>LPCTSTR</b> If <i>lpFile</i> specifies an executable file, this parameter is a pointer to a
///                   <b>null</b>-terminated string that specifies the parameters to be passed to the application. The format of this
///                   string is determined by the verb that is to be invoked. If <i>lpFile</i> specifies a document file,
///                   <i>lpParameters</i> should be <b>NULL</b>.
///    lpDirectory = Type: <b>LPCTSTR</b> A pointer to a <b>null</b>-terminated string that specifies the default (working) directory
///                  for the action. If this value is <b>NULL</b>, the current working directory is used. If a relative path is
///                  provided at <i>lpFile</i>, do not use a relative path for <i>lpDirectory</i>.
///    nShowCmd = Type: <b>INT</b> The flags that specify how an application is to be displayed when it is opened. If <i>lpFile</i>
///               specifies a document file, the flag is simply passed to the associated application. It is up to the application
///               to decide how to handle it. These values are defined in Winuser.h.
///Returns:
///    Type: <b>HINSTANCE</b> If the function succeeds, it returns a value greater than 32. If the function fails, it
///    returns an error value that indicates the cause of the failure. The return value is cast as an HINSTANCE for
///    backward compatibility with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only
///    to an <b>int</b> and compared to either 32 or the following error codes below. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> The
///    operating system is out of memory or resources. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified file was not found. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified path
///    was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_FORMAT</b></dt> </dl> </td> <td
///    width="60%"> The .exe file is invalid (non-Win32 .exe or error in .exe image). </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>SE_ERR_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> The operating system denied access to the
///    specified file. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SE_ERR_ASSOCINCOMPLETE</b></dt> </dl> </td> <td
///    width="60%"> The file name association is incomplete or invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>SE_ERR_DDEBUSY</b></dt> </dl> </td> <td width="60%"> The DDE transaction could not be completed because
///    other DDE transactions were being processed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>SE_ERR_DDEFAIL</b></dt> </dl> </td> <td width="60%"> The DDE transaction failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>SE_ERR_DDETIMEOUT</b></dt> </dl> </td> <td width="60%"> The DDE transaction could not be
///    completed because the request timed out. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>SE_ERR_DLLNOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified DLL was not found. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>SE_ERR_FNF</b></dt> </dl> </td> <td width="60%"> The specified file was not found.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SE_ERR_NOASSOC</b></dt> </dl> </td> <td width="60%"> There is no
///    application associated with the given file name extension. This error will also be returned if you attempt to
///    print a file that is not printable. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SE_ERR_OOM</b></dt> </dl> </td>
///    <td width="60%"> There was not enough memory to complete the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>SE_ERR_PNF</b></dt> </dl> </td> <td width="60%"> The specified path was not found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>SE_ERR_SHARE</b></dt> </dl> </td> <td width="60%"> A sharing violation occurred. </td>
///    </tr> </table>
///    
@DllImport("SHELL32")
HINSTANCE ShellExecuteW(HWND hwnd, const(wchar)* lpOperation, const(wchar)* lpFile, const(wchar)* lpParameters, 
                        const(wchar)* lpDirectory, int nShowCmd);

///Retrieves the name of and handle to the executable (.exe) file associated with a specific document file.
///Params:
///    lpFile = Type: <b>LPCTSTR</b> The address of a <b>null</b>-terminated string that specifies a file name. This file should
///             be a document.
///    lpDirectory = Type: <b>LPCTSTR</b> The address of a <b>null</b>-terminated string that specifies the default directory. This
///                  value can be <b>NULL</b>.
///    lpResult = Type: <b>LPTSTR</b> The address of a buffer that receives the file name of the associated executable file. This
///               file name is a <b>null</b>-terminated string that specifies the executable file started when an "open" by
///               association is run on the file specified in the <i>lpFile</i> parameter. Put simply, this is the application that
///               is launched when the document file is directly double-clicked or when <b>Open</b> is chosen from the file's
///               shortcut menu. This parameter must contain a valid non-<b>null</b> value and is assumed to be of length MAX_PATH.
///               Responsibility for validating the value is left to the programmer.
///Returns:
///    Type: <b>HINSTANCE</b> Returns a value greater than 32 if successful, or a value less than or equal to 32
///    representing an error. The following table lists possible error values. <table> <tr> <th>Return code/value</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>SE_ERR_FNF</b></dt> <dt>2</dt> </dl> </td> <td
///    width="60%"> The specified file was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SE_ERR_PNF</b></dt>
///    <dt>3</dt> </dl> </td> <td width="60%"> The specified path is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>SE_ERR_ACCESSDENIED</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> The specified file cannot be
///    accessed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SE_ERR_OOM</b></dt> <dt>8</dt> </dl> </td> <td
///    width="60%"> The system is out of memory or resources. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>SE_ERR_NOASSOC</b></dt> <dt>31</dt> </dl> </td> <td width="60%"> There is no association for the specified
///    file type with an executable file. </td> </tr> </table>
///    
@DllImport("SHELL32")
HINSTANCE FindExecutableA(const(char)* lpFile, const(char)* lpDirectory, const(char)* lpResult);

///Retrieves the name of and handle to the executable (.exe) file associated with a specific document file.
///Params:
///    lpFile = Type: <b>LPCTSTR</b> The address of a <b>null</b>-terminated string that specifies a file name. This file should
///             be a document.
///    lpDirectory = Type: <b>LPCTSTR</b> The address of a <b>null</b>-terminated string that specifies the default directory. This
///                  value can be <b>NULL</b>.
///    lpResult = Type: <b>LPTSTR</b> The address of a buffer that receives the file name of the associated executable file. This
///               file name is a <b>null</b>-terminated string that specifies the executable file started when an "open" by
///               association is run on the file specified in the <i>lpFile</i> parameter. Put simply, this is the application that
///               is launched when the document file is directly double-clicked or when <b>Open</b> is chosen from the file's
///               shortcut menu. This parameter must contain a valid non-<b>null</b> value and is assumed to be of length MAX_PATH.
///               Responsibility for validating the value is left to the programmer.
///Returns:
///    Type: <b>HINSTANCE</b> Returns a value greater than 32 if successful, or a value less than or equal to 32
///    representing an error. The following table lists possible error values. <table> <tr> <th>Return code/value</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>SE_ERR_FNF</b></dt> <dt>2</dt> </dl> </td> <td
///    width="60%"> The specified file was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SE_ERR_PNF</b></dt>
///    <dt>3</dt> </dl> </td> <td width="60%"> The specified path is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>SE_ERR_ACCESSDENIED</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> The specified file cannot be
///    accessed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SE_ERR_OOM</b></dt> <dt>8</dt> </dl> </td> <td
///    width="60%"> The system is out of memory or resources. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>SE_ERR_NOASSOC</b></dt> <dt>31</dt> </dl> </td> <td width="60%"> There is no association for the specified
///    file type with an executable file. </td> </tr> </table>
///    
@DllImport("SHELL32")
HINSTANCE FindExecutableW(const(wchar)* lpFile, const(wchar)* lpDirectory, const(wchar)* lpResult);

///Displays a <b>ShellAbout</b> dialog box.
///Params:
///    hWnd = Type: <b>HWND</b> A window handle to a parent window. This parameter can be <b>NULL</b>.
///    szApp = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains text to be displayed in the title bar of
///            the <b>ShellAbout</b> dialog box and on the first line of the dialog box after the text "Microsoft". If the text
///            contains a separator (
///    szOtherStuff = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains text to be displayed in the dialog box
///                   after the version and copyright information. This parameter can be <b>NULL</b>.
///    hIcon = Type: <b>HICON</b> The handle of an icon that the function displays in the dialog box. This parameter can be
///            <b>NULL</b>, in which case the function displays the Windows icon.
///Returns:
///    Type: <b>int</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
int ShellAboutA(HWND hWnd, const(char)* szApp, const(char)* szOtherStuff, HICON hIcon);

///Displays a <b>ShellAbout</b> dialog box.
///Params:
///    hWnd = Type: <b>HWND</b> A window handle to a parent window. This parameter can be <b>NULL</b>.
///    szApp = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains text to be displayed in the title bar of
///            the <b>ShellAbout</b> dialog box and on the first line of the dialog box after the text "Microsoft". If the text
///            contains a separator (
///    szOtherStuff = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains text to be displayed in the dialog box
///                   after the version and copyright information. This parameter can be <b>NULL</b>.
///    hIcon = Type: <b>HICON</b> The handle of an icon that the function displays in the dialog box. This parameter can be
///            <b>NULL</b>, in which case the function displays the Windows icon.
///Returns:
///    Type: <b>int</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
int ShellAboutW(HWND hWnd, const(wchar)* szApp, const(wchar)* szOtherStuff, HICON hIcon);

///Creates a duplicate of a specified icon.
///Params:
///    hInst = Type: <b>HINSTANCE</b>
///    hIcon = Type: <b>HICON</b> Handle to the icon to be duplicated.
///Returns:
///    Type: <b>HICON</b> If successful, the function returns the handle to the new icon that was created; otherwise,
///    <b>NULL</b>.
///    
@DllImport("SHELL32")
HICON DuplicateIcon(HINSTANCE hInst, HICON hIcon);

///Gets a handle to an icon stored as a resource in a file or an icon stored in a file's associated executable file.
///Params:
///    hInst = Type: <b>HINSTANCE</b> A handle to the instance of the calling application.
///    pszIconPath = Type: <b>LPTSTR</b> Pointer to a string that, on entry, specifies the full path and file name of the file that
///                  contains the icon. The function extracts the icon handle from that file, or from an executable file associated
///                  with that file. When this function returns, if the icon handle was obtained from an executable file (either an
///                  executable file pointed to by <i>lpIconPath</i> or an associated executable file) the function stores the full
///                  path and file name of that executable in the buffer pointed to by this parameter.
///    piIcon = Type: <b>LPWORD</b> Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle
///             is to be obtained. When the function returns, if the icon handle was obtained from an executable file (either an
///             executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the
///             icon's index in that file.
///Returns:
///    Type: <b>HICON</b> If the function succeeds, the return value is an icon handle. If the icon is extracted from an
///    associated executable file, the function stores the full path and file name of the executable file in the string
///    pointed to by <i>lpIconPath</i>, and stores the icon's identifier in the <b>WORD</b> pointed to by
///    <i>lpiIcon</i>. If the function fails, the return value is <b>NULL</b>.
///    
@DllImport("SHELL32")
HICON ExtractAssociatedIconA(HINSTANCE hInst, const(char)* pszIconPath, ushort* piIcon);

///Gets a handle to an icon stored as a resource in a file or an icon stored in a file's associated executable file.
///Params:
///    hInst = Type: <b>HINSTANCE</b> A handle to the instance of the calling application.
///    pszIconPath = Type: <b>LPTSTR</b> Pointer to a string that, on entry, specifies the full path and file name of the file that
///                  contains the icon. The function extracts the icon handle from that file, or from an executable file associated
///                  with that file. When this function returns, if the icon handle was obtained from an executable file (either an
///                  executable file pointed to by <i>lpIconPath</i> or an associated executable file) the function stores the full
///                  path and file name of that executable in the buffer pointed to by this parameter.
///    piIcon = Type: <b>LPWORD</b> Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle
///             is to be obtained. When the function returns, if the icon handle was obtained from an executable file (either an
///             executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the
///             icon's index in that file.
///Returns:
///    Type: <b>HICON</b> If the function succeeds, the return value is an icon handle. If the icon is extracted from an
///    associated executable file, the function stores the full path and file name of the executable file in the string
///    pointed to by <i>lpIconPath</i>, and stores the icon's identifier in the <b>WORD</b> pointed to by
///    <i>lpiIcon</i>. If the function fails, the return value is <b>NULL</b>.
///    
@DllImport("SHELL32")
HICON ExtractAssociatedIconW(HINSTANCE hInst, const(wchar)* pszIconPath, ushort* piIcon);

///<p class="CCE_Message">[<b>ExtractAssociatedIconEx</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Gets a handle to an icon stored as a
///resource in a file or an icon stored in a file's associated executable file. It extends the ExtractAssociatedIcon
///function by retrieving the icon's ID when that icon is extracted from an executable file.
///Params:
///    hInst = Type: <b>HINSTANCE</b> The handle of the module from which to extract the icon.
///    pszIconPath = Type: <b>LPTSTR</b> Pointer to a string that, on entry, specifies the full path and file name of the file that
///                  contains the icon. The function extracts the icon handle from that file, or from an executable file associated
///                  with that file. When this function returns, if the icon handle was obtained from an executable file (either an
///                  executable file directly pointed to by this parameter or an associated executable file) the function stores the
///                  full path and file name of that executable in the buffer pointed to by this parameter.
///    piIconIndex = Type: <b>LPWORD</b> Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle
///                  is to be obtained. When the function returns, if the icon handle was obtained from an executable file (either an
///                  executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the
///                  icon's index in that file.
///    piIconId = Type: <b>LPWORD</b> Pointer to a <b>WORD</b> value that, on entry, specifies the ID of the icon whose handle is
///               to be obtained. When the function returns, if the icon handle was obtained from an executable file (either an
///               executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the
///               icon's ID within that file.
///Returns:
///    Type: <b>HICON</b> Returns the icon's handle if successful, otherwise <b>NULL</b>.
///    
@DllImport("SHELL32")
HICON ExtractAssociatedIconExA(HINSTANCE hInst, const(char)* pszIconPath, ushort* piIconIndex, ushort* piIconId);

///<p class="CCE_Message">[<b>ExtractAssociatedIconEx</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Gets a handle to an icon stored as a
///resource in a file or an icon stored in a file's associated executable file. It extends the ExtractAssociatedIcon
///function by retrieving the icon's ID when that icon is extracted from an executable file.
///Params:
///    hInst = Type: <b>HINSTANCE</b> The handle of the module from which to extract the icon.
///    pszIconPath = Type: <b>LPTSTR</b> Pointer to a string that, on entry, specifies the full path and file name of the file that
///                  contains the icon. The function extracts the icon handle from that file, or from an executable file associated
///                  with that file. When this function returns, if the icon handle was obtained from an executable file (either an
///                  executable file directly pointed to by this parameter or an associated executable file) the function stores the
///                  full path and file name of that executable in the buffer pointed to by this parameter.
///    piIconIndex = Type: <b>LPWORD</b> Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle
///                  is to be obtained. When the function returns, if the icon handle was obtained from an executable file (either an
///                  executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the
///                  icon's index in that file.
///    piIconId = Type: <b>LPWORD</b> Pointer to a <b>WORD</b> value that, on entry, specifies the ID of the icon whose handle is
///               to be obtained. When the function returns, if the icon handle was obtained from an executable file (either an
///               executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the
///               icon's ID within that file.
///Returns:
///    Type: <b>HICON</b> Returns the icon's handle if successful, otherwise <b>NULL</b>.
///    
@DllImport("SHELL32")
HICON ExtractAssociatedIconExW(HINSTANCE hInst, const(wchar)* pszIconPath, ushort* piIconIndex, ushort* piIconId);

///Gets a handle to an icon from the specified executable file, DLL, or icon file. To retrieve an array of handles to
///large or small icons, use the ExtractIconEx function.
///Params:
///    hInst = Type: <b>HINSTANCE</b> Handle to the instance of the application that calls the function.
///    pszExeFileName = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the name of an executable file, DLL, or
///                     icon file.
///    nIconIndex = Type: <b>UINT</b> Specifies the zero-based index of the icon to retrieve. For example, if this value is 0, the
///                 function returns a handle to the first icon in the specified file. If this value is -1, the function returns the
///                 total number of icons in the specified file. If the file is an executable file or DLL, the return value is the
///                 number of RT_GROUP_ICON resources. If the file is an .ICO file, the return value is 1. If this value is a
///                 negative number not equal to –1, the function returns a handle to the icon in the specified file whose resource
///                 identifier is equal to the absolute value of <i>nIconIndex</i>. For example, you should use –3 to extract the
///                 icon whose resource identifier is 3. To extract the icon whose resource identifier is 1, use the ExtractIconEx
///                 function.
///Returns:
///    Type: <b>HICON</b> The return value is a handle to an icon. If the file specified was not an executable file,
///    DLL, or icon file, the return is 1. If no icons were found in the file, the return value is <b>NULL</b>.
///    
@DllImport("SHELL32")
HICON ExtractIconA(HINSTANCE hInst, const(char)* pszExeFileName, uint nIconIndex);

///Gets a handle to an icon from the specified executable file, DLL, or icon file. To retrieve an array of handles to
///large or small icons, use the ExtractIconEx function.
///Params:
///    hInst = Type: <b>HINSTANCE</b> Handle to the instance of the application that calls the function.
///    pszExeFileName = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the name of an executable file, DLL, or
///                     icon file.
///    nIconIndex = Type: <b>UINT</b> Specifies the zero-based index of the icon to retrieve. For example, if this value is 0, the
///                 function returns a handle to the first icon in the specified file. If this value is -1, the function returns the
///                 total number of icons in the specified file. If the file is an executable file or DLL, the return value is the
///                 number of RT_GROUP_ICON resources. If the file is an .ICO file, the return value is 1. If this value is a
///                 negative number not equal to –1, the function returns a handle to the icon in the specified file whose resource
///                 identifier is equal to the absolute value of <i>nIconIndex</i>. For example, you should use –3 to extract the
///                 icon whose resource identifier is 3. To extract the icon whose resource identifier is 1, use the ExtractIconEx
///                 function.
///Returns:
///    Type: <b>HICON</b> The return value is a handle to an icon. If the file specified was not an executable file,
///    DLL, or icon file, the return is 1. If no icons were found in the file, the return value is <b>NULL</b>.
///    
@DllImport("SHELL32")
HICON ExtractIconW(HINSTANCE hInst, const(wchar)* pszExeFileName, uint nIconIndex);

///Sends an appbar message to the system.
///Params:
///    dwMessage = Type: <b>DWORD</b> Appbar message value to send. This parameter can be one of the following values.
///    pData = Type: <b>PAPPBARDATA</b> A pointer to an APPBARDATA structure. The content of the structure on entry and on exit
///            depends on the value set in the <i>dwMessage</i> parameter. See the individual message pages for specifics.
///Returns:
///    Type: <b>UINT_PTR</b> This function returns a message-dependent value. For more information, see the Windows SDK
///    documentation for the specific appbar message sent. Links to those documents are given in the See Also section.
///    
@DllImport("SHELL32")
size_t SHAppBarMessage(uint dwMessage, APPBARDATA* pData);

///<p class="CCE_Message">[This function is retained only for backward compatibility. Use ExpandEnvironmentStrings
///instead.] Parses an input string that contains references to one or more environment variables and replaces them with
///their fully expanded values.
///Params:
///    pszSrc = Type: <b>LPTSTR</b> A pointer to a null-terminated string that contains references to one or more environment
///             variables, each in the following form. Case is ignored. <pre class="syntax"
///             xml:space="preserve"><code>%VariableName%</code></pre> Any character in the string that is not enclosed in '%'
///             characters is ignored and returned unchanged. Therefore, if your string contains multiple environment variables,
///             you can use any character other than '%' as a separator, including spaces or no separator. When this function
///             returns successfully, each %<i>VariableName</i>% is replaced with its expanded value. The replacement rules are
///             the same as those used by the command interpreter. If the variable name is not found on the system, the
///             %<i>variableName</i>% is left as it was submitted on entry. If this function fails due to the expanded string
///             being too large for the buffer, the contents of this buffer are left unchanged.
///    cchSrc = Type: <b>UINT</b> The size, in characters, of the buffer pointed to by <i>pszSrc</i>. Note that the buffer must
///             be large enough to hold the returned string.
///Returns:
///    Type: <b>DWORD</b> If the expanded string fits in the buffer, <b>TRUE</b> is returned in the HIWORD and the
///    length, in characters, of the new <i>pszSrc</i> is returned in the LOWORD. If the expanded string is too large
///    for the buffer, <b>FALSE</b> is returned in the HIWORD and <i>cchSrc</i> in the LOWORD.
///    
@DllImport("SHELL32")
uint DoEnvironmentSubstA(const(char)* pszSrc, uint cchSrc);

///<p class="CCE_Message">[This function is retained only for backward compatibility. Use ExpandEnvironmentStrings
///instead.] Parses an input string that contains references to one or more environment variables and replaces them with
///their fully expanded values.
///Params:
///    pszSrc = Type: <b>LPTSTR</b> A pointer to a null-terminated string that contains references to one or more environment
///             variables, each in the following form. Case is ignored. <pre class="syntax"
///             xml:space="preserve"><code>%VariableName%</code></pre> Any character in the string that is not enclosed in '%'
///             characters is ignored and returned unchanged. Therefore, if your string contains multiple environment variables,
///             you can use any character other than '%' as a separator, including spaces or no separator. When this function
///             returns successfully, each %<i>VariableName</i>% is replaced with its expanded value. The replacement rules are
///             the same as those used by the command interpreter. If the variable name is not found on the system, the
///             %<i>variableName</i>% is left as it was submitted on entry. If this function fails due to the expanded string
///             being too large for the buffer, the contents of this buffer are left unchanged.
///    cchSrc = Type: <b>UINT</b> The size, in characters, of the buffer pointed to by <i>pszSrc</i>. Note that the buffer must
///             be large enough to hold the returned string.
///Returns:
///    Type: <b>DWORD</b> If the expanded string fits in the buffer, <b>TRUE</b> is returned in the HIWORD and the
///    length, in characters, of the new <i>pszSrc</i> is returned in the LOWORD. If the expanded string is too large
///    for the buffer, <b>FALSE</b> is returned in the HIWORD and <i>cchSrc</i> in the LOWORD.
///    
@DllImport("SHELL32")
uint DoEnvironmentSubstW(const(wchar)* pszSrc, uint cchSrc);

///The <b>ExtractIconEx</b> function creates an array of handles to large or small icons extracted from the specified
///executable file, DLL, or icon file.
///Params:
///    lpszFile = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the name of an executable file, DLL, or
///               icon file from which icons will be extracted.
///    nIconIndex = Type: <b>int</b> Specifies the zero-based index of the first icon to extract. For example, if this value is zero,
///                 the function extracts the first icon in the specified file. If this value is –1 and <i>phiconLarge</i> and
///                 <i>phiconSmall</i> are both <b>NULL</b>, the function returns the total number of icons in the specified file. If
///                 the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is
///                 an .ico file, the return value is 1. If this value is a negative number and either <i>phiconLarge</i> or
///                 <i>phiconSmall</i> is not <b>NULL</b>, the function begins by extracting the icon whose resource identifier is
///                 equal to the absolute value of <i>nIconIndex</i>. For example, use -3 to extract the icon whose resource
///                 identifier is 3.
///    phiconLarge = Type: <b>HICON*</b> Pointer to an array of icon handles that receives handles to the large icons extracted from
///                  the file. If this parameter is <b>NULL</b>, no large icons are extracted from the file.
///    phiconSmall = Type: <b>HICON*</b> Pointer to an array of icon handles that receives handles to the small icons extracted from
///                  the file. If this parameter is <b>NULL</b>, no small icons are extracted from the file.
///    nIcons = Type: <b>UINT</b> The number of icons to extract from the file.
///Returns:
///    Type: **UINT** If the *nIconIndex* parameter is -1 and both the *phiconLarge* and *phiconSmall* parameters are
///    **NULL**, then the return value is the number of icons contained in the specified file. If the *nIconIndex*
///    parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**, the return value
///    is the number of icons successfully extracted from the file. > [!NOTE] > If the function encounters an error, it
///    returns **UINT_MAX**. In this case, you can call
///    [GetLastError](../errhandlingapi/nf-errhandlingapi-getlasterror.md) to retrieve the error code. For example, this
///    function returns **UINT_MAX** if the file specified by *lpszFile* cannot be found while the *nIconIndex*
///    parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**. In this case,
///    **GetLastError** returns **ERROR_FILE_NOT_FOUND** (2).
///    
@DllImport("SHELL32")
uint ExtractIconExA(const(char)* lpszFile, int nIconIndex, char* phiconLarge, char* phiconSmall, uint nIcons);

///The <b>ExtractIconEx</b> function creates an array of handles to large or small icons extracted from the specified
///executable file, DLL, or icon file.
///Params:
///    lpszFile = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the name of an executable file, DLL, or
///               icon file from which icons will be extracted.
///    nIconIndex = Type: <b>int</b> Specifies the zero-based index of the first icon to extract. For example, if this value is zero,
///                 the function extracts the first icon in the specified file. If this value is –1 and <i>phiconLarge</i> and
///                 <i>phiconSmall</i> are both <b>NULL</b>, the function returns the total number of icons in the specified file. If
///                 the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is
///                 an .ico file, the return value is 1. If this value is a negative number and either <i>phiconLarge</i> or
///                 <i>phiconSmall</i> is not <b>NULL</b>, the function begins by extracting the icon whose resource identifier is
///                 equal to the absolute value of <i>nIconIndex</i>. For example, use -3 to extract the icon whose resource
///                 identifier is 3.
///    phiconLarge = Type: <b>HICON*</b> Pointer to an array of icon handles that receives handles to the large icons extracted from
///                  the file. If this parameter is <b>NULL</b>, no large icons are extracted from the file.
///    phiconSmall = Type: <b>HICON*</b> Pointer to an array of icon handles that receives handles to the small icons extracted from
///                  the file. If this parameter is <b>NULL</b>, no small icons are extracted from the file.
///    nIcons = Type: <b>UINT</b> The number of icons to extract from the file.
///Returns:
///    Type: **UINT** If the *nIconIndex* parameter is -1 and both the *phiconLarge* and *phiconSmall* parameters are
///    **NULL**, then the return value is the number of icons contained in the specified file. If the *nIconIndex*
///    parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**, the return value
///    is the number of icons successfully extracted from the file. > [!NOTE] > If the function encounters an error, it
///    returns **UINT_MAX**. In this case, you can call
///    [GetLastError](../errhandlingapi/nf-errhandlingapi-getlasterror.md) to retrieve the error code. For example, this
///    function returns **UINT_MAX** if the file specified by *lpszFile* cannot be found while the *nIconIndex*
///    parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**. In this case,
///    **GetLastError** returns **ERROR_FILE_NOT_FOUND** (2).
///    
@DllImport("SHELL32")
uint ExtractIconExW(const(wchar)* lpszFile, int nIconIndex, char* phiconLarge, char* phiconSmall, uint nIcons);

///Copies, moves, renames, or deletes a file system object. This function has been replaced in Windows Vista by
///IFileOperation.
///Params:
///    lpFileOp = Type: <b>LPSHFILEOPSTRUCT</b> A pointer to an SHFILEOPSTRUCT structure that contains information this function
///               needs to carry out the specified operation. This parameter must contain a valid value that is not <b>NULL</b>.
///               You are responsible for validating the value. If you do not validate it, you will experience unexpected results.
///Returns:
///    Type: <b>int</b> Returns zero if successful; otherwise nonzero. Applications normally should simply check for
///    zero or nonzero. It is good practice to examine the value of the <b>fAnyOperationsAborted</b> member of the
///    SHFILEOPSTRUCT. <b>SHFileOperation</b> can return 0 for success if the user cancels the operation. If you do not
///    check <b>fAnyOperationsAborted</b> as well as the return value, you cannot know that the function accomplished
///    the full task you asked of it and you might proceed under incorrect assumptions. Do not use GetLastError with the
///    return values of this function. To examine the nonzero values for troubleshooting purposes, they largely map to
///    those defined in Winerror.h. However, several of its possible return values are based on pre-Win32 error codes,
///    which in some cases overlap the later Winerror.h values without matching their meaning. Those particular values
///    are detailed here, and <i>for these specific values only</i> these meanings should be accepted over the
///    Winerror.h codes. However, these values are provided with these warnings: <ul> <li>These are pre-Win32 error
///    codes and are no longer supported or defined in any public header file. To use them, you must either define them
///    yourself or compare against the numerical value.</li> <li>These error codes are subject to change and have
///    historically done so.</li> <li>These values are provided only as an aid in debugging. They should not be regarded
///    as definitive.</li> </ul> <table class="clsStd"> <tr> <th>Error Code</th> <th>Value</th> <th>Meaning</th> </tr>
///    <tr> <td>DE_SAMEFILE</td> <td>0x71</td> <td>The source and destination files are the same file.</td> </tr> <tr>
///    <td>DE_MANYSRC1DEST</td> <td>0x72</td> <td>Multiple file paths were specified in the source buffer, but only one
///    destination file path.</td> </tr> <tr> <td>DE_DIFFDIR</td> <td>0x73</td> <td>Rename operation was specified but
///    the destination path is a different directory. Use the move operation instead.</td> </tr> <tr>
///    <td>DE_ROOTDIR</td> <td>0x74</td> <td>The source is a root directory, which cannot be moved or renamed.</td>
///    </tr> <tr> <td>DE_OPCANCELLED</td> <td>0x75</td> <td>The operation was canceled by the user, or silently canceled
///    if the appropriate flags were supplied to <b>SHFileOperation</b>.</td> </tr> <tr> <td>DE_DESTSUBTREE</td>
///    <td>0x76</td> <td>The destination is a subtree of the source.</td> </tr> <tr> <td>DE_ACCESSDENIEDSRC</td>
///    <td>0x78</td> <td>Security settings denied access to the source.</td> </tr> <tr> <td>DE_PATHTOODEEP</td>
///    <td>0x79</td> <td>The source or destination path exceeded or would exceed MAX_PATH.</td> </tr> <tr>
///    <td>DE_MANYDEST</td> <td>0x7A</td> <td>The operation involved multiple destination paths, which can fail in the
///    case of a move operation.</td> </tr> <tr> <td>DE_INVALIDFILES</td> <td>0x7C</td> <td>The path in the source or
///    destination or both was invalid.</td> </tr> <tr> <td>DE_DESTSAMETREE</td> <td>0x7D</td> <td>The source and
///    destination have the same parent folder.</td> </tr> <tr> <td>DE_FLDDESTISFILE</td> <td>0x7E</td> <td>The
///    destination path is an existing file.</td> </tr> <tr> <td>DE_FILEDESTISFLD</td> <td>0x80</td> <td>The destination
///    path is an existing folder.</td> </tr> <tr> <td>DE_FILENAMETOOLONG</td> <td>0x81</td> <td>The name of the file
///    exceeds MAX_PATH.</td> </tr> <tr> <td>DE_DEST_IS_CDROM</td> <td>0x82</td> <td>The destination is a read-only
///    CD-ROM, possibly unformatted.</td> </tr> <tr> <td>DE_DEST_IS_DVD</td> <td>0x83</td> <td>The destination is a
///    read-only DVD, possibly unformatted.</td> </tr> <tr> <td>DE_DEST_IS_CDRECORD</td> <td>0x84</td> <td>The
///    destination is a writable CD-ROM, possibly unformatted.</td> </tr> <tr> <td>DE_FILE_TOO_LARGE</td> <td>0x85</td>
///    <td>The file involved in the operation is too large for the destination media or file system.</td> </tr> <tr>
///    <td>DE_SRC_IS_CDROM</td> <td>0x86</td> <td>The source is a read-only CD-ROM, possibly unformatted.</td> </tr>
///    <tr> <td>DE_SRC_IS_DVD</td> <td>0x87</td> <td>The source is a read-only DVD, possibly unformatted.</td> </tr>
///    <tr> <td>DE_SRC_IS_CDRECORD</td> <td>0x88</td> <td>The source is a writable CD-ROM, possibly unformatted.</td>
///    </tr> <tr> <td>DE_ERROR_MAX</td> <td>0xB7</td> <td>MAX_PATH was exceeded during the operation.</td> </tr> <tr>
///    <td></td> <td>0x402</td> <td>An unknown error occurred. This is typically due to an invalid path in the source or
///    destination. This error does not occur on Windows Vista and later.</td> </tr> <tr> <td>ERRORONDEST</td>
///    <td>0x10000</td> <td>An unspecified error occurred on the destination.</td> </tr> <tr> <td>DE_ROOTDIR |
///    ERRORONDEST</td> <td>0x10074</td> <td>Destination is a root directory and cannot be renamed.</td> </tr> </table>
///    
@DllImport("SHELL32")
int SHFileOperationA(SHFILEOPSTRUCTA* lpFileOp);

///Copies, moves, renames, or deletes a file system object. This function has been replaced in Windows Vista by
///IFileOperation.
///Params:
///    lpFileOp = Type: <b>LPSHFILEOPSTRUCT</b> A pointer to an SHFILEOPSTRUCT structure that contains information this function
///               needs to carry out the specified operation. This parameter must contain a valid value that is not <b>NULL</b>.
///               You are responsible for validating the value. If you do not validate it, you will experience unexpected results.
///Returns:
///    Type: <b>int</b> Returns zero if successful; otherwise nonzero. Applications normally should simply check for
///    zero or nonzero. It is good practice to examine the value of the <b>fAnyOperationsAborted</b> member of the
///    SHFILEOPSTRUCT. <b>SHFileOperation</b> can return 0 for success if the user cancels the operation. If you do not
///    check <b>fAnyOperationsAborted</b> as well as the return value, you cannot know that the function accomplished
///    the full task you asked of it and you might proceed under incorrect assumptions. Do not use GetLastError with the
///    return values of this function. To examine the nonzero values for troubleshooting purposes, they largely map to
///    those defined in Winerror.h. However, several of its possible return values are based on pre-Win32 error codes,
///    which in some cases overlap the later Winerror.h values without matching their meaning. Those particular values
///    are detailed here, and <i>for these specific values only</i> these meanings should be accepted over the
///    Winerror.h codes. However, these values are provided with these warnings: <ul> <li>These are pre-Win32 error
///    codes and are no longer supported or defined in any public header file. To use them, you must either define them
///    yourself or compare against the numerical value.</li> <li>These error codes are subject to change and have
///    historically done so.</li> <li>These values are provided only as an aid in debugging. They should not be regarded
///    as definitive.</li> </ul> <table class="clsStd"> <tr> <th>Error Code</th> <th>Value</th> <th>Meaning</th> </tr>
///    <tr> <td>DE_SAMEFILE</td> <td>0x71</td> <td>The source and destination files are the same file.</td> </tr> <tr>
///    <td>DE_MANYSRC1DEST</td> <td>0x72</td> <td>Multiple file paths were specified in the source buffer, but only one
///    destination file path.</td> </tr> <tr> <td>DE_DIFFDIR</td> <td>0x73</td> <td>Rename operation was specified but
///    the destination path is a different directory. Use the move operation instead.</td> </tr> <tr>
///    <td>DE_ROOTDIR</td> <td>0x74</td> <td>The source is a root directory, which cannot be moved or renamed.</td>
///    </tr> <tr> <td>DE_OPCANCELLED</td> <td>0x75</td> <td>The operation was canceled by the user, or silently canceled
///    if the appropriate flags were supplied to <b>SHFileOperation</b>.</td> </tr> <tr> <td>DE_DESTSUBTREE</td>
///    <td>0x76</td> <td>The destination is a subtree of the source.</td> </tr> <tr> <td>DE_ACCESSDENIEDSRC</td>
///    <td>0x78</td> <td>Security settings denied access to the source.</td> </tr> <tr> <td>DE_PATHTOODEEP</td>
///    <td>0x79</td> <td>The source or destination path exceeded or would exceed MAX_PATH.</td> </tr> <tr>
///    <td>DE_MANYDEST</td> <td>0x7A</td> <td>The operation involved multiple destination paths, which can fail in the
///    case of a move operation.</td> </tr> <tr> <td>DE_INVALIDFILES</td> <td>0x7C</td> <td>The path in the source or
///    destination or both was invalid.</td> </tr> <tr> <td>DE_DESTSAMETREE</td> <td>0x7D</td> <td>The source and
///    destination have the same parent folder.</td> </tr> <tr> <td>DE_FLDDESTISFILE</td> <td>0x7E</td> <td>The
///    destination path is an existing file.</td> </tr> <tr> <td>DE_FILEDESTISFLD</td> <td>0x80</td> <td>The destination
///    path is an existing folder.</td> </tr> <tr> <td>DE_FILENAMETOOLONG</td> <td>0x81</td> <td>The name of the file
///    exceeds MAX_PATH.</td> </tr> <tr> <td>DE_DEST_IS_CDROM</td> <td>0x82</td> <td>The destination is a read-only
///    CD-ROM, possibly unformatted.</td> </tr> <tr> <td>DE_DEST_IS_DVD</td> <td>0x83</td> <td>The destination is a
///    read-only DVD, possibly unformatted.</td> </tr> <tr> <td>DE_DEST_IS_CDRECORD</td> <td>0x84</td> <td>The
///    destination is a writable CD-ROM, possibly unformatted.</td> </tr> <tr> <td>DE_FILE_TOO_LARGE</td> <td>0x85</td>
///    <td>The file involved in the operation is too large for the destination media or file system.</td> </tr> <tr>
///    <td>DE_SRC_IS_CDROM</td> <td>0x86</td> <td>The source is a read-only CD-ROM, possibly unformatted.</td> </tr>
///    <tr> <td>DE_SRC_IS_DVD</td> <td>0x87</td> <td>The source is a read-only DVD, possibly unformatted.</td> </tr>
///    <tr> <td>DE_SRC_IS_CDRECORD</td> <td>0x88</td> <td>The source is a writable CD-ROM, possibly unformatted.</td>
///    </tr> <tr> <td>DE_ERROR_MAX</td> <td>0xB7</td> <td>MAX_PATH was exceeded during the operation.</td> </tr> <tr>
///    <td></td> <td>0x402</td> <td>An unknown error occurred. This is typically due to an invalid path in the source or
///    destination. This error does not occur on Windows Vista and later.</td> </tr> <tr> <td>ERRORONDEST</td>
///    <td>0x10000</td> <td>An unspecified error occurred on the destination.</td> </tr> <tr> <td>DE_ROOTDIR |
///    ERRORONDEST</td> <td>0x10074</td> <td>Destination is a root directory and cannot be renamed.</td> </tr> </table>
///    
@DllImport("SHELL32")
int SHFileOperationW(SHFILEOPSTRUCTW* lpFileOp);

///Frees a file name mapping object that was retrieved by the SHFileOperation function.
@DllImport("SHELL32")
void SHFreeNameMappings(HANDLE hNameMappings);

///Performs an operation on a specified file.
///Params:
///    pExecInfo = Type: <b>SHELLEXECUTEINFO*</b> A pointer to a SHELLEXECUTEINFO structure that contains and receives information
///                about the application being executed.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. Call GetLastError for extended
///    error information.
///    
@DllImport("SHELL32")
BOOL ShellExecuteExA(SHELLEXECUTEINFOA* pExecInfo);

///Performs an operation on a specified file.
///Params:
///    pExecInfo = Type: <b>SHELLEXECUTEINFO*</b> A pointer to a SHELLEXECUTEINFO structure that contains and receives information
///                about the application being executed.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. Call GetLastError for extended
///    error information.
///    
@DllImport("SHELL32")
BOOL ShellExecuteExW(SHELLEXECUTEINFOW* pExecInfo);

///<p class="CCE_Message">[<b>SHCreateProcessAsUserW</b> is not implemented under Windows XP or later systems.] Creates
///a new user-mode process and its primary thread to run a specified executable file.
///Params:
///    pscpi = Type: <b>PSHCREATEPROCESSINFOW</b> A pointer to an SHCREATEPROCESSINFOW structure with information on how to
///            create the process.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> if not. To retrieve extended error
///    information, call GetLastError.
///    
@DllImport("SHELL32")
BOOL SHCreateProcessAsUserW(SHCREATEPROCESSINFOW* pscpi);

///Enforces strict validation of parameters used in a call to CreateProcess or ShellExecute.
///Params:
///    pszCmdTemplate = Type: <b>PCWSTR</b> A command line, which may or may not include parameters. If the parameters are substitution
///                     parameters, then <b>SHEvaluateSystemCommandTemplate</b> should be called before parameters have been replaced.
///    ppszApplication = Type: <b>PWSTR*</b> A pointer to the verified path to the application. This value should be passed as the
///                      <i>lpApplication</i> parameter in a call to CreateProcess or as the <i>lpFile</i> parameter in a call to
///                      ShellExecute. This resource is allocated using CoTaskMemAlloc, and it is the responsibility of the caller to free
///                      the resource when it is no longer needed by calling CoTaskMemFree.
///    ppszCommandLine = Type: <b>PWSTR*</b> A pointer to a command-line string template to be used in a call to CreateProcess.
///                      Command-line parameters should be specified based on this template, and then passed as the <i>lpCommandLine</i>
///                      parameter to <b>CreateProcess</b>. It is guaranteed to be of a form that PathGetArgs can always read correctly.
///                      This resource is allocated using CoTaskMemAlloc, and it is the responsibility of the caller to free the resource
///                      when it is no longer needed by calling CoTaskMemFree. This parameter can be <b>NULL</b> if this function is not
///                      being used in association with a call to CreateProcess.
///    ppszParameters = Type: <b>PWSTR*</b> A pointer to a command-line string template to be used in a call to ShellExecute.
///                     Command-line parameters should be specified based on this template, and then passed as the <i>lpParameters</i>
///                     parameter to <b>ShellExecute</b>. This parameter is identical to calling PathGetArgs. This resource is allocated
///                     using CoTaskMemAlloc, and it is the responsibility of the caller to free the resource when it is no longer needed
///                     by calling CoTaskMemFree. This parameter can be <b>NULL</b> if this function is not being used in association
///                     with a call to CreateProcess.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHEvaluateSystemCommandTemplate(const(wchar)* pszCmdTemplate, ushort** ppszApplication, 
                                        ushort** ppszCommandLine, ushort** ppszParameters);

///Retrieves an object that implements an IQueryAssociations interface.
///Params:
///    rgClasses = Type: <b>const ASSOCIATIONELEMENT*</b> A pointer to an array of ASSOCIATIONELEMENT structures.
///    cClasses = Type: <b>ULONG</b> The number of elements in the array pointed to by <i>rgClasses</i>.
///    riid = Type: <b>REFIID</b> Reference to the desired IID, normally IID_IQueryAssociations.
///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This is
///          normally IQueryAssociations.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT AssocCreateForClasses(char* rgClasses, uint cClasses, const(GUID)* riid, void** ppv);

///Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive.
///Params:
///    pszRootPath = Type: <b>LPCTSTR</b> The address of a <b>null</b>-terminated string of maximum length MAX_PATH to contain the
///                  path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string
///                  formatted with the drive, folder, and subfolder names (C:\Windows\System...).
///    pSHQueryRBInfo = Type: <b>LPSHQUERYRBINFO</b> The address of a SHQUERYRBINFO structure that receives the Recycle Bin information.
///                     The <b>cbSize</b> member of the structure must be set to the size of the structure before calling this API.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHQueryRecycleBinA(const(char)* pszRootPath, SHQUERYRBINFO* pSHQueryRBInfo);

///Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive.
///Params:
///    pszRootPath = Type: <b>LPCTSTR</b> The address of a <b>null</b>-terminated string of maximum length MAX_PATH to contain the
///                  path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string
///                  formatted with the drive, folder, and subfolder names (C:\Windows\System...).
///    pSHQueryRBInfo = Type: <b>LPSHQUERYRBINFO</b> The address of a SHQUERYRBINFO structure that receives the Recycle Bin information.
///                     The <b>cbSize</b> member of the structure must be set to the size of the structure before calling this API.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHQueryRecycleBinW(const(wchar)* pszRootPath, SHQUERYRBINFO* pSHQueryRBInfo);

///Empties the Recycle Bin on the specified drive.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to the parent window of any dialog boxes that might be displayed during the operation.
///           This parameter can be <b>NULL</b>.
///    pszRootPath = Type: <b>LPCTSTR</b> The address of a null-terminated string of maximum length MAX_PATH that contains the path of
///                  the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted
///                  with the drive, folder, and subfolder names, for example c:\windows\system\. It can also contain an empty string
///                  or <b>NULL</b>. If this value is an empty string or <b>NULL</b>, all Recycle Bins on all drives will be emptied.
///    dwFlags = Type: <b>DWORD</b> One or more of the following values.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHEmptyRecycleBinA(HWND hwnd, const(char)* pszRootPath, uint dwFlags);

///Empties the Recycle Bin on the specified drive.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to the parent window of any dialog boxes that might be displayed during the operation.
///           This parameter can be <b>NULL</b>.
///    pszRootPath = Type: <b>LPCTSTR</b> The address of a null-terminated string of maximum length MAX_PATH that contains the path of
///                  the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted
///                  with the drive, folder, and subfolder names, for example c:\windows\system\. It can also contain an empty string
///                  or <b>NULL</b>. If this value is an empty string or <b>NULL</b>, all Recycle Bins on all drives will be emptied.
///    dwFlags = Type: <b>DWORD</b> One or more of the following values.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHEmptyRecycleBinW(HWND hwnd, const(wchar)* pszRootPath, uint dwFlags);

///Checks the state of the computer for the current user to determine whether sending a notification is appropriate.
///Params:
///    pquns = Type: <b>QUERY_USER_NOTIFICATION_STATE*</b> When this function returns, contains a pointer to one of the values
///            of the QUERY_USER_NOTIFICATION_STATE enumeration.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHQueryUserNotificationState(QUERY_USER_NOTIFICATION_STATE* pquns);

///Sends a message to the taskbar's status area.
///Params:
///    dwMessage = Type: <b>DWORD</b> A value that specifies the action to be taken by this function. It can have one of the
///                following values:
///    lpData = Type: <b>PNOTIFYICONDATA</b> A pointer to a NOTIFYICONDATA structure. The content of the structure depends on the
///             value of <i>dwMessage</i>. It can define an icon to add to the notification area, cause that icon to display a
///             notification, or identify an icon to modify or delete.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. If <i>dwMessage</i> is set to
///    NIM_SETVERSION, the function returns <b>TRUE</b> if the version was successfully changed, or <b>FALSE</b> if the
///    requested version is not supported.
///    
@DllImport("SHELL32")
BOOL Shell_NotifyIconA(uint dwMessage, NOTIFYICONDATAA* lpData);

///Sends a message to the taskbar's status area.
///Params:
///    dwMessage = Type: <b>DWORD</b> A value that specifies the action to be taken by this function. It can have one of the
///                following values:
///    lpData = Type: <b>PNOTIFYICONDATA</b> A pointer to a NOTIFYICONDATA structure. The content of the structure depends on the
///             value of <i>dwMessage</i>. It can define an icon to add to the notification area, cause that icon to display a
///             notification, or identify an icon to modify or delete.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. If <i>dwMessage</i> is set to
///    NIM_SETVERSION, the function returns <b>TRUE</b> if the version was successfully changed, or <b>FALSE</b> if the
///    requested version is not supported.
///    
@DllImport("SHELL32")
BOOL Shell_NotifyIconW(uint dwMessage, NOTIFYICONDATAW* lpData);

///Gets the screen coordinates of the bounding rectangle of a notification icon.
///Params:
///    identifier = Type: <b>const NOTIFYICONIDENTIFIER*</b> Pointer to a NOTIFYICONIDENTIFIER structure that identifies the icon.
///    iconLocation = Type: <b>RECT*</b> Pointer to a RECT structure that, when this function returns successfully, receives the
///                   coordinates of the icon.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT Shell_NotifyIconGetRect(const(NOTIFYICONIDENTIFIER)* identifier, RECT* iconLocation);

///Retrieves information about an object in the file system, such as a file, folder, directory, or drive root.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a <b>null</b>-terminated string of maximum length MAX_PATH that contains the
///              path and file name. Both absolute and relative paths are valid. If the <i>uFlags</i> parameter includes the
///              <b>SHGFI_PIDL</b> flag, this parameter must be the address of an ITEMIDLIST (PIDL) structure that contains the
///              list of item identifiers that uniquely identifies the file within the Shell's namespace. The PIDL must be a fully
///              qualified PIDL. Relative PIDLs are not allowed. If the <i>uFlags</i> parameter includes the
///              <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter does not have to be a valid file name. The function will
///              proceed as if the file exists with the specified name and with the file attributes passed in the
///              <i>dwFileAttributes</i> parameter. This allows you to obtain information about a file type by passing just the
///              extension for <i>pszPath</i> and passing <b>FILE_ATTRIBUTE_NORMAL</b> in <i>dwFileAttributes</i>. This string can
///              use either short (the 8.3 form) or long file names.
///    dwFileAttributes = Type: <b>DWORD</b> A combination of one or more file attribute flags (FILE_ATTRIBUTE_ values as defined in
///                       Winnt.h). If <i>uFlags</i> does not include the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter is ignored.
///    psfi = Type: <b>SHFILEINFO*</b> Pointer to a SHFILEINFO structure to receive the file information.
///    cbFileInfo = Type: <b>UINT</b> The size, in bytes, of the SHFILEINFO structure pointed to by the <i>psfi</i> parameter.
///    uFlags = Type: <b>UINT</b> The flags that specify the file information to retrieve. This parameter can be a combination of
///             the following values.
///Returns:
///    Type: <b>DWORD_PTR</b> Returns a value whose meaning depends on the <i>uFlags</i> parameter. If <i>uFlags</i>
///    does not contain <b>SHGFI_EXETYPE</b> or <b>SHGFI_SYSICONINDEX</b>, the return value is nonzero if successful, or
///    zero otherwise. If <i>uFlags</i> contains the <b>SHGFI_EXETYPE</b> flag, the return value specifies the type of
///    the executable file. It will be one of the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>0</b></dt> </dl> </td> <td width="60%">
///    Nonexecutable file or an error condition. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>LOWORD = NE or PE and
///    HIWORD = Windows version</b></dt> </dl> </td> <td width="60%"> Windows application. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>LOWORD = MZ and HIWORD = 0</b></dt> </dl> </td> <td width="60%"> MS-DOS .exe or .com
///    file </td> </tr> <tr> <td width="40%"> <dl> <dt><b>LOWORD = PE and HIWORD = 0</b></dt> </dl> </td> <td
///    width="60%"> Console application or .bat file </td> </tr> </table>
///    
@DllImport("SHELL32")
size_t SHGetFileInfoA(const(char)* pszPath, uint dwFileAttributes, char* psfi, uint cbFileInfo, uint uFlags);

///Retrieves information about an object in the file system, such as a file, folder, directory, or drive root.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a <b>null</b>-terminated string of maximum length MAX_PATH that contains the
///              path and file name. Both absolute and relative paths are valid. If the <i>uFlags</i> parameter includes the
///              <b>SHGFI_PIDL</b> flag, this parameter must be the address of an ITEMIDLIST (PIDL) structure that contains the
///              list of item identifiers that uniquely identifies the file within the Shell's namespace. The PIDL must be a fully
///              qualified PIDL. Relative PIDLs are not allowed. If the <i>uFlags</i> parameter includes the
///              <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter does not have to be a valid file name. The function will
///              proceed as if the file exists with the specified name and with the file attributes passed in the
///              <i>dwFileAttributes</i> parameter. This allows you to obtain information about a file type by passing just the
///              extension for <i>pszPath</i> and passing <b>FILE_ATTRIBUTE_NORMAL</b> in <i>dwFileAttributes</i>. This string can
///              use either short (the 8.3 form) or long file names.
///    dwFileAttributes = Type: <b>DWORD</b> A combination of one or more file attribute flags (FILE_ATTRIBUTE_ values as defined in
///                       Winnt.h). If <i>uFlags</i> does not include the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter is ignored.
///    psfi = Type: <b>SHFILEINFO*</b> Pointer to a SHFILEINFO structure to receive the file information.
///    cbFileInfo = Type: <b>UINT</b> The size, in bytes, of the SHFILEINFO structure pointed to by the <i>psfi</i> parameter.
///    uFlags = Type: <b>UINT</b> The flags that specify the file information to retrieve. This parameter can be a combination of
///             the following values.
///Returns:
///    Type: <b>DWORD_PTR</b> Returns a value whose meaning depends on the <i>uFlags</i> parameter. If <i>uFlags</i>
///    does not contain <b>SHGFI_EXETYPE</b> or <b>SHGFI_SYSICONINDEX</b>, the return value is nonzero if successful, or
///    zero otherwise. If <i>uFlags</i> contains the <b>SHGFI_EXETYPE</b> flag, the return value specifies the type of
///    the executable file. It will be one of the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>0</b></dt> </dl> </td> <td width="60%">
///    Nonexecutable file or an error condition. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>LOWORD = NE or PE and
///    HIWORD = Windows version</b></dt> </dl> </td> <td width="60%"> Windows application. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>LOWORD = MZ and HIWORD = 0</b></dt> </dl> </td> <td width="60%"> MS-DOS .exe or .com
///    file </td> </tr> <tr> <td width="40%"> <dl> <dt><b>LOWORD = PE and HIWORD = 0</b></dt> </dl> </td> <td
///    width="60%"> Console application or .bat file </td> </tr> </table>
///    
@DllImport("SHELL32")
size_t SHGetFileInfoW(const(wchar)* pszPath, uint dwFileAttributes, char* psfi, uint cbFileInfo, uint uFlags);

///Retrieves information about system-defined Shell icons.
///Params:
///    siid = Type: <b>SHSTOCKICONID</b> One of the values from the SHSTOCKICONID enumeration that specifies which icon should
///           be retrieved.
///    uFlags = Type: <b>UINT</b> A combination of zero or more of the following flags that specify which information is
///             requested.
///    psii = Type: <b>SHSTOCKICONINFO*</b> A pointer to a SHSTOCKICONINFO structure. When this function is called, the
///           <b>cbSize</b> member of this structure needs to be set to the size of the <b>SHSTOCKICONINFO</b> structure. When
///           this function returns, contains a pointer to a <b>SHSTOCKICONINFO</b> structure that contains the requested
///           information.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetStockIconInfo(SHSTOCKICONID siid, uint uFlags, SHSTOCKICONINFO* psii);

///Retrieves disk space information for a disk volume.
///Params:
///    pszDirectoryName = Type: <b>LPCTSTR</b> A null-terminated string that specifies the volume for which size information is retrieved.
///                       This can be a drive letter, UNC name, or the path of a folder. You cannot use <b>NULL</b> to represent the
///                       current drive.
///    pulFreeBytesAvailableToCaller = Type: <b>ULARGE_INTEGER*</b> Pointer to a value that receives the number of bytes on the volume available to the
///                                    calling application. If the operating system implements per-user quotas, this value may be less than the total
///                                    number of free bytes on the volume.
///    pulTotalNumberOfBytes = Type: <b>ULARGE_INTEGER*</b> Pointer to a value that receives the total size of the volume, in bytes.
///    pulTotalNumberOfFreeBytes = Type: <b>ULARGE_INTEGER*</b> Pointer to a value that receives the number of bytes of free space on the volume.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.
///    
@DllImport("SHELL32")
BOOL SHGetDiskFreeSpaceExA(const(char)* pszDirectoryName, ULARGE_INTEGER* pulFreeBytesAvailableToCaller, 
                           ULARGE_INTEGER* pulTotalNumberOfBytes, ULARGE_INTEGER* pulTotalNumberOfFreeBytes);

///Retrieves disk space information for a disk volume.
///Params:
///    pszDirectoryName = Type: <b>LPCTSTR</b> A null-terminated string that specifies the volume for which size information is retrieved.
///                       This can be a drive letter, UNC name, or the path of a folder. You cannot use <b>NULL</b> to represent the
///                       current drive.
///    pulFreeBytesAvailableToCaller = Type: <b>ULARGE_INTEGER*</b> Pointer to a value that receives the number of bytes on the volume available to the
///                                    calling application. If the operating system implements per-user quotas, this value may be less than the total
///                                    number of free bytes on the volume.
///    pulTotalNumberOfBytes = Type: <b>ULARGE_INTEGER*</b> Pointer to a value that receives the total size of the volume, in bytes.
///    pulTotalNumberOfFreeBytes = Type: <b>ULARGE_INTEGER*</b> Pointer to a value that receives the number of bytes of free space on the volume.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.
///    
@DllImport("SHELL32")
BOOL SHGetDiskFreeSpaceExW(const(wchar)* pszDirectoryName, ULARGE_INTEGER* pulFreeBytesAvailableToCaller, 
                           ULARGE_INTEGER* pulTotalNumberOfBytes, ULARGE_INTEGER* pulTotalNumberOfFreeBytes);

///Creates a name for a new shortcut based on the shortcut's proposed target. This function does not create the
///shortcut, just the name.
///Params:
///    pszLinkTo = Type: <b>LPCTSTR</b> A pointer to the path and file name of the shortcut's target. If <i>uFlags</i> does not
///                contain the <b>SHGNLI_PIDL</b> value, this parameter is the address of a null-terminated string that contains the
///                target. If <i>uFlags</i> contains the <b>SHGNLI_PIDL</b> value, this parameter is a PIDL that represents the
///                target.
///    pszDir = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the path of the folder in which the
///             shortcut would be created.
///    pszName = Type: <b>LPTSTR</b> A pointer to a string that receives the null-terminated path and file name for the shortcut.
///              This buffer is assumed to be at least MAX_PATH characters in size.
///    pfMustCopy = Type: <b>BOOL*</b> The address of a <b>BOOL</b> value that receives a flag indicating whether the shortcut would
///                 be copied. When a shortcut to another shortcut is created, the Shell simply copies the target shortcut and
///                 modifies that copied shortcut appropriately. This parameter receives a nonzero value if the target specified in
///                 <i>pszLinkTo</i> specifies a shortcut that will cause the target shortcut to be copied. This parameter receives
///                 zero if the target does not specify a shortcut that would be copied.
///    uFlags = Type: <b>UINT</b> The options for the function. This can be zero or a combination of the following values.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL SHGetNewLinkInfoA(const(char)* pszLinkTo, const(char)* pszDir, const(char)* pszName, int* pfMustCopy, 
                       uint uFlags);

///Creates a name for a new shortcut based on the shortcut's proposed target. This function does not create the
///shortcut, just the name.
///Params:
///    pszLinkTo = Type: <b>LPCTSTR</b> A pointer to the path and file name of the shortcut's target. If <i>uFlags</i> does not
///                contain the <b>SHGNLI_PIDL</b> value, this parameter is the address of a null-terminated string that contains the
///                target. If <i>uFlags</i> contains the <b>SHGNLI_PIDL</b> value, this parameter is a PIDL that represents the
///                target.
///    pszDir = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the path of the folder in which the
///             shortcut would be created.
///    pszName = Type: <b>LPTSTR</b> A pointer to a string that receives the null-terminated path and file name for the shortcut.
///              This buffer is assumed to be at least MAX_PATH characters in size.
///    pfMustCopy = Type: <b>BOOL*</b> The address of a <b>BOOL</b> value that receives a flag indicating whether the shortcut would
///                 be copied. When a shortcut to another shortcut is created, the Shell simply copies the target shortcut and
///                 modifies that copied shortcut appropriately. This parameter receives a nonzero value if the target specified in
///                 <i>pszLinkTo</i> specifies a shortcut that will cause the target shortcut to be copied. This parameter receives
///                 zero if the target does not specify a shortcut that would be copied.
///    uFlags = Type: <b>UINT</b> The options for the function. This can be zero or a combination of the following values.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL SHGetNewLinkInfoW(const(wchar)* pszLinkTo, const(wchar)* pszDir, const(wchar)* pszName, int* pfMustCopy, 
                       uint uFlags);

///Executes a command on a printer object. <div class="alert"><b>Note</b> This function has been deprecated as of
///Windows Vista. It is recommended that, in its place, you invoke verbs on printers through IContextMenu or
///ShellExecute.</div><div> </div>
///Params:
///    hwnd = Type: <b>HWND</b> The handle of the parent window of any windows or dialog boxes that are created during the
///           operation.
///    uAction = Type: <b>UINT</b> The type of printer operation to perform. One of the following values:
///    lpBuf1 = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that contains additional information for the printer
///             command. The information contained in this parameter depends upon the value of <i>uAction</i>.
///    lpBuf2 = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that contains additional information for the printer
///             command. The information contained in this parameter depends upon the value of <i>uAction</i>.
///    fModal = Type: <b>BOOL</b> <b>TRUE</b> to specify that <b>SHInvokePrinterCommand</b> should not return until the command
///             is completed; <b>FALSE</b> if the function should return as soon as the command is initialized.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL SHInvokePrinterCommandA(HWND hwnd, uint uAction, const(char)* lpBuf1, const(char)* lpBuf2, BOOL fModal);

///Executes a command on a printer object. <div class="alert"><b>Note</b> This function has been deprecated as of
///Windows Vista. It is recommended that, in its place, you invoke verbs on printers through IContextMenu or
///ShellExecute.</div><div> </div>
///Params:
///    hwnd = Type: <b>HWND</b> The handle of the parent window of any windows or dialog boxes that are created during the
///           operation.
///    uAction = Type: <b>UINT</b> The type of printer operation to perform. One of the following values:
///    lpBuf1 = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that contains additional information for the printer
///             command. The information contained in this parameter depends upon the value of <i>uAction</i>.
///    lpBuf2 = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that contains additional information for the printer
///             command. The information contained in this parameter depends upon the value of <i>uAction</i>.
///    fModal = Type: <b>BOOL</b> <b>TRUE</b> to specify that <b>SHInvokePrinterCommand</b> should not return until the command
///             is completed; <b>FALSE</b> if the function should return as soon as the command is initialized.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL SHInvokePrinterCommandW(HWND hwnd, uint uAction, const(wchar)* lpBuf1, const(wchar)* lpBuf2, BOOL fModal);

///Signals the Shell that during the next operation requiring overlay information, it should load icon overlay
///identifiers that either failed creation or were not present for creation at startup. Identifiers that have already
///been loaded are not affected.
///Returns:
///    Type: <b>HRESULT</b> Always returns S_OK.
///    
@DllImport("SHELL32")
HRESULT SHLoadNonloadedIconOverlayIdentifiers();

///Determines whether a file or folder is available for offline use. This function also determines whether the file
///would be opened from the network, from the local Offline Files cache, or from both locations.
///Params:
///    pwszPath = Type: <b>PCWSTR</b> A pointer to a string value that specifies the full path to a network file or directory. This
///               path does not need to be in UNC form. If <i>pszPath</i> is not a network path, the function returns E_INVALIDARG.
///    pdwStatus = Type: <b>LPDWORD</b> A pointer to a variable of type <b>DWORD</b> that receives one or more of the following
///                flags if the function succeeds.
///Returns:
///    Type: <b>HRESULT</b> This function can return one of these values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The file
///    or directory is cached. It is available offline unless <b>OFFLINE_STATUS_INCOMPLETE</b> is set. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The path is invalid or not a
///    network path. The file or directory is not cached. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt>
///    </dl> </td> <td width="60%"> The file or directory is not cached. </td> </tr> </table>
///    
@DllImport("SHELL32")
HRESULT SHIsFileAvailableOffline(const(wchar)* pwszPath, uint* pdwStatus);

///Sets the localized name of a file in a Shell folder.
///Params:
///    pszPath = Type: <b>PCWSTR</b> A pointer to a string that specifies the fully qualified path of the target file.
///    pszResModule = Type: <b>PCWSTR</b> A pointer to a string resource that specifies the localized version of the file name.
///    idsRes = Type: <b>int</b> An integer ID that specifies the localized file name in the string resource.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHSetLocalizedName(const(wchar)* pszPath, const(wchar)* pszResModule, int idsRes);

///Removes the localized name of a file in a Shell folder.
///Params:
///    pszPath = Type: <b>PCWSTR</b> A pointer to a null-terminated, Unicode string that specifies the fully qualified path of the
///              target file.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHRemoveLocalizedName(const(wchar)* pszPath);

///Retrieves the localized name of a file in a Shell folder.
///Params:
///    pszPath = Type: <b>PCWSTR</b> A pointer to a string that specifies the fully qualified path of the file.
///    pszResModule = Type: <b>PWSTR</b> When this function returns, contains a pointer to a string resource that specifies the
///                   localized version of the file name.
///    cch = Type: <b>UINT</b> When this function returns, contains the size of the string, in <b>WCHARs</b>, at
///          <i>pszResModule</i>.
///    pidsRes = Type: <b>int*</b> When this function returns, contains a pointer to the ID of the localized file name in the
///              resource file.
@DllImport("SHELL32")
HRESULT SHGetLocalizedName(const(wchar)* pszPath, const(wchar)* pszResModule, uint cch, int* pidsRes);

///<p class="CCE_Message">[<b>ShellMessageBox</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] <b>ShellMessageBox</b> is a special
///instance of MessageBox that provides the option of using the owner window's title as the title of the message box.
///Params:
///    hAppInst = Type: <b>HINSTANCE</b> The handle of the module from which to load a string resource named in <i>pszTitle</i>. If
///               <i>pszTitle</i> does not name a string resource, this parameter is ignored. This value must be valid if
///               <i>pszMsg</i> or <i>pszTitle</i> is a resource ID.
///    hWnd = Type: <b>HWND</b> A handle to the owner window of the message box to be created. If this variable is not
///           <b>NULL</b>, the title of the owner window is used as the title of the message box.
///    lpcText = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains either the message to be displayed or a
///              resource ID specifying where the message is to be retrieved from.
///    lpcTitle = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the dialog box title or a resource ID
///               specifying where the title is to be retrieved. If both this parameter and <i>hWnd</i> are <b>NULL</b>, no title
///               is displayed. If this parameter points to a loadable resource formed with the MAKEINTRESOURCE macro, it overrides
///               <i>hWnd</i> as the title.
///    fuStyle = Type: <b>UINT</b> Specifies the contents and behavior of the dialog box. For possible values, see MessageBox.
///    arg6 = A variable argument list that is combined with <i>pszMsg</i> to form the full text displayed in the message box.
///Returns:
///    Type: <b>int</b> An integer value indicating a button that was pressed in the message box. For specific values,
///    see MessageBox. If the function fails, the return value is zero. To get extended error information, call
///    GetLastError.
///    
@DllImport("SHLWAPI")
int ShellMessageBoxA(HINSTANCE hAppInst, HWND hWnd, const(char)* lpcText, const(char)* lpcTitle, uint fuStyle);

///<p class="CCE_Message">[<b>ShellMessageBox</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] <b>ShellMessageBox</b> is a special
///instance of MessageBox that provides the option of using the owner window's title as the title of the message box.
///Params:
///    hAppInst = Type: <b>HINSTANCE</b> The handle of the module from which to load a string resource named in <i>pszTitle</i>. If
///               <i>pszTitle</i> does not name a string resource, this parameter is ignored. This value must be valid if
///               <i>pszMsg</i> or <i>pszTitle</i> is a resource ID.
///    hWnd = Type: <b>HWND</b> A handle to the owner window of the message box to be created. If this variable is not
///           <b>NULL</b>, the title of the owner window is used as the title of the message box.
///    lpcText = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains either the message to be displayed or a
///              resource ID specifying where the message is to be retrieved from.
///    lpcTitle = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the dialog box title or a resource ID
///               specifying where the title is to be retrieved. If both this parameter and <i>hWnd</i> are <b>NULL</b>, no title
///               is displayed. If this parameter points to a loadable resource formed with the MAKEINTRESOURCE macro, it overrides
///               <i>hWnd</i> as the title.
///    fuStyle = Type: <b>UINT</b> Specifies the contents and behavior of the dialog box. For possible values, see MessageBox.
///    arg6 = A variable argument list that is combined with <i>pszMsg</i> to form the full text displayed in the message box.
///Returns:
///    Type: <b>int</b> An integer value indicating a button that was pressed in the message box. For specific values,
///    see MessageBox. If the function fails, the return value is zero. To get extended error information, call
///    GetLastError.
///    
@DllImport("SHLWAPI")
int ShellMessageBoxW(HINSTANCE hAppInst, HWND hWnd, const(wchar)* lpcText, const(wchar)* lpcTitle, uint fuStyle);

@DllImport("SHELL32")
BOOL IsLFNDriveA(const(char)* pszPath);

@DllImport("SHELL32")
BOOL IsLFNDriveW(const(wchar)* pszPath);

///Enumerates the user accounts that have unread email.
///Params:
///    hKeyUser = Type: <b>HKEY</b> A valid HKEY for a given user.
///    dwIndex = Type: <b>DWORD</b> The index of the user account.
///    pszMailAddress = Type: <b>LPTSTR</b> A pointer to a Unicode string that specifies the email address of an account belonging to the
///                     specified user.
///    cchMailAddress = Type: <b>int</b> The number of characters in the email address.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHEnumerateUnreadMailAccountsW(HKEY hKeyUser, uint dwIndex, const(wchar)* pszMailAddress, 
                                       int cchMailAddress);

///Retrieves a specified user's unread message count for any or all email accounts.
///Params:
///    hKeyUser = Type: <b>HKEY</b> A valid HKEY for a given user. This parameter should be <b>NULL</b> if the function is called
///               in a user's environment, in which case <b>HKEY_CURRENT_USER</b> is used. This parameter should be <b>NULL</b> if
///               the function is called from the SYSTEM context, in which case <b>HKEY_USERS</b>&
///    pszMailAddress = Type: <b>LPCTSTR</b> A pointer to a string in Unicode that specifies the email address of an account belonging to
///                     the specified user. When this parameter is <b>NULL</b>, <i>pdwCount</i> returns the total count of unread
///                     messages for all accounts owned by the designated user.
///    pdwCount = Type: <b>DWORD*</b> Pointer to a DWORD value which receives the unread message count.
///    pFileTime = Type: <b>FILETIME*</b> A pointer to a FILETIME structure. The use of this parameter is determined by whether
///                <i>pszMailAddress</i> is <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, then this parameter is treated as
///                an [in] parameter, which specifies a filter, so that only unread mail newer than the specified time appears. If
///                <i>pszMailAddress</i> is not <b>NULL</b>, then this parameter is treated as an [out] parameter, which points to a
///                <b>FILETIME</b> structure into which the function places the <b>timestamp</b> of the last SHSetUnreadMailCount
///                call for the specified user and email account.
///    pszShellExecuteCommand = Type: <b>LPCTSTR</b> A pointer to a string that returns the ShellExecute command statement passed into the last
///                             SHSetUnreadMailCount call for the specified user and email account. This command string starts the email
///                             application that owns the account referenced by <i>pszMailAddress</i>. If the ShellExecute command is not
///                             required, this parameter can be <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, this parameter is ignored
///                             and must be <b>NULL</b>.
///    cchShellExecuteCommand = Type: <b>int</b> The maximum size, in characters, of the ShellExecute command buffer pointed to by
///                             <i>pszShellExecuteCommand</i>. This parameter must be zero for total counts when <i>pszMailAddress</i> is
///                             <b>NULL</b>. It can also be <b>NULL</b> whenever the ShellExecute command string is not required.
@DllImport("SHELL32")
HRESULT SHGetUnreadMailCountW(HKEY hKeyUser, const(wchar)* pszMailAddress, uint* pdwCount, FILETIME* pFileTime, 
                              const(wchar)* pszShellExecuteCommand, int cchShellExecuteCommand);

///Stores the current user's unread message count for a specified email account in the registry.
///Params:
///    pszMailAddress = Type: <b>LPCTSTR</b> A pointer to a string in Unicode that contains the current user's full email address.
///    dwCount = Type: <b>DWORD</b> The number of unread messages.
///    pszShellExecuteCommand = Type: <b>LPCTSTR</b> A pointer to a string in Unicode that contains the full text of a command that can be passed
///                             to ShellExecute. This command should start the email application that owns the account referenced by
///                             <i>pszMailAddress</i>.
///Returns:
///    Type: <b>HRESULT</b> <b>HRESULT</b>, which includes the following possible values. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
///    The call completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td>
///    <td width="60%"> Insufficient memory available. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid string argument in either the
///    <i>pszMailAddress</i> or <i>pszShellExecuteCommand</i> parameters. </td> </tr> </table>
///    
@DllImport("SHELL32")
HRESULT SHSetUnreadMailCountW(const(wchar)* pszMailAddress, uint dwCount, const(wchar)* pszShellExecuteCommand);

///Uses CheckTokenMembership to test whether the given token is a member of the local group with the specified RID.
///Params:
///    hToken = Type: <b>HANDLE</b> A handle to the token. This value can be <b>NULL</b>.
///    ulRID = Type: <b>ULONG</b> The RID of the local group for which membership is tested.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> on success, <b>FALSE</b> on failure.
///    
@DllImport("SHELL32")
BOOL SHTestTokenMembership(HANDLE hToken, uint ulRID);

///Retrieves an image list.
///Params:
///    iImageList = Type: <b>int</b> The image type contained in the list. One of the following values:
///    riid = Type: <b>REFIID</b> Reference to the image list interface identifier, normally IID_IImageList.
///    ppvObj = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This is
///             typically IImageList.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetImageList(int iImageList, const(GUID)* riid, void** ppvObj);

///Initializes the network address control window class.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if the initialization succeeded; or <b>FALSE</b> otherwise.
///    
@DllImport("SHELL32")
BOOL InitNetworkAddressControl();

///Returns the type of media that is in the given drive.
///Params:
///    pszDrive = Type: <b>PCWSTR</b> The drive in which to check the media type.
///    pdwMediaContent = Type: <b>DWORD*</b> A pointer to the type of media in the given drive. A combination of ARCONTENT flags.
@DllImport("SHELL32")
HRESULT SHGetDriveMedia(const(wchar)* pszDrive, uint* pdwMediaContent);

///Deprecated. Returns a pointer to an ITEMIDLIST structure when passed a path.
///Params:
///    pszPath = Type: <b>PCWSTR</b> A pointer to a null-terminated string that contains the path to be converted to a PIDL.
///Returns:
///    Type: <b>PIDLIST_ABSOLUTE</b> Returns a pointer to an ITEMIDLIST structure if successful, or <b>NULL</b>
///    otherwise.
///    
@DllImport("SHELL32")
ITEMIDLIST* SHSimpleIDListFromPath(const(wchar)* pszPath);

///Creates and initializes a Shell item object from a pointer to an item identifier list (PIDL). The resulting shell
///item object supports the IShellItem interface.
///Params:
///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> The source PIDL.
///    riid = Type: <b>REFIID</b> A reference to the IID of the requested interface.
///    ppv = Type: <b>void**</b> When this function returns, contains the interface pointer requested in riid. This will
///          typically be IShellItem or IShellItem2.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCreateItemFromIDList(ITEMIDLIST* pidl, const(GUID)* riid, void** ppv);

///Creates and initializes a Shell item object from a parsing name.
///Params:
///    pszPath = Type: <b>PCWSTR</b> A pointer to a display name.
///    pbc = Type: <b>IBindCtx*</b> Optional. A pointer to a bind context used to pass parameters as inputs and outputs to the
///          parsing function. These passed parameters are often specific to the data source and are documented by the data
///          source owners. For example, the file system data source accepts the name being parsed (as a WIN32_FIND_DATA
///          structure), using the STR_FILE_SYS_BIND_DATA bind context parameter. STR_PARSE_PREFER_FOLDER_BROWSING can be
///          passed to indicate that URLs are parsed using the file system data source when possible. Construct a bind context
///          object using CreateBindCtx and populate the values using IBindCtx::RegisterObjectParam. See <b>Bind Context
///          String Keys</b> for a complete list of these. See the Parsing With Parameters Sample for an example of the use of
///          this parameter. If no data is being passed to or received from the parsing function, this value can be
///          <b>NULL</b>.
///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>, typically
///           <b>IID_IShellItem</b> or <b>IID_IShellItem2</b>.
///    ppv = Type: <b>void**</b> When this method returns successfully, contains the interface pointer requested in
///          <i>riid</i>. This is typically IShellItem or IShellItem2.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCreateItemFromParsingName(const(wchar)* pszPath, IBindCtx pbc, const(GUID)* riid, void** ppv);

///Create a Shell item, given a parent folder and a child item ID.
///Params:
///    pidlParent = Type: <b>PCIDLIST_ABSOLUTE</b> The IDList of the parent folder of the item being created; the IDList of
///                 <i>psfParent</i>. This parameter can be <b>NULL</b>, if <i>psfParent</i> is specified.
///    psfParent = Type: <b>IShellFolder*</b> A pointer to IShellFolder interface that specifies the shell data source of the child
///                item specified by the <i>pidl</i>.This parameter can be <b>NULL</b>, if <i>pidlParent</i> is specified.
///    pidl = Type: <b>PCUITEMID_CHILD</b> A child item ID relative to its parent folder specified by <i>psfParent</i> or
///           <i>pidlParent</i>.
///    riid = Type: <b>REFIID</b> A reference to an interface ID.
///    ppvItem = Type: <b>void**</b> When this function returns, contains the interface pointer requested in riid. This will
///              typically be IShellItem or IShellItem2.
@DllImport("SHELL32")
HRESULT SHCreateItemWithParent(ITEMIDLIST* pidlParent, IShellFolder psfParent, ITEMIDLIST* pidl, const(GUID)* riid, 
                               void** ppvItem);

///Creates and initializes a Shell item object from a relative parsing name.
///Params:
///    psiParent = Type: <b>IShellItem*</b> A pointer to the parent Shell item.
///    pszName = Type: <b>PCWSTR</b> A pointer to a null-terminated, Unicode string that specifies a display name that is relative
///              to the <i>psiParent</i>.
///    pbc = Type: <b>IBindCtx*</b> A pointer to a bind context that controls the parsing operation. This parameter can be
///          <b>NULL</b>.
///    riid = Type: <b>REFIID</b> A reference to an interface ID.
///    ppv = Type: <b>void**</b> When this function returns, contains the interface pointer requested in riid. This will
///          usually be IShellItem or IShellItem2.
@DllImport("SHELL32")
HRESULT SHCreateItemFromRelativeName(IShellItem psiParent, const(wchar)* pszName, IBindCtx pbc, const(GUID)* riid, 
                                     void** ppv);

///Creates a Shell item object for a single file that exists inside a known folder.
///Params:
///    kfid = Type: <b>REFKNOWNFOLDERID</b> A reference to the KNOWNFOLDERID, a <b>GUID</b> that identifies the folder that
///           contains the item.
///    dwKFFlags = Type: <b>DWORD</b> Flags that specify special options in the object retrieval. This value can be 0; otherwise,
///                one or more of the KNOWN_FOLDER_FLAG values.
///    pszItem = Type: <b>PCWSTR</b> A pointer to a null-terminated buffer that contains the file name of the new item as a
///              Unicode string. This parameter can also be <b>NULL</b>. In this case, an IShellItem that represents the known
///              folder itself is created.
///    riid = Type: <b>REFIID</b> A reference to the IID of the interface that represents the item, retrieved through
///           <i>ppv</i>. This value is typically IID_IShellItem or IID_IShellItem2.
///    ppv = Type: <b>void**</b> When this function returns successfully, contains the interface pointer requested in
///          <i>riid</i>. This is typically IShellItem or IShellItem2.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCreateItemInKnownFolder(const(GUID)* kfid, uint dwKFFlags, const(wchar)* pszItem, const(GUID)* riid, 
                                  void** ppv);

///Retrieves the pointer to an item identifier list (PIDL) of an object.
///Params:
///    punk = Type: <b>IUnknown*</b> A pointer to the IUnknown of the object from which to get the PIDL.
///    ppidl = Type: <b>PIDLIST_ABSOLUTE*</b> When this function returns, contains a pointer to the PIDL of the given object.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetIDListFromObject(IUnknown punk, ITEMIDLIST** ppidl);

///Retrieves an IShellItem for an object.
///Params:
///    punk = Type: <b>IUnknown*</b> A pointer to the IUnknown of the object.
///    riid = Type: <b>REFIID</b> Reference to the desired IID.
///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This is
///          typically IShellItem or a related interface.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetItemFromObject(IUnknown punk, const(GUID)* riid, void** ppv);

///Retrieves the display name of an item identified by its IDList.
///Params:
///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL that identifies the item.
///    sigdnName = Type: <b>SIGDN</b> A value from the SIGDN enumeration that specifies the type of display name to retrieve.
///    ppszName = Type: <b>PWSTR*</b> A value that, when this function returns successfully, receives the address of a pointer to
///               the retrieved display name.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetNameFromIDList(ITEMIDLIST* pidl, SIGDN sigdnName, ushort** ppszName);

///Creates an IShellItem or related object based on an item specified by an IDataObject.
///Params:
///    pdtobj = Type: <b>IDataObject*</b> A pointer to the source IDataObject instance.
///    dwFlags = Type: <b>DATAOBJ_GET_ITEM_FLAGS</b> One or more values from the DATAOBJ_GET_ITEM_FLAGS enumeration to specify
///              options regarding the target object. This value can be 0.
///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>, typically
///           IID_IShellItem.
///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This is
///          typically IShellItem.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetItemFromDataObject(IDataObject pdtobj, DATAOBJ_GET_ITEM_FLAGS dwFlags, const(GUID)* riid, void** ppv);

///Creates a Shell item array object.
///Params:
///    pidlParent = Type: <b>PCIDLIST_ABSOLUTE</b> The ID list of the parent folder of the items specified in <i>ppidl</i>. If
///                 <i>psf</i> is specified, this parameter can be <b>NULL</b>. If this <i>pidlParent</i> is not specified, it is
///                 computed from the <i>psf</i> parameter using IPersistFolder2.
///    psf = Type: <b>IShellFolder*</b> The Shell data source object that is the parent of the child items specified in
///          <i>ppidl</i>. If <i>pidlParent</i> is specified, this parameter can be <b>NULL</b>.
///    cidl = Type: <b>UINT</b> The number of elements in the array specified by <i>ppidl</i>.
///    ppidl = Type: <b>PCUITEMID_CHILD_ARRAY</b> The list of child item IDs for which the array is being created. This value
///            can be <b>NULL</b>.
///    ppsiItemArray = Type: <b>IShellItemArray**</b> When this function returns, contains the address of an IShellItemArray interface
///                    pointer.
@DllImport("SHELL32")
HRESULT SHCreateShellItemArray(ITEMIDLIST* pidlParent, IShellFolder psf, uint cidl, char* ppidl, 
                               IShellItemArray* ppsiItemArray);

///Creates a Shell item array object from a data object.
///Params:
///    pdo = Type: <b>IDataObject*</b> A pointer to IDataObject interface.
///    riid = Type: <b>REFIID</b> A reference to the desired interface ID.
///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This is
///          typically IShellItemArray.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCreateShellItemArrayFromDataObject(IDataObject pdo, const(GUID)* riid, void** ppv);

///Creates a Shell item array object from a list of ITEMIDLIST structures.
///Params:
///    cidl = Type: <b>UINT</b> The number of elements in the array.
///    rgpidl = Type: <b>PCIDLIST_ABSOLUTE_ARRAY</b> A list of <i>cidl</i> constant pointers to ITEMIDLIST structures.
///    ppsiItemArray = Type: <b>IShellItemArray**</b> When this function returns, contains an IShellItemArray interface pointer.
@DllImport("SHELL32")
HRESULT SHCreateShellItemArrayFromIDLists(uint cidl, char* rgpidl, IShellItemArray* ppsiItemArray);

///Creates an array of one element from a single Shell item.
///Params:
///    psi = Type: <b>IShellItem*</b> Pointer to IShellItem object that represents the item.
///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>, typically
///           IID_IShellItemArray.
///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This is
///          typically a pointer to an IShellItemArray.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCreateShellItemArrayFromShellItem(IShellItem psi, const(GUID)* riid, void** ppv);

///Creates an IApplicationAssociationRegistration object based on the stock implementation of the interface provided by
///Windows.
///Params:
///    riid = Type: <b>REFIID</b> A reference to the IID of the requested interface.
///    ppv = Type: <b>void**</b> When this function returns, contains the address of a pointer to the
///          IApplicationAssociationRegistration object.
@DllImport("SHELL32")
HRESULT SHCreateAssociationRegistration(const(GUID)* riid, void** ppv);

///Creates a standard icon extractor, whose defaults can be further configured via the IDefaultExtractIconInit
///interface.
///Params:
///    riid = Type: <b>REFIID</b> A reference to interface ID.
///    ppv = Type: <b>void**</b> The address of IDefaultExtractIconInit interface pointer.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCreateDefaultExtractIcon(const(GUID)* riid, void** ppv);

///Specifies a unique application-defined Application User Model ID (AppUserModelID) that identifies the current process
///to the taskbar. This identifier allows an application to group its associated processes and windows under a single
///taskbar button.
///Params:
///    AppID = Type: <b>PCWSTR</b> Pointer to the AppUserModelID to assign to the current process.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SetCurrentProcessExplicitAppUserModelID(const(wchar)* AppID);

///Retrieves the application-defined, explicit Application User Model ID (AppUserModelID) for the current process.
///Params:
///    AppID = Type: <b>PWSTR*</b> A pointer that receives the address of the AppUserModelID assigned to the process. The caller
///            is responsible for freeing this string with CoTaskMemFree when it is no longer needed.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT GetCurrentProcessExplicitAppUserModelID(ushort** AppID);

///Retrieves the temporary property for the given item. A temporary property is a read/write store that holds properties
///only for the lifetime of the IShellItem object, rather than being persisted back into the item.
///Params:
///    psi = Type: <b>IShellItem*</b> A pointer to the item for which the temporary property is to be retrieved.
///    propkey = Type: <b>REFPROPERTYKEY</b> The property key.
///    ppropvar = Type: <b>PROPVARIANT*</b> A pointer to the temporary property for the item.
@DllImport("SHELL32")
HRESULT SHGetTemporaryPropertyForItem(IShellItem psi, const(PROPERTYKEY)* propkey, PROPVARIANT* ppropvar);

///Sets a temporary property for the specified item. A temporary property is kept in a read/write store that holds
///properties only for the lifetime of the IShellItem object, instead of writing them back into the item.
///Params:
///    psi = Type: <b>IShellItem*</b> A pointer to the item on which the temporary property is to be set.
///    propkey = Type: <b>REFPROPERTYKEY</b> Reference to the PROPERTYKEY that identifies the temporary property that is being
///              set.
///    propvar = Type: <b>REFPROPVARIANT</b> Reference to a PROPVARIANT that contains the value of the temporary property.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHSetTemporaryPropertyForItem(IShellItem psi, const(PROPERTYKEY)* propkey, const(PROPVARIANT)* propvar);

///Shows the library management dialog box, which enables users to manage the library folders and default save location.
///Params:
///    psiLibrary = Type: <b>IShellItem*</b> A pointer to an IShellItem object that represents the library that is to be managed.
///    hwndOwner = Type: <b>HWND</b> The handle for the window that owns the library management dialog box. The value of this
///                parameter can be <b>NULL</b>.
///    pszTitle = Type: <b>LPCWSTR</b> A pointer to the title for the library management dialog. To display the generic title
///               string, set the value of this parameter to <b>NULL</b>.
///    pszInstruction = Type: <b>LPCWSTR</b> A pointer to a help string to display below the title string in the library management
///                     dialog box. To display the generic help string, set the value of this parameter to <b>NULL</b>.
///    lmdOptions = Type: <b>LIBRARYMANAGEDIALOGOPTIONS</b> A value from the LIBRARYMANAGEDIALOGOPTIONS enumeration that specifies
///                 the behavior of the management dialog box.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHShowManageLibraryUI(IShellItem psiLibrary, HWND hwndOwner, const(wchar)* pszTitle, 
                              const(wchar)* pszInstruction, LIBRARYMANAGEDIALOGOPTIONS lmdOptions);

///Resolves all locations in a library, even those locations that have been moved or renamed.
///Params:
///    psiLibrary = Type: <b>IShellItem*</b> A pointer to an IShellItem object that represents the library.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHResolveLibrary(IShellItem psiLibrary);

///Returns an enumeration object for a specified set of file name extension handlers.
///Params:
///    pszExtra = Type: <b>PCWSTR</b> A pointer to a null-terminated buffer that contains a single file type extension, for
///               instance ".jpg". Only handlers associated with the given extension are enumerated. This parameter may not be
///               **NULL**.
///    afFilter = Type: <b>ASSOC_FILTER</b> Specifies the enumeration handler filter applied to the full list of handlers that
///               results from the value given in <i>pszExtra</i>. One of the following values. | Value | Description |
///               |-------|-------------| | ASSOC_FILTER_NONE | Return all handlers. | | ASSOC_FILTER_RECOMMENDED | Return only
///               recommended handlers. A handler sets its recommended status in the registry when it is installed. An initial
///               status of non-recommended can later be promoted to recommended as a result of user action. |
///    ppEnumHandler = Type: <b>IEnumAssocHandlers**</b> When this method returns, contains the address of a pointer to an
///                    IEnumAssocHandlers object.
@DllImport("SHELL32")
HRESULT SHAssocEnumHandlers(const(wchar)* pszExtra, ASSOC_FILTER afFilter, IEnumAssocHandlers* ppEnumHandler);

///Gets an enumeration interface that provides access to handlers associated with a given protocol.
///Params:
///    protocol = Type: <b>PCWSTR</b> Pointer to a string that specifies the protocol.
///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>enumHandlers</i>, typically
///           IID_IEnumAssocHandlers.
///    enumHandlers = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This is
///                   typically IEnumAssocHandlers.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHAssocEnumHandlersForProtocolByApplication(const(wchar)* protocol, const(GUID)* riid, void** enumHandlers);

@DllImport("OLE32")
uint HMONITOR_UserSize(uint* param0, uint param1, ptrdiff_t* param2);

@DllImport("OLE32")
ubyte* HMONITOR_UserMarshal(uint* param0, ubyte* param1, ptrdiff_t* param2);

@DllImport("OLE32")
ubyte* HMONITOR_UserUnmarshal(uint* param0, char* param1, ptrdiff_t* param2);

@DllImport("OLE32")
void HMONITOR_UserFree(uint* param0, ptrdiff_t* param1);

@DllImport("OLE32")
uint HMONITOR_UserSize64(uint* param0, uint param1, ptrdiff_t* param2);

@DllImport("OLE32")
ubyte* HMONITOR_UserMarshal64(uint* param0, ubyte* param1, ptrdiff_t* param2);

@DllImport("OLE32")
ubyte* HMONITOR_UserUnmarshal64(uint* param0, char* param1, ptrdiff_t* param2);

@DllImport("OLE32")
void HMONITOR_UserFree64(uint* param0, ptrdiff_t* param1);

///Creates a file operation that sets the default properties on the Shell item that have not already been set.
///Params:
///    psi = Type: <b>IShellItem*</b> A pointer to the source shell item. See IShellItem.
///    ppFileOp = Type: <b>IFileOperation**</b> The address of the IFileOperation interface pointer.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCreateDefaultPropertiesOp(IShellItem psi, IFileOperation* ppFileOp);

///Applies the default set of properties on a Shell item.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to the item's parent window, which receives error notifications. This value can be
///           <b>NULL</b>.
///    psi = Type: <b>IShellItem*</b> A pointer to the IShellItem object that represents the item.
///    dwFileOpFlags = Type: <b>DWORD</b> Flags that customize the operation. See IFileOperation::SetOperationFlags for flag values.
///    pfops = Type: <b>IFileOperationProgressSink*</b> A pointer to an IFileOperationProgressSink object used to follow the
///            progress of the operation. See IFileOperation::Advise for details. This value can be <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHSetDefaultProperties(HWND hwnd, IShellItem psi, uint dwFileOpFlags, IFileOperationProgressSink pfops);

///<p class="CCE_Message">[<b>SHGetMalloc</b> is available through Windows Vista and Windows Server 2003, but may be
///altered or unavailable in subsequent versions of the operating system or product. See the Remarks section for
///alternate recommendations.] Retrieves a pointer to the Shell's IMalloc interface.
///Params:
///    ppMalloc = Type: <b>LPMALLOC*</b> The address of a pointer that receives the Shell's IMalloc interface pointer.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetMalloc(IMalloc* ppMalloc);

///<p class="CCE_Message">[This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be altered or unavailable in subsequent versions of Windows. Use CoTaskMemAlloc instead.] Allocates memory
///from the Shell's heap.
///Params:
///    cb = Type: <b>SIZE_T</b> The number of bytes of memory to allocate.
///Returns:
///    Type: <b>LPVOID</b> A pointer to the allocated memory.
///    
@DllImport("SHELL32")
void* SHAlloc(size_t cb);

///<p class="CCE_Message">[This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be altered or unavailable in subsequent versions of Windows. Use CoTaskMemFree instead.] Frees the memory
///allocated by SHAlloc.
@DllImport("SHELL32")
void SHFree(void* pv);

///Returns the index of the overlay icon in the system image list.
///Params:
///    pszIconPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length <b>MAX_PATH</b> that contains the
///                  fully qualified path of the file that contains the icon.
///    iIconIndex = Type: <b>int</b> The icon's index in the file pointed to by <i>pszIconPath</i>. To request a standard overlay
///                 icon, set <i>pszIconPath</i> to <b>NULL</b>, and <i>iIconIndex</i> to one of the following:
///Returns:
///    Type: <b>int</b> Returns the index of the overlay icon in the system image list if successful, or -1 otherwise.
///    
@DllImport("SHELL32")
int SHGetIconOverlayIndexA(const(char)* pszIconPath, int iIconIndex);

///Returns the index of the overlay icon in the system image list.
///Params:
///    pszIconPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length <b>MAX_PATH</b> that contains the
///                  fully qualified path of the file that contains the icon.
///    iIconIndex = Type: <b>int</b> The icon's index in the file pointed to by <i>pszIconPath</i>. To request a standard overlay
///                 icon, set <i>pszIconPath</i> to <b>NULL</b>, and <i>iIconIndex</i> to one of the following:
///Returns:
///    Type: <b>int</b> Returns the index of the overlay icon in the system image list if successful, or -1 otherwise.
///    
@DllImport("SHELL32")
int SHGetIconOverlayIndexW(const(wchar)* pszIconPath, int iIconIndex);

///Clones an ITEMIDLIST structure.
///Params:
///    pidl = Type: <b>PCUIDLIST_RELATIVE</b> A pointer to the ITEMIDLIST structure to be cloned.
///Returns:
///    Type: <b>PIDLIST_RELATIVE</b> Returns a pointer to a copy of the ITEMIDLIST structure pointed to by <i>pidl</i>.
///    
@DllImport("SHELL32")
ITEMIDLIST* ILClone(ITEMIDLIST* pidl);

///Clones the first SHITEMID structure in an ITEMIDLIST structure.
///Params:
///    pidl = Type: <b>PCUIDLIST_RELATIVE</b> A pointer to the ITEMIDLIST structure that you want to clone.
///Returns:
///    Type: <b>PITEMID_CHILD</b> A pointer to an ITEMIDLIST structure that contains the first SHITEMID structure from
///    the <b>ITEMIDLIST</b> structure specified by <i>pidl</i>. Returns <b>NULL</b> on failure.
///    
@DllImport("SHELL32")
ITEMIDLIST* ILCloneFirst(ITEMIDLIST* pidl);

///Combines two ITEMIDLIST structures.
///Params:
///    pidl1 = Type: <b>PCIDLIST_ABSOLUTE</b> A pointer to the first ITEMIDLIST structure.
///    pidl2 = Type: <b>PCUIDLIST_RELATIVE</b> A pointer to the second ITEMIDLIST structure. This structure is appended to the
///            structure pointed to by <i>pidl1</i>.
@DllImport("SHELL32")
ITEMIDLIST* ILCombine(ITEMIDLIST* pidl1, ITEMIDLIST* pidl2);

///Frees an ITEMIDLIST structure allocated by the Shell.
///Params:
///    pidl = Type: <b>PIDLIST_RELATIVE</b> A pointer to the ITEMIDLIST structure to be freed. This parameter can be
///           <b>NULL</b>.
@DllImport("SHELL32")
void ILFree(ITEMIDLIST* pidl);

///Retrieves the next SHITEMID structure in an ITEMIDLIST structure.
///Params:
///    pidl = Type: <b>PCUIDLIST_RELATIVE</b> A pointer to a particular SHITEMID structure in a larger ITEMIDLIST structure.
@DllImport("SHELL32")
ITEMIDLIST* ILGetNext(ITEMIDLIST* pidl);

///Returns the size, in bytes, of an ITEMIDLIST structure.
///Params:
///    pidl = Type: <b>PCUIDLIST_RELATIVE</b> A pointer to an ITEMIDLIST structure.
@DllImport("SHELL32")
uint ILGetSize(ITEMIDLIST* pidl);

///Determines whether a specified ITEMIDLIST structure is the child of another <b>ITEMIDLIST</b> structure.
///Params:
///    pidlParent = Type: <b>PCIDLIST_ABSOLUTE</b> A pointer to the parent ITEMIDLIST structure.
///    pidlChild = Type: <b>PCIDLIST_ABSOLUTE</b> A pointer to the child ITEMIDLIST structure.
@DllImport("SHELL32")
ITEMIDLIST* ILFindChild(ITEMIDLIST* pidlParent, ITEMIDLIST* pidlChild);

///Returns a pointer to the last SHITEMID structure in an ITEMIDLIST structure.
///Params:
///    pidl = Type: <b>PCUIDLIST_RELATIVE</b> A pointer to an ITEMIDLIST structure.
///Returns:
///    Type: <b>PUITEMID_CHILD</b> A pointer to the last SHITEMID structure in <i>pidl</i>.
///    
@DllImport("SHELL32")
ITEMIDLIST* ILFindLastID(ITEMIDLIST* pidl);

///Removes the last SHITEMID structure from an ITEMIDLIST structure.
///Params:
///    pidl = Type: <b>PUIDLIST_RELATIVE</b> A pointer to the ITEMIDLIST structure to be shortened. When the function returns,
///           this variable points to the shortened structure.
@DllImport("SHELL32")
BOOL ILRemoveLastID(ITEMIDLIST* pidl);

///Tests whether two ITEMIDLIST structures are equal in a binary comparison.
///Params:
///    pidl1 = Type: <b>PCIDLIST_ABSOLUTE</b> The first ITEMIDLIST structure.
///    pidl2 = Type: <b>PCIDLIST_ABSOLUTE</b> The second ITEMIDLIST structure.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the two structures are equal, <b>FALSE</b> otherwise.
///    
@DllImport("SHELL32")
BOOL ILIsEqual(ITEMIDLIST* pidl1, ITEMIDLIST* pidl2);

///Tests whether an ITEMIDLIST structure is the parent of another <b>ITEMIDLIST</b> structure.
///Params:
///    pidl1 = Type: <b>PCIDLIST_ABSOLUTE</b> A pointer to an ITEMIDLIST (PIDL) structure that specifies the parent. This must
///            be an absolute PIDL.
///    pidl2 = Type: <b>PCIDLIST_ABSOLUTE</b> A pointer to an ITEMIDLIST (PIDL) structure that specifies the child. This must be
///            an absolute PIDL.
///    fImmediate = Type: <b>BOOL</b> A Boolean value that is set to <b>TRUE</b> to test for immediate parents of <i>pidl2</i>, or
///                 <b>FALSE</b> to test for any parents of <i>pidl2</i>.
@DllImport("SHELL32")
BOOL ILIsParent(ITEMIDLIST* pidl1, ITEMIDLIST* pidl2, BOOL fImmediate);

///Saves an ITEMIDLIST structure to a stream.
///Params:
///    pstm = Type: <b>IStream *</b> A pointer to the IStream interface where the ITEMIDLIST is saved.
///    pidl = Type: <b>PCUIDLIST_RELATIVE</b> A pointer to the ITEMIDLIST structure to be saved.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
///    
@DllImport("SHELL32")
HRESULT ILSaveToStream(IStream pstm, ITEMIDLIST* pidl);

///<p class="CCE_Message">[<b>ILLoadFromStreamEx(IStream*, PITEMID_CHILD*)</b> is available for use in the operating
///systems specified in the Requirements section. It may be altered or unavailable in subsequent versions.] Loads a
///child pointer to an item identifier list (PIDL) from an IStream.
///Params:
///    pstm = Type: <b>IStream*</b> A pointer to the IStream interface from which the child PIDL loads.
///    ppidl = Type: <b>PITEMID_CHILD*</b> When this function returns and succeeds, contains a child PIDL, which contains
///            exactly one <b>SHITEMID</b> structure. If it fails, contains <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT ILLoadFromStreamEx(IStream pstm, ITEMIDLIST** pidl);

///Returns the ITEMIDLIST structure associated with a specified file path.
///Params:
///    pszPath = Type: <b>PCTSTR</b> A pointer to a null-terminated Unicode string that contains the path. This string should be
///              no more than MAX_PATH characters in length, including the terminating null character.
///Returns:
///    Type: <b>PIDLIST_ABSOLUTE</b> Returns a pointer to an ITEMIDLIST structure that corresponds to the path.
///    
@DllImport("SHELL32")
ITEMIDLIST* ILCreateFromPathA(const(char)* pszPath);

///Returns the ITEMIDLIST structure associated with a specified file path.
///Params:
///    pszPath = Type: <b>PCTSTR</b> A pointer to a null-terminated Unicode string that contains the path. This string should be
///              no more than MAX_PATH characters in length, including the terminating null character.
///Returns:
///    Type: <b>PIDLIST_ABSOLUTE</b> Returns a pointer to an ITEMIDLIST structure that corresponds to the path.
///    
@DllImport("SHELL32")
ITEMIDLIST* ILCreateFromPathW(const(wchar)* pszPath);

///<p class="CCE_Message">[<b>SHILCreateFromPath</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Applications should use
///SHParseDisplayName instead] Creates a pointer to an item identifier list (PIDL) from a path.
///Params:
///    pszPath = Type: <b>PCWSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH containing the path to be
///              converted.
///    ppidl = Type: <b>PIDLIST_ABSOLUTE*</b> The path in <i>pszPath</i> expressed as a PIDL.
///    rgfInOut = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> value that, on entry, indicates any attributes of the folder
///               named in <i>pszPath</i> that the calling application would like to retrieve along with the PIDL. On exit, this
///               value contains those requested attributes. For a list of possible attribute flags for this parameter, see
///               IShellFolder::GetAttributesOf.
@DllImport("SHELL32")
HRESULT SHILCreateFromPath(const(wchar)* pszPath, ITEMIDLIST** ppidl, uint* rgfInOut);

///Appends or prepends an SHITEMID structure to an ITEMIDLIST structure.
///Params:
///    pidl = Type: <b>PIDLIST_RELATIVE</b> A pointer to an ITEMIDLIST structure. When the function returns, the SHITEMID
///           structure specified by <i>pmkid</i> is appended or prepended.
///    pmkid = Type: <b>LPSHITEMID</b> A pointer to a SHITEMID structure to be appended or prepended to <i>pidl</i>.
///    fAppend = Type: <b>BOOL</b> Value that is set to <b>TRUE</b> to append <i>pmkid</i> to <i>pidl</i>. Set this value to
///              <b>FALSE</b> to prepend <i>pmkid</i> to <i>pidl</i>.
@DllImport("SHELL32")
ITEMIDLIST* ILAppendID(ITEMIDLIST* pidl, SHITEMID* pmkid, BOOL fAppend);

///Converts an item identifier list to a file system path. This function extends SHGetPathFromIDList by allowing you to
///set the initial size of the string buffer and declare the options below.
///Params:
///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> A pointer to an item identifier list that specifies a file or directory location
///           relative to the root of the namespace (the desktop).
///    pszPath = Type: <b>PWSTR</b> When this function is called it is passed a null-terminated, Unicode buffer to receive the
///              file system path. This buffer is of size <i>cchPath</i>. When this function returns, contains the address of a
///              null-terminated, Unicode buffer that contains the file system path. This buffer is of size <i>cchPath</i>.
///    cchPath = Type: <b>DWORD</b> The size of the buffer pointed to by <i>pszPath</i>, in characters.
///    uOpts = Type: <b>GPFIDL_FLAGS</b> These flags determine the type of path returned.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL SHGetPathFromIDListEx(ITEMIDLIST* pidl, const(wchar)* pszPath, uint cchPath, int uOpts);

///Converts an item identifier list to a file system path.
///Params:
///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> The address of an item identifier list that specifies a file or directory location
///           relative to the root of the namespace (the desktop).
///    pszPath = Type: <b>LPTSTR</b> The address of a buffer to receive the file system path. This buffer must be at least
///              MAX_PATH characters in size.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL SHGetPathFromIDListA(ITEMIDLIST* pidl, const(char)* pszPath);

///Converts an item identifier list to a file system path.
///Params:
///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> The address of an item identifier list that specifies a file or directory location
///           relative to the root of the namespace (the desktop).
///    pszPath = Type: <b>LPTSTR</b> The address of a buffer to receive the file system path. This buffer must be at least
///              MAX_PATH characters in size.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL SHGetPathFromIDListW(ITEMIDLIST* pidl, const(wchar)* pszPath);

///<p class="CCE_Message">[<b>SHCreateDirectory</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Creates a new file system folder.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to a parent window. This parameter can be set to <b>NULL</b> if no user interface is
///           displayed.
///    pszPath = Type: <b>PCWSTR</b> A pointer to a null-terminated Unicode string that contains the fully qualified path of the
///              directory. This string should have no more than MAX_PATH characters, including the terminating null character.
///Returns:
///    Type: <b>int</b> Returns <b>ERROR_SUCCESS</b> if successful. If the operation fails, other error codes can be
///    returned, including those listed here. For values not specifically listed, see System Error Codes. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_PATHNAME</b></dt>
///    </dl> </td> <td width="60%"> The <i>pszPath</i> parameter was set to a relative path. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_FILENAME_EXCED_RANGE</b></dt> </dl> </td> <td width="60%"> The path pointed to by
///    <i>pszPath</i> is too long. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_EXISTS</b></dt> </dl> </td>
///    <td width="60%"> The directory exists. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td> <td width="60%"> The directory exists. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_CANCELLED</b></dt> </dl> </td> <td width="60%"> The user canceled the operation.
///    </td> </tr> </table>
///    
@DllImport("SHELL32")
int SHCreateDirectory(HWND hwnd, const(wchar)* pszPath);

///<p class="CCE_Message">[This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be altered or unavailable in subsequent versions of Windows.] Creates a new file system folder, with
///optional security attributes.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to a parent window. This parameter can be set to <b>NULL</b> if no user interface will
///           be displayed.
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string specifying the fully qualified path of the directory.
///              This string is of maximum length of 248 characters, including the terminating null character.
///    psa = Type: <b>const SECURITY_ATTRIBUTES*</b> A pointer to a SECURITY_ATTRIBUTES structure with the directory's
///          security attribute. Set this parameter to <b>NULL</b> if no security attributes need to be set.
///Returns:
///    Type: <b>int</b> Returns <b>ERROR_SUCCESS</b> if successful. If the operation fails, other error codes can be
///    returned, including those listed here. For values not specifically listed, see System Error Codes. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_PATHNAME</b></dt>
///    </dl> </td> <td width="60%"> The <i>pszPath</i> parameter was set to a relative path. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_FILENAME_EXCED_RANGE</b></dt> </dl> </td> <td width="60%"> The path pointed to by
///    <i>pszPath</i> is too long. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl>
///    </td> <td width="60%"> The system cannot find the path pointed to by <i>pszPath</i>. The path may contain an
///    invalid entry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_EXISTS</b></dt> </dl> </td> <td
///    width="60%"> The directory exists. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt>
///    </dl> </td> <td width="60%"> The directory exists. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_CANCELLED</b></dt> </dl> </td> <td width="60%"> The user canceled the operation. </td> </tr>
///    </table>
///    
@DllImport("SHELL32")
int SHCreateDirectoryExA(HWND hwnd, const(char)* pszPath, const(SECURITY_ATTRIBUTES)* psa);

///<p class="CCE_Message">[This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be altered or unavailable in subsequent versions of Windows.] Creates a new file system folder, with
///optional security attributes.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to a parent window. This parameter can be set to <b>NULL</b> if no user interface will
///           be displayed.
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string specifying the fully qualified path of the directory.
///              This string is of maximum length of 248 characters, including the terminating null character.
///    psa = Type: <b>const SECURITY_ATTRIBUTES*</b> A pointer to a SECURITY_ATTRIBUTES structure with the directory's
///          security attribute. Set this parameter to <b>NULL</b> if no security attributes need to be set.
///Returns:
///    Type: <b>int</b> Returns <b>ERROR_SUCCESS</b> if successful. If the operation fails, other error codes can be
///    returned, including those listed here. For values not specifically listed, see System Error Codes. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_PATHNAME</b></dt>
///    </dl> </td> <td width="60%"> The <i>pszPath</i> parameter was set to a relative path. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_FILENAME_EXCED_RANGE</b></dt> </dl> </td> <td width="60%"> The path pointed to by
///    <i>pszPath</i> is too long. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl>
///    </td> <td width="60%"> The system cannot find the path pointed to by <i>pszPath</i>. The path may contain an
///    invalid entry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_EXISTS</b></dt> </dl> </td> <td
///    width="60%"> The directory exists. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt>
///    </dl> </td> <td width="60%"> The directory exists. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_CANCELLED</b></dt> </dl> </td> <td width="60%"> The user canceled the operation. </td> </tr>
///    </table>
///    
@DllImport("SHELL32")
int SHCreateDirectoryExW(HWND hwnd, const(wchar)* pszPath, const(SECURITY_ATTRIBUTES)* psa);

///Opens a Windows Explorer window with specified items in a particular folder selected.
///Params:
///    pidlFolder = Type: <b>PCIDLIST_ABSOLUTE</b> A pointer to a fully qualified item ID list that specifies the folder.
///    cidl = Type: <b>UINT</b> A count of items in the selection array, <i>apidl</i>. If <i>cidl</i> is zero, then
///           <i>pidlFolder</i> must point to a fully specified ITEMIDLIST describing a single item to select. This function
///           opens the parent folder and selects that item.
///    apidl = Type: <b>PCUITEMID_CHILD_ARRAY</b> A pointer to an array of PIDL structures, each of which is an item to select
///            in the target folder referenced by <i>pidlFolder</i>.
///    dwFlags = Type: <b>DWORD</b> The optional flags. Under Windows XP this parameter is ignored. In Windows Vista, the
///              following flags are defined.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHOpenFolderAndSelectItems(ITEMIDLIST* pidlFolder, uint cidl, char* apidl, uint dwFlags);

///Creates an IShellItem object. <div class="alert"><b>Note</b> It is recommended that you use SHCreateItemWithParent or
///SHCreateItemFromIDList instead of this function.</div><div> </div>
///Params:
///    pidlParent = Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL to the parent. This value can be <b>NULL</b>.
///    psfParent = Type: <b>IShellFolder*</b> A pointer to the parent IShellFolder. This value can be <b>NULL</b>.
///    pidl = Type: <b>PCUITEMID_CHILD</b> A PIDL to the requested item. If parent information is not included in
///           <i>pidlParent</i> or <i>psfParent</i>, this must be an absolute PIDL.
///    ppsi = Type: <b>IShellItem**</b> When this method returns, contains the interface pointer to the new IShellItem.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCreateShellItem(ITEMIDLIST* pidlParent, IShellFolder psfParent, ITEMIDLIST* pidl, IShellItem* ppsi);

///<p class="CCE_Message">[<b>SHGetSpecialFolderLocation</b> is not supported and may be altered or unavailable in the
///future. Instead, use SHGetFolderLocation.] Retrieves a pointer to the ITEMIDLIST structure of a special folder.
///Params:
///    hwnd = Type: <b>HWND</b> Reserved.
///    csidl = Type: <b>int</b> A CSIDL value that identifies the folder of interest.
///    ppidl = Type: <b>PIDLIST_ABSOLUTE*</b> A PIDL specifying the folder's location relative to the root of the namespace (the
///            desktop). It is the responsibility of the calling application to free the returned IDList by using CoTaskMemFree.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetSpecialFolderLocation(HWND hwnd, int csidl, ITEMIDLIST** ppidl);

///<p class="CCE_Message">[<b>SHCloneSpecialIDList</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Instead, use
///SHGetSpecialFolderLocation.] Retrieves a pointer to the ITEMIDLIST structure that specifies a special folder.
///Params:
///    hwnd = Type: <b>HWND</b> Reserved.
///    csidl = Type: <b>int</b> A CSIDL value that identifies the folder of interest.
///    fCreate = Type: <b>BOOL</b> A value of type <b>BOOL</b> that indicates if the folder should be created if it does not
///              already exist. If <i>fCreate</i> is <b>TRUE</b>, the folder is created. If it is <b>FALSE</b>, the folder is not
///              created.
///Returns:
///    Type: <b>PIDLIST_ABSOLUTE</b> Returns a pointer to the ITEMIDLIST structure of a special folder specified by
///    <i>csidl</i>. The function creates the folder if <i>fCreate</i> is <b>TRUE</b>.
///    
@DllImport("SHELL32")
ITEMIDLIST* SHCloneSpecialIDList(HWND hwnd, int csidl, BOOL fCreate);

///<p class="CCE_Message">[<b>SHGetSpecialFolderPath</b> is not supported. Instead, use SHGetFolderPath.] Retrieves the
///path of a special folder, identified by its CSIDL.
///Params:
///    hwnd = Type: <b>HWND</b> Reserved.
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string that receives the drive and path of the specified
///              folder. This buffer must be at least MAX_PATH characters in size.
///    csidl = Type: <b>int</b> A CSIDL that identifies the folder of interest. If a virtual folder is specified, this function
///            will fail.
///    fCreate = Type: <b>BOOL</b> Indicates whether the folder should be created if it does not already exist. If this value is
///              nonzero, the folder is created. If this value is zero, the folder is not created.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL SHGetSpecialFolderPathA(HWND hwnd, const(char)* pszPath, int csidl, BOOL fCreate);

///<p class="CCE_Message">[<b>SHGetSpecialFolderPath</b> is not supported. Instead, use SHGetFolderPath.] Retrieves the
///path of a special folder, identified by its CSIDL.
///Params:
///    hwnd = Type: <b>HWND</b> Reserved.
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string that receives the drive and path of the specified
///              folder. This buffer must be at least MAX_PATH characters in size.
///    csidl = Type: <b>int</b> A CSIDL that identifies the folder of interest. If a virtual folder is specified, this function
///            will fail.
///    fCreate = Type: <b>BOOL</b> Indicates whether the folder should be created if it does not already exist. If this value is
///              nonzero, the folder is created. If this value is zero, the folder is not created.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL SHGetSpecialFolderPathW(HWND hwnd, const(wchar)* pszPath, int csidl, BOOL fCreate);

///<p class="CCE_Message">[<b>SHFlushSFCache</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Flushes the special folder cache.
@DllImport("SHELL32")
void SHFlushSFCache();

///Deprecated. Gets the path of a folder identified by a CSIDL value. <div class="alert"><b>Note</b> As of Windows
///Vista, this function is merely a wrapper for SHGetKnownFolderPath. The CSIDL value is translated to its associated
///KNOWNFOLDERID and then <b>SHGetKnownFolderPath</b> is called. New applications should use the known folder system
///rather than the older CSIDL system, which is supported only for backward compatibility.</div><div> </div>
///Params:
///    hwnd = Type: <b>HWND</b> Reserved.
///    csidl = Type: <b>int</b> A CSIDL value that identifies the folder whose path is to be retrieved. Only real folders are
///            valid. If a virtual folder is specified, this function fails. You can force creation of a folder by combining the
///            folder's <b>CSIDL</b> with <b>CSIDL_FLAG_CREATE</b>.
///    hToken = Type: <b>HANDLE</b> An access token that can be used to represent a particular user. <b>Microsoft Windows 2000
///             and earlier:</b> Always set this parameter to <b>NULL</b>. <b>Windows XP and later:</b> This parameter is usually
///             set to <b>NULL</b>, but you might need to assign a non-<b>NULL</b> value to <i>hToken</i> for those folders that
///             can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type
///             is <b>Documents</b>. The calling process is responsible for correct impersonation when <i>hToken</i> is
///             non-<b>NULL</b>. The calling process must have appropriate security privileges for the particular user, including
///             TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See Access Control for
///             further discussion of access control issues. Assigning the <i>hToken</i> parameter a value of -1 indicates the
///             Default User. This enables clients of <b>SHGetFolderPath</b> to find folder locations (such as the Desktop
///             folder) for the Default User. The Default User user profile is duplicated when any new user account is created,
///             and includes special folders such as My Documents and Desktop. Any items added to the Default User folder also
///             appear in any new user account.
///    dwFlags = Type: <b>DWORD</b> Flags that specify the path to be returned. This value is used in cases where the folder
///              associated with a KNOWNFOLDERID (or CSIDL) can be moved, renamed, redirected, or roamed across languages by a
///              user or administrator. The known folder system that underlies <b>SHGetFolderPath</b> allows users or
///              administrators to redirect a known folder to a location that suits their needs. This is achieved by calling
///              IKnownFolderManager::Redirect, which sets the "current" value of the folder associated with the
///              SHGFP_TYPE_CURRENT flag. The default value of the folder, which is the location of the folder if a user or
///              administrator had not redirected it elsewhere, is retrieved by specifying the SHGFP_TYPE_DEFAULT flag. This value
///              can be used to implement a "restore defaults" feature for a known folder. For example, the default value
///              (SHGFP_TYPE_DEFAULT) for FOLDERID_Music (CSIDL_MYMUSIC) is "C:\Users&
///    pszPath = Type: <b>LPTSTR</b> A pointer to a <b>null</b>-terminated string of length MAX_PATH which will receive the path.
///              If an error occurs or S_FALSE is returned, this string will be empty. The returned path does not include a
///              trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\".
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, uint dwFlags, const(char)* pszPath);

///Deprecated. Gets the path of a folder identified by a CSIDL value. <div class="alert"><b>Note</b> As of Windows
///Vista, this function is merely a wrapper for SHGetKnownFolderPath. The CSIDL value is translated to its associated
///KNOWNFOLDERID and then <b>SHGetKnownFolderPath</b> is called. New applications should use the known folder system
///rather than the older CSIDL system, which is supported only for backward compatibility.</div><div> </div>
///Params:
///    hwnd = Type: <b>HWND</b> Reserved.
///    csidl = Type: <b>int</b> A CSIDL value that identifies the folder whose path is to be retrieved. Only real folders are
///            valid. If a virtual folder is specified, this function fails. You can force creation of a folder by combining the
///            folder's <b>CSIDL</b> with <b>CSIDL_FLAG_CREATE</b>.
///    hToken = Type: <b>HANDLE</b> An access token that can be used to represent a particular user. <b>Microsoft Windows 2000
///             and earlier:</b> Always set this parameter to <b>NULL</b>. <b>Windows XP and later:</b> This parameter is usually
///             set to <b>NULL</b>, but you might need to assign a non-<b>NULL</b> value to <i>hToken</i> for those folders that
///             can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type
///             is <b>Documents</b>. The calling process is responsible for correct impersonation when <i>hToken</i> is
///             non-<b>NULL</b>. The calling process must have appropriate security privileges for the particular user, including
///             TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See Access Control for
///             further discussion of access control issues. Assigning the <i>hToken</i> parameter a value of -1 indicates the
///             Default User. This enables clients of <b>SHGetFolderPath</b> to find folder locations (such as the Desktop
///             folder) for the Default User. The Default User user profile is duplicated when any new user account is created,
///             and includes special folders such as My Documents and Desktop. Any items added to the Default User folder also
///             appear in any new user account.
///    dwFlags = Type: <b>DWORD</b> Flags that specify the path to be returned. This value is used in cases where the folder
///              associated with a KNOWNFOLDERID (or CSIDL) can be moved, renamed, redirected, or roamed across languages by a
///              user or administrator. The known folder system that underlies <b>SHGetFolderPath</b> allows users or
///              administrators to redirect a known folder to a location that suits their needs. This is achieved by calling
///              IKnownFolderManager::Redirect, which sets the "current" value of the folder associated with the
///              SHGFP_TYPE_CURRENT flag. The default value of the folder, which is the location of the folder if a user or
///              administrator had not redirected it elsewhere, is retrieved by specifying the SHGFP_TYPE_DEFAULT flag. This value
///              can be used to implement a "restore defaults" feature for a known folder. For example, the default value
///              (SHGFP_TYPE_DEFAULT) for FOLDERID_Music (CSIDL_MYMUSIC) is "C:\Users&
///    pszPath = Type: <b>LPWSTR</b> A pointer to a <b>null</b>-terminated string of length MAX_PATH which will receive the path.
///              If an error occurs or S_FALSE is returned, this string will be empty. The returned path does not include a
///              trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\\".
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, uint dwFlags, const(wchar)* pszPath);

///Deprecated. Retrieves the path of a folder as an ITEMIDLIST structure.
///Params:
///    hwnd = Type: <b>HWND</b> Reserved.
///    csidl = Type: <b>int</b> A CSIDL value that identifies the folder to be located. The folders associated with the CSIDLs
///            might not exist on a particular system.
///    hToken = Type: <b>HANDLE</b> An access token that can be used to represent a particular user. It is usually set to
///             <b>NULL</b>, but it may be needed when there are multiple users for those folders that are treated as belonging
///             to a single user. The most commonly used folder of this type is <b>My Documents</b>. The calling application is
///             responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. It must have appropriate security
///             privileges for the particular user, and the user's registry hive must be currently mounted. See Access Control
///             for further discussion of access control issues. Assigning the <i>hToken</i> parameter a value of -1 indicates
///             the Default User. This allows clients of <b>SHGetFolderLocation</b> to find folder locations (such as the Desktop
///             folder) for the Default User. The Default User user profile is duplicated when any new user account is created,
///             and includes special folders such as <b>My Documents</b> and <b>Desktop</b>. Any items added to the Default User
///             folder also appear in any new user account.
///    dwFlags = Type: <b>DWORD</b>
///    ppidl = Type: <b>PIDLIST_ABSOLUTE*</b> The address of a pointer to an item identifier list structure that specifies the
///            folder's location relative to the root of the namespace (the desktop). The <i>ppidl</i> parameter is set to
///            <b>NULL</b> on failure. The calling application is responsible for freeing this resource by calling ILFree.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following: <table>
///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)</b></dt> </dl> </td> <td width="60%"> The CSIDL in <i>nFolder</i>
///    is valid but the folder does not exist. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
///    </td> <td width="60%"> The CSIDL in <i>nFolder</i> is not valid. </td> </tr> </table>
///    
@DllImport("SHELL32")
HRESULT SHGetFolderLocation(HWND hwnd, int csidl, HANDLE hToken, uint dwFlags, ITEMIDLIST** ppidl);

///Deprecated. Assigns a new path to a system folder identified by its CSIDL.
///Params:
///    csidl = Type: <b>int</b> A CSIDL value that identifies the folder whose path is to be set. Only physical folders are
///            valid. If a virtual folder is specified, this function fails. Add the CSIDL_FLAG_DONT_UNEXPAND value to the CSIDL
///            to ensure that the string is written to the registry exactly as provided. If the CSIDL_FLAG_DONT_UNEXPAND flag is
///            not included, portions of the path may be replaced by environment strings, such as %USERPROFILE%.
///    hToken = Type: <b>HANDLE</b> An access token that can be used to represent a particular user. This parameter is usually
///             set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder.
///             However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are
///             treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>. The
///             calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have
///             appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the
///             user's registry hive must be currently mounted. See Access Control for further discussion of access control
///             issues.
///    dwFlags = Type: <b>DWORD</b> Reserved. Must be set to 0.
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the folder's new
///              path. This value cannot be <b>NULL</b>, and the string cannot be of zero length.
///Returns:
///    Type: <b>HRESULT</b> Returns standard <b>HRESULT</b> codes, including the following: <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
///    The folder's path was successfully updated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
///    </dl> </td> <td width="60%"> Several error conditions cause the return of this value, including the following:
///    <ul> <li>The <i>csidl</i> value is not valid.</li> <li>The <i>csidl</i> value does not refer to a virtual
///    folder.</li> <li>The <i>csidl</i> value does not refer to a system folder.</li> <li>The <i>csidl</i> value refers
///    to a folder that cannot be renamed or moved.</li> <li>The <i>dwFlags</i> value is not 0 (zero).</li> <li>The
///    <i>pszPath</i> value is <b>NULL</b>.</li> <li>The string pointed to by <i>pszPath</i> value is an empty string
///    ("") of length zero.</li> </ul> </td> </tr> </table>
///    
@DllImport("SHELL32")
HRESULT SHSetFolderPathA(int csidl, HANDLE hToken, uint dwFlags, const(char)* pszPath);

///Deprecated. Assigns a new path to a system folder identified by its CSIDL.
///Params:
///    csidl = Type: <b>int</b> A CSIDL value that identifies the folder whose path is to be set. Only physical folders are
///            valid. If a virtual folder is specified, this function fails. Add the CSIDL_FLAG_DONT_UNEXPAND value to the CSIDL
///            to ensure that the string is written to the registry exactly as provided. If the CSIDL_FLAG_DONT_UNEXPAND flag is
///            not included, portions of the path may be replaced by environment strings, such as %USERPROFILE%.
///    hToken = Type: <b>HANDLE</b> An access token that can be used to represent a particular user. This parameter is usually
///             set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder.
///             However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are
///             treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>. The
///             calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have
///             appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the
///             user's registry hive must be currently mounted. See Access Control for further discussion of access control
///             issues.
///    dwFlags = Type: <b>DWORD</b> Reserved. Must be set to 0.
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the folder's new
///              path. This value cannot be <b>NULL</b>, and the string cannot be of zero length.
///Returns:
///    Type: <b>HRESULT</b> Returns standard <b>HRESULT</b> codes, including the following: <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
///    The folder's path was successfully updated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
///    </dl> </td> <td width="60%"> Several error conditions cause the return of this value, including the following:
///    <ul> <li>The <i>csidl</i> value is not valid.</li> <li>The <i>csidl</i> value does not refer to a virtual
///    folder.</li> <li>The <i>csidl</i> value does not refer to a system folder.</li> <li>The <i>csidl</i> value refers
///    to a folder that cannot be renamed or moved.</li> <li>The <i>dwFlags</i> value is not 0 (zero).</li> <li>The
///    <i>pszPath</i> value is <b>NULL</b>.</li> <li>The string pointed to by <i>pszPath</i> value is an empty string
///    ("") of length zero.</li> </ul> </td> </tr> </table>
///    
@DllImport("SHELL32")
HRESULT SHSetFolderPathW(int csidl, HANDLE hToken, uint dwFlags, const(wchar)* pszPath);

///Gets the path of a folder and appends a user-provided subfolder path.
///Params:
///    hwnd = Type: <b>HWND</b> Reserved.
///    csidl = Type: <b>int</b> A CSIDL value that identifies the folder whose path is to be retrieved. Only real folders are
///            valid. If a virtual folder is specified, this function fails. You can force creation of a folder with
///            <b>SHGetFolderPathAndSubDir</b> by combining the folder's <b>CSIDL</b> with CSIDL_FLAG_CREATE.
///    hToken = Type: <b>HANDLE</b> An access token that represents a particular user. For systems earlier than Windows 2000, set
///             this value to <b>NULL</b>. For later systems, <i>hToken</i> is usually, but not always, set to <b>NULL</b>. You
///             might need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as
///             belonging to a single user. The most commonly used folder of this type is My Documents.
///    dwFlags = Type: <b>DWORD</b> Specifies whether the path to be returned is the actual path of the folder or the default
///              path. This value is used in cases where the folder associated with a CSIDL value may be moved or renamed by the
///              user.
///    pszSubDir = Type: <b>LPCTSTR</b> A pointer to the subpath to be appended to the folder's path. This is a
///                <b>null</b>-terminated string of length MAX_PATH. If you are not creating a new directory, this must be an
///                existing subdirectory or the function returns an error. This value can be <b>NULL</b> if no subpath is to be
///                appended.
///    pszPath = Type: <b>LPTSTR</b> When this function returns, this value points to the directory path and appended subpath.
///              This is a <b>null</b>-terminated string of length MAX_PATH. This string is empty when the function returns an
///              error code.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetFolderPathAndSubDirA(HWND hwnd, int csidl, HANDLE hToken, uint dwFlags, const(char)* pszSubDir, 
                                  const(char)* pszPath);

///Gets the path of a folder and appends a user-provided subfolder path.
///Params:
///    hwnd = Type: <b>HWND</b> Reserved.
///    csidl = Type: <b>int</b> A CSIDL value that identifies the folder whose path is to be retrieved. Only real folders are
///            valid. If a virtual folder is specified, this function fails. You can force creation of a folder with
///            <b>SHGetFolderPathAndSubDir</b> by combining the folder's <b>CSIDL</b> with CSIDL_FLAG_CREATE.
///    hToken = Type: <b>HANDLE</b> An access token that represents a particular user. For systems earlier than Windows 2000, set
///             this value to <b>NULL</b>. For later systems, <i>hToken</i> is usually, but not always, set to <b>NULL</b>. You
///             might need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as
///             belonging to a single user. The most commonly used folder of this type is My Documents.
///    dwFlags = Type: <b>DWORD</b> Specifies whether the path to be returned is the actual path of the folder or the default
///              path. This value is used in cases where the folder associated with a CSIDL value may be moved or renamed by the
///              user.
///    pszSubDir = Type: <b>LPCTSTR</b> A pointer to the subpath to be appended to the folder's path. This is a
///                <b>null</b>-terminated string of length MAX_PATH. If you are not creating a new directory, this must be an
///                existing subdirectory or the function returns an error. This value can be <b>NULL</b> if no subpath is to be
///                appended.
///    pszPath = Type: <b>LPTSTR</b> When this function returns, this value points to the directory path and appended subpath.
///              This is a <b>null</b>-terminated string of length MAX_PATH. This string is empty when the function returns an
///              error code.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetFolderPathAndSubDirW(HWND hwnd, int csidl, HANDLE hToken, uint dwFlags, const(wchar)* pszSubDir, 
                                  const(wchar)* pszPath);

///Retrieves the path of a known folder as an ITEMIDLIST structure.
///Params:
///    rfid = Type: <b>REFKNOWNFOLDERID</b> A reference to the KNOWNFOLDERID that identifies the folder. The folders associated
///           with the known folder IDs might not exist on a particular system.
///    dwFlags = Type: <b>DWORD</b> Flags that specify special retrieval options. This value can be 0; otherwise, it is one or
///              more of the KNOWN_FOLDER_FLAG values.
///    hToken = Type: <b>HANDLE</b> An access token used to represent a particular user. This parameter is usually set to
///             <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you
///             may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as
///             belonging to a single user. The most commonly used folder of this type is <b>Documents</b>. The calling
///             application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate
///             security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry
///             hive must be currently mounted. See Access Control for further discussion of access control issues. Assigning the
///             <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of
///             <b>SHGetKnownFolderIDList</b> to find folder locations (such as the <b>Desktop</b> folder) for the Default User.
///             The Default User user profile is duplicated when any new user account is created, and includes special folders
///             such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new
///             user account. Note that access to the Default User folders requires administrator privileges.
///    ppidl = Type: <b>PIDLIST_ABSOLUTE*</b> When this method returns, contains a pointer to the PIDL of the folder. This
///            parameter is passed uninitialized. The caller is responsible for freeing the returned PIDL when it is no longer
///            needed by calling ILFree.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following: <table>
///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
///    </dl> </td> <td width="60%"> Among other things, this value can indicate that the <i>rfid</i> parameter
///    references a KNOWNFOLDERID that is not present on the system. Not all <b>KNOWNFOLDERID</b> values are present on
///    all systems. Use IKnownFolderManager::GetFolderIds to retrieve the set of <b>KNOWNFOLDERID</b> values for the
///    current system. </td> </tr> </table>
///    
@DllImport("SHELL32")
HRESULT SHGetKnownFolderIDList(const(GUID)* rfid, uint dwFlags, HANDLE hToken, ITEMIDLIST** ppidl);

///Redirects a known folder to a new location.
///Params:
///    rfid = Type: <b>REFKNOWNFOLDERID</b> A <b>GUID</b> that identifies the known folder.
///    dwFlags = Type: <b>DWORD</b> Either 0 or the following value.
///    hToken = Type: <b>HANDLE</b> An access token used to represent a particular user. This parameter is usually set to
///             <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you
///             may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as
///             belonging to a single user. The most commonly used folder of this type is <b>Documents</b>. The calling
///             application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate
///             security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry
///             hive must be currently mounted. See Access Control for further discussion of access control issues. Assigning the
///             <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of
///             <b>SHSetKnownFolderPath</b> to set folder locations (such as the <b>Desktop</b> folder) for the Default User. The
///             Default User user profile is duplicated when any new user account is created, and includes special folders such
///             as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user
///             account. Note that access to the Default User folders requires administrator privileges.
///    pszPath = Type: <b>PCWSTR</b> A pointer to the folder's new path. This is a null-terminated Unicode string of length
///              MAX_PATH. This path cannot be of zero length.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following: <table>
///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
///    </dl> </td> <td width="60%"> Among other things, this value can indicate that the <i>rfid</i> parameter
///    references a KNOWNFOLDERID that is not present on the system. Not all <b>KNOWNFOLDERID</b> values are present on
///    all systems. Use IKnownFolderManager::GetFolderIds to retrieve the set of <b>KNOWNFOLDERID</b> values for the
///    current system. </td> </tr> </table>
///    
@DllImport("SHELL32")
HRESULT SHSetKnownFolderPath(const(GUID)* rfid, uint dwFlags, HANDLE hToken, const(wchar)* pszPath);

///Retrieves the full path of a known folder identified by the folder's KNOWNFOLDERID.
///Params:
///    rfid = Type: <b>REFKNOWNFOLDERID</b> A reference to the KNOWNFOLDERID that identifies the folder.
///    dwFlags = Type: <b>DWORD</b> Flags that specify special retrieval options. This value can be 0; otherwise, one or more of
///              the KNOWN_FOLDER_FLAG values.
///    hToken = Type: <b>HANDLE</b> An access token that represents a particular user. If this parameter is <b>NULL</b>, which is
///             the most common usage, the function requests the known folder for the current user. Request a specific user's
///             folder by passing the <i>hToken</i> of that user. This is typically done in the context of a service that has
///             sufficient privileges to retrieve the token of a given user. That token must be opened with TOKEN_QUERY and
///             TOKEN_IMPERSONATE rights. In some cases, you also need to include TOKEN_DUPLICATE. In addition to passing the
///             user's <i>hToken</i>, the registry hive of that specific user must be mounted. See Access Control for further
///             discussion of access control issues. Assigning the <i>hToken</i> parameter a value of -1 indicates the Default
///             User. This allows clients of <b>SHGetKnownFolderPath</b> to find folder locations (such as the <b>Desktop</b>
///             folder) for the Default User. The Default User user profile is duplicated when any new user account is created,
///             and includes special folders such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User
///             folder also appear in any new user account. Note that access to the Default User folders requires administrator
///             privileges.
///    ppszPath = Type: <b>PWSTR*</b> When this method returns, contains the address of a pointer to a null-terminated Unicode
///               string that specifies the path of the known folder. The calling process is responsible for freeing this resource
///               once it is no longer needed by calling CoTaskMemFree, whether <b>SHGetKnownFolderPath</b> succeeds or not. The
///               returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than
///               "C:\Users\\".
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following: <table>
///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
///    </td> <td width="60%"> Among other things, this value can indicate that the <i>rfid</i> parameter references a
///    KNOWNFOLDERID which does not have a path (such as a folder marked as KF_CATEGORY_VIRTUAL). </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Among other things, this value can
///    indicate that the <i>rfid</i> parameter references a KNOWNFOLDERID that is not present on the system. Not all
///    <b>KNOWNFOLDERID</b> values are present on all systems. Use IKnownFolderManager::GetFolderIds to retrieve the set
///    of <b>KNOWNFOLDERID</b> values for the current system. </td> </tr> </table>
///    
@DllImport("SHELL32")
HRESULT SHGetKnownFolderPath(const(GUID)* rfid, uint dwFlags, HANDLE hToken, ushort** ppszPath);

///Retrieves an IShellItem object that represents a known folder.
///Params:
///    rfid = Type: <b>REFKNOWNFOLDERID</b> A reference to the KNOWNFOLDERID, a <b>GUID</b> that identifies the folder that
///           contains the item.
///    flags = Type: <b>KNOWN_FOLDER_FLAG</b> Flags that specify special options used in the retrieval of the known folder
///            IShellItem. This value can be <b>KF_FLAG_DEFAULT</b>; otherwise, one or more of the KNOWN_FOLDER_FLAG values.
///    hToken = Type: <b>HANDLE</b> An access token used to represent a particular user. This parameter is usually set to
///             <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you
///             may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as
///             belonging to a single user. The most commonly used folder of this type is <b>Documents</b>. The calling
///             application is responsible for correct impersonation when <i>hToken</i> is non-<b>null</b>. It must have
///             appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the
///             user's registry hive must be currently mounted. See Access Control for further discussion of access control
///             issues. Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of
///             SHSetKnownFolderPath to set folder locations (such as the <b>Desktop</b> folder) for the Default User. The
///             Default User user profile is duplicated when any new user account is created, and includes special folders such
///             as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user
///             account. Note that access to the Default User folders requires administrator privileges.
///    riid = Type: <b>REFIID</b> A reference to the IID of the interface that represents the item, usually IID_IShellItem or
///           IID_IShellItem2.
///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following: <table>
///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
///    </dl> </td> <td width="60%"> Among other things, this value can indicate that the <i>rfid</i> parameter
///    references a KNOWNFOLDERID that is not present on the system. Not all <b>KNOWNFOLDERID</b> values are present on
///    all systems. Use IKnownFolderManager::GetFolderIds to retrieve the set of <b>KNOWNFOLDERID</b> values for the
///    current system. </td> </tr> </table>
///    
@DllImport("SHELL32")
HRESULT SHGetKnownFolderItem(const(GUID)* rfid, KNOWN_FOLDER_FLAG flags, HANDLE hToken, const(GUID)* riid, 
                             void** ppv);

///<p class="CCE_Message">[<b>SHGetSetFolderCustomSettings</b> is available for use in the operating systems specified
///in the Requirements section. It may be altered or unavailable in subsequent versions.] Sets or retrieves custom
///folder settings. This function reads from and writes to Desktop.ini.
///Params:
///    pfcs = Type: <b>LPSHFOLDERCUSTOMSETTINGS</b> A pointer to a SHFOLDERCUSTOMSETTINGS structure that provides or receives
///           the custom folder settings.
///    pszPath = Type: <b>PCTSTR</b> A pointer to a null-terminated Unicode string that contains the path to the folder. The
///              length of <b>pszPath</b> must be MAX_PATH or less, including the terminating null character.
///    dwReadWrite = Type: <b>DWORD</b> A flag that controls the action of the function. It may be one of the following values.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetSetFolderCustomSettings(SHFOLDERCUSTOMSETTINGS* pfcs, const(wchar)* pszPath, uint dwReadWrite);

///Displays a dialog box that enables the user to select a Shell folder.
///Params:
///    lpbi = Type: <b>LPBROWSEINFO</b> A pointer to a BROWSEINFO structure that contains information used to display the
///           dialog box.
///Returns:
///    Type: <b>PIDLIST_ABSOLUTE</b> Returns a PIDL that specifies the location of the selected folder relative to the
///    root of the namespace. If the user chooses the <b>Cancel</b> button in the dialog box, the return value is
///    <b>NULL</b>. It is possible that the PIDL returned is that of a folder shortcut rather than a folder. For a full
///    discussion of this case, see the Remarks section.
///    
@DllImport("SHELL32")
ITEMIDLIST* SHBrowseForFolderA(BROWSEINFOA* lpbi);

///Displays a dialog box that enables the user to select a Shell folder.
///Params:
///    lpbi = Type: <b>LPBROWSEINFO</b> A pointer to a BROWSEINFO structure that contains information used to display the
///           dialog box.
///Returns:
///    Type: <b>PIDLIST_ABSOLUTE</b> Returns a PIDL that specifies the location of the selected folder relative to the
///    root of the namespace. If the user chooses the <b>Cancel</b> button in the dialog box, the return value is
///    <b>NULL</b>. It is possible that the PIDL returned is that of a folder shortcut rather than a folder. For a full
///    discussion of this case, see the Remarks section.
///    
@DllImport("SHELL32")
ITEMIDLIST* SHBrowseForFolderW(BROWSEINFOW* lpbi);

///Creates an instance of the specified object class from within the context of the Shell's process. <b>Windows
///Vista</b> and later: This function has been disabled and returns E_NOTIMPL.
///Params:
///    rclsid = Type: <b>REFCLSID</b> The CLSID of the object class to be created.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. In Windows Vista and later
///    versions, always returns E_NOTIMPL.
///    
@DllImport("SHELL32")
HRESULT SHLoadInProc(const(GUID)* rclsid);

///Retrieves the IShellFolder interface for the desktop folder, which is the root of the Shell's namespace.
///Params:
///    ppshf = Type: <b>IShellFolder**</b> When this method returns, receives an IShellFolder interface pointer for the desktop
///            folder. The calling application is responsible for eventually freeing the interface by calling its
///            IUnknown::Release method.
@DllImport("SHELL32")
HRESULT SHGetDesktopFolder(IShellFolder* ppshf);

///Notifies the system of an event that an application has performed. An application should use this function if it
///performs an action that may affect the Shell.
///Params:
///    wEventId = Type: <b>LONG</b> Describes the event that has occurred. Typically, only one event is specified at a time. If
///               more than one event is specified, the values contained in the <i>dwItem1</i> and <i>dwItem2</i> parameters must
///               be the same, respectively, for all specified events. This parameter can be one or more of the following values:
///    uFlags = Type: <b>UINT</b> Flags that, when combined bitwise with <b>SHCNF_TYPE</b>, indicate the meaning of the
///             <i>dwItem1</i> and <i>dwItem2</i> parameters. The <i>uFlags</i> parameter must be one of the following values.
///    dwItem1 = Type: <b>LPCVOID</b> Optional. First event-dependent value.
///    dwItem2 = Type: <b>LPCVOID</b> Optional. Second event-dependent value.
@DllImport("SHELL32")
void SHChangeNotify(int wEventId, uint uFlags, void* dwItem1, void* dwItem2);

///Notifies the system that an item has been accessed, for the purposes of tracking those items used most recently and
///most frequently. This function can also be used to clear all usage data.
///Params:
///    uFlags = Type: <b>UINT</b> A value from the SHARD enumeration that indicates the form of the information pointed to by the
///             <i>pv</i> parameter.
///    pv = Type: <b>LPCVOID</b> A pointer to data that identifies the item that has been accessed. The item can be specified
///         in this parameter in one of the following forms: <ul> <li>A null-terminated string that contains the path and
///         file name of the item.</li> <li>A PIDL that identifies the item's file object.</li> <li><b>Windows 7 and later
///         only</b>. A SHARDAPPIDINFO, SHARDAPPIDINFOIDLIST, or SHARDAPPIDINFOLINK structure that identifies the item
///         through an AppUserModelID. See Application User Model IDs (AppUserModelIDs) for more information.</li>
///         <li><b>Windows 7 and later only</b>. An IShellLink object that identifies the item through a shortcut.</li> </ul>
///         Set this parameter to <b>NULL</b> to clear all usage data on all items.
@DllImport("SHELL32")
void SHAddToRecentDocs(uint uFlags, void* pv);

///<p class="CCE_Message">[<b>SHHandleUpdateImage</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Handles the <b>SHCNE_UPDATEIMAGE</b>
///Shell change notification.
///Params:
///    pidlExtra = Type: <b>PCIDLIST_ABSOLUTE</b> The index in the system image list that has changed, specified in the <i>pidl2</i>
///                parameter of IShellChangeNotify::OnChange.
///Returns:
///    Type: <b>int</b> Returns -1 on failure or the index of the changed image list entry on success.
///    
@DllImport("SHELL32")
int SHHandleUpdateImage(ITEMIDLIST* pidlExtra);

///Notifies the Shell that an image in the system image list has changed.
///Params:
///    pszHashItem = Type: <b>LPCTSTR</b> A pointer to a string value that specifies the fully qualified path of the file that
///                  contains the icon. Use the path that is returned in the buffer pointed to by the <i>szIconFile</i> parameter of
///                  IExtractIcon::GetIconLocation.
///    iIndex = Type: <b>int</b> An integer that specifies the zero-based index of the icon in the file specified by
///             <i>pszHashItem</i>. Use the value that is pointed to by the <i>piIndex</i> parameter of
///             IExtractIcon::GetIconLocation.
///    uFlags = Type: <b>UINT</b> An unsigned integer that specifies the flags that determine the icon attributes. Set
///             <i>uFlags</i> to the value that is pointed to by the <i>pwFlags</i> parameter of IExtractIcon::GetIconLocation.
///             The flags that are relevant to <b>SHUpdateImage</b> are <b>GIL_NOTFILENAME</b> and <b>GIL_SIMULATEDOC</b>.
///    iImageIndex = Type: <b>int</b> An integer that specifies the index in the system image list of the icon that is being updated.
@DllImport("SHELL32")
void SHUpdateImageA(const(char)* pszHashItem, int iIndex, uint uFlags, int iImageIndex);

///Notifies the Shell that an image in the system image list has changed.
///Params:
///    pszHashItem = Type: <b>LPCTSTR</b> A pointer to a string value that specifies the fully qualified path of the file that
///                  contains the icon. Use the path that is returned in the buffer pointed to by the <i>szIconFile</i> parameter of
///                  IExtractIcon::GetIconLocation.
///    iIndex = Type: <b>int</b> An integer that specifies the zero-based index of the icon in the file specified by
///             <i>pszHashItem</i>. Use the value that is pointed to by the <i>piIndex</i> parameter of
///             IExtractIcon::GetIconLocation.
///    uFlags = Type: <b>UINT</b> An unsigned integer that specifies the flags that determine the icon attributes. Set
///             <i>uFlags</i> to the value that is pointed to by the <i>pwFlags</i> parameter of IExtractIcon::GetIconLocation.
///             The flags that are relevant to <b>SHUpdateImage</b> are <b>GIL_NOTFILENAME</b> and <b>GIL_SIMULATEDOC</b>.
///    iImageIndex = Type: <b>int</b> An integer that specifies the index in the system image list of the icon that is being updated.
@DllImport("SHELL32")
void SHUpdateImageW(const(wchar)* pszHashItem, int iIndex, uint uFlags, int iImageIndex);

///Registers a window to receive notifications from the file system or Shell, if the file system supports notifications.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to the window that receives the change or notification messages.
///    fSources = Type: <b>int</b> One or more of the following values that indicate the type of events for which to receive
///               notifications. <div class="alert"><b>Note</b> In earlier versions of the SDK, these flags are not defined in a
///               header file and implementers must define these values themselves or use their numeric values directly. As of
///               Windows Vista, these flags are defined in Shlobj.h.</div> <div> </div>
///    fEvents = Type: <b>LONG</b> Change notification events for which to receive notification. See the SHCNE flags listed in
///              SHChangeNotify for possible values.
///    wMsg = Type: <b>UINT</b> Message to be posted to the window procedure.
///    cEntries = Type: <b>int</b> Number of entries in the <i>pshcne</i> array.
///    pshcne = Type: <b>const SHChangeNotifyEntry*</b> Array of SHChangeNotifyEntry structures that contain the notifications.
///             This array should always be set to one when calling <b>SHChangeNotifyRegister</b> or SHChangeNotifyDeregister
///             will not work properly.
///Returns:
///    Type: <b>ULONG</b> Returns a positive integer registration ID. Returns 0 if out of memory or in response to
///    invalid parameters.
///    
@DllImport("SHELL32")
uint SHChangeNotifyRegister(HWND hwnd, int fSources, int fEvents, uint wMsg, int cEntries, 
                            const(SHChangeNotifyEntry)* pshcne);

///Unregisters the client's window process from receiving SHChangeNotify messages.
///Params:
///    ulID = Type: <b>ULONG</b> A value of type <b>ULONG</b> that specifies the registration ID returned by
///           SHChangeNotifyRegister.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the specified client was found and removed; otherwise <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL SHChangeNotifyDeregister(uint ulID);

///Locks the shared memory associated with a Shell change notification event.
///Params:
///    hChange = Type: <b>HANDLE</b> A handle to a window received as a <i>wParam</i> in the specified Shell change notification
///              message.
///    dwProcId = Type: <b>DWORD</b> The process ID (<i>lParam</i> in the message callback).
///    pppidl = Type: <b>PIDLIST_ABSOLUTE**</b> The address of a pointer to a PIDLIST_ABSOLUTE that, when this function returns
///             successfully, receives the list of affected PIDLs.
///    plEvent = Type: <b>LONG*</b> A pointer to a LONG value that, when this function returns successfully, receives the Shell
///              change notification ID of the event that took place.
@DllImport("SHELL32")
ShFindChangeNotifcationHandle SHChangeNotification_Lock(HANDLE hChange, uint dwProcId, ITEMIDLIST*** pppidl, 
                                                        int* plEvent);

///Unlocks shared memory for a change notification.
///Params:
///    hLock = Type: <b>HANDLE</b> A handle to the memory lock. This is the handle returned by SHChangeNotification_Lock when it
///            locked the memory.
@DllImport("SHELL32")
BOOL SHChangeNotification_Unlock(HANDLE hLock);

///<p class="CCE_Message">[<b>SHGetRealIDL</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Converts a simple pointer to an item
///identifier list (PIDL) into a full PIDL.
///Params:
///    psf = Type: <b>IShellFolder*</b> A pointer to an instance of IShellFolder whose simple PIDL is to be converted.
///    pidlSimple = Type: <b>PCUITEMID_CHILD</b> The simple PIDL to be converted.
///    ppidlReal = Type: <b>PITEMID_CHILD*</b> When this method returns, contains a pointer to the full converted PIDL. If the
///                function fails, this parameter is set to <b>NULL</b>.
@DllImport("SHELL32")
HRESULT SHGetRealIDL(IShellFolder psf, ITEMIDLIST* pidlSimple, ITEMIDLIST** ppidlReal);

///Retrieves an interface that allows hosted Shell extensions and other components to prevent their host process from
///closing prematurely. The host process is typically Windows Explorer or Windows Internet Explorer, but this function
///can also be used by other applications.
///Params:
///    ppunk = Type: <b>IUnknown**</b> When this function returns successfully, contains the address of the host process'
///            IUnknown interface pointer. This is a free-threaded interface used to prevent the host process from terminating.
///            If the function call fails, this value is set to <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHGetInstanceExplorer(IUnknown* ppunk);

///Retrieves extended property data from a relative identifier list.
///Params:
///    psf = Type: <b>IShellFolder*</b> The address of the parent IShellFolder interface. This must be the immediate parent of
///          the ITEMIDLIST structure referenced by the <i>pidl</i> parameter.
///    pidl = Type: <b>PCUITEMID_CHILD</b> A pointer to an ITEMIDLIST structure that identifies the object relative to the
///           folder specified in <i>psf</i>.
///    nFormat = Type: <b>int</b> The format in which the data is being requested. This parameter must be set to one of the
///              following values.
///    pv = Type: <b>void*</b> A pointer to a buffer that, when this function returns successfully, receives the requested
///         data. The format of this buffer is determined by <i>nFormat</i>. If <i>nFormat</i> is <b>SHGDFIL_NETRESOURCE</b>,
///         there are two possible cases. If the buffer is large enough, the net resource's string information (fields for
///         the network name, local name, provider, and comments) will be placed into the buffer. If the buffer is not large
///         enough, only the net resource structure will be placed into the buffer and the string information pointers will
///         be <b>NULL</b>.
///    cb = Type: <b>int</b> Size of the buffer at <i>pv</i>, in bytes.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or E_INVALIDARG otherwise.
///    
@DllImport("SHELL32")
HRESULT SHGetDataFromIDListA(IShellFolder psf, ITEMIDLIST* pidl, int nFormat, char* pv, int cb);

///Retrieves extended property data from a relative identifier list.
///Params:
///    psf = Type: <b>IShellFolder*</b> The address of the parent IShellFolder interface. This must be the immediate parent of
///          the ITEMIDLIST structure referenced by the <i>pidl</i> parameter.
///    pidl = Type: <b>PCUITEMID_CHILD</b> A pointer to an ITEMIDLIST structure that identifies the object relative to the
///           folder specified in <i>psf</i>.
///    nFormat = Type: <b>int</b> The format in which the data is being requested. This parameter must be set to one of the
///              following values.
///    pv = Type: <b>void*</b> A pointer to a buffer that, when this function returns successfully, receives the requested
///         data. The format of this buffer is determined by <i>nFormat</i>. If <i>nFormat</i> is <b>SHGDFIL_NETRESOURCE</b>,
///         there are two possible cases. If the buffer is large enough, the net resource's string information (fields for
///         the network name, local name, provider, and comments) will be placed into the buffer. If the buffer is not large
///         enough, only the net resource structure will be placed into the buffer and the string information pointers will
///         be <b>NULL</b>.
///    cb = Type: <b>int</b> Size of the buffer at <i>pv</i>, in bytes.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or E_INVALIDARG otherwise.
///    
@DllImport("SHELL32")
HRESULT SHGetDataFromIDListW(IShellFolder psf, ITEMIDLIST* pidl, int nFormat, char* pv, int cb);

///<p class="CCE_Message">[This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be altered or unavailable in subsequent versions of Windows.] Displays a dialog box that prompts the user to
///restart Windows. When the user clicks the button, the function calls ExitWindowsEx to attempt to restart Windows.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to the parent window.
///    pszPrompt = Type: <b>PCWSTR</b> A null-terminated Unicode string that contains the text that displays in the dialog box which
///                prompts the user.
///    dwReturn = Type: <b>DWORD</b> The flags that specify the type of shutdown. This parameter must include one of the following
///               values.
@DllImport("SHELL32")
int RestartDialog(HWND hwnd, const(wchar)* pszPrompt, uint dwReturn);

///<p class="CCE_Message">[This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be altered or unavailable in subsequent versions of Windows.] Displays a dialog box that asks the user to
///restart Windows. When the user clicks the button, the function calls ExitWindowsEx to attempt to restart Windows.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to the parent window.
///    pszPrompt = Type: <b>PCWSTR</b> A null-terminated string that contains the text that displays in the dialog box to prompt the
///                user.
///    dwReturn = Type: <b>DWORD</b> The flags that specify the type of shutdown. This parameter must include one of the following
///               values.
///    dwReasonCode = Type: <b>DWORD</b> <b>Windows XP:</b>Specifies the reason for initiating the shutdown. For more information, see
///                   System Shutdown Reason Codes. <b>Windows 2000:</b> This parameter is ignored.
@DllImport("SHELL32")
int RestartDialogEx(HWND hwnd, const(wchar)* pszPrompt, uint dwReturn, uint dwReasonCode);

///<p class="CCE_Message">[<b>SHCoCreateInstance</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Instead, use CoCreateInstance.]
///Creates Component Object Model (COM) objects that are implemented in Shell32.dll.
///Params:
///    pszCLSID = Type: <b>PCWSTR</b> A pointer to a string to convert to a CLSID. If <b>NULL</b>, <i>pclsid</i> is used as the
///               CLSID.
///    pclsid = Type: <b>const CLSID*</b> The CLSID to create.
///    pUnkOuter = Type: <b>IUnknown*</b> A pointer to outer IUnknown. Used for aggregation.
///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>.
///    ppv = Type: <b>void**</b> When this function returns successfully, receives the interface pointer requested in
///          <i>riid</i>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCoCreateInstance(const(wchar)* pszCLSID, const(GUID)* pclsid, IUnknown pUnkOuter, const(GUID)* riid, 
                           void** ppv);

///Creates a data object in a parent folder.
///Params:
///    pidlFolder = Type: <b>PCIDLIST_ABSOLUTE</b> A pointer to an ITEMIDLIST (PIDL) of the parent folder that contains the data
///                 object.
///    cidl = Type: <b>UINT</b> The number of file objects or subfolders specified in the <i>apidl</i> parameter.
///    apidl = Type: <b>PCUITEMID_CHILD_ARRAY</b> An array of pointers to constant ITEMIDLIST structures, each of which uniquely
///            identifies a file object or subfolder relative to the parent folder. Each item identifier list must contain
///            exactly one SHITEMID structure followed by a terminating zero.
///    pdtInner = Type: <b>IDataObject*</b> A pointer to interface IDataObject. This parameter can be <b>NULL</b>. Specify
///               <i>pdtInner</i> only if the data object created needs to support additional FORMATETC clipboard formats beyond
///               the default formats it is assigned at creation. Alternatively, provide support for populating the created data
///               object using non-default clipboard formats by calling method IDataObject::SetData and specifying the format in
///               the <b>FORMATETC</b> structure passed in parameter <i>pFormatetc</i>.
///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>. This must be
///           IID_IDataObject.
///    ppv = Type: <b>void**</b> When this method returns successfully, contains the IDataObject interface pointer requested
///          in <i>riid</i>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCreateDataObject(ITEMIDLIST* pidlFolder, uint cidl, char* apidl, IDataObject pdtInner, const(GUID)* riid, 
                           void** ppv);

///<p class="CCE_Message">[<b>CIDLData_CreateFromIDArray</b> is available for use in the operating systems specified in
///the Requirements section. It may be altered or unavailable in subsequent versions.] Creates a data object with the
///default vtable pointer.
///Params:
///    pidlFolder = Type: <b>PCIDLIST_ABSOLUTE</b> A fully qualified IDLIST for the root of the items specified in <i>apidl</i>.
///    cidl = Type: <b>UINT</b> The number of entries in the <i>apidl</i> array.
///    apidl = Type: <b>PCUIDLIST_RELATIVE_ARRAY</b> The array of item IDs relative to <i>pidlFolder</i>. Typically,
///            <i>apidl</i> is an array of child IDs and <i>pidlFolder</i> is a full PIDL for those items. However,
///            <i>pidlFolder</i> can be a null PIDL (desktop IDLISTs). In that case, <i>apidl</i> can contain fully qualified ID
///            lists.
///    ppdtobj = Type: <b>IDataObject**</b> The address to a pointer to the object that implements IDataObject.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT CIDLData_CreateFromIDArray(ITEMIDLIST* pidlFolder, uint cidl, char* apidl, IDataObject* ppdtobj);

///<p class="CCE_Message">[<b>SHCreateStdEnumFmtEtc</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Creates an IEnumFORMATETC object from
///an array of FORMATETC structures.
///Params:
///    cfmt = Type: <b>UINT</b> The number of entries in the <i>afmt</i> array.
///    afmt = Type: <b>const FORMATETC[]</b> An array of FORMATETC structures that specifies the clipboard formats of interest.
///    ppenumFormatEtc = Type: <b>IEnumFORMATETC**</b> When this function returns successfully, receives an IEnumFORMATETC interface
///                      pointer. Receives <b>NULL</b> on failure.
@DllImport("SHELL32")
HRESULT SHCreateStdEnumFmtEtc(uint cfmt, char* afmt, IEnumFORMATETC* ppenumFormatEtc);

///Executes a drag-and-drop operation. Supports drag source creation on demand, as well as drag images.
///Params:
///    hwnd = Type: <b>HWND</b> The handle of the window used to obtain the drag image. This value can be <b>NULL</b>. See
///           Remarks for more details.
///    pdata = Type: <b>IDataObject*</b> A pointer to the IDataObject interface on a data object that contains the data being
///            dragged.
///    pdsrc = Type: <b>IDropSource*</b> A pointer to an implementation of the IDropSource interface, which is used to
///            communicate with the source during the drag operation. As of Windows Vista, if this value is <b>NULL</b>, the
///            Shell creates a drop source object for you.
///    dwEffect = Type: <b>DWORD</b> The effects that the source allows in the drag-and-drop operation. The most significant effect
///               is whether the drag-and-drop operation permits a move. For a list of possible values, see DROPEFFECT.
///    pdwEffect = Type: <b>DWORD*</b> A pointer to a value that indicates how the drag-and-drop operation affected the source data.
///                The <i>pdwEffect</i> parameter is set only if the operation is not canceled. For a list of possible values, see
///                DROPEFFECT.
///Returns:
///    Type: <b>HRESULT</b> This function supports the standard return value E_OUTOFMEMORY, as well as the following
///    values: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DRAGDROP_S_DROP</b></dt> </dl> </td> <td width="60%"> The drag-and-drop operation was successful. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>DRAGDROP_S_CANCEL</b></dt> </dl> </td> <td width="60%"> The drag-and-drop
///    operation was canceled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNSPEC</b></dt> </dl> </td> <td
///    width="60%"> Unexpected error occurred. </td> </tr> </table>
///    
@DllImport("SHELL32")
HRESULT SHDoDragDrop(HWND hwnd, IDataObject pdata, IDropSource pdsrc, uint dwEffect, uint* pdwEffect);

///<p class="CCE_Message">[<b>DAD_SetDragImage</b> is available in Windows 2000 and Windows XP. It might be altered or
///unavailable in subsequent versions. Use ImageList_BeginDrag instead.] Sets the drag image.
///Params:
///    him = Type: <b>HIMAGELIST</b> A handle to an image list. This parameter uses the zero index in the ImageList.
///    pptOffset = Type: <b>POINT*</b> A pointer to the coordinates used as the hot spot for dragging the image. The coordinates are
///                relative to upper-left corner of the image.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("SHELL32")
BOOL DAD_SetDragImage(HIMAGELIST him, POINT* pptOffset);

///<p class="CCE_Message">[<b>DAD_DragEnterEx</b> is available in Windows 2000 and Windows XP. It might be altered or
///unavailable in subsequent versions. Use ImageList_DragEnter instead. ] Locks updates to the specified window during a
///drag operation and displays the drag image at the specified position within the window.
///Params:
///    hwndTarget = Type: <b>HWND</b> A handle to the window that owns the drag image.
///    ptStart = Type: <b>const POINT</b> The coordinates at which to begin displaying the drag image. The coordinates are
///              relative to the upper-left corner of the window, not the client area.
@DllImport("SHELL32")
BOOL DAD_DragEnterEx(HWND hwndTarget, const(POINT) ptStart);

///<p class="CCE_Message">[<b>DAD_DragEnterEx2</b> is available in Windows 2000 and Windows XP. It might be altered or
///unavailable in subsequent versions. Use ImageList_DragEnter instead.] Locks updates to the specified window during a
///drag-and-drop operation and displays the drag image at the specified position within the window.
///Params:
///    hwndTarget = Type: <b>HWND</b> A handle to the window that owns the drag image.
///    ptStart = Type: <b>const POINT</b> Specifies the coordinates at which to begin displaying the drag image. The coordinates
///              are relative to the upper-left corner of the window, not the client area.
///    pdtObject = Type: <b>IDataObject*</b> A pointer to the IDataObject interface on the data object. This data object contains
///                the data being transferred in the drag-and-drop operation. If the drop occurs, this data object will be
///                incorporated into the target. This parameter may be <b>NULL</b>.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.
///    
@DllImport("SHELL32")
BOOL DAD_DragEnterEx2(HWND hwndTarget, const(POINT) ptStart, IDataObject pdtObject);

///<p class="CCE_Message">[<b>DAD_ShowDragImage</b> is available in Windows 2000 and Windows XP. It might be altered or
///unavailable in subsequent versions. Use ImageList_DragShowNolock instead. ] Shows or hides the image being dragged.
///Params:
///    fShow = Type: <b>BOOL</b> A value that specifies whether to show or hide the image being dragged.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("SHELL32")
BOOL DAD_ShowDragImage(BOOL fShow);

///<p class="CCE_Message">[<b>DAD_DragMove</b> is available in Windows 2000 and Windows XP. It might be altered or
///unavailable in subsequent versions. Use ImageList_DragMove instead. ] Moves the image that is being dragged during a
///drag-and-drop operation.
///Params:
///    pt = Type: <b>POINT</b> The coordinates at which to display the drag image. The coordinates are relative to the
///         upper-left corner of the window, not the client area.
@DllImport("SHELL32")
BOOL DAD_DragMove(POINT pt);

///<p class="CCE_Message">[<b>DAD_DragLeave</b> is available in Windows 2000 and Windows XP. It might be altered or
///unavailable in subsequent versions. Use ImageList_DragLeave instead.] Unlocks the window locked by the
///DAD_DragEnterEx function.
@DllImport("SHELL32")
BOOL DAD_DragLeave();

///<p class="CCE_Message">[<b>DAD_AutoScroll</b> is available in Windows 2000 and Windows XP. It might be altered or
///unavailable in subsequent versions.] Scrolls the window while an image is being dragged.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to the window being scrolled.
///    pad = Type: <b>AUTO_SCROLL_DATA*</b> A pointer to the AUTO_SCROLL_DATA structure.
///    pptNow = Type: <b>const POINT*</b> A pointer to the current scroll coordinates.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("SHELL32")
BOOL DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA* pad, const(POINT)* pptNow);

///<p class="CCE_Message">[<b>ReadCabinetState</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Fills a CABINETSTATE structure with
///information from the registry.
///Params:
///    pcs = Type: <b>CABINETSTATE*</b> When this function returns, contains a pointer to a CABINETSTATE structure that
///          contains either information pulled from the registry or default information.
///    cLength = Type: <b>int</b> The size of the structure pointed to by <i>pcs</i>, in bytes.
@DllImport("SHELL32")
BOOL ReadCabinetState(char* pcs, int cLength);

///<p class="CCE_Message">[<b>WriteCabinetState</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Writes the information contained in a
///CABINETSTATE structure into the registry.
///Params:
///    pcs = Type: <b>CABINETSTATE*</b> A pointer to a CABINETSTATE structure that holds the values to be set.
@DllImport("SHELL32")
BOOL WriteCabinetState(CABINETSTATE* pcs);

///Creates a unique path name from a template.
///Params:
///    pszUniqueName = Type: <b>PWSTR</b> A buffer that receives a null-terminated Unicode string that contains the unique path name. It
///                    should be at least MAX_PATH characters in length.
///    cchMax = Type: <b>UINT</b> The number of characters in the buffer pointed to by <i>pszUniqueName</i>.
///    pszTemplate = Type: <b>PCWSTR</b> A null-terminated Unicode string that contains a template that is used to construct the
///                  unique name. This template is used for drives that require file names with the 8.3 format. This string should be
///                  no more than MAX_PATH characters in length, including the terminating null character.
///    pszLongPlate = Type: <b>PCWSTR</b> A null-terminated Unicode string that contains a template that is used to construct the
///                   unique name. This template is used for drives that support long file names. This string should be no more than
///                   MAX_PATH characters in length, including the terminating null character.
///    pszDir = Type: <b>PCWSTR</b> A null-terminated string that contains the directory in which the new file resides. This
///             string should be no more than MAX_PATH characters in length, including the terminating null character.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL PathMakeUniqueName(const(wchar)* pszUniqueName, uint cchMax, const(wchar)* pszTemplate, 
                        const(wchar)* pszLongPlate, const(wchar)* pszDir);

///<p class="CCE_Message">[<b>PathIsExe</b> is available for use in the operating systems specified in the Requirements
///section. It may be altered or unavailable in subsequent versions.] Determines whether a file is an executable by
///examining the file name extension.
///Params:
///    pszPath = Type: <b>PCWSTR</b> A pointer to a null-terminated, Unicode string that contains the file path, which includes
///              the name of the file.
@DllImport("SHELL32")
BOOL PathIsExe(const(wchar)* pszPath);

///<p class="CCE_Message">[<b>PathCleanupSpec</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Removes illegal characters from a
///file or directory name. Enforces the 8.3 filename format on drives that do not support long file names.
///Params:
///    pszDir = Type: <b>PCWSTR</b> A pointer to a null-terminated buffer that contains the fully qualified path of the directory
///             that will contain the file or directory named at <i>pszSpec</i>. The path must not exceed MAX_PATH characters in
///             length, including the terminating null character. This path is not altered. This value can be <b>NULL</b>.
///    pszSpec = Type: <b>PWSTR</b> A pointer to a null-terminated buffer that contains the file or directory name to be cleaned.
///              In the case of a file, include the file's extension. Note that because '\' is considered an invalid character and
///              will be removed, this buffer cannot contain a path more than one directory deep. On exit, the buffer contains a
///              null-terminated string that includes the cleaned name. This buffer should be at least MAX_PATH characters in
///              length to avoid the possibility of a buffer overrun.
///Returns:
///    Type: <b>int</b> Returns one or more of the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>PCS_REPLACEDCHAR</b></dt> </dl> </td> <td
///    width="60%"> Replaced one or more invalid characters. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>PCS_REMOVEDCHAR</b></dt> </dl> </td> <td width="60%"> Removed one or more invalid characters. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>PCS_TRUNCATED</b></dt> </dl> </td> <td width="60%"> The returned path is
///    truncated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>PCS_PATHTOOLONG</b></dt> </dl> </td> <td width="60%">
///    The function failed because the input path specified at <i>pszDir</i> is too long to allow the formation of a
///    valid file name from <i>pszSpec</i>. When this flag is returned, it is always accompanied by the PCS_FATAL flag.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>PCS_FATAL</b></dt> </dl> </td> <td width="60%"> The cleaned path is
///    not a valid file name. This flag is always returned in conjunction with PCS_PATHTOOLONG. </td> </tr> </table>
///    
@DllImport("SHELL32")
int PathCleanupSpec(const(wchar)* pszDir, const(wchar)* pszSpec);

///<p class="CCE_Message">[<b>PathResolve</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Converts a relative or unqualified
///path name to a fully qualified path name.
///Params:
///    pszPath = Type: <b>PWSTR</b> A null-terminated Unicode string that contains the path to resolve. When the function returns,
///              the string contains the corresponding fully qualified path. This buffer should be at least MAX_PATH characters
///              long.
///    dirs = Type: <b>PZPCWSTR</b> A pointer to an optional null-terminated array of directories to be searched first in the
///           case that the path cannot be resolved from <i>pszPath</i>. This value can be <b>NULL</b>.
///    fFlags = Type: <b>UINT</b> Flags that specify how the function operates.
///Returns:
///    Type: <b>int</b> Returns <b>TRUE</b>, unless PRF_VERIFYEXISTS is set. If that flag is set, the function returns
///    <b>TRUE</b> if the file is verified to exist and <b>FALSE</b> otherwise. It also sets an ERROR_FILE_NOT_FOUND
///    error code that you can retrieve by calling GetLastError.
///    
@DllImport("SHELL32")
int PathResolve(const(wchar)* pszPath, ushort** dirs, uint fFlags);

///<p class="CCE_Message">[This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be altered or unavailable in subsequent versions of Windows.] Creates an <b>Open</b> dialog box so that the
///user can specify the drive, directory, and name of a file to open.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to the window that owns the dialog box. This member can be any valid window handle, or
///           it can be <b>NULL</b> if the dialog box has no owner.
///    pszFilePath = Type: <b>PWSTR</b> A null-terminated Unicode string that contains a file name used to initialize the File Name
///                  edit control. This string corresponds to the OPENFILENAME structure's <b>lpstrFile</b> member and is used in
///                  exactly the same way.
///    cchFilePath = Type: <b>UINT</b> The number of characters in <i>pszFilePath</i>, including the terminating null character.
///    pszWorkingDir = Type: <b>PCWSTR</b> The fully qualified file path of the initial directory. This string corresponds to the
///                    OPENFILENAME structure's <b>lpstrInitialDir</b> member and is used in exactly the same way.
///    pszDefExt = Type: <b>PCWSTR</b> A null-terminated Unicode string that contains the default file name extension. This
///                extension is added to <i>pszFilePath</i> if the user does not specify an extension. The string should not contain
///                any '.' characters. If this string is <b>NULL</b> and the user fails to type an extension, no extension is
///                appended.
///    pszFilters = Type: <b>PCWSTR</b> A null-terminated Unicode string that defines the filter. This string corresponds to the
///                 OPENFILENAME structure's <b>lpstrFilter</b> member and is used in exactly the same way.
///    pszTitle = Type: <b>PCWSTR</b> A null-terminated Unicode string that is placed in the title bar of the dialog box. If this
///               value is <b>NULL</b>, the system uses the default title.
///Returns:
///    Type: <b>BOOL</b> If the user specifies a file name and clicks <b>OK</b>, the return value is <b>TRUE</b>. The
///    buffer that <i>pszFilePath</i> points to contains the full path and file name that the user specifies. If the
///    user cancels or closes the <b>Open</b> dialog box or an error occurs, the return value is <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL GetFileNameFromBrowse(HWND hwnd, const(wchar)* pszFilePath, uint cchFilePath, const(wchar)* pszWorkingDir, 
                           const(wchar)* pszDefExt, const(wchar)* pszFilters, const(wchar)* pszTitle);

///<p class="CCE_Message">[<b>DriveType</b> is available for use in the operating systems specified in the Requirements
///section. It may be altered or unavailable in subsequent versions.] Determines the drive type based on the drive
///number.
///Params:
///    iDrive = Type: <b>int</b> The number of the drive that you want to test. "A:" corresponds to 0, "B:" to 1, and so on.
///Returns:
///    Type: <b>int</b> Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>DRIVE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> The drive type cannot
///    be determined. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DRIVE_NO_ROOT_DIR</b></dt> </dl> </td> <td
///    width="60%"> The root path is invalid. For example, no volume is mounted at the path. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>DRIVE_REMOVABLE</b></dt> </dl> </td> <td width="60%"> The disk can be removed from the
///    drive. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DRIVE_FIXED</b></dt> </dl> </td> <td width="60%"> The disk
///    cannot be removed from the drive. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DRIVE_REMOTE</b></dt> </dl> </td>
///    <td width="60%"> The drive is a remote (network) drive. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DRIVE_CDROM</b></dt> </dl> </td> <td width="60%"> The drive is a CD-ROM drive. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>DRIVE_RAMDISK</b></dt> </dl> </td> <td width="60%"> The drive is a RAM disk. </td> </tr>
///    </table>
///    
@DllImport("SHELL32")
int DriveType(int iDrive);

///<p class="CCE_Message">[<b>RealDriveType</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Determines the drive type based on
///the drive number.
///Params:
///    iDrive = Type: <b>int</b> The number of the drive that you want to test. "A:" corresponds to 0, "B:" to 1, and so on.
///    fOKToHitNet = Type: <b>BOOL</b> Reserved. Must be set to 0.
///Returns:
///    Type: <b>int</b> Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>DRIVE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> The drive type cannot
///    be determined. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DRIVE_NO_ROOT_DIR</b></dt> </dl> </td> <td
///    width="60%"> The root path is invalid. For example, no volume is mounted at the path. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>DRIVE_REMOVABLE</b></dt> </dl> </td> <td width="60%"> The disk can be removed from the
///    drive. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DRIVE_FIXED</b></dt> </dl> </td> <td width="60%"> The disk
///    cannot be removed from the drive. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DRIVE_REMOTE</b></dt> </dl> </td>
///    <td width="60%"> The drive is a remote (network) drive. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DRIVE_CDROM</b></dt> </dl> </td> <td width="60%"> The drive is a CD-ROM drive. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>DRIVE_RAMDISK</b></dt> </dl> </td> <td width="60%"> The drive is a RAM disk. </td> </tr>
///    </table>
///    
@DllImport("SHELL32")
int RealDriveType(int iDrive, BOOL fOKToHitNet);

///<p class="CCE_Message">[This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be altered or unavailable in subsequent versions of Windows. Use GetDriveType or WNetGetConnection instead.]
///Tests whether a drive is a network drive.
///Params:
///    iDrive = Type: <b>int</b> An integer that indicates which drive letter you want to test. Set it to 0 for A:, 1 for B:, and
///             so on.
@DllImport("SHELL32")
int IsNetDrive(int iDrive);

///<p class="CCE_Message">[<b>Shell_MergeMenus</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Merges two menus.
///Params:
///    hmDst = Type: <b>HMENU</b> The destination menu to which <i>hmSrc</i> is added.
///    hmSrc = Type: <b>HMENU</b> The source menu which is added to <i>hmDst</i>.
///    uInsert = Type: <b>UINT</b> The point in <i>hmDst</i> after which the entries in <i>hmSrc</i> are inserted.
///    uIDAdjust = Type: <b>UINT</b> This number is added to each menu's ID to give an adjusted ID. Set to <code>0</code> for no
///                adjustment. The value for <i>uIDAdjust</i> would typically be the number of items in <i>hmDst</i>. This number
///                can be obtained using the GetMenuItemCount.
///    uIDAdjustMax = Type: <b>UINT</b> The maximum adjusted ID to add to the menu. Any adjusted ID greater than this value is not
///                   added. To allow all IDs, set this parameter to 0xFFFF.
///    uFlags = Type: <b>ULONG</b> One or more of the following flags.
@DllImport("SHELL32")
uint Shell_MergeMenus(HMENU hmDst, HMENU hmSrc, uint uInsert, uint uIDAdjust, uint uIDAdjustMax, uint uFlags);

///<p class="CCE_Message">[<b>SHObjectProperties</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Invokes the <b>Properties</b> context
///menu command on a Shell object.
///Params:
///    hwnd = Type: <b>HWND</b> The handle of the parent window of the dialog box. This value can be <b>NULL</b>.
///    shopObjectType = Type: <b>DWORD</b> A flag value that specifies the type of object.
///    pszObjectName = Type: <b>PCWSTR</b> A null-terminated Unicode string that contains the object name. The contents of the string
///                    are determined by the flag set in <i>shopObjectType</i>.
///    pszPropertyPage = Type: <b>PCWSTR</b> A null-terminated Unicode string that contains the name of the property sheet page to be
///                      opened initially. Set this parameter to <b>NULL</b> to specify the default page.
@DllImport("SHELL32")
BOOL SHObjectProperties(HWND hwnd, uint shopObjectType, const(wchar)* pszObjectName, const(wchar)* pszPropertyPage);

///<p class="CCE_Message">[<b>SHFormatDrive</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Opens the Shell's <b>Format</b>
///dialog box.
///Params:
///    hwnd = Type: <b>HWND</b> The handle of the parent window of the dialog box. The <b>Format</b> dialog box must have a
///           parent window; therefore, this parameter cannot be <b>NULL</b>.
///    drive = Type: <b>UINT</b> The drive to format. The value of this parameter represents a letter drive starting at 0 for
///            the A: drive. For example, a value of 2 stands for the C: drive.
///    fmtID = Type: <b>UINT</b> The ID of the physical format. Only the following flag is currently defined.
///    options = Type: <b>UINT</b> This value must be 0 or one of the following values that alter the default format options in
///              the dialog box. This value is regarded as a bitfield and should be treated accordingly.
///Returns:
///    Type: <b>DWORD</b> Returns the format ID of the last successful format or one of the following values. The LOWORD
///    of this value can be passed on subsequent calls as the <i>fmtID</i> parameter to repeat the last format. <table>
///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>SHFMT_ERROR</b></dt> </dl>
///    </td> <td width="60%"> An error occurred during the last format. This does not indicate that the drive is
///    unformattable. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SHFMT_CANCEL</b></dt> </dl> </td> <td width="60%">
///    The last format was canceled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SHFMT_NOFORMAT</b></dt> </dl> </td>
///    <td width="60%"> The drive cannot be formatted. </td> </tr> </table>
///    
@DllImport("SHELL32")
uint SHFormatDrive(HWND hwnd, uint drive, uint fmtID, uint options);

///<p class="CCE_Message">[<b>SHDestroyPropSheetExtArray</b> is available for use in the operating systems specified in
///the Requirements section. It may be altered or unavailable in subsequent versions.] Frees property sheet handlers
///that are pointed to an array created by SHCreatePropSheetExtArray.
///Params:
///    hpsxa = Type: <b>HPSXA</b> The handle of the array that contains pointers to the property sheet handlers to destroy.
@DllImport("SHELL32")
void SHDestroyPropSheetExtArray(HPSXA__* hpsxa);

///<p class="CCE_Message">[This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be altered or unavailable in subsequent versions of Windows.] Adds pages to a property sheet extension array
///created by SHCreatePropSheetExtArray.
///Params:
///    hpsxa = Type: <b>HPSXA</b> The array of property sheet handlers returned by SHCreatePropSheetExtArray.
///    lpfnAddPage = Type: <b>LPFNADDPROPSHEETPAGE</b> A pointer to an AddPropSheetPageProc callback function. It is called once for
///                  each property sheet handler. The callback function then returns the information needed to add a page to the
///                  handler's property sheet.
///    lParam = Type: <b>LPARAM</b> A pointer to application-defined data. This data is passed to the callback function specified
///             by <i>lpfnAddPage</i>.
///Returns:
///    Type: <b>UINT</b> Returns the number of pages actually added.
///    
@DllImport("SHELL32")
uint SHAddFromPropSheetExtArray(HPSXA__* hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

///<p class="CCE_Message">[This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be altered or unavailable in subsequent versions of Windows.] Requests each property sheet in a property
///sheet extension array to replace pages. Each page is allowed up to one replacement.
///Params:
///    hpsxa = Type: <b>HPSXA</b> A property sheet array handle (HPSXA) returned from a call to SHCreatePropSheetExtArray.
///    uPageID = Type: <b>UINT</b> The ID of the page to replace.
///    lpfnReplaceWith = Type: <b>LPFNADDPROPSHEETPAGE</b> A pointer to an AddPropSheetPageProc function used by the property sheet
///                      extension to add a page to a property sheet.
///    lParam = Type: <b>LPARAM</b> An application-defined value.
@DllImport("SHELL32")
uint SHReplaceFromPropSheetExtArray(HPSXA__* hpsxa, uint uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
                                    LPARAM lParam);

///<p class="CCE_Message">[<b>OpenRegStream</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Instead, use SHOpenRegStream2 or
///SHOpenRegStream.] Opens a registry value and supplies an IStream interface that can be used to read from or write to
///the value.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the key that is currently open.
///    pszSubkey = Type: <b>PCWSTR</b> A null-terminated Unicode string that specifies the name of the subkey.
///    pszValue = Type: <b>PCWSTR</b> A null-terminated Unicode string that specifies the value to be accessed.
///    grfMode = Type: <b>DWORD</b> The type of access for the stream. This can be one of the following values.
@DllImport("SHELL32")
IStream OpenRegStream(HKEY hkey, const(wchar)* pszSubkey, const(wchar)* pszValue, uint grfMode);

///<p class="CCE_Message">[<b>SHFindFiles</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Displays the <b>Search</b> window UI.
///Params:
///    pidlFolder = Type: <b>PCIDLIST_ABSOLUTE</b> The folder from which to start the search. This folder appears in the <b>Look
///                 in:</b> box in the <b>Search</b> window. This folder and all of its subfolders are searched unless users choose
///                 other options in the <b>Search</b> window's <b>More Advanced Options</b>. This value can be <b>NULL</b>.
///    pidlSaveFile = Type: <b>PCIDLIST_ABSOLUTE</b> This parameter is not used and must be set to <b>NULL</b>. <b>Windows Server 2003
///                   and Windows XP: </b>A saved search file (.fnd) to load. You can save search parameters to a .fnd file after the
///                   search is begun. This value can be <b>NULL</b>.
@DllImport("SHELL32")
BOOL SHFindFiles(ITEMIDLIST* pidlFolder, ITEMIDLIST* pidlSaveFile);

///<p class="CCE_Message">[<b>PathGetShortPath</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Retrieves the short path form of a
///specified input path.
@DllImport("SHELL32")
void PathGetShortPath(const(wchar)* pszLongPath);

///Creates a unique filename based on an existing filename.
///Params:
///    pszUniqueName = Type: <b>PWSTR</b> A string buffer that receives a null-terminated Unicode string that contains the fully
///                    qualified path of the unique file name. This buffer should be at least MAX_PATH characters long to avoid causing
///                    a buffer overrun.
///    pszPath = Type: <b>PCWSTR</b> A null-terminated Unicode string that contains the fully qualified path of folder that will
///              contain the new file. If <i>pszShort</i> is set to <b>NULL</b>, this string must contain a full destination path,
///              ending with the long file name that the new file name will be base on.
///    pszShort = Type: <b>PCWSTR</b> A null-terminated Unicode string that contains the short file name that the unique name will
///               be based on. Set this value to <b>NULL</b> to create a name based on the long file name.
///    pszFileSpec = Type: <b>PCWSTR</b> A null-terminated Unicode string that contains the long file name that the unique name will
///                  be based on.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if a unique name was successfully created; otherwise <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL PathYetAnotherMakeUniqueName(const(wchar)* pszUniqueName, const(wchar)* pszPath, const(wchar)* pszShort, 
                                  const(wchar)* pszFileSpec);

///<p class="CCE_Message">[<b>Win32DeleteFile</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Deletes a file.
///Params:
///    pszPath = Type: <b>PCWSTR</b> A pointer to a buffer that contains the full name of the file to delete.
@DllImport("SHELL32")
BOOL Win32DeleteFile(const(wchar)* pszPath);

///<p class="CCE_Message">[<b>SHRestricted</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Determines whether a specified
///administrator policy is in effect. In many cases, applications need to modify certain behaviors to comply with the
///policies enacted by system administrators.
///Params:
///    rest = Type: <b>RESTRICTIONS</b> Specifies one of the flags described in the RESTRICTIONS enumerated type.
@DllImport("SHELL32")
uint SHRestricted(RESTRICTIONS rest);

///<p class="CCE_Message">[<b>SignalFileOpen</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Sends a notification to the Shell
///that the specified file has been opened.
///Params:
///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL that specifies the file.
@DllImport("SHELL32")
BOOL SignalFileOpen(ITEMIDLIST* pidl);

///Retrieves the value for a given property key using the file association information provided by the Namespace
///Extensions.
///Params:
///    psf = Type: <b>IShellFolder*</b> A pointer to the shell folder for which the details of the property key of the file
///          association are being retrieved.
///    pidl = Type: <b>PCUITEMID_CHILD</b> The PIDL of the child item for which the file associations are being requested.
///    pkey = Type: <b>PROPERTYKEY*</b> A pointer to the property key that is being retrieved.
///    pv = Type: <b>VARIANT*</b> When this function returns, contains the details of the given property key.
///    pfFoundPropKey = Type: <b>BOOL*</b> When this function returns, contains a flag that is <b>TRUE</b> if the property key was found,
///                     otherwise <b>FALSE</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT AssocGetDetailsOfPropKey(IShellFolder psf, ITEMIDLIST* pidl, const(PROPERTYKEY)* pkey, VARIANT* pv, 
                                 int* pfFoundPropKey);

///<p class="CCE_Message">[<b>SHStartNetConnectionDialog</b> is available for use in the operating systems specified in
///the Requirements section. It may be altered or unavailable in subsequent versions.] Displays a general browsing
///dialog box for a network resource connection.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to the parent window.
///    pszRemoteName = Type: <b>LPCTSTR</b> A pointer to a null-terminated character string that specifies the remote network name. This
///                    value can be set to <b>NULL</b>.
///    dwType = Type: <b>DWORD</b> A bitfield that contains a set of flags that identify the type of resource that the dialog box
///             is set to find. This value can contain one of the following values, defined in Winnetwk.h:
///Returns:
///    Type: <b>HRESULT</b> Always returns S_OK.
///    
@DllImport("SHELL32")
HRESULT SHStartNetConnectionDialogW(HWND hwnd, const(wchar)* pszRemoteName, uint dwType);

///Provides a default handler to extract an icon from a file.
///Params:
///    pszIconFile = Type: <b>LPCTSTR</b> A pointer to a null-terminated buffer that contains the path and name of the file from which
///                  the icon is extracted.
///    iIndex = Type: <b>int</b> The location of the icon within the file named in <i>pszIconFile</i>. If this is a positive
///             number, it refers to the zero-based position of the icon in the file. For instance, 0 refers to the 1st icon in
///             the resource file and 2 refers to the 3rd. If this is a negative number, it refers to the icon's resource ID.
///    uFlags = Type: <b>UINT</b> A flag that controls the icon extraction.
///    phiconLarge = Type: <b>HICON*</b> A pointer to an HICON that, when this function returns successfully, receives the handle of
///                  the large version of the icon specified in the LOWORD of <i>nIconSize</i>. This value can be <b>NULL</b>.
///    phiconSmall = Type: <b>HICON*</b> A pointer to an HICON that, when this function returns successfully, receives the handle of
///                  the small version of the icon specified in the HIWORD of <i>nIconSize</i>.
///    nIconSize = Type: <b>UINT</b> A value that contains the large icon size in its LOWORD and the small icon size in its HIWORD.
///                Size is measured in pixels. Pass 0 to specify default large and small sizes.
///Returns:
///    Type: <b>HRESULT</b> This function can return one of these values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The requested icon is
///    not present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The file
///    cannot be accessed, or is being accessed through a slow link. </td> </tr> </table>
///    
@DllImport("SHELL32")
HRESULT SHDefExtractIconA(const(char)* pszIconFile, int iIndex, uint uFlags, HICON* phiconLarge, 
                          HICON* phiconSmall, uint nIconSize);

///Provides a default handler to extract an icon from a file.
///Params:
///    pszIconFile = Type: <b>LPCTSTR</b> A pointer to a null-terminated buffer that contains the path and name of the file from which
///                  the icon is extracted.
///    iIndex = Type: <b>int</b> The location of the icon within the file named in <i>pszIconFile</i>. If this is a positive
///             number, it refers to the zero-based position of the icon in the file. For instance, 0 refers to the 1st icon in
///             the resource file and 2 refers to the 3rd. If this is a negative number, it refers to the icon's resource ID.
///    uFlags = Type: <b>UINT</b> A flag that controls the icon extraction.
///    phiconLarge = Type: <b>HICON*</b> A pointer to an HICON that, when this function returns successfully, receives the handle of
///                  the large version of the icon specified in the LOWORD of <i>nIconSize</i>. This value can be <b>NULL</b>.
///    phiconSmall = Type: <b>HICON*</b> A pointer to an HICON that, when this function returns successfully, receives the handle of
///                  the small version of the icon specified in the HIWORD of <i>nIconSize</i>.
///    nIconSize = Type: <b>UINT</b> A value that contains the large icon size in its LOWORD and the small icon size in its HIWORD.
///                Size is measured in pixels. Pass 0 to specify default large and small sizes.
///Returns:
///    Type: <b>HRESULT</b> This function can return one of these values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The requested icon is
///    not present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The file
///    cannot be accessed, or is being accessed through a slow link. </td> </tr> </table>
///    
@DllImport("SHELL32")
HRESULT SHDefExtractIconW(const(wchar)* pszIconFile, int iIndex, uint uFlags, HICON* phiconLarge, 
                          HICON* phiconSmall, uint nIconSize);

///Displays the <b>Open With</b> dialog box.
///Params:
///    hwndParent = Type: <b>HWND</b> The handle of the parent window. This value can be <b>NULL</b>.
///    poainfo = Type: <b>const OPENASINFO*</b> A pointer to an OPENASINFO structure, which specifies the contents of the
///              resulting dialog.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHOpenWithDialog(HWND hwndParent, const(OPENASINFO)* poainfo);

///<p class="CCE_Message">[This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be altered or unavailable in subsequent versions of Windows.] Retrieves system image lists for large and
///small icons.
///Params:
///    phiml = Type: <b>HIMAGELIST*</b> A pointer to the handle of an image list which, on success, receives the system image
///            list for large (32 x 32) icons.
///    phimlSmall = Type: <b>HIMAGELIST*</b> A pointer to the handle of an image list which, on success, receives the system image
///                 list for small (16 x 16) icons.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> on success. On failure, returns <b>FALSE</b> and the image lists pointed to
///    by <i>phiml</i> and <i>phimlSmall</i> are unchanged.
///    
@DllImport("SHELL32")
BOOL Shell_GetImageLists(HIMAGELIST* phiml, HIMAGELIST* phimlSmall);

///<p class="CCE_Message">[<b>Shell_GetCachedImageIndex</b> is available for use in the operating systems specified in
///the Requirements section. It may be altered or unavailable in subsequent versions. Instead, use
///<b>Shell_GetCachedImageIndexA</b> or <b>Shell_GetCachedImageIndexW</b>.] Retrieves the cache index of a cached icon.
///Params:
///    pwszIconPath = Type: <b>PCWSTR</b> A pointer to a buffer that contains the path to the image file.
///    iIconIndex = Type: <b>int</b> The index of the image within the file named at <i>pwszIconPath</i>.
///    uIconFlags = Type: <b>UINT</b> Not used.
///Returns:
///    Type: <b>int</b> Returns the index of the image, or –1 on failure.
///    
@DllImport("SHELL32")
int Shell_GetCachedImageIndex(const(wchar)* pwszIconPath, int iIconIndex, uint uIconFlags);

///<p class="CCE_Message">[<b>Shell_GetCachedImageIndex</b> is available for use in the operating systems specified in
///the Requirements section. It may be altered or unavailable in subsequent versions. Instead, use
///<b>Shell_GetCachedImageIndexA</b> or <b>Shell_GetCachedImageIndexW</b>.] Retrieves the cache index of a cached icon.
///Params:
///    pszIconPath = TBD
///    iIconIndex = Type: <b>int</b> The index of the image within the file named at <i>pwszIconPath</i>.
///    uIconFlags = Type: <b>UINT</b> Not used.
///Returns:
///    Type: <b>int</b> Returns the index of the image, or –1 on failure.
///    
@DllImport("SHELL32")
int Shell_GetCachedImageIndexA(const(char)* pszIconPath, int iIconIndex, uint uIconFlags);

///<p class="CCE_Message">[<b>Shell_GetCachedImageIndex</b> is available for use in the operating systems specified in
///the Requirements section. It may be altered or unavailable in subsequent versions. Instead, use
///<b>Shell_GetCachedImageIndexA</b> or <b>Shell_GetCachedImageIndexW</b>.] Retrieves the cache index of a cached icon.
///Params:
///    pszIconPath = TBD
///    iIconIndex = Type: <b>int</b> The index of the image within the file named at <i>pwszIconPath</i>.
///    uIconFlags = Type: <b>UINT</b> Not used.
///Returns:
///    Type: <b>int</b> Returns the index of the image, or –1 on failure.
///    
@DllImport("SHELL32")
int Shell_GetCachedImageIndexW(const(wchar)* pszIconPath, int iIconIndex, uint uIconFlags);

///<p class="CCE_Message">[<b>SHValidateUNC</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Validates a Universal Naming
///Convention (UNC) path by calling WNetAddConnection3. The function makes it possible for the user to type a remote
///network access (RNA) UNC application or document name from the <b>Run</b> dialog box on the <b>Start</b> menu.
///Params:
///    hwndOwner = Type: <b>HWND</b> Handle of the parent window, used to display UI. If this is not needed, this value can be set
///                to <b>NULL</b>.
///    pszFile = Type: <b>PWSTR</b> A pointer to a null-terminated Unicode string that specifies the UNC path to validate. Note:
///              This string must not be a constant string.
///    fConnect = Type: <b>UINT</b> One or more of the following values.
@DllImport("SHELL32")
BOOL SHValidateUNC(HWND hwndOwner, const(wchar)* pszFile, uint fConnect);

///Provides an interface that allows hosted Shell extensions and other components to prevent their host process from
///closing prematurely. The host process is typically Windows Explorer or Windows Internet Explorer, but this function
///can also be used by other applications.
///Params:
///    punk = Type: <b>IUnknown*</b> A pointer to a free-threaded IUnknown. Components can use this interface (through
///           SHGetInstanceExplorer) to prevent the host process from terminating. This value can be <b>NULL</b>, in which case
///           the process reference is no longer made available to components.
@DllImport("SHELL32")
void SHSetInstanceExplorer(IUnknown punk);

///<p class="CCE_Message">[<b>IsUserAnAdmin</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Tests whether the current user is a
///member of the Administrator's group.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the user is a member of the Administrator's group; otherwise,
///    <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL IsUserAnAdmin();

///<p class="CCE_Message">[<b>SHShellFolderView_Message</b> is available for use in the operating systems specified in
///the Requirements section. It may be altered or unavailable in subsequent versions.] Sends a message to the shell's
///default IFolderView implementation (DefView).
///Params:
///    hwndMain = Type: <b>HWND</b> A handle to the window that receives the message.
///    uMsg = Type: <b>UINT</b> The message to send. The following is a list of possible messages. <table class="clsStd"> <tr>
///           <th>Message</th> <th>Description</th> </tr> <tr> <td> SFVM_ADDOBJECT </td> <td>Adds an object to the shell
///           view.</td> </tr> <tr> <td> SFVM_GETSELECTEDOBJECTS </td> <td>Retrieves an array of PIDLs for all selected
///           objects.</td> </tr> <tr> <td> SFVM_REARRANGE </td> <td>Notifies the IShellView to rearrange its items.</td> </tr>
///           <tr> <td> SFVM_REMOVEOBJECT </td> <td>Removes an object from the shell view.</td> </tr> <tr> <td>
///           SFVM_SETCLIPBOARD </td> <td>Notifies the IShellView when one of its objects is placed on the clipboard as a
///           result of a menu command.</td> </tr> <tr> <td> SFVM_SETITEMPOS </td> <td>Sets the position of an item in the
///           shell view.</td> </tr> <tr> <td> SFVM_SETPOINTS </td> <td>Sets the points of the currently selected objects to
///           the data object on <b>copy</b> and <b>cut</b> commands.</td> </tr> <tr> <td> SFVM_UPDATEOBJECT </td> <td>Updates
///           an object by passing a pointer to an array of two PIDLs.</td> </tr> </table>
///    lParam = Type: <b>LPARAM</b> Contents of this value depend on the message passed in <i>uMsg</i>. See individual message
///             topics for more information.
///Returns:
///    Type: <b>LRESULT</b> The return value depends on the message passed in <i>uMsg</i>. See individual message topics
///    for more information.
///    
@DllImport("SHELL32")
LRESULT SHShellFolderView_Message(HWND hwndMain, uint uMsg, LPARAM lParam);

///Creates a new instance of the default Shell folder view object (DefView).
///Params:
///    pcsfv = Type: <b>const SFV_CREATE*</b> Pointer to a SFV_CREATE structure that describes the particulars used in creating
///            this instance of the Shell folder view object.
///    ppsv = Type: <b>IShellView**</b> When this function returns successfully, contains an interface pointer to the new
///           IShellView object. On failure, this value is <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCreateShellFolderView(const(SFV_CREATE)* pcsfv, IShellView* ppsv);

///Creates a context menu for a selected group of file folder objects.
///Params:
///    pidlFolder = Type: <b>PCIDLIST_ABSOLUTE</b> An ITEMIDLIST structure for the parent folder. This value can be <b>NULL</b>.
///    hwnd = Type: <b>HWND</b> A handle to the parent window. This value can be <b>NULL</b>.
///    cidl = Type: <b>UINT</b> The number of ITEMIDLIST structures in the array pointed to by <i>apidl</i>.
///    apidl = Type: <b>PCUITEMID_CHILD_ARRAY*</b> A pointer to an array of ITEMIDLIST structures, one for each item that is
///            selected.
///    psf = Type: <b>IShellFolder*</b> A pointer to the parent folder's IShellFolder interface. This <b>IShellFolder</b> must
///          support the IDataObject interface. If it does not, <b>CDefFolderMenu_Create2</b> fails and returns E_NOINTERFACE.
///          This value can be <b>NULL</b>.
///    pfn = Type: <b>LPFNDFMCALLBACK</b> The LPFNDFMCALLBACK callback object. This value can be <b>NULL</b> if the callback
///          object is not needed.
///    nKeys = Type: <b>UINT</b> The number of registry keys in the array pointed to by <i>ahkeys</i>. <div
///            class="alert"><b>Note</b> The maximum number of registry keys is 16. Callers must enforce this limit as the API
///            does not. Failing to do so can result in memory corruption.</div> <div> </div>
///    ahkeys = Type: <b>const HKEY*</b> A pointer to an array of registry keys that specify the context menu handlers used with
///             the menu's entries. For more information on context menu handlers, see Creating Context Menu Handlers. This array
///             can contain a maximum of 16 registry keys.
///    ppcm = Type: <b>IContextMenu**</b> The address of an IContextMenu interface pointer that, when this function returns
///           successfully, points to the <b>IContextMenu</b> object that represents the context menu.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT CDefFolderMenu_Create2(ITEMIDLIST* pidlFolder, HWND hwnd, uint cidl, char* apidl, IShellFolder psf, 
                               LPFNDFMCALLBACK pfn, uint nKeys, char* ahkeys, IContextMenu* ppcm);

///Creates an object that represents the Shell's default context menu implementation.
///Params:
///    pdcm = Type: <b>const DEFCONTEXTMENU*</b> A pointer to a constant DEFCONTEXTMENU structure.
///    riid = Type: <b>REFIID</b> Reference to the interface ID of the interface on which to base the object. This is typically
///           the IID of IContextMenu, IContextMenu2, or IContextMenu3.
///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCreateDefaultContextMenu(const(DEFCONTEXTMENU)* pdcm, const(GUID)* riid, void** ppv);

///<p class="CCE_Message">[<b>SHFind_InitMenuPopup</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Retrieves the IContextMenu instance
///for the submenu of options displayed for the <b>Search</b> entry in the Classic style Start menu.
///Params:
///    hmenu = Type: <b>HMENU</b> The handle of the popup menu.
///    hwndOwner = Type: <b>HWND</b> The handle of the popup menu's owner window. This value can be <b>NULL</b>.
///    idCmdFirst = Type: <b>UINT</b> The ID of the first menu item.
///    idCmdLast = Type: <b>UINT</b> The ID of the last menu item.
@DllImport("SHELL32")
IContextMenu SHFind_InitMenuPopup(HMENU hmenu, HWND hwndOwner, uint idCmdFirst, uint idCmdLast);

///Creates a new instance of the default Shell folder view object. It is recommended that you use
///SHCreateShellFolderView rather than this function.
///Params:
///    pcsfv = Type: <b>CSFV*</b> Pointer to a structure that describes the details used in creating this instance of the Shell
///            folder view object.
///    ppsv = Type: <b>IShellView**</b> The address of an IShellView interface pointer that, when this function returns
///           successfully, points to the new view object. On failure, this value is <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCreateShellFolderViewEx(CSFV* pcsfv, IShellView* ppsv);

///<p class="CCE_Message">[<b>SHGetSetSettings</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Sets or retrieves Shell state
///settings.
///Params:
///    lpss = Type: <b>LPSHELLSTATE</b> A pointer to a SHELLSTATE structure that provides or receives the Shell state settings.
///    dwMask = Type: <b>DWORD</b> One or more of the SSF flags that indicate which settings should be set or retrieved.
///    bSet = Type: <b>BOOL</b> <b>TRUE</b> to indicate that the contents of <i>lpss</i> should be used to set the Shell
///           settings, <b>FALSE</b> to indicate that the Shell settings should be retrieved to <i>lpss</i>.
@DllImport("SHELL32")
void SHGetSetSettings(SHELLSTATEA* lpss, uint dwMask, BOOL bSet);

///Retrieves the current Shell option settings.
///Params:
///    psfs = Type: <b>LPSHELLFLAGSTATE</b> The address of a SHELLFLAGSTATE structure that receives the Shell option settings.
///    dwMask = Type: <b>DWORD</b> A set of flags that determine which members of <i>lpsfs</i> are being requested. This can be
///             one or more of the following values.
@DllImport("SHELL32")
void SHGetSettings(SHELLFLAGSTATE* psfs, uint dwMask);

///Takes a pointer to a fully qualified item identifier list (PIDL), and returns a specified interface pointer on the
///parent object.
///Params:
///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> The item's PIDL.
///    riid = Type: <b>REFIID</b> The <b>REFIID</b> of one of the interfaces exposed by the item's parent object.
///    ppv = Type: <b>VOID**</b> A pointer to the interface specified by <i>riid</i>. You must release the object when you are
///          finished.
///    ppidlLast = Type: <b>PCUITEMID_CHILD*</b> The item's PIDL relative to the parent folder. This PIDL can be used with many of
///                the methods supported by the parent folder's interfaces. If you set <i>ppidlLast</i> to <b>NULL</b>, the PIDL is
///                not returned. <div class="alert"><b>Note</b> <b>SHBindToParent</b> does not allocate a new PIDL; it simply
///                receives a pointer through this parameter. Therefore, you are not responsible for freeing this resource.</div>
///                <div> </div>
@DllImport("SHELL32")
HRESULT SHBindToParent(ITEMIDLIST* pidl, const(GUID)* riid, void** ppv, ITEMIDLIST** ppidlLast);

///Given a Shell namespace item specified in the form of a folder, and an item identifier list relative to that folder,
///this function binds to the parent of the namespace item and optionally returns a pointer to the final component of
///the item identifier list.
///Params:
///    psfRoot = Type: <b>IShellFolder*</b> A pointer to a Shell folder object. If <i>psfRoot</i> is <b>NULL</b>, indicates that
///              the IDList passed is relative to the desktop.
///    pidl = Type: <b>PCUIDLIST_RELATIVE</b> A PIDL to bind to, relative to <i>psfRoot</i>. If <i>psfRoot</i> is <b>NULL</b>,
///           this is an absolute IDList relative to the desktop folder.
///    riid = Type: <b>REFIID</b> Reference to the desired interface ID. This is typically IID_IShellFolder or
///           IID_IShellFolder2, but can be anything supported by the target folder.
///    ppv = Type: <b>void**</b> When this function returns, contains the interface pointer requested in <i>riid</i>. This is
///          typically IShellFolder or IShellFolder2, but can be anything supported by the target folder.
///    ppidlLast = Type: <b>PCUITEMID_CHILD*</b> A pointer to the last ID of the <i>pidl</i> parameter, and is a child ID relative
///                to the parent folder returned in <i>ppv</i>. This value can be <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHBindToFolderIDListParent(IShellFolder psfRoot, ITEMIDLIST* pidl, const(GUID)* riid, void** ppv, 
                                   ITEMIDLIST** ppidlLast);

///Extends the SHBindToFolderIDListParent function by allowing the caller to specify a bind context.
///Params:
///    psfRoot = Type: <b>IShellFolder*</b> A pointer to a Shell folder object. If <i>psfRoot</i> is <b>NULL</b>, indicates that
///              the IDList passed is relative to the desktop.
///    pidl = Type: <b>PCUIDLIST_RELATIVE</b> A PIDL to bind to, relative to <i>psfRoot</i>. If <i>psfRoot</i> is <b>NULL</b>,
///           this is an absolute IDList relative to the desktop folder.
///    ppbc = Type: <b>IBindCtx*</b> A pointer to IBindCtx interface on a bind context object to be used during this operation.
///           If this parameter is not used, set it to <b>NULL</b>, which is equivalent to calling the
///           SHBindToFolderIDListParent function. Because support for <i>pbc</i> is optional for folder object
///           implementations, some folders may not support the use of bind contexts.
///    riid = Type: <b>REFIID</b> Reference to the desired interface ID. This is typically IID_IShellFolder or
///           IID_IShellFolder2, but can be anything supported by the target folder.
///    ppv = Type: <b>void**</b> When this function returns, contains the interface pointer requested in <i>riid</i>. This is
///          typically IShellFolder or IShellFolder2, but can be anything supported by the target folder.
///    ppidlLast = Type: <b>PCUITEMID_CHILD*</b> A pointer to the last ID of the <i>pidl</i> parameter, and is a child ID relative
///                to the parent folder returned in <i>ppv</i>. This value can be <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHBindToFolderIDListParentEx(IShellFolder psfRoot, ITEMIDLIST* pidl, IBindCtx ppbc, const(GUID)* riid, 
                                     void** ppv, ITEMIDLIST** ppidlLast);

///Retrieves and binds to a specified object by using the Shell namespace IShellFolder::BindToObject method.
///Params:
///    psf = Type: <b>IShellFolder*</b> A pointer to IShellFolder. This parameter can be <b>NULL</b>. If <i>psf</i> is
///          <b>NULL</b>, this indicates parameter <i>pidl</i> is relative to the desktop. In this case, <i>pidl</i> must
///          specify an absolute ITEMIDLIST.
///    pidl = Type: <b>PCUIDLIST_RELATIVE</b> A pointer to a constant ITEMIDLIST to bind to that is relative to <i>psf</i>. If
///           <i>psf</i> is <b>NULL</b>, this is an absolute <b>ITEMIDLIST</b> relative to the desktop folder.
///    pbc = Type: <b>IBindCtx*</b> A pointer to IBindCtx interface on a bind context object to be used during this operation.
///          If this parameter is not used, set it to <b>NULL</b>. Because support for <i>pbc</i> is optional for folder
///          object implementations, some folders may not support the use of bind contexts.
///    riid = Type: <b>REFIID</b> Identifier of the interface to return.
///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer as specified in <i>riid</i> to the
///          bound object. If an error occurs, contains a <b>NULL</b> pointer.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHBindToObject(IShellFolder psf, ITEMIDLIST* pidl, IBindCtx pbc, const(GUID)* riid, void** ppv);

///Translates a Shell namespace object's display name into an item identifier list and returns the attributes of the
///object. This function is the preferred method to convert a string to a pointer to an item identifier list (PIDL).
///Params:
///    pszName = Type: <b>LPCWSTR</b> A pointer to a zero-terminated wide string that contains the display name to parse.
///    pbc = Type: <b>IBindCtx*</b> A bind context that controls the parsing operation. This parameter is normally set to
///          <b>NULL</b>.
///    ppidl = Type: <b>PIDLIST_ABSOLUTE*</b> The address of a pointer to a variable of type ITEMIDLIST that receives the item
///            identifier list for the object. If an error occurs, then this parameter is set to <b>NULL</b>.
///    sfgaoIn = Type: <b>SFGAOF</b> A <b>ULONG</b> value that specifies the attributes to query. To query for one or more
///              attributes, initialize this parameter with the flags that represent the attributes of interest. For a list of
///              available SFGAO flags, see IShellFolder::GetAttributesOf.
///    psfgaoOut = Type: <b>SFGAOF*</b> A pointer to a <b>ULONG</b>. On return, those attributes that are true for the object and
///                were requested in <i>sfgaoIn</i> are set. An object's attribute flags can be zero or a combination of SFGAO
///                flags. For a list of available SFGAO flags, see IShellFolder::GetAttributesOf.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHParseDisplayName(const(wchar)* pszName, IBindCtx pbc, ITEMIDLIST** ppidl, uint sfgaoIn, uint* psfgaoOut);

///Checks to see if the path exists. This includes remounting mapped network drives, prompting for ejectable media to be
///reinserted, creating the paths, prompting for the media to be formatted, and providing the appropriate user
///interfaces, if necessary. Read/write permissions for the medium are not checked.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to a window that specifies the parent window to be used for any user interface windows
///           that must be created. If set to <b>NULL</b>, user interface windows are not created.
///    punkEnableModless = Type: <b>IUnknown*</b> A pointer to an IUnknown interface that specifies the IOleInPlaceActiveObject object that
///                        implements the EnableModeless method.
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that specifies the path to
///              be verified as valid for writing. This can be a UNC or file drive path.
///    dwFlags = Type: <b>DWORD</b> Flags that determine behavior options. This parameter can be a combination of the following
///              values.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if the path is available, or an error code otherwise. Note that a return value
///    of S_OK does not mean that the medium is writable; it simply means that the path is available.
///    
@DllImport("SHELL32")
HRESULT SHPathPrepareForWriteA(HWND hwnd, IUnknown punkEnableModless, const(char)* pszPath, uint dwFlags);

///Checks to see if the path exists. This includes remounting mapped network drives, prompting for ejectable media to be
///reinserted, creating the paths, prompting for the media to be formatted, and providing the appropriate user
///interfaces, if necessary. Read/write permissions for the medium are not checked.
///Params:
///    hwnd = Type: <b>HWND</b> A handle to a window that specifies the parent window to be used for any user interface windows
///           that must be created. If set to <b>NULL</b>, user interface windows are not created.
///    punkEnableModless = Type: <b>IUnknown*</b> A pointer to an IUnknown interface that specifies the IOleInPlaceActiveObject object that
///                        implements the EnableModeless method.
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that specifies the path to
///              be verified as valid for writing. This can be a UNC or file drive path.
///    dwFlags = Type: <b>DWORD</b> Flags that determine behavior options. This parameter can be a combination of the following
///              values.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if the path is available, or an error code otherwise. Note that a return value
///    of S_OK does not mean that the medium is writable; it simply means that the path is available.
///    
@DllImport("SHELL32")
HRESULT SHPathPrepareForWriteW(HWND hwnd, IUnknown punkEnableModless, const(wchar)* pszPath, uint dwFlags);

///<p class="CCE_Message">[<b>SHCreateFileExtractIcon</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Creates a default IExtractIcon
///handler for a file system object. Namespace extensions that display file system objects typically use this function.
///The extension and file attributes derive all that is needed for a simple icon extractor.
///Params:
///    pszFile = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that specifies the file system object. The buffer must
///              not exceed MAX_PATH characters in length.
///    dwFileAttributes = Type: <b>DWORD</b> A combination of one or more file attribute flags (FILE_ATTRIBUTE_* values as defined in
///                       Winnt.h) that specify the type of object.
///    riid = Type: <b>REFIID</b> Reference to the desired interface ID of the icon extractor interface to create. This must be
///           either IID_IExtractIconA or IID_IExtractIconW.
///    ppv = Type: <b>void**</b> When this function returns, contains the interface pointer requested in <i>riid</i>. This is
///          typically IExtractIcon.
@DllImport("SHELL32")
HRESULT SHCreateFileExtractIconW(const(wchar)* pszFile, uint dwFileAttributes, const(GUID)* riid, void** ppv);

///<p class="CCE_Message">[This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be altered or unavailable in subsequent versions of Windows.] Sets limits on valid characters for an edit
///control.
///Params:
///    hwndEdit = Type: <b>HWND</b> The handle of the edit control.
///    psf = Type: <b>IShellFolder*</b> An IShellFolder interface pointer. This object must also implement IItemNameLimits,
///          which supplies a list of invalid characters and a maximum name length.
@DllImport("SHELL32")
HRESULT SHLimitInputEdit(HWND hwndEdit, IShellFolder psf);

///<p class="CCE_Message">[<b>SHGetAttributesFromDataObject</b> is available for use in the operating systems specified
///in the Requirements section. It may be altered or unavailable in subsequent versions.] Retrieves specified pieces of
///information from a system data object.
///Params:
///    pdo = Type: <b>IDataObject*</b> The data object from which to retrieve the information.
///    dwAttributeMask = Type: <b>DWORD</b> One or more of the SFGAO flags that indicate which pieces of information the calling
///                      application wants to retrieve.
///    pdwAttributes = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> value that, when this function returns successfully, receives one
///                    or more SFGAO flags that indicate the attributes, among those requested, that are common to all items in
///                    <i>pdo</i>. This pointer can be <b>NULL</b> if this information is not needed.
///    pcItems = Type: <b>UINT*</b> A pointer to a <b>UINT</b> that, when this function returns successfully, receives the number
///              of PIDLs in the data object pointed to by <i>pdo</i>. This pointer can be <b>NULL</b> if this information is not
///              needed.
@DllImport("SHELL32")
HRESULT SHGetAttributesFromDataObject(IDataObject pdo, uint dwAttributeMask, uint* pdwAttributes, uint* pcItems);

///<p class="CCE_Message">[<b>SHMapPIDLToSystemImageListIndex</b> is available for use in the operating systems
///specified in the Requirements section. It may be altered or unavailable in subsequent versions.] Retrieves the icon
///index from the system image list that is associated with a folder item.
///Params:
///    pshf = Type: <b>IShellFolder*</b> An IShellFolder interface pointer for the folder that contains the item.
///    pidl = Type: <b>PCUITEMID_CHILD</b> A pointer to the item's ITEMIDLIST structure.
///    piIndexSel = Type: <b>int*</b> A pointer to an <b>int</b> that, when this function returns successfully, receives the index of
///                 the item's <b>open</b> icon in the system image list. If the item does not have a special <b>open</b> icon then
///                 the index of its normal icon is returned. If the <b>open</b> icon exists and cannot be obtained, then the value
///                 pointed to by <i>piIndex</i> is set to -1. This parameter can be <b>NULL</b> if the calling application is not
///                 interested in the <b>open</b> icon.
@DllImport("SHELL32")
int SHMapPIDLToSystemImageListIndex(IShellFolder pshf, ITEMIDLIST* pidl, int* piIndexSel);

///<p class="CCE_Message">[This function is available through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be altered or unavailable in subsequent versions of Windows. Use CLSIDFromString instead.] Takes the string
///form of a class identifier (CLSID) and creates the corresponding CLSID.
///Params:
///    psz = Type: <b>PCWSTR</b> A Unicode string that contains the CLSID in the format,
///          <code>{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}</code>.
///    pclsid = Type: <b>CLSID*</b> A pointer to a CLSID value that, when this function returns successfully, receives the
///             converted string as a CLSID.
@DllImport("SHELL32")
HRESULT SHCLSIDFromString(const(wchar)* psz, GUID* pclsid);

///<p class="CCE_Message">[<b>PickIconDlg</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Displays a dialog box that allows the
///user to choose an icon from the selection available embedded in a resource such as an executable or DLL file.
///Params:
///    hwnd = Type: <b>HWND</b> The handle of the parent window. This value can be <b>NULL</b>.
///    pszIconPath = Type: <b>PWSTR</b> A pointer to a string that contains the null-terminated, fully qualified path of the default
///                  resource that contains the icons. If the user chooses a different resource in the dialog, this buffer contains
///                  the path of that file when the function returns. This buffer should be at least MAX_PATH characters in length, or
///                  the returned path may be truncated. You should verify that the path is valid before using it.
///    cchIconPath = Type: <b>UINT</b> The number of characters in <i>pszIconPath</i>, including the terminating <b>NULL</b>
///                  character.
///    piIconIndex = Type: <b>int*</b> A pointer to an integer that on entry specifies the index of the initial selection and, when
///                  this function returns successfully, receives the index of the icon that was selected.
@DllImport("SHELL32")
int PickIconDlg(HWND hwnd, const(wchar)* pszIconPath, uint cchIconPath, int* piIconIndex);

///Creates a unique name for a stream or storage object from a template.
///Params:
///    pstgParent = Type: <b>IStorage*</b> A pointer to an IStorage object.
///    pszFileSpec = Type: <b>PCWSTR</b> The format or template for the name of the stream or storage object.
///    grfMode = Type: <b>DWORD</b> The access mode to use when opening the stream or storage object. For more information and
///              descriptions of the possible values, see STGM Constants.
///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>, typically
///           IID_IStorage or IID_IStream.
///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This is
///          typically IStorage or IStream.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT StgMakeUniqueName(IStorage pstgParent, const(wchar)* pszFileSpec, uint grfMode, const(GUID)* riid, 
                          void** ppv);

///Enables asynchronous register and deregister of a thread.
@DllImport("SHELL32")
void SHChangeNotifyRegisterThread(SCNRT_STATUS status);

@DllImport("SHELL32")
void PathQualify(const(wchar)* psz);

///<p class="CCE_Message">[<b>PathIsSlow</b> is available for use in the operating systems specified in the Requirements
///section. It may be altered or unavailable in subsequent versions.] Determines whether a file path is a high-latency
///network connection.
///Params:
///    pszFile = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the fully qualified path of the file.
///    dwAttr = Type: <b>DWORD</b> The file attributes, if known; otherwise, pass –1 and this function gets the attributes by
///             calling GetFileAttributes. See <b>GetFileAttributes</b> for a list of file attributes.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the connection is high-latency; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL PathIsSlowA(const(char)* pszFile, uint dwAttr);

///<p class="CCE_Message">[<b>PathIsSlow</b> is available for use in the operating systems specified in the Requirements
///section. It may be altered or unavailable in subsequent versions.] Determines whether a file path is a high-latency
///network connection.
///Params:
///    pszFile = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the fully qualified path of the file.
///    dwAttr = Type: <b>DWORD</b> The file attributes, if known; otherwise, pass –1 and this function gets the attributes by
///             calling GetFileAttributes. See <b>GetFileAttributes</b> for a list of file attributes.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the connection is high-latency; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL PathIsSlowW(const(wchar)* pszFile, uint dwAttr);

///<p class="CCE_Message">[<b>SHCreatePropSheetExtArray</b> is available for use in the operating systems specified in
///the Requirements section. It may be altered or unavailable in subsequent versions.] Loads all the Shell property
///sheet extension handlers located under a specified registry key.
///Params:
///    hKey = Type: <b>HKEY</b> The registry root key that contains the subkey with the property sheet extension handlers. For
///           instance, <b>HKEY_LOCAL_MACHINE</b>.
///    pszSubKey = Type: <b>PCWSTR</b> A pointer to a null-terminated string specifying the name of the subkey that contains
///                <b>shellex</b>&
///    max_iface = Type: <b>UINT</b> The maximum number of property sheet handlers to be returned.
///Returns:
///    Type: <b>HPSXA</b> Returns a handle to an array of property sheet handlers. Pass this value to
///    SHAddFromPropSheetExtArray. You do not access this value directly.
///    
@DllImport("SHELL32")
HPSXA__* SHCreatePropSheetExtArray(HKEY hKey, const(wchar)* pszSubKey, uint max_iface);

///<p class="CCE_Message">[<b>SHOpenPropSheet</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Creates a property sheet from a list
///of registry keys that contain the <b>CLSID</b>s of the individual sheets, then opens the property sheet.
///Params:
///    pszCaption = Type: <b>LPCTSTR</b> A pointer to a string that contains the caption for the property sheet. This value can be
///                 <b>NULL</b> if no caption is needed.
///    ahkeys = Type: <b>HKEY[]</b> An array of registry keys that represent the <b>CLSID</b>s of the individual property sheets.
///    ckeys = Type: <b>UINT</b> <b>UINT</b> value that specifies the number of property sheets in the array specified by
///            <i>ahkeys</i>.
///    pclsidDefault = Type: <b>const CLSID*</b> A pointer to the default <b>CLSID</b>. This value can be <b>NULL</b>.
///    pdtobj = Type: <b>IDataObject*</b> A pointer to an IDataObject, an OLE object that can be used to carry out actions on the
///             property sheet(s).
///    psb = Type: <b>IShellBrowser*</b> Not used.
///    pStartPage = Type: <b>LPCTSTR</b> A pointer to a string that specifies the start page. This value can be <b>NULL</b>.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the property sheet was successfully created; otherwise, <b>FALSE</b>.
///    
@DllImport("SHELL32")
BOOL SHOpenPropSheetW(const(wchar)* pszCaption, char* ahkeys, uint ckeys, const(GUID)* pclsidDefault, 
                      IDataObject pdtobj, IShellBrowser psb, const(wchar)* pStartPage);

///Displays a standard message box that can be used to notify a user that an application has been updated.
///Params:
///    hWnd = Type: <b>HWND</b> A handle to the parent window.
///    pszDistUnit = Type: <b>PCWSTR</b> The string value containing the identifier for the code distribution unit. For ActiveX
///                  controls, <i>pszDistUnit</i> is typically a GUID.
///    dwFlags = Type: <b>DWORD</b> Reserved. Must be set to zero.
///    psdi = Type: <b>LPSOFTDISTINFO</b> A pointer to a SOFTDISTINFO structure that, when this method returns successfully,
///           receives the update information. The <b>cbSize</b> member must be initialized to the
///           <code>sizeof(SOFTDISTINFO)</code>.
///Returns:
///    Type: <b>DWORD</b> Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>IDNO</b></dt> </dl> </td> <td width="60%"> The user clicked the <b>Do Not
///    Update</b> button on the dialog box. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>IDYES</b></dt> </dl> </td> <td
///    width="60%"> The user clicked the <b>Update Now</b> or <b>About Update</b> button. The application should
///    navigate to the HTML page referred to by the <b>szHREF</b> member of the structure pointed to by <i>psdi</i>.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>IDIGNORE</b></dt> </dl> </td> <td width="60%"> There is no pending
///    software update. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>IDABORT</b></dt> </dl> </td> <td width="60%"> An
///    error occurred. </td> </tr> </table>
///    
@DllImport("SHDOCVW")
uint SoftwareUpdateMessageBox(HWND hWnd, const(wchar)* pszDistUnit, uint dwFlags, SOFTDISTINFO* psdi);

///Displays a merged property sheet for a set of files. Property values common to all the files are shown while those
///that differ display the string <b>(multiple values)</b>.
///Params:
///    pdtobj = Type: <b>IDataObject*</b> A pointer to a data object that supplies the PIDLs of all of the files for which to
///             display the merged property sheet. The data object must use the CFSTR_SHELLIDLIST clipboard format. The parent
///             folder's implementation of IShellFolder::GetDisplayNameOf must return a fully qualified file system path for each
///             item in response to the SHGDN_FORPARSING flag.
///    dwFlags = Type: <b>DWORD</b> Reserved. Must be set to 0.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHMultiFileProperties(IDataObject pdtobj, uint dwFlags);

///<p class="CCE_Message">[This function is deprecated. Use CreateClassMoniker instead. Note that the CLSID used in the
///call to <b>CreateClassMoniker</b> must be application-defined. Do not call <b>CreateClassMoniker</b> with a
///system-defined CLSID.] Deprecated. Creates a <b>QueryCancelAutoPlay</b> class moniker, which can then be used to
///register the IQueryCancelAutoPlay handler in the running object table (ROT).
///Params:
///    ppmoniker = Type: <b>IMoniker**</b> The address of a IMoniker interface pointer that, when this function returns
///                successfully, receives the <b>QueryCancelAutoPlay</b> class moniker. If this function call fails, this value is
///                <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHELL32")
HRESULT SHCreateQueryCancelAutoPlayMoniker(IMoniker* ppmoniker);

@DllImport("SHDOCVW")
BOOL ImportPrivacySettings(const(wchar)* pszFilename, int* pfParsePrivacyPreferences, int* pfParsePerSiteRules);

@DllImport("SHDOCVW")
HRESULT DoPrivacyDlg(HWND hwndOwner, const(wchar)* pszUrl, IEnumPrivacyRecords pPrivacyEnum, BOOL fReportAllSites);

///Gets the preferred scale factor for a display device. <div class="alert"><b>Note</b> This function is not supported
///as of Windows 8.1. Use GetScaleFactorForMonitor instead.</div><div> </div>
///Params:
///    deviceType = Type: <b>DISPLAY_DEVICE_TYPE</b> The value that indicates the type of the display device.
///Returns:
///    Type: <b>DEVICE_SCALE_FACTOR</b> A value that indicates the scale factor that should be used with the specified
///    DISPLAY_DEVICE_TYPE. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>SCALE_100_PERCENT</b></dt> <dt>100</dt> </dl> </td> <td width="60%"> Use a scale factor of 1x. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>SCALE_140_PERCENT</b></dt> <dt>140</dt> </dl> </td> <td width="60%"> Use
///    a scale factor of 1.4x. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SCALE_180_PERCENT</b></dt> <dt>180</dt>
///    </dl> </td> <td width="60%"> Use a scale factor of 1.8x. </td> </tr> </table>
///    
@DllImport("api-ms-win-shcore-scaling-l1-1-0")
DEVICE_SCALE_FACTOR GetScaleFactorForDevice(DISPLAY_DEVICE_TYPE deviceType);

///Registers a window to receive callbacks when scaling information changes. <div class="alert"><b>Note</b> This
///function is not supported as of Windows 8.1. Use RegisterScaleChangeEvent instead.</div><div> </div>
///Params:
///    displayDevice = Type: <b>DISPLAY_DEVICE_TYPE</b> The enum value that indicates which display device to receive notifications
///                    about.
///    hwndNotify = Type: <b>HWND</b> The handle of the window that will receive the notifications.
///    uMsgNotify = Type: <b>UINT</b> An application-defined message that is passed to the window specified by <i>hwndNotify</i> when
///                 scaling information changes. Typically, this should be set to WM_APP+<i>x</i>, where <i>x</i> is an integer
///                 value.
///    pdwCookie = Type: <b>DWORD*</b> Pointer to a value that, when this function returns successfully, receives a registration
///                token. This token is used to revoke notifications by calling RevokeScaleChangeNotifications.
///Returns:
///    Type: <b>STDAPI</b> If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b>
///    error code.
///    
@DllImport("api-ms-win-shcore-scaling-l1-1-0")
HRESULT RegisterScaleChangeNotifications(DISPLAY_DEVICE_TYPE displayDevice, HWND hwndNotify, uint uMsgNotify, 
                                         uint* pdwCookie);

///Revokes the registration of a window, preventing it from receiving callbacks when scaling information changes. <div
///class="alert"><b>Note</b> This function is not supported as of Windows 8.1. Use UnregisterScaleChangeEvent
///instead.</div><div> </div>
///Params:
///    displayDevice = Type: <b>DISPLAY_DEVICE_TYPE</b> The enum value that indicates which display device to receive notifications
///                    about.
///    dwCookie = Type: <b>DWORD</b> The registration token returned by a previous call to RegisterScaleChangeNotifications.
///Returns:
///    Type: <b>STDAPI</b> If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b>
///    error code.
///    
@DllImport("api-ms-win-shcore-scaling-l1-1-0")
HRESULT RevokeScaleChangeNotifications(DISPLAY_DEVICE_TYPE displayDevice, uint dwCookie);

///Gets the scale factor of a specific monitor. This function replaces GetScaleFactorForDevice.
///Params:
///    hMon = The monitor's handle.
///    pScale = When this function returns successfully, this value points to one of the DEVICE_SCALE_FACTOR values that specify
///             the scale factor of the specified monitor. If the function call fails, this value points to a valid scale factor
///             so that apps can opt to continue on with incorrectly sized resources.
///Returns:
///    If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
///    
@DllImport("api-ms-win-shcore-scaling-l1-1-1")
HRESULT GetScaleFactorForMonitor(ptrdiff_t hMon, DEVICE_SCALE_FACTOR* pScale);

///Registers for an event that is triggered when the scale has possibly changed. This function replaces
///RegisterScaleChangeNotifications.
///Params:
///    hEvent = Handle of the event to register for scale change notifications.
///    pdwCookie = When this function returns successfully, this value receives the address of a pointer to a cookie that can be
///                used later to unregister for the scale change notifications through UnregisterScaleChangeEvent.
///Returns:
///    If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
///    
@DllImport("api-ms-win-shcore-scaling-l1-1-1")
HRESULT RegisterScaleChangeEvent(HANDLE hEvent, size_t* pdwCookie);

///Unregisters for the scale change event registered through RegisterScaleChangeEvent. This function replaces
///RevokeScaleChangeNotifications.
///Params:
///    dwCookie = A pointer to the cookie retrieved in the call to RegisterScaleChangeEvent.
///Returns:
///    If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
///    
@DllImport("api-ms-win-shcore-scaling-l1-1-1")
HRESULT UnregisterScaleChangeEvent(size_t dwCookie);

///Retrieves the dots per inch (dpi) occupied by a SHELL_UI_COMPONENT based on the current scale factor and
///PROCESS_DPI_AWARENESS.
///Params:
///    Arg1 = The type of shell component.
@DllImport("api-ms-win-shcore-scaling-l1-1-2")
uint GetDpiForShellUIComponent(SHELL_UI_COMPONENT param0);

///Searches a string for the first occurrence of a character that matches the specified character. The comparison is
///case-sensitive.
///Params:
///    pszStart = Type: <b>PTSTR</b> The address of the string to be searched.
///    wMatch = Type: <b>TCHAR</b> The character to be used for comparison.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the first occurrence of the character in the string if successful, or
///    <b>NULL</b> otherwise.
///    
@DllImport("SHLWAPI")
byte* StrChrA(const(char)* pszStart, ushort wMatch);

///Searches a string for the first occurrence of a character that matches the specified character. The comparison is
///case-sensitive.
///Params:
///    pszStart = Type: <b>PTSTR</b> The address of the string to be searched.
///    wMatch = Type: <b>TCHAR</b> The character to be used for comparison.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the first occurrence of the character in the string if successful, or
///    <b>NULL</b> otherwise.
///    
@DllImport("SHLWAPI")
ushort* StrChrW(const(wchar)* pszStart, ushort wMatch);

///Searches a string for the first occurrence of a character that matches the specified character. The comparison is not
///case-sensitive.
///Params:
///    pszStart = Type: <b>PTSTR</b> A pointer to the string to be searched.
///    wMatch = Type: <b>TCHAR</b> The character to be used for comparison.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the first occurrence of the character in the string if successful, or
///    <b>NULL</b> otherwise.
///    
@DllImport("SHLWAPI")
byte* StrChrIA(const(char)* pszStart, ushort wMatch);

///Searches a string for the first occurrence of a character that matches the specified character. The comparison is not
///case-sensitive.
///Params:
///    pszStart = Type: <b>PTSTR</b> A pointer to the string to be searched.
///    wMatch = Type: <b>TCHAR</b> The character to be used for comparison.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the first occurrence of the character in the string if successful, or
///    <b>NULL</b> otherwise.
///    
@DllImport("SHLWAPI")
ushort* StrChrIW(const(wchar)* pszStart, ushort wMatch);

///Searches a string for the first occurrence of a specified character. The comparison is case-sensitive.
///Params:
///    pszStart = Type: <b>PWSTR</b> A pointer to the string to be searched.
///    wMatch = Type: <b>WCHAR</b> The character to be used for comparison.
///    cchMax = Type: <b>UINT</b> The maximum number of characters to search.
///Returns:
///    Type: <b>PWSTR</b> Returns the address of the first occurrence of the character in the string if successful, or
///    <b>NULL</b> otherwise.
///    
@DllImport("SHLWAPI")
ushort* StrChrNW(const(wchar)* pszStart, ushort wMatch, uint cchMax);

///Searches a string for the first occurrence of a specified character. The comparison is not case-sensitive.
///Params:
///    pszStart = Type: <b>PCWSTR</b> A pointer to the string to be searched.
///    wMatch = Type: <b>WCHAR</b> The character to be used for comparison.
///    cchMax = Type: <b>UINT</b> The maximum number of characters to search.
///Returns:
///    Type: <b>PWSTR</b> Returns the address of the first occurrence of the character in the string if successful, or
///    <b>NULL</b> otherwise.
///    
@DllImport("SHLWAPI")
ushort* StrChrNIW(const(wchar)* pszStart, ushort wMatch, uint cchMax);

///Compares a specified number of characters from the beginning of two strings to determine if they are the same. The
///comparison is case-sensitive. The <b>StrNCmp</b> macro differs from this function in name only.
///Params:
///    psz1 = Type: <b>PCTSTR</b> A pointer to the first null-terminated string to be compared.
///    psz2 = Type: <b>PCTSTR</b> A pointer to the second null-terminated string to be compared.
///    nChar = Type: <b>int</b> The number of characters from the beginning of each string to be compared.
///Returns:
///    Type: <b>int</b> Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i>
///    characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by
///    <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by
///    <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.
///    
@DllImport("SHLWAPI")
int StrCmpNA(const(char)* psz1, const(char)* psz2, int nChar);

///Compares a specified number of characters from the beginning of two strings to determine if they are the same. The
///comparison is case-sensitive. The <b>StrNCmp</b> macro differs from this function in name only.
///Params:
///    psz1 = Type: <b>PCTSTR</b> A pointer to the first null-terminated string to be compared.
///    psz2 = Type: <b>PCTSTR</b> A pointer to the second null-terminated string to be compared.
///    nChar = Type: <b>int</b> The number of characters from the beginning of each string to be compared.
///Returns:
///    Type: <b>int</b> Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i>
///    characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by
///    <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by
///    <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.
///    
@DllImport("SHLWAPI")
int StrCmpNW(const(wchar)* psz1, const(wchar)* psz2, int nChar);

///Compares a specified number of characters from the beginning of two strings to determine if they are the same. The
///comparison is not case-sensitive. The <b>StrNCmpI</b> macro differs from this function in name only.
///Params:
///    psz1 = Type: <b>PCTSTR</b> A pointer to the first null-terminated string to be compared.
///    psz2 = Type: <b>PCTSTR</b> A pointer to the second null-terminated string to be compared.
///    nChar = Type: <b>int</b> The number of characters from the beginning of each string to be compared.
///Returns:
///    Type: <b>int</b> Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i>
///    characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by
///    <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by
///    <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.
///    
@DllImport("SHLWAPI")
int StrCmpNIA(const(char)* psz1, const(char)* psz2, int nChar);

///Compares a specified number of characters from the beginning of two strings to determine if they are the same. The
///comparison is not case-sensitive. The <b>StrNCmpI</b> macro differs from this function in name only.
///Params:
///    psz1 = Type: <b>PCTSTR</b> A pointer to the first null-terminated string to be compared.
///    psz2 = Type: <b>PCTSTR</b> A pointer to the second null-terminated string to be compared.
///    nChar = Type: <b>int</b> The number of characters from the beginning of each string to be compared.
///Returns:
///    Type: <b>int</b> Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i>
///    characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by
///    <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by
///    <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.
///    
@DllImport("SHLWAPI")
int StrCmpNIW(const(wchar)* psz1, const(wchar)* psz2, int nChar);

///Searches a string for the first occurrence of any of a group of characters. The search method is case-sensitive, and
///the terminating <b>NULL</b> character is included within the search pattern match.
///Params:
///    pszStr = Type: <b>PCTSTR</b> A pointer to the null-terminated string to be searched.
///    pszSet = Type: <b>PCTSTR</b> A pointer to a null-terminated string that contains the characters to search for.
///Returns:
///    Type: <b>int</b> Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>,
///    or the length of <i>pszStr</i> if no match is found.
///    
@DllImport("SHLWAPI")
int StrCSpnA(const(char)* pszStr, const(char)* pszSet);

///Searches a string for the first occurrence of any of a group of characters. The search method is case-sensitive, and
///the terminating <b>NULL</b> character is included within the search pattern match.
///Params:
///    pszStr = Type: <b>PCTSTR</b> A pointer to the null-terminated string to be searched.
///    pszSet = Type: <b>PCTSTR</b> A pointer to a null-terminated string that contains the characters to search for.
///Returns:
///    Type: <b>int</b> Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>,
///    or the length of <i>pszStr</i> if no match is found.
///    
@DllImport("SHLWAPI")
int StrCSpnW(const(wchar)* pszStr, const(wchar)* pszSet);

///Searches a string for the first occurrence of any of a group of characters. The search method is not case-sensitive,
///and the terminating <b>NULL</b> character is included within the search pattern match.
///Params:
///    pszStr = Type: <b>PCTSTR</b> A pointer to the null-terminated string to be searched.
///    pszSet = Type: <b>PCTSTR</b> A pointer to a null-terminated string containing the characters to search for.
///Returns:
///    Type: <b>int</b> Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>,
///    or the length of <i>pszStr</i> if no match is found.
///    
@DllImport("SHLWAPI")
int StrCSpnIA(const(char)* pszStr, const(char)* pszSet);

///Searches a string for the first occurrence of any of a group of characters. The search method is not case-sensitive,
///and the terminating <b>NULL</b> character is included within the search pattern match.
///Params:
///    pszStr = Type: <b>PCTSTR</b> A pointer to the null-terminated string to be searched.
///    pszSet = Type: <b>PCTSTR</b> A pointer to a null-terminated string containing the characters to search for.
///Returns:
///    Type: <b>int</b> Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>,
///    or the length of <i>pszStr</i> if no match is found.
///    
@DllImport("SHLWAPI")
int StrCSpnIW(const(wchar)* pszStr, const(wchar)* pszSet);

///Duplicates a string.
///Params:
///    pszSrch = Type: <b>PCTSTR</b> A pointer to a constant <b>null</b>-terminated character string.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the string that was copied, or <b>NULL</b> if the string cannot be
///    copied.
///    
@DllImport("SHLWAPI")
byte* StrDupA(const(char)* pszSrch);

///Duplicates a string.
///Params:
///    pszSrch = Type: <b>PCTSTR</b> A pointer to a constant <b>null</b>-terminated character string.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the string that was copied, or <b>NULL</b> if the string cannot be
///    copied.
///    
@DllImport("SHLWAPI")
ushort* StrDupW(const(wchar)* pszSrch);

///Converts a numeric value into a string that represents the number in bytes, kilobytes, megabytes, or gigabytes,
///depending on the size. Extends StrFormatByteSizeW by offering the option to round to the nearest displayed digit or
///to discard undisplayed digits.
///Params:
///    ull = Type: <b>ULONGLONG</b> The numeric value to be converted.
///    flags = Type: <b>SFBS_FLAGS</b> One of the SFBS_FLAGS enumeration values that specifies whether to round or truncate
///            undisplayed digits. This value cannot be NULL.
///    pszBuf = Type: <b>PWSTR</b> A pointer to a buffer that receives the converted string.
///    cchBuf = Type: <b>UINT</b> The size of the buffer pointed to by <i>pszBuf</i>, in characters.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT StrFormatByteSizeEx(ulong ull, int flags, const(wchar)* pszBuf, uint cchBuf);

///Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes,
///megabytes, or gigabytes, depending on the size. Differs from StrFormatByteSizeW in one parameter type.
///Params:
///    dw = Type: <b>DWORD</b> The numeric value to be converted.
///    pszBuf = Type: <b>PSTR</b> A pointer to a buffer that receives the converted string.
///    cchBuf = Type: <b>UINT</b> The size of the buffer pointed to by <i>pszBuf</i>, in characters.
///Returns:
///    Type: <b>PSTR</b> Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
///    
@DllImport("SHLWAPI")
byte* StrFormatByteSizeA(uint dw, const(char)* pszBuf, uint cchBuf);

///Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes,
///megabytes, or gigabytes, depending on the size.
///Params:
///    qdw = Type: <b>LONGLONG</b> The numeric value to be converted.
///    pszBuf = Type: <b>PSTR</b> A pointer to a buffer that, when this function returns successfully, receives the converted
///             number.
///    cchBuf = Type: <b>UINT</b> The size of the buffer pointed to by <i>pszBuf</i>, in characters.
///Returns:
///    Type: <b>PSTR</b> Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
///    
@DllImport("SHLWAPI")
byte* StrFormatByteSize64A(long qdw, const(char)* pszBuf, uint cchBuf);

///Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes,
///megabytes, or gigabytes, depending on the size. Differs from StrFormatByteSizeA in one parameter type.
///Params:
///    qdw = Type: <b>LONGLONG</b> The numeric value to be converted.
///    pszBuf = Type: <b>PWSTR</b> A pointer to a buffer that, when this function returns successfully, receives the converted
///             number.
///    cchBuf = Type: <b>UINT</b> The size of the buffer pointed to by <i>pszBuf</i>, in characters.
///Returns:
///    Type: <b>PWSTR</b> Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
///    
@DllImport("SHLWAPI")
ushort* StrFormatByteSizeW(long qdw, const(wchar)* pszBuf, uint cchBuf);

///Converts a numeric value into a string that represents the number expressed as a size value in kilobytes.
///Params:
///    qdw = Type: <b>LONGLONG</b> The numeric value to be converted.
///    pszBuf = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the converted
///             number.
///    cchBuf = Type: <b>UINT</b> The size of <i>pszBuf</i>, in characters.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
///    
@DllImport("SHLWAPI")
ushort* StrFormatKBSizeW(long qdw, const(wchar)* pszBuf, uint cchBuf);

///Converts a numeric value into a string that represents the number expressed as a size value in kilobytes.
///Params:
///    qdw = Type: <b>LONGLONG</b> The numeric value to be converted.
///    pszBuf = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the converted
///             number.
///    cchBuf = Type: <b>UINT</b> The size of <i>pszBuf</i>, in characters.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
///    
@DllImport("SHLWAPI")
byte* StrFormatKBSizeA(long qdw, const(char)* pszBuf, uint cchBuf);

///Converts a time interval, specified in milliseconds, to a string.
///Params:
///    pszOut = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the converted
///             number.
///    cchMax = Type: <b>UINT</b> The size of <i>pszOut</i>, in characters. If <i>cchMax</i> is set to zero,
///             <b>StrFromTimeInterval</b> will return the minimum size of the character buffer needed to hold the converted
///             string. In this case, <i>pszOut</i> will not contain the converted string.
///    dwTimeMS = Type: <b>DWORD</b> The time interval, in milliseconds.
///    digits = Type: <b>int</b> The maximum number of significant digits to be represented in <i>pszOut</i>. Some examples are:
///             <table class="clsStd"> <tr> <th>dwTimeMS</th> <th>digits</th> <th>pszOut</th> </tr> <tr> <td>34000</td>
///             <td>3</td> <td>34 sec</td> </tr> <tr> <td>34000</td> <td>2</td> <td>34 sec</td> </tr> <tr> <td>34000</td>
///             <td>1</td> <td>30 sec</td> </tr> <tr> <td>74000</td> <td>3</td> <td>1 min 14 sec</td> </tr> <tr> <td>74000</td>
///             <td>2</td> <td>1 min 10 sec</td> </tr> <tr> <td>74000</td> <td>1</td> <td>1 min</td> </tr> </table>
///Returns:
///    Type: <b>int</b> Returns the number of characters in <i>pszOut</i>, excluding the terminating <b>NULL</b>
///    character.
///    
@DllImport("SHLWAPI")
int StrFromTimeIntervalA(const(char)* pszOut, uint cchMax, uint dwTimeMS, int digits);

///Converts a time interval, specified in milliseconds, to a string.
///Params:
///    pszOut = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the converted
///             number.
///    cchMax = Type: <b>UINT</b> The size of <i>pszOut</i>, in characters. If <i>cchMax</i> is set to zero,
///             <b>StrFromTimeInterval</b> will return the minimum size of the character buffer needed to hold the converted
///             string. In this case, <i>pszOut</i> will not contain the converted string.
///    dwTimeMS = Type: <b>DWORD</b> The time interval, in milliseconds.
///    digits = Type: <b>int</b> The maximum number of significant digits to be represented in <i>pszOut</i>. Some examples are:
///             <table class="clsStd"> <tr> <th>dwTimeMS</th> <th>digits</th> <th>pszOut</th> </tr> <tr> <td>34000</td>
///             <td>3</td> <td>34 sec</td> </tr> <tr> <td>34000</td> <td>2</td> <td>34 sec</td> </tr> <tr> <td>34000</td>
///             <td>1</td> <td>30 sec</td> </tr> <tr> <td>74000</td> <td>3</td> <td>1 min 14 sec</td> </tr> <tr> <td>74000</td>
///             <td>2</td> <td>1 min 10 sec</td> </tr> <tr> <td>74000</td> <td>1</td> <td>1 min</td> </tr> </table>
///Returns:
///    Type: <b>int</b> Returns the number of characters in <i>pszOut</i>, excluding the terminating <b>NULL</b>
///    character.
///    
@DllImport("SHLWAPI")
int StrFromTimeIntervalW(const(wchar)* pszOut, uint cchMax, uint dwTimeMS, int digits);

///Compares a specified number of characters from the beginning of two strings to determine if they are equal.
///Params:
///    fCaseSens = Type: <b>BOOL</b> The case sensitivity of the comparison. If this value is nonzero, the comparison is
///                case-sensitive. If this value is zero, the comparison is not case-sensitive.
///    pszString1 = Type: <b>PCTSTR</b> A pointer to the first null-terminated string to be compared.
///    pszString2 = Type: <b>PCTSTR</b> A pointer to the second null-terminated string to be compared.
///    nChar = Type: <b>int</b> The number of characters from the beginning of each string to be compared.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if the first <i>nChar</i> characters from the two strings are equal; otherwise,
///    <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL StrIsIntlEqualA(BOOL fCaseSens, const(char)* pszString1, const(char)* pszString2, int nChar);

///Compares a specified number of characters from the beginning of two strings to determine if they are equal.
///Params:
///    fCaseSens = Type: <b>BOOL</b> The case sensitivity of the comparison. If this value is nonzero, the comparison is
///                case-sensitive. If this value is zero, the comparison is not case-sensitive.
///    pszString1 = Type: <b>PCTSTR</b> A pointer to the first null-terminated string to be compared.
///    pszString2 = Type: <b>PCTSTR</b> A pointer to the second null-terminated string to be compared.
///    nChar = Type: <b>int</b> The number of characters from the beginning of each string to be compared.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if the first <i>nChar</i> characters from the two strings are equal; otherwise,
///    <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL StrIsIntlEqualW(BOOL fCaseSens, const(wchar)* pszString1, const(wchar)* pszString2, int nChar);

///Appends a specified number of characters from the beginning of one string to the end of another. <div
///class="alert"><b>Note</b> Do not use this function or the <b>StrCatN</b> macro. See Remarks for alternative
///functions.</div><div> </div>
///Params:
///    psz1 = Type: <b>PTSTR</b> A pointer to a null-terminated string to which the function appends the characters from
///           <i>psz2</i>. It must be large enough to hold the combined strings plus the terminating null character.
///    psz2 = Type: <b>PCTSTR</b> A pointer to the null-terminated string to be appended.
///    cchMax = Type: <b>int</b> The number of characters to be appended to <i>psz1</i> from the beginning of <i>psz2</i>.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to <i>psz1</i>, which holds the combined string.
///    
@DllImport("SHLWAPI")
byte* StrNCatA(const(char)* psz1, const(char)* psz2, int cchMax);

///Appends a specified number of characters from the beginning of one string to the end of another. <div
///class="alert"><b>Note</b> Do not use this function or the <b>StrCatN</b> macro. See Remarks for alternative
///functions.</div><div> </div>
///Params:
///    psz1 = Type: <b>PTSTR</b> A pointer to a null-terminated string to which the function appends the characters from
///           <i>psz2</i>. It must be large enough to hold the combined strings plus the terminating null character.
///    psz2 = Type: <b>PCTSTR</b> A pointer to the null-terminated string to be appended.
///    cchMax = Type: <b>int</b> The number of characters to be appended to <i>psz1</i> from the beginning of <i>psz2</i>.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to <i>psz1</i>, which holds the combined string.
///    
@DllImport("SHLWAPI")
ushort* StrNCatW(const(wchar)* psz1, const(wchar)* psz2, int cchMax);

///Searches a string for the first occurrence of a character contained in a specified buffer. This search does not
///include the terminating null character.
///Params:
///    psz = Type: <b>PTSTR</b> A pointer to the null-terminated string to be searched.
///    pszSet = Type: <b>PCTSTR</b> A pointer to a null-terminated character buffer that contains the characters for which to
///             search.
///Returns:
///    Type: <b>PTSTR</b> Returns the address in <i>psz</i> of the first occurrence of a character contained in the
///    buffer at <i>pszSet</i>, or <b>NULL</b> if no match is found.
///    
@DllImport("SHLWAPI")
byte* StrPBrkA(const(char)* psz, const(char)* pszSet);

///Searches a string for the first occurrence of a character contained in a specified buffer. This search does not
///include the terminating null character.
///Params:
///    psz = Type: <b>PTSTR</b> A pointer to the null-terminated string to be searched.
///    pszSet = Type: <b>PCTSTR</b> A pointer to a null-terminated character buffer that contains the characters for which to
///             search.
///Returns:
///    Type: <b>PTSTR</b> Returns the address in <i>psz</i> of the first occurrence of a character contained in the
///    buffer at <i>pszSet</i>, or <b>NULL</b> if no match is found.
///    
@DllImport("SHLWAPI")
ushort* StrPBrkW(const(wchar)* psz, const(wchar)* pszSet);

///Searches a string for the last occurrence of a specified character. The comparison is case-sensitive.
///Params:
///    pszStart = Type: <b>PTSTR</b> A pointer to the null-terminated string to be searched.
///    pszEnd = Type: <b>PCTSTR</b> A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to
///             point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to
///             <b>NULL</b> to search the entire string.
///    wMatch = Type: <b>TCHAR</b> The character to search for.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to the last occurrence of the character in the string, if successful, or
///    <b>NULL</b> if not.
///    
@DllImport("SHLWAPI")
byte* StrRChrA(const(char)* pszStart, const(char)* pszEnd, ushort wMatch);

///Searches a string for the last occurrence of a specified character. The comparison is case-sensitive.
///Params:
///    pszStart = Type: <b>PTSTR</b> A pointer to the null-terminated string to be searched.
///    pszEnd = Type: <b>PCTSTR</b> A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to
///             point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to
///             <b>NULL</b> to search the entire string.
///    wMatch = Type: <b>TCHAR</b> The character to search for.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to the last occurrence of the character in the string, if successful, or
///    <b>NULL</b> if not.
///    
@DllImport("SHLWAPI")
ushort* StrRChrW(const(wchar)* pszStart, const(wchar)* pszEnd, ushort wMatch);

///Searches a string for the last occurrence of a specified character. The comparison is not case-sensitive.
///Params:
///    pszStart = Type: <b>PTSTR</b> A pointer to the null-terminated string to be searched.
///    pszEnd = Type: <b>PCTSTR</b> A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to
///             point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to
///             <b>NULL</b> to search the entire string.
///    wMatch = Type: <b>TCHAR</b> The character to search for.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to the last occurrence of the character in the string, if successful, or
///    <b>NULL</b> if not.
///    
@DllImport("SHLWAPI")
byte* StrRChrIA(const(char)* pszStart, const(char)* pszEnd, ushort wMatch);

///Searches a string for the last occurrence of a specified character. The comparison is not case-sensitive.
///Params:
///    pszStart = Type: <b>PTSTR</b> A pointer to the null-terminated string to be searched.
///    pszEnd = Type: <b>PCTSTR</b> A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to
///             point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to
///             <b>NULL</b> to search the entire string.
///    wMatch = Type: <b>TCHAR</b> The character to search for.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to the last occurrence of the character in the string, if successful, or
///    <b>NULL</b> if not.
///    
@DllImport("SHLWAPI")
ushort* StrRChrIW(const(wchar)* pszStart, const(wchar)* pszEnd, ushort wMatch);

///Searches for the last occurrence of a specified substring within a string. The comparison is not case-sensitive.
///Params:
///    pszSource = Type: <b>PTSTR</b> A pointer to a <b>null</b>-terminated source string.
///    pszLast = Type: <b>PCTSTR</b> A pointer into the source string that defines the range of the search. Set <i>pszLast</i> to
///              point to a character in the source string, and the search will stop with the preceding character. Set
///              <i>pszLast</i> to <b>NULL</b> to search the entire source string.
///    pszSrch = Type: <b>PCTSTR</b> A pointer to the substring to search for.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the last occurrence of the substring if successful, or <b>NULL</b>
///    otherwise.
///    
@DllImport("SHLWAPI")
byte* StrRStrIA(const(char)* pszSource, const(char)* pszLast, const(char)* pszSrch);

///Searches for the last occurrence of a specified substring within a string. The comparison is not case-sensitive.
///Params:
///    pszSource = Type: <b>PTSTR</b> A pointer to a <b>null</b>-terminated source string.
///    pszLast = Type: <b>PCTSTR</b> A pointer into the source string that defines the range of the search. Set <i>pszLast</i> to
///              point to a character in the source string, and the search will stop with the preceding character. Set
///              <i>pszLast</i> to <b>NULL</b> to search the entire source string.
///    pszSrch = Type: <b>PCTSTR</b> A pointer to the substring to search for.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the last occurrence of the substring if successful, or <b>NULL</b>
///    otherwise.
///    
@DllImport("SHLWAPI")
ushort* StrRStrIW(const(wchar)* pszSource, const(wchar)* pszLast, const(wchar)* pszSrch);

///Obtains the length of a substring within a string that consists entirely of characters contained in a specified
///buffer.
///Params:
///    psz = Type: <b>PCTSTR</b> A pointer to the null-terminated string that is to be searched.
///    pszSet = Type: <b>PCTSTR</b> A pointer to a null-terminated character buffer that contains the set of characters for which
///             to search.
///Returns:
///    Type: <b>int</b> Returns the length, in characters, of the matching string or zero if no match is found.
///    
@DllImport("SHLWAPI")
int StrSpnA(const(char)* psz, const(char)* pszSet);

///Obtains the length of a substring within a string that consists entirely of characters contained in a specified
///buffer.
///Params:
///    psz = Type: <b>PCTSTR</b> A pointer to the null-terminated string that is to be searched.
///    pszSet = Type: <b>PCTSTR</b> A pointer to a null-terminated character buffer that contains the set of characters for which
///             to search.
///Returns:
///    Type: <b>int</b> Returns the length, in characters, of the matching string or zero if no match is found.
///    
@DllImport("SHLWAPI")
int StrSpnW(const(wchar)* psz, const(wchar)* pszSet);

///Finds the first occurrence of a substring within a string. The comparison is case-sensitive.
///Params:
///    pszFirst = Type: <b>PTSTR</b> A pointer to the null-terminated string to search.
///    pszSrch = Type: <b>PCTSTR</b> A pointer to the substring to search for.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the first occurrence of the matching substring if successful, or
///    <b>NULL</b> otherwise.
///    
@DllImport("SHLWAPI")
byte* StrStrA(const(char)* pszFirst, const(char)* pszSrch);

///Finds the first occurrence of a substring within a string. The comparison is case-sensitive.
///Params:
///    pszFirst = Type: <b>PTSTR</b> A pointer to the null-terminated string to search.
///    pszSrch = Type: <b>PCTSTR</b> A pointer to the substring to search for.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the first occurrence of the matching substring if successful, or
///    <b>NULL</b> otherwise.
///    
@DllImport("SHLWAPI")
ushort* StrStrW(const(wchar)* pszFirst, const(wchar)* pszSrch);

///Finds the first occurrence of a substring within a string. The comparison is not case-sensitive.
///Params:
///    pszFirst = Type: <b>PTSTR</b> A pointer to the null-terminated string being searched.
///    pszSrch = Type: <b>PCTSTR</b> A pointer to the substring to search for.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the first occurrence of the matching substring if successful, or
///    <b>NULL</b> otherwise.
///    
@DllImport("SHLWAPI")
byte* StrStrIA(const(char)* pszFirst, const(char)* pszSrch);

///Finds the first occurrence of a substring within a string. The comparison is not case-sensitive.
///Params:
///    pszFirst = Type: <b>PTSTR</b> A pointer to the null-terminated string being searched.
///    pszSrch = Type: <b>PCTSTR</b> A pointer to the substring to search for.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the first occurrence of the matching substring if successful, or
///    <b>NULL</b> otherwise.
///    
@DllImport("SHLWAPI")
ushort* StrStrIW(const(wchar)* pszFirst, const(wchar)* pszSrch);

///Finds the first occurrence of a substring within a string. The comparison is case-sensitive.
///Params:
///    pszFirst = Type: <b>PWSTR</b> A pointer to the null-terminated, Unicode string that is being searched.
///    pszSrch = Type: <b>PCWSTR</b> A pointer to the null-terminated, Unicode substring that is being searched for.
///    cchMax = Type: <b>UINT</b> The maximum number of characters from the beginning of the searched string in which to search
///             for the substring.
@DllImport("SHLWAPI")
ushort* StrStrNW(const(wchar)* pszFirst, const(wchar)* pszSrch, uint cchMax);

///Finds the first occurrence of a substring within a string. The comparison is case-insensitive.
///Params:
///    pszFirst = Type: <b>PWSTR</b> A pointer to the null-terminated, Unicode string that is being searched.
///    pszSrch = Type: <b>PCWSTR</b> A pointer to the null-terminated, Unicode substring that is being searched for.
///    cchMax = Type: <b>UINT</b> The maximum number of characters from the beginning of the searched string in which to search
///             for the substring.
@DllImport("SHLWAPI")
ushort* StrStrNIW(const(wchar)* pszFirst, const(wchar)* pszSrch, uint cchMax);

///Converts a string that represents a decimal value to an integer. The <b>StrToLong</b> macro is identical to this
///function.
///Params:
///    pszSrc = Type: <b>PCTSTR</b> A pointer to the null-terminated string to be converted. A valid string representing a
///             decimal value contains only the characters 0-9 and must have the following form to be parsed successfully. <pre
///             class="syntax" xml:space="preserve"><code>(optional white space)(optional sign)(one or more decimal
///             digits)</code></pre> The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be
///             positive.
///Returns:
///    Type: <b>int</b> Returns the <b>int</b> value represented by <i>pszSrc</i>. For instance, the string "123"
///    returns the integer value 123.
///    
@DllImport("SHLWAPI")
int StrToIntA(const(char)* pszSrc);

///Converts a string that represents a decimal value to an integer. The <b>StrToLong</b> macro is identical to this
///function.
///Params:
///    pszSrc = Type: <b>PCTSTR</b> A pointer to the null-terminated string to be converted. A valid string representing a
///             decimal value contains only the characters 0-9 and must have the following form to be parsed successfully. <pre
///             class="syntax" xml:space="preserve"><code>(optional white space)(optional sign)(one or more decimal
///             digits)</code></pre> The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be
///             positive.
///Returns:
///    Type: <b>int</b> Returns the <b>int</b> value represented by <i>pszSrc</i>. For instance, the string "123"
///    returns the integer value 123.
///    
@DllImport("SHLWAPI")
int StrToIntW(const(wchar)* pszSrc);

///Converts a string representing a decimal or hexadecimal number to an integer.
///Params:
///    pszString = Type: <b>PCTSTR</b> A pointer to the null-terminated string to be converted. For further details concerning the
///                valid forms of the string, see the Remarks section.
///    dwFlags = Type: <b>STIF_FLAGS</b> One of the following values that specify how <i>pszString</i> should be parsed for its
///              conversion to an integer.
///    piRet = Type: <b>int*</b> A pointer to an <b>int</b> that receives the converted string. For instance, in the case of the
///            string "123", the integer pointed to by this value receives the integer value 123. If this function returns
///            <b>FALSE</b>, this value is undefined. If the value returned is too large to be contained in a variable of type
///            <b>int</b>, this parameter contains the 32 low-order bits of the value. Any high-order bits beyond that are lost.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL StrToIntExA(const(char)* pszString, int dwFlags, int* piRet);

///Converts a string representing a decimal or hexadecimal number to an integer.
///Params:
///    pszString = Type: <b>PCTSTR</b> A pointer to the null-terminated string to be converted. For further details concerning the
///                valid forms of the string, see the Remarks section.
///    dwFlags = Type: <b>STIF_FLAGS</b> One of the following values that specify how <i>pszString</i> should be parsed for its
///              conversion to an integer.
///    piRet = Type: <b>int*</b> A pointer to an <b>int</b> that receives the converted string. For instance, in the case of the
///            string "123", the integer pointed to by this value receives the integer value 123. If this function returns
///            <b>FALSE</b>, this value is undefined. If the value returned is too large to be contained in a variable of type
///            <b>int</b>, this parameter contains the 32 low-order bits of the value. Any high-order bits beyond that are lost.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL StrToIntExW(const(wchar)* pszString, int dwFlags, int* piRet);

///Converts a string representing a decimal or hexadecimal value to a 64-bit integer.
///Params:
///    pszString = Type: <b>PCTSTR</b> A pointer to the <b>null</b>-terminated string to be converted. For further details
///                concerning the valid forms of the string, see the Remarks section.
///    dwFlags = Type: <b>STIF_FLAGS</b> One of the following values that specify how <i>pszString</i> should be parsed for its
///              conversion to a 64-bit integer.
///    pllRet = Type: <b>LONGLONG*</b> A pointer to a variable of type <b>LONGLONG</b> that receives the 64-bit integer value of
///             the converted string. For instance, in the case of the string "123", the integer pointed to by this value
///             receives the value 123. If this function returns <b>FALSE</b>, this value is undefined. If the value returned is
///             too large to be contained in a variable of type <b>LONGLONG</b>, this parameter contains the 64 low-order bits of
///             the value. Any high-order bits beyond that are lost.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL StrToInt64ExA(const(char)* pszString, int dwFlags, long* pllRet);

///Converts a string representing a decimal or hexadecimal value to a 64-bit integer.
///Params:
///    pszString = Type: <b>PCTSTR</b> A pointer to the <b>null</b>-terminated string to be converted. For further details
///                concerning the valid forms of the string, see the Remarks section.
///    dwFlags = Type: <b>STIF_FLAGS</b> One of the following values that specify how <i>pszString</i> should be parsed for its
///              conversion to a 64-bit integer.
///    pllRet = Type: <b>LONGLONG*</b> A pointer to a variable of type <b>LONGLONG</b> that receives the 64-bit integer value of
///             the converted string. For instance, in the case of the string "123", the integer pointed to by this value
///             receives the value 123. If this function returns <b>FALSE</b>, this value is undefined. If the value returned is
///             too large to be contained in a variable of type <b>LONGLONG</b>, this parameter contains the 64 low-order bits of
///             the value. Any high-order bits beyond that are lost.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL StrToInt64ExW(const(wchar)* pszString, int dwFlags, long* pllRet);

///Removes specified leading and trailing characters from a string.
///Params:
///    psz = Type: <b>PTSTR</b> A pointer to the null-terminated string to be trimmed. When this function returns
///          successfully, <i>psz</i> receives the trimmed string.
///    pszTrimChars = Type: <b>PCTSTR</b> A pointer to a null-terminated string that contains the characters to trim from <i>psz</i>.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if any characters were removed; otherwise, <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL StrTrimA(const(char)* psz, const(char)* pszTrimChars);

///Removes specified leading and trailing characters from a string.
///Params:
///    psz = Type: <b>PTSTR</b> A pointer to the null-terminated string to be trimmed. When this function returns
///          successfully, <i>psz</i> receives the trimmed string.
///    pszTrimChars = Type: <b>PCTSTR</b> A pointer to a null-terminated string that contains the characters to trim from <i>psz</i>.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if any characters were removed; otherwise, <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL StrTrimW(const(wchar)* psz, const(wchar)* pszTrimChars);

///Appends one string to another. <div class="alert"><b>Note</b> Do not use. See Remarks for alternative
///functions.</div><div> </div>
///Params:
///    psz1 = Type: <b>PTSTR</b> A pointer to a null-terminated string. When this function returns successfully, this string
///           contains its original content with the string <i>psz2</i> appended. This buffer must be large enough to hold both
///           strings and the terminating null character.
///    psz2 = Type: <b>PCTSTR</b> A pointer to a null-terminated string to be appended to <i>psz1</i>.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to <i>psz1</i>, which holds the combined strings.
///    
@DllImport("SHLWAPI")
ushort* StrCatW(const(wchar)* psz1, const(wchar)* psz2);

///Compares two strings to determine if they are the same. The comparison is case-sensitive.
///Params:
///    psz1 = Type: <b>PCTSTR</b> A pointer to the first null-terminated string to be compared.
///    psz2 = Type: <b>PCTSTR</b> A pointer to the second null-terminated string to be compared.
@DllImport("SHLWAPI")
int StrCmpW(const(wchar)* psz1, const(wchar)* psz2);

///Compares two strings to determine if they are the same. The comparison is not case-sensitive.
///Params:
///    psz1 = Type: <b>PCTSTR</b> A pointer to the first null-terminated string to be compared.
///    psz2 = Type: <b>PCTSTR</b> A pointer to the second null-terminated string to be compared.
@DllImport("SHLWAPI")
int StrCmpIW(const(wchar)* psz1, const(wchar)* psz2);

///Copies one string to another. <div class="alert"><b>Note</b> Do not use. See Remarks for alternative
///functions.</div><div> </div>
///Params:
///    psz1 = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the copied
///           string. This string is not guaranteed to be null-terminated.
///    psz2 = Type: <b>PCTSTR</b> A pointer to the null-terminated source string.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to <i>psz1</i>.
///    
@DllImport("SHLWAPI")
ushort* StrCpyW(const(wchar)* psz1, const(wchar)* psz2);

///Copies a specified number of characters from the beginning of one string to another. <div class="alert"><b>Note</b>
///Do not use this function or the <b>StrNCpy</b> macro. See Remarks for alternative functions.</div><div> </div>
///Params:
///    pszDst = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the copied
///             string. This buffer must be of sufficient size to hold the copied characters. This string is not guaranteed to be
///             null-terminated.
///    pszSrc = Type: <b>PCTSTR</b> A pointer to the null-terminated source string.
///    cchMax = Type: <b>int</b> The number of characters to be copied, including the terminating null character.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to <i>pszDst</i>.
///    
@DllImport("SHLWAPI")
ushort* StrCpyNW(const(wchar)* pszDst, const(wchar)* pszSrc, int cchMax);

///Copies and appends characters from one string to the end of another. <div class="alert"><b>Note</b> Do not use. See
///Remarks for alternative functions.</div><div> </div>
///Params:
///    pszDest = Type: <b>PTSTR</b> A pointer to a null-terminated string. When this function returns successfully, this string
///              contains its original content with the string <i>pszSrc</i> appended.
///    pszSrc = Type: <b>PCTSTR</b> A pointer to the string to be appended to <i>pszDest</i>.
///    cchDestBuffSize = Type: <b>int</b> The size of the buffer, in characters, pointed to by <i>pszDest</i>. This value must be at least
///                      the length of the combined string plus the terminating null character. If the buffer is too small to fit the
///                      entire string, the string will be truncated.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to the destination string.
///    
@DllImport("SHLWAPI")
ushort* StrCatBuffW(const(wchar)* pszDest, const(wchar)* pszSrc, int cchDestBuffSize);

///Copies and appends characters from one string to the end of another. <div class="alert"><b>Note</b> Do not use. See
///Remarks for alternative functions.</div><div> </div>
///Params:
///    pszDest = Type: <b>PTSTR</b> A pointer to a null-terminated string. When this function returns successfully, this string
///              contains its original content with the string <i>pszSrc</i> appended.
///    pszSrc = Type: <b>PCTSTR</b> A pointer to the string to be appended to <i>pszDest</i>.
///    cchDestBuffSize = Type: <b>int</b> The size of the buffer, in characters, pointed to by <i>pszDest</i>. This value must be at least
///                      the length of the combined string plus the terminating null character. If the buffer is too small to fit the
///                      entire string, the string will be truncated.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to the destination string.
///    
@DllImport("SHLWAPI")
byte* StrCatBuffA(const(char)* pszDest, const(char)* pszSrc, int cchDestBuffSize);

///Performs a comparison between two characters. The comparison is not case-sensitive.
///Params:
///    w1 = Type: <b>TCHAR</b> The first character to be compared.
///    w2 = Type: <b>TCHAR</b> The second character to be compared.
///Returns:
///    Type: <b>BOOL</b> Returns zero if the two characters are the same, or nonzero otherwise.
///    
@DllImport("SHLWAPI")
BOOL ChrCmpIA(ushort w1, ushort w2);

///Performs a comparison between two characters. The comparison is not case-sensitive.
///Params:
///    w1 = Type: <b>TCHAR</b> The first character to be compared.
///    w2 = Type: <b>TCHAR</b> The second character to be compared.
///Returns:
///    Type: <b>BOOL</b> Returns zero if the two characters are the same, or nonzero otherwise.
///    
@DllImport("SHLWAPI")
BOOL ChrCmpIW(ushort w1, ushort w2);

///Takes a list of arguments and returns the values of the arguments as a printf-style formatted string. <div
///class="alert"><b>Note</b> Do not use this function. See Remarks for alternative functions.</div><div> </div>
///Params:
///    pszDest = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the output
///              string.
///    cchDest = Type: <b>int</b> The maximum number of characters allowed in <i>pszDest</i>.
///    pszFmt = Type: <b>PCTSTR</b> A printf-style format string. The %s format identifier should never be used in an unbounded
///             form. To avoid potential buffer overruns, always specify a size; for instance "%32s".
///    arglist = Type: <b>va_list</b> A pointer to a list of command-line parameters used to customize the output.
///Returns:
///    Type: <b>int</b> Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b>
///    characters. A negative value is returned if an error occurs.
///    
@DllImport("SHLWAPI")
int wvnsprintfA(const(char)* pszDest, int cchDest, const(char)* pszFmt, byte* arglist);

///Takes a list of arguments and returns the values of the arguments as a printf-style formatted string. <div
///class="alert"><b>Note</b> Do not use this function. See Remarks for alternative functions.</div><div> </div>
///Params:
///    pszDest = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the output
///              string.
///    cchDest = Type: <b>int</b> The maximum number of characters allowed in <i>pszDest</i>.
///    pszFmt = Type: <b>PCTSTR</b> A printf-style format string. The %s format identifier should never be used in an unbounded
///             form. To avoid potential buffer overruns, always specify a size; for instance "%32s".
///    arglist = Type: <b>va_list</b> A pointer to a list of command-line parameters used to customize the output.
///Returns:
///    Type: <b>int</b> Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b>
///    characters. A negative value is returned if an error occurs.
///    
@DllImport("SHLWAPI")
int wvnsprintfW(const(wchar)* pszDest, int cchDest, const(wchar)* pszFmt, byte* arglist);

///Takes a variable-length argument list and returns the values of the arguments as a printf-style formatted string.
///<div class="alert"><b>Note</b> Do not use this function. See Remarks for alternative functions.</div><div> </div>
///Params:
///    pszDest = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the output
///              string.
///    cchDest = Type: <b>int</b> The maximum number of characters allowed in <i>pszDest</i>.
///    pszFmt = Type: <b>PCTSTR</b> A printf-style format string. The %s format identifier should never be used in an unbounded
///             form. To avoid potential buffer overruns, always specify a size; for instance "%32s".
///    arg4 = Additional parameters that contain the data to be output.
///Returns:
///    Type: <b>int</b> Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b>
///    characters. A negative value is returned if an error occurs.
///    
@DllImport("SHLWAPI")
int wnsprintfA(const(char)* pszDest, int cchDest, const(char)* pszFmt);

///Takes a variable-length argument list and returns the values of the arguments as a printf-style formatted string.
///<div class="alert"><b>Note</b> Do not use this function. See Remarks for alternative functions.</div><div> </div>
///Params:
///    pszDest = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the output
///              string.
///    cchDest = Type: <b>int</b> The maximum number of characters allowed in <i>pszDest</i>.
///    pszFmt = Type: <b>PCTSTR</b> A printf-style format string. The %s format identifier should never be used in an unbounded
///             form. To avoid potential buffer overruns, always specify a size; for instance "%32s".
///    arg4 = Additional parameters that contain the data to be output.
///Returns:
///    Type: <b>int</b> Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b>
///    characters. A negative value is returned if an error occurs.
///    
@DllImport("SHLWAPI")
int wnsprintfW(const(wchar)* pszDest, int cchDest, const(wchar)* pszFmt);

///Takes an STRRET structure returned by IShellFolder::GetDisplayNameOf and returns a pointer to an allocated string
///containing the display name.
///Params:
///    pstr = Type: <b>STRRET*</b> A pointer to the STRRET structure. When the function returns, this pointer will no longer be
///           valid.
///    pidl = Type: <b>PCUITEMID_CHILD</b> A pointer to the item's ITEMIDLIST structure. This value can be <b>NULL</b>.
///    ppsz = Type: <b>LPTSTR*</b> A pointer to an allocated string containing the result. <b>StrRetToStr</b> allocates memory
///           for this string with CoTaskMemAlloc. You should free the string with CoTaskMemFree when it is no longer needed.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT StrRetToStrA(STRRET* pstr, ITEMIDLIST* pidl, byte** ppsz);

///Takes an STRRET structure returned by IShellFolder::GetDisplayNameOf and returns a pointer to an allocated string
///containing the display name.
///Params:
///    pstr = Type: <b>STRRET*</b> A pointer to the STRRET structure. When the function returns, this pointer will no longer be
///           valid.
///    pidl = Type: <b>PCUITEMID_CHILD</b> A pointer to the item's ITEMIDLIST structure. This value can be <b>NULL</b>.
///    ppsz = Type: <b>LPTSTR*</b> A pointer to an allocated string containing the result. <b>StrRetToStr</b> allocates memory
///           for this string with CoTaskMemAlloc. You should free the string with CoTaskMemFree when it is no longer needed.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT StrRetToStrW(STRRET* pstr, ITEMIDLIST* pidl, ushort** ppsz);

///Converts an STRRET structure returned by IShellFolder::GetDisplayNameOf to a string, and places the result in a
///buffer.
///Params:
///    pstr = Type: <b>STRRET*</b> A pointer to the STRRET structure. When the function returns, this pointer will no longer be
///           valid.
///    pidl = Type: <b>PCUITEMID_CHILD</b> A pointer to the item's ITEMIDLIST structure.
///    pszBuf = Type: <b>LPTSTR</b> A buffer to hold the display name. It will be returned as a null-terminated string. If
///             <i>cchBuf</i> is too small, the name will be truncated to fit.
///    cchBuf = Type: <b>UINT</b> The size of <i>pszBuf</i>, in characters. If <i>cchBuf</i> is too small, the string will be
///             truncated to fit.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT StrRetToBufA(STRRET* pstr, ITEMIDLIST* pidl, const(char)* pszBuf, uint cchBuf);

///Converts an STRRET structure returned by IShellFolder::GetDisplayNameOf to a string, and places the result in a
///buffer.
///Params:
///    pstr = Type: <b>STRRET*</b> A pointer to the STRRET structure. When the function returns, this pointer will no longer be
///           valid.
///    pidl = Type: <b>PCUITEMID_CHILD</b> A pointer to the item's ITEMIDLIST structure.
///    pszBuf = Type: <b>LPTSTR</b> A buffer to hold the display name. It will be returned as a null-terminated string. If
///             <i>cchBuf</i> is too small, the name will be truncated to fit.
///    cchBuf = Type: <b>UINT</b> The size of <i>pszBuf</i>, in characters. If <i>cchBuf</i> is too small, the string will be
///             truncated to fit.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT StrRetToBufW(STRRET* pstr, ITEMIDLIST* pidl, const(wchar)* pszBuf, uint cchBuf);

///Makes a copy of a string in newly allocated memory.
///Params:
///    psz = Type: <b>LPCTSTR</b> A pointer to the null-terminated string to be copied.
///    ppwsz = Type: <b>LPTSTR*</b> A pointer to an allocated Unicode string that contains the result. <b>SHStrDup</b> allocates
///            memory for this string with CoTaskMemAlloc. You should free the string with CoTaskMemFree when it is no longer
///            needed. In the case of failure, this value is NULL.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
///    
@DllImport("SHLWAPI")
HRESULT SHStrDupA(const(char)* psz, ushort** ppwsz);

///Makes a copy of a string in newly allocated memory.
///Params:
///    psz = Type: <b>LPCTSTR</b> A pointer to the null-terminated string to be copied.
///    ppwsz = Type: <b>LPTSTR*</b> A pointer to an allocated Unicode string that contains the result. <b>SHStrDup</b> allocates
///            memory for this string with CoTaskMemAlloc. You should free the string with CoTaskMemFree when it is no longer
///            needed. In the case of failure, this value is NULL.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
///    
@DllImport("SHLWAPI")
HRESULT SHStrDupW(const(wchar)* psz, ushort** ppwsz);

///Compares two Unicode strings. Digits in the strings are considered as numerical content rather than text. This test
///is not case-sensitive.
///Params:
///    psz1 = Type: <b>PCWSTR</b> A pointer to the first null-terminated string to be compared.
///    psz2 = Type: <b>PCWSTR</b> A pointer to the second null-terminated string to be compared.
///Returns:
///    Type: <b>int</b> <ul> <li>Returns zero if the strings are identical.</li> <li>Returns 1 if the string pointed to
///    by <i>psz1</i> has a greater value than that pointed to by <i>psz2</i>.</li> <li>Returns -1 if the string pointed
///    to by <i>psz1</i> has a lesser value than that pointed to by <i>psz2</i>.</li> </ul>
///    
@DllImport("SHLWAPI")
int StrCmpLogicalW(const(wchar)* psz1, const(wchar)* psz2);

///Concatenates two Unicode strings. Used when repeated concatenations to the same buffer are required.
///Params:
///    pszDst = Type: <b>PWSTR</b> A pointer to a buffer that, when this function returns successfully, receives the
///             null-terminated, Unicode string.
///    cchDst = Type: <b>DWORD</b> The size of the destination buffer, in characters. This buffer must be of sufficient size to
///             hold both strings as well as a terminating null character. If the buffer is too small, the final string is
///             truncated.
///    ichAt = Type: <b>DWORD</b> The offset into the destination buffer at which to begin the append action. If the string is
///            not empty, set this value to -1 to have the current number of filled characters (not including the terminating
///            null character) calculated for you.
///    pszSrc = Type: <b>PCWSTR</b> A pointer to the null-terminated Unicode source string.
///Returns:
///    Type: <b>DWORD</b> Returns the offset of the null character after the last character added to <i>pszDst</i>.
///    
@DllImport("SHLWAPI")
uint StrCatChainW(const(wchar)* pszDst, uint cchDst, uint ichAt, const(wchar)* pszSrc);

///Accepts a STRRET structure returned by IShellFolder::GetDisplayNameOf that contains or points to a string, and
///returns that string as a BSTR.
///Params:
///    pstr = Type: <b>STRRET*</b> A pointer to a STRRET structure. When the function returns, this pointer is longer valid.
///    pidl = Type: <b>PCUITEMID_CHILD</b> A pointer to an ITEMIDLIST that uniquely identifies a file object or subfolder
///           relative to the parent folder. This value can be <b>NULL</b>.
///    pbstr = Type: <b>BSTR*</b> A pointer to a variable of type BSTR that receives the converted string.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT StrRetToBSTR(STRRET* pstr, ITEMIDLIST* pidl, BSTR* pbstr);

///Extracts a specified text resource when given that resource in the form of an indirect string (a string that begins
///with the '@' symbol).
///Params:
///    pszSource = Type: <b>PCWSTR</b> A pointer to a buffer that contains the indirect string from which the resource will be
///                retrieved. This string should begin with the '@' symbol and use one of the forms discussed in the Remarks
///                section. This function will successfully accept a string that does not begin with an '@' symbol, but the string
///                will be simply passed unchanged to <i>pszOutBuf</i>.
///    pszOutBuf = Type: <b>PWSTR</b> A pointer to a buffer that, when this function returns successfully, receives the text
///                resource. Both <i>pszOutBuf</i> and <i>pszSource</i> can point to the same buffer, in which case the original
///                string will be overwritten.
///    cchOutBuf = Type: <b>UINT</b> The size of the buffer pointed to by <i>pszOutBuf</i>, in characters.
///    ppvReserved = Type: <b>void**</b> Not used; set to <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT SHLoadIndirectString(const(wchar)* pszSource, const(wchar)* pszOutBuf, uint cchOutBuf, void** ppvReserved);

///Determines whether a character represents a space.
///Params:
///    wch = Type: <b>TCHAR</b> A single character.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the character is a space; otherwise, <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL IsCharSpaceA(byte wch);

///Determines whether a character represents a space.
///Params:
///    wch = Type: <b>TCHAR</b> A single character.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the character is a space; otherwise, <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL IsCharSpaceW(ushort wch);

///Compares strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.
///Params:
///    pszStr1 = Type: <b>LPCTSTR</b> A pointer to the first null-terminated string to be compared.
///    pszStr2 = Type: <b>LPCTSTR</b> A pointer to the second null-terminated string to be compared.
///Returns:
///    Type: <b>int</b> Returns zero if the strings are identical. Returns a positive value if the string pointed to by
///    <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the
///    string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>.
///    
@DllImport("SHLWAPI")
int StrCmpCA(const(char)* pszStr1, const(char)* pszStr2);

///Compares strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.
///Params:
///    pszStr1 = Type: <b>LPCTSTR</b> A pointer to the first null-terminated string to be compared.
///    pszStr2 = Type: <b>LPCTSTR</b> A pointer to the second null-terminated string to be compared.
///Returns:
///    Type: <b>int</b> Returns zero if the strings are identical. Returns a positive value if the string pointed to by
///    <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the
///    string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>.
///    
@DllImport("SHLWAPI")
int StrCmpCW(const(wchar)* pszStr1, const(wchar)* pszStr2);

///Compares two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.
///Params:
///    pszStr1 = Type: <b>LPCTSTR</b> A pointer to the first null-terminated string to be compared.
///    pszStr2 = Type: <b>LPCTSTR</b> A pointer to the second null-terminated string to be compared.
///Returns:
///    Type: <b>int</b> Returns zero if the strings are identical. Returns a positive value if the string pointed to by
///    <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the
///    string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>
///    
@DllImport("SHLWAPI")
int StrCmpICA(const(char)* pszStr1, const(char)* pszStr2);

///Compares two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.
///Params:
///    pszStr1 = Type: <b>LPCTSTR</b> A pointer to the first null-terminated string to be compared.
///    pszStr2 = Type: <b>LPCTSTR</b> A pointer to the second null-terminated string to be compared.
///Returns:
///    Type: <b>int</b> Returns zero if the strings are identical. Returns a positive value if the string pointed to by
///    <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the
///    string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>
///    
@DllImport("SHLWAPI")
int StrCmpICW(const(wchar)* pszStr1, const(wchar)* pszStr2);

///Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules.
///The comparison is case-sensitive.
///Params:
///    pszStr1 = Type: <b>LPCTSTR</b> A pointer to the first null-terminated string to be compared.
///    pszStr2 = Type: <b>LPCTSTR</b> A pointer to the second null-terminated string to be compared.
///    nChar = Type: <b>int</b> The number of characters from the beginning of each string to be compared.
///Returns:
///    Type: <b>int</b> Returns zero if the substrings are identical. Returns a positive value if the string taken from
///    that pointed to by <i>pszStr1</i> is alphabetically greater than the string taken from that pointed to by
///    <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is
///    alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.
///    
@DllImport("SHLWAPI")
int StrCmpNCA(const(char)* pszStr1, const(char)* pszStr2, int nChar);

///Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules.
///The comparison is case-sensitive.
///Params:
///    pszStr1 = Type: <b>LPCTSTR</b> A pointer to the first null-terminated string to be compared.
///    pszStr2 = Type: <b>LPCTSTR</b> A pointer to the second null-terminated string to be compared.
///    nChar = Type: <b>int</b> The number of characters from the beginning of each string to be compared.
///Returns:
///    Type: <b>int</b> Returns zero if the substrings are identical. Returns a positive value if the string taken from
///    that pointed to by <i>pszStr1</i> is alphabetically greater than the string taken from that pointed to by
///    <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is
///    alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.
///    
@DllImport("SHLWAPI")
int StrCmpNCW(const(wchar)* pszStr1, const(wchar)* pszStr2, int nChar);

///Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules.
///The comparison is not case-sensitive.
///Params:
///    pszStr1 = Type: <b>LPCTSTR</b> A pointer to the first null-terminated string to be compared.
///    pszStr2 = Type: <b>LPCTSTR</b> A pointer to the second null-terminated string to be compared.
///    nChar = Type: <b>int</b> The number of characters from the beginning of each string to be compared.
///Returns:
///    Type: <b>int</b> Returns zero if the substrings are identical. Returns a positive value if the string taken from
///    that pointed to by <i>pszStr1</i> is alphabetically greater the string taken from that pointed to by
///    <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is
///    alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.
///    
@DllImport("SHLWAPI")
int StrCmpNICA(const(char)* pszStr1, const(char)* pszStr2, int nChar);

///Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules.
///The comparison is not case-sensitive.
///Params:
///    pszStr1 = Type: <b>LPCTSTR</b> A pointer to the first null-terminated string to be compared.
///    pszStr2 = Type: <b>LPCTSTR</b> A pointer to the second null-terminated string to be compared.
///    nChar = Type: <b>int</b> The number of characters from the beginning of each string to be compared.
///Returns:
///    Type: <b>int</b> Returns zero if the substrings are identical. Returns a positive value if the string taken from
///    that pointed to by <i>pszStr1</i> is alphabetically greater the string taken from that pointed to by
///    <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is
///    alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.
///    
@DllImport("SHLWAPI")
int StrCmpNICW(const(wchar)* pszStr1, const(wchar)* pszStr2, int nChar);

///Compares a specified number of characters from the beginning of two localized strings.
///Params:
///    fCaseSens = Type: <b>BOOL</b> A value that is set to <b>TRUE</b> for a case-sensitive comparison, or to <b>FALSE</b> for a
///                case-insensitive comparison.
///    lpString1 = Type: <b>LPCTSTR</b> A pointer to a null-terminated string.
///    lpString2 = Type: <b>LPCTSTR</b> A pointer to a null-terminated string.
///    nChar = Type: <b>int</b> The number of characters to be compared, starting from the beginning of the strings.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the first <i>nChar</i> characters are identical, or <b>FALSE</b>
///    otherwise.
///    
@DllImport("SHLWAPI")
BOOL IntlStrEqWorkerA(BOOL fCaseSens, const(char)* lpString1, const(char)* lpString2, int nChar);

///Compares a specified number of characters from the beginning of two localized strings.
///Params:
///    fCaseSens = Type: <b>BOOL</b> A value that is set to <b>TRUE</b> for a case-sensitive comparison, or to <b>FALSE</b> for a
///                case-insensitive comparison.
///    lpString1 = Type: <b>LPCTSTR</b> A pointer to a null-terminated string.
///    lpString2 = Type: <b>LPCTSTR</b> A pointer to a null-terminated string.
///    nChar = Type: <b>int</b> The number of characters to be compared, starting from the beginning of the strings.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the first <i>nChar</i> characters are identical, or <b>FALSE</b>
///    otherwise.
///    
@DllImport("SHLWAPI")
BOOL IntlStrEqWorkerW(BOOL fCaseSens, const(wchar)* lpString1, const(wchar)* lpString2, int nChar);

///Adds a backslash to the end of a string to create the correct syntax for a path. If the source path already has a
///trailing backslash, no backslash will be added. <div class="alert"><b>Note</b> Misuse of this function can lead to a
///buffer overrun. We recommend the use of the safer PathCchAddBackslash or PathCchAddBackslashEx function in its
///place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a buffer with a string that represents a path. The size of this buffer must be
///              set to MAX_PATH to ensure that it is large enough to hold the returned string.
///Returns:
///    Type: <b>LPTSTR</b> A pointer that, when this function returns successfully, points to the new string's
///    terminating null character. If the backslash could not be appended due to inadequate buffer size, this value is
///    <b>NULL</b>.
///    
@DllImport("SHLWAPI")
byte* PathAddBackslashA(const(char)* pszPath);

///Adds a backslash to the end of a string to create the correct syntax for a path. If the source path already has a
///trailing backslash, no backslash will be added. <div class="alert"><b>Note</b> Misuse of this function can lead to a
///buffer overrun. We recommend the use of the safer PathCchAddBackslash or PathCchAddBackslashEx function in its
///place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a buffer with a string that represents a path. The size of this buffer must be
///              set to MAX_PATH to ensure that it is large enough to hold the returned string.
///Returns:
///    Type: <b>LPTSTR</b> A pointer that, when this function returns successfully, points to the new string's
///    terminating null character. If the backslash could not be appended due to inadequate buffer size, this value is
///    <b>NULL</b>.
///    
@DllImport("SHLWAPI")
ushort* PathAddBackslashW(const(wchar)* pszPath);

///Adds a file name extension to a path string. <div class="alert"><b>Note</b> Misuse of this function can lead to a
///buffer overrun. We recommend the use of the safer PathCchAddExtension function in its place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a buffer with the null-terminated string to which the file name extension will
///              be appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the
///              returned string.
///    pszExt = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the file name extension. This value can
///             be <b>NULL</b>.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if an extension was added, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathAddExtensionA(const(char)* pszPath, const(char)* pszExt);

///Adds a file name extension to a path string. <div class="alert"><b>Note</b> Misuse of this function can lead to a
///buffer overrun. We recommend the use of the safer PathCchAddExtension function in its place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a buffer with the null-terminated string to which the file name extension will
///              be appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the
///              returned string.
///    pszExt = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the file name extension. This value can
///             be <b>NULL</b>.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if an extension was added, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathAddExtensionW(const(wchar)* pszPath, const(wchar)* pszExt);

///Appends one path to the end of another. <div class="alert"><b>Note</b> Misuse of this function can lead to a buffer
///overrun. We recommend the use of the safer PathCchAppend or PathCchAppendEx function in its place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string to which the path specified in <i>pszMore</i> is
///              appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned
///              string.
///    pszMore = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be appended.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathAppendA(const(char)* pszPath, const(char)* pszMore);

///Appends one path to the end of another. <div class="alert"><b>Note</b> Misuse of this function can lead to a buffer
///overrun. We recommend the use of the safer PathCchAppend or PathCchAppendEx function in its place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string to which the path specified in <i>pszMore</i> is
///              appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned
///              string.
///    pszMore = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be appended.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathAppendW(const(wchar)* pszPath, const(wchar)* pszMore);

///Creates a root path from a given drive number.
///Params:
///    pszRoot = Type: <b>LPTSTR</b> A pointer to the string that receives the constructed root path. This buffer must be at least
///              four characters in size.
///    iDrive = Type: <b>int</b> A variable of type <b>int</b> that indicates the desired drive number. It should be between 0
///             and 25.
///Returns:
///    Type: <b>LPTSTR</b> Returns the address of the constructed root path. If the call fails for any reason (for
///    example, an invalid drive number), <i>szRoot</i> is returned unchanged.
///    
@DllImport("SHLWAPI")
byte* PathBuildRootA(const(char)* pszRoot, int iDrive);

///Creates a root path from a given drive number.
///Params:
///    pszRoot = Type: <b>LPTSTR</b> A pointer to the string that receives the constructed root path. This buffer must be at least
///              four characters in size.
///    iDrive = Type: <b>int</b> A variable of type <b>int</b> that indicates the desired drive number. It should be between 0
///             and 25.
///Returns:
///    Type: <b>LPTSTR</b> Returns the address of the constructed root path. If the call fails for any reason (for
///    example, an invalid drive number), <i>szRoot</i> is returned unchanged.
///    
@DllImport("SHLWAPI")
ushort* PathBuildRootW(const(wchar)* pszRoot, int iDrive);

///Simplifies a path by removing navigation elements such as "." and ".." to produce a direct, well-formed path. <div
///class="alert"><b>Note</b> Misuse of this function can lead to a buffer overrun. We recommend the use of the safer
///PathCchCanonicalize or PathCchCanonicalizeEx function in its place.</div><div> </div>
///Params:
///    pszBuf = Type: <b>LPTSTR</b> A pointer to a string that receives the canonicalized path. You must set the size of this
///             buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be canonicalized.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if a result has been computed and the content of the <i>lpszDst</i> output
///    buffer is valid. Returns <b>FALSE</b> otherwise, and the contents of the buffer pointed to by <i>lpszDst</i> are
///    invalid. To get extended error information, call GetLastError.
///    
@DllImport("SHLWAPI")
BOOL PathCanonicalizeA(const(char)* pszBuf, const(char)* pszPath);

///Simplifies a path by removing navigation elements such as "." and ".." to produce a direct, well-formed path. <div
///class="alert"><b>Note</b> Misuse of this function can lead to a buffer overrun. We recommend the use of the safer
///PathCchCanonicalize or PathCchCanonicalizeEx function in its place.</div><div> </div>
///Params:
///    pszBuf = Type: <b>LPTSTR</b> A pointer to a string that receives the canonicalized path. You must set the size of this
///             buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be canonicalized.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if a result has been computed and the content of the <i>lpszDst</i> output
///    buffer is valid. Returns <b>FALSE</b> otherwise, and the contents of the buffer pointed to by <i>lpszDst</i> are
///    invalid. To get extended error information, call GetLastError.
///    
@DllImport("SHLWAPI")
BOOL PathCanonicalizeW(const(wchar)* pszBuf, const(wchar)* pszPath);

///Concatenates two strings that represent properly formed paths into one path; also concatenates any relative path
///elements. <div class="alert"><b>Note</b> Misuse of this function can lead to a buffer overrun. We recommend the use
///of the safer PathCchCombine or PathCchCombineEx function in its place.</div><div> </div>
///Params:
///    pszDest = Type: <b>LPTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the combined
///              path string. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the
///              returned string.
///    pszDir = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the first
///             path. This value can be <b>NULL</b>.
///    pszFile = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the second
///              path. This value can be <b>NULL</b>.
///Returns:
///    Type: <b>LPTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the
///    concatenated path string. This is the same string pointed to by <i>pszPathOut</i>. If this function does not
///    return successfully, this value is <b>NULL</b>.
///    
@DllImport("SHLWAPI")
byte* PathCombineA(const(char)* pszDest, const(char)* pszDir, const(char)* pszFile);

///Concatenates two strings that represent properly formed paths into one path; also concatenates any relative path
///elements. <div class="alert"><b>Note</b> Misuse of this function can lead to a buffer overrun. We recommend the use
///of the safer PathCchCombine or PathCchCombineEx function in its place.</div><div> </div>
///Params:
///    pszDest = Type: <b>LPTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the combined
///              path string. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the
///              returned string.
///    pszDir = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the first
///             path. This value can be <b>NULL</b>.
///    pszFile = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the second
///              path. This value can be <b>NULL</b>.
///Returns:
///    Type: <b>LPTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the
///    concatenated path string. This is the same string pointed to by <i>pszPathOut</i>. If this function does not
///    return successfully, this value is <b>NULL</b>.
///    
@DllImport("SHLWAPI")
ushort* PathCombineW(const(wchar)* pszDest, const(wchar)* pszDir, const(wchar)* pszFile);

///Truncates a file path to fit within a given pixel width by replacing path components with ellipses.
///Params:
///    hDC = Type: <b>HDC</b> A handle to the device context used for font metrics. This value can be <b>NULL</b>.
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path to be
///              modified. On return, this buffer will contain the modified string.
///    dx = Type: <b>UINT</b> The width, in pixels, in which the string must fit.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the path was successfully compacted to the specified width. Returns
///    <b>FALSE</b> on failure, or if the base portion of the path would not fit the specified width.
///    
@DllImport("SHLWAPI")
BOOL PathCompactPathA(HDC hDC, const(char)* pszPath, uint dx);

///Truncates a file path to fit within a given pixel width by replacing path components with ellipses.
///Params:
///    hDC = Type: <b>HDC</b> A handle to the device context used for font metrics. This value can be <b>NULL</b>.
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path to be
///              modified. On return, this buffer will contain the modified string.
///    dx = Type: <b>UINT</b> The width, in pixels, in which the string must fit.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the path was successfully compacted to the specified width. Returns
///    <b>FALSE</b> on failure, or if the base portion of the path would not fit the specified width.
///    
@DllImport("SHLWAPI")
BOOL PathCompactPathW(HDC hDC, const(wchar)* pszPath, uint dx);

///Truncates a path to fit within a certain number of characters by replacing path components with ellipses.
///Params:
///    pszOut = Type: <b>LPTSTR</b> The address of the string that has been altered.
///    pszSrc = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path to be
///             altered.
///    cchMax = Type: <b>UINT</b> The maximum number of characters to be contained in the new string, including the terminating
///             null character. For example, if <i>cchMax</i> = 8, the resulting string can contain a maximum of 7 characters
///             plus the terminating null character.
///    dwFlags = Type: <b>DWORD</b>
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathCompactPathExA(const(char)* pszOut, const(char)* pszSrc, uint cchMax, uint dwFlags);

///Truncates a path to fit within a certain number of characters by replacing path components with ellipses.
///Params:
///    pszOut = Type: <b>LPTSTR</b> The address of the string that has been altered.
///    pszSrc = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path to be
///             altered.
///    cchMax = Type: <b>UINT</b> The maximum number of characters to be contained in the new string, including the terminating
///             null character. For example, if <i>cchMax</i> = 8, the resulting string can contain a maximum of 7 characters
///             plus the terminating null character.
///    dwFlags = Type: <b>DWORD</b>
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathCompactPathExW(const(wchar)* pszOut, const(wchar)* pszSrc, uint cchMax, uint dwFlags);

///Compares two paths to determine if they share a common prefix. A prefix is one of these types: "C:\\", ".", "..",
///"..\\".
///Params:
///    pszFile1 = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the first path name.
///    pszFile2 = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the second path name.
///    achPath = Type: <b>LPTSTR</b> A pointer to a buffer that receives the common prefix. This buffer must be at least MAX_PATH
///              characters in size. If there is no common prefix, it is set to <b>NULL</b>.
///Returns:
///    Type: <b>int</b> Returns the count of common prefix characters in the path. If the output buffer pointer is not
///    <b>NULL</b>, then these characters are copied to the output buffer.
///    
@DllImport("SHLWAPI")
int PathCommonPrefixA(const(char)* pszFile1, const(char)* pszFile2, const(char)* achPath);

///Compares two paths to determine if they share a common prefix. A prefix is one of these types: "C:\\", ".", "..",
///"..\\".
///Params:
///    pszFile1 = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the first path name.
///    pszFile2 = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the second path name.
///    achPath = Type: <b>LPTSTR</b> A pointer to a buffer that receives the common prefix. This buffer must be at least MAX_PATH
///              characters in size. If there is no common prefix, it is set to <b>NULL</b>.
///Returns:
///    Type: <b>int</b> Returns the count of common prefix characters in the path. If the output buffer pointer is not
///    <b>NULL</b>, then these characters are copied to the output buffer.
///    
@DllImport("SHLWAPI")
int PathCommonPrefixW(const(wchar)* pszFile1, const(wchar)* pszFile2, const(wchar)* achPath);

///Determines whether a path to a file system object such as a file or folder is valid.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the full path
///              of the object to verify.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if the file exists; otherwise, <b>FALSE</b>. Call GetLastError for extended error
///    information.
///    
@DllImport("SHLWAPI")
BOOL PathFileExistsA(const(char)* pszPath);

///Determines whether a path to a file system object such as a file or folder is valid.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the full path
///              of the object to verify.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if the file exists; otherwise, <b>FALSE</b>. Call GetLastError for extended error
///    information. If the file does not exist, GetLastError will return ERROR_FILE_NOT_FOUND.
///    
@DllImport("SHLWAPI")
BOOL PathFileExistsW(const(wchar)* pszPath);

///Searches a path for an extension.
///Params:
///    pszPath = Type: <b>PTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              search, including the extension being searched for.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the "." that precedes the extension within <i>pszPath</i> if an
///    extension is found, or the address of the terminating null character otherwise.
///    
@DllImport("SHLWAPI")
byte* PathFindExtensionA(const(char)* pszPath);

///Searches a path for an extension.
///Params:
///    pszPath = Type: <b>PTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              search, including the extension being searched for.
///Returns:
///    Type: <b>PTSTR</b> Returns the address of the "." that precedes the extension within <i>pszPath</i> if an
///    extension is found, or the address of the terminating null character otherwise.
///    
@DllImport("SHLWAPI")
ushort* PathFindExtensionW(const(wchar)* pszPath);

///Searches a path for a file name.
///Params:
///    pszPath = Type: <b>PTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              search.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to the address of the string if successful, or a pointer to the beginning of
///    the path otherwise.
///    
@DllImport("SHLWAPI")
byte* PathFindFileNameA(const(char)* pszPath);

///Searches a path for a file name.
///Params:
///    pszPath = Type: <b>PTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              search.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to the address of the string if successful, or a pointer to the beginning of
///    the path otherwise.
///    
@DllImport("SHLWAPI")
ushort* PathFindFileNameW(const(wchar)* pszPath);

///Parses a path and returns the portion of that path that follows the first backslash.
///Params:
///    pszPath = Type: <b>PTSTR</b> A pointer to a null-terminated string that contains the path to parse. This string must not be
///              longer than MAX_PATH characters, plus the terminating null character. Path components are delimited by
///              backslashes. For instance, the path "c:\path1\path2\file.txt" has four components: c:, path1, path2, and
///              file.txt.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to a null-terminated string that contains the truncated path. If
///    <i>pszPath</i> points to the last component in the path, this function returns a pointer to the terminating null
///    character. If <i>pszPath</i> points to the terminating null character or if the call fails, this function returns
///    <b>NULL</b>.
///    
@DllImport("SHLWAPI")
byte* PathFindNextComponentA(const(char)* pszPath);

///Parses a path and returns the portion of that path that follows the first backslash.
///Params:
///    pszPath = Type: <b>PTSTR</b> A pointer to a null-terminated string that contains the path to parse. This string must not be
///              longer than MAX_PATH characters, plus the terminating null character. Path components are delimited by
///              backslashes. For instance, the path "c:\path1\path2\file.txt" has four components: c:, path1, path2, and
///              file.txt.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to a null-terminated string that contains the truncated path. If
///    <i>pszPath</i> points to the last component in the path, this function returns a pointer to the terminating null
///    character. If <i>pszPath</i> points to the terminating null character or if the call fails, this function returns
///    <b>NULL</b>.
///    
@DllImport("SHLWAPI")
ushort* PathFindNextComponentW(const(wchar)* pszPath);

///Searches for a file.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the file name for
///              which to search. If the search is successful, this parameter is used to return the fully qualified path name.
///    ppszOtherDirs = Type: <b>LPCTSTR*</b> An optional, null-terminated array of directories to be searched first. This value can be
///                    <b>NULL</b>.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathFindOnPathA(const(char)* pszPath, byte** ppszOtherDirs);

///Searches for a file.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the file name for
///              which to search. If the search is successful, this parameter is used to return the fully qualified path name.
///    ppszOtherDirs = Type: <b>LPCTSTR*</b> An optional, null-terminated array of directories to be searched first. This value can be
///                    <b>NULL</b>.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathFindOnPathW(const(wchar)* pszPath, ushort** ppszOtherDirs);

///Determines whether a given file name has one of a list of suffixes.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name
///              to be tested. A full path can be used.
///    apszSuffix = Type: <b>const LPCTSTR*</b> An array of <i>iArraySize</i> string pointers. Each string pointed to is
///                 null-terminated and contains one suffix. The strings can be of variable lengths.
///    iArraySize = Type: <b>int</b> The number of elements in the array pointed to by <i>apszSuffix</i>.
///Returns:
///    Type: <b>LPCTSTR</b> Returns a pointer to a string with the matching suffix if successful, or <b>NULL</b> if
///    <i>pszPath</i> does not end with one of the specified suffixes.
///    
@DllImport("SHLWAPI")
byte* PathFindSuffixArrayA(const(char)* pszPath, char* apszSuffix, int iArraySize);

///Determines whether a given file name has one of a list of suffixes.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name
///              to be tested. A full path can be used.
///    apszSuffix = Type: <b>const LPCTSTR*</b> An array of <i>iArraySize</i> string pointers. Each string pointed to is
///                 null-terminated and contains one suffix. The strings can be of variable lengths.
///    iArraySize = Type: <b>int</b> The number of elements in the array pointed to by <i>apszSuffix</i>.
///Returns:
///    Type: <b>LPCTSTR</b> Returns a pointer to a string with the matching suffix if successful, or <b>NULL</b> if
///    <i>pszPath</i> does not end with one of the specified suffixes.
///    
@DllImport("SHLWAPI")
ushort* PathFindSuffixArrayW(const(wchar)* pszPath, char* apszSuffix, int iArraySize);

///Finds the command line arguments within a given path.
///Params:
///    pszPath = Type: <b>PTSTR</b> Pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be
///              searched.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to a null-terminated string that contains the arguments portion of the path
///    if successful. If there are no arguments in the path, the function returns a pointer to the end of the input
///    string. If the function is given a <b>NULL</b> argument it returns <b>NULL</b>.
///    
@DllImport("SHLWAPI")
byte* PathGetArgsA(const(char)* pszPath);

///Finds the command line arguments within a given path.
///Params:
///    pszPath = Type: <b>PTSTR</b> Pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be
///              searched.
///Returns:
///    Type: <b>PTSTR</b> Returns a pointer to a null-terminated string that contains the arguments portion of the path
///    if successful. If there are no arguments in the path, the function returns a pointer to the end of the input
///    string. If the function is given a <b>NULL</b> argument it returns <b>NULL</b>.
///    
@DllImport("SHLWAPI")
ushort* PathGetArgsW(const(wchar)* pszPath);

///Determines whether a file name is in long format.
///Params:
///    pszName = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name
///              to be tested.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if <i>pszName</i> exceeds the number of characters allowed by the 8.3
///    format, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsLFNFileSpecA(const(char)* pszName);

///Determines whether a file name is in long format.
///Params:
///    pszName = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name
///              to be tested.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if <i>pszName</i> exceeds the number of characters allowed by the 8.3
///    format, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsLFNFileSpecW(const(wchar)* pszName);

///Determines the type of character in relation to a path.
///Params:
///    ch = Type: <b>TUCHAR</b> The character for which to determine the type.
///Returns:
///    Type: <b>UINT</b> Returns one or more of the following values that define the type of character. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>GCT_INVALID</b></dt> </dl>
///    </td> <td width="60%"> The character is not valid in a path. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>GCT_LFNCHAR</b></dt> </dl> </td> <td width="60%"> The character is valid in a long file name. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>GCT_SEPARATOR</b></dt> </dl> </td> <td width="60%"> The character is a path
///    separator. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>GCT_SHORTCHAR</b></dt> </dl> </td> <td width="60%"> The
///    character is valid in a short (8.3) file name. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>GCT_WILD</b></dt>
///    </dl> </td> <td width="60%"> The character is a wildcard character. </td> </tr> </table>
///    
@DllImport("SHLWAPI")
uint PathGetCharTypeA(ubyte ch);

///Determines the type of character in relation to a path.
///Params:
///    ch = Type: <b>TUCHAR</b> The character for which to determine the type.
///Returns:
///    Type: <b>UINT</b> Returns one or more of the following values that define the type of character. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>GCT_INVALID</b></dt> </dl>
///    </td> <td width="60%"> The character is not valid in a path. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>GCT_LFNCHAR</b></dt> </dl> </td> <td width="60%"> The character is valid in a long file name. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>GCT_SEPARATOR</b></dt> </dl> </td> <td width="60%"> The character is a path
///    separator. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>GCT_SHORTCHAR</b></dt> </dl> </td> <td width="60%"> The
///    character is valid in a short (8.3) file name. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>GCT_WILD</b></dt>
///    </dl> </td> <td width="60%"> The character is a wildcard character. </td> </tr> </table>
///    
@DllImport("SHLWAPI")
uint PathGetCharTypeW(ushort ch);

///Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be searched.
///Returns:
///    Type: <b>int</b> Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has a drive letter, or -1
///    otherwise.
///    
@DllImport("SHLWAPI")
int PathGetDriveNumberA(const(char)* pszPath);

///Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be searched.
///Returns:
///    Type: <b>int</b> Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has a drive letter, or -1
///    otherwise.
///    
@DllImport("SHLWAPI")
int PathGetDriveNumberW(const(wchar)* pszPath);

///Verifies that a path is a valid directory.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              verify.
///Returns:
///    Type: <b>BOOL</b> Returns (BOOL)FILE_ATTRIBUTE_DIRECTORY if the path is a valid directory; otherwise,
///    <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL PathIsDirectoryA(const(char)* pszPath);

///Verifies that a path is a valid directory.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              verify.
///Returns:
///    Type: <b>BOOL</b> Returns (BOOL)FILE_ATTRIBUTE_DIRECTORY if the path is a valid directory; otherwise,
///    <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL PathIsDirectoryW(const(wchar)* pszPath);

///Determines whether a specified path is an empty directory.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be tested.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if <i>pszPath</i> is an empty directory. Returns <b>FALSE</b> if
///    <i>pszPath</i> is not a directory, or if it contains at least one file other than "." or "..".
///    
@DllImport("SHLWAPI")
BOOL PathIsDirectoryEmptyA(const(char)* pszPath);

///Determines whether a specified path is an empty directory.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be tested.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if <i>pszPath</i> is an empty directory. Returns <b>FALSE</b> if
///    <i>pszPath</i> is not a directory, or if it contains at least one file other than "." or "..".
///    
@DllImport("SHLWAPI")
BOOL PathIsDirectoryEmptyW(const(wchar)* pszPath);

///Searches a path for any path-delimiting characters (for example, ':' or '\' ). If there are no path-delimiting
///characters present, the path is considered to be a File Spec path.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be searched.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if there are no path-delimiting characters within the path, or <b>FALSE</b>
///    if there are path-delimiting characters.
///    
@DllImport("SHLWAPI")
BOOL PathIsFileSpecA(const(char)* pszPath);

///Searches a path for any path-delimiting characters (for example, ':' or '\' ). If there are no path-delimiting
///characters present, the path is considered to be a File Spec path.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be searched.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if there are no path-delimiting characters within the path, or <b>FALSE</b>
///    if there are path-delimiting characters.
///    
@DllImport("SHLWAPI")
BOOL PathIsFileSpecW(const(wchar)* pszPath);

///Searches a path to determine if it contains a valid prefix of the type passed by <i>pszPrefix</i>. A prefix is one of
///these types: "C:\\", ".", "..", "..\\".
///Params:
///    pszPrefix = Type: <b>IN LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the prefix
///                for which to search.
///    pszPath = Type: <b>IN LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path
///              to be searched.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the compared path is the full prefix for the path, or <b>FALSE</b>
///    otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsPrefixA(const(char)* pszPrefix, const(char)* pszPath);

///Searches a path to determine if it contains a valid prefix of the type passed by <i>pszPrefix</i>. A prefix is one of
///these types: "C:\\", ".", "..", "..\\".
///Params:
///    pszPrefix = Type: <b>IN LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the prefix
///                for which to search.
///    pszPath = Type: <b>IN LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path
///              to be searched.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the compared path is the full prefix for the path, or <b>FALSE</b>
///    otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsPrefixW(const(wchar)* pszPrefix, const(wchar)* pszPath);

///Searches a path and determines if it is relative.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              search.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the path is relative, or <b>FALSE</b> if it is absolute.
///    
@DllImport("SHLWAPI")
BOOL PathIsRelativeA(const(char)* pszPath);

///Searches a path and determines if it is relative.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              search.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the path is relative, or <b>FALSE</b> if it is absolute.
///    
@DllImport("SHLWAPI")
BOOL PathIsRelativeW(const(wchar)* pszPath);

///Determines whether a path string refers to the root of a volume.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be validated.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsRootA(const(char)* pszPath);

///Determines whether a path string refers to the root of a volume.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be validated.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsRootW(const(wchar)* pszPath);

///Compares two paths to determine if they have a common root component.
///Params:
///    pszPath1 = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the first
///               path to be compared.
///    pszPath2 = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the second
///               path to be compared.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if both strings have the same root component, or <b>FALSE</b> otherwise. If
///    <i>pszPath1</i> contains only the server and share, this function also returns <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL PathIsSameRootA(const(char)* pszPath1, const(char)* pszPath2);

///Compares two paths to determine if they have a common root component.
///Params:
///    pszPath1 = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the first
///               path to be compared.
///    pszPath2 = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the second
///               path to be compared.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if both strings have the same root component, or <b>FALSE</b> otherwise. If
///    <i>pszPath1</i> contains only the server and share, this function also returns <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL PathIsSameRootW(const(wchar)* pszPath1, const(wchar)* pszPath2);

///Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive
///letter.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              validate.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL PathIsUNCA(const(char)* pszPath);

///Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive
///letter.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              validate.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL PathIsUNCW(const(wchar)* pszPath);

///Determines whether a path string represents a network resource.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string represents a network resource, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsNetworkPathA(const(char)* pszPath);

///Determines whether a path string represents a network resource.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string represents a network resource, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsNetworkPathW(const(wchar)* pszPath);

///Determines if a string is a valid Universal Naming Convention (UNC) for a server path only.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              validate.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string is a valid UNC path for a server only (no share name), or
///    <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsUNCServerA(const(char)* pszPath);

///Determines if a string is a valid Universal Naming Convention (UNC) for a server path only.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              validate.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string is a valid UNC path for a server only (no share name), or
///    <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsUNCServerW(const(wchar)* pszPath);

///Determines if a string is a valid Universal Naming Convention (UNC) share path,
///&#92;&#92;<i>server</i>&#92;<i>share</i>.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be validated.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string is in the form &#92;&#92;<i>server</i>&#92;<i>share</i>, or
///    <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsUNCServerShareA(const(char)* pszPath);

///Determines if a string is a valid Universal Naming Convention (UNC) share path,
///&#92;&#92;<i>server</i>&#92;<i>share</i>.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be validated.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string is in the form &#92;&#92;<i>server</i>&#92;<i>share</i>, or
///    <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsUNCServerShareW(const(wchar)* pszPath);

///Determines if a file's registered content type matches the specified content type. This function obtains the content
///type for the specified file type and compares that string with the <i>pszContentType</i>. The comparison is not
///case-sensitive.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the file
///              whose content type will be compared.
///    pszContentType = Type: <b>LPCTSTR</b> The address of a character buffer that contains the null-terminated content type string to
///                     which the file's registered content type will be compared.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if the file's registered content type matches <i>pszContentType</i>, or zero
///    otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsContentTypeA(const(char)* pszPath, const(char)* pszContentType);

///Determines if a file's registered content type matches the specified content type. This function obtains the content
///type for the specified file type and compares that string with the <i>pszContentType</i>. The comparison is not
///case-sensitive.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the file
///              whose content type will be compared.
///    pszContentType = Type: <b>LPCTSTR</b> The address of a character buffer that contains the null-terminated content type string to
///                     which the file's registered content type will be compared.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if the file's registered content type matches <i>pszContentType</i>, or zero
///    otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsContentTypeW(const(wchar)* pszPath, const(wchar)* pszContentType);

///Tests a given string to determine if it conforms to a valid URL format.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the URL path
///              to validate.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if <i>pszPath</i> has a valid URL format, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsURLA(const(char)* pszPath);

///Tests a given string to determine if it conforms to a valid URL format.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the URL path
///              to validate.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if <i>pszPath</i> has a valid URL format, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsURLW(const(wchar)* pszPath);

///Converts an all-uppercase path to all lowercase characters to give the path a consistent appearance.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path to be
///              converted.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the path has been converted, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathMakePrettyA(const(char)* pszPath);

///Converts an all-uppercase path to all lowercase characters to give the path a consistent appearance.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path to be
///              converted.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the path has been converted, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathMakePrettyW(const(wchar)* pszPath);

///Searches a string using a Microsoft MS-DOS wildcard match type.
///Params:
///    pszFile = Type: <b>LPCSTR</b> A pointer to a null-terminated string that contains the path to be searched.
///    pszSpec = Type: <b>LPCSTR</b> A pointer to a null-terminated string that contains the file type for which to search. For
///              example, to test whether <i>pszFile</i> is a .doc file, <i>pszSpec</i> should be set to "*.doc".
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string matches, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathMatchSpecA(const(char)* pszFile, const(char)* pszSpec);

///Searches a string using a Microsoft MS-DOS wildcard match type.
///Params:
///    pszFile = Type: <b>LPCSTR</b> A pointer to a null-terminated string that contains the path to be searched.
///    pszSpec = Type: <b>LPCSTR</b> A pointer to a null-terminated string that contains the file type for which to search. For
///              example, to test whether <i>pszFile</i> is a .doc file, <i>pszSpec</i> should be set to "*.doc".
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the string matches, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathMatchSpecW(const(wchar)* pszFile, const(wchar)* pszSpec);

///Matches a file name from a path against one or more file name patterns.
///Params:
///    pszFile = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the path from which the file name to be
///              matched is taken.
///    pszSpec = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the file name pattern for which to
///              search. This can be the exact name, or it can contain wildcard characters. If exactly one pattern is specified,
///              set the <b>PMSF_NORMAL</b> flag in <i>dwFlags</i>. If more than one pattern is specified, separate them with
///              semicolons and set the <b>PMSF_MULTIPLE</b> flag.
///    dwFlags = Type: <b>DWORD</b> Modifies the search condition. The following are valid flags.
///Returns:
///    Type: <b>HRESULT</b> Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> A file name pattern specified
///    in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No file name pattern specified in
///    <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>. </td> </tr> </table>
///    
@DllImport("SHLWAPI")
HRESULT PathMatchSpecExA(const(char)* pszFile, const(char)* pszSpec, uint dwFlags);

///Matches a file name from a path against one or more file name patterns.
///Params:
///    pszFile = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the path from which the file name to be
///              matched is taken.
///    pszSpec = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the file name pattern for which to
///              search. This can be the exact name, or it can contain wildcard characters. If exactly one pattern is specified,
///              set the <b>PMSF_NORMAL</b> flag in <i>dwFlags</i>. If more than one pattern is specified, separate them with
///              semicolons and set the <b>PMSF_MULTIPLE</b> flag.
///    dwFlags = Type: <b>DWORD</b> Modifies the search condition. The following are valid flags.
///Returns:
///    Type: <b>HRESULT</b> Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> A file name pattern specified
///    in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No file name pattern specified in
///    <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>. </td> </tr> </table>
///    
@DllImport("SHLWAPI")
HRESULT PathMatchSpecExW(const(wchar)* pszFile, const(wchar)* pszSpec, uint dwFlags);

///Parses a file location string that contains a file location and icon index, and returns separate values.
///Params:
///    pszIconFile = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains a file location
///                  string. It should be in the form "<i>path</i>,<i>iconindex</i>". When the function returns, <i>pszIconFile</i>
///                  will point to the file's path.
///Returns:
///    Type: <b>int</b> Returns the valid icon index value.
///    
@DllImport("SHLWAPI")
int PathParseIconLocationA(const(char)* pszIconFile);

///Parses a file location string that contains a file location and icon index, and returns separate values.
///Params:
///    pszIconFile = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains a file location
///                  string. It should be in the form "<i>path</i>,<i>iconindex</i>". When the function returns, <i>pszIconFile</i>
///                  will point to the file's path.
///Returns:
///    Type: <b>int</b> Returns the valid icon index value.
///    
@DllImport("SHLWAPI")
int PathParseIconLocationW(const(wchar)* pszIconFile);

///Searches a path for spaces. If spaces are found, the entire path is enclosed in quotation marks.
///Params:
///    lpsz = Type: <b>LPTSTR</b> A pointer to a null-terminated string that contains the path to search. The size of this
///           buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if spaces were found; otherwise, <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL PathQuoteSpacesA(const(char)* lpsz);

///Searches a path for spaces. If spaces are found, the entire path is enclosed in quotation marks.
///Params:
///    lpsz = Type: <b>LPTSTR</b> A pointer to a null-terminated string that contains the path to search. The size of this
///           buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if spaces were found; otherwise, <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL PathQuoteSpacesW(const(wchar)* lpsz);

///Creates a relative path from one file or folder to another.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a string that receives the relative path. This buffer must be at least MAX_PATH
///              characters in size.
///    pszFrom = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that
///              defines the start of the relative path.
///    dwAttrFrom = Type: <b>DWORD</b> The file attributes of <i>pszFrom</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY,
///                 <i>pszFrom</i> is assumed to be a directory; otherwise, <i>pszFrom</i> is assumed to be a file.
///    pszTo = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that
///            defines the endpoint of the relative path.
///    dwAttrTo = Type: <b>DWORD</b> The file attributes of <i>pszTo</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY,
///               <i>pszTo</i> is assumed to be directory; otherwise, <i>pszTo</i> is assumed to be a file.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathRelativePathToA(const(char)* pszPath, const(char)* pszFrom, uint dwAttrFrom, const(char)* pszTo, 
                         uint dwAttrTo);

///Creates a relative path from one file or folder to another.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a string that receives the relative path. This buffer must be at least MAX_PATH
///              characters in size.
///    pszFrom = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that
///              defines the start of the relative path.
///    dwAttrFrom = Type: <b>DWORD</b> The file attributes of <i>pszFrom</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY,
///                 <i>pszFrom</i> is assumed to be a directory; otherwise, <i>pszFrom</i> is assumed to be a file.
///    pszTo = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that
///            defines the endpoint of the relative path.
///    dwAttrTo = Type: <b>DWORD</b> The file attributes of <i>pszTo</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY,
///               <i>pszTo</i> is assumed to be directory; otherwise, <i>pszTo</i> is assumed to be a file.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathRelativePathToW(const(wchar)* pszPath, const(wchar)* pszFrom, uint dwAttrFrom, const(wchar)* pszTo, 
                         uint dwAttrTo);

///Removes any arguments from a given path.
///Params:
///    pszPath = Type: <b>LPTSTR</b> Pointer to a null-terminated string of length MAX_PATH that contains the path from which to
///              remove arguments.
@DllImport("SHLWAPI")
void PathRemoveArgsA(const(char)* pszPath);

///Removes any arguments from a given path.
///Params:
///    pszPath = Type: <b>LPTSTR</b> Pointer to a null-terminated string of length MAX_PATH that contains the path from which to
///              remove arguments.
@DllImport("SHLWAPI")
void PathRemoveArgsW(const(wchar)* pszPath);

///Removes the trailing backslash from a given path. <div class="alert"><b>Note</b> This function is deprecated. We
///recommend the use of the PathCchRemoveBackslash or PathCchRemoveBackslashEx function in its place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path from which to
///              remove the backslash.
///Returns:
///    Type: <b>LPTSTR</b> A pointer that, when this function returns successfully and if a backslash has been removed,
///    points to the terminating null character that has replaced the backslash at the end of the string. If the path
///    did not include a trailing backslash, this value will point to the final character in the string.
///    
@DllImport("SHLWAPI")
byte* PathRemoveBackslashA(const(char)* pszPath);

///Removes the trailing backslash from a given path. <div class="alert"><b>Note</b> This function is deprecated. We
///recommend the use of the PathCchRemoveBackslash or PathCchRemoveBackslashEx function in its place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path from which to
///              remove the backslash.
///Returns:
///    Type: <b>LPTSTR</b> A pointer that, when this function returns successfully and if a backslash has been removed,
///    points to the terminating null character that has replaced the backslash at the end of the string. If the path
///    did not include a trailing backslash, this value will point to the final character in the string.
///    
@DllImport("SHLWAPI")
ushort* PathRemoveBackslashW(const(wchar)* pszPath);

///Removes all leading and trailing spaces from a string.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH from which to strip all leading and
///              trailing spaces.
@DllImport("SHLWAPI")
void PathRemoveBlanksA(const(char)* pszPath);

///Removes all leading and trailing spaces from a string.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH from which to strip all leading and
///              trailing spaces.
@DllImport("SHLWAPI")
void PathRemoveBlanksW(const(wchar)* pszPath);

///Removes the file name extension from a path, if one is present. <div class="alert"><b>Note</b> This function is
///deprecated. We recommend the use of the PathCchRemoveExtension in its place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH from which to remove the extension.
@DllImport("SHLWAPI")
void PathRemoveExtensionA(const(char)* pszPath);

///Removes the file name extension from a path, if one is present. <div class="alert"><b>Note</b> This function is
///deprecated. We recommend the use of the PathCchRemoveExtension in its place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH from which to remove the extension.
@DllImport("SHLWAPI")
void PathRemoveExtensionW(const(wchar)* pszPath);

///Removes the trailing file name and backslash from a path, if they are present. <div class="alert"><b>Note</b> This
///function is deprecated. We recommend the use of the PathCchRemoveFileSpec function in its place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path from which to
///              remove the file name.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if something was removed, or zero otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathRemoveFileSpecA(const(char)* pszPath);

///Removes the trailing file name and backslash from a path, if they are present. <div class="alert"><b>Note</b> This
///function is deprecated. We recommend the use of the PathCchRemoveFileSpec function in its place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path from which to
///              remove the file name.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if something was removed, or zero otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathRemoveFileSpecW(const(wchar)* pszPath);

///Replaces the extension of a file name with a new extension. If the file name does not contain an extension, the
///extension will be attached to the end of the string. <div class="alert"><b>Note</b> Misuse of this function can lead
///to a buffer overrun. We recommend the use of the safer PathCchRenameExtension function in its place.</div><div>
///</div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> Pointer to a null-terminated string of length MAX_PATH in which to replace the extension.
///    pszExt = Type: <b>LPCTSTR</b> Pointer to a character buffer that contains a '.' character followed by the new extension.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero if the new path and extension would exceed MAX_PATH
///    characters.
///    
@DllImport("SHLWAPI")
BOOL PathRenameExtensionA(const(char)* pszPath, const(char)* pszExt);

///Replaces the extension of a file name with a new extension. If the file name does not contain an extension, the
///extension will be attached to the end of the string. <div class="alert"><b>Note</b> Misuse of this function can lead
///to a buffer overrun. We recommend the use of the safer PathCchRenameExtension function in its place.</div><div>
///</div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> Pointer to a null-terminated string of length MAX_PATH in which to replace the extension.
///    pszExt = Type: <b>LPCTSTR</b> Pointer to a character buffer that contains a '.' character followed by the new extension.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero if the new path and extension would exceed MAX_PATH
///    characters.
///    
@DllImport("SHLWAPI")
BOOL PathRenameExtensionW(const(wchar)* pszPath, const(wchar)* pszExt);

///Determines if a given path is correctly formatted and fully qualified.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              search.
///    pszBuf = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path to be
///             referenced.
///    cchBuf = Type: <b>UINT</b> The size of the buffer pointed to by <i>pszFullyQualifiedPath</i>, in characters.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the path is qualified, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathSearchAndQualifyA(const(char)* pszPath, const(char)* pszBuf, uint cchBuf);

///Determines if a given path is correctly formatted and fully qualified.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              search.
///    pszBuf = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path to be
///             referenced.
///    cchBuf = Type: <b>UINT</b> The size of the buffer pointed to by <i>pszFullyQualifiedPath</i>, in characters.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the path is qualified, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathSearchAndQualifyW(const(wchar)* pszPath, const(wchar)* pszBuf, uint cchBuf);

///Sets the text of a child control in a window or dialog box, using PathCompactPath to ensure the path fits in the
///control.
///Params:
///    hDlg = Type: <b>HWND</b> A handle to the dialog box or window.
///    id = Type: <b>int</b> The identifier of the control.
///    pszPath = Type: <b>LPCSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              set in the control.
@DllImport("SHLWAPI")
void PathSetDlgItemPathA(HWND hDlg, int id, const(char)* pszPath);

///Sets the text of a child control in a window or dialog box, using PathCompactPath to ensure the path fits in the
///control.
///Params:
///    hDlg = Type: <b>HWND</b> A handle to the dialog box or window.
///    id = Type: <b>int</b> The identifier of the control.
///    pszPath = Type: <b>LPCSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              set in the control.
@DllImport("SHLWAPI")
void PathSetDlgItemPathW(HWND hDlg, int id, const(wchar)* pszPath);

///Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC)
///server/share path elements.
///Params:
///    pszPath = Type: <b>PTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              parse.
///Returns:
///    Type: <b>PTSTR</b> A pointer that, when this function returns successfully, points to the beginning of the
///    subpath that follows the root (drive letter or UNC server/share). If the function encounters an error, this value
///    will be <b>NULL</b>.
///    
@DllImport("SHLWAPI")
byte* PathSkipRootA(const(char)* pszPath);

///Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC)
///server/share path elements.
///Params:
///    pszPath = Type: <b>PTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              parse.
///Returns:
///    Type: <b>PTSTR</b> A pointer that, when this function returns successfully, points to the beginning of the
///    subpath that follows the root (drive letter or UNC server/share). If the function encounters an error, this value
///    will be <b>NULL</b>.
///    
@DllImport("SHLWAPI")
ushort* PathSkipRootW(const(wchar)* pszPath);

///Removes the path portion of a fully qualified path and file.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path and file
///              name. When this function returns successfully, the string contains only the file name, with the path removed.
@DllImport("SHLWAPI")
void PathStripPathA(const(char)* pszPath);

///Removes the path portion of a fully qualified path and file.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path and file
///              name. When this function returns successfully, the string contains only the file name, with the path removed.
@DllImport("SHLWAPI")
void PathStripPathW(const(wchar)* pszPath);

///Removes all file and directory elements in a path except for the root information. <div class="alert"><b>Note</b>
///Misuse of this function can lead to a buffer overrun. We recommend the use of the safer PathCchStripToRoot function
///in its place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path to be
///              converted. When this function returns successfully, this string contains only the root information taken from
///              that path.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if a valid drive letter was found in the path, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathStripToRootA(const(char)* pszPath);

///Removes all file and directory elements in a path except for the root information. <div class="alert"><b>Note</b>
///Misuse of this function can lead to a buffer overrun. We recommend the use of the safer PathCchStripToRoot function
///in its place.</div><div> </div>
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path to be
///              converted. When this function returns successfully, this string contains only the root information taken from
///              that path.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if a valid drive letter was found in the path, or <b>FALSE</b> otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathStripToRootW(const(wchar)* pszPath);

///Removes quotes from the beginning and end of a path.
///Params:
///    lpsz = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path. When the
///           function returns successfully, points to the string with beginning and ending quotation marks removed.
///Returns:
///    No return value.
///    
@DllImport("SHLWAPI")
BOOL PathUnquoteSpacesA(const(char)* lpsz);

///Removes quotes from the beginning and end of a path.
///Params:
///    lpsz = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the path. When the
///           function returns successfully, points to the string with beginning and ending quotation marks removed.
///Returns:
///    No return value.
///    
@DllImport("SHLWAPI")
BOOL PathUnquoteSpacesW(const(wchar)* lpsz);

///Gives an existing folder the proper attributes to become a system folder.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the name of an
///              existing folder that will be made into a system folder.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathMakeSystemFolderA(const(char)* pszPath);

///Gives an existing folder the proper attributes to become a system folder.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of length MAX_PATH that contains the name of an
///              existing folder that will be made into a system folder.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathMakeSystemFolderW(const(wchar)* pszPath);

///Removes the attributes from a folder that make it a system folder. This folder must actually exist in the file
///system.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an
///              existing folder that will have the system folder attributes removed.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathUnmakeSystemFolderA(const(char)* pszPath);

///Removes the attributes from a folder that make it a system folder. This folder must actually exist in the file
///system.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an
///              existing folder that will have the system folder attributes removed.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if successful, or zero otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathUnmakeSystemFolderW(const(wchar)* pszPath);

///Determines if an existing folder contains the attributes that make it a system folder. Alternately, this function
///indicates if certain attributes qualify a folder to be a system folder.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of
///              an existing folder. The attributes for this folder will be retrieved and compared with those that define a system
///              folder. If this folder contains the attributes to make it a system folder, the function returns nonzero. If this
///              value is <b>NULL</b>, this function determines if the attributes passed in <i>dwAttrb</i> qualify it to be a
///              system folder.
///    dwAttrb = Type: <b>DWORD</b> The file attributes to be compared. Used only if <i>pszPath</i> is <b>NULL</b>. In that case,
///              the attributes passed in this value are compared with those that qualify a folder as a system folder. If the
///              attributes are sufficient to make this a system folder, this function returns nonzero. These attributes are the
///              attributes that are returned from GetFileAttributes.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if the <i>pszPath</i> or <i>dwAttrb</i> represent a system folder, or zero
///    otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsSystemFolderA(const(char)* pszPath, uint dwAttrb);

///Determines if an existing folder contains the attributes that make it a system folder. Alternately, this function
///indicates if certain attributes qualify a folder to be a system folder.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of
///              an existing folder. The attributes for this folder will be retrieved and compared with those that define a system
///              folder. If this folder contains the attributes to make it a system folder, the function returns nonzero. If this
///              value is <b>NULL</b>, this function determines if the attributes passed in <i>dwAttrb</i> qualify it to be a
///              system folder.
///    dwAttrb = Type: <b>DWORD</b> The file attributes to be compared. Used only if <i>pszPath</i> is <b>NULL</b>. In that case,
///              the attributes passed in this value are compared with those that qualify a folder as a system folder. If the
///              attributes are sufficient to make this a system folder, this function returns nonzero. These attributes are the
///              attributes that are returned from GetFileAttributes.
///Returns:
///    Type: <b>BOOL</b> Returns nonzero if the <i>pszPath</i> or <i>dwAttrb</i> represent a system folder, or zero
///    otherwise.
///    
@DllImport("SHLWAPI")
BOOL PathIsSystemFolderW(const(wchar)* pszPath, uint dwAttrb);

///Removes the decoration from a path string.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A null-terminated string of length MAX_PATH that contains the path. When the function
///              returns, <i>pszPath</i> points to the undecorated string.
@DllImport("SHLWAPI")
void PathUndecorateA(const(char)* pszPath);

///Removes the decoration from a path string.
///Params:
///    pszPath = Type: <b>LPTSTR</b> A null-terminated string of length MAX_PATH that contains the path. When the function
///              returns, <i>pszPath</i> points to the undecorated string.
@DllImport("SHLWAPI")
void PathUndecorateW(const(wchar)* pszPath);

///Replaces certain folder names in a fully qualified path with their associated environment string.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be unexpanded.
///    pszBuf = Type: <b>LPTSTR</b> A pointer to a buffer that, when this method returns successfully, receives the unexpanded
///             string. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned
///             string.
///    cchBuf = Type: <b>UINT</b> The size, in characters, in the <i>pszBuf</i> buffer.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL PathUnExpandEnvStringsA(const(char)* pszPath, const(char)* pszBuf, uint cchBuf);

///Replaces certain folder names in a fully qualified path with their associated environment string.
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to
///              be unexpanded.
///    pszBuf = Type: <b>LPTSTR</b> A pointer to a buffer that, when this method returns successfully, receives the unexpanded
///             string. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned
///             string.
///    cchBuf = Type: <b>UINT</b> The size, in characters, in the <i>pszBuf</i> buffer.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL PathUnExpandEnvStringsW(const(wchar)* pszPath, const(wchar)* pszBuf, uint cchBuf);

///Makes a case-sensitive comparison of two URL strings.
///Params:
///    psz1 = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the first
///           URL.
///    psz2 = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the second
///           URL.
///    fIgnoreSlash = Type: <b>BOOL</b> A value that is set to <b>TRUE</b> to have <b>UrlCompare</b> ignore a trailing '/' character on
///                   either or both URLs.
///Returns:
///    Type: <b>int</b> Returns zero if the two strings are equal. The function will also return zero if
///    <i>fIgnoreSlash</i> is set to <b>TRUE</b> and one of the strings has a trailing '\' character. The function
///    returns a negative integer if the string pointed to by <i>psz1</i> is less than the string pointed to by
///    <i>psz2</i>. Otherwise, it returns a positive integer.
///    
@DllImport("SHLWAPI")
int UrlCompareA(const(char)* psz1, const(char)* psz2, BOOL fIgnoreSlash);

///Makes a case-sensitive comparison of two URL strings.
///Params:
///    psz1 = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the first
///           URL.
///    psz2 = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the second
///           URL.
///    fIgnoreSlash = Type: <b>BOOL</b> A value that is set to <b>TRUE</b> to have <b>UrlCompare</b> ignore a trailing '/' character on
///                   either or both URLs.
///Returns:
///    Type: <b>int</b> Returns zero if the two strings are equal. The function will also return zero if
///    <i>fIgnoreSlash</i> is set to <b>TRUE</b> and one of the strings has a trailing '\' character. The function
///    returns a negative integer if the string pointed to by <i>psz1</i> is less than the string pointed to by
///    <i>psz2</i>. Otherwise, it returns a positive integer.
///    
@DllImport("SHLWAPI")
int UrlCompareW(const(wchar)* psz1, const(wchar)* psz2, BOOL fIgnoreSlash);

///When provided with a relative URL and its base, returns a URL in canonical form.
///Params:
///    pszBase = Type: <b>PCTSTR</b> A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains
///              the base URL.
///    pszRelative = Type: <b>PCTSTR</b> A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains
///                  the relative URL.
///    pszCombined = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives a
///                  null-terminated string that contains the combined URL.
///    pcchCombined = Type: <b>DWORD*</b> A pointer to a value that, on entry, is set to the number of characters in the
///                   <i>pszCombined</i> buffer. When the function returns successfully, the value depends on whether the function is
///                   successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
///    dwFlags = Type: <b>DWORD</b> Flags that specify how the URL is converted to canonical form. The following flags can be
///              combined.
///Returns:
///    Type: <b>HRESULT</b> Returns standard COM error codes, including the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
///    <i>pszCombined</i> points to a string that contains the combined URLs. The value of <i>pcchCombined</i> is set to
///    the number of characters in the string, not counting the terminating <b>NULL</b> character. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The buffer was too small. The value of
///    <i>pcchCombined</i> is set to the minimum number of characters that the buffer must be able to contain, including
///    the terminating <b>NULL</b> character. </td> </tr> </table>
///    
@DllImport("SHLWAPI")
HRESULT UrlCombineA(const(char)* pszBase, const(char)* pszRelative, const(char)* pszCombined, uint* pcchCombined, 
                    uint dwFlags);

///When provided with a relative URL and its base, returns a URL in canonical form.
///Params:
///    pszBase = Type: <b>PCTSTR</b> A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains
///              the base URL.
///    pszRelative = Type: <b>PCTSTR</b> A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains
///                  the relative URL.
///    pszCombined = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives a
///                  null-terminated string that contains the combined URL.
///    pcchCombined = Type: <b>DWORD*</b> A pointer to a value that, on entry, is set to the number of characters in the
///                   <i>pszCombined</i> buffer. When the function returns successfully, the value depends on whether the function is
///                   successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
///    dwFlags = Type: <b>DWORD</b> Flags that specify how the URL is converted to canonical form. The following flags can be
///              combined.
///Returns:
///    Type: <b>HRESULT</b> Returns standard COM error codes, including the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
///    <i>pszCombined</i> points to a string that contains the combined URLs. The value of <i>pcchCombined</i> is set to
///    the number of characters in the string, not counting the terminating <b>NULL</b> character. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The buffer was too small. The value of
///    <i>pcchCombined</i> is set to the minimum number of characters that the buffer must be able to contain, including
///    the terminating <b>NULL</b> character. </td> </tr> </table>
///    
@DllImport("SHLWAPI")
HRESULT UrlCombineW(const(wchar)* pszBase, const(wchar)* pszRelative, const(wchar)* pszCombined, 
                    uint* pcchCombined, uint dwFlags);

///Converts a URL string into canonical form.
///Params:
///    pszUrl = Type: <b>PCTSTR</b> A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains
///             a URL string. If the string does not refer to a file, it must include a valid scheme such as "http://".
///    pszCanonicalized = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the converted
///                       URL as a null-terminated string.
///    pcchCanonicalized = Type: <b>DWORD*</b> A pointer to a value that, on entry, is set to the number of characters in the
///                        <i>pszCanonicalized</i> buffer.
///    dwFlags = Type: <b>DWORD</b> The flags that specify how the URL is converted to canonical form. The following flags can be
///              combined.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT UrlCanonicalizeA(const(char)* pszUrl, const(char)* pszCanonicalized, uint* pcchCanonicalized, uint dwFlags);

///Converts a URL string into canonical form.
///Params:
///    pszUrl = Type: <b>PCTSTR</b> A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains
///             a URL string. If the string does not refer to a file, it must include a valid scheme such as "http://".
///    pszCanonicalized = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the converted
///                       URL as a null-terminated string.
///    pcchCanonicalized = Type: <b>DWORD*</b> A pointer to a value that, on entry, is set to the number of characters in the
///                        <i>pszCanonicalized</i> buffer.
///    dwFlags = Type: <b>DWORD</b> The flags that specify how the URL is converted to canonical form. The following flags can be
///              combined.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT UrlCanonicalizeW(const(wchar)* pszUrl, const(wchar)* pszCanonicalized, uint* pcchCanonicalized, 
                         uint dwFlags);

///Returns whether a URL is opaque.
///Params:
///    pszURL = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
///Returns:
///    Type: <b>BOOL</b> Returns a nonzero value if the URL is opaque, or zero otherwise.
///    
@DllImport("SHLWAPI")
BOOL UrlIsOpaqueA(const(char)* pszURL);

///Returns whether a URL is opaque.
///Params:
///    pszURL = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
///Returns:
///    Type: <b>BOOL</b> Returns a nonzero value if the URL is opaque, or zero otherwise.
///    
@DllImport("SHLWAPI")
BOOL UrlIsOpaqueW(const(wchar)* pszURL);

///Returns whether a URL is a URL that browsers typically do not include in navigation history.
///Params:
///    pszURL = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
///Returns:
///    Type: <b>BOOL</b> Returns a nonzero value if the URL is a URL that is not included in navigation history, or zero
///    otherwise.
///    
@DllImport("SHLWAPI")
BOOL UrlIsNoHistoryA(const(char)* pszURL);

///Returns whether a URL is a URL that browsers typically do not include in navigation history.
///Params:
///    pszURL = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
///Returns:
///    Type: <b>BOOL</b> Returns a nonzero value if the URL is a URL that is not included in navigation history, or zero
///    otherwise.
///    
@DllImport("SHLWAPI")
BOOL UrlIsNoHistoryW(const(wchar)* pszURL);

///Tests whether a URL is a specified type.
///Params:
///    pszUrl = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
///    UrlIs = Type: <b>URLIS</b> The type of URL to be tested for. This parameter can take one of the following values.
///Returns:
///    Type: <b>BOOL</b> For all but one of the URL types, <b>UrlIs</b> returns <b>TRUE</b> if the URL is the specified
///    type, or <b>FALSE</b> if not. If <i>UrlIs</i> is set to <b>URLIS_APPLIABLE</b>, <b>UrlIs</b> will attempt to
///    determine the URL scheme. If the function is able to determine a scheme, it returns <b>TRUE</b>, or <b>FALSE</b>
///    otherwise.
///    
@DllImport("SHLWAPI")
BOOL UrlIsA(const(char)* pszUrl, URLIS UrlIs);

///Tests whether a URL is a specified type.
///Params:
///    pszUrl = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
///    UrlIs = Type: <b>URLIS</b> The type of URL to be tested for. This parameter can take one of the following values.
///Returns:
///    Type: <b>BOOL</b> For all but one of the URL types, <b>UrlIs</b> returns <b>TRUE</b> if the URL is the specified
///    type, or <b>FALSE</b> if not. If <i>UrlIs</i> is set to <b>URLIS_APPLIABLE</b>, <b>UrlIs</b> will attempt to
///    determine the URL scheme. If the function is able to determine a scheme, it returns <b>TRUE</b>, or <b>FALSE</b>
///    otherwise.
///    
@DllImport("SHLWAPI")
BOOL UrlIsW(const(wchar)* pszUrl, URLIS UrlIs);

///Retrieves the location from a URL.
///Params:
///    pszURL = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the
///             location.
///Returns:
///    Type: <b>LPCTSTR</b> Returns a pointer to a null-terminated string with the location, or <b>NULL</b> otherwise.
///    
@DllImport("SHLWAPI")
byte* UrlGetLocationA(const(char)* pszURL);

///Retrieves the location from a URL.
///Params:
///    pszURL = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the
///             location.
///Returns:
///    Type: <b>LPCTSTR</b> Returns a pointer to a null-terminated string with the location, or <b>NULL</b> otherwise.
///    
@DllImport("SHLWAPI")
ushort* UrlGetLocationW(const(wchar)* pszURL);

///Converts escape sequences back into ordinary characters.
///Params:
///    pszUrl = Type: <b>PTSTR</b> A pointer to a null-terminated string with the URL. If <i>dwFlags</i> is set to
///             <b>URL_UNESCAPE_INPLACE</b>, the converted string is returned through this parameter.
///    pszUnescaped = Type: <b>PTSTR</b> A pointer to a buffer that will receive a null-terminated string that contains the unescaped
///                   version of <i>pszURL</i>. If <b>URL_UNESCAPE_INPLACE</b> is set in <i>dwFlags</i>, this parameter is ignored.
///    pcchUnescaped = Type: <b>DWORD*</b> The number of characters in the buffer pointed to by <i>pszUnescaped</i>. On entry, the value
///                    <i>pcchUnescaped</i> points to is set to the size of the buffer. If the function returns a success code, the
///                    value that <i>pcchUnescaped</i> points to is set to the number of characters written to that buffer, not counting
///                    the terminating <b>NULL</b> character. If an E_POINTER error code is returned, the buffer was too small, and the
///                    value to which <i>pcchUnescaped</i> points is set to the required number of characters that the buffer must be
///                    able to contain. If any other errors are returned, the value to which <i>pcchUnescaped</i> points is undefined.
///    dwFlags = Type: <b>DWORD</b> Flags that control which characters are unescaped. It can be a combination of the following
///              flags.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful. If the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value
///    pointed to by <i>pcchUnescaped</i> will be set to the number of characters in the output buffer pointed to by
///    <i>pszUnescaped</i>. Returns E_POINTER if the <b>URL_UNESCAPE_INPLACE</b> flag is not set and the output buffer
///    is too small. The <i>pcchUnescaped</i> parameter will be set to the required buffer size. Otherwise, returns a
///    standard error value.
///    
@DllImport("SHLWAPI")
HRESULT UrlUnescapeA(const(char)* pszUrl, const(char)* pszUnescaped, uint* pcchUnescaped, uint dwFlags);

///Converts escape sequences back into ordinary characters.
///Params:
///    pszUrl = Type: <b>PTSTR</b> A pointer to a null-terminated string with the URL. If <i>dwFlags</i> is set to
///             <b>URL_UNESCAPE_INPLACE</b>, the converted string is returned through this parameter.
///    pszUnescaped = Type: <b>PTSTR</b> A pointer to a buffer that will receive a null-terminated string that contains the unescaped
///                   version of <i>pszURL</i>. If <b>URL_UNESCAPE_INPLACE</b> is set in <i>dwFlags</i>, this parameter is ignored.
///    pcchUnescaped = Type: <b>DWORD*</b> The number of characters in the buffer pointed to by <i>pszUnescaped</i>. On entry, the value
///                    <i>pcchUnescaped</i> points to is set to the size of the buffer. If the function returns a success code, the
///                    value that <i>pcchUnescaped</i> points to is set to the number of characters written to that buffer, not counting
///                    the terminating <b>NULL</b> character. If an E_POINTER error code is returned, the buffer was too small, and the
///                    value to which <i>pcchUnescaped</i> points is set to the required number of characters that the buffer must be
///                    able to contain. If any other errors are returned, the value to which <i>pcchUnescaped</i> points is undefined.
///    dwFlags = Type: <b>DWORD</b> Flags that control which characters are unescaped. It can be a combination of the following
///              flags.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful. If the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value
///    pointed to by <i>pcchUnescaped</i> will be set to the number of characters in the output buffer pointed to by
///    <i>pszUnescaped</i>. Returns E_POINTER if the <b>URL_UNESCAPE_INPLACE</b> flag is not set and the output buffer
///    is too small. The <i>pcchUnescaped</i> parameter will be set to the required buffer size. Otherwise, returns a
///    standard error value.
///    
@DllImport("SHLWAPI")
HRESULT UrlUnescapeW(const(wchar)* pszUrl, const(wchar)* pszUnescaped, uint* pcchUnescaped, uint dwFlags);

///Converts characters or surrogate pairs in a URL that might be altered during transport across the Internet ("unsafe"
///characters) into their corresponding escape sequences. Surrogate pairs are characters between U+10000 to U+10FFFF (in
///UTF-32) or between DC00 to DFFF (in UTF-16).
///Params:
///    pszUrl = Type: <b>PCTSTR</b> A null-terminated string of maximum length <b>INTERNET_MAX_URL_LENGTH</b> that contains a
///             full or partial URL, as appropriate for the value in <i>dwFlags</i>.
///    pszEscaped = Type: <b>PTSTR</b> The buffer that receives the converted string, with the unsafe characters converted to their
///                 escape sequences.
///    pcchEscaped = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> value that, on entry, contains the number of characters in the
///                  <i>pszEscaped</i> buffer. Before calling <b>UrlEscape</b>, the calling application must set the value referenced
///                  by <i>pcchEscaped</i> to the size of the buffer. When this function returns successfully, the value receives the
///                  number of characters written to the buffer, not including the terminating <b>NULL</b> character. If an E_POINTER
///                  error code is returned, the buffer was too small to hold the result, and the value referenced by
///                  <i>pcchEscaped</i> is set to the required number of characters in the buffer. If any other errors are returned,
///                  the value referenced by <i>pcchEscaped</i> is undefined.
///    dwFlags = Type: <b>DWORD</b> The flags that indicate which portion of the URL is being provided in <i>pszURL</i> and which
///              characters in that string should be converted to their escape sequences. The following flags are defined.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful. If the <i>pcchEscaped</i> buffer was too small to contain the
///    result, E_POINTER is returned, and the value pointed to by <i>pcchEscaped</i> is set to the required buffer size.
///    Otherwise, a standard error value is returned.
///    
@DllImport("SHLWAPI")
HRESULT UrlEscapeA(const(char)* pszUrl, const(char)* pszEscaped, uint* pcchEscaped, uint dwFlags);

///Converts characters or surrogate pairs in a URL that might be altered during transport across the Internet ("unsafe"
///characters) into their corresponding escape sequences. Surrogate pairs are characters between U+10000 to U+10FFFF (in
///UTF-32) or between DC00 to DFFF (in UTF-16).
///Params:
///    pszUrl = Type: <b>PCTSTR</b> A null-terminated string of maximum length <b>INTERNET_MAX_URL_LENGTH</b> that contains a
///             full or partial URL, as appropriate for the value in <i>dwFlags</i>.
///    pszEscaped = Type: <b>PTSTR</b> The buffer that receives the converted string, with the unsafe characters converted to their
///                 escape sequences.
///    pcchEscaped = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> value that, on entry, contains the number of characters in the
///                  <i>pszEscaped</i> buffer. Before calling <b>UrlEscape</b>, the calling application must set the value referenced
///                  by <i>pcchEscaped</i> to the size of the buffer. When this function returns successfully, the value receives the
///                  number of characters written to the buffer, not including the terminating <b>NULL</b> character. If an E_POINTER
///                  error code is returned, the buffer was too small to hold the result, and the value referenced by
///                  <i>pcchEscaped</i> is set to the required number of characters in the buffer. If any other errors are returned,
///                  the value referenced by <i>pcchEscaped</i> is undefined.
///    dwFlags = Type: <b>DWORD</b> The flags that indicate which portion of the URL is being provided in <i>pszURL</i> and which
///              characters in that string should be converted to their escape sequences. The following flags are defined.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful. If the <i>pcchEscaped</i> buffer was too small to contain the
///    result, E_POINTER is returned, and the value pointed to by <i>pcchEscaped</i> is set to the required buffer size.
///    Otherwise, a standard error value is returned.
///    
@DllImport("SHLWAPI")
HRESULT UrlEscapeW(const(wchar)* pszUrl, const(wchar)* pszEscaped, uint* pcchEscaped, uint dwFlags);

///Converts a Microsoft MS-DOS path to a canonicalized URL.
///Params:
///    pszPath = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the MS-DOS
///              path.
///    pszUrl = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the URL.
///    pcchUrl = Type: <b>DWORD*</b> The number of characters in <i>pszUrl</i>.
///    dwFlags = Type: <b>DWORD</b> Reserved. Set this parameter to <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> Returns S_FALSE if <i>pszPath</i> is already in URL format. In this case, <i>pszPath</i>
///    will simply be copied to <i>pszUrl</i>. Otherwise, it returns S_OK if successful or a standard COM error value if
///    not.
///    
@DllImport("SHLWAPI")
HRESULT UrlCreateFromPathA(const(char)* pszPath, const(char)* pszUrl, uint* pcchUrl, uint dwFlags);

///Converts a Microsoft MS-DOS path to a canonicalized URL.
///Params:
///    pszPath = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the MS-DOS
///              path.
///    pszUrl = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the URL.
///    pcchUrl = Type: <b>DWORD*</b> The number of characters in <i>pszUrl</i>.
///    dwFlags = Type: <b>DWORD</b> Reserved. Set this parameter to <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> Returns S_FALSE if <i>pszPath</i> is already in URL format. In this case, <i>pszPath</i>
///    will simply be copied to <i>pszUrl</i>. Otherwise, it returns S_OK if successful or a standard COM error value if
///    not.
///    
@DllImport("SHLWAPI")
HRESULT UrlCreateFromPathW(const(wchar)* pszPath, const(wchar)* pszUrl, uint* pcchUrl, uint dwFlags);

///Converts a file URL to a Microsoft MS-DOS path.
///Params:
///    pszUrl = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
///    pszPath = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the MS-DOS path.
///              You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
///    pcchPath = Type: <b>DWORD*</b> The number of characters in the <i>pszPath</i> buffer.
///    dwFlags = Type: <b>DWORD</b> Reserved. Set this parameter to <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT PathCreateFromUrlA(const(char)* pszUrl, const(char)* pszPath, uint* pcchPath, uint dwFlags);

///Converts a file URL to a Microsoft MS-DOS path.
///Params:
///    pszUrl = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
///    pszPath = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives the MS-DOS path.
///              You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
///    pcchPath = Type: <b>DWORD*</b> The number of characters in the <i>pszPath</i> buffer.
///    dwFlags = Type: <b>DWORD</b> Reserved. Set this parameter to <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT PathCreateFromUrlW(const(wchar)* pszUrl, const(wchar)* pszPath, uint* pcchPath, uint dwFlags);

///Creates a path from a file URL.
///Params:
///    pszIn = Type: <b>PCWSTR</b> A pointer to the URL of a file, represented as a null-terminated, Unicode string.
///    ppszOut = Type: <b>PWSTR*</b> The address of a pointer to a buffer of length MAX_PATH that, when this function returns
///              successfully, receives the file path.
///    dwFlags = Type: <b>DWORD</b> Reserved, must be 0.
@DllImport("SHLWAPI")
HRESULT PathCreateFromUrlAlloc(const(wchar)* pszIn, ushort** ppszOut, uint dwFlags);

///Hashes a URL string.
///Params:
///    pszUrl = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
///    pbHash = Type: <b>BYTE*</b> A pointere to a buffer that, when this function returns successfully, receives the hashed
///             array.
///    cbHash = Type: <b>DWORD</b> The number of elements in the array at <i>pbHash</i>. It should be no larger than 256.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT UrlHashA(const(char)* pszUrl, char* pbHash, uint cbHash);

///Hashes a URL string.
///Params:
///    pszUrl = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
///    pbHash = Type: <b>BYTE*</b> A pointere to a buffer that, when this function returns successfully, receives the hashed
///             array.
///    cbHash = Type: <b>DWORD</b> The number of elements in the array at <i>pbHash</i>. It should be no larger than 256.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT UrlHashW(const(wchar)* pszUrl, char* pbHash, uint cbHash);

///Accepts a URL string and returns a specified part of that URL.
///Params:
///    pszIn = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
///    pszOut = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives a
///             null-terminated string with the specified part of the URL.
///    pcchOut = Type: <b>DWORD*</b> A pointer to a value that, on entry, is set to the number of characters in the <i>pszOut</i>
///              buffer. When this function returns successfully, the value depends on whether the function is successful or
///              returns E_POINTER. For other return values, the value of this parameter is meaningless.
///    dwPart = Type: <b>DWORD</b> The flags that specify which part of the URL to retrieve. It can have one of the following
///             values.
///    dwFlags = Type: <b>DWORD</b> A flag that can be set to keep the URL scheme, in addition to the part that is specified by
///              <i>dwPart</i>.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful. The value pointed to by <i>pcchOut</i> will be set to the number
///    of characters written to the output buffer, excluding the terminating <b>NULL</b>. If the buffer was too small,
///    E_POINTER is returned, and the value pointed to by <i>pcchOut</i> will be set to the minimum number of characters
///    that the buffer must be able to contain, including the terminating <b>NULL</b> character. Otherwise, a COM error
///    value is returned.
///    
@DllImport("SHLWAPI")
HRESULT UrlGetPartW(const(wchar)* pszIn, const(wchar)* pszOut, uint* pcchOut, uint dwPart, uint dwFlags);

///Accepts a URL string and returns a specified part of that URL.
///Params:
///    pszIn = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
///    pszOut = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives a
///             null-terminated string with the specified part of the URL.
///    pcchOut = Type: <b>DWORD*</b> A pointer to a value that, on entry, is set to the number of characters in the <i>pszOut</i>
///              buffer. When this function returns successfully, the value depends on whether the function is successful or
///              returns E_POINTER. For other return values, the value of this parameter is meaningless.
///    dwPart = Type: <b>DWORD</b> The flags that specify which part of the URL to retrieve. It can have one of the following
///             values.
///    dwFlags = Type: <b>DWORD</b> A flag that can be set to keep the URL scheme, in addition to the part that is specified by
///              <i>dwPart</i>.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful. The value pointed to by <i>pcchOut</i> will be set to the number
///    of characters written to the output buffer, excluding the terminating <b>NULL</b>. If the buffer was too small,
///    E_POINTER is returned, and the value pointed to by <i>pcchOut</i> will be set to the minimum number of characters
///    that the buffer must be able to contain, including the terminating <b>NULL</b> character. Otherwise, a COM error
///    value is returned.
///    
@DllImport("SHLWAPI")
HRESULT UrlGetPartA(const(char)* pszIn, const(char)* pszOut, uint* pcchOut, uint dwPart, uint dwFlags);

///Determines a scheme for a specified URL string, and returns a string with an appropriate prefix.
///Params:
///    pszIn = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL.
///    pszOut = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives a
///             null-terminated string set to the URL specified by <i>pszIn</i> and converted to the standard
///             <i>scheme</i>://<i>URL_string</i> format.
///    pcchOut = Type: <b>DWORD*</b> The address of a value set to the number of characters in the <i>pszOut</i> buffer. When the
///              function returns, the value depends on whether the function is successful or returns E_POINTER. For other return
///              values, the value of this parameter is meaningless.
///    dwFlags = Type: <b>DWORD</b> The flags that specify how to determine the scheme. The following flags can be combined.
///Returns:
///    Type: <b>HRESULT</b> Returns a standard COM return value, including the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
///    A scheme was determined. pszOut points to a string containing the URL with the scheme's prefix. The value of
///    <i>pcchOut</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b>
///    character. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> There were
///    no errors, but no prefix was prepended. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
///    </td> <td width="60%"> The buffer was too small. The value of <i>pcchOut</i> is set to the minimum number of
///    characters that the buffer must be able to contain, including the terminating <b>NULL</b> character. </td> </tr>
///    </table>
///    
@DllImport("SHLWAPI")
HRESULT UrlApplySchemeA(const(char)* pszIn, const(char)* pszOut, uint* pcchOut, uint dwFlags);

///Determines a scheme for a specified URL string, and returns a string with an appropriate prefix.
///Params:
///    pszIn = Type: <b>PCTSTR</b> A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL.
///    pszOut = Type: <b>PTSTR</b> A pointer to a buffer that, when this function returns successfully, receives a
///             null-terminated string set to the URL specified by <i>pszIn</i> and converted to the standard
///             <i>scheme</i>://<i>URL_string</i> format.
///    pcchOut = Type: <b>DWORD*</b> The address of a value set to the number of characters in the <i>pszOut</i> buffer. When the
///              function returns, the value depends on whether the function is successful or returns E_POINTER. For other return
///              values, the value of this parameter is meaningless.
///    dwFlags = Type: <b>DWORD</b> The flags that specify how to determine the scheme. The following flags can be combined.
///Returns:
///    Type: <b>HRESULT</b> Returns a standard COM return value, including the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
///    A scheme was determined. pszOut points to a string containing the URL with the scheme's prefix. The value of
///    <i>pcchOut</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b>
///    character. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> There were
///    no errors, but no prefix was prepended. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
///    </td> <td width="60%"> The buffer was too small. The value of <i>pcchOut</i> is set to the minimum number of
///    characters that the buffer must be able to contain, including the terminating <b>NULL</b> character. </td> </tr>
///    </table>
///    
@DllImport("SHLWAPI")
HRESULT UrlApplySchemeW(const(wchar)* pszIn, const(wchar)* pszOut, uint* pcchOut, uint dwFlags);

///Hashes an array of data.
///Params:
///    pbData = Type: <b>BYTE*</b> A pointer to the data array.
///    cbData = Type: <b>DWORD</b> The number of elements in the array at <i>pbData</i>.
///    pbHash = Type: <b>BYTE*</b> A pointer to a value that, when this function returns successfully, receives the hashed array.
///    cbHash = Type: <b>DWORD</b> The number of elements in <i>pbHash</i>. It should be no larger than 256.
@DllImport("SHLWAPI")
HRESULT HashData(char* pbData, uint cbData, char* pbHash, uint cbHash);

///<p class="CCE_Message">[<b>UrlFixupW</b> is available for use in the operating systems specified in the Requirements
///section. It may be altered or unavailable in subsequent versions.] Attempts to correct a URL whose protocol
///identifier is incorrect. For example, <code>htttp</code> will be changed to <code>http</code>.
///Params:
///    pcszUrl = Type: <b>PCWSTR</b> A pointer to a <b>null</b>-terminated string that contains the URL to be corrected. This
///              string must not exceed INTERNET_MAX_PATH_LENGTH characters in length, including the terminating <b>NULL</b>
///              character.
///    pszTranslatedUrl = Type: <b>PWSTR</b> A pointer to a buffer that, when this function returns successfully, receives the copied
///                       characters. The buffer must be large enough to contain the number of WCHAR characters specified by the
///                       <i>cchMax</i> parameter, including the terminating <b>NULL</b> character. This parameter can be equal to the
///                       <i>pcszUrl</i> parameter to correct a URL in place. If <i>pszTranslatedUrl</i> is not equal to <i>pcszUrl</i>,
///                       the buffer pointed to by <i>pszTranslatedUrl</i> must not overlap the buffer pointed to by <i>pcszUrl</i>.
///    cchMax = Type: <b>DWORD</b> The number of <b>WCHAR</b> characters that can be contained in the buffer pointed to by
///             <i>pszTranslatedUrl</i>. This parameter must be greater than zero.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if the proposed URL was already acceptable or was successfully corrected. The
///    <i>pszTranslatedUrl</i> buffer contains the corrected URL, or the original URL if no correction was needed.
///    Returns S_FALSE if the proposed URL could not be recognized sufficiently to be corrected. Otherwise, returns a
///    standard COM error code.
///    
@DllImport("SHLWAPI")
HRESULT UrlFixupW(const(wchar)* pcszUrl, const(wchar)* pszTranslatedUrl, uint cchMax);

///Performs rudimentary parsing of a URL.
///Params:
///    pcszURL = Type: <b>LPCTSTR</b> A pointer to a null-terminated string containing the URL to be parsed.
///    ppu = Type: <b>PARSEDURL*</b> A pointer to a PARSEDURL structure that receives the parsed results. The calling
///          application must set the structure's <i>cbSize</i> member to the size of the structure before calling
///          <b>ParseURL</b>.
///Returns:
///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success, or a COM error code otherwise. The function returns
///    <b>URL_E_INVALID_SYNTAX</b> (defined in Intshcut.h) if the string could not be parsed as a URL.
///    
@DllImport("SHLWAPI")
HRESULT ParseURLA(const(char)* pcszURL, PARSEDURLA* ppu);

///Performs rudimentary parsing of a URL.
///Params:
///    pcszURL = Type: <b>LPCTSTR</b> A pointer to a null-terminated string containing the URL to be parsed.
///    ppu = Type: <b>PARSEDURL*</b> A pointer to a PARSEDURL structure that receives the parsed results. The calling
///          application must set the structure's <i>cbSize</i> member to the size of the structure before calling
///          <b>ParseURL</b>.
///Returns:
///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success, or a COM error code otherwise. The function returns
///    <b>URL_E_INVALID_SYNTAX</b> (defined in Intshcut.h) if the string could not be parsed as a URL.
///    
@DllImport("SHLWAPI")
HRESULT ParseURLW(const(wchar)* pcszURL, PARSEDURLW* ppu);

///Deletes an empty key.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to an open registry key, or one of the following predefined keys: <a
///           id="HKEY_CLASSES_ROOT"></a> <a id="hkey_classes_root"></a>
///    pszSubKey = Type: <b>LPCTSTR</b> The address of a null-terminated string specifying the name of the key to delete.
///Returns:
///    Type: <b>LSTATUS</b> Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a
///    generic description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHDeleteEmptyKeyA(HKEY hkey, const(char)* pszSubKey);

///Deletes an empty key.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to an open registry key, or one of the following predefined keys: <a
///           id="HKEY_CLASSES_ROOT"></a> <a id="hkey_classes_root"></a>
///    pszSubKey = Type: <b>LPCTSTR</b> The address of a null-terminated string specifying the name of the key to delete.
///Returns:
///    Type: <b>LSTATUS</b> Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a
///    generic description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHDeleteEmptyKeyW(HKEY hkey, const(wchar)* pszSubKey);

///Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to an open registry key, or one of the following predefined keys: <a
///           id="HKEY_CLASSES_ROOT"></a> <a id="hkey_classes_root"></a>
///    pszSubKey = Type: <b>LPCTSTR</b> The address of a null-terminated string specifying the name of the key to delete.
///Returns:
///    Type: <b>LSTATUS</b> Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a
///    generic description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHDeleteKeyA(HKEY hkey, const(char)* pszSubKey);

///Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to an open registry key, or one of the following predefined keys: <a
///           id="HKEY_CLASSES_ROOT"></a> <a id="hkey_classes_root"></a>
///    pszSubKey = Type: <b>LPCTSTR</b> The address of a null-terminated string specifying the name of the key to delete.
///Returns:
///    Type: <b>LSTATUS</b> Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a
///    generic description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHDeleteKeyW(HKEY hkey, const(wchar)* pszSubKey);

///Duplicates a registry key's HKEY handle.
///Params:
///    hkey = Type: <b>HKEY</b> The HKEY handle to be duplicated.
@DllImport("SHLWAPI")
HKEY SHRegDuplicateHKey(HKEY hkey);

///Deletes a named value from the specified registry key.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    pszSubKey = Type: <b>LPCTSTR</b> The address of a null-terminated string specifying the name of the subkey for which to
///                change the value.
///    pszValue = Type: <b>LPCTSTR</b> The address of the value to be deleted.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHDeleteValueA(HKEY hkey, const(char)* pszSubKey, const(char)* pszValue);

///Deletes a named value from the specified registry key.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    pszSubKey = Type: <b>LPCTSTR</b> The address of a null-terminated string specifying the name of the subkey for which to
///                change the value.
///    pszValue = Type: <b>LPCTSTR</b> The address of the value to be deleted.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHDeleteValueW(HKEY hkey, const(wchar)* pszSubKey, const(wchar)* pszValue);

///Retrieves a registry value.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    pszSubKey = Type: <b>LPCTSTR</b> The address of a null-terminated string that specifies the name of the subkey from which to
///                retrieve the value.
///    pszValue = Type: <b>LPCTSTR</b> The address of the value.
///    pdwType = Type: <b>LPDWORD</b> The type of value. For more information, see Registry Data Types.
///    pvData = Type: <b>LPVOID</b> The address of the destination data buffer.
///    pcbData = Type: <b>LPDWORD</b> The size of the destination data buffer.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHGetValueA(HKEY hkey, const(char)* pszSubKey, const(char)* pszValue, uint* pdwType, char* pvData, 
                    uint* pcbData);

///Retrieves a registry value.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    pszSubKey = Type: <b>LPCTSTR</b> The address of a null-terminated string that specifies the name of the subkey from which to
///                retrieve the value.
///    pszValue = Type: <b>LPCTSTR</b> The address of the value.
///    pdwType = Type: <b>LPDWORD</b> The type of value. For more information, see Registry Data Types.
///    pvData = Type: <b>LPVOID</b> The address of the destination data buffer.
///    pcbData = Type: <b>LPDWORD</b> The size of the destination data buffer.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHGetValueW(HKEY hkey, const(wchar)* pszSubKey, const(wchar)* pszValue, uint* pdwType, char* pvData, 
                    uint* pcbData);

///Sets the value of a registry key.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    pszSubKey = Type: <b>LPCTSTR</b> The address of a null-terminated string that specifies the name of the subkey with which a
///                value is associated. This can be <b>NULL</b> or a pointer to an empty string. In this case, the value is added to
///                the key identified by the <i>hkey</i> parameter.
///    pszValue = Type: <b>LPCTSTR</b> The address of a null-terminated string that specifies the value. This value can be
///               <b>NULL</b>.
///    dwType = Type: <b>DWORD</b> Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more
///             information, see Registry Data Types.
///    pvData = Type: <b>LPCVOID</b> Pointer to a buffer that contains the data to set for the specified value. This value can be
///             <b>NULL</b>.
///    cbData = Type: <b>DWORD</b> Length, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. If the data is a
///             null-terminated string, this length includes the terminating null character.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h.
///    You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description
///    of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHSetValueA(HKEY hkey, const(char)* pszSubKey, const(char)* pszValue, uint dwType, char* pvData, 
                    uint cbData);

///Sets the value of a registry key.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    pszSubKey = Type: <b>LPCTSTR</b> The address of a null-terminated string that specifies the name of the subkey with which a
///                value is associated. This can be <b>NULL</b> or a pointer to an empty string. In this case, the value is added to
///                the key identified by the <i>hkey</i> parameter.
///    pszValue = Type: <b>LPCTSTR</b> The address of a null-terminated string that specifies the value. This value can be
///               <b>NULL</b>.
///    dwType = Type: <b>DWORD</b> Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more
///             information, see Registry Data Types.
///    pvData = Type: <b>LPCVOID</b> Pointer to a buffer that contains the data to set for the specified value. This value can be
///             <b>NULL</b>.
///    cbData = Type: <b>DWORD</b> Length, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. If the data is a
///             null-terminated string, this length includes the terminating null character.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h.
///    You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description
///    of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHSetValueW(HKEY hkey, const(wchar)* pszSubKey, const(wchar)* pszValue, uint dwType, char* pvData, 
                    uint cbData);

///<p class="CCE_Message">[<b>SHRegGetValue</b> may be altered or unavailable in subsequent versions of the operating
///system or product. Use RegGetValue in its place.] Retrieves a registry value.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values. <a
///           id="HKEY_CLASSES_ROOT"></a> <a id="hkey_classes_root"></a>
///    pszSubKey = Type: <b>LPCTSTR</b> A pointer to a <b>null</b>-terminated string that specifies the relative path from
///                <i>hkey</i> to the subkey to retrieve the value from. This parameter can be <b>NULL</b> or an empty string, in
///                which case the data is retrieved from the <i>hkey</i> location.
///    pszValue = Type: <b>LPCTSTR</b> A pointer to a <b>null</b>-terminated string that contains the name of the value. This
///               parameter can be <b>NULL</b> or an empty string, in which case the data is retrieved from the Default value.
///    srrfFlags = Type: <b>SRRF</b> One or more of the SRRF flags that restricts the data to be retrieved. At least one type
///                restriction (SRRF_RT) value must be specified.
///    pdwType = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value.
///              When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see
///              Registry Data Types. If the SRRF_NOEXPAND flag is not set, REG_EXPAND_SZ types are automatically expanded and
///              returned as REG_SZ. If type information is not required, this parameter can be <b>NULL</b>.
///    pvData = Type: <b>LPVOID</b> A pointer to a buffer that receives the value's data. This parameter can be <b>NULL</b> if
///             the data is not needed. For example, if you were testing only for a value's existence, the specific value data
///             would be superfluous.
///    pcbData = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that, on entry, contains the size of the destination data buffer
///              <i>pvData</i>, in bytes. This value can be <b>NULL</b> only if <i>pvData</i> is <b>NULL</b>. On exit,
///              <i>pcbData</i> points to one of these values. <table class="clsStd"> <tr> <th>pvData</th> <th>Return Value</th>
///              <th>pcbData</th> </tr> <tr> <td><b>NULL</b></td> <td>ERROR_SUCCESS</td> <td>Size in bytes sufficient to hold the
///              registry data. Note that this is not guaranteed to be the precise size, but only a sufficient size.</td> </tr>
///              <tr> <td>Non-<b>NULL</b></td> <td>ERROR_SUCCESS</td> <td>Exact number of bytes written to <i>pvData</i>.</td>
///              </tr> <tr> <td>Non-<b>NULL</b></td> <td>ERROR_MORE_DATA</td> <td>Size in bytes needed to hold the entire data.
///              Note that this is not guaranteed to be the precise size, but only a sufficient size.</td> </tr> </table>
///Returns:
///    Type: <b>LSTATUS</b> Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a
///    generic description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegGetValueA(HKEY hkey, const(char)* pszSubKey, const(char)* pszValue, int srrfFlags, uint* pdwType, 
                       char* pvData, uint* pcbData);

///<p class="CCE_Message">[<b>SHRegGetValue</b> may be altered or unavailable in subsequent versions of the operating
///system or product. Use RegGetValue in its place.] Retrieves a registry value.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values. <a
///           id="HKEY_CLASSES_ROOT"></a> <a id="hkey_classes_root"></a>
///    pszSubKey = Type: <b>LPCTSTR</b> A pointer to a <b>null</b>-terminated string that specifies the relative path from
///                <i>hkey</i> to the subkey to retrieve the value from. This parameter can be <b>NULL</b> or an empty string, in
///                which case the data is retrieved from the <i>hkey</i> location.
///    pszValue = Type: <b>LPCTSTR</b> A pointer to a <b>null</b>-terminated string that contains the name of the value. This
///               parameter can be <b>NULL</b> or an empty string, in which case the data is retrieved from the Default value.
///    srrfFlags = Type: <b>SRRF</b> One or more of the SRRF flags that restricts the data to be retrieved. At least one type
///                restriction (SRRF_RT) value must be specified.
///    pdwType = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value.
///              When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see
///              Registry Data Types. If the SRRF_NOEXPAND flag is not set, REG_EXPAND_SZ types are automatically expanded and
///              returned as REG_SZ. If type information is not required, this parameter can be <b>NULL</b>.
///    pvData = Type: <b>LPVOID</b> A pointer to a buffer that receives the value's data. This parameter can be <b>NULL</b> if
///             the data is not needed. For example, if you were testing only for a value's existence, the specific value data
///             would be superfluous.
///    pcbData = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that, on entry, contains the size of the destination data buffer
///              <i>pvData</i>, in bytes. This value can be <b>NULL</b> only if <i>pvData</i> is <b>NULL</b>. On exit,
///              <i>pcbData</i> points to one of these values. <table class="clsStd"> <tr> <th>pvData</th> <th>Return Value</th>
///              <th>pcbData</th> </tr> <tr> <td><b>NULL</b></td> <td>ERROR_SUCCESS</td> <td>Size in bytes sufficient to hold the
///              registry data. Note that this is not guaranteed to be the precise size, but only a sufficient size.</td> </tr>
///              <tr> <td>Non-<b>NULL</b></td> <td>ERROR_SUCCESS</td> <td>Exact number of bytes written to <i>pvData</i>.</td>
///              </tr> <tr> <td>Non-<b>NULL</b></td> <td>ERROR_MORE_DATA</td> <td>Size in bytes needed to hold the entire data.
///              Note that this is not guaranteed to be the precise size, but only a sufficient size.</td> </tr> </table>
///Returns:
///    Type: <b>LSTATUS</b> Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a
///    generic description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegGetValueW(HKEY hkey, const(wchar)* pszSubKey, const(wchar)* pszValue, int srrfFlags, uint* pdwType, 
                       char* pvData, uint* pcbData);

///<p class="CCE_Message">[This function is no longer supported.] Obtains specified information from the registry. This
///function will check HKEY_CURRENT_USER for the requested information in the specified subkey. If the information does
///not exist under the HKEY_CURRENT_USER subtree, the function checks the HKEY_LOCAL_MACHINE subtree for the same
///information.
///Params:
///    pwszKey = Type: <b>PCWSTR</b> A pointer to a <b>null</b>-terminated Unicode string that specifies the path to the registry
///              key.
///    pwszValue = Type: <b>PCWSTR</b> A pointer to a <b>null</b>-terminated Unicode string that specifies the key value. This value
///                can be <b>NULL</b>, in which case data is retrieved from the Default value.
///    srrfFlags = Type: <b>SRRF</b> The SRRF flag constants. If more than one flag is used they can be combined using a bitwise OR.
///                These flags are used to restrict the type of data returned. This value cannot be 0.
///    pdwType = Type: <b>DWORD*</b> When this function returns, contains a pointer to a <b>DWORD</b> which receives a code that
///              indicates the type of data stored in the specified value. This can be set to <b>NULL</b> if no type information
///              is wanted. If this value is not <b>NULL</b>, and the SRRF_NOEXPAND flag has not been set, data types of
///              REG_EXPAND_SZ will be returned as REG_SZ since they are automatically expanded in this method.
///    pvData = Type: <b>LPCVOID</b> A pointer to a buffer that contains the value's data. This parameter can be <b>NULL</b> if
///             the data is not needed. This value must contain the size of the <i>pvData</i> buffer on entry. If <i>pvData</i>
///             is <b>NULL</b> (or if <i>pvData</i> is not <b>NULL</b>, but too small of a buffer to hold the registry data),
///             then on exit it will contain the size required to hold the registry data.
///    pcbData = Type: <b>DWORD*</b> When this function returns, contains a pointer to the size of the data, in bytes.
@DllImport("SHLWAPI")
LSTATUS SHRegGetValueFromHKCUHKLM(const(wchar)* pwszKey, const(wchar)* pwszValue, int srrfFlags, uint* pdwType, 
                                  char* pvData, uint* pcbData);

///Opens a registry key and queries it for a specific value.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    pszValue = Type: <b>LPCTSTR</b> The address of the <b>null</b>-terminated string that contains the name of the value to be
///               queried.
///    pdwReserved = Type: <b>LPDWORD</b> Reserved. Must be <b>NULL</b>.
///    pdwType = Type: <b>LPDWORD</b> The address of the variable that receives the key's value type. For more information, see
///              Registry Data Types.
///    pvData = Type: <b>LPVOID</b> The address of the buffer that receives the value's data. This parameter can be <b>NULL</b>
///             if the data is not required.
///    pcbData = Type: <b>LPDWORD</b> The address of the variable that specifies the size, in bytes, of the buffer pointed to by
///              the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to
///              <i>pvData</i>.
///Returns:
///    Type: <b>DWORD</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise.
///    You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description
///    of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHQueryValueExA(HKEY hkey, const(char)* pszValue, uint* pdwReserved, uint* pdwType, char* pvData, 
                        uint* pcbData);

///Opens a registry key and queries it for a specific value.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    pszValue = Type: <b>LPCTSTR</b> The address of the <b>null</b>-terminated string that contains the name of the value to be
///               queried.
///    pdwReserved = Type: <b>LPDWORD</b> Reserved. Must be <b>NULL</b>.
///    pdwType = Type: <b>LPDWORD</b> The address of the variable that receives the key's value type. For more information, see
///              Registry Data Types.
///    pvData = Type: <b>LPVOID</b> The address of the buffer that receives the value's data. This parameter can be <b>NULL</b>
///             if the data is not required.
///    pcbData = Type: <b>LPDWORD</b> The address of the variable that specifies the size, in bytes, of the buffer pointed to by
///              the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to
///              <i>pvData</i>.
///Returns:
///    Type: <b>DWORD</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise.
///    You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description
///    of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHQueryValueExW(HKEY hkey, const(wchar)* pszValue, uint* pdwReserved, uint* pdwType, char* pvData, 
                        uint* pcbData);

///Enumerates the subkeys of the specified open registry key.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    dwIndex = Type: <b>DWORD</b> The index of the subkey to retrieve. This parameter should be zero for the first call and
///              incremented for subsequent calls.
///    pszName = Type: <b>LPTSTR</b> The address of a character buffer that receives the enumerated key name.
///    pcchName = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at
///               <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to
///               <i>pszName</i>.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHEnumKeyExA(HKEY hkey, uint dwIndex, const(char)* pszName, uint* pcchName);

///Enumerates the subkeys of the specified open registry key.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    dwIndex = Type: <b>DWORD</b> The index of the subkey to retrieve. This parameter should be zero for the first call and
///              incremented for subsequent calls.
///    pszName = Type: <b>LPTSTR</b> The address of a character buffer that receives the enumerated key name.
///    pcchName = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at
///               <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to
///               <i>pszName</i>.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHEnumKeyExW(HKEY hkey, uint dwIndex, const(wchar)* pszName, uint* pcchName);

///Enumerates the values of the specified open registry key.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    dwIndex = Type: <b>DWORD</b> The index of the value to retrieve. This parameter should be zero for the first call and
///              incremented for subsequent calls.
///    pszValueName = Type: <b>LPTSTR</b> The address of a character buffer that receives the enumerated value name. The size of this
///                   buffer is specified in <i>pcchValueName</i>.
///    pcchValueName = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at
///                    <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to
///                    <i>pszValueName</i>.
///    pdwType = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that receives the data type of the value. These are the same
///              values as those described under the <i>lpType</i> parameter of RegEnumValue.
///    pvData = Type: <b>LPVOID</b> The address of a buffer that receives the data for the value entry. The size of this buffer
///             is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.
///    pcbData = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at
///              <i>pvData</i>, in bytes. On exit, this contains the number of bytes that were copied to <i>pvData</i>.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHEnumValueA(HKEY hkey, uint dwIndex, const(char)* pszValueName, uint* pcchValueName, uint* pdwType, 
                     char* pvData, uint* pcbData);

///Enumerates the values of the specified open registry key.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    dwIndex = Type: <b>DWORD</b> The index of the value to retrieve. This parameter should be zero for the first call and
///              incremented for subsequent calls.
///    pszValueName = Type: <b>LPTSTR</b> The address of a character buffer that receives the enumerated value name. The size of this
///                   buffer is specified in <i>pcchValueName</i>.
///    pcchValueName = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at
///                    <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to
///                    <i>pszValueName</i>.
///    pdwType = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that receives the data type of the value. These are the same
///              values as those described under the <i>lpType</i> parameter of RegEnumValue.
///    pvData = Type: <b>LPVOID</b> The address of a buffer that receives the data for the value entry. The size of this buffer
///             is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.
///    pcbData = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at
///              <i>pvData</i>, in bytes. On exit, this contains the number of bytes that were copied to <i>pvData</i>.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHEnumValueW(HKEY hkey, uint dwIndex, const(wchar)* pszValueName, uint* pcchValueName, uint* pdwType, 
                     char* pvData, uint* pcbData);

///Retrieves information about a specified registry key.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    pcSubKeys = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that receives the number of subkeys under the specified key.
///    pcchMaxSubKeyLen = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that receives the number of characters in the name of the
///                       subkey with the largest name.
///    pcValues = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that receives the number of values under the specified key.
///    pcchMaxValueNameLen = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that receives the number of characters in the name of the
///                          value with the largest name.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHQueryInfoKeyA(HKEY hkey, uint* pcSubKeys, uint* pcchMaxSubKeyLen, uint* pcValues, 
                        uint* pcchMaxValueNameLen);

///Retrieves information about a specified registry key.
///Params:
///    hkey = Type: <b>HKEY</b> A handle to the currently open key, or any of the following predefined values.
///    pcSubKeys = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that receives the number of subkeys under the specified key.
///    pcchMaxSubKeyLen = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that receives the number of characters in the name of the
///                       subkey with the largest name.
///    pcValues = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that receives the number of values under the specified key.
///    pcchMaxValueNameLen = Type: <b>LPDWORD</b> The address of a <b>DWORD</b> that receives the number of characters in the name of the
///                          value with the largest name.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHQueryInfoKeyW(HKEY hkey, uint* pcSubKeys, uint* pcchMaxSubKeyLen, uint* pcValues, 
                        uint* pcchMaxValueNameLen);

///Recursively copies the subkeys and values of the source subkey to the destination key. <b>SHCopyKey</b> does not copy
///the security attributes of the keys.
///Params:
///    hkeySrc = Type: <b>HKEY</b> A handle to the source key (for example, <b>HKEY_CURRENT_USER</b>).
///    pszSrcSubKey = Type: <b>LPCTSTR</b> The subkey whose subkeys and values are to be copied.
///    hkeyDest = Type: <b>HKEY</b> The destination key.
///    fReserved = Type: <b>DWORD</b> Reserved. Must be 0.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h
///    otherwise. Use FormatMessage with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the
///    error.
///    
@DllImport("SHLWAPI")
LSTATUS SHCopyKeyA(HKEY hkeySrc, const(char)* pszSrcSubKey, HKEY hkeyDest, uint fReserved);

///Recursively copies the subkeys and values of the source subkey to the destination key. <b>SHCopyKey</b> does not copy
///the security attributes of the keys.
///Params:
///    hkeySrc = Type: <b>HKEY</b> A handle to the source key (for example, <b>HKEY_CURRENT_USER</b>).
///    pszSrcSubKey = Type: <b>LPCTSTR</b> The subkey whose subkeys and values are to be copied.
///    hkeyDest = Type: <b>HKEY</b> The destination key.
///    fReserved = Type: <b>DWORD</b> Reserved. Must be 0.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h
///    otherwise. Use FormatMessage with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the
///    error.
///    
@DllImport("SHLWAPI")
LSTATUS SHCopyKeyW(HKEY hkeySrc, const(wchar)* pszSrcSubKey, HKEY hkeyDest, uint fReserved);

///Retrieves a file path from the registry, expanding environment variables as needed.
///Params:
///    hKey = Type: <b>HKEY</b> A handle to a key that is currently open, or a registry root key.
///    pcszSubKey = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the name of the subkey.
///    pcszValue = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the name of the value that holds the
///                unexpanded path string.
///    pszPath = Type: <b>LPTSTR</b> A buffer to hold the expanded path. You should set the size of this buffer to <b>MAX_PATH</b>
///              to ensure that it is large enough to hold the returned string.
///    dwFlags = Type: <b>DWORD</b> Reserved.
///Returns:
///    Type: <b>LSTATUS</b> Returns <b>ERROR_SUCCESS</b> if successful, or a Windows error code otherwise.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegGetPathA(HKEY hKey, const(char)* pcszSubKey, const(char)* pcszValue, const(char)* pszPath, 
                      uint dwFlags);

///Retrieves a file path from the registry, expanding environment variables as needed.
///Params:
///    hKey = Type: <b>HKEY</b> A handle to a key that is currently open, or a registry root key.
///    pcszSubKey = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the name of the subkey.
///    pcszValue = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the name of the value that holds the
///                unexpanded path string.
///    pszPath = Type: <b>LPTSTR</b> A buffer to hold the expanded path. You should set the size of this buffer to <b>MAX_PATH</b>
///              to ensure that it is large enough to hold the returned string.
///    dwFlags = Type: <b>DWORD</b> Reserved.
///Returns:
///    Type: <b>LSTATUS</b> Returns <b>ERROR_SUCCESS</b> if successful, or a Windows error code otherwise.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegGetPathW(HKEY hKey, const(wchar)* pcszSubKey, const(wchar)* pcszValue, const(wchar)* pszPath, 
                      uint dwFlags);

///Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry.
///Params:
///    hKey = Type: <b>HKEY</b> A handle to a key that is currently open, or a registry root key.
///    pcszSubKey = Type: <b>LPCTSTR</b> A pointer to a null-terminated string containing the name of an existing subkey. If the
///                 subkey does not exist, <b>SHRegSetPath</b> will fail.
///    pcszValue = Type: <b>LPCTSTR</b> A pointer to a null-terminated string with the name of the value to hold the path string.
///    pcszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string with a fully qualified file path.
///    dwFlags = Type: <b>DWORD</b> Reserved.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a Windows error code otherwise.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegSetPathA(HKEY hKey, const(char)* pcszSubKey, const(char)* pcszValue, const(char)* pcszPath, 
                      uint dwFlags);

///Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry.
///Params:
///    hKey = Type: <b>HKEY</b> A handle to a key that is currently open, or a registry root key.
///    pcszSubKey = Type: <b>LPCTSTR</b> A pointer to a null-terminated string containing the name of an existing subkey. If the
///                 subkey does not exist, <b>SHRegSetPath</b> will fail.
///    pcszValue = Type: <b>LPCTSTR</b> A pointer to a null-terminated string with the name of the value to hold the path string.
///    pcszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string with a fully qualified file path.
///    dwFlags = Type: <b>DWORD</b> Reserved.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a Windows error code otherwise.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegSetPathW(HKEY hKey, const(wchar)* pcszSubKey, const(wchar)* pcszValue, const(wchar)* pcszPath, 
                      uint dwFlags);

///Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the subkey to be created or opened. If a
///              value with this name is already present in the subkey, it will be opened.
///    samDesired = Type: <b>REGSAM</b> The desired security access. For more information on security access, see REGSAM.
///    hRelativeUSKey = Type: <b>HUSKEY</b> The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the
///                     key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set
///                     <i>hRelativeUSKey</i> to <b>NULL</b>. The key will then be created under <b>HKEY_LOCAL_MACHINE</b> or
///                     <b>HKEY_CURRENT_USER</b>, depending the value of <i>dwFlags</i>.
///    phNewUSKey = Type: <b>PHUSKEY</b> A pointer to an <b>HUSKEY</b> that will receive the handle to the new key.
///    dwFlags = Type: <b>DWORD</b> The base key under which the key should be opened. This can be one or more of the following
///              values.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegCreateUSKeyA(const(char)* pszPath, uint samDesired, ptrdiff_t hRelativeUSKey, ptrdiff_t* phNewUSKey, 
                          uint dwFlags);

///Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    pwzPath = TBD
///    samDesired = Type: <b>REGSAM</b> The desired security access. For more information on security access, see REGSAM.
///    hRelativeUSKey = Type: <b>HUSKEY</b> The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the
///                     key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set
///                     <i>hRelativeUSKey</i> to <b>NULL</b>. The key will then be created under <b>HKEY_LOCAL_MACHINE</b> or
///                     <b>HKEY_CURRENT_USER</b>, depending the value of <i>dwFlags</i>.
///    phNewUSKey = Type: <b>PHUSKEY</b> A pointer to an <b>HUSKEY</b> that will receive the handle to the new key.
///    dwFlags = Type: <b>DWORD</b> The base key under which the key should be opened. This can be one or more of the following
///              values.
///    dwFlags = Create/open the key under both <b>HKEY_CURRENT_USER</b> (forced) and <b>HKEY_LOCAL_MACHINE</b> (only if empty).
///              This flag is the equivalent of (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).
///    dwFlags = Create/open the key under <b>HKEY_CURRENT_USER</b>. Creates a key even if it is not empty.
///    dwFlags = Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Creates a key even if it is not empty.
///    dwFlags = Create/open the key under <b>HKEY_CURRENT_USER</b>. Only creates a key if it is empty.
///    dwFlags = Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Only creates a key if it is empty.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegCreateUSKeyW(const(wchar)* pwzPath, uint samDesired, ptrdiff_t hRelativeUSKey, ptrdiff_t* phNewUSKey, 
                          uint dwFlags);

///Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    pszPath = Type: <b>LPCTSTR</b> A pointer to a null-terminated string with the name of the subkey.
///    samDesired = Type: <b>REGSAM</b> The desired security access. For more information on security access, see REGSAM.
///    hRelativeUSKey = Type: <b>HUSKEY</b> The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the
///                     key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set
///                     <i>hRelativeUSKey</i> to <b>NULL</b>.
///    phNewUSKey = Type: <b>PHUSKEY</b> A pointer to the handle of the opened key.
///    fIgnoreHKCU = Type: <b>BOOL</b> The variable that specifies which key to look under. When set to <b>TRUE</b>,
///                  <b>SHRegOpenUSKey</b> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegOpenUSKeyA(const(char)* pszPath, uint samDesired, ptrdiff_t hRelativeUSKey, ptrdiff_t* phNewUSKey, 
                        BOOL fIgnoreHKCU);

///Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    pwzPath = TBD
///    samDesired = Type: <b>REGSAM</b> The desired security access. For more information on security access, see REGSAM.
///    hRelativeUSKey = Type: <b>HUSKEY</b> The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the
///                     key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set
///                     <i>hRelativeUSKey</i> to <b>NULL</b>.
///    phNewUSKey = Type: <b>PHUSKEY</b> A pointer to the handle of the opened key.
///    fIgnoreHKCU = Type: <b>BOOL</b> The variable that specifies which key to look under. When set to <b>TRUE</b>,
///                  <b>SHRegOpenUSKey</b> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegOpenUSKeyW(const(wchar)* pwzPath, uint samDesired, ptrdiff_t hRelativeUSKey, ptrdiff_t* phNewUSKey, 
                        BOOL fIgnoreHKCU);

///Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree
///(HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    hUSKey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey, or one of the following predefined values. The
///             subkey must have been opened with the KEY_SET_VALUE access right. For more information, see Registry Key Security
///             and Access Rights. This handle can be obtained through the SHRegOpenUSKey function.
///    pszValue = Type: <b>LPCTSTR</b> A pointer to the <b>null</b>-terminated string that contains the name of the value to be
///               queried.
///    pdwType = Type: <b>LPDWORD*</b> A pointer to the variable that sets or receives the key's value type. For more information,
///              see Registry Data Types. This parameter can be <b>NULL</b>.
///    pvData = Type: <b>LPVOID*</b> A pointer to the buffer that receives the value's data. This parameter can be <b>NULL</b> if
///             the data is not required.
///    pcbData = Type: <b>LPDWORD*</b> A pointer to the variable that specifies the size, in bytes, of the buffer pointed to by
///              the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to
///              <i>pvData</i>.
///    fIgnoreHKCU = Type: <b>BOOL</b> The variable that specifies which key to look under. When set to <b>TRUE</b>,
///                  <b>SHRegQueryUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under
///                  <b>HKEY_LOCAL_MACHINE</b>.
///    pvDefaultData = Type: <b>LPVOID*</b> A pointer to the default data.
///    dwDefaultDataSize = Type: <b>DWORD</b> The length, in bytes, of the default data.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegQueryUSValueA(ptrdiff_t hUSKey, const(char)* pszValue, uint* pdwType, char* pvData, uint* pcbData, 
                           BOOL fIgnoreHKCU, char* pvDefaultData, uint dwDefaultDataSize);

///Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree
///(HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    hUSKey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey, or one of the following predefined values. The
///             subkey must have been opened with the KEY_SET_VALUE access right. For more information, see Registry Key Security
///             and Access Rights. This handle can be obtained through the SHRegOpenUSKey function.
///    pszValue = Type: <b>LPCTSTR</b> A pointer to the <b>null</b>-terminated string that contains the name of the value to be
///               queried.
///    pdwType = Type: <b>LPDWORD*</b> A pointer to the variable that sets or receives the key's value type. For more information,
///              see Registry Data Types. This parameter can be <b>NULL</b>.
///    pvData = Type: <b>LPVOID*</b> A pointer to the buffer that receives the value's data. This parameter can be <b>NULL</b> if
///             the data is not required.
///    pcbData = Type: <b>LPDWORD*</b> A pointer to the variable that specifies the size, in bytes, of the buffer pointed to by
///              the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to
///              <i>pvData</i>.
///    fIgnoreHKCU = Type: <b>BOOL</b> The variable that specifies which key to look under. When set to <b>TRUE</b>,
///                  <b>SHRegQueryUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under
///                  <b>HKEY_LOCAL_MACHINE</b>.
///    pvDefaultData = Type: <b>LPVOID*</b> A pointer to the default data.
///    dwDefaultDataSize = Type: <b>DWORD</b> The length, in bytes, of the default data.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegQueryUSValueW(ptrdiff_t hUSKey, const(wchar)* pszValue, uint* pdwType, char* pvData, uint* pcbData, 
                           BOOL fIgnoreHKCU, char* pvDefaultData, uint dwDefaultDataSize);

///Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    hUSKey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey. The subkey must have been opened with the
///             KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights. This handle can be
///             obtained through the SHRegOpenUSKey function.
///    pszValue = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that specifies the name of the value. This value is an
///               entry in the subkey specified by <i>hUSKey</i>. If a value with this name is not already present in the subkey,
///               it will be added. If this parameter is <b>NULL</b> or an empty string, the function sets the type and data for
///               the subkey's Default value.
///    dwType = Type: <b>DWORD</b> The type of the data to be stored in the value specified by <i>pszValue</i>. One of the
///             following registry value types defined in Winnt.h and Wdm.h.
///    pvData = Type: <b>const void*</b> A pointer to the data to be set for the value specified by <i>pszValue</i>. For
///             string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the
///             string must be terminated with two null characters. A backslash in a path must be preceded by another backslash
///             as an escape character. For example, specify "C:\\mydir\\myfile" to store the string "C:\mydir\myfile".
///    cbData = Type: <b>DWORD</b> The size, in bytes, of the data pointed to by the <i>pvData</i> parameter. If the data is of
///             type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, <i>cbData</i> must include the size of the terminating null
///             character or characters.
///    dwFlags = Type: <b>DWORD</b> Flags that indicate the subtree to which the data should be written. One or more of the
///              following values:
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h.
///    You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description
///    of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegWriteUSValueA(ptrdiff_t hUSKey, const(char)* pszValue, uint dwType, char* pvData, uint cbData, 
                           uint dwFlags);

///Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    hUSKey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey. The subkey must have been opened with the
///             KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights. This handle can be
///             obtained through the SHRegOpenUSKey function.
///    pwzValue = TBD
///    dwType = Type: <b>DWORD</b> The type of the data to be stored in the value specified by <i>pszValue</i>. One of the
///             following registry value types defined in Winnt.h and Wdm.h.
///    pvData = Type: <b>const void*</b> A pointer to the data to be set for the value specified by <i>pszValue</i>. For
///             string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the
///             string must be terminated with two null characters. A backslash in a path must be preceded by another backslash
///             as an escape character. For example, specify "C:\\mydir\\myfile" to store the string "C:\mydir\myfile".
///    cbData = Type: <b>DWORD</b> The size, in bytes, of the data pointed to by the <i>pvData</i> parameter. If the data is of
///             type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, <i>cbData</i> must include the size of the terminating null
///             character or characters.
///    dwFlags = Type: <b>DWORD</b> Flags that indicate the subtree to which the data should be written. One or more of the
///              following values:
///    dwFlags = Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).
///    dwFlags = Write to <b>HKEY_CURRENT_USER</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be
///              overwritten.
///    dwFlags = Write to <b>HKEY_LOCAL_MACHINE</b>. If a value of the name specified in <i>pszValue</i> already exists, it will
///              be overwritten.
///    dwFlags = Write to <b>HKEY_CURRENT_USER</b> only if a value of the name specified in <i>pszValue</i> does not currently
///              exist under the specified subkey.
///    dwFlags = Write to <b>HKEY_LOCAL_MACHINE</b> only if a value of the name specified in <i>pszValue</i> does not currently
///              exist under the specified subkey..
///    dwType = 
///    dwType = 
///    dwType = 
///    dwType = 
///    dwType = 
///    dwType = 
///    dwType = 
///    dwType = 
///    dwType = 
///    dwType = 
///    dwType = 
///    dwType = 
///    dwType = 
///    dwType = 
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h.
///    You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description
///    of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegWriteUSValueW(ptrdiff_t hUSKey, const(wchar)* pwzValue, uint dwType, char* pvData, uint cbData, 
                           uint dwFlags);

///Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    hUSKey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey. The subkey must have been opened with the
///             KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights. This handle can be
///             obtained through the SHRegOpenUSKey function.
///    pszValue = Type: <b>LPCTSTR</b> A pointer to the null-terminated string that names the value to remove.
///    delRegFlags = Type: <b>SHREGDEL_FLAGS</b> One of the SHREGDEL_FLAGS that specifies from which base key the value will be
///                  deleted.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegDeleteUSValueA(ptrdiff_t hUSKey, const(char)* pszValue, SHREGDEL_FLAGS delRegFlags);

///Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    hUSKey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey. The subkey must have been opened with the
///             KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights. This handle can be
///             obtained through the SHRegOpenUSKey function.
///    pwzValue = TBD
///    delRegFlags = Type: <b>SHREGDEL_FLAGS</b> One of the SHREGDEL_FLAGS that specifies from which base key the value will be
///                  deleted.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegDeleteUSValueW(ptrdiff_t hUSKey, const(wchar)* pwzValue, SHREGDEL_FLAGS delRegFlags);

///Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    hUSKey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey. The subkey must have been opened with the
///             KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights. This handle can be
///             obtained through the SHRegOpenUSKey function.
///    pwzSubKey = TBD
///    delRegFlags = Type: <b>SHREGDEL_FLAGS</b> One of the SHREGDEL_FLAGS that specifies from which base key the subkey will be
///                  deleted.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegDeleteEmptyUSKeyW(ptrdiff_t hUSKey, const(wchar)* pwzSubKey, SHREGDEL_FLAGS delRegFlags);

///Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    hUSKey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey. The subkey must have been opened with the
///             KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights. This handle can be
///             obtained through the SHRegOpenUSKey function.
///    pszSubKey = Type: <b>LPCSTR</b> A pointer to the null-terminated string that specifies the empty user-defined registry subkey
///                to be deleted.
///    delRegFlags = Type: <b>SHREGDEL_FLAGS</b> One of the SHREGDEL_FLAGS that specifies from which base key the subkey will be
///                  deleted.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegDeleteEmptyUSKeyA(ptrdiff_t hUSKey, const(char)* pszSubKey, SHREGDEL_FLAGS delRegFlags);

///Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    hUSKey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey. The subkey must have been opened with the
///             KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights. This handle can be
///             obtained through the SHRegOpenUSKey function.
///    dwIndex = Type: <b>DWORD</b> The index of the subkey to retrieve. This parameter should be zero for the first call and
///              incremented for subsequent calls.
///    pszName = Type: <b>LPTSTR</b> A pointer to a character buffer that receives the enumerated key name.
///    pcchName = Type: <b>LPDWORD</b> A pointer to a DWORD that, on entry, contains the size of the buffer at <i>pszName</i>, in
///               characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.
///    enumRegFlags = Type: <b>SHREGENUM_FLAGS</b> A SHREGENUM_FLAGS that specifies the base key in which the enumeration should take
///                   place.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegEnumUSKeyA(ptrdiff_t hUSKey, uint dwIndex, const(char)* pszName, uint* pcchName, 
                        SHREGENUM_FLAGS enumRegFlags);

///Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    hUSKey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey. The subkey must have been opened with the
///             KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights. This handle can be
///             obtained through the SHRegOpenUSKey function.
///    dwIndex = Type: <b>DWORD</b> The index of the subkey to retrieve. This parameter should be zero for the first call and
///              incremented for subsequent calls.
///    pwzName = TBD
///    pcchName = Type: <b>LPDWORD</b> A pointer to a DWORD that, on entry, contains the size of the buffer at <i>pszName</i>, in
///               characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.
///    enumRegFlags = Type: <b>SHREGENUM_FLAGS</b> A SHREGENUM_FLAGS that specifies the base key in which the enumeration should take
///                   place.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegEnumUSKeyW(ptrdiff_t hUSKey, uint dwIndex, const(wchar)* pwzName, uint* pcchName, 
                        SHREGENUM_FLAGS enumRegFlags);

///Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or
///HKEY_LOCAL_MACHINE).
///Params:
///    hUSkey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey. The subkey must have been opened with the
///             KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights. This handle can be
///             obtained through the SHRegOpenUSKey function.
///    dwIndex = Type: <b>DWORD</b> The index of the value to retrieve. This parameter should be zero for the first call and
///              incremented for subsequent calls.
///    pszValueName = Type: <b>LPTSTR</b> A pointer to a character buffer that receives the enumerated value name. The size of this
///                   buffer is specified in <i>pcchValueNameLen</i>.
///    pcchValueName = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at
///                    <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to
///                    <i>pszValueName</i>.
///    pdwType = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that receives the data type of the value. These are the same
///              values as those described under the <i>lpType</i> parameter of RegEnumValue.
///    pvData = Type: <b>void*</b> A pointer to a buffer that receives the data for the value entry. The size of this buffer is
///             specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.
///    pcbData = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at
///              <i>pvData</i>. On exit, this contains the number of bytes that were copied to <i>pvData</i>.
///    enumRegFlags = Type: <b>SHREGENUM_FLAGS</b> One of the SHREGENUM_FLAGS that specifies the base key in which the enumeration
///                   should take place.
///Returns:
///    Type: <b>LSTATUS</b> Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a
///    textual description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegEnumUSValueA(ptrdiff_t hUSkey, uint dwIndex, const(char)* pszValueName, uint* pcchValueName, 
                          uint* pdwType, char* pvData, uint* pcbData, SHREGENUM_FLAGS enumRegFlags);

///Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or
///HKEY_LOCAL_MACHINE).
///Params:
///    hUSkey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey. The subkey must have been opened with the
///             KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights. This handle can be
///             obtained through the SHRegOpenUSKey function.
///    dwIndex = Type: <b>DWORD</b> The index of the value to retrieve. This parameter should be zero for the first call and
///              incremented for subsequent calls.
///    pszValueName = Type: <b>LPTSTR</b> A pointer to a character buffer that receives the enumerated value name. The size of this
///                   buffer is specified in <i>pcchValueNameLen</i>.
///    pcchValueName = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at
///                    <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to
///                    <i>pszValueName</i>.
///    pdwType = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that receives the data type of the value. These are the same
///              values as those described under the <i>lpType</i> parameter of RegEnumValue.
///    pvData = Type: <b>void*</b> A pointer to a buffer that receives the data for the value entry. The size of this buffer is
///             specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.
///    pcbData = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at
///              <i>pvData</i>. On exit, this contains the number of bytes that were copied to <i>pvData</i>.
///    enumRegFlags = Type: <b>SHREGENUM_FLAGS</b> One of the SHREGENUM_FLAGS that specifies the base key in which the enumeration
///                   should take place.
///Returns:
///    Type: <b>LSTATUS</b> Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a
///    textual description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegEnumUSValueW(ptrdiff_t hUSkey, uint dwIndex, const(wchar)* pszValueName, uint* pcchValueName, 
                          uint* pdwType, char* pvData, uint* pcbData, SHREGENUM_FLAGS enumRegFlags);

///Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or
///HKEY_LOCAL_MACHINE).
///Params:
///    hUSKey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey. The subkey must have been opened with the
///             KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights. This handle can be
///             obtained through the SHRegOpenUSKey function.
///    pcSubKeys = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that receives the number of subkeys under the specified key.
///    pcchMaxSubKeyLen = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that receives the number of characters in the largest subkey
///                       name.
///    pcValues = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that receives the number of values under the specified key.
///    pcchMaxValueNameLen = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that receives the number of characters in the largest value
///                          name.
///    enumRegFlags = Type: <b>SHREGENUM_FLAGS</b> One of the SHREGENUM_FLAGS that specifies the base key in which the query should
///                   take place.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegQueryInfoUSKeyA(ptrdiff_t hUSKey, uint* pcSubKeys, uint* pcchMaxSubKeyLen, uint* pcValues, 
                             uint* pcchMaxValueNameLen, SHREGENUM_FLAGS enumRegFlags);

///Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or
///HKEY_LOCAL_MACHINE).
///Params:
///    hUSKey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey. The subkey must have been opened with the
///             KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights. This handle can be
///             obtained through the SHRegOpenUSKey function.
///    pcSubKeys = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that receives the number of subkeys under the specified key.
///    pcchMaxSubKeyLen = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that receives the number of characters in the largest subkey
///                       name.
///    pcValues = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that receives the number of values under the specified key.
///    pcchMaxValueNameLen = Type: <b>LPDWORD</b> A pointer to a <b>DWORD</b> that receives the number of characters in the largest value
///                          name.
///    enumRegFlags = Type: <b>SHREGENUM_FLAGS</b> One of the SHREGENUM_FLAGS that specifies the base key in which the query should
///                   take place.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegQueryInfoUSKeyW(ptrdiff_t hUSKey, uint* pcSubKeys, uint* pcchMaxSubKeyLen, uint* pcValues, 
                             uint* pcchMaxValueNameLen, SHREGENUM_FLAGS enumRegFlags);

///Closes a handle to a user-specific registry subkey in a user-specific subtree (HKEY_CURRENT_USER or
///HKEY_LOCAL_MACHINE).
///Params:
///    hUSKey = Type: <b>HUSKEY</b> A handle to a currently open registry subkey. The subkey must have been opened with the
///             KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights. This handle can be
///             obtained through the SHRegOpenUSKey function.
@DllImport("SHLWAPI")
LSTATUS SHRegCloseUSKey(ptrdiff_t hUSKey);

///Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    pszSubKey = Type: <b>LPCTSTR</b> A pointer to a null-terminated string with the name of the subkey relative to
///                <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example: "Software\MyCompany\MyProduct".
///    pszValue = Type: <b>LPCTSTR</b> A pointer to a null-terminated string with the name of the value. This value can be
///               <b>NULL</b>.
///    pdwType = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value.
///              When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see
///              Registry Data Types. If type information is not required, this parameter can be <b>NULL</b>.
///    pvData = Type: <b>void*</b> A pointer to a buffer that receives the value's data.
///    pcbData = Type: <b>DWORD*</b> A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by
///              <i>pvData</i>. When <b>SHRegGetUSValue</b> returns, <i>pcbData</i> contains the size of the data copied to
///              <i>pvData</i>.
///    fIgnoreHKCU = Type: <b>BOOL</b> A variable that specifies which key to look under. When set to <b>TRUE</b>,
///                  <b>SHRegGetUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under
///                  <b>HKEY_LOCAL_MACHINE</b>.
///    pvDefaultData = Type: <b>void*</b> A pointer to a buffer that receives the value's default data.
///    dwDefaultDataSize = Type: <b>DWORD</b> The length, in bytes, of the buffer pointed to by <i>pvDefaultData</i>.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegGetUSValueA(const(char)* pszSubKey, const(char)* pszValue, uint* pdwType, char* pvData, uint* pcbData, 
                         BOOL fIgnoreHKCU, char* pvDefaultData, uint dwDefaultDataSize);

///Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    pszSubKey = Type: <b>LPCTSTR</b> A pointer to a null-terminated string with the name of the subkey relative to
///                <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example: "Software\MyCompany\MyProduct".
///    pszValue = Type: <b>LPCTSTR</b> A pointer to a null-terminated string with the name of the value. This value can be
///               <b>NULL</b>.
///    pdwType = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value.
///              When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see
///              Registry Data Types. If type information is not required, this parameter can be <b>NULL</b>.
///    pvData = Type: <b>void*</b> A pointer to a buffer that receives the value's data.
///    pcbData = Type: <b>DWORD*</b> A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by
///              <i>pvData</i>. When <b>SHRegGetUSValue</b> returns, <i>pcbData</i> contains the size of the data copied to
///              <i>pvData</i>.
///    fIgnoreHKCU = Type: <b>BOOL</b> A variable that specifies which key to look under. When set to <b>TRUE</b>,
///                  <b>SHRegGetUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under
///                  <b>HKEY_LOCAL_MACHINE</b>.
///    pvDefaultData = Type: <b>void*</b> A pointer to a buffer that receives the value's default data.
///    dwDefaultDataSize = Type: <b>DWORD</b> The length, in bytes, of the buffer pointed to by <i>pvDefaultData</i>.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegGetUSValueW(const(wchar)* pszSubKey, const(wchar)* pszValue, uint* pdwType, char* pvData, 
                         uint* pcbData, BOOL fIgnoreHKCU, char* pvDefaultData, uint dwDefaultDataSize);

///Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    pszSubKey = Type: <b>LPCTSTR</b> A pointer to a null-terminated string with the name of the subkey.
///    pszValue = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that specifies the name of the value.
///    dwType = Type: <b>DWORD</b> Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more
///             information, see Registry Data Types.
///    pvData = Type: <b>LPVOID*</b> Apointer to a null-terminated string that contains the value to be set for the specified
///             key.
///    cbData = Type: <b>DWORD</b> Length, in bytes, of the string pointed to by the <i>pvData</i> parameter, not including the
///             terminating null character.
///    dwFlags = Type: <b>DWORD</b> Flags indicating where the data should be written.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegSetUSValueA(const(char)* pszSubKey, const(char)* pszValue, uint dwType, char* pvData, uint cbData, 
                         uint dwFlags);

///Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
///Params:
///    pwzSubKey = TBD
///    pwzValue = TBD
///    dwType = Type: <b>DWORD</b> Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more
///             information, see Registry Data Types.
///    pvData = Type: <b>LPVOID*</b> Apointer to a null-terminated string that contains the value to be set for the specified
///             key.
///    cbData = Type: <b>DWORD</b> Length, in bytes, of the string pointed to by the <i>pvData</i> parameter, not including the
///             terminating null character.
///    dwFlags = Type: <b>DWORD</b> Flags indicating where the data should be written.
///    dwFlags = Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).
///    dwFlags = Write to <b>HKEY_CURRENT_USER</b>.
///    dwFlags = Write to <b>HKEY_LOCAL_MACHINE</b>.
///    dwFlags = Write to <b>HKEY_CURRENT_USER</b> if empty.
///    dwFlags = Write to <b>HKEY_LOCAL_MACHINE</b> if empty.
///Returns:
///    Type: <b>LSTATUS</b> Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h
///    otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic
///    description of the error.
///    
@DllImport("SHLWAPI")
LSTATUS SHRegSetUSValueW(const(wchar)* pwzSubKey, const(wchar)* pwzValue, uint dwType, char* pvData, uint cbData, 
                         uint dwFlags);

///Reads a numeric string value from the registry and converts it to an integer.
///Params:
///    hk = Type: <b>HKEY</b> A handle to the registry key that specifies the value to be read.
///    pwzKey = Type: <b>LPCWSTR</b> A pointer to a string value that specifies the name of the value to be read. The string must
///             be null-terminated.
///    iDefault = Type: <b>int</b> An <b>int</b> that specifies the value returned if the registry value cannot be retrieved
///               successfully.
///Returns:
///    Type: <b>int</b> Returns the converted string as an <b>int</b>, or the default value specified by
///    <i>nDefault</i>.
///    
@DllImport("SHLWAPI")
int SHRegGetIntW(HKEY hk, const(wchar)* pwzKey, int iDefault);

///Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or
///HKEY_LOCAL_MACHINE).
///Params:
///    pszSubKey = Type: <b>LPCTSTR</b> A pointer to a null-terminated string with the name of the subkey relative to
///                <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example, "Software\MyCompany\MyProduct".
///    pszValue = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that specifies the name of the value. This value can
///               be <b>NULL</b>.
///    fIgnoreHKCU = Type: <b>BOOL</b> A variable that specifies which key to look under. When set to <b>TRUE</b>, SHRegGetUSValue
///                  ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.
///    fDefault = Type: <b>BOOL</b> A value that is returned if there is no registry value.
///Returns:
///    Type: <b>BOOL</b> Returns either the value from the registry, or <i>fDefault</i> if none is found.
///    
@DllImport("SHLWAPI")
BOOL SHRegGetBoolUSValueA(const(char)* pszSubKey, const(char)* pszValue, BOOL fIgnoreHKCU, BOOL fDefault);

///Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or
///HKEY_LOCAL_MACHINE).
///Params:
///    pszSubKey = Type: <b>LPCTSTR</b> A pointer to a null-terminated string with the name of the subkey relative to
///                <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example, "Software\MyCompany\MyProduct".
///    pszValue = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that specifies the name of the value. This value can
///               be <b>NULL</b>.
///    fIgnoreHKCU = Type: <b>BOOL</b> A variable that specifies which key to look under. When set to <b>TRUE</b>, SHRegGetUSValue
///                  ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.
///    fDefault = Type: <b>BOOL</b> A value that is returned if there is no registry value.
///Returns:
///    Type: <b>BOOL</b> Returns either the value from the registry, or <i>fDefault</i> if none is found.
///    
@DllImport("SHLWAPI")
BOOL SHRegGetBoolUSValueW(const(wchar)* pszSubKey, const(wchar)* pszValue, BOOL fIgnoreHKCU, BOOL fDefault);

///Returns a pointer to an IQueryAssociations object.
///Params:
///    clsid = Type: <b>CLSID</b> The CLSID of the object that exposes the interface. This parameter must be set to
///            CLSID_QueryAssociations, which is defined in Shlguid.h.
///    riid = Type: <b>REFIID</b> Reference to the IID IID_IQueryAssociations, which is defined in Shlguid.h.
///    ppv = Type: <b>void*</b> When this method returns, contains the IQueryAssociations interface pointer requested in
///          <i>riid</i>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT AssocCreate(GUID clsid, const(GUID)* riid, void** ppv);

///Searches for and retrieves a file or protocol association-related string from the registry.
///Params:
///    flags = Type: <b>ASSOCF</b> The flags that can be used to control the search. It can be any combination of ASSOCF values,
///            except that only one ASSOCF_INIT value can be included.
///    str = Type: <b>ASSOCSTR</b> The ASSOCSTR value that specifies the type of string that is to be returned.
///    pszAssoc = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that is used to determine the root key. The following
///               four types of strings can be used.
///    pszExtra = Type: <b>LPCTSTR</b> An optional null-terminated string with additional information about the location of the
///               string. It is typically set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not
///               used.
///    pszOut = Type: <b>LPTSTR</b> Pointer to a null-terminated string that, when this function returns successfully, receives
///             the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.
///    pcchOut = Type: <b>DWORD*</b> A pointer to a value that, when calling the function, is set to the number of characters in
///              the <i>pszOut</i> buffer. When the function returns successfully, the value is set to the number of characters
///              actually placed in the buffer. If the ASSOCF_NOTRUNCATE flag is set in <i>flags</i> and the buffer specified in
///              <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the
///              buffer. If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required
///              size, in characters, of the buffer.
///Returns:
///    Type: <b>HRESULT</b> Returns a standard COM error value, including the following: <table class="clsStd"> <tr>
///    <th>Error</th> <th>Meaning</th> </tr> <tr> <td>S_OK</td> <td>Success.</td> </tr> <tr> <td>E_POINTER</td> <td>The
///    <i>pszOut</i> buffer is too small to hold the entire string.</td> </tr> <tr> <td>S_FALSE</td> <td><i>pszOut</i>
///    is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</td> </tr> </table>
///    
@DllImport("SHLWAPI")
HRESULT AssocQueryStringA(uint flags, ASSOCSTR str, const(char)* pszAssoc, const(char)* pszExtra, 
                          const(char)* pszOut, uint* pcchOut);

///Searches for and retrieves a file or protocol association-related string from the registry.
///Params:
///    flags = Type: <b>ASSOCF</b> The flags that can be used to control the search. It can be any combination of ASSOCF values,
///            except that only one ASSOCF_INIT value can be included.
///    str = Type: <b>ASSOCSTR</b> The ASSOCSTR value that specifies the type of string that is to be returned.
///    pszAssoc = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that is used to determine the root key. The following
///               four types of strings can be used.
///    pszExtra = Type: <b>LPCTSTR</b> An optional null-terminated string with additional information about the location of the
///               string. It is typically set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not
///               used.
///    pszOut = Type: <b>LPTSTR</b> Pointer to a null-terminated string that, when this function returns successfully, receives
///             the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.
///    pcchOut = Type: <b>DWORD*</b> A pointer to a value that, when calling the function, is set to the number of characters in
///              the <i>pszOut</i> buffer. When the function returns successfully, the value is set to the number of characters
///              actually placed in the buffer. If the ASSOCF_NOTRUNCATE flag is set in <i>flags</i> and the buffer specified in
///              <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the
///              buffer. If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required
///              size, in characters, of the buffer.
///Returns:
///    Type: <b>HRESULT</b> Returns a standard COM error value, including the following: <table class="clsStd"> <tr>
///    <th>Error</th> <th>Meaning</th> </tr> <tr> <td>S_OK</td> <td>Success.</td> </tr> <tr> <td>E_POINTER</td> <td>The
///    <i>pszOut</i> buffer is too small to hold the entire string.</td> </tr> <tr> <td>S_FALSE</td> <td><i>pszOut</i>
///    is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</td> </tr> </table>
///    
@DllImport("SHLWAPI")
HRESULT AssocQueryStringW(uint flags, ASSOCSTR str, const(wchar)* pszAssoc, const(wchar)* pszExtra, 
                          const(wchar)* pszOut, uint* pcchOut);

///Searches for and retrieves a file association-related string from the registry starting from a specified key.
///Params:
///    flags = Type: <b>ASSOCF</b> The flags that can be used to control the search. It can be any combination of ASSOCF values,
///            except that only one ASSOCF_INIT value can be included.
///    str = Type: <b>ASSOCSTR</b> The ASSOCSTR value that specifies the type of string that is to be returned.
///    hkAssoc = Type: <b>HKEY</b> The HKEY value of the key that will be used as a root key. The search looks only below this
///              key.
///    pszExtra = Type: <b>LPCTSTR</b> A pointer to an optional null-terminated string with additional information about the
///               location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b>
///               if it is not used.
///    pszOut = Type: <b>LPTSTR</b> A pointer to a null-terminated string used to return the requested string. Set this parameter
///             to <b>NULL</b> to retrieve the required buffer size.
///    pcchOut = Type: <b>DWORD*</b> A pointer to a value that, on entry, specifies the number of characters in the <i>pszOut</i>
///              buffer. When the function returns, it points to the number of characters placed in the buffer. If the
///              ASSOCF_NOTRUNCATE flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the
///              function returns E_POINTER and the value is set to the required size of the buffer. If <i>pszOut</i> is
///              <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size of the buffer.
///Returns:
///    Type: <b>HRESULT</b> Returns a standard COM error value, including the following: <table class="clsStd"> <tr>
///    <th>Error</th> <th>Meaning</th> </tr> <tr> <td>S_OK</td> <td>Success.</td> </tr> <tr> <td>E_POINTER</td> <td>The
///    <i>pszOut</i> buffer is too small to hold the entire string.</td> </tr> <tr> <td>S_FALSE</td> <td><i>pszOut</i>
///    is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</td> </tr> </table>
///    
@DllImport("SHLWAPI")
HRESULT AssocQueryStringByKeyA(uint flags, ASSOCSTR str, HKEY hkAssoc, const(char)* pszExtra, const(char)* pszOut, 
                               uint* pcchOut);

///Searches for and retrieves a file association-related string from the registry starting from a specified key.
///Params:
///    flags = Type: <b>ASSOCF</b> The flags that can be used to control the search. It can be any combination of ASSOCF values,
///            except that only one ASSOCF_INIT value can be included.
///    str = Type: <b>ASSOCSTR</b> The ASSOCSTR value that specifies the type of string that is to be returned.
///    hkAssoc = Type: <b>HKEY</b> The HKEY value of the key that will be used as a root key. The search looks only below this
///              key.
///    pszExtra = Type: <b>LPCTSTR</b> A pointer to an optional null-terminated string with additional information about the
///               location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b>
///               if it is not used.
///    pszOut = Type: <b>LPTSTR</b> A pointer to a null-terminated string used to return the requested string. Set this parameter
///             to <b>NULL</b> to retrieve the required buffer size.
///    pcchOut = Type: <b>DWORD*</b> A pointer to a value that, on entry, specifies the number of characters in the <i>pszOut</i>
///              buffer. When the function returns, it points to the number of characters placed in the buffer. If the
///              ASSOCF_NOTRUNCATE flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the
///              function returns E_POINTER and the value is set to the required size of the buffer. If <i>pszOut</i> is
///              <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size of the buffer.
///Returns:
///    Type: <b>HRESULT</b> Returns a standard COM error value, including the following: <table class="clsStd"> <tr>
///    <th>Error</th> <th>Meaning</th> </tr> <tr> <td>S_OK</td> <td>Success.</td> </tr> <tr> <td>E_POINTER</td> <td>The
///    <i>pszOut</i> buffer is too small to hold the entire string.</td> </tr> <tr> <td>S_FALSE</td> <td><i>pszOut</i>
///    is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</td> </tr> </table>
///    
@DllImport("SHLWAPI")
HRESULT AssocQueryStringByKeyW(uint flags, ASSOCSTR str, HKEY hkAssoc, const(wchar)* pszExtra, 
                               const(wchar)* pszOut, uint* pcchOut);

///Searches for and retrieves a key related to a file or protocol association from the registry.
///Params:
///    flags = Type: <b>ASSOCF</b> The flags that can be used to control the search. It can be any combination of ASSOCF values,
///            except that only one ASSOCF_INIT value can be included.
///    key = Type: <b>ASSOCKEY</b> The ASSOCKEY value that specifies the type of key that is to be returned.
///    pszAssoc = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that is used to determine the root key. Four types of
///               strings can be used.
///    pszExtra = Type: <b>LPCTSTR</b> A pointer to an optional null-terminated string with additional information about the
///               location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b>
///               if it is not used.
///    phkeyOut = Type: <b>HKEY*</b> A pointer to the key's HKEY value.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
///    
@DllImport("SHLWAPI")
HRESULT AssocQueryKeyA(uint flags, ASSOCKEY key, const(char)* pszAssoc, const(char)* pszExtra, HKEY* phkeyOut);

///Searches for and retrieves a key related to a file or protocol association from the registry.
///Params:
///    flags = Type: <b>ASSOCF</b> The flags that can be used to control the search. It can be any combination of ASSOCF values,
///            except that only one ASSOCF_INIT value can be included.
///    key = Type: <b>ASSOCKEY</b> The ASSOCKEY value that specifies the type of key that is to be returned.
///    pszAssoc = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that is used to determine the root key. Four types of
///               strings can be used.
///    pszExtra = Type: <b>LPCTSTR</b> A pointer to an optional null-terminated string with additional information about the
///               location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b>
///               if it is not used.
///    phkeyOut = Type: <b>HKEY*</b> A pointer to the key's HKEY value.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
///    
@DllImport("SHLWAPI")
HRESULT AssocQueryKeyW(uint flags, ASSOCKEY key, const(wchar)* pszAssoc, const(wchar)* pszExtra, HKEY* phkeyOut);

///Determines whether a file type is considered a potential security risk.
///Params:
///    pszAssoc = Type: <b>PCWSTR</b> A pointer to a string that contains the type of file in question. This may be either an
///               extension such as ".exe" or a progid such as "exefile".
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the file type is considered dangerous; otherwise, <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL AssocIsDangerous(const(wchar)* pszAssoc);

///Retrieves a file's perceived type based on its extension.
///Params:
///    pszExt = Type: <b>PCWSTR</b> A pointer to a buffer that contains the file's extension. This should include the leading
///             period, for example ".txt".
///    ptype = Type: <b>PERCEIVED*</b> A pointer to a PERCEIVED value that indicates the perceived type.
///    pflag = Type: <b>PERCEIVEDFLAG*</b> A pointer to a value that indicates the source of the perceived type information. One
///            or more of the following values.
///    ppszType = Type: <b>PWSTR*</b> If the function returns a success code, this contains the address of a pointer to a buffer
///               that receives the perceived type string, for instance "text" or "video". This value can be <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT AssocGetPerceivedType(const(wchar)* pszExt, PERCEIVED* ptype, uint* pflag, ushort** ppszType);

///Deprecated. Opens a registry value and supplies a stream that can be used to read from or write to the value. <div
///class="alert"><b>Note</b> This function has been replaced by SHOpenRegStream2. It is recommended that you use
///<b>SHOpenRegStream2</b> at all times.</div><div> </div>
///Params:
///    hkey = Type: <b>HKEY</b> Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.
///    pszSubkey = Type: <b>LPCTSTR</b> Optional. Pointer to a null-terminated string that specifies the subkey that contains the
///                value. This value can be <b>NULL</b>.
///    pszValue = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the value to be accessed. This value can
///               be <b>NULL</b>.
///    grfMode = Type: <b>DWORD</b> The type of access for the stream. This can be one of the following values:
///Returns:
///    Type: <b>IStream*</b> Returns an IStream interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b>
///    value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, or an inability
///    to open the stream. <div class="alert"><b>Note</b> In some situations, such as when the subkey named by
///    <i>pszSubkey</i> does not exist or the caller does not have sufficient permissions to access the subkey, a
///    zero-length stream is returned rather than a <b>NULL</b> value. SHOpenRegStream2 returns <b>NULL</b> in all error
///    situations and is the preferred function for that reason.</div> <div> </div>
///    
@DllImport("SHLWAPI")
IStream SHOpenRegStreamA(HKEY hkey, const(char)* pszSubkey, const(char)* pszValue, uint grfMode);

///Deprecated. Opens a registry value and supplies a stream that can be used to read from or write to the value. <div
///class="alert"><b>Note</b> This function has been replaced by SHOpenRegStream2. It is recommended that you use
///<b>SHOpenRegStream2</b> at all times.</div><div> </div>
///Params:
///    hkey = Type: <b>HKEY</b> Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.
///    pszSubkey = Type: <b>LPCTSTR</b> Optional. Pointer to a null-terminated string that specifies the subkey that contains the
///                value. This value can be <b>NULL</b>.
///    pszValue = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the value to be accessed. This value can
///               be <b>NULL</b>.
///    grfMode = Type: <b>DWORD</b> The type of access for the stream. This can be one of the following values:
///Returns:
///    Type: <b>IStream*</b> Returns an IStream interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b>
///    value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, or an inability
///    to open the stream. <div class="alert"><b>Note</b> In some situations, such as when the subkey named by
///    <i>pszSubkey</i> does not exist or the caller does not have sufficient permissions to access the subkey, a
///    zero-length stream is returned rather than a <b>NULL</b> value. SHOpenRegStream2 returns <b>NULL</b> in all error
///    situations and is the preferred function for that reason.</div> <div> </div>
///    
@DllImport("SHLWAPI")
IStream SHOpenRegStreamW(HKEY hkey, const(wchar)* pszSubkey, const(wchar)* pszValue, uint grfMode);

///Opens a registry value and supplies a stream that can be used to read from or write to the value. This function
///supersedes SHOpenRegStream.
///Params:
///    hkey = Type: <b>HKEY</b> Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.
///    pszSubkey = Type: <b>LPCTSTR</b> Optional. Pointer to a null-terminated string that specifies the subkey that contains the
///                value. This value can be <b>NULL</b>.
///    pszValue = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the value to be accessed. This value can
///               be <b>NULL</b>.
///    grfMode = Type: <b>DWORD</b> The type of access for the stream. This can be one of the following values:
///Returns:
///    Type: <b>IStream*</b> Returns an IStream interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b>
///    value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, a subkey named
///    by <i>pszSubkey</i> that does not exist, a caller without sufficient permissions to access the subkey, or an
///    inability to open the stream.
///    
@DllImport("SHLWAPI")
IStream SHOpenRegStream2A(HKEY hkey, const(char)* pszSubkey, const(char)* pszValue, uint grfMode);

///Opens a registry value and supplies a stream that can be used to read from or write to the value. This function
///supersedes SHOpenRegStream.
///Params:
///    hkey = Type: <b>HKEY</b> Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.
///    pszSubkey = Type: <b>LPCTSTR</b> Optional. Pointer to a null-terminated string that specifies the subkey that contains the
///                value. This value can be <b>NULL</b>.
///    pszValue = Type: <b>LPCTSTR</b> Pointer to a null-terminated string that specifies the value to be accessed. This value can
///               be <b>NULL</b>.
///    grfMode = Type: <b>DWORD</b> The type of access for the stream. This can be one of the following values:
///Returns:
///    Type: <b>IStream*</b> Returns an IStream interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b>
///    value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, a subkey named
///    by <i>pszSubkey</i> that does not exist, a caller without sufficient permissions to access the subkey, or an
///    inability to open the stream.
///    
@DllImport("SHLWAPI")
IStream SHOpenRegStream2W(HKEY hkey, const(wchar)* pszSubkey, const(wchar)* pszValue, uint grfMode);

///<p class="CCE_Message">[<b>SHCreateStreamOnFile</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Instead, use SHCreateStreamOnFileEx.]
///Opens or creates a file and retrieves a stream to read or write to that file.
///Params:
///    pszFile = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that specifies the file name.
///    grfMode = Type: <b>DWORD</b> One or more STGM values that are used to specify the file access mode and how the object that
///              exposes the stream is created and deleted.
///    ppstm = Type: <b>IStream**</b> Receives an IStream interface pointer for the stream associated with the file.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT SHCreateStreamOnFileA(const(char)* pszFile, uint grfMode, IStream* ppstm);

///<p class="CCE_Message">[<b>SHCreateStreamOnFile</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Instead, use SHCreateStreamOnFileEx.]
///Opens or creates a file and retrieves a stream to read or write to that file.
///Params:
///    pszFile = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that specifies the file name.
///    grfMode = Type: <b>DWORD</b> One or more STGM values that are used to specify the file access mode and how the object that
///              exposes the stream is created and deleted.
///    ppstm = Type: <b>IStream**</b> Receives an IStream interface pointer for the stream associated with the file.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT SHCreateStreamOnFileW(const(wchar)* pszFile, uint grfMode, IStream* ppstm);

///Opens or creates a file and retrieves a stream to read or write to that file.
///Params:
///    pszFile = Type: <b>LPCWSTR</b> A pointer to a null-terminated string that specifies the file name.
///    grfMode = Type: <b>DWORD</b> One or more STGM values that are used to specify the file access mode and how the object that
///              exposes the stream is created and deleted.
///    dwAttributes = Type: <b>DWORD</b> One or more flag values that specify file attributes in the case that a new file is created.
///                   For a complete list of possible values, see the <i>dwFlagsAndAttributes</i> parameter of the CreateFile function.
///    fCreate = Type: <b>BOOL</b> A <b>BOOL</b> value that helps specify, in conjunction with <i>grfMode</i>, how existing files
///              should be treated when creating the stream. See Remarks for details.
///    pstmTemplate = Type: <b>IStream*</b> Reserved.
///    ppstm = Type: <b>IStream**</b> Receives an IStream interface pointer for the stream associated with the file.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT SHCreateStreamOnFileEx(const(wchar)* pszFile, uint grfMode, uint dwAttributes, BOOL fCreate, 
                               IStream pstmTemplate, IStream* ppstm);

///Creates a memory stream using a similar process to CreateStreamOnHGlobal.
///Params:
///    pInit = Type: <b>const BYTE*</b> A pointer to a buffer of size <i>cbInit</i>. The contents of this buffer are used to set
///            the initial contents of the memory stream. If this parameter is <b>NULL</b>, the returned memory stream does not
///            have any initial content.
///    cbInit = Type: <b>UINT</b> The number of bytes in the buffer pointed to by <i>pInit</i>. If <i>pInit</i> is set to
///             <b>NULL</b>, <i>cbInit</i> must be zero.
///Returns:
///    Type: <b>IStream*</b> On success, returns a pointer to the created memory stream. Returns <b>NULL</b> if the
///    stream object could not be allocated.
///    
@DllImport("SHLWAPI")
IStream SHCreateMemStream(char* pInit, uint cbInit);

///Retrieves a string used with websites when specifying language preferences.
///Params:
///    pszLanguages = Type: <b>LPTSTR</b> A pointer to a string that, when this function returns successfully, receives the language
///                   preferences information. We recommend that this buffer be of size 2048 characters to ensure sufficient space to
///                   return the full string. You can also call this function with this parameter set to NULL to retrieve the size of
///                   the string that will be returned.
///    pcchLanguages = Type: <b>DWORD*</b> A pointer to the size, in characters, of the string at <i>pszLanguages</i>. On entry, this
///                    value is the size of <i>pszLanguages</i>, including the terminating null character. On exit, it is the actual
///                    size of <i>pszLanguages</i>, not including the terminating null character.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT GetAcceptLanguagesA(const(char)* pszLanguages, uint* pcchLanguages);

///Retrieves a string used with websites when specifying language preferences.
///Params:
///    pszLanguages = Type: <b>LPTSTR</b> A pointer to a string that, when this function returns successfully, receives the language
///                   preferences information. We recommend that this buffer be of size 2048 characters to ensure sufficient space to
///                   return the full string. You can also call this function with this parameter set to NULL to retrieve the size of
///                   the string that will be returned.
///    pcchLanguages = Type: <b>DWORD*</b> A pointer to the size, in characters, of the string at <i>pszLanguages</i>. On entry, this
///                    value is the size of <i>pszLanguages</i>, including the terminating null character. On exit, it is the actual
///                    size of <i>pszLanguages</i>, not including the terminating null character.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT GetAcceptLanguagesW(const(wchar)* pszLanguages, uint* pcchLanguages);

///Changes the value of a Component Object Model (COM) interface pointer and releases the previous interface.
///Params:
///    ppunk = Type: <b>IUnknown**</b> The address of a COM interface pointer to receive the pointer assigned to <i>punk</i>. If
///            the previous value of the pointer is non-<b>NULL</b>, the function releases that interface by calling its
///            IUnkown::Release method.
///    punk = Type: <b>IUnknown*</b> The interface pointer to be copied to <i>ppunk</i>. If the value is non-<b>NULL</b>, the
///           function increments the interface's reference count.
@DllImport("SHLWAPI")
void IUnknown_Set(IUnknown* ppunk, IUnknown punk);

///Releases a Component Object Model (COM) pointer and sets it to <b>NULL</b>.
///Params:
///    ppunk = Type: <b>void**</b> The address of a pointer to a COM interface.
@DllImport("SHLWAPI")
void IUnknown_AtomicRelease(void** ppunk);

///Attempts to retrieve a window handle from a Component Object Model (COM) object by querying for various interfaces
///that have a <b>GetWindow</b> method.
///Params:
///    punk = Type: <b>IUnknown*</b> A pointer to the COM object from which this function will attempt to obtain a window
///           handle.
///    phwnd = Type: <b>HWND*</b> A pointer to a HWND that, when this function returns successfully, receives the window handle.
///            If a window handle was not obtained, this parameter is set to <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if a window handle was successfully returned, or a COM error code otherwise. If
///    no suitable interface was found, the function returns E_NOINTERFACE. Otherwise, the function returns the
///    <b>HRESULT</b> returned by the corresponding interface's <b>GetWindow</b> method.
///    
@DllImport("SHLWAPI")
HRESULT IUnknown_GetWindow(IUnknown punk, HWND* phwnd);

///Sets the specified object's site by calling its IObjectWithSite::SetSite method.
///Params:
///    punk = Type: <b>IUnknown*</b> A pointer to the IUnknown interface of the object whose site is to be changed.
///    punkSite = Type: <b>IUnknown*</b> A pointer to the IUnknown interface of the new site.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if the site was successfully set, or a COM error code otherwise.
///    
@DllImport("SHLWAPI")
HRESULT IUnknown_SetSite(IUnknown punk, IUnknown punkSite);

///Calls the specified object's IObjectWithSite::GetSite method.
///Params:
///    punk = Type: <b>IUnknown*</b> A pointer to the COM object whose IObjectWithSite::GetSite method is to be called.
///    riid = Type: <b>REFIID</b> The IID of the interface pointer that should be returned in <i>ppvSite</i>.
///    ppv = Type: <b>VOID**</b> The address of the pointer to receive the requested interface pointer. If the function call
///          is successful, <i>ppvSite</i> will contain the requested interface pointer. If no site is available or the
///          requested interface is not supported, <i>ppvSite</i> is set to <b>NULL</b> and the function returns a COM error
///          code.
///Returns:
///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if the site was successfully retrieved or a COM error code otherwise.
///    
@DllImport("SHLWAPI")
HRESULT IUnknown_GetSite(IUnknown punk, const(GUID)* riid, void** ppv);

///Retrieves an interface for a service from a specified object.
///Params:
///    punk = Type: <b>IUnknown*</b> A pointer to the IUnknown instance of the COM object that supports the service.
///    guidService = Type: <b>REFGUID</b> The service's unique identifier (SID).
///    riid = Type: <b>REFIID</b> The IID of the desired service interface.
///    ppvOut = Type: <b>void**</b> When this method returns, contains the interface pointer requested <i>riid</i>. If
///             successful, the calling application is responsible for calling IUnknown::Release using this value when the
///             service is no longer needed. In the case of failure, this value is <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful. Returns <b>E_FAIL</b> if the object does not support
///    IServiceProvider. Otherwise, the function returns the <b>HRESULT</b> returned by the object's QueryService
///    method.
///    
@DllImport("SHLWAPI")
HRESULT IUnknown_QueryService(IUnknown punk, const(GUID)* guidService, const(GUID)* riid, void** ppvOut);

///Reads bytes from a specified stream and returns a value that indicates whether all bytes were successfully read.
///Params:
///    pstm = Type: <b>IStream*</b> A pointer to the IStream interface of the stream from which to read.
///    pv = Type: <b>VOID*</b> A pointer to a buffer to receive the stream data from <i>pstm</i>. This buffer must be at
///         least <i>cb</i> bytes in size.
///    cb = Type: <b>ULONG</b> The number of bytes of data that the function should attempt to read from the input stream.
///Returns:
///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if the function successfully reads the specified number of bytes from
///    the stream, or a COM failure code otherwise. In particular, if the read attempt was successful but fewer than
///    <i>cb</i> bytes were read, the function returns <b>E_FAIL</b>.
///    
@DllImport("SHLWAPI")
HRESULT IStream_Read(IStream pstm, char* pv, uint cb);

///Writes data of unknown format from a buffer to a specified stream.
///Params:
///    pstm = Type: <b>IStream*</b> An IStream pointer that specifies the target stream.
///    pv = Type: <b>const void*</b> Pointer to a buffer that holds the data to send to the target stream. This buffer must
///         be at least <i>cb</i> bytes in size.
///    cb = Type: <b>ULONG</b> The number of bytes of data to write to the target stream.
@DllImport("SHLWAPI")
HRESULT IStream_Write(IStream pstm, char* pv, uint cb);

///Moves the seek position in a specified stream to the beginning of the stream.
///Params:
///    pstm = Type: <b>IStream*</b> A pointer to the IStream interface of the stream whose position is to be reset.
///Returns:
///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success or a COM failure code otherwise. See IStream::Seek for
///    further discussion of possible error codes.
///    
@DllImport("SHLWAPI")
HRESULT IStream_Reset(IStream pstm);

///Retrieves the size, in bytes, of a specified stream.
///Params:
///    pstm = Type: <b>IStream*</b> A pointer to the IStream interface of the stream whose size is to be determined.
///    pui = Type: <b>ULARGE_INTEGER*</b> A pointer to a ULARGE_INTEGER structure to receive the size of the stream.
///Returns:
///    Type: <b>HRESULT</b> Returns <b>S_OK</b> on success or a COM failure code otherwise. See IStream::Stat for
///    further discussion of possible error codes.
///    
@DllImport("SHLWAPI")
HRESULT IStream_Size(IStream pstm, ULARGE_INTEGER* pui);

///<p class="CCE_Message">[This function is available through Windows XP and Windows Server 2003. It might be altered or
///unavailable in subsequent versions of Windows.] Establishes or terminates a connection between a client's sink and a
///connection point container.
///Params:
///    punk = Type: <b>IUnknown*</b> A pointer to the IUnknown interface of the object to be connected to the connection point
///           container. If you set <i>fConnect</i> to <b>FALSE</b> to indicate that you are disconnecting the object, this
///           parameter is ignored and can be set to <b>NULL</b>.
///    riidEvent = Type: <b>REFIID</b> The IID of the interface on the connection point container whose connection point object is
///                being requested.
///    fConnect = Type: <b>BOOL</b> <b>TRUE</b> if a connection is being established; <b>FALSE</b> if a connection is being broken.
///    punkTarget = Type: <b>IUnknown*</b> A pointer to the connection point container's IUnknown interface.
///    pdwCookie = Type: <b>DWORD*</b> A connection token. If you set <i>fConnect</i> to <b>TRUE</b> to make a new connection, this
///                parameter receives a token that uniquely identifies the connection. If you set <i>fConnect</i> to <b>FALSE</b> to
///                break a connection, this parameter must point to the token that you received when you called
///                <b>ConnectToConnectionPoint</b> to establish the connection.
///    ppcpOut = Type: <b>IConnectionPoint**</b> A pointer to the connection point container's IConnectionPoint interface, if the
///              operation was successful. The calling application must release this pointer when it is no longer needed. If the
///              request is unsuccessful, the pointer receives <b>NULL</b>. This parameter is optional and can be <b>NULL</b>.
@DllImport("SHLWAPI")
HRESULT ConnectToConnectionPoint(IUnknown punk, const(GUID)* riidEvent, BOOL fConnect, IUnknown punkTarget, 
                                 uint* pdwCookie, IConnectionPoint* ppcpOut);

///Reads a pointer to an item identifier list (PIDL) from an IStream object into a PIDLIST_RELATIVE object.
///Params:
///    pstm = Type: <b>IStream*</b> A pointer to the IStream from which the PIDL is read.
///    ppidlOut = Type: <b>PIDLIST_RELATIVE*</b> A pointer to the resulting PIDL.
@DllImport("SHLWAPI")
HRESULT IStream_ReadPidl(IStream pstm, ITEMIDLIST** ppidlOut);

///Writes a pointer to an item identifier list (PIDL) from a PCUIDLIST_RELATIVE object into an IStream object.
///Params:
///    pstm = Type: <b>IStream*</b> A pointer to the IStream object in which to write.
///    pidlWrite = Type: <b>PCUIDLIST_RELATIVE</b> The source PIDL.
@DllImport("SHLWAPI")
HRESULT IStream_WritePidl(IStream pstm, ITEMIDLIST* pidlWrite);

///Reads from a stream and writes into a string.
///Params:
///    pstm = Type: <b>IStream*</b> A pointer to the stream from which to read.
///    ppsz = Type: <b>PWSTR*</b> A pointer to the null-terminated, Unicode string into which the stream is written.
@DllImport("SHLWAPI")
HRESULT IStream_ReadStr(IStream pstm, ushort** ppsz);

///Reads from a string and writes into a stream.
///Params:
///    pstm = Type: <b>IStream*</b> A pointer to the stream in which to write.
///    psz = Type: <b>PCWSTR</b> A pointer to a null-terminated, Unicode string from which to read.
@DllImport("SHLWAPI")
HRESULT IStream_WriteStr(IStream pstm, const(wchar)* psz);

///Copies a stream to another stream.
///Params:
///    pstmFrom = Type: <b>IStream*</b> A pointer to the source stream.
///    pstmTo = Type: <b>IStream*</b> A pointer to the destination stream.
///    cb = Type: <b>DWORD</b> The number of bytes to copy from the source stream.
@DllImport("SHLWAPI")
HRESULT IStream_Copy(IStream pstmFrom, IStream pstmTo, uint cb);

///<p class="CCE_Message">[<b>SHGetViewStatePropertyBag</b> is available for use in the operating systems specified in
///the Requirements section. It may be altered or unavailable in subsequent versions.] Retrieves a property bag in which
///the view state information for a folder can be stored and subsequently retrieved. The user's settings are kept for
///the next time the user visits the folder.
///Params:
///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL of the folder for which you are requesting properties. This parameter must
///           be <b>NULL</b> if the SHGVSPB_ALLFOLDERS flag is passed.
///    pszBagName = Type: <b>PCWSTR</b> A pointer to a string that contains the name of the requested property bag.
///    dwFlags = Type: <b>DWORD</b> A value that specifies a combination of the following flags. One value from the following set
///              of flags is required.
///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>.
///    ppv = Type: <b>void**</b> When this method returns successfully, contains the interface pointer requested in
///          <i>riid</i>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT SHGetViewStatePropertyBag(ITEMIDLIST* pidl, const(wchar)* pszBagName, uint dwFlags, const(GUID)* riid, 
                                  void** ppv);

///<p class="CCE_Message">[<b>SHFormatDateTime</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Produces a string representation of a
///time specified as a FILETIME structure.
///Params:
///    pft = Type: <b>const FILETIME UNALIGNED*</b> A pointer to the FILETIME structure whose time is to be converted to a
///          string.
///    pdwFlags = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> value that contains bitwise flags that specify the date and time
///               format. When you call the function, you can combine zero or more of the following flags, with exceptions as
///               noted. You can also set this parameter to <b>NULL</b>, in which case the function assumes that the FDTF_DEFAULT
///               flag is set.
///    pszBuf = Type: <b>LPTSTR</b> A pointer to a buffer that receives the formatted date and time. The buffer must be large
///             enough to contain the number of TCHAR characters specified by the <i>cchBuf</i> parameter, including a
///             terminating null character.
///    cchBuf = Type: <b>UINT</b> The number of TCHARs that can be contained by the buffer pointed to by <i>pszBuf</i>.
///Returns:
///    Type: <b>int</b> Returns the number of TCHARs written to the buffer, including the terminating null character. On
///    failure, this value is 0.
///    
@DllImport("SHLWAPI")
int SHFormatDateTimeA(const(FILETIME)* pft, uint* pdwFlags, const(char)* pszBuf, uint cchBuf);

///<p class="CCE_Message">[<b>SHFormatDateTime</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Produces a string representation of a
///time specified as a FILETIME structure.
///Params:
///    pft = Type: <b>const FILETIME UNALIGNED*</b> A pointer to the FILETIME structure whose time is to be converted to a
///          string.
///    pdwFlags = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> value that contains bitwise flags that specify the date and time
///               format. When you call the function, you can combine zero or more of the following flags, with exceptions as
///               noted. You can also set this parameter to <b>NULL</b>, in which case the function assumes that the FDTF_DEFAULT
///               flag is set.
///    pszBuf = Type: <b>LPTSTR</b> A pointer to a buffer that receives the formatted date and time. The buffer must be large
///             enough to contain the number of TCHAR characters specified by the <i>cchBuf</i> parameter, including a
///             terminating null character.
///    cchBuf = Type: <b>UINT</b> The number of TCHARs that can be contained by the buffer pointed to by <i>pszBuf</i>.
///Returns:
///    Type: <b>int</b> Returns the number of TCHARs written to the buffer, including the terminating null character. On
///    failure, this value is 0.
///    
@DllImport("SHLWAPI")
int SHFormatDateTimeW(const(FILETIME)* pft, uint* pdwFlags, const(wchar)* pszBuf, uint cchBuf);

///<p class="CCE_Message">[This function is available through Windows XP and Windows Server 2003. It might be altered or
///unavailable in subsequent versions of Windows.] Converts a string from the ANSI code page to the Unicode code page.
///Params:
///    pszSrc = Type: <b>PCSTR</b> A pointer to a null-terminated ANSI string to be converted to Unicode.
///    pwszDst = Type: <b>PWSTR</b> A pointer to a buffer that, when this function returns successfully, receives the string
///              specified by <i>pszSrc</i>, after the ANSI characters have been converted to Unicode (WCHAR). The buffer must be
///              large enough to contain the number of Unicode characters specified by the <i>cwchBuf</i> parameter, including a
///              terminating null character.
///    cwchBuf = Type: <b>int</b> The number of Unicode characters that can be contained by the buffer pointed to by
///              <i>pwszDst</i>. This parameter must be greater than zero.
///Returns:
///    Type: <b>int</b> Returns the number of Unicode characters written to <i>pwszDst</i>, including the terminating
///    null character. Returns 0 if unsuccessful.
///    
@DllImport("SHLWAPI")
int SHAnsiToUnicode(const(char)* pszSrc, const(wchar)* pwszDst, int cwchBuf);

///<p class="CCE_Message">[This function is available through Windows XP and Windows Server 2003. It might be altered or
///unavailable in subsequent versions of Windows.] Copies an ANSI string.
///Params:
///    pszSrc = Type: <b>LPCSTR</b> A pointer to a null-terminated ANSI string to be converted to Unicode.
///    pszDst = Type: <b>LPWSTR</b> A pointer to a buffer that, when this function returns successfully, receives the characters
///             copied from <i>pszSrc</i>. The buffer must be large enough to contain the number of characters specified by the
///             <i>cchBuf</i> parameter, including a room for a terminating null character.
///    cchBuf = Type: <b>int</b> The number of characters that can be contained by the buffer pointed to by <i>pszDst</i>. This
///             parameter must be greater than zero.
///Returns:
///    Type: <b>int</b> Returns the number of characters written to <i>pszDst</i>, including the terminating null
///    character. Returns 0 if unsuccessful.
///    
@DllImport("SHLWAPI")
int SHAnsiToAnsi(const(char)* pszSrc, const(char)* pszDst, int cchBuf);

///<p class="CCE_Message">[This function is available through Windows XP and Windows Server 2003. It might be altered or
///unavailable in subsequent versions of Windows.] Converts a string from the Unicode code page to the ANSI code page.
///Params:
///    pwszSrc = Type: <b>PCWSTR</b> A pointer to the null-terminated Unicode string to be converted to ANSI.
///    pszDst = Type: <b>PSTR</b> A pointer to a buffer that, when this function returns successfully, receives the converted
///             characters. The buffer must be large enough to contain the number of <b>CHAR</b> characters specified by the
///             <i>cchBuf</i> parameter, including room for a terminating null character.
///    cchBuf = Type: <b>int</b> The number of <b>CHAR</b> values that can be contained by the buffer pointed to by
///             <i>pszDst</i>. The value assigned to parameter must be greater than zero.
///Returns:
///    Type: <b>int</b> Returns the number of <b>CHAR</b> values written to the output buffer, including the terminating
///    null character. Returns 0 if unsuccessful.
///    
@DllImport("SHLWAPI")
int SHUnicodeToAnsi(const(wchar)* pwszSrc, const(char)* pszDst, int cchBuf);

///<p class="CCE_Message">[This function is available through Windows XP and Windows Server 2003. It might be altered or
///unavailable in subsequent versions of Windows.] Copies a Unicode string.
///Params:
///    pwzSrc = Type: <b>PCWSTR</b> A pointer to a null-terminated Unicode string to be copied to the output buffer.
///    pwzDst = Type: <b>PWSTR</b> A pointer to an output buffer to receive the copied characters. The buffer must be large
///             enough to contain the number of <b>WCHAR</b> characters specified by <i>cwchBuf</i>, including room for a
///             terminating null character.
///    cwchBuf = Type: <b>int</b> The number of <b>WCHAR</b> characters that can be contained by the buffer pointed to by
///              <i>pwzDst</i> parameter. This parameter must be greater than zero.
///Returns:
///    Type: <b>int</b> Returns the number of <b>WCHAR</b> characters written to the output buffer, including the
///    terminating null character. Returns 0 if unsuccessful.
///    
@DllImport("SHLWAPI")
int SHUnicodeToUnicode(const(wchar)* pwzSrc, const(wchar)* pwzDst, int cwchBuf);

///<p class="CCE_Message">[<b>SHMessageBoxCheck</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Displays a message box that gives the
///user the option of suppressing further occurrences. If the user has already opted to suppress the message box, the
///function does not display a dialog box and instead simply returns the default value.
///Params:
///    hwnd = Type: <b>HWND</b> The window handle to the message box's owner. This value can be <b>NULL</b>.
///    pszText = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the message to be displayed.
///    pszCaption = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the title of the message box. If this
///                 parameter is set to <b>NULL</b>, the title is set to <b>Error!</b>.
///    uType = Type: <b>UINT</b> The flags that specify the contents and behavior of the message box. This function supports
///            only a subset of the flags supported by MessageBox. If you use any flags that are not listed below, the
///            function's behavior is undefined. You must specify the buttons to be displayed by setting one and only one of the
///            following flags.
///    iDefault = Type: <b>int</b> The value that the function returns when the user has opted not to have the message box
///               displayed again. If the user has not opted to suppress the message box, the message box is displayed and the
///               function ignores <i>iDefault</i>.
///    pszRegVal = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains a unique string value to associate with
///                this message. To avoid collisions with values used by Microsoft, this string should include a GUID. This string
///                must not exceed REGSTR_MAX_VALUE_LENGTH characters in length, including the terminating null character.
///Returns:
///    Type: <b>int</b> If the user has already chosen to suppress the message box, the function immediately returns the
///    value assigned to <i>iDefault</i>. If the user clicks the <b>OK</b>, <b>Cancel</b>, <b>Yes</b>, or <b>No</b>
///    button, the function returns IDOK, IDCANCEL, IDYES, or IDNO, respectively. If the user closes the message box by
///    clicking the <b>X</b> button in the caption, the function returns IDCANCEL. This value is returned in this case
///    even if the MB_OKCANCEL flag has not been set. If an error occurs, the return value is normally –1. However,
///    under certain low-memory conditions, the function might return <i>iDefault</i>.
///    
@DllImport("SHLWAPI")
int SHMessageBoxCheckA(HWND hwnd, const(char)* pszText, const(char)* pszCaption, uint uType, int iDefault, 
                       const(char)* pszRegVal);

///<p class="CCE_Message">[<b>SHMessageBoxCheck</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Displays a message box that gives the
///user the option of suppressing further occurrences. If the user has already opted to suppress the message box, the
///function does not display a dialog box and instead simply returns the default value.
///Params:
///    hwnd = Type: <b>HWND</b> The window handle to the message box's owner. This value can be <b>NULL</b>.
///    pszText = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the message to be displayed.
///    pszCaption = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains the title of the message box. If this
///                 parameter is set to <b>NULL</b>, the title is set to <b>Error!</b>.
///    uType = Type: <b>UINT</b> The flags that specify the contents and behavior of the message box. This function supports
///            only a subset of the flags supported by MessageBox. If you use any flags that are not listed below, the
///            function's behavior is undefined. You must specify the buttons to be displayed by setting one and only one of the
///            following flags.
///    iDefault = Type: <b>int</b> The value that the function returns when the user has opted not to have the message box
///               displayed again. If the user has not opted to suppress the message box, the message box is displayed and the
///               function ignores <i>iDefault</i>.
///    pszRegVal = Type: <b>LPCTSTR</b> A pointer to a null-terminated string that contains a unique string value to associate with
///                this message. To avoid collisions with values used by Microsoft, this string should include a GUID. This string
///                must not exceed REGSTR_MAX_VALUE_LENGTH characters in length, including the terminating null character.
///Returns:
///    Type: <b>int</b> If the user has already chosen to suppress the message box, the function immediately returns the
///    value assigned to <i>iDefault</i>. If the user clicks the <b>OK</b>, <b>Cancel</b>, <b>Yes</b>, or <b>No</b>
///    button, the function returns IDOK, IDCANCEL, IDYES, or IDNO, respectively. If the user closes the message box by
///    clicking the <b>X</b> button in the caption, the function returns IDCANCEL. This value is returned in this case
///    even if the MB_OKCANCEL flag has not been set. If an error occurs, the return value is normally –1. However,
///    under certain low-memory conditions, the function might return <i>iDefault</i>.
///    
@DllImport("SHLWAPI")
int SHMessageBoxCheckW(HWND hwnd, const(wchar)* pszText, const(wchar)* pszCaption, uint uType, int iDefault, 
                       const(wchar)* pszRegVal);

///<p class="CCE_Message">[This function is available through Windows XP and Windows Server 2003. It might be altered or
///unavailable in subsequent versions of Windows.] Sends a message to all top-level windows in the system.
///Params:
///    uMsg = Type: <b>UINT</b> The message to send.
///    wParam = Type: <b>WPARAM</b> Additional message-specific information.
///    lParam = Type: <b>LPARAM</b> Additional message-specific information.
///Returns:
///    Type: <b>LRESULT</b> The return value is not meaningful.
///    
@DllImport("SHLWAPI")
LRESULT SHSendMessageBroadcastA(uint uMsg, WPARAM wParam, LPARAM lParam);

///<p class="CCE_Message">[This function is available through Windows XP and Windows Server 2003. It might be altered or
///unavailable in subsequent versions of Windows.] Sends a message to all top-level windows in the system.
///Params:
///    uMsg = Type: <b>UINT</b> The message to send.
///    wParam = Type: <b>WPARAM</b> Additional message-specific information.
///    lParam = Type: <b>LPARAM</b> Additional message-specific information.
///Returns:
///    Type: <b>LRESULT</b> The return value is not meaningful.
///    
@DllImport("SHLWAPI")
LRESULT SHSendMessageBroadcastW(uint uMsg, WPARAM wParam, LPARAM lParam);

///<p class="CCE_Message">[This function is available through Windows XP and Windows Server 2003. It might be altered or
///unavailable in subsequent versions of Windows.] Removes the mnemonic marker from a string.
///Params:
///    pszMenu = Type: <b>LPTSTR*</b> A pointer to the null-terminated string that contains the mnemonic marker.
///Returns:
///    Type: <b>TCHAR</b> Returns the mnemonic character, if one was found. Otherwise, returns 0.
///    
@DllImport("SHLWAPI")
byte SHStripMneumonicA(const(char)* pszMenu);

///<p class="CCE_Message">[This function is available through Windows XP and Windows Server 2003. It might be altered or
///unavailable in subsequent versions of Windows.] Removes the mnemonic marker from a string.
///Params:
///    pszMenu = Type: <b>LPTSTR*</b> A pointer to the null-terminated string that contains the mnemonic marker.
///Returns:
///    Type: <b>TCHAR</b> Returns the mnemonic character, if one was found. Otherwise, returns 0.
///    
@DllImport("SHLWAPI")
ushort SHStripMneumonicW(const(wchar)* pszMenu);

///Checks for specified operating systems and operating system features.
///Params:
///    dwOS = Type: <b>DWORD</b> A value that specifies which operating system or operating system feature to check for. One of
///           the following values (you cannot combine values). <table class="clsStd"> <tr> <th>Name</th> <th>Value</th>
///           <th>Description</th> </tr> <tr> <td>OS_WINDOWS</td> <td>0</td> <td>The program is running on one of the following
///           versions of Windows: <ul> <li>Windows 95</li> <li>Windows 98</li> <li>Windows Me</li> </ul> Equivalent to
///           VER_PLATFORM_WIN32_WINDOWS. Note that none of those systems are supported at this time. <b>OS_WINDOWS</b> returns
///           <b>FALSE</b> on all supported systems. </td> </tr> <tr> <td>OS_NT</td> <td>1</td> <td>Always returns
///           <b>TRUE</b>.</td> </tr> <tr> <td>OS_WIN95ORGREATER</td> <td>2</td> <td>Always returns <b>FALSE</b>.</td> </tr>
///           <tr> <td>OS_NT4ORGREATER</td> <td>3</td> <td>Always returns <b>FALSE</b>.</td> </tr> <tr>
///           <td>OS_WIN98ORGREATER</td> <td>5</td> <td>Always returns <b>FALSE</b>.</td> </tr> <tr> <td>OS_WIN98_GOLD</td>
///           <td>6</td> <td>Always returns <b>FALSE</b>.</td> </tr> <tr> <td>OS_WIN2000ORGREATER</td> <td>7</td> <td>The
///           program is running on Windows 2000 or one of its successors.</td> </tr> <tr> <td>OS_WIN2000PRO</td> <td>8</td>
///           <td>Do not use; use OS_PROFESSIONAL.</td> </tr> <tr> <td>OS_WIN2000SERVER</td> <td>9</td> <td>Do not use; use
///           OS_SERVER.</td> </tr> <tr> <td>OS_WIN2000ADVSERVER</td> <td>10</td> <td>Do not use; use OS_ADVSERVER.</td> </tr>
///           <tr> <td>OS_WIN2000DATACENTER</td> <td>11</td> <td>Do not use; use OS_DATACENTER.</td> </tr> <tr>
///           <td>OS_WIN2000TERMINAL</td> <td>12</td> <td>The program is running on Windows 2000 Terminal Server in either
///           Remote Administration mode or Application Server mode, or Windows Server 2003 (or one of its successors) in
///           Terminal Server mode or Remote Desktop for Administration mode. Consider using a more specific value such as
///           OS_TERMINALSERVER, OS_TERMINALREMOTEADMIN, or OS_PERSONALTERMINALSERVER.</td> </tr> <tr> <td>OS_EMBEDDED</td>
///           <td>13</td> <td>The program is running on Windows Embedded, any version. Equivalent to VER_SUITE_EMBEDDEDNT.</td>
///           </tr> <tr> <td>OS_TERMINALCLIENT</td> <td>14</td> <td>The program is running as a Terminal Server client.
///           Equivalent to GetSystemMetrics(SM_REMOTESESSION).</td> </tr> <tr> <td>OS_TERMINALREMOTEADMIN</td> <td>15</td>
///           <td>The program is running on Windows 2000 Terminal Server in the Remote Administration mode or Windows Server
///           2003 (or one of its successors) in the Remote Desktop for Administration mode (these are the default installation
///           modes). This is equivalent to VER_SUITE_TERMINAL &amp;&amp; VER_SUITE_SINGLEUSERTS.</td> </tr> <tr>
///           <td>OS_WIN95_GOLD</td> <td>16</td> <td>Always returns <b>FALSE</b>.</td> </tr> <tr> <td>OS_MEORGREATER</td>
///           <td>17</td> <td>Always returns <b>FALSE</b>.</td> </tr> <tr> <td>OS_XPORGREATER</td> <td>18</td> <td>Always
///           returns <b>FALSE</b>.</td> </tr> <tr> <td>OS_HOME</td> <td>19</td> <td>Always returns <b>FALSE</b>.</td> </tr>
///           <tr> <td>OS_PROFESSIONAL</td> <td>20</td> <td>The program is running on Windows NT Workstation or Windows 2000
///           (or one of its successors) Professional. Equivalent to VER_PLATFORM_WIN32_NT &amp;&amp; VER_NT_WORKSTATION.</td>
///           </tr> <tr> <td>OS_DATACENTER</td> <td>21</td> <td>The program is running on Windows Datacenter Server or Windows
///           Server Datacenter Edition, any version. Equivalent to (VER_NT_SERVER || VER_NT_DOMAIN_CONTROLLER) &amp;&amp;
///           VER_SUITE_DATACENTER.</td> </tr> <tr> <td>OS_ADVSERVER</td> <td>22</td> <td>The program is running on Windows
///           Advanced Server or Windows Server Enterprise Edition, any version. Equivalent to (VER_NT_SERVER ||
///           VER_NT_DOMAIN_CONTROLLER) &amp;&amp; VER_SUITE_ENTERPRISE &amp;&amp; !VER_SUITE_DATACENTER.</td> </tr> <tr>
///           <td>OS_SERVER</td> <td>23</td> <td>The program is running on Windows Server (Standard) or Windows Server Standard
///           Edition, any version. This value will not return <b>true</b> for VER_SUITE_DATACENTER, VER_SUITE_ENTERPRISE,
///           VER_SUITE_SMALLBUSINESS, or VER_SUITE_SMALLBUSINESS_RESTRICTED.</td> </tr> <tr> <td>OS_TERMINALSERVER</td>
///           <td>24</td> <td>The program is running on Windows 2000 Terminal Server in Application Server mode, or on Windows
///           Server 2003 (or one of its successors) in Terminal Server mode. This is equivalent to VER_SUITE_TERMINAL
///           &amp;&amp; VER_SUITE_SINGLEUSERTS.</td> </tr> <tr> <td>OS_PERSONALTERMINALSERVER</td> <td>25</td> <td>The program
///           is running on Windows XP (or one of its successors), Home Edition or Professional. This is equivalent to
///           VER_SUITE_SINGLEUSERTS &amp;&amp; !VER_SUITE_TERMINAL.</td> </tr> <tr> <td>OS_FASTUSERSWITCHING</td> <td>26</td>
///           <td>Fast user switching is enabled.</td> </tr> <tr> <td>OS_WELCOMELOGONUI</td> <td>27</td> <td>Always returns
///           <b>FALSE</b>.</td> </tr> <tr> <td>OS_DOMAINMEMBER</td> <td>28</td> <td>The computer is joined to a domain.</td>
///           </tr> <tr> <td>OS_ANYSERVER</td> <td>29</td> <td>The program is running on any Windows Server product. Equivalent
///           to VER_NT_SERVER || VER_NT_DOMAIN_CONTROLLER.</td> </tr> <tr> <td>OS_WOW6432</td> <td>30</td> <td>The program is
///           a 32-bit program running on 64-bit Windows.</td> </tr> <tr> <td>OS_WEBSERVER</td> <td>31</td> <td>Always returns
///           <b>FALSE</b>.</td> </tr> <tr> <td>OS_SMALLBUSINESSSERVER</td> <td>32</td> <td>The program is running on Microsoft
///           Small Business Server with restrictive client license in force. Equivalent to
///           VER_SUITE_SMALLBUSINESS_RESTRICTED.</td> </tr> <tr> <td>OS_TABLETPC</td> <td>33</td> <td>The program is running
///           on Windows XP Tablet PC Edition, or one of its successors.</td> </tr> <tr> <td>OS_SERVERADMINUI</td> <td>34</td>
///           <td>The user should be presented with administrator UI. It is possible to have server administrative UI on a
///           non-server machine. This value informs the application that an administrator's profile has roamed to a
///           non-server, and UI should be appropriate to an administrator. Otherwise, the user is shown a mix of administrator
///           and nonadministrator settings.</td> </tr> <tr> <td>OS_MEDIACENTER</td> <td>35</td> <td>The program is running on
///           Windows XP Media Center Edition, or one of its successors. Equivalent to GetSystemMetrics(SM_MEDIACENTER).</td>
///           </tr> <tr> <td>OS_APPLIANCE</td> <td>36</td> <td>The program is running on Windows Appliance Server.</td> </tr>
///           </table>
///Returns:
///    Type: <b>BOOL</b> Returns a nonzero value if the specified operating system or operating system feature is
///    detected, otherwise <b>FALSE</b>.
///    
@DllImport("SHLWAPI")
BOOL IsOS(uint dwOS);

///Gets the current value of a global counter.
///Params:
///    id = Type: <b>const SHGLOBALCOUNTER</b> The SHGLOBALCOUNTER for which to retrieve the current value.
///Returns:
///    Type: <b>long</b> The current value of the counter.
///    
@DllImport("SHLWAPI")
int SHGlobalCounterGetValue(const(SHGLOBALCOUNTER) id);

///Increments a global counter.
///Params:
///    id = Type: <b>const SHGLOBALCOUNTER</b> The SHGLOBALCOUNTER to increment.
///Returns:
///    Type: <b>long</b> The value of the counter after the increment.
///    
@DllImport("SHLWAPI")
int SHGlobalCounterIncrement(const(SHGLOBALCOUNTER) id);

///Decrements a global counter.
///Params:
///    id = Type: <b>const SHGLOBALCOUNTER</b> The SHGLOBALCOUNTER to decrement.
///Returns:
///    Type: <b>long</b> The value of the counter after the decrement.
///    
@DllImport("SHLWAPI")
int SHGlobalCounterDecrement(const(SHGLOBALCOUNTER) id);

///<p class="CCE_Message">[<b>SHAllocShared</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Allocates a handle in a specified
///process to a copy of a specified memory block in the calling process.
///Params:
///    pvData = Type: <b>const void*</b> A pointer to the memory block in the calling process that is to be copied. You can set
///             this parameter to <b>NULL</b> if you want to share a block of memory without copying any data to it.
///    dwSize = Type: <b>DWORD</b> The size, in bytes, of the memory block pointed to by <i>pvData</i>.
///    dwProcessId = Type: <b>DWORD</b> The process ID of the process that will share memory block specified by <i>pvData</i>.
///Returns:
///    Type: <b>HANDLE</b> Returns a handle to the shared memory for the process specified by
///    <i>dwDestinationProcessId</i>. Returns <b>NULL</b> if unsuccessful.
///    
@DllImport("SHLWAPI")
HANDLE SHAllocShared(char* pvData, uint dwSize, uint dwProcessId);

///<p class="CCE_Message">[<b>SHFreeShared</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Frees shared memory, regardless of
///which process allocated it.
///Params:
///    hData = Type: <b>HANDLE</b> A handle to the mapped memory.
///    dwProcessId = Type: <b>DWORD</b> The process ID of the process from which the memory was allocated.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information,
///    call GetLastError.
///    
@DllImport("SHLWAPI")
BOOL SHFreeShared(HANDLE hData, uint dwProcessId);

///<p class="CCE_Message">[<b>SHLockShared</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Maps a block of memory from a
///specified process into the calling process.
///Params:
///    hData = Type: <b>HANDLE</b> A handle to the memory you want to map into the calling process.
///    dwProcessId = Type: <b>DWORD</b> The process ID of the process from which you want to map the block of memory.
///Returns:
///    Returns a void pointer to the shared memory. Returns <b>NULL</b> if unsuccessful.
///    
@DllImport("SHLWAPI")
void* SHLockShared(HANDLE hData, uint dwProcessId);

///<p class="CCE_Message">[<b>SHUnlockShared</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Unlocks memory locked by
///SHLockShared.
///Params:
///    pvData = Type: <b>void*</b> A pointer to the shared memory block returned by SHLockShared.
///Returns:
///    Type: <b>BOOL</b> If the function succeeds, the return value is <b>TRUE</b> and all modified pages within the
///    specified range are written to the disk with low priority. If the function fails, the return value is
///    <b>FALSE</b>. To get extended error information, call GetLastError.
///    
@DllImport("SHLWAPI")
BOOL SHUnlockShared(char* pvData);

///<p class="CCE_Message">[<b>WhichPlatform</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Retrieves a value that indicates the
///type of Shell32.dll that the platform contains.
///Returns:
///    Type: <b>UINT</b> <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>PLATFORM_UNKNOWN</b></dt> </dl> </td> <td width="60%"> The function was unable to determine the
///    Shell32.dll version. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>PLATFORM_IE3</b></dt> </dl> </td> <td
///    width="60%"> Obsolete: Use PLATFORM_BROWSERONLY. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>PLATFORM_BROWSERONLY</b></dt> </dl> </td> <td width="60%"> The Shell32.dll version is browser-only, with
///    no new shell. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>PLATFORM_INTEGRATED</b></dt> </dl> </td> <td
///    width="60%"> The platform contains an integrated shell. </td> </tr> </table>
///    
@DllImport("SHLWAPI")
uint WhichPlatform();

///A table-driven implementation of the IUnknown::QueryInterface method.
///Params:
///    that = Type: <b>void*</b> A pointer to the base of a COM object.
///    pqit = Type: <b>LPCQITAB</b> An array of QITAB structures. The last structure in the array must have its <b>piid</b>
///           member set to <b>NULL</b> and its <b>dwOffset</b> member set to 0.
///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>.
///    ppv = Type: <b>void**</b> When this method returns successfully, contains the interface pointer requested in
///          <i>riid</i>.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if the requested interface was found in the table or if the requested interface
///    was IUnknown. Returns E_NOINTERFACE if the requested interface was not found.
///    
@DllImport("SHLWAPI")
HRESULT QISearch(void* that, QITAB* pqit, const(GUID)* riid, void** ppv);

///Not supported.
///Params:
///    dwType = Type: <b>DWORD</b> The type of machine being examined. The following is the only recognized value.
@DllImport("SHLWAPI")
BOOL SHIsLowMemoryMachine(uint dwType);

///<p class="CCE_Message">[<b>GetMenuPosFromID</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Determines the position of an item in
///a menu. Used in the case where the item's ID is known.
///Params:
///    hmenu = Type: <b>HMENU</b> The handle of the menu.
///    id = Type: <b>UINT</b> An application-defined 16-bit value that identifies the menu item.
///Returns:
///    Type: <b>int</b> The item's zero-based position in the menu.
///    
@DllImport("SHLWAPI")
int GetMenuPosFromID(HMENU hmenu, uint id);

///<p class="CCE_Message">[This function is available through Windows XP and Windows Server 2003. It might be altered or
///unavailable in subsequent versions of Windows.] Retrieves the inverse color table mapping for the halftone palette.
///Params:
///    pbMap = Type: <b>BYTE*</b> A pointer to an array of <b>BYTE</b><b>s</b> that receives the inverse color table mapping, or
///            a pointer to an <b>LPBYTE</b> which receives a pointer to a cached copy of the inverse color table mapping,
///            depending on the value of the <i>cbMap</i> parameter.
///    cbMap = Type: <b>ULONG</b> The size of the buffer pointed to by <i>pbMap</i>, which also defines its contents. Two values
///            are recognized.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT SHGetInverseCMAP(char* pbMap, uint cbMap);

///Instructs system edit controls to use AutoComplete to help complete URLs or file system paths.
///Params:
///    hwndEdit = Type: <b>HWND</b> The window handle of a system edit control. Typically, this parameter is the handle of an edit
///               control or the edit control embedded in a ComboBoxEx control.
///    dwFlags = Type: <b>DWORD</b> The flags to control the operation of <b>SHAutoComplete</b>. The first four flags are used to
///              override the Internet Explorer registry settings. The user can change these settings manually by launching the
///              <b>Internet Options</b> property sheet from the <b>Tools</b> menu and clicking the <b>Advanced</b> tab.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT SHAutoComplete(HWND hwndEdit, uint dwFlags);

///Creates a per-thread reference to a Component Object Model (COM) object.
///Params:
///    pcRef = Type: <b>LONG*</b> A pointer to a value, usually a local variable in the thread's ThreadProc, that is used by the
///            interface in <i>ppunk</i> as a reference counter.
///    ppunk = Type: <b>IUnknown**</b> The address of a pointer to an IUnknown interface. If successful, this parameter holds
///            the thread's <b>IUnknown</b> pointer on return. Your application is responsible for freeing the pointer when it
///            is finished.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT SHCreateThreadRef(int* pcRef, IUnknown* ppunk);

///Stores a per-thread reference to a Component Object Model (COM) object. This allows the caller to control the
///thread's lifetime so that it can ensure that Windows won't shut down the thread before the caller is ready.
///Params:
///    punk = Type: <b>IUnknown*</b> A pointer to the IUnknown of the object for which you want to store a reference. This
///           value can be <b>NULL</b>.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT SHSetThreadRef(IUnknown punk);

///Retrieves the per-thread object reference set by SHSetThreadRef.
///Params:
///    ppunk = Type: <b>IUnknown**</b> The address of a pointer that, when this function returns successfully, points to the
///            object whose reference is stored. Your application is responsible for freeing this resource when it is no longer
///            needed.
///Returns:
///    Type: <b>HRESULT</b> Returns S_OK if the object reference exists, or <b>E_NOINTERFACE</b> otherwise.
///    
@DllImport("SHLWAPI")
HRESULT SHGetThreadRef(IUnknown* ppunk);

///Checks a bind context to see if it is safe to bind to a particular component object.
///Params:
///    pbc = Type: <b>IBindCtx*</b> A pointer to an IBindCtx interface that specifies the bind context you want to check. This
///          value can be <b>NULL</b>.
///    pclsid = Type: <b>const CLSID*</b> A pointer to a variable that specifies the <b>CLSID</b> of the object being tested to
///             see if it must be skipped. Typically, this is the CLSID of the object that IShellFolder::BindToObject is about to
///             create.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the object specified by <i>pclsid</i> must be skipped, or <b>FALSE</b>
///    otherwise.
///    
@DllImport("SHLWAPI")
BOOL SHSkipJunction(IBindCtx pbc, const(GUID)* pclsid);

///Creates a thread.
///Params:
///    pfnThreadProc = Type: <b>LPTHREAD_START_ROUTINE</b> A pointer to an application-defined function of the LPTHREAD_START_ROUTINE
///                    type. If a new thread was successfully created, this application-defined function is called in the context of
///                    that thread. <b>SHCreateThread</b> does not wait for the function pointed to by this parameter to complete before
///                    returning to its caller. The application-defined function's return value is the exit code of the thread.
///    pData = Type: <b>void*</b> A pointer to an optional application-defined data structure that contains initialization data.
///            It is passed to the function pointed to by <i>pfnThreadProc</i> and, optionally, <i>pfnCallback</i>. This value
///            can be <b>NULL</b>.
///    flags = Type: <b>SHCT_FLAGS</b> The flags that control the behavior of the function. One or more of the CTF constants.
///    pfnCallback = Type: <b>LPTHREAD_START_ROUTINE</b> A pointer to an optional application-defined function of the
///                  LPTHREAD_START_ROUTINE type. This function is called in the context of the created thread before the function
///                  pointed to by <i>pfnThreadProc</i> is called. It will also receive <i>pData</i> as its argument.
///                  <b>SHCreateThread</b> will wait for the function pointed to by <i>pfnCallback</i> to return before returning to
///                  its caller. The return value of the function pointed to by <i>pfnCallback</i> is ignored.
///Returns:
///    Type: <b>BOOL</b> Returns <b>TRUE</b> if the thread is successfully created, or <b>FALSE</b> otherwise. On
///    failure, use GetLastError to retrieve the specific error value as shown here. ``` if (!SHCreateThread(...)) { hr
///    = HRESULT_FROM_WIN32( GetLastError() ); } else { .... } ```
///    
@DllImport("SHLWAPI")
BOOL SHCreateThread(LPTHREAD_START_ROUTINE pfnThreadProc, void* pData, uint flags, 
                    LPTHREAD_START_ROUTINE pfnCallback);

///Creates a new thread and retrieves its handle.
///Params:
///    pfnThreadProc = Type: <b>LPTHREAD_START_ROUTINE</b> A pointer to an application-defined function of type LPTHREAD_START_ROUTINE.
///                    If a new thread was successfully created, this application-defined function is called in the context of that
///                    thread. <b>SHCreateThreadWithHandle</b> does not wait for the function pointed to by <i>pfnThreadProc</i> to
///                    complete before returning to its caller. The return value for the function specified by <i>pfnThreadProc</i> is
///                    the exit code of the thread.
///    pData = Type: <b>void*</b> A pointer to an optional application-defined data structure that contains initialization data.
///            It is passed to the function pointed to by <i>pfnThreadProc</i> and, optionally, the function pointed to by
///            <i>pfnCallback</i>.
///    flags = Type: <b>SHCT_FLAGS</b> Flags that control the behavior of the function; one or more of the CTF constants.
///    pfnCallback = Type: <b>LPTHREAD_START_ROUTINE</b> A pointer to an optional application-defined function of type
///                  LPTHREAD_START_ROUTINE. This function is called in the context of the created thread before the function pointed
///                  to by <i>pfnThreadProc</i> is called. It will also receive <i>pData</i> as its argument.
///                  <b>SHCreateThreadWithHandle</b> waits for the function pointed to by <i>pfnCallback</i> to complete before
///                  returning to its caller. The return value for the function specified by <i>pfnCallback</i> is ignored.
///    pHandle = Type: <b>HANDLE*</b> A pointer to the <b>HANDLE</b> of the created thread. When it is no longer needed, this
///              handle should be closed by calling the CloseHandle function. This value can be <b>NULL</b>.
///Returns:
///    Type: <b>BOOL</b> <b>TRUE</b> if the thread is successfully created; otherwise, <b>FALSE</b>
///    
@DllImport("SHLWAPI")
BOOL SHCreateThreadWithHandle(LPTHREAD_START_ROUTINE pfnThreadProc, void* pData, uint flags, 
                              LPTHREAD_START_ROUTINE pfnCallback, HANDLE* pHandle);

///Releases a thread reference before the thread procedure returns.
///Returns:
///    Type: <b>HRESULT</b> If this function succeeds, it returns <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("SHLWAPI")
HRESULT SHReleaseThreadRef();

///Creates a halftone palette for the specified device context.
///Params:
///    hdc = Type: <b>HDC</b> The device context.
///Returns:
///    Type: <b>HPALETTE</b> Returns the palette if successful; otherwise 0.
///    
@DllImport("SHLWAPI")
HPALETTE SHCreateShellPalette(HDC hdc);

///Converts colors from RGB to hue-luminance-saturation (HLS) format.
///Params:
///    clrRGB = Type: <b>COLORREF</b> The original RGB color.
///    pwHue = Type: <b>WORD*</b> A pointer to a value that, when this method returns successfully, receives the HLS hue value.
///    pwLuminance = Type: <b>WORD*</b> A pointer to a value that, when this method returns successfully, receives the HLS luminance
///                  value.
@DllImport("SHLWAPI")
void ColorRGBToHLS(uint clrRGB, ushort* pwHue, ushort* pwLuminance, ushort* pwSaturation);

///Converts colors from hue-luminance-saturation (HLS) to RGB format.
///Params:
///    wHue = Type: <b>WORD</b> The original HLS hue value.
///    wLuminance = Type: <b>WORD</b> The original HLS luminance value.
///    wSaturation = Type: <b>WORD</b> The original HLS saturation value.
@DllImport("SHLWAPI")
uint ColorHLSToRGB(ushort wHue, ushort wLuminance, ushort wSaturation);

///Changes the luminance of a RGB value. Hue and saturation are not affected.
///Params:
///    clrRGB = Type: <b>COLORREF</b> The initial RGB value.
///    n = Type: <b>int</b> The luminance in units of 0.1 percent of the total range. For example, a value of <i>n</i> = 50
///        corresponds to 5 percent of the maximum luminance.
///    fScale = Type: <b>BOOL</b> If <i>fScale</i> is set to <b>TRUE</b>, <i>n</i> specifies how much to increment or decrement
///             the current luminance. If <i>fScale</i> is set to <b>FALSE</b>, <i>n</i> specifies the absolute luminance.
///Returns:
///    Type: <b>COLORREF</b> Returns the modified RGB value.
///    
@DllImport("SHLWAPI")
uint ColorAdjustLuma(uint clrRGB, int n, BOOL fScale);

///Determines whether Windows Internet Explorer is in the Enhanced Security Configuration.
@DllImport("SHLWAPI")
BOOL IsInternetESCEnabled();

@DllImport("hlink")
HRESULT HlinkCreateFromMoniker(IMoniker pimkTrgt, const(wchar)* pwzLocation, const(wchar)* pwzFriendlyName, 
                               IHlinkSite pihlsite, uint dwSiteData, IUnknown piunkOuter, const(GUID)* riid, 
                               void** ppvObj);

@DllImport("hlink")
HRESULT HlinkCreateFromString(const(wchar)* pwzTarget, const(wchar)* pwzLocation, const(wchar)* pwzFriendlyName, 
                              IHlinkSite pihlsite, uint dwSiteData, IUnknown piunkOuter, const(GUID)* riid, 
                              void** ppvObj);

@DllImport("hlink")
HRESULT HlinkCreateFromData(IDataObject piDataObj, IHlinkSite pihlsite, uint dwSiteData, IUnknown piunkOuter, 
                            const(GUID)* riid, void** ppvObj);

@DllImport("hlink")
HRESULT HlinkQueryCreateFromData(IDataObject piDataObj);

@DllImport("hlink")
HRESULT HlinkClone(IHlink pihl, const(GUID)* riid, IHlinkSite pihlsiteForClone, uint dwSiteData, void** ppvObj);

@DllImport("hlink")
HRESULT HlinkCreateBrowseContext(IUnknown piunkOuter, const(GUID)* riid, void** ppvObj);

@DllImport("hlink")
HRESULT HlinkNavigateToStringReference(const(wchar)* pwzTarget, const(wchar)* pwzLocation, IHlinkSite pihlsite, 
                                       uint dwSiteData, IHlinkFrame pihlframe, uint grfHLNF, IBindCtx pibc, 
                                       IBindStatusCallback pibsc, IHlinkBrowseContext pihlbc);

@DllImport("hlink")
HRESULT HlinkNavigate(IHlink pihl, IHlinkFrame pihlframe, uint grfHLNF, IBindCtx pbc, IBindStatusCallback pibsc, 
                      IHlinkBrowseContext pihlbc);

@DllImport("hlink")
HRESULT HlinkOnNavigate(IHlinkFrame pihlframe, IHlinkBrowseContext pihlbc, uint grfHLNF, IMoniker pimkTarget, 
                        const(wchar)* pwzLocation, const(wchar)* pwzFriendlyName, uint* puHLID);

@DllImport("hlink")
HRESULT HlinkUpdateStackItem(IHlinkFrame pihlframe, IHlinkBrowseContext pihlbc, uint uHLID, IMoniker pimkTrgt, 
                             const(wchar)* pwzLocation, const(wchar)* pwzFriendlyName);

@DllImport("hlink")
HRESULT HlinkOnRenameDocument(uint dwReserved, IHlinkBrowseContext pihlbc, IMoniker pimkOld, IMoniker pimkNew);

@DllImport("hlink")
HRESULT HlinkResolveMonikerForData(IMoniker pimkReference, uint reserved, IBindCtx pibc, uint cFmtetc, 
                                   FORMATETC* rgFmtetc, IBindStatusCallback pibsc, IMoniker pimkBase);

@DllImport("hlink")
HRESULT HlinkResolveStringForData(const(wchar)* pwzReference, uint reserved, IBindCtx pibc, uint cFmtetc, 
                                  FORMATETC* rgFmtetc, IBindStatusCallback pibsc, IMoniker pimkBase);

@DllImport("hlink")
HRESULT HlinkParseDisplayName(IBindCtx pibc, const(wchar)* pwzDisplayName, BOOL fNoForceAbs, uint* pcchEaten, 
                              IMoniker* ppimk);

@DllImport("hlink")
HRESULT HlinkCreateExtensionServices(const(wchar)* pwzAdditionalHeaders, HWND phwnd, const(wchar)* pszUsername, 
                                     const(wchar)* pszPassword, IUnknown piunkOuter, const(GUID)* riid, 
                                     void** ppvObj);

@DllImport("hlink")
HRESULT HlinkPreprocessMoniker(IBindCtx pibc, IMoniker pimkIn, IMoniker* ppimkOut);

@DllImport("hlink")
HRESULT OleSaveToStreamEx(IUnknown piunk, IStream pistm, BOOL fClearDirty);

@DllImport("hlink")
HRESULT HlinkSetSpecialReference(uint uReference, const(wchar)* pwzReference);

@DllImport("hlink")
HRESULT HlinkGetSpecialReference(uint uReference, ushort** ppwzReference);

@DllImport("hlink")
HRESULT HlinkCreateShortcut(uint grfHLSHORTCUTF, IHlink pihl, const(wchar)* pwzDir, const(wchar)* pwzFileName, 
                            ushort** ppwzShortcutFile, uint dwReserved);

@DllImport("hlink")
HRESULT HlinkCreateShortcutFromMoniker(uint grfHLSHORTCUTF, IMoniker pimkTarget, const(wchar)* pwzLocation, 
                                       const(wchar)* pwzDir, const(wchar)* pwzFileName, ushort** ppwzShortcutFile, 
                                       uint dwReserved);

@DllImport("hlink")
HRESULT HlinkCreateShortcutFromString(uint grfHLSHORTCUTF, const(wchar)* pwzTarget, const(wchar)* pwzLocation, 
                                      const(wchar)* pwzDir, const(wchar)* pwzFileName, ushort** ppwzShortcutFile, 
                                      uint dwReserved);

@DllImport("hlink")
HRESULT HlinkResolveShortcut(const(wchar)* pwzShortcutFileName, IHlinkSite pihlsite, uint dwSiteData, 
                             IUnknown piunkOuter, const(GUID)* riid, void** ppvObj);

@DllImport("hlink")
HRESULT HlinkResolveShortcutToMoniker(const(wchar)* pwzShortcutFileName, IMoniker* ppimkTarget, 
                                      ushort** ppwzLocation);

@DllImport("hlink")
HRESULT HlinkResolveShortcutToString(const(wchar)* pwzShortcutFileName, ushort** ppwzTarget, ushort** ppwzLocation);

@DllImport("hlink")
HRESULT HlinkIsShortcut(const(wchar)* pwzFileName);

@DllImport("hlink")
HRESULT HlinkGetValueFromParams(const(wchar)* pwzParams, const(wchar)* pwzName, ushort** ppwzValue);

@DllImport("hlink")
HRESULT HlinkTranslateURL(const(wchar)* pwzURL, uint grfFlags, ushort** ppwzTranslatedURL);

///Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive
///letter. This function differs from PathIsUNC in that it also allows you to extract the name of the server from the
///path.
///Params:
///    pszPath = A pointer to the path string.
///    ppszServer = A pointer to a string that, when this function returns successfully, receives the server portion of the UNC path.
///                 This value can be <b>NULL</b> if you don't need this information.
@DllImport("api-ms-win-core-path-l1-1-0")
BOOL PathIsUNCEx(const(wchar)* pszPath, ushort** ppszServer);

///Determines whether a path string refers to the root of a volume. This function differs from PathIsRoot in that it
///accepts paths with "\\", "\\?\" and "\\?\UNC\" prefixes.
///Params:
///    pszPath = A pointer to the path string.
///Returns:
///    Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.
///    
@DllImport("api-ms-win-core-path-l1-1-0")
BOOL PathCchIsRoot(const(wchar)* pszPath);

///Adds a backslash to the end of a string to create the correct syntax for a path. If the source path already has a
///trailing backslash, no backslash will be added. This function differs from PathCchAddBackslash in that it can return
///a pointer to the new end of the string and report the number of unused characters remaining in the buffer. This
///function differs from PathAddBackslash in that it accepts paths with "\\", "\\?\" and "\\?\UNC\" prefixes. <div
///class="alert"><b>Note</b> This function, or <b>PathCchAddBackslashEx</b>, should be used in place of PathAddBackslash
///to prevent the possibility of a buffer overrun.</div>
///Params:
///    pszPath = A pointer to the path string. When this function returns successfully, the buffer contains the string with the
///              appended backslash. This value should not be <b>NULL</b>.
///    cchPath = The size of the buffer pointed to by <i>pszPath</i>, in characters.
///    ppszEnd = A value that, when this function returns successfully, receives the address of a pointer to the terminating null
///              character at the end of the string.
///    pcchRemaining = A pointer to a value that, when this function returns successfully, is set to the number of unused characters in
///                    the destination buffer, including the terminating null character.
///Returns:
///    This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if the path string already ends
///    in a backslash, or an error code otherwise.
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchAddBackslashEx(const(wchar)* pszPath, size_t cchPath, ushort** ppszEnd, size_t* pcchRemaining);

///Adds a backslash to the end of a string to create the correct syntax for a path. If the source path already has a
///trailing backslash, no backslash will be added. This function differs from <b>PathCchAddBackslash</b> in that you are
///restricted to a final path of length MAX_PATH. This function differs from PathAddBackslash in that it accepts paths
///with "\\", "\\?\" and "\\?\UNC\" prefixes. <div class="alert"><b>Note</b> This function, or PathCchAddBackslashEx,
///should be used in place of PathAddBackslash to prevent the possibility of a buffer overrun.</div>
///Params:
///    pszPath = A pointer to the path string. When this function returns successfully, the buffer contains the string with the
///              appended backslash. This value should not be <b>NULL</b>.
///    cchPath = The size of the buffer pointed to by <i>pszPath</i>, in characters.
///Returns:
///    This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if the path string already ends
///    in a backslash, or an error code otherwise.
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchAddBackslash(const(wchar)* pszPath, size_t cchPath);

///Removes the trailing backslash from the end of a path string. This function differs from PathCchRemoveBackslash in
///that it can return a pointer to the new end of the string and report the number of unused characters remaining in the
///buffer. This function differs from PathRemoveBackslash in that it accepts paths with "\\", "\\?\" and "\\?\UNC\"
///prefixes. <div class="alert"><b>Note</b> This function, or PathCchRemoveBackslash, should be used in place of
///PathRemoveBackslash to prevent the possibility of a buffer overrun.</div>
///Params:
///    pszPath = A pointer to the path string. When this function returns successfully, the string contains the path with any
///              trailing backslash removed. If no trailing backslash was found, the string is unchanged.
///    cchPath = The size of the buffer pointed to by <i>pszPath</i>, in characters.
///    ppszEnd = A value that, when this function returns successfully, receives the address of a pointer to end of the new
///              string. If the string is a root path such as "C:\", the pointer points to the backslash; otherwise the pointer
///              points to the string's terminating null character.
///    pcchRemaining = A pointer to a value that, when this function returns successfully, receives the number of unused characters in
///                    the destination buffer, including the terminating null character. If the string is a root path such as "C:\",
///                    this count includes the backslash in that string.
///Returns:
///    This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if the string was a root path or
///    if no backslash was found, or an error code otherwise.
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchRemoveBackslashEx(const(wchar)* pszPath, size_t cchPath, ushort** ppszEnd, size_t* pcchRemaining);

///Removes the trailing backslash from the end of a path string. This function differs from PathRemoveBackslash in that
///it accepts paths with "\\", "\\?\" and "\\?\UNC\" prefixes. <div class="alert"><b>Note</b> This function, or
///PathCchRemoveBackslashEx, should be used in place of PathRemoveBackslash to prevent the possibility of a buffer
///overrun.</div>
///Params:
///    pszPath = A pointer to the path string. When this function returns successfully, the string contains the path with any
///              trailing backslash removed. If no trailing backslash was found, the string is unchanged.
///    cchPath = The size of the buffer pointed to by <i>pszPath</i>, in characters.
///Returns:
///    This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if the string was a root path or
///    if no backslash was found, or an error code otherwise.
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchRemoveBackslash(const(wchar)* pszPath, size_t cchPath);

///Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC)
///server/share path elements. This function differs from PathSkipRoot in that it accepts paths with "\\", "\\?\" and
///"\\?\UNC\" prefixes.
///Params:
///    pszPath = A pointer to the path string.
///    ppszRootEnd = The address of a pointer that, when this function returns successfully, points to the first character in a path
///                  following the drive letter or UNC server/share path elements. If the path consists of only a root, this value
///                  will point to the string's terminating null character.
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchSkipRoot(const(wchar)* pszPath, ushort** ppszRootEnd);

///Removes all file and directory elements in a path except for the root information. This function differs from
///PathStripToRoot in that it accepts paths with "\\", "\\?\" and "\\?\UNC\" prefixes. <div class="alert"><b>Note</b>
///This function should be used in place of PathStripToRoot to prevent the possibility of a buffer overrun.</div>
///Params:
///    pszPath = A pointer to the path string. When this function returns successfully, this string contains only the root
///              information taken from that path.
///    cchPath = The size of the buffer pointed to by <i>pszPath</i>, in characters.
///Returns:
///    This function returns <b>S_OK</b> if the path was truncated, <b>S_FALSE</b> if the path was already just a root,
///    or an <b>HRESULT</b> failure code.
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchStripToRoot(const(wchar)* pszPath, size_t cchPath);

///Removes the last element in a path string, whether that element is a file name or a directory name. The element's
///leading backslash is also removed. This function differs from PathRemoveFileSpec in that it accepts paths with "\\",
///"\\?\" and "\\?\UNC\" prefixes. <div class="alert"><b>Note</b>This function should be used in place of
///PathRemoveFileSpec to prevent the possibility of a buffer overrun.</div>
///Params:
///    pszPath = A pointer to the fully-qualified path string. When this function returns successfully, the string will have had
///              its last element and its leading backslash removed. This function does not affect root paths such as "C:\". In
///              the case of a root path, the path string is returned unaltered. If a path string ends with a trailing backslash,
///              only that backslash is removed.
///    cchPath = The size of the buffer pointed to by <i>pszPath</i>, in characters.
///Returns:
///    This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if there was nothing to remove,
///    or an error code otherwise.
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchRemoveFileSpec(const(wchar)* pszPath, size_t cchPath);

///Searches a path to find its file name extension, such as ".exe" or ".ini". This function does not search for a
///specific extension; it searches for the presence of any extension. This function differs from PathFindExtension in
///that it accepts paths with "\\", "\\?\" and "\\?\UNC\" prefixes. <div class="alert"><b>Note</b> This function should
///be used in place of PathFindExtension to prevent the possibility of a buffer overrun.</div>
///Params:
///    pszPath = A pointer to the path to search.
///    cchPath = The size of the buffer pointed to by <i>pszPath</i>, in characters.
///    ppszExt = The address of a pointer that, when this function returns successfully, points to the "." character that precedes
///              the extension within <i>pszPath</i>. If no extension is found, it points to the string's terminating null
///              character.
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchFindExtension(const(wchar)* pszPath, size_t cchPath, ushort** ppszExt);

///Adds a file name extension to a path string. This function differs from PathAddExtension in that it accepts paths
///with "\\", "\\?\" and "\\?\UNC\" prefixes. <div class="alert"><b>Note</b> This function should be used in place of
///PathAddExtension to prevent the possibility of a buffer overrun.</div>
///Params:
///    pszPath = A pointer to the path string. When this function returns successfully, the buffer contains the string with the
///              appended extension. This value should not be <b>NULL</b>. <div class="alert"><b>Note</b> If the original string
///              already has a file name extension present, no new extension will be added and the original string will be
///              unchanged.</div>
///    cchPath = The size of the buffer pointed to by <i>pszPath</i>, in characters.
///    pszExt = A pointer to the file name extension string. This string can be given either with or without a preceding period
///             (".ext" or "ext").
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchAddExtension(const(wchar)* pszPath, size_t cchPath, const(wchar)* pszExt);

///Replaces a file name's extension at the end of a path string with a new extension. If the path string does not end
///with an extension, the new extension is added. This function differs from PathRenameExtension in that it accepts
///paths with "\\", "\\?\" and "\\?\UNC\" prefixes. <div class="alert"><b>Note</b> This function should be used in place
///of PathRenameExtension to prevent the possibility of a buffer overrun.</div>
///Params:
///    pszPath = A pointer to the path string. When this function returns successfully, this value points to the same string, but
///              with the renamed or added extension.
///    cchPath = The size of the buffer pointed to by <i>pszPath</i>, in characters.
///    pszExt = A pointer to the new extension string. The leading '.' character is optional. In the case of an empty string
///             (""), any existing extension in the path string is removed.
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchRenameExtension(const(wchar)* pszPath, size_t cchPath, const(wchar)* pszExt);

///Removes the file name extension from a path, if one is present. This function differs from PathRemoveExtension in
///that it accepts paths with "\\", "\\?\" and "\\?\UNC\" prefixes. <div class="alert"><b>Note</b>This function, should
///be used in place of PathRemoveExtension to prevent the possibility of a buffer overrun.</div>
///Params:
///    pszPath = A pointer to the path string. When this function returns successfully, the string contains the path with any
///              extension removed. If no extension was found, the string is unchanged.
///    cchPath = The size of the buffer pointed to by <i>pszPath</i>, in characters.
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchRemoveExtension(const(wchar)* pszPath, size_t cchPath);

///Simplifies a path by removing navigation elements such as "." and ".." to produce a direct, well-formed path. This
///function differs from PathCchCanonicalize in that it allows for a longer final path to be constructed. This function
///differs from PathAllocCanonicalize in that the caller must declare the size of the returned string, which is stored
///on the stack. This function differs from PathCanonicalize in that it accepts paths with "\\", "\\?\" and "\\?\UNC\"
///prefixes. <div class="alert"><b>Note</b> This function, PathCchCanonicalize, or PathAllocCanonicalize should be used
///in place of PathCanonicalize to prevent the possibility of a buffer overrun.</div>
///Params:
///    pszPathOut = A pointer to a buffer that, when this function returns successfully, receives the edited path string.
///    cchPathOut = The size of the buffer pointed to by <i>pszPathOut</i>, in characters.
///    pszPathIn = A pointer to the original path string. If this value is <b>NULL</b>, points to an empty string, or results in an
///                empty string once the "." and ".." elements are removed, a single backslash is copied to the buffer pointed to by
///                <i>pszPathOut</i>.
///    dwFlags = One or more of the following flags: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl> <dt><b>PATHCCH_NONE</b></dt> <dt>0x0000000</dt> </dl>
///              </td> <td width="60%"> Do not allow for the construction of \\?\ paths (ie, long paths) longer than
///              <b>MAX_PATH</b> . </td> </tr> <tr> <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a
///              id="pathcch_allow_long_paths"></a><dl> <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt> <dt>0x00000001</dt> </dl> </td>
///              <td width="60%"> Allow the building of \\?\ paths longer than <b>MAX_PATH</b> . Note that <i>cchPathOut</i> must
///              be greater than <b>MAX_PATH</b> . If it is not, this flag is ignored. </td> </tr> <tr> <td width="40%"><a
///              id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_enable_long_name_process"></a><dl>
///              <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Forces
///              the API to treat the caller as long path enabled, independent of the process's long name enabled state. This
///              option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with
///              <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>. <b>Note</b> This value is available starting in Windows 10,
///              version 1703. </td> </tr> <tr> <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a
///              id="____pathcch_force_disable_long_name_process"></a><dl> <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
///              <dt>0x00000004</dt> </dl> </td> <td width="60%"> Forces the API to treat the caller as long path disabled,
///              independent of the process's long name enabled state. This option can be used only when
///              <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with
///              <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>. <b>Note</b> This value is available starting in Windows 10,
///              version 1703. </td> </tr> <tr> <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a
///              id="____pathcch_do_not_normalize_segments"></a><dl> <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
///              <dt>0x00000008</dt> </dl> </td> <td width="60%"> Disables the normalization of path segments that includes
///              removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
///              <b>Note</b> This value is available starting in Windows 10, version 1703. </td> </tr> <tr> <td width="40%"><a
///              id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a
///              id="________pathcch_ensure_is_extended_length_path"></a><dl>
///              <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%">Converts
///              the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form.
///              This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip
///              trailing dots and spaces) and path length limitations. This option implies the same behavior of
///              <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>. <b>Note</b> This value is available starting in Windows 10, version
///              1703. </td> </tr> <tr> <td width="40%"><a id="____PATHCCH_ENSURE_TRAILING_SLASH"></a><a
///              id="____pathcch_ensure_trailing_slash"></a><dl> <dt><b>PATHCCH_ENSURE_TRAILING_SLASH</b></dt> <dt>0x00000020</dt>
///              </dl> </td> <td width="60%">When combining or normalizing a path, ensure there is a trailing backslash.
///              <b>Note</b> This value is available starting in Windows 10, version 1703. </td> </tr> </table>
///Returns:
///    If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> code, including but
///    not limited to the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>cchPathOut</i> value is greater than
///    <b>PATHCCH_MAX_CCH</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt> </dl>
///    </td> <td width="60%"> A path segment has more than <b>PATHCCH_MAX_CCH</b> characters, or, if the
///    <b>PATHCCH_ALLOW_LONG_PATHS</b> flag is not set, exceeds the standard path segment length limit of 256
///    characters. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The
///    function could not allocate a buffer of the neccessary size. </td> </tr> </table>
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchCanonicalizeEx(const(wchar)* pszPathOut, size_t cchPathOut, const(wchar)* pszPathIn, uint dwFlags);

///Converts a path string into a canonical form. This function differs from PathCchCanonicalizeEx in that you are
///restricted to a final path of length MAX_PATH. This function differs from PathAllocCanonicalize in that the caller
///must declare the size of the returned string, which is stored on the stack. This function differs from
///PathCanonicalize in that it accepts paths with "\\", "\\?\" and "\\?\UNC\" prefixes. <div class="alert"><b>Note</b>
///This function, PathCchCanonicalizeEx, or PathAllocCanonicalize should be used in place of PathCanonicalize to prevent
///the possibility of a buffer overrun.</div>
///Params:
///    pszPathOut = A pointer to a buffer that, when this function returns successfully, receives the canonicalized path string.
///    cchPathOut = The size of the buffer pointed to by <i>pszPathOut</i>, in characters.
///    pszPathIn = A pointer to the original path string. If this value points to an empty string, or results in an empty string
///                once the "." and ".." elements are removed, a single backslash is copied to the buffer pointed to by
///                <i>pszPathOut</i>.
///Returns:
///    If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> code, including the
///    following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>cchPathOut</i> value is greater than
///    <b>PATHCCH_MAX_CCH</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt> </dl>
///    </td> <td width="60%"> A path segment exceeds the standard path segment length limit of 256 characters. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The function could
///    not allocate a buffer of the neccessary size. </td> </tr> </table>
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchCanonicalize(const(wchar)* pszPathOut, size_t cchPathOut, const(wchar)* pszPathIn);

///Combines two path fragments into a single path. This function also canonicalizes any relative path elements, removing
///"." and ".." elements to simplify the final path. This function differs from PathCchCombine in that it allows for a
///longer final path to be constructed. This function differs from PathAllocCombine in that the caller must declare the
///size of the returned string, which is stored on the stack. This function differs from PathCombine in that it accepts
///paths with "\\", "\\?\" and "\\?\UNC\" prefixes. <div class="alert"><b>Note</b> This function, PathCchCombine, or
///PathAllocCombine should be used in place of PathCombine to prevent the possibility of a buffer overrun.</div>
///Params:
///    pszPathOut = A pointer to a buffer that, when this function returns successfully, receives the combined path string. This
///                 parameter can point to the same buffer as <i>pszPathIn</i> or <i>pszMore</i>.
///    cchPathOut = The size of the buffer pointed to by <i>pszPathOut</i>, in characters.
///    pszPathIn = A pointer to the first path string. This value can be <b>NULL</b>.
///    pszMore = A pointer to the second path string. If this path begins with a single backslash, it is combined with only the
///              root of the path pointed to by <i>pszPathIn</i>. If this path is fully qualfied, it is copied directly to the
///              output buffer without being combined with the other path. This value can be <b>NULL</b>.
///    dwFlags = One or more of the following flags: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl> <dt><b>PATHCCH_NONE</b></dt> <dt>0x0000000</dt> </dl>
///              </td> <td width="60%"> Do not allow for the construction of \\?\ paths (ie, long paths) longer than
///              <b>MAX_PATH</b> . </td> </tr> <tr> <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a
///              id="pathcch_allow_long_paths"></a><dl> <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt> <dt>0x00000001</dt> </dl> </td>
///              <td width="60%"> Allow the construction of \\?\ paths longer than <b>MAX_PATH</b>. Note that <i>cchPathOut</i>
///              must be greater than <b>MAX_PATH</b>. Note that <i>cchPathOut</i> must be greater than <b>MAX_PATH</b>. If it is
///              not, this flag is ignored. </td> </tr> <tr> <td width="40%"><a
///              id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_enable_long_name_process"></a><dl>
///              <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%">Forces the
///              API to treat the caller as long path enabled, independent of the process's long name enabled state. This option
///              can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with
///              <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>. <b>Note</b> This value is available starting in Windows 10,
///              version 1703. </td> </tr> <tr> <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a
///              id="____pathcch_force_disable_long_name_process"></a><dl> <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
///              <dt>0x00000004</dt> </dl> </td> <td width="60%">Forces the API to treat the caller as long path disabled,
///              independent of the process's long name enabled state. This option can be used only when
///              <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with
///              <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>. <b>Note</b> This value is available starting in Windows 10,
///              version 1703. </td> </tr> <tr> <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a
///              id="____pathcch_do_not_normalize_segments"></a><dl> <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
///              <dt>0x00000008</dt> </dl> </td> <td width="60%">Disables the normalization of path segments that includes
///              removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
///              <b>Note</b> This value is available starting in Windows 10, version 1703. </td> </tr> <tr> <td width="40%"><a
///              id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a
///              id="________pathcch_ensure_is_extended_length_path"></a><dl>
///              <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%">Converts
///              the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form.
///              This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip
///              trailing dots and spaces) and path length limitations. This option implies the same behavior of
///              <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>. <b>Note</b> This value is available starting in Windows 10, version
///              1703. </td> </tr> </table>
///Returns:
///    This function returns an <b>HRESULT</b> code, including the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
///    function succeeded. Note that this also includes the case of an empty extension, such as a period with no
///    characters following it. In that case, the original string is returned unaltered. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> This value can be caused by several
///    things, such as the <i>pszPathOut</i> param being set to <b>NULL</b>, or the <i>cchPathOut</i> value being set to
///    0 or a value greater than <b>PATHCCH_MAX_CCH</b> . </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The function could not allocate enough memory to
///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt> </dl>
///    </td> <td width="60%"> The size of one or both of the original paths exceeded <b>PATHCCH_MAX_CCH</b> . </td>
///    </tr> </table>
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchCombineEx(const(wchar)* pszPathOut, size_t cchPathOut, const(wchar)* pszPathIn, 
                         const(wchar)* pszMore, uint dwFlags);

///Combines two path fragments into a single path. This function also canonicalizes any relative path elements, removing
///"." and ".." elements to simplify the final path. This function differs from PathCchCombineEx in that you are
///restricted to a final path of length MAX_PATH. This function differs from PathAllocCombine in that the caller must
///declare the size of the returned string, which is stored on the stack. This function differs from PathCombine in that
///it accepts paths with "\\", "\\?\" and "\\?\UNC\" prefixes. <div class="alert"><b>Note</b> This function,
///PathCchCombineEx, or PathAllocCombine should be used in place of PathCombine to prevent the possibility of a buffer
///overrun.</div>
///Params:
///    pszPathOut = A pointer to a buffer that, when this function returns successfully, receives the combined path string. This
///                 parameter can point to the same buffer as <i>pszPathIn</i> or <i>pszMore</i>.
///    cchPathOut = The size of the buffer pointed to by <i>pszPathOut</i>, in characters.
///    pszPathIn = A pointer to the first path string. This value can be <b>NULL</b>.
///    pszMore = A pointer to the second path string. If this path begins with a single backslash, it is combined with only the
///              root of the path pointed to by <i>pszPathIn</i>. If this path is fully qualfied, it is copied directly to the
///              output buffer without being combined with the other path. This value can be <b>NULL</b>.
///Returns:
///    This function returns an <b>HRESULT</b> code, including the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
///    function succeeded. Note that this also includes the case of an empty extension, such as a period with no
///    characters following it. In that case, the original string is returned unaltered. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> This value can be caused by several
///    things, such as the <i>pszPathOut</i> param being set to <b>NULL</b>, or the <i>cchPathOut</i> value being set to
///    0 or a value greater than <b>PATHCCH_MAX_CCH</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The function could not allocate enough memory to
///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt> </dl>
///    </td> <td width="60%"> The size of one or both of the original paths exceeded <b>PATHCCH_MAX_CCH</b>. </td> </tr>
///    </table>
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchCombine(const(wchar)* pszPathOut, size_t cchPathOut, const(wchar)* pszPathIn, const(wchar)* pszMore);

///Appends one path to the end of another. This function differs from PathCchAppend in that it allows for a longer final
///path to be constructed. This function differs from PathAppend in that it accepts paths with "\\", "\\?\" and
///"\\?\UNC\" prefixes. <div class="alert"><b>Note</b> This function, or PathCchAppend, should be used in place of
///PathAppend to prevent the possibility of a buffer overrun.</div>
///Params:
///    pszPath = A pointer to a buffer that, on entry, contains the original path. When this function returns successfully, the
///              buffer contains the original path plus the appended path.
///    cchPath = The size of the buffer pointed to by <i>pszPath</i>, in characters.
///    pszMore = A pointer the path to append to the end of the path pointed to by <i>pszPath</i>. UNC paths and paths that begin
///              with the sequence \\?\ are accepted and recognized as fully-qualified paths. These paths replace the string
///              pointed to by <i>pszPath</i> instead of being appended to it.
///    dwFlags = One or more of the following flags: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl> <dt><b>PATHCCH_NONE</b></dt> <dt>0x0000000</dt> </dl>
///              </td> <td width="60%">Do not allow for the construction of \\?\ paths (ie, long paths) longer than
///              <b>MAX_PATH</b>. </td> </tr> <tr> <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a
///              id="pathcch_allow_long_paths"></a><dl> <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt> <dt>0x00000001</dt> </dl> </td>
///              <td width="60%">Allow the building of \\?\ paths longer than <b>MAX_PATH</b>. </td> </tr> <tr> <td width="40%"><a
///              id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_enable_long_name_process"></a><dl>
///              <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%">Forces the
///              API to treat the caller as long path enabled, independent of the process's long name enabled state. This option
///              can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with
///              <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>. <b>Note</b> This value is available starting in Windows 10,
///              version 1703. </td> </tr> <tr> <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a
///              id="____pathcch_force_disable_long_name_process"></a><dl> <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
///              <dt>0x00000004</dt> </dl> </td> <td width="60%">Forces the API to treat the caller as long path disabled,
///              independent of the process's long name enabled state. This option can be used only when
///              <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with
///              <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>. <b>Note</b> This value is available starting in Windows 10,
///              version 1703. </td> </tr> <tr> <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a
///              id="____pathcch_do_not_normalize_segments"></a><dl> <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
///              <dt>0x00000008</dt> </dl> </td> <td width="60%">Disables the normalization of path segments that includes
///              removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
///              <b>Note</b> This value is available starting in Windows 10, version 1703. </td> </tr> <tr> <td width="40%"><a
///              id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a
///              id="________pathcch_ensure_is_extended_length_path"></a><dl>
///              <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%">Converts
///              the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form.
///              This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip
///              trailing dots and spaces) and path length limitations. This option implies the same behavior of
///              <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>. <b>Note</b> This value is available starting in Windows 10, version
///              1703. </td> </tr> </table>
///Returns:
///    If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> code, including the
///    following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Either <i>pszPath</i> or <i>pszMore</i> is <b>NULL</b>,
///    <i>cchPath</i> is 0, or <i>cchPath</i> is greater than <b>PATHCCH_MAX_CCH</b>. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt> </dl> </td> <td width="60%"> The resulting string would exceed
///    <b>PATHCCH_MAX_CCH</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
///    width="60%"> The function could not allocate a buffer of the neccessary size. </td> </tr> </table>
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchAppendEx(const(wchar)* pszPath, size_t cchPath, const(wchar)* pszMore, uint dwFlags);

///Appends one path to the end of another. This function differs from PathCchAppendEx in that you are restricted to a
///final path of length MAX_PATH. This function differs from PathAppend in that it accepts paths with "\\", "\\?\" and
///"\\?\UNC\" prefixes. <div class="alert"><b>Note</b> This function, or PathCchAppendEx, should be used in place of
///PathAppend to prevent the possibility of a buffer overrun.</div>
///Params:
///    pszPath = A pointer to a buffer that, on entry, contains the original path. When this function returns successfully, the
///              buffer contains the original path plus the appended path.
///    cchPath = The size of the buffer pointed to by <i>pszPath</i>, in characters.
///    pszMore = A pointer to the path to append to the end of the path pointed to by <i>pszPath</i>. UNC paths and paths
///              beginning with the "\\?\" sequence are accepted and recognized as fully-qualified paths. These paths replace the
///              string pointed to by <i>pszPath</i> instead of being appended to it.
///Returns:
///    If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> code, including the
///    following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Either <i>pszPath</i> or <i>pszMore</i> is <b>NULL</b>,
///    <i>cchPath</i> is 0, or <i>cchPath</i> is greater than <b>PATHCCH_MAX_CCH</b>. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt> </dl> </td> <td width="60%"> The resulting string would exceed
///    <b>PATHCCH_MAX_CCH</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
///    width="60%"> The function could not allocate a buffer of the neccessary size. </td> </tr> </table>
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchAppend(const(wchar)* pszPath, size_t cchPath, const(wchar)* pszMore);

///Removes the "\\?\" prefix, if present, from a file path.
///Params:
///    pszPath = A pointer to the path string. When this function returns successfully, the same path string will have had the
///              prefix removed, if the prefix was present. If no prefix was present, the string will be unchanged.
///    cchPath = The size of the buffer pointed to by <i>pszPath</i>, in characters.
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathCchStripPrefix(const(wchar)* pszPath, size_t cchPath);

///Concatenates two path fragments into a single path. This function also canonicalizes any relative path elements,
///replacing path elements such as "." and "..". This function differs from PathCchCombine and PathCchCombineEx in that
///it returns the result on the heap. This means that the caller does not have to declare the size of the returned
///string and reduces stack use. This function differs from PathCombine in that it accepts paths with "\\", "\\?\" and
///"\\?\UNC\" prefixes. <div class="alert"><b>Note</b> This function, PathCchCombine, or PathCchCombineEx, should be
///used in place of PathCombine.</div><
///Params:
///    pszPathIn = A pointer to the first path string.
///    pszMore = A pointer to the second path string. If this path begins with a single backslash, it is combined with only the
///              root of the path pointed to by <i>pszPathIn</i>. If this path is fully qualified, it is copied directly to the
///              output buffer without being combined with the other path.
///    dwFlags = One or more of the following flags: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl> <dt><b>PATHCCH_NONE</b></dt> <dt>0x0000000</dt> </dl>
///              </td> <td width="60%">Do not allow for the construction of \\?\ paths (ie, long paths) longer than
///              <b>MAX_PATH</b> . </td> </tr> <tr> <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a
///              id="pathcch_allow_long_paths"></a><dl> <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt> <dt>0x00000001</dt> </dl> </td>
///              <td width="60%">Allow the construction of \\?\ paths longer than <b>MAX_PATH</b> . </td> </tr> <tr> <td
///              width="40%"><a id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a
///              id="____pathcch_force_enable_long_name_process"></a><dl> <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt>
///              <dt>0x00000002</dt> </dl> </td> <td width="60%">Forces the API to treat the caller as long path enabled,
///              independent of the process's long name enabled state. This option can be used only when
///              <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with
///              <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>. <b>Note</b> This value is available starting in Windows 10,
///              version 1703. </td> </tr> <tr> <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a
///              id="____pathcch_force_disable_long_name_process"></a><dl> <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
///              <dt>0x00000004</dt> </dl> </td> <td width="60%">Forces the API to treat the caller as long path disabled,
///              independent of the process's long name enabled state. This option can be used only when
///              <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with
///              <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>. <b>Note</b> This value is available starting in Windows 10,
///              version 1703. </td> </tr> <tr> <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a
///              id="____pathcch_do_not_normalize_segments"></a><dl> <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
///              <dt>0x00000008</dt> </dl> </td> <td width="60%">Disables the normalization of path segments that includes
///              removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
///              <b>Note</b> This value is available starting in Windows 10, version 1703. </td> </tr> <tr> <td width="40%"><a
///              id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a
///              id="________pathcch_ensure_is_extended_length_path"></a><dl>
///              <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%">Converts
///              the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form.
///              This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip
///              trailing dots and spaces) and path length limitations. This option implies the same behavior of
///              <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>. <b>Note</b> This value is available starting in Windows 10, version
///              1703. </td> </tr> <tr> <td width="40%"><a id="____PATHCCH_ENSURE_TRAILING_SLASH"></a><a
///              id="____pathcch_ensure_trailing_slash"></a><dl> <dt><b>PATHCCH_ENSURE_TRAILING_SLASH</b></dt> <dt>0x00000020</dt>
///              </dl> </td> <td width="60%">When combining or normalizing a path, ensure there is a trailing backslash.
///              <b>Note</b> This value is available starting in Windows 10, version 1703. </td> </tr> </table>
///    ppszPathOut = The address of a pointer to a buffer that, when this function returns successfully, receives the combined path
///                  string. It is the responsibility of the caller to free this resource, when it is no longer needed, by calling the
///                  LocalFree function. This value cannot be <b>NULL</b>.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathAllocCombine(const(wchar)* pszPathIn, const(wchar)* pszMore, uint dwFlags, ushort** ppszPathOut);

///Converts a path string into a canonical form. This function differs from PathCchCanonicalize and
///PathCchCanonicalizeEx in that it returns the result on the heap. This means that the caller does not have to declare
///the size of the returned string and reduces stack use. This function differs from PathCanonicalize in that it accepts
///paths with "\\", "\\?\" and "\\?\UNC\" prefixes. <div class="alert"><b>Note</b> This function, PathCchCanonicalize,
///or PathCchCanonicalizeEx, should be used in place of PathCanonicalize.</div>
///Params:
///    pszPathIn = A pointer to a buffer that contains the original string. This value cannot be <b>NULL</b>.
///    dwFlags = One or more of the following flags: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl> <dt><b>PATHCCH_NONE</b></dt> <dt>0x0000000</dt> </dl>
///              </td> <td width="60%">Do not allow for the construction of \\?\ paths (ie, long paths) longer than
///              <b>MAX_PATH</b> . </td> </tr> <tr> <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a
///              id="pathcch_allow_long_paths"></a><dl> <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt> <dt>0x00000001</dt> </dl> </td>
///              <td width="60%">Allow the building of \\?\ paths longer than <b>MAX_PATH</b> . </td> </tr> <tr> <td
///              width="40%"><a id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a
///              id="____pathcch_force_enable_long_name_process"></a><dl> <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt>
///              <dt>0x00000002</dt> </dl> </td> <td width="60%">Forces the API to treat the caller as long path enabled,
///              independent of the process's long name enabled state. This option can be used only when
///              <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with
///              <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>. <b>Note</b> This value is available starting in Windows 10,
///              version 1703. </td> </tr> <tr> <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a
///              id="____pathcch_force_disable_long_name_process"></a><dl> <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
///              <dt>0x00000004</dt> </dl> </td> <td width="60%">Forces the API to treat the caller as long path disabled,
///              independent of the process's long name enabled state. This option can be used only when
///              <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with
///              <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>. <b>Note</b> This value is available starting in Windows 10,
///              version 1703. </td> </tr> <tr> <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a
///              id="____pathcch_do_not_normalize_segments"></a><dl> <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
///              <dt>0x00000008</dt> </dl> </td> <td width="60%">Disables the normalization of path segments that includes
///              removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
///              <b>Note</b> This value is available starting in Windows 10, version 1703. </td> </tr> <tr> <td width="40%"><a
///              id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a
///              id="________pathcch_ensure_is_extended_length_path"></a><dl>
///              <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%">Converts
///              the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form.
///              This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip
///              trailing dots and spaces) and path length limitations. This option implies the same behavior of
///              <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>. <b>Note</b> This value is available starting in Windows 10, version
///              1703. </td> </tr> <tr> <td width="40%"><a id="____PATHCCH_ENSURE_TRAILING_SLASH"></a><a
///              id="____pathcch_ensure_trailing_slash"></a><dl> <dt><b>PATHCCH_ENSURE_TRAILING_SLASH</b></dt> <dt>0x00000020</dt>
///              </dl> </td> <td width="60%">When combining or normalizing a path, ensure there is a trailing backslash.
///              <b>Note</b> This value is available starting in Windows 10, version 1703. </td> </tr> </table>
///    ppszPathOut = The address of a pointer to a buffer that, when this function returns successfully, receives the canonicalized
///                  path string. It is the responsibility of the caller to free this resource, when it is no longer needed, by
///                  calling the LocalFree function. This value cannot be <b>NULL</b>.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("api-ms-win-core-path-l1-1-0")
HRESULT PathAllocCanonicalize(const(wchar)* pszPathIn, uint dwFlags, ushort** ppszPathOut);

///Enables an app to register a callback function through which it can be notified that its library is going into or
///coming out of a suspended state. The app can use this information to perform any necessary operations, such as
///preserving state, that should be performed at that point.
///Params:
///    Routine = A pointer to a callback function that is called when the app enters or leaves the suspended state. See
///              PAPPSTATE_CHANGE_ROUTINE for more detail on this function.
///    Context = App-specific context information that the app uses when going into or out of a suspended state. This is commonly
///              a "this" pointer.
///    Registration = When this function returns successfully, this parameter receives the address of a pointer to a value that can be
///                   used to identify the registration. Store this value to use with UnregisterAppStateChangeNotification.
///Returns:
///    A standard Win32 status code.
///    
@DllImport("api-ms-win-core-psm-appnotify-l1-1-0")
uint RegisterAppStateChangeNotification(PAPPSTATE_CHANGE_ROUTINE Routine, void* Context, 
                                        _APPSTATE_REGISTRATION** Registration);

///Cancels a change notification registered through RegisterAppStateChangeNotification.
///Params:
///    Registration = A pointer to the registration handle retrieved by RegisterAppStateChangeNotification through its
///                   <i>Registration</i> parameter.
///Returns:
///    This function does not return a value.
///    
@DllImport("api-ms-win-core-psm-appnotify-l1-1-0")
void UnregisterAppStateChangeNotification(_APPSTATE_REGISTRATION* Registration);

@DllImport("api-ms-win-core-psm-appnotify-l1-1-1")
uint RegisterAppConstrainedChangeNotification(PAPPCONSTRAIN_CHANGE_ROUTINE Routine, void* Context, 
                                              _APPCONSTRAIN_REGISTRATION** Registration);

@DllImport("api-ms-win-core-psm-appnotify-l1-1-1")
void UnregisterAppConstrainedChangeNotification(_APPCONSTRAIN_REGISTRATION* Registration);


// Interfaces

@GUID("331F1768-05A9-4DDD-B86E-DAE34DDC998A")
struct QueryCancelAutoPlay;

@GUID("3BB4118F-DDFD-4D30-A348-9FB5D6BF1AFE")
struct TimeCategorizer;

@GUID("3C2654C6-7372-4F6B-B310-55D6128F49D2")
struct AlphabeticalCategorizer;

@GUID("8E827C11-33E7-4BC1-B242-8CD9A1C2B304")
struct MergedCategorizer;

@GUID("7AB770C7-0E23-4D7A-8AA2-19BFAD479829")
struct ImageProperties;

@GUID("FBEB8A05-BEEE-4442-804E-409D6C4515E9")
struct CDBurn;

@GUID("A2A9545D-A0C2-42B4-9708-A0B2BADD77C8")
struct StartMenuPin;

@GUID("C827F149-55C1-4D28-935E-57E47CAED973")
struct WebWizardHost;

@GUID("CC6EEFFB-43F6-46C5-9619-51D571967F7D")
struct PublishDropTarget;

@GUID("6B33163C-76A5-4B6C-BF21-45DE9CD503A1")
struct PublishingWizard;

@GUID("ADD36AA8-751A-4579-A266-D66F5202CCBB")
struct InternetPrintOrdering;

@GUID("20B1CB23-6968-4EB9-B7D4-A66D00D07CEE")
struct FolderViewHost;

@GUID("71F96385-DDD6-48D3-A0C1-AE06E8B055FB")
struct ExplorerBrowser;

@GUID("6E33091C-D2F8-4740-B55E-2E11D1477A2C")
struct ImageRecompress;

@GUID("F60AD0A0-E5E1-45CB-B51A-E15B9F8B2934")
struct TrayBandSiteService;

@GUID("E6442437-6C68-4F52-94DD-2CFED267EFB9")
struct TrayDeskBand;

@GUID("4125DD96-E03A-4103-8F70-E0597D803B9C")
struct AttachmentServices;

@GUID("883373C3-BF89-11D1-BE35-080036B11A03")
struct DocPropShellExtension;

@GUID("D197380A-0A79-4DC8-A033-ED882C2FA14B")
struct FSCopyHandler;

@GUID("596AB062-B4D2-4215-9F74-E9109B0A8153")
struct PreviousVersions;

@GUID("AE054212-3535-4430-83ED-D501AA6680E6")
struct NamespaceTreeControl;

@GUID("ACE52D03-E5CD-4B20-82FF-E71B11BEAE1D")
struct IENamespaceTreeControl;

@GUID("1968106D-F3B5-44CF-890E-116FCB9ECEF1")
struct ApplicationAssociationRegistrationUI;

@GUID("924CCC1B-6562-4C85-8657-D177925222B6")
struct DesktopGadget;

@GUID("29CE1D46-B481-4AA0-A08A-D3EBC8ACA402")
struct AccessibilityDockingService;

@GUID("11DBB47C-A525-400B-9E80-A54615A090C0")
struct ExecuteFolder;

@GUID("AA509086-5CA9-4C25-8F95-589D3C07B48A")
struct VirtualDesktopManager;

@GUID("7CCDF9F4-E576-455A-8BC7-F6EC68D6F063")
struct StorageProviderBanners;

@GUID("C2CF3110-460E-4FC1-B9D0-8A1C0C9CC4BD")
struct DesktopWallpaper;

@GUID("00021400-0000-0000-C000-000000000046")
struct ShellDesktop;

@GUID("F3364BA0-65B9-11CE-A9BA-00AA004AE837")
struct ShellFSFolder;

@GUID("208D2C60-3AEA-1069-A2D7-08002B30309D")
struct NetworkPlaces;

@GUID("00021401-0000-0000-C000-000000000046")
struct ShellLink;

@GUID("94357B53-CA29-4B78-83AE-E8FE7409134F")
struct DriveSizeCategorizer;

@GUID("B0A8F3CF-4333-4BAB-8873-1CCB1CADA48B")
struct DriveTypeCategorizer;

@GUID("B5607793-24AC-44C7-82E2-831726AA6CB7")
struct FreeSpaceCategorizer;

@GUID("55D7B852-F6D1-42F2-AA75-8728A1B2D264")
struct SizeCategorizer;

@GUID("D912F8CF-0396-4915-884E-FB425D32943B")
struct PropertiesUI;

@GUID("0010890E-8789-413C-ADBC-48F5B511B3AF")
struct UserNotification;

@GUID("56FDF344-FD6D-11D0-958A-006097C9A090")
struct TaskbarList;

@GUID("9AC9FBE1-E0A2-4AD6-B4EE-E212013EA917")
struct ShellItem;

@GUID("72EB61E0-8672-4303-9175-F2E4C68B2E7C")
struct NamespaceWalker;

@GUID("3AD05575-8857-4850-9277-11B85BDB8E09")
struct FileOperation;

@GUID("DC1C5A9C-E88A-4DDE-A5A1-60F82A20AEF7")
struct FileOpenDialog;

@GUID("C0B4E2F3-BA21-4773-8DBA-335EC946EB8B")
struct FileSaveDialog;

@GUID("4DF0C730-DF9D-4AE3-9153-AA6B82E9795A")
struct KnownFolderManager;

@GUID("49F371E1-8C5C-4D9C-9A3B-54A6827F513C")
struct SharingConfigurationManager;

@GUID("7007ACC7-3202-11D1-AAD2-00805FC1270E")
struct NetworkConnections;

@GUID("D6277990-4C6A-11CF-8D87-00AA0060F5BF")
struct ScheduledTasks;

@GUID("591209C7-767B-42B2-9FBA-44EE4615F2C7")
struct ApplicationAssociationRegistration;

@GUID("14010E02-BBBD-41F0-88E3-EDA371216584")
struct SearchFolderItemFactory;

@GUID("06622D85-6856-4460-8DE1-A81921B41C4B")
struct OpenControlPanel;

@GUID("9E56BE60-C50F-11CF-9A2C-00A0C90A90CE")
struct MailRecipient;

@GUID("F02C1A0D-BE21-4350-88B0-7367FC96EF3C")
struct NetworkExplorerFolder;

@GUID("77F10CF0-3DB5-4966-B520-B7C54FD35ED6")
struct DestinationList;

@GUID("86C14003-4D6B-4EF3-A7B4-0506663B2E68")
struct ApplicationDestinations;

@GUID("86BEC222-30F2-47E0-9F25-60D11CD75C28")
struct ApplicationDocumentLists;

@GUID("DE77BA04-3C92-4D11-A1A5-42352A53E0E3")
struct HomeGroup;

@GUID("D9B3211D-E57F-4426-AAEF-30A806ADD397")
struct ShellLibrary;

@GUID("273EB5E7-88B0-4843-BFEF-E2C81D43AAE5")
struct AppStartupLink;

@GUID("2D3468C1-36A7-43B6-AC24-D3F02FD9607A")
struct EnumerableObjectCollection;

@GUID("D5120AA3-46BA-44C5-822D-CA8092C1FC72")
struct FrameworkInputPane;

@GUID("C63382BE-7933-48D0-9AC8-85FB46BE2FDD")
struct DefFolderMenu;

@GUID("7E5FE3D9-985F-4908-91F9-EE19F9FD1514")
struct AppVisibility;

@GUID("4ED3A719-CEA8-4BD9-910D-E252F997AFC2")
struct AppShellVerbHandler;

@GUID("E44E9428-BDBC-4987-A099-40DC8FD255E7")
struct ExecuteUnknown;

@GUID("B1AEC16F-2383-4852-B0E9-8F0B1DC66B4D")
struct PackageDebugSettings;

@GUID("6B273FC5-61FD-4918-95A2-C3B5E9D7F581")
struct SuspensionDependencyManager;

@GUID("45BA127D-10A8-46EA-8AB7-56EA9078943C")
struct ApplicationActivationManager;

@GUID("958A6FB5-DCB2-4FAF-AAFD-7FB054AD1A3B")
struct ApplicationDesignModeSettings;

@GUID("9BA05971-F6A8-11CF-A442-00A0C90A8F39")
struct ShellFolderViewOC;

@GUID("2FE352EA-FD1F-11D2-B1F4-00C04F8EEB3E")
struct ShellFolderItem;

@GUID("11219420-1768-11D1-95BE-00609797EA4F")
struct ShellLinkObject;

@GUID("62112AA1-EBE4-11CF-A5FB-0020AFE7292D")
struct ShellFolderView;

@GUID("13709620-C279-11CE-A49E-444553540000")
struct Shell;

@GUID("0A89A860-D7B1-11CE-8350-444553540000")
struct ShellDispatchInproc;

@GUID("C4EE31F3-4768-11D2-BE5C-00A0C9A83DA1")
struct FileSearchBand;

@GUID("60B78E88-EAD8-445C-9CFD-0B87F74EA6CD")
struct PasswordCredentialProvider;

@GUID("6F45DC1E-5384-457A-BC13-2CD81B0D28ED")
struct V1PasswordCredentialProvider;

@GUID("CB82EA12-9F71-446D-89E1-8D0924E1256E")
struct PINLogonCredentialProvider;

@GUID("3DD6BEC0-8193-4FFE-AE25-E08E39EA4063")
struct NPCredentialProvider;

@GUID("8FD7E19C-3BF7-489B-A72C-846AB3678C96")
struct SmartcardCredentialProvider;

@GUID("8BF9A910-A8FF-457F-999F-A5CA10B4A885")
struct V1SmartcardCredentialProvider;

@GUID("94596C7E-3744-41CE-893E-BBF09122F76A")
struct SmartcardPinProvider;

@GUID("1B283861-754F-4022-AD47-A5EAAA618894")
struct SmartcardReaderSelectionProvider;

@GUID("1EE7337F-85AC-45E2-A23C-37C753209769")
struct SmartcardWinRTProvider;

@GUID("25CBB996-92ED-457E-B28C-4774084BD562")
struct GenericCredentialProvider;

@GUID("5537E283-B1E7-4EF8-9C6E-7AB0AFE5056D")
struct RASProvider;

@GUID("07AA0886-CC8D-4E19-A410-1C75AF686E62")
struct OnexCredentialProvider;

@GUID("33C86CD6-705F-4BA1-9ADB-67070B837775")
struct OnexPlapSmartcardCredentialProvider;

@GUID("503739D0-4C5E-4CFD-B3BA-D881334F0DF2")
struct VaultProvider;

@GUID("BEC09223-B018-416D-A0AC-523971B639F5")
struct WinBioCredentialProvider;

@GUID("AC3AC249-E820-4343-A65B-377AC634DC09")
struct V1WinBioCredentialProvider;

@GUID("1202DB60-1DAC-42C5-AED5-1ABDD432248E")
struct SyncMgrClient;

@GUID("1A1F4206-0688-4E7F-BE03-D82EC69DF9A5")
struct SyncMgrControl;

@GUID("8D8B8E30-C451-421B-8553-D2976AFA648C")
struct SyncMgrScheduleWizard;

@GUID("9C73F5E5-7AE7-4E32-A8E8-8D23B85255BF")
struct SyncMgrFolder;

@GUID("2E9E59C0-B437-4981-A647-9C34B9B90891")
struct SyncSetupFolder;

@GUID("289978AC-A101-4341-A817-21EBA7FD046D")
struct ConflictFolder;

@GUID("71D99464-3B6B-475C-B241-E15883207529")
struct SyncResultsFolder;

@GUID("7A0F6AB7-ED84-46B6-B47E-02AA159A152B")
struct SimpleConflictPresenter;

@GUID("2853ADD3-F096-4C63-A78F-7FA3EA837FB7")
struct InputPanelConfiguration;

@GUID("50EF4544-AC9F-4A8E-B21B-8A26180DB13F")
struct LocalThumbnailCache;

@GUID("4DB26476-6787-4046-B836-E8412A9E8A27")
struct SharedBitmap;

@GUID("66E4E4FB-F385-4DD0-8D74-A2EFD1BC6178")
struct ShellImageDataFactory;

@GUID("6295DF27-35EE-11D1-8707-00C04FD93327")
struct SyncMgr;

@GUID("CBE0FED3-4B91-4E90-8354-8A8C84EC6872")
struct ThumbnailStreamCache;

@GUID("8278F931-2A3E-11D2-838F-00C04FD918D0")
struct TrackShellMenu;

@GUID("17B75166-928F-417D-9685-64AA135565C1")
struct ImageTranscode;

@GUID("4955DD33-B159-11D0-8FCF-00AA006BCC59")
struct CActiveIMM;

///Exposes a method that provides an object's creator with the means to notify the object that it may be subject to
///subsequent reconciliation. The briefcase reconciler is responsible for implementing this interface.
@GUID("99180163-DA16-101A-935C-444553540000")
interface INotifyReplica : IUnknown
{
    ///Notifies an object that it may be subject to subsequent reconciliation through the Reconcile method.
    ///Params:
    ///    ulcOtherReplicas = Type: <b>ULONG</b> The number of other replicas of the object. This parameter must not be zero.
    ///    rgpmkOtherReplicas = Type: <b>IMoniker**</b> The address of an array that contains the addresses of the monikers to use to access
    ///                         the other replicas.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or <b>E_UNEXPECTED</b> otherwise.
    ///    
    HRESULT YouAreAReplica(uint ulcOtherReplicas, char* rgpmkOtherReplicas);
}

///Exposes a method to initialize a handler, such as a property handler, thumbnail handler, or preview handler, with a
///file path.
@GUID("B7D14566-0509-4CCE-A71F-0A554233BD9B")
interface IInitializeWithFile : IUnknown
{
    ///Initializes a handler with a file path.
    ///Params:
    ///    pszFilePath = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the file path as a null-terminated Unicode string.
    ///    grfMode = Type: <b>DWORD</b> One of the following STGM values that indicates the access mode for <i>pszFilePath</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(const(wchar)* pszFilePath, uint grfMode);
}

///Exposes a method that initializes a handler, such as a property handler, thumbnail handler, or preview handler, with
///a stream.
@GUID("B824B49D-22AC-4161-AC8A-9916E8FA3F7F")
interface IInitializeWithStream : IUnknown
{
    ///Initializes a handler with a stream.
    ///Params:
    ///    pstream = Type: <b>IStream*</b> A pointer to an IStream interface that represents the stream source.
    ///    grfMode = Type: <b>DWORD</b> One of the following STGM values that indicates the access mode for <i>pstream</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(IStream pstream, uint grfMode);
}

///Exposes methods that get and set named properties.
@GUID("71604B0F-97B0-4764-8577-2F13E98A1422")
interface INamedPropertyStore : IUnknown
{
    ///Gets the value of a named property from the named property store.
    ///Params:
    ///    pszName = Type: <b>LPCWSTR</b> A pointer to the property name, as a Unicode string, of the property in the named
    ///              property store.
    ///    ppropvar = Type: <b>PROPVARIANT*</b> When this method returns, contains a pointer to a PROPVARIANT structure that holds
    ///               the property's value.
    HRESULT GetNamedValue(const(wchar)* pszName, PROPVARIANT* ppropvar);
    ///Sets the value of a named property.
    ///Params:
    ///    pszName = Type: <b>LPCWSTR</b> A pointer to the property name, as a Unicode string, in the named property store.
    ///    propvar = Type: <b>const PROPVARIANT*</b> A pointer to a PROPVARIANT structure that contains the value to set for the
    ///              property named in <i>pszName</i>.
    HRESULT SetNamedValue(const(wchar)* pszName, const(PROPVARIANT)* propvar);
    ///Gets the number of property names in the property store.
    ///Params:
    ///    pdwCount = Type: <b>DWORD*</b> When this method returns, contains a pointer to the count of names.
    HRESULT GetNameCount(uint* pdwCount);
    ///Gets the name of a property at a specified index in the property store.
    ///Params:
    ///    iProp = Type: <b>DWORD</b> The index of the property in the store.
    ///    pbstrName = Type: <b>BSTR*</b> When this method returns, contains a pointer to the property's name. It is the calling
    ///                application's responsibility to free this resource when it is no longer needed.
    HRESULT GetNameAt(uint iProp, BSTR* pbstrName);
}

///Exposes methods for getting and setting the property key.
@GUID("FC0CA0A7-C316-4FD2-9031-3E628E6D4F23")
interface IObjectWithPropertyKey : IUnknown
{
    ///Sets the property key.
    ///Params:
    ///    key = Type: <b>REFPROPERTYKEY</b> The property key.
    HRESULT SetPropertyKey(const(PROPERTYKEY)* key);
    ///Gets the property key.
    ///Params:
    ///    pkey = Type: <b>PROPERTYKEY*</b> When this returns, contains the property key.
    HRESULT GetPropertyKey(PROPERTYKEY* pkey);
}

///Exposes a method to create a specified IPropertyStore object in circumstances where property access is potentially
///slow.
@GUID("40D4577F-E237-4BDB-BD69-58F089431B6A")
interface IDelayedPropertyStoreFactory : IPropertyStoreFactory
{
    ///Gets an IPropertyStore interface object, as specified.
    ///Params:
    ///    flags = Type: <b>GETPROPERTYSTOREFLAGS</b> The GPS_XXX flags that modify the store that is returned. See
    ///            GETPROPERTYSTOREFLAGS.
    ///    dwStoreId = Type: <b>DWORD</b> The property store ID. Valid values are.
    ///    riid = Type: <b>REFIID</b> A reference to the desired IID.
    ///    ppv = Type: <b>void**</b> The address of an IPropertyStore interface pointer.
    HRESULT GetDelayedPropertyStore(GETPROPERTYSTOREFLAGS flags, uint dwStoreId, const(GUID)* riid, void** ppv);
}

///Exposes methods to persist serialized property storage data for later use and to restore persisted data to a new
///property store instance.
@GUID("E318AD57-0AA0-450F-ACA5-6FAB7103D917")
interface IPersistSerializedPropStorage : IUnknown
{
    ///Toggles the property store object between the read-only and read/write state.
    ///Params:
    ///    flags = Type: <b>PERSIST_SPROPSTORE_FLAGS</b> The <i>flags</i> parameter takes one of the following values to set
    ///            options for the behavior of the property storage:
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetFlags(int flags);
    ///Initializes the property store instance from the specified serialized property storage data.
    ///Params:
    ///    psps = Type: <b>PCUSERIALIZEDPROPSTORAGE</b> A pointer to the serialized property store data that will be used to
    ///           initialize the property store.
    ///    cb = Type: <b>DWORD</b> The count of bytes contained in the serialized property storage data pointed to by
    ///         <i>psps</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPropertyStorage(char* psps, uint cb);
    ///Gets the serialized property storage data from the property store instance.
    ///Params:
    ///    ppsps = Type: <b>SERIALIZEDPROPSTORAGE**</b> When this method returns, contains the address of a pointer to the
    ///            serialized property storage data.
    ///    pcb = Type: <b>DWORD*</b> When this method returns, contains the count of bytes contained in the serialized
    ///          property storage data pointed to by <i>ppsps</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPropertyStorage(SERIALIZEDPROPSTORAGE** ppsps, uint* pcb);
}

///Exposes methods to persist serialized property storage data for later use and to restore persisted data to a new
///property store instance.
@GUID("77EFFA68-4F98-4366-BA72-573B3D880571")
interface IPersistSerializedPropStorage2 : IPersistSerializedPropStorage
{
    ///Gets the size of serialized property storage data from the property store instance.
    ///Params:
    ///    pcb = Type: <b>DWORD*</b> The count of bytes contained in the serialized property storage data.
    HRESULT GetPropertyStorageSize(uint* pcb);
    ///Gets the serialized property storage buffer from the property store instance.
    ///Params:
    ///    psps = Type: <b>SERIALIZEDPROPSTORAGE*</b> When this method returns successfully, contains the contents of the
    ///           property storage buffer.
    ///    cb = Type: <b>DWORD</b> The initial size, in bytes, of the buffer pointed to by <i>psps</i>
    ///    pcbWritten = Type: <b>DWORD*</b> The count of bytes contained in the serialized property storage buffer pointed to by
    ///                 <i>psps</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPropertyStorageBuffer(char* psps, uint cb, uint* pcbWritten);
}

///Exposes a method that creates an object of a specified class.
@GUID("75121952-E0D0-43E5-9380-1D80483ACF72")
interface ICreateObject : IUnknown
{
    ///Creates a local object of a specified class and returns a pointer to a specified interface on the object.
    ///Params:
    ///    clsid = Type: <b>REFCLSID</b> A reference to a CLSID.
    ///    pUnkOuter = Type: <b>IUnknown*</b> A pointer to the IUnknown interface that aggregates the object created by this
    ///                function, or <b>NULL</b> if no aggregation is desired.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the interface the created object should return.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the address of the pointer to the interface requested
    ///          in <i>riid</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateObject(const(GUID)* clsid, IUnknown pUnkOuter, const(GUID)* riid, void** ppv);
}

///Exposes methods that enable clients to access items in a collection of objects that support IUnknown.
@GUID("92CA9DCD-5622-4BBA-A805-5E9F541BD8C9")
interface IObjectArray : IUnknown
{
    ///Provides a count of the objects in the collection.
    ///Params:
    ///    pcObjects = Type: <b>UINT*</b> The number of objects in the collection.
    HRESULT GetCount(uint* pcObjects);
    ///Provides a pointer to a specified object's interface. The object and interface are specified by index and
    ///interface ID.
    ///Params:
    ///    uiIndex = Type: <b>UINT</b> The index of the object
    ///    riid = Type: <b>REFIID</b> Reference to the desired interface ID.
    ///    ppv = Type: <b>void**</b> Receives the interface pointer requested in <i>riid</i>.
    HRESULT GetAt(uint uiIndex, const(GUID)* riid, void** ppv);
}

///Extends the IObjectArray interface by providing methods that enable clients to add and remove objects that support
///IUnknown in a collection.
@GUID("5632B1A4-E38A-400A-928A-D4CD63230295")
interface IObjectCollection : IObjectArray
{
    ///Adds a single object to the collection.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> Pointer to the IUnknown of the object to be added to the collection.
    HRESULT AddObject(IUnknown punk);
    ///Adds the objects contained in an IObjectArray to the collection.
    ///Params:
    ///    poaSource = Type: <b>IObjectArray*</b> Pointer to the IObjectArray whose contents are to be added to the collection.
    HRESULT AddFromArray(IObjectArray poaSource);
    ///Removes a single, specified object from the collection.
    ///Params:
    ///    uiIndex = Type: <b>UINT*</b> A pointer to the index of the object within the collection.
    HRESULT RemoveObjectAt(uint uiIndex);
    ///Removes all objects from the collection.
    HRESULT Clear();
}

///Exposes methods that either create or merge a shortcut menu associated with a Shell object.
@GUID("000214E4-0000-0000-C000-000000000046")
interface IContextMenu : IUnknown
{
    ///Adds commands to a shortcut menu.
    ///Params:
    ///    hmenu = Type: <b>HMENU</b> A handle to the shortcut menu. The handler should specify this handle when adding menu
    ///            items.
    ///    indexMenu = Type: <b>UINT</b> The zero-based position at which to insert the first new menu item.
    ///    idCmdFirst = Type: <b>UINT</b> The minimum value that the handler can specify for a menu item identifier.
    ///    idCmdLast = Type: <b>UINT</b> The maximum value that the handler can specify for a menu item identifier.
    ///    uFlags = Type: <b>UINT</b> Optional flags that specify how the shortcut menu can be changed. This parameter can be set
    ///             to a combination of the following values. The remaining bits of the low-order word are reserved by the
    ///             system. The high-order word can be used for context-specific communications. The CMF_RESERVED value can be
    ///             used to mask the low-order word.
    ///Returns:
    ///    Type: <b>HRESULT</b> If successful, returns an <b>HRESULT</b> value that has its severity value set to
    ///    SEVERITY_SUCCESS and its code value set to the offset of the largest command identifier that was assigned,
    ///    plus one. For example, if <i>idCmdFirst</i> is set to 5 and you add three items to the menu with command
    ///    identifiers of 5, 7, and 8, the return value should be MAKE_HRESULT(SEVERITY_SUCCESS, 0, 8 - 5 + 1).
    ///    Otherwise, it returns a COM error value.
    ///    
    HRESULT QueryContextMenu(HMENU hmenu, uint indexMenu, uint idCmdFirst, uint idCmdLast, uint uFlags);
    ///Carries out the command associated with a shortcut menu item.
    ///Params:
    ///    pici = Type: <b>LPCMINVOKECOMMANDINFO</b> A pointer to a CMINVOKECOMMANDINFO or CMINVOKECOMMANDINFOEX structure that
    ///           contains specifics about the command.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InvokeCommand(CMINVOKECOMMANDINFO* pici);
    ///Gets information about a shortcut menu command, including the help string and the language-independent, or
    ///<i>canonical</i>, name for the command.
    ///Params:
    ///    idCmd = Type: <b>UINT_PTR</b> Menu command identifier offset.
    ///    uType = Type: <b>UINT</b> Flags specifying the information to return. This parameter can have one of the following
    ///            values.
    ///    pReserved = Type: <b>UINT*</b> Reserved. Applications must specify <b>NULL</b> when calling this method and handlers must
    ///                ignore this parameter when called.
    ///    pszName = Type: <b>LPSTR</b> The address of the buffer to receive the null-terminated string being retrieved.
    ///    cchMax = Type: <b>UINT</b> Size of the buffer, in characters, to receive the null-terminated string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCommandString(size_t idCmd, uint uType, uint* pReserved, char* pszName, uint cchMax);
}

///Exposes methods that either create or merge a shortcut (context) menu associated with a Shell object. Extends
///IContextMenu by adding a method that allows client objects to handle messages associated with owner-drawn menu items.
@GUID("000214F4-0000-0000-C000-000000000046")
interface IContextMenu2 : IContextMenu
{
    ///Enables client objects of the IContextMenu interface to handle messages associated with owner-drawn menu items.
    ///Params:
    ///    uMsg = Type: <b>UINT</b> The message to be processed. In the case of some messages, such as WM_INITMENUPOPUP,
    ///           WM_DRAWITEM, WM_MENUCHAR, or WM_MEASUREITEM, the client object being called may provide owner-drawn menu
    ///           items.
    ///    wParam = Type: <b>WPARAM</b> Additional message information. The value of this parameter depends on the value of the
    ///             <i>uMsg</i> parameter.
    ///    lParam = Type: <b>LPARAM</b> Additional message information. The value of this parameter depends on the value of the
    ///             <i>uMsg</i> parameter.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT HandleMenuMsg(uint uMsg, WPARAM wParam, LPARAM lParam);
}

///Exposes methods that either create or merge a shortcut menu associated with a Shell object. Allows client objects to
///handle messages associated with owner-drawn menu items and extends IContextMenu2 by accepting a return value from
///that message handling.
@GUID("BCFCE0A0-EC17-11D0-8D10-00A0C90F2719")
interface IContextMenu3 : IContextMenu2
{
    ///Allows client objects of the IContextMenu3 interface to handle messages associated with owner-drawn menu items.
    ///Params:
    ///    uMsg = Type: <b>UINT</b> The message to be processed. In the case of some messages, such as WM_INITMENUPOPUP,
    ///           WM_DRAWITEM, WM_MENUCHAR, or WM_MEASUREITEM, the client object being called may provide owner-drawn menu
    ///           items.
    ///    wParam = Type: <b>WPARAM</b> Additional message information. The value of this parameter depends on the value of the
    ///             <i>uMsg</i> parameter.
    ///    lParam = Type: <b>LPARAM</b> Additional message information. The value of this parameter depends on the value of the
    ///             <i>uMsg</i> parameter.
    ///    plResult = Type: <b>LRESULT*</b> The address of an <b>LRESULT</b> value that the owner of the menu will return from the
    ///               message. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT HandleMenuMsg2(uint uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);
}

///Exposes methods that set a given state or parameter related to the command verb, as well as a method to invoke that
///verb.
@GUID("7F9185B0-CB92-43C5-80A9-92277A4F7B54")
interface IExecuteCommand : IUnknown
{
    ///Sets a value based on the current state of the keys CTRL and SHIFT.
    ///Params:
    ///    grfKeyState = Type: <b>DWORD</b> One or both of the following flags to indicate whether the key is pressed.
    HRESULT SetKeyState(uint grfKeyState);
    ///Provides parameter values for the verb.
    ///Params:
    ///    pszParameters = Type: <b>LPCWSTR</b> Pointer to a string that contains parameter values. The format and contents of this
    ///                    string is determined by the verb that is to be invoked.
    HRESULT SetParameters(const(wchar)* pszParameters);
    ///Sets the coordinates of a point used for display.
    ///Params:
    ///    pt = Type: <b>POINT</b> The screen coordinates at which the user right-clicked to invoke the shortcut menu from
    ///         which a command was chosen. Applications can use this information to present any UI. This is particularly
    ///         useful in a multi-monitor situation. The default position is the center of the default monitor.
    HRESULT SetPosition(POINT pt);
    ///Sets the specified window's visual state.
    ///Params:
    ///    nShow = Type: <b>int</b> One of the following flags to indicate how the window is to be shown.
    HRESULT SetShowWindow(int nShow);
    ///Indicates whether any UI associated with the selected Shell item should be displayed.
    ///Params:
    ///    fNoShowUI = Type: <b>BOOL</b> <b>TRUE</b> to block display of any associated UI; <b>FALSE</b> to display the UI.
    ///                <b>FALSE</b> is the default value.
    HRESULT SetNoShowUI(BOOL fNoShowUI);
    ///Sets a new working directory.
    ///Params:
    ///    pszDirectory = Type: <b>LPCWSTR</b> Pointer to a null-terminated string with the fully qualified path of the new working
    ///                   directory. If this value is <b>NULL</b>, the current working directory is used.
    HRESULT SetDirectory(const(wchar)* pszDirectory);
    ///Invoke the verb on the selected items. Call this method after you have called the other methods of this
    ///interface.
    HRESULT Execute();
}

///Exposes a method that initializes Shell folder objects.
@GUID("000214EA-0000-0000-C000-000000000046")
interface IPersistFolder : IPersist
{
    ///Instructs a Shell folder object to initialize itself based on the information passed.
    ///Params:
    ///    pidl = Type: <b>LPCITEMIDLIST</b> The address of the ITEMIDLIST (item identifier list) structure that specifies the
    ///           absolute location of the folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(ITEMIDLIST* pidl);
}

///A free-threaded interface that can be exposed by an object to allow operations to be performed on a background
///thread. For example, if the IExtractImage::GetLocation method returns E_PENDING, the calling application is permitted
///to extract the image on a background thread.
@GUID("85788D00-6807-11D0-B810-00C04FD706EC")
interface IRunnableTask : IUnknown
{
    ///Requests that a task begin.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns one of the following two codes. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Execution is complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PENDING</b></dt> </dl> </td> <td
    ///    width="60%"> Execution is suspended. </td> </tr> </table>
    ///    
    HRESULT Run();
    ///Requests that a task be stopped.
    ///Params:
    ///    bWait = Type: <b>BOOL</b> Not currently used.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Kill(BOOL bWait);
    ///Requests that a task be suspended.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if successful, or standard COM-defined error codes otherwise.
    ///    
    HRESULT Suspend();
    ///Requests that a task resume.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or standard COM-defined error codes otherwise.
    ///    
    HRESULT Resume();
    ///Requests information on the state of a task, such as thumbnail extraction.
    ///Returns:
    ///    Type: <b>LONG</b> Returns one of the following values to indicate the current execution state. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>IRTIR_TASK_NOT_RUNNING</b></dt> </dl> </td> <td width="60%"> Extraction has not yet started. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>IRTIR_TASK_RUNNING</b></dt> </dl> </td> <td width="60%"> The task is
    ///    running. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>IRTIR_TASK_SUSPENDED</b></dt> </dl> </td> <td
    ///    width="60%"> The task is suspended. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>IRTIR_TASK_PENDING</b></dt>
    ///    </dl> </td> <td width="60%"> IRunnableTask::Kill has been called on the thread, but the thread has not yet
    ///    completely shut down. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>IRTIR_TASK_FINISHED</b></dt> </dl> </td>
    ///    <td width="60%"> The task is finished. </td> </tr> </table>
    ///    
    uint    IsRunning();
}

///<p class="CCE_Message">[<b>IShellTaskScheduler</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Exposes methods that enable
///interaction with, and control of, a task scheduler.
@GUID("6CCB7BE0-6807-11D0-B810-00C04FD706EC")
interface IShellTaskScheduler : IUnknown
{
    ///Adds a task to the scheduler's background queue.
    ///Params:
    ///    prt = Type: <b>IRunnableTask*</b> A pointer to an instance of an IRunnableTask interface representing the task to
    ///          add to the queue.
    ///    rtoid = Type: <b>REFTASKOWNERID</b> A GUID identifying the owner of the task. This information can be used to group
    ///            tasks for later counting or removal by owner.
    ///    lParam = Type: <b>DWORD_PTR</b> A pointer to a user-defined <b>DWORD</b> value allowing the task to be identified
    ///             within the tasks owned by <i>rtoid</i>. This is used to identify single tasks or to subgroup them, for
    ///             instance associating the task with a particular item such as an item in a ListView. This parameter can be
    ///             zero.
    ///    dwPriority = Type: <b>DWORD</b> One of the following values assigning the task's priority. Response to this priority
    ///                 depends on the cooperation of the other tasks being executed. New tasks are inserted in the queue in priority
    ///                 order. If a task of a low priority is currently under execution when a higher priority task is added, the
    ///                 scheduler attempts to suspend the task under execution. That lower priority task is resumed when the higher
    ///                 priority task(s) are completed.
    HRESULT AddTask(IRunnableTask prt, const(GUID)* rtoid, size_t lParam, uint dwPriority);
    ///Removes tasks from the scheduler's background queue.
    ///Params:
    ///    rtoid = Type: <b>REFTASKOWNERID</b> A GUID identifying the owner of the tasks to remove.
    ///    lParam = Type: <b>DWORD_PTR</b> A pointer to a user-defined <b>DWORD</b> value that allows the task to be identified
    ///             within the tasks owned by <i>rtoid</i>. Set this value to 0 to remove all tasks for the owner specified by
    ///             <i>rtoid</i>.
    ///    bWaitIfRunning = Type: <b>BOOL</b> <b>TRUE</b> if you want a currently running task to complete before removing it,
    ///                     <b>FALSE</b> otherwise.
    HRESULT RemoveTasks(const(GUID)* rtoid, size_t lParam, BOOL bWaitIfRunning);
    ///Counts tasks with the same owner ID in the scheduler's queue.
    ///Params:
    ///    rtoid = Type: <b>REFTASKOWNERID</b> A GUID identifying the owner of the tasks. Supplying a specific ID will count
    ///            only those tasks tagged with that owner ID. To count all items in the queue, pass TOID_NULL.
    uint    CountTasks(const(GUID)* rtoid);
    ///Sets the release status and background thread timeout for the current task.
    ///Params:
    ///    dwReleaseStatus = Type: <b>DWORD</b> The following flag or 0.
    ///    dwThreadTimeout = Type: <b>DWORD</b> Not used.
    HRESULT Status(uint dwReleaseStatus, uint dwThreadTimeout);
}

///Exposes methods that obtain information from Shell folder objects.
@GUID("1AC3D9F0-175C-11D1-95BE-00609797EA4F")
interface IPersistFolder2 : IPersistFolder
{
    ///Gets the ITEMIDLIST for the folder object.
    ///Params:
    ///    ppidl = Type: <b>LPITEMIDLIST*</b> The address of an ITEMIDLIST pointer. This PIDL represents the absolute location
    ///            of the folder and must be relative to the desktop. This is typically a copy of the PIDL passed to Initialize.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCurFolder(ITEMIDLIST** ppidl);
}

///Extends the IPersistFolder and IPersistFolder2 interfaces by allowing a folder object to implement nondefault
///handling of folder shortcuts.
@GUID("CEF04FDF-FE72-11D2-87A5-00C04F6837CF")
interface IPersistFolder3 : IPersistFolder2
{
    ///Initializes a folder and specifies its location in the namespace. If the folder is a shortcut, this method also
    ///specifies the location of the target folder.
    ///Params:
    ///    pbc = Type: <b>IBindCtx*</b> A pointer to an IBindCtx object that provides the bind context. This parameter can be
    ///          <b>NULL</b>.
    ///    pidlRoot = Type: <b>LPCITEMIDLIST</b> A pointer to a fully qualified PIDL that specifies the absolute location of a
    ///               folder or folder shortcut. The calling application is responsible for allocating and freeing this PIDL.
    ///    ppfti = Type: <b>const PERSIST_FOLDER_TARGET_INFO*</b> A pointer to a PERSIST_FOLDER_TARGET_INFO structure that
    ///            specifies the location of the target folder and its attributes. If <i>ppfti</i> points to a valid structure,
    ///            <i>pidlRoot</i> represents a folder shortcut. If <i>ppfti</i> is set to <b>NULL</b>, <i>pidlRoot</i>
    ///            represents a normal folder. In that case, <b>InitializeEx</b> should behave as if Initialize had been called.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InitializeEx(IBindCtx pbc, ITEMIDLIST* pidlRoot, const(PERSIST_FOLDER_TARGET_INFO)* ppfti);
    ///Provides the location and attributes of a folder shortcut's target folder.
    ///Params:
    ///    ppfti = Type: <b>PERSIST_FOLDER_TARGET_INFO*</b> A pointer to a PERSIST_FOLDER_TARGET_INFO structure used to return
    ///            the target folder's location and attributes.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO* ppfti);
}

///Exposes methods that are used to persist item identifier lists.
@GUID("1079ACFC-29BD-11D3-8E0D-00C04F6837D5")
interface IPersistIDList : IPersist
{
    ///Sets a persisted item identifier list.
    ///Params:
    ///    pidl = Type: <b>LPCITEMIDLIST</b> A pointer to the item identifier list to set.
    HRESULT SetIDList(ITEMIDLIST* pidl);
    ///Gets an item identifier list.
    ///Params:
    ///    ppidl = Type: <b>LPITEMIDLIST*</b> The address of a pointer to the item identifier list to get.
    HRESULT GetIDList(ITEMIDLIST** ppidl);
}

///Exposes a standard set of methods used to enumerate the pointers to item identifier lists (PIDLs) of the items in a
///Shell folder. When a folder's IShellFolder::EnumObjects method is called, it creates an enumeration object and passes
///a pointer to the object's <b>IEnumIDList</b> interface back to the calling application.
@GUID("000214F2-0000-0000-C000-000000000046")
interface IEnumIDList : IUnknown
{
    ///Retrieves the specified number of item identifiers in the enumeration sequence and advances the current position
    ///by the number of items retrieved.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of elements in the array referenced by the <i>rgelt</i> parameter.
    ///    rgelt = Type: <b>LPITEMIDLIST*</b> The address of a pointer to an array of ITEMIDLIST pointers that receive the item
    ///            identifiers. The implementation must allocate these item identifiers using CoTaskMemAlloc. The calling
    ///            application is responsible for freeing the item identifiers using CoTaskMemFree. The ITEMIDLIST structures
    ///            returned in the array are relative to the IShellFolder being enumerated.
    ///    pceltFetched = Type: <b>ULONG*</b> A pointer to a value that receives a count of the item identifiers actually returned in
    ///                   <i>rgelt</i>. The count can be smaller than the value specified in the <i>celt</i> parameter. This parameter
    ///                   can be <b>NULL</b> on entry only if <i>celt</i> = 1, because in that case the method can only retrieve one
    ///                   (S_OK) or zero (S_FALSE) items.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the method successfully retrieved the requested <i>celt</i> elements.
    ///    This method only returns S_OK if the full count of requested items are successfully retrieved. S_FALSE
    ///    indicates that more items were requested than remained in the enumeration. The value pointed to by the
    ///    <i>pceltFetched</i> parameter specifies the actual number of items retrieved. Note that the value will be 0
    ///    if there are no more items to retrieve. Returns a COM-defined error value otherwise.
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips the specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of item identifiers to skip.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT Skip(uint celt);
    ///Returns to the beginning of the enumeration sequence.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT Reset();
    ///Creates a new item enumeration object with the same contents and state as the current one.
    ///Params:
    ///    ppenum = Type: <b>IEnumIDList**</b> The address of a pointer to the new enumeration object. The calling application
    ///             must eventually free the new object by calling its Release member function.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT Clone(IEnumIDList* ppenum);
}

///Exposes a standard set of methods that enumerate the pointers to item identifier lists (PIDLs) of the items in a
///Shell folder.
@GUID("D0191542-7954-4908-BC06-B2360BBE45BA")
interface IEnumFullIDList : IUnknown
{
    ///Retrieves a specified number of IDLIST_ABSOLUTE items.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of items referenced in the array referenced by the <i>rgelt</i> parameter.
    ///    rgelt = Type: <b>PIDLIST_ABSOLUTE*</b> On success, contains a PIDL array. The implementation must allocate these item
    ///            identifiers using CoTaskMemAlloc. The calling application is responsible for freeing the item identifiers
    ///            using CoTaskMemFree.
    ///    pceltFetched = Type: <b>ULONG*</b> On success, contains a pointer to a value that receives a count of the absolute item
    ///                   identifiers actually returned in <i>rgelt</i>. The count can be smaller than the value specified in the
    ///                   <i>celt</i> parameter. This parameter can be <b>NULL</b> on entry only if <i>celt</i> is 1, because in that
    ///                   case the method can only retrieve one (S_OK) or zero (S_FALSE) items.
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips a specified number of IDLIST_ABSOLUTE items.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of items to skip.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Skip(uint celt);
    ///Returns the enumerator to the beginning of the enumeration sequence.
    HRESULT Reset();
    ///Creates a new item enumeration object with the same contents and state as the current one.
    ///Params:
    ///    ppenum = Type: <b>IEnumFullIDList**</b> On success, contains the address of an IEnumFullIDList interface pointer.
    HRESULT Clone(IEnumFullIDList* ppenum);
}

///Exposed methods to handle file sync operations between a local copy and a server copy of a file.
@GUID("D97B5AAC-C792-433C-975D-35C4EADC7A9D")
interface IFileSyncMergeHandler : IUnknown
{
    ///Merges changes between the local copy and server copy of a file.
    ///Params:
    ///    localFilePath = Type: <b>LPCWSTR</b> A pointer to a string containing the path to the local copy of the file.
    ///    serverFilePath = Type: <b>LPCWSTR</b> A pointer to a string containing the network path to the server copy of the file.
    ///    updateStatus = Type: <b>MERGE_UPDATE_STATUS*</b> When this method returns, contains a pointer to one of the following values
    ///                   indicating status of the merge process.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Merge(const(wchar)* localFilePath, const(wchar)* serverFilePath, MERGE_UPDATE_STATUS* updateStatus);
    ///Displays a UI to resolve conflicts between the local copy and server copy of a file.
    ///Params:
    ///    localFilePath = Type: <b>LPCWSTR</b> The path of the file with the merge conflict.
    ///    monitorToDisplayOn = Type: <b>HMONITOR</b> Indicates the monitor on which to display the UI.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ShowResolveConflictUIAsync(const(wchar)* localFilePath, ptrdiff_t monitorToDisplayOn);
}

///Exposes methods that get and set enumeration modes of a parsed item.
@GUID("6A9D9026-0E6E-464C-B000-42ECC07DE673")
interface IObjectWithFolderEnumMode : IUnknown
{
    ///Sets the enumeration mode of the parsed item.
    ///Params:
    ///    feMode = Type: <b>FOLDER_ENUM_MODE</b> One of the FOLDER_ENUM_MODE values that specify the enumeration mode.
    HRESULT SetMode(FOLDER_ENUM_MODE feMode);
    ///Retrieves the enumeration mode of the parsed item.
    ///Params:
    ///    pfeMode = Type: <b>FOLDER_ENUM_MODE*</b> Pointer to a value that, when this method returns successfully, receives one
    ///              of the FOLDER_ENUM_MODE values specifying the enumeration mode.
    HRESULT GetMode(FOLDER_ENUM_MODE* pfeMode);
}

///When the **STR_PARSE_AND_CREATE_ITEM** [binding context](/windows/win32/shell/str-constants) is specified, this
///interface gets or sets the stored Shell items that
///[SHCreateItemFromParsingName](./nf-shobjidl_core-shcreateitemfromparsingname.md) creates from a parsing name.
@GUID("67EFED0E-E827-4408-B493-78F3982B685C")
interface IParseAndCreateItem : IUnknown
{
    ///Sets a Shell item that [SHCreateItemFromParsingName](./nf-shobjidl_core-shcreateitemfromparsingname.md) created
    ///from a parsing name.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> Pointer to an IShellItem object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetItem(IShellItem psi);
    ///Gets a stored Shell item that [SHCreateItemFromParsingName](./nf-shobjidl_core-shcreateitemfromparsingname.md)
    ///created from a parsing name.
    ///Params:
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>, typically
    ///           IID_IShellItem.
    ///    ppv = Type: <b>void**</b> When this method returns successfully, contains the interface pointer requested in
    ///          <i>riid</i>. This is typically IShellItem.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetItem(const(GUID)* riid, void** ppv);
}

///Exposed by all Shell namespace folder objects, its methods are used to manage folders.
@GUID("000214E6-0000-0000-C000-000000000046")
interface IShellFolder : IUnknown
{
    ///Translates the display name of a file object or a folder into an item identifier list.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> A window handle. The client should provide a window handle if it displays a dialog or
    ///           message box. Otherwise set <i>hwnd</i> to <b>NULL</b>.
    ///    pbc = Type: <b>IBindCtx*</b> Optional. A pointer to a bind context used to pass parameters as inputs and outputs to
    ///          the parsing function. These passed parameters are often specific to the data source and are documented by the
    ///          data source owners. For example, the file system data source accepts the name being parsed (as a
    ///          WIN32_FIND_DATA structure), using the STR_FILE_SYS_BIND_DATA bind context parameter.
    ///          STR_PARSE_PREFER_FOLDER_BROWSING can be passed to indicate that URLs are parsed using the file system data
    ///          source when possible. Construct a bind context object using CreateBindCtx and populate the values using
    ///          IBindCtx::RegisterObjectParam. See <b>Bind Context String Keys</b> for a complete list of these. If no data
    ///          is being passed to or received from the parsing function, this value can be <b>NULL</b>.
    ///    pszDisplayName = Type: <b>LPWSTR</b> A null-terminated Unicode string with the display name. Because each Shell folder defines
    ///                     its own parsing syntax, the form this string can take may vary. The desktop folder, for instance, accepts
    ///                     paths such as "C:\My Docs\My File.txt". It also will accept references to items in the namespace that have a
    ///                     GUID associated with them using the "::{GUID}" syntax. For example, to retrieve a fully qualified identifier
    ///                     list for the control panel from the desktop folder, you can use the following: ```cpp ::{CLSID for Control
    ///                     Panel}\::{CLSID for printers folder} ```
    ///    pchEaten = Type: <b>ULONG*</b> A pointer to a <b>ULONG</b> value that receives the number of characters of the display
    ///               name that was parsed. If your application does not need this information, set <i>pchEaten</i> to <b>NULL</b>,
    ///               and no value will be returned.
    ///    ppidl = Type: <b>PIDLIST_RELATIVE*</b> When this method returns, contains a pointer to the PIDL for the object. The
    ///            returned item identifier list specifies the item relative to the parsing folder. If the object associated
    ///            with <i>pszDisplayName</i> is within the parsing folder, the returned item identifier list will contain only
    ///            one SHITEMID structure. If the object is in a subfolder of the parsing folder, the returned item identifier
    ///            list will contain multiple <b>SHITEMID</b> structures. If an error occurs, <b>NULL</b> is returned in this
    ///            address. When it is no longer needed, it is the responsibility of the caller to free this resource by calling
    ///            CoTaskMemFree.
    ///    pdwAttributes = Type: <b>ULONG*</b> The value used to query for file attributes. If not used, it should be set to
    ///                    <b>NULL</b>. To query for one or more attributes, initialize this parameter with the SFGAO flags that
    ///                    represent the attributes of interest. On return, those attributes that are true <i>and</i> were requested
    ///                    will be set.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ParseDisplayName(HWND hwnd, IBindCtx pbc, const(wchar)* pszDisplayName, uint* pchEaten, 
                             ITEMIDLIST** ppidl, uint* pdwAttributes);
    ///Enables a client to determine the contents of a folder by creating an item identifier enumeration object and
    ///returning its IEnumIDList interface. The methods supported by that interface can then be used to enumerate the
    ///folder's contents.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> If user input is required to perform the enumeration, this window handle should be used by
    ///           the enumeration object as the parent window to take user input. An example would be a dialog box to ask for a
    ///           password or prompt the user to insert a CD or floppy disk. If <i>hwndOwner</i> is set to <b>NULL</b>, the
    ///           enumerator should not post any messages, and if user input is required, it should silently fail.
    ///    grfFlags = Type: <b>SHCONTF</b> Flags indicating which items to include in the enumeration. For a list of possible
    ///               values, see the SHCONTF enumerated type.
    ///    ppenumIDList = Type: <b>IEnumIDList**</b> The address that receives a pointer to the IEnumIDList interface of the
    ///                   enumeration object created by this method. If an error occurs or no suitable subobjects are found,
    ///                   <i>ppenumIDList</i> is set to <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <code>S_OK</code> if successful, or an error value otherwise. Some
    ///    implementations may also return <code>S_FALSE</code>, indicating that there are no children matching the
    ///    <i>grfFlags</i> that were passed in. If <code>S_FALSE</code> is returned, <i>ppenumIDList</i> is set to
    ///    <code>NULL</code>.
    ///    
    HRESULT EnumObjects(HWND hwnd, uint grfFlags, IEnumIDList* ppenumIDList);
    ///Retrieves a handler, typically the Shell folder object that implements IShellFolder for a particular item.
    ///Optional parameters that control the construction of the handler are passed in the bind context.
    ///Params:
    ///    pidl = Type: <b>PCUIDLIST_RELATIVE</b> The address of an ITEMIDLIST structure (PIDL) that identifies the subfolder.
    ///           This value can refer to an item at any level below the parent folder in the namespace hierarchy. The
    ///           structure contains one or more SHITEMID structures, followed by a terminating <b>NULL</b>.
    ///    pbc = Type: <b>IBindCtx*</b> A pointer to an IBindCtx interface on a bind context object that can be used to pass
    ///          parameters to the construction of the handler. If this parameter is not used, set it to <b>NULL</b>. Because
    ///          support for this parameter is optional for folder object implementations, some folders may not support the
    ///          use of bind contexts. Information that can be provided in the bind context includes a BIND_OPTS structure
    ///          that includes a <b>grfMode</b> member that indicates the access mode when binding to a stream handler. Other
    ///          parameters can be set and discovered using IBindCtx::RegisterObjectParam and IBindCtx::GetObjectParam.
    ///    riid = Type: <b>REFIID</b> The identifier of the interface to return. This may be <b>IID_IShellFolder</b>,
    ///           <b>IID_IStream</b>, or any other interface that identifies a particular handler.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the address of a pointer to the requested interface.
    ///          If an error occurs, a <b>NULL</b> pointer is returned at this address.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BindToObject(ITEMIDLIST* pidl, IBindCtx pbc, const(GUID)* riid, void** ppv);
    ///Requests a pointer to an object's storage interface.
    ///Params:
    ///    pidl = Type: <b>PCUIDLIST_RELATIVE</b> The address of an ITEMIDLIST structure that identifies the subfolder relative
    ///           to its parent folder. The structure must contain exactly one SHITEMID structure followed by a terminating
    ///           zero.
    ///    pbc = Type: <b>IBindCtx*</b> The optional address of an IBindCtx interface on a bind context object to be used
    ///          during this operation. If this parameter is not used, set it to <b>NULL</b>. Because support for <i>pbc</i>
    ///          is optional for folder object implementations, some folders may not support the use of bind contexts.
    ///    riid = Type: <b>REFIID</b> The IID of the requested storage interface. To retrieve an IStream, IStorage, or
    ///           IPropertySetStorage interface pointer, set <i>riid</i> to <b>IID_IStream</b>, <b>IID_IStorage</b>, or
    ///           <b>IID_IPropertySetStorage</b>, respectively.
    ///    ppv = Type: <b>void**</b> The address that receives the interface pointer specified by <i>riid</i>. If an error
    ///          occurs, a <b>NULL</b> pointer is returned in this address.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BindToStorage(ITEMIDLIST* pidl, IBindCtx pbc, const(GUID)* riid, void** ppv);
    ///Determines the relative order of two file objects or folders, given their item identifier lists.
    ///Params:
    ///    lParam = Type: <b>LPARAM</b> A value that specifies how the comparison should be performed. The lower sixteen bits of
    ///             <i>lParam</i> define the sorting rule. Most applications set the sorting rule to the default value of zero,
    ///             indicating that the two items should be compared by name. The system does not define any other sorting rules.
    ///             Some folder objects might allow calling applications to use the lower sixteen bits of <i>lParam</i> to
    ///             specify folder-specific sorting rules. The rules and their associated <i>lParam</i> values are defined by the
    ///             folder. When the system folder view object calls <b>IShellFolder::CompareIDs</b>, the lower sixteen bits of
    ///             <i>lParam</i> are used to specify the column to be used for the comparison. The upper sixteen bits of
    ///             <i>lParam</i> are used for flags that modify the sorting rule. The system currently defines these modifier
    ///             flags.
    ///    pidl1 = Type: <b>PCUIDLIST_RELATIVE</b> A pointer to the first item's ITEMIDLIST structure. It will be relative to
    ///            the folder. This <b>ITEMIDLIST</b> structure can contain more than one element; therefore, the entire
    ///            structure must be compared, not just the first element.
    ///    pidl2 = Type: <b>PCUIDLIST_RELATIVE</b> A pointer to the second item's ITEMIDLIST structure. It will be relative to
    ///            the folder. This <b>ITEMIDLIST</b> structure can contain more than one element; therefore, the entire
    ///            structure must be compared, not just the first element.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method is successful, the CODE field of the <b>HRESULT</b> contains one of the
    ///    following values. For information regarding the extraction of the CODE field from the returned
    ///    <b>HRESULT</b>, see Remarks. If this method is unsuccessful, it returns a COM error code. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>Negative</b></dt> </dl>
    ///    </td> <td width="60%"> A negative return value indicates that the first item should precede the second (pidl1
    ///    &lt; pidl2). </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Positive</b></dt> </dl> </td> <td width="60%"> A
    ///    positive return value indicates that the first item should follow the second (pidl1 &gt; pidl2). </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>Zero</b></dt> </dl> </td> <td width="60%"> A return value of zero indicates
    ///    that the two items are the same (pidl1 = pidl2). </td> </tr> </table>
    ///    
    HRESULT CompareIDs(LPARAM lParam, ITEMIDLIST* pidl1, ITEMIDLIST* pidl2);
    ///Requests an object that can be used to obtain information from or interact with a folder object.
    ///Params:
    ///    hwndOwner = Type: <b>HWND</b> A handle to the owner window. If you have implemented a custom folder view object, your
    ///                folder view window should be created as a child of <i>hwndOwner</i>.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>, typically
    ///           IID_IShellView.
    ///    ppv = Type: <b>void**</b> When this method returns successfully, contains the interface pointer requested in
    ///          <i>riid</i>. This is typically IShellView. See the Remarks section for more details.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateViewObject(HWND hwndOwner, const(GUID)* riid, void** ppv);
    ///Gets the attributes of one or more file or folder objects contained in the object represented by IShellFolder.
    ///Params:
    ///    cidl = Type: <b>UINT</b> The number of items from which to retrieve attributes.
    ///    apidl = Type: <b>PCUITEMID_CHILD_ARRAY*</b> The address of an array of pointers to ITEMIDLIST structures, each of
    ///            which uniquely identifies an item relative to the parent folder. Each <b>ITEMIDLIST</b> structure must
    ///            contain exactly one SHITEMID structure followed by a terminating zero.
    ///    rgfInOut = Type: <b>SFGAOF*</b> Pointer to a single <b>ULONG</b> value that, on entry, contains the bitwise SFGAO
    ///               attributes that the calling application is requesting. On exit, this value contains the requested attributes
    ///               that are common to all of the specified items.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAttributesOf(uint cidl, char* apidl, uint* rgfInOut);
    ///Gets an object that can be used to carry out actions on the specified file objects or folders.
    ///Params:
    ///    hwndOwner = Type: <b>HWND</b> A handle to the owner window that the client should specify if it displays a dialog box or
    ///                message box.
    ///    cidl = Type: <b>UINT</b> The number of file objects or subfolders specified in the <i>apidl</i> parameter.
    ///    apidl = Type: <b>PCUITEMID_CHILD_ARRAY</b> The address of an array of pointers to ITEMIDLIST structures, each of
    ///            which uniquely identifies a file object or subfolder relative to the parent folder. Each item identifier list
    ///            must contain exactly one SHITEMID structure followed by a terminating zero.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>. This can be any
    ///           valid interface identifier that can be created for an item. The most common identifiers used by the Shell are
    ///           listed in the comments at the end of this reference.
    ///    rgfReserved = Type: <b>UINT*</b> Reserved.
    ///    ppv = Type: <b>void**</b> When this method returns successfully, contains the interface pointer requested in
    ///          <i>riid</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetUIObjectOf(HWND hwndOwner, uint cidl, char* apidl, const(GUID)* riid, uint* rgfReserved, void** ppv);
    ///Retrieves the display name for the specified file object or subfolder.
    ///Params:
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> PIDL that uniquely identifies the file object or subfolder relative to the
    ///           parent folder.
    ///    uFlags = Type: <b>SHGDNF</b> Flags used to request the type of display name to return. For a list of possible values,
    ///             see the SHGDNF enumerated type.
    ///    pName = Type: <b>STRRET*</b> When this method returns, contains a pointer to a STRRET structure in which to return
    ///            the display name. The type of name returned in this structure can be the requested type, but the Shell folder
    ///            might return a different type.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDisplayNameOf(ITEMIDLIST* pidl, uint uFlags, STRRET* pName);
    ///Sets the display name of a file object or subfolder, changing the item identifier in the process.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> A handle to the owner window of any dialog or message box that the client displays.
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> A pointer to an ITEMIDLIST structure that uniquely identifies the file object or
    ///           subfolder relative to the parent folder. The structure must contain exactly one SHITEMID structure followed
    ///           by a terminating zero.
    ///    pszName = Type: <b>LPCWSTR</b> A pointer to a null-terminated string that specifies the new display name.
    ///    uFlags = Type: <b>SHGDNF</b> Flags that indicate the type of name specified by the <i>pszName</i> parameter. For a
    ///             list of possible values and combinations of values, see SHGDNF.
    ///    ppidlOut = Type: <b>PITEMID_CHILD*</b> Optional. If specified, the address of a pointer to an ITEMIDLIST structure that
    ///               receives the <b>ITEMIDLIST</b> of the renamed item. The caller requests this value by passing a non-null
    ///               <i>ppidlOut</i>. Implementations of <b>IShellFolder::SetNameOf</b> must return a pointer to the new
    ///               <b>ITEMIDLIST</b> in the <i>ppidlOut</i> parameter.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetNameOf(HWND hwnd, ITEMIDLIST* pidl, const(wchar)* pszName, uint uFlags, ITEMIDLIST** ppidlOut);
}

///A standard OLE enumerator used by a client to determine the available search objects for a folder.
@GUID("0E700BE1-9DB6-11D1-A1CE-00C04FD75D13")
interface IEnumExtraSearch : IUnknown
{
    ///Used to request information on one or more search objects.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of search objects to be enumerated, starting from the current object. If
    ///           <i>celt</i> is too large, the method should stop and return the actual number of search objects in
    ///           <i>pceltFetched</i>.
    ///    rgelt = Type: <b>EXTRASEARCH*</b> A pointer to an array of <i>pceltFetched</i> EXTRASEARCH structures containing
    ///            information on the enumerated objects.
    ///    pceltFetched = Type: <b>ULONG*</b> The number of objects actually enumerated. This may be less than <i>celt</i>.
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skip a specified number of objects.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of objects to skip.
    HRESULT Skip(uint celt);
    ///Used to reset the enumeration index to zero.
    HRESULT Reset();
    ///Used to request a duplicate of the enumerator object to preserve its current state.
    ///Params:
    ///    ppenum = Type: <b>IEnumExtraSearch**</b> A pointer to the IEnumExtraSearch interface of a new enumerator object.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error code otherwise.
    ///    
    HRESULT Clone(IEnumExtraSearch* ppenum);
}

///Extends the capabilities of IShellFolder. Its methods provide a variety of information about the contents of a Shell
///folder.
@GUID("93F2F68C-1D1B-11D3-A30E-00C04F79ABD1")
interface IShellFolder2 : IShellFolder
{
    ///Returns the globally unique identifier (GUID) of the default search object for the folder.
    ///Params:
    ///    pguid = Type: <b>GUID*</b> The GUID of the default search object.
    HRESULT GetDefaultSearchGUID(GUID* pguid);
    ///Requests a pointer to an interface that allows a client to enumerate the available search objects.
    ///Params:
    ///    ppenum = Type: <b>IEnumExtraSearch**</b> The address of a pointer to an enumerator object's IEnumExtraSearch
    ///             interface.
    HRESULT EnumSearches(IEnumExtraSearch* ppenum);
    ///Gets the default sorting and display columns.
    ///Params:
    ///    dwRes = Type: <b>DWORD</b> Reserved. Set to zero.
    ///    pSort = Type: <b>ULONG*</b> A pointer to a value that receives the index of the default sorted column.
    ///    pDisplay = Type: <b>ULONG*</b> A pointer to a value that receives the index of the default display column.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
    ///    
    HRESULT GetDefaultColumn(uint dwRes, uint* pSort, uint* pDisplay);
    ///Gets the default state for a specified column.
    ///Params:
    ///    iColumn = Type: <b>UINT</b> An integer that specifies the column number.
    ///    pcsFlags = Type: <b>SHCOLSTATEF*</b> A pointer to a value that contains flags that indicate the default column state.
    ///               This parameter can include a combination of the following flags.
    HRESULT GetDefaultColumnState(uint iColumn, uint* pcsFlags);
    ///Gets detailed information, identified by a property set identifier (FMTID) and a property identifier (PID), on an
    ///item in a Shell folder.
    ///Params:
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> A PIDL of the item, relative to the parent folder. This method accepts only
    ///           single-level PIDLs. The structure must contain exactly one SHITEMID structure followed by a terminating zero.
    ///           This value cannot be <b>NULL</b>.
    ///    pscid = Type: <b>const SHCOLUMNID*</b> A pointer to an SHCOLUMNID structure that identifies the column.
    ///    pv = Type: <b>VARIANT*</b> A pointer to a <b>VARIANT</b> with the requested information. The value is fully typed.
    ///         The value returned for properties from the property system must conform to the type specified in that
    ///         property definition's typeInfo as the <i>legacyType</i> attribute.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDetailsEx(ITEMIDLIST* pidl, const(PROPERTYKEY)* pscid, VARIANT* pv);
    ///Gets detailed information, identified by a column index, on an item in a Shell folder.
    ///Params:
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> PIDL of the item for which you are requesting information. This method accepts
    ///           only single-level PIDLs. The structure must contain exactly one SHITEMID structure followed by a terminating
    ///           zero. If this parameter is set to <b>NULL</b>, the title of the information field specified by <i>iColumn</i>
    ///           is returned.
    ///    iColumn = Type: <b>UINT</b> The zero-based index of the desired information field. It is identical to the column number
    ///              of the information as it is displayed in a Windows Explorer Details view.
    ///    psd = Type: <b>SHELLDETAILS*</b> A pointer to a SHELLDETAILS structure that contains the information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDetailsOf(ITEMIDLIST* pidl, uint iColumn, SHELLDETAILS* psd);
    ///Converts a column to the appropriate property set ID (FMTID) and property ID (PID).
    ///Params:
    ///    iColumn = Type: <b>UINT</b> The column ID.
    ///    pscid = Type: <b>SHCOLUMNID*</b> A pointer to an SHCOLUMNID structure containing the FMTID and PID.
    HRESULT MapColumnToSCID(uint iColumn, PROPERTYKEY* pscid);
}

///Exposes methods that present a view in the Windows Explorer or folder windows.
@GUID("000214E3-0000-0000-C000-000000000046")
interface IShellView : IOleWindow
{
    HRESULT TranslateAcceleratorA(MSG* pmsg);
    ///Enables or disables modeless dialog boxes. This method is not currently implemented.
    ///Params:
    ///    fEnable = Type: <b>BOOL</b> Nonzero to enable modeless dialog box windows or zero to disable them.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT EnableModeless(BOOL fEnable);
    ///Called when the activation state of the view window is changed by an event that is not caused by the Shell view
    ///itself. For example, if the TAB key is pressed when the tree has the focus, the view should be given the focus.
    ///Params:
    ///    uState = Type: <b>UINT</b> Flag specifying the activation state of the window. This parameter can be one of the
    ///             following values.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT UIActivate(uint uState);
    ///Refreshes the view's contents in response to user input.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT Refresh();
    ///Creates a view window. This can be either the right pane of Windows Explorer or the client window of a folder
    ///window.
    ///Params:
    ///    psvPrevious = Type: <b>IShellView*</b> The address of the IShellView interface of the view window being exited. Views can
    ///                  use this parameter to communicate with a previous view of the same implementation. This interface can be used
    ///                  to optimize browsing between like views. This pointer may be <b>NULL</b>.
    ///    pfs = Type: <b>LPCFOLDERSETTINGS</b> The address of a FOLDERSETTINGS structure. The view should use this when
    ///          creating its view.
    ///    psb = Type: <b>IShellBrowser*</b> The address of the current instance of the IShellBrowser interface. The view
    ///          should call this interface's AddRef method and keep the interface pointer to allow communication with the
    ///          Windows Explorer window.
    ///    prcView = Type: <b>RECT*</b> The dimensions of the new view, in client coordinates.
    ///    phWnd = Type: <b>HWND*</b> The address of the window handle being created.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns a success code if successful, or a COM error code otherwise. Use the SUCCEEDED
    ///    and FAILED macros to determine whether the operation succeeded or failed.
    ///    
    HRESULT CreateViewWindow(IShellView psvPrevious, FOLDERSETTINGS* pfs, IShellBrowser psb, RECT* prcView, 
                             HWND* phWnd);
    ///Destroys the view window.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT DestroyViewWindow();
    ///Gets the current folder settings.
    ///Params:
    ///    pfs = Type: <b>LPFOLDERSETTINGS</b> The address of a FOLDERSETTINGS structure to receive the settings.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT GetCurrentInfo(FOLDERSETTINGS* pfs);
    ///Allows the view to add pages to the <b>Options</b> property sheet from the <b>View</b> menu.
    ///Params:
    ///    dwReserved = Type: <b>DWORD</b> Reserved.
    ///    pfn = Type: <b>LPFNADDPROPSHEETPAGE</b> The address of the callback function used to add the pages.
    ///    lparam = Type: <b>LPARAM</b> A value that must be passed as the callback function's <i>lparam</i> parameter.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT AddPropertySheetPages(uint dwReserved, LPFNSVADDPROPSHEETPAGE pfn, LPARAM lparam);
    ///Saves the Shell's view settings so the current state can be restored during a subsequent browsing session.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT SaveViewState();
    ///Changes the selection state of one or more items within the Shell view window.
    ///Params:
    ///    pidlItem = Type: <b>PCUITEMID_CHILD</b> The address of the ITEMIDLIST structure.
    ///    uFlags = Type: <b>UINT</b> One of the _SVSIF constants that specify the type of selection to apply.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SelectItem(ITEMIDLIST* pidlItem, uint uFlags);
    ///Gets an interface that refers to data presented in the view.
    ///Params:
    ///    uItem = Type: <b>UINT</b> The constants that refer to an aspect of the view. This parameter can be any one of the
    ///            _SVGIO constants.
    ///    riid = Type: <b>REFIID</b> The identifier of the COM interface being requested.
    ///    ppv = Type: <b>LPVOID*</b> The address that receives the interface pointer. If an error occurs, the pointer
    ///          returned must be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetItemObject(uint uItem, const(GUID)* riid, void** ppv);
}

///Extends the capabilities of IShellView.
@GUID("88E39E80-3578-11CF-AE69-08002B2E1262")
interface IShellView2 : IShellView
{
    ///Requests the current or default Shell view, together with all other valid view identifiers (VIDs) supported by
    ///this implementation of IShellView2.
    ///Params:
    ///    pvid = Type: <b>SHELLVIEWID*</b> A pointer to the GUID of the requested view. The following views are defined in
    ///           Shlguid.h.
    ///    uView = Type: <b>ULONG</b> The type of view requested.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a standard COM error code otherwise.
    ///    
    HRESULT GetView(GUID* pvid, uint uView);
    ///Used to request the creation of a new Shell view window. It can be either the right pane of Windows Explorer or
    ///the client window of a folder window.
    ///Params:
    ///    lpParams = Type: <b>LPSV2CVW2_PARAMS</b> A pointer to an SV2CVW2_PARAMS structure that defines the new view window.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns a success code if successful, or a COM error code otherwise. Use the SUCCEEDED
    ///    and FAILED macros to determine whether the operation succeeded or failed.
    ///    
    HRESULT CreateViewWindow2(SV2CVW2_PARAMS* lpParams);
    ///Used to change an item's identifier.
    ///Params:
    ///    pidlNew = Type: <b>PCUITEMID_CHILD</b> A pointer to an ITEMIDLIST structure. The current identifier is passed in and is
    ///              replaced by the new one.
    HRESULT HandleRename(ITEMIDLIST* pidlNew);
    ///Selects and positions an item in a Shell View.
    ///Params:
    ///    pidlItem = Type: <b>PCUITEMID_CHILD</b> A pointer to an ITEMIDLIST structure that uniquely identifies the item of
    ///               interest.
    ///    uFlags = Type: <b>UINT</b> One of the _SVSIF constants that specify the type of selection to apply.
    ///    ppt = Type: <b>POINT*</b> A pointer to a POINT structure containing the new position.
    HRESULT SelectAndPositionItem(ITEMIDLIST* pidlItem, uint uFlags, POINT* ppt);
}

///Exposes methods that retrieve information about a folder's display options, select specified items in that folder,
///and set the folder's view mode.
@GUID("CDE725B0-CCC9-4519-917E-325D72FAB4CE")
interface IFolderView : IUnknown
{
    ///Gets an address containing a value representing the folder's current view mode.
    ///Params:
    ///    pViewMode = Type: <b>UINT*</b> A pointer to a memory location at which to store the folder's current view mode. The value
    ///                at that address is one of the following FOLDERVIEWMODE values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCurrentViewMode(uint* pViewMode);
    ///Sets the selected folder's view mode.
    ///Params:
    ///    ViewMode = Type: <b>UINT</b> One of the following values from the FOLDERVIEWMODE enumeration.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCurrentViewMode(uint ViewMode);
    ///Gets the folder object.
    ///Params:
    ///    riid = Type: <b>REFIID</b> Reference to the desired IID to represent the folder.
    ///    ppv = Type: <b>VOID**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This
    ///          is typically IShellFolder or a related interface. This can also be an IShellItemArray with a single element.
    HRESULT GetFolder(const(GUID)* riid, void** ppv);
    ///Gets the identifier of a specific item in the folder view, by index.
    ///Params:
    ///    iItemIndex = Type: <b>int</b> The index of the item in the view.
    ///    ppidl = Type: <b>PITEMID_CHILD*</b> The address of a pointer to a PIDL containing the item's identifier information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Item(int iItemIndex, ITEMIDLIST** ppidl);
    ///Gets the number of items in the folder. This can be the number of all items, or a subset such as the number of
    ///selected items.
    ///Params:
    ///    uFlags = Type: <b>UINT</b> Flags from the _SVGIO enumeration that limit the count to certain types of items.
    ///    pcItems = Type: <b>int*</b> Pointer to an integer that receives the number of items (files and folders) displayed in
    ///              the folder view.
    HRESULT ItemCount(uint uFlags, int* pcItems);
    ///Gets the address of an enumeration object based on the collection of items in the folder view.
    ///Params:
    ///    uFlags = Type: <b>UINT</b> _SVGIO values that limit the enumeration to certain types of items.
    ///    riid = Type: <b>REFIID</b> Reference to the desired IID to represent the folder.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This
    ///          is typically an IEnumIDList, IDataObject, or IShellItemArray. If an error occurs, this value is <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Items(uint uFlags, const(GUID)* riid, void** ppv);
    ///Gets the index of an item in the folder's view which has been marked by using the SVSI_SELECTIONMARK in
    ///IFolderView::SelectItem.
    ///Params:
    ///    piItem = Type: <b>int*</b> A pointer to the index of the marked item.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSelectionMarkedItem(int* piItem);
    ///Gets the index of the item that currently has focus in the folder's view.
    ///Params:
    ///    piItem = Type: <b>int*</b> A pointer to the index of the item.
    HRESULT GetFocusedItem(int* piItem);
    ///Gets the position of an item in the folder's view.
    ///Params:
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> A pointer to an ITEMIDLIST interface.
    ///    ppt = Type: <b>POINT*</b> A pointer to a structure that receives the position of the item's upper-left corner.
    HRESULT GetItemPosition(ITEMIDLIST* pidl, POINT* ppt);
    ///Gets a POINT structure containing the width (x) and height (y) dimensions, including the surrounding white space,
    ///of an item.
    ///Params:
    ///    ppt = Type: <b>POINT*</b> A pointer to an existing structure to be filled with the current sizing dimensions of the
    ///          items in the folder's view.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSpacing(POINT* ppt);
    ///Gets a pointer to a POINT structure containing the default width (x) and height (y) measurements of an item,
    ///including the surrounding white space.
    ///Params:
    ///    ppt = Type: <b>POINT*</b> Pointer to an existing structure to be filled with the default sizing dimensions of the
    ///          items in the folder's view.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDefaultSpacing(POINT* ppt);
    ///Gets the current state of the folder's Auto Arrange mode.
    HRESULT GetAutoArrange();
    ///Selects an item in the folder's view.
    ///Params:
    ///    iItem = Type: <b>int</b> The index of the item to select in the folder's view.
    ///    dwFlags = Type: <b>DWORD</b> One of the _SVSIF constants that specify the type of selection to apply.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SelectItem(int iItem, uint dwFlags);
    ///Allows the selection and positioning of items visible in the folder's view.
    ///Params:
    ///    cidl = Type: <b>UINT</b> The number of items to select.
    ///    apidl = Type: <b>PCUITEMID_CHILD_ARRAY*</b> A pointer to an array of size <i>cidl</i> that contains the PIDLs of the
    ///            items.
    ///    apt = Type: <b>POINT*</b> A pointer to an array of <i>cidl</i> structures containing the locations each
    ///          corresponding element in <i>apidl</i> should be positioned.
    ///    dwFlags = Type: <b>DWORD</b> One of the _SVSIF constants that specifies the type of selection to apply.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SelectAndPositionItems(uint cidl, char* apidl, char* apt, uint dwFlags);
}

///Exposes methods that retrieve information about a folder's display options, select specified items in that folder,
///and set the folder's view mode.
@GUID("1AF3A467-214F-4298-908E-06B03E0B39F9")
interface IFolderView2 : IFolderView
{
    ///Groups the view by the given property key and direction.
    ///Params:
    ///    key = Type: <b>REFPROPERTYKEY</b> A PROPERTYKEY by which the view should be grouped.
    ///    fAscending = Type: <b>BOOL</b> A value of type <b>BOOL</b> to indicate sort order of the groups.
    HRESULT SetGroupBy(const(PROPERTYKEY)* key, BOOL fAscending);
    ///Retrieves the property and sort order used for grouping items in the folder display.
    ///Params:
    ///    pkey = Type: <b>PROPERTYKEY*</b> A pointer to the PROPERTYKEY by which the view is grouped.
    ///    pfAscending = Type: <b>BOOL*</b> A pointer to a value of type <b>BOOL</b> that indicates sort order of the groups.
    HRESULT GetGroupBy(PROPERTYKEY* pkey, int* pfAscending);
    ///<p class="CCE_Message">[This method is still implemented, but should be considered deprecated as of Windows 7. It
    ///might not be implemented in future versions of Windows. It cannot be used with items in search results or library
    ///views, so consider using the item's existing properties or, if applicable, emitting properties from your
    ///namespace or property handler. See Developing Property Handlers for Windows Search for more information.] Caches
    ///a property for an item in the view's property cache.
    ///Params:
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> A PIDL that identifies the item.
    ///    propkey = Type: <b>REFPROPERTYKEY</b> The PROPERTYKEY which is to be stored.
    ///    propvar = Type: <b>const PROPVARIANT*</b> A pointer to a PROPVARIANT structure in which the PROPERTYKEY is stored.
    ///Returns:
    ///    Type: <b>DEPRECATED_HRESULT</b> Returns <b>S_OK</b> if successful, or an error value otherwise.
    ///    
    HRESULT SetViewProperty(ITEMIDLIST* pidl, const(PROPERTYKEY)* propkey, const(PROPVARIANT)* propvar);
    ///<p class="CCE_Message">[This method is still implemented, but should be considered deprecated as of Windows 7. It
    ///might not be implemented in future versions of Windows. It cannot be used with items in search results or library
    ///views, so consider using the item's existing properties or, if applicable, emitting properties from your
    ///namespace or property handler. See Developing Property Handlers for Windows Search for more information.] Gets a
    ///property value for a given property key from the view's cache.
    ///Params:
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> A pointer to an item identifier list (PIDL).
    ///    propkey = Type: <b>REFPROPERTYKEY</b> The PROPERTYKEY to be retrieved.
    ///    ppropvar = Type: <b>PROPVARIANT*</b> A pointer to a PROPVARIANT structure in which the PROPERTYKEY is stored.
    ///Returns:
    ///    Type: <b>DEPRECATED_HRESULT</b> Returns <b>S_OK</b> if successful, or an error value otherwise. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success, the value is in the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The value is not in the view's cache. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetViewProperty(ITEMIDLIST* pidl, const(PROPERTYKEY)* propkey, PROPVARIANT* ppropvar);
    ///<p class="CCE_Message">[This method is still implemented, but should be considered deprecated as of Windows 7. It
    ///might not be implemented in future versions of Windows. It cannot be used with items in search results or library
    ///views, so consider using the item's existing properties or, if applicable, emitting properties from your
    ///namespace or property handler. See Developing Property Handlers for Windows Search for more information.] Set the
    ///list of tile properties for an item.
    ///Params:
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> A pointer to an item identifier list (PIDL).
    ///    pszPropList = Type: <b>LPCWSTR</b> A pointer to a Unicode string containing a list of properties.
    ///Returns:
    ///    Type: <b>DEPRECATED_HRESULT</b> Returns <b>S_OK</b> if successful, or an error value otherwise.
    ///    
    HRESULT SetTileViewProperties(ITEMIDLIST* pidl, const(wchar)* pszPropList);
    ///<p class="CCE_Message">[This method is still implemented, but should be considered deprecated as of Windows 7. It
    ///might not be implemented in future versions of Windows. It cannot be used with items in search results or library
    ///views, so consider using the item's existing properties or, if applicable, emitting properties from your
    ///namespace or property handler. See Developing Property Handlers for Windows Search for more information.] Sets
    ///the list of extended tile properties for an item.
    ///Params:
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> A pointer to an item identifier list (PIDL).
    ///    pszPropList = Type: <b>LPCWSTR</b> A pointer to a Unicode string containing a list of properties.
    ///Returns:
    ///    Type: <b>DEPRECATED_HRESULT</b> Returns <b>S_OK</b> if successful, or an error value otherwise.
    ///    
    HRESULT SetExtendedTileViewProperties(ITEMIDLIST* pidl, const(wchar)* pszPropList);
    ///Sets the default text to be used when there are no items in the view.
    ///Params:
    ///    iType = Type: <b>FVTEXTTYPE</b> This value should be set to the following flag.
    ///    pwszText = Type: <b>LPCWSTR</b> A pointer to a Unicode string that contains the text to be used.
    HRESULT SetText(FVTEXTTYPE iType, const(wchar)* pwszText);
    ///Sets and applies specified folder flags.
    ///Params:
    ///    dwMask = Type: <b>DWORD</b> The value of type <b>DWORD</b> that specifies the bitmask indicating which items in the
    ///             structure are desired or valid.
    ///    dwFlags = Type: <b>DWORD</b> The value of type <b>DWORD</b> that contains one or more FOLDERFLAGS.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCurrentFolderFlags(uint dwMask, uint dwFlags);
    ///Gets the currently applied folder flags.
    ///Params:
    ///    pdwFlags = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> with any FOLDERFLAGS that have been applied to the folder.
    HRESULT GetCurrentFolderFlags(uint* pdwFlags);
    ///Gets the count of sort columns currently applied to the view.
    ///Params:
    ///    pcColumns = Type: <b>int*</b> A pointer to an <b>int</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSortColumnCount(int* pcColumns);
    ///Sets and sorts the view by the given sort columns.
    ///Params:
    ///    rgSortColumns = Type: <b>const SORTCOLUMN*</b> A pointer to a SORTCOLUMN structure. The size of this structure is determined
    ///                    by <i>cColumns</i>.
    ///    cColumns = Type: <b>int</b> The count of columns to sort by.
    HRESULT SetSortColumns(char* rgSortColumns, int cColumns);
    ///Gets the sort columns currently applied to the view.
    ///Params:
    ///    rgSortColumns = Type: <b>const SORTCOLUMN*</b> A pointer to a SORTCOLUMN structure. The size of this structure is determined
    ///                    by <i>cColumns</i>.
    ///    cColumns = Type: <b>int</b> The count of columns to sort by.
    HRESULT GetSortColumns(char* rgSortColumns, int cColumns);
    ///Retrieves an object that represents a specified item.
    ///Params:
    ///    iItem = Type: <b>int</b> The zero-based index of the item to retrieve.
    ///    riid = Type: <b>REFIID</b> Reference to the desired IID to represent the item, such as IID_IShellItem.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This
    ///          is typically IShellItem.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the specified item was found, or an error value otherwise, including the
    ///    following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The index in <i>iItem</i> is out of range. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetItem(int iItem, const(GUID)* riid, void** ppv);
    ///Gets the next visible item in relation to a given index in the view.
    ///Params:
    ///    iStart = Type: <b>int</b> The zero-based position at which to start searching for a visible item.
    ///    fPrevious = Type: <b>BOOL</b> <b>TRUE</b> to find the first visible item before <i>iStart</i>. <b>FALSE</b> to find the
    ///                first visible item after <i>iStart</i>.
    ///    piItem = Type: <b>int*</b> When this method returns, contains a pointer to a value that receives the index of the
    ///             visible item in the view.
    HRESULT GetVisibleItem(int iStart, BOOL fPrevious, int* piItem);
    ///Locates the currently selected item at or after a given index.
    ///Params:
    ///    iStart = Type: <b>int</b> The index position from which to start searching for the currently selected item.
    ///    piItem = Type: <b>int*</b> A pointer to a value that receives the index of the item in the view.
    HRESULT GetSelectedItem(int iStart, int* piItem);
    ///Gets the current selection as an IShellItemArray.
    ///Params:
    ///    fNoneImpliesFolder = Type: <b>BOOL</b> If <b>TRUE</b>, this method returns an IShellItemArray containing the parent folder when
    ///                         there is no current selection.
    ///    ppsia = Type: <b>IShellItemArray**</b> The address of a pointer to an IShellItemArray.
    HRESULT GetSelection(BOOL fNoneImpliesFolder, IShellItemArray* ppsia);
    ///Gets the selection state including check state.
    ///Params:
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> A PIDL of the item.
    ///    pdwFlags = Type: <b>DWORD*</b> Zero or one of the following _SVSIF constants that specify the current type of selection:
    ///               <b>SVSI_FOCUSED</b>, <b>SVSI_SELECT</b>, <b>SVSI_CHECK</b>, or <b>SVSI_CHECK2</b>. Other <b>_SVSIF</b>
    ///               constants are not returned by this API.
    HRESULT GetSelectionState(ITEMIDLIST* pidl, uint* pdwFlags);
    ///Invokes the given verb on the current selection.
    ///Params:
    ///    pszVerb = Type: <b>LPCSTR</b> A pointer to a Unicode string containing a verb.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InvokeVerbOnSelection(const(char)* pszVerb);
    ///Sets and applies the view mode and image size.
    ///Params:
    ///    uViewMode = Type: <b>FOLDERVIEWMODE</b> The FOLDERVIEWMODE to be applied.
    ///    iImageSize = Type: <b>int</b> The size of the image in pixels.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetViewModeAndIconSize(FOLDERVIEWMODE uViewMode, int iImageSize);
    ///Gets the current view mode and icon size applied to the view.
    ///Params:
    ///    puViewMode = Type: <b>FOLDERVIEWMODE*</b> A pointer to the current FOLDERVIEWMODE.
    ///    piImageSize = Type: <b>int*</b> A pointer to the size of the icon in pixels.
    HRESULT GetViewModeAndIconSize(FOLDERVIEWMODE* puViewMode, int* piImageSize);
    ///Turns on group subsetting and sets the number of visible rows of items in each group.
    ///Params:
    ///    cVisibleRows = Type: <b>UINT</b> The number of rows to be visible.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetGroupSubsetCount(uint cVisibleRows);
    ///Gets the count of visible rows displayed for a group's subset.
    ///Params:
    ///    pcVisibleRows = Type: <b>UINT*</b> The number of rows currently visible.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetGroupSubsetCount(uint* pcVisibleRows);
    ///Sets redraw on and off.
    ///Params:
    ///    fRedrawOn = Type: <b>BOOL</b> a <b>BOOL</b> value.
    HRESULT SetRedraw(BOOL fRedrawOn);
    ///Checks to see if this view sourced the current drag-and-drop or cut-and-paste operation (used by drop target
    ///objects).
    HRESULT IsMoveInSameFolder();
    ///Starts a rename operation on the current selection.
    HRESULT DoRename();
}

///Exposes methods to obtain folder view settings.
@GUID("AE8C987D-8797-4ED3-BE72-2A47DD938DB0")
interface IFolderViewSettings : IUnknown
{
    ///Gets an ordered list of columns that corresponds to the column enumerated.
    ///Params:
    ///    riid = A reference to the interface identifier (IID) of the IPropertyDescriptionList.
    ///    ppv = Type: <b>IPropertyDescriptionList**</b> The address of an IPropertyDescriptionList interface pointer.
    HRESULT GetColumnPropertyList(const(GUID)* riid, void** ppv);
    ///Gets a grouping property.
    ///Params:
    ///    pkey = Type: <b>PROPERTYKEY*</b> A pointer to a PROPERTYKEY structure indicating the key by which content is
    ///           grouped.
    ///    pfGroupAscending = Type: <b>BOOL*</b> A pointer to a value indicating whether grouping order is ascending.
    HRESULT GetGroupByProperty(PROPERTYKEY* pkey, int* pfGroupAscending);
    ///Gets a folder's logical view mode.
    ///Params:
    ///    plvm = Type: <b>FOLDERLOGICALVIEWMODE*</b> A pointer to a FOLDERLOGICALVIEWMODE value.
    HRESULT GetViewMode(FOLDERLOGICALVIEWMODE* plvm);
    ///Gets the folder icon size.
    ///Params:
    ///    puIconSize = Type: <b>UINT*</b> A pointer to the icon size.
    HRESULT GetIconSize(uint* puIconSize);
    ///Gets folder view options flags.
    ///Params:
    ///    pfolderMask = Type: <b>FOLDERFLAGS*</b> A pointer to a mask for folder view options.
    ///    pfolderFlags = Type: <b>FOLDERFLAGS*</b> A pointer to a flag for folder view options.
    HRESULT GetFolderFlags(FOLDERFLAGS* pfolderMask, FOLDERFLAGS* pfolderFlags);
    ///Gets sort column information.
    ///Params:
    ///    rgSortColumns = Type: <b>SORTCOLUMN*</b> A pointer to an array of SORTCOLUMN structures.
    ///    cColumnsIn = Type: <b>UINT</b> The source column count.
    ///    pcColumnsOut = Type: <b>UINT*</b> A pointer to the <i>rgSortColumns</i> array length.
    HRESULT GetSortColumns(char* rgSortColumns, uint cColumnsIn, uint* pcColumnsOut);
    ///Gets group count for visible rows.
    ///Params:
    ///    pcVisibleRows = Type: <b>UINT*</b> A pointer to group count.
    HRESULT GetGroupSubsetCount(uint* pcVisibleRows);
}

///Exposes a method that initializes the network data source CLSID_NetworkPlaces as specified.
@GUID("6E0F9881-42A8-4F2A-97F8-8AF4E026D92D")
interface IInitializeNetworkFolder : IUnknown
{
    ///Initializes a network folder, as specified.
    ///Params:
    ///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> The Shell namespace location for this data source, as an IDList.
    ///    pidlTarget = Type: <b>PCIDLIST_ABSOLUTE</b> The target namespace location, as an IDList. This is used when the data source
    ///                 is aliased into the namespace. This parameter specifies the location of the network item that the data source
    ///                 will represent. See InitializeEx and in PERSIST_FOLDER_TARGET_INFO see the <i>pidlTargetFolder</i> definition
    ///                 for more information.
    ///    uDisplayType = Type: <b>UINT</b> The display type of the network resource this data source will represent. This is one of
    ///                   the RESOURCEDISPLAYTYPE_XXX values found in winnetwk.h.
    ///    pszResName = Type: <b>LPCWSTR</b> The network resource name. for example, \\server or \\server\share. this is passed to
    ///                 the WNet in the NETRESOURCE.<i>lpRemoteName</i> field.
    ///    pszProvider = Type: <b>LPCWSTR</b> Optional network provider, as in the NETRESOURCE.<i>lpProvider</i> field.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(ITEMIDLIST* pidl, ITEMIDLIST* pidlTarget, uint uDisplayType, const(wchar)* pszResName, 
                       const(wchar)* pszProvider);
}

@GUID("CEB38218-C971-47BB-A703-F0BC99CCDB81")
interface INetworkFolderInternal : IUnknown
{
    HRESULT GetResourceDisplayType(uint* displayType);
    HRESULT GetIDList(ITEMIDLIST** idList);
    HRESULT GetProvider(uint itemIdCount, char* itemIds, uint providerMaxLength, const(wchar)* provider);
}

///Exposes methods for applying color and font information to preview handlers.
@GUID("196BF9A5-B346-4EF0-AA1E-5DCDB76768B1")
interface IPreviewHandlerVisuals : IUnknown
{
    ///Sets the background color of the preview handler.
    ///Params:
    ///    color = Type: <b>COLORREF</b> A value of type COLORREF to use for the preview handler background.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetBackgroundColor(uint color);
    ///Sets the font attributes to be used for text within the preview handler.
    ///Params:
    ///    plf = Type: <b>const LOGFONTW*</b> A pointer to a LOGFONTW Structure containing the necessary attributes for the
    ///          font to use.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetFont(const(LOGFONTW)* plf);
    ///Sets the color of the text within the preview handler.
    ///Params:
    ///    color = Type: <b>COLORREF</b> A value of type COLORREF to use for the preview handler text color.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetTextColor(uint color);
}

///Exposed by the common file dialog boxes to be used when they host a Shell browser. If supported,
///<b>ICommDlgBrowser</b> exposes methods that allow a Shell view to handle several cases that require different
///behavior in a dialog box than in a normal Shell view. You obtain an <b>ICommDlgBrowser</b> interface pointer by
///calling QueryInterface on the IShellBrowser object.
@GUID("000214F1-0000-0000-C000-000000000046")
interface ICommDlgBrowser : IUnknown
{
    ///Called when a user double-clicks in the view or presses the ENTER key.
    ///Params:
    ///    ppshv = Type: <b>IShellView*</b> A pointer to the view's IShellView interface.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnDefaultCommand(IShellView ppshv);
    ///Called after a state, identified by the <i>uChange</i> parameter, has changed in the IShellView interface.
    ///Params:
    ///    ppshv = Type: <b>IShellView*</b> A pointer to the view's IShellView interface.
    ///    uChange = Type: <b>ULONG</b> Change in the selection state. This parameter can be one of the following values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnStateChange(IShellView ppshv, uint uChange);
    ///Allows the common dialog box to filter objects that the view displays.
    ///Params:
    ///    ppshv = Type: <b>IShellView*</b> A pointer to the view's IShellView interface.
    ///    pidl = Type: <b>LPCITEMIDLIST</b> A PIDL, relative to the folder, that identifies the object.
    ///Returns:
    ///    Type: <b>HRESULT</b> The browser should return S_OK to include the object in the view, or S_FALSE to hide it.
    ///    
    HRESULT IncludeObject(IShellView ppshv, ITEMIDLIST* pidl);
}

///Extends the capabilities of ICommDlgBrowser. This interface is exposed by the common file dialog boxes when they host
///a Shell browser. A pointer to <b>ICommDlgBrowser2</b> can be obtained by calling QueryInterface on the IShellBrowser
///object.
@GUID("10339516-2894-11D2-9039-00C04F8EEB3E")
interface ICommDlgBrowser2 : ICommDlgBrowser
{
    ///Called by a Shell view to notify the common dialog box hosting it that an event has occurred.
    ///Params:
    ///    ppshv = Type: <b>IShellView*</b> A pointer to the IShellView interface of the hosted view.
    ///    dwNotifyType = Type: <b>DWORD</b> A flag that can can take one of the following two values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Notify(IShellView ppshv, uint dwNotifyType);
    ///Called by the Shell view to get the default shortcut menu text.
    ///Params:
    ///    ppshv = Type: <b>IShellView*</b> A pointer to the IShellView interface of the hosted view.
    ///    pszText = Type: <b>WCHAR*</b> A pointer to a buffer that is used by the Shell browser to return the default shortcut
    ///              menu text.
    ///    cchMax = Type: <b>int</b> The size of the <i>pszText</i> buffer, in characters. It should be at least the maximum
    ///             allowable path length (MAX_PATH) in size.
    HRESULT GetDefaultMenuText(IShellView ppshv, const(wchar)* pszText, int cchMax);
    ///Called when the view must determine if special customization needs to be made for the common dialog browser.
    ///Params:
    ///    pdwFlags = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> value that controls the behavior of the view when in common
    ///               dialog mode.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetViewFlags(uint* pdwFlags);
}

///Exposes methods that enable inspection and manipulation of columns in the Windows Explorer Details view. Each column
///is referenced by a PROPERTYKEY structure, which names a property.
@GUID("D8EC27BB-3F3B-4042-B10A-4ACFD924D453")
interface IColumnManager : IUnknown
{
    ///Sets the state for a specified column.
    ///Params:
    ///    propkey = Type: <b>REFPROPERTYKEY</b> A reference to a PROPERTYKEY structure that identifies the column.
    ///    pcmci = Type: <b>const CM_COLUMNINFO*</b> A pointer to a CM_COLUMNINFO structure that contains the state to set for
    ///            this column.
    HRESULT SetColumnInfo(const(PROPERTYKEY)* propkey, const(CM_COLUMNINFO)* pcmci);
    ///Gets information about each column: width, visibility, display name, and state.
    ///Params:
    ///    propkey = Type: <b>REFPROPERTYKEY</b> A reference to a PROPERTYKEY structure.
    ///    pcmci = Type: <b>CM_COLUMNINFO*</b> A pointer to a CM_COLUMNINFO structure. On entry, set this structure's
    ///            <b>dwMask</b> member to specify the information to retrieve. Also set its <b>cbSize</b> member. When this
    ///            method returns successfully, the structure contains the requested information.
    HRESULT GetColumnInfo(const(PROPERTYKEY)* propkey, CM_COLUMNINFO* pcmci);
    ///Gets the column count for either the visible columns or the complete set of columns.
    ///Params:
    ///    dwFlags = Type: <b>CM_ENUM_FLAGS</b> A value from the CM_ENUM_FLAGS enumeration that specifies whether to show only
    ///              visible columns or all columns regardless of visibility.
    ///    puCount = Type: <b>UINT*</b> Contains a pointer to the column count.
    HRESULT GetColumnCount(CM_ENUM_FLAGS dwFlags, uint* puCount);
    ///Gets an array of PROPERTYKEY structures that represent the columns that the view supports. Includes either all
    ///columns or only those currently visible.
    ///Params:
    ///    dwFlags = Type: <b>CM_ENUM_FLAGS</b> A value from the CM_ENUM_FLAGS enumeration that specifies whether to show only
    ///              visible columns or all columns regardless of visibility.
    ///    rgkeyOrder = Type: <b>PROPERTYKEY*</b> On success, contains a pointer to an array of PROPERTYKEY structures that represent
    ///                 the columns.
    ///    cColumns = Type: <b>UINT</b> The length of the <i>rgkeyOrder</i> array.
    HRESULT GetColumns(CM_ENUM_FLAGS dwFlags, char* rgkeyOrder, uint cColumns);
    ///Sets the collection of columns for the view to display.
    ///Params:
    ///    rgkeyOrder = Type: <b>const PROPERTYKEY*</b> A pointer to an array of PROPERTYKEY structures that specify the columns to
    ///                 display.
    ///    cVisible = Type: <b>UINT</b> The size of the <i>rgkeyOrder</i> array.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns one of the following values: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Collection set. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>failure</b></dt> </dl> </td> <td width="60%">
    ///    Collection not set. </td> </tr> </table>
    ///    
    HRESULT SetColumns(char* rgkeyOrder, uint cVisible);
}

///Exported by a host to allow clients to specify how to filter a Shell folder enumeration.
@GUID("C0A651F5-B48B-11D2-B5ED-006097C686F6")
interface IFolderFilterSite : IUnknown
{
    ///Exposed by a host to allow clients to pass the host their IUnknown interface pointers.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to the client's IUnknown interface. To notify the host to terminate
    ///           filtering and stop calling your IFolderFilter interface, set this parameter to <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetFilter(IUnknown punk);
}

///Exposed by a client to specify how to filter the enumeration of a Shell folder by a server application.
@GUID("9CC22886-DC8E-11D2-B1D0-00C04F8EEB3E")
interface IFolderFilter : IUnknown
{
    ///Specifies whether an individual item should be allowed through the filter and which should be blocked. When used
    ///with SHBrowseForFolder, specifies which items should be shown in the dialog box tree view and which should not.
    ///The determination to show or not show an item is up to the application.
    ///Params:
    ///    psf = Type: <b>IShellFolder*</b> A pointer to the folder's IShellFolder interface.
    ///    pidlFolder = Type: <b>PCIDLIST_ABSOLUTE</b> The PIDL of the folder.
    ///    pidlItem = Type: <b>PCUITEMID_CHILD</b> The relative PIDL of the child item of <i>pidlFolder</i> in question.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the item should be shown, S_FALSE if it should not be shown, or a
    ///    standard error code if an error is encountered. If an error is encountered, the item is not shown.
    ///    
    HRESULT ShouldShow(IShellFolder psf, ITEMIDLIST* pidlFolder, ITEMIDLIST* pidlItem);
    ///Allows a client to specify which classes of objects in a Shell folder should be enumerated. When used with
    ///SHBrowseForFolder, specifies the class or classes of items that should be shown in the dialog box tree view and
    ///which class or classes should not.
    ///Params:
    ///    psf = Type: <b>IShellFolder*</b> A pointer to the folder's IShellFolder interface.
    ///    pidlFolder = Type: <b>PCIDLIST_ABSOLUTE </b> The PIDL of the folder.
    ///    phwnd = Type: <b>HWND*</b> A pointer to the host's window handle.
    ///    pgrfFlags = Type: <b>DWORD*</b> One or more SHCONTF values that specify the classes of object to enumerate.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEnumFlags(IShellFolder psf, ITEMIDLIST* pidlFolder, HWND* phwnd, uint* pgrfFlags);
}

///Exposes a method that is used to communicate focus changes for a user input object contained in the Shell.
@GUID("F1DB8392-7331-11D0-8C99-00A0C92DBFE8")
interface IInputObjectSite : IUnknown
{
    ///Informs the browser that the focus has changed.
    ///Params:
    ///    punkObj = Type: <b>IUnknown*</b> The address of the IUnknown interface of the object gaining or losing the focus.
    ///    fSetFocus = Type: <b>BOOL</b> Indicates if the object has gained or lost the focus. If this value is nonzero, the object
    ///                has gained the focus. If this value is zero, the object has lost the focus.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the method was successful, or a COM-defined error code otherwise.
    ///    
    HRESULT OnFocusChangeIS(IUnknown punkObj, BOOL fSetFocus);
}

///Exposes methods that change UI activation and process accelerators for a user input object contained in the Shell.
@GUID("68284FAA-6A48-11D0-8C78-00C04FD918B4")
interface IInputObject : IUnknown
{
    ///UI-activates or deactivates the object.
    ///Params:
    ///    fActivate = Type: <b>BOOL</b> Indicates if the object is being activated or deactivated. If this value is nonzero, the
    ///                object is being activated. If this value is zero, the object is being deactivated.
    ///    pMsg = Type: <b>MSG*</b> A pointer to an MSG structure that contains the message that caused the activation change.
    ///           This value may be <b>NULL</b>.
    HRESULT UIActivateIO(BOOL fActivate, MSG* pMsg);
    ///Determines if one of the object's windows has the keyboard focus.
    HRESULT HasFocusIO();
    ///Enables the object to process keyboard accelerators.
    ///Params:
    ///    pMsg = Type: <b>LPMSG</b> The address of an MSG structure that contains the keyboard message that is being
    ///           translated.
    HRESULT TranslateAcceleratorIO(MSG* pMsg);
}

///Exposes a method that extends IInputObject by handling global accelerators.
@GUID("6915C085-510B-44CD-94AF-28DFA56CF92B")
interface IInputObject2 : IInputObject
{
    ///Handles global accelerators so that input objects can respond to the keyboard even when they are not active in
    ///the UI.
    ///Params:
    ///    pMsg = Type: <b>MSG*</b> A pointer to an MSG structure that contains a keyboard message.
    HRESULT TranslateAcceleratorGlobal(MSG* pMsg);
}

///Exposes a method that obtains an icon index for an IShellFolder object.
@GUID("000214E5-0000-0000-C000-000000000046")
interface IShellIcon : IUnknown
{
    ///Gets an icon for an object inside a specific folder.
    ///Params:
    ///    pidl = Type: <b>LPCITEMIDLIST</b> The address of the ITEMIDLIST structure that specifies the relative location of
    ///           the folder.
    ///    flags = Type: <b>UINT</b> Flags specifying how the icon is to display. This parameter can be zero or one of the
    ///            following values.
    ///    pIconIndex = Type: <b>LPINT</b> The address of the index of the icon in the system image list. The following standard
    ///                 image list indexes can be returned.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if <i>lpIconIndex</i> contains the correct system image list index, or
    ///    S_FALSE if an icon can't be obtained for this object.
    ///    
    HRESULT GetIconOf(ITEMIDLIST* pidl, uint flags, int* pIconIndex);
}

///Implemented by hosts of Shell views (objects that implement IShellView). Exposes methods that provide services for
///the view it is hosting and other objects that run in the context of the Explorer window.
@GUID("000214E2-0000-0000-C000-000000000046")
interface IShellBrowser : IOleWindow
{
    ///Allows the container to insert its menu groups into the composite menu that is displayed when an extended
    ///namespace is being viewed or used.
    ///Params:
    ///    hmenuShared = Type: <b>HMENU</b> A handle to an empty menu.
    ///    lpMenuWidths = Type: <b>LPOLEMENUGROUPWIDTHS</b> The address of an OLEMENUGROUPWIDTHS array of six <b>LONG</b> values. The
    ///                   container fills in elements 0, 2, and 4 to reflect the number of menu elements it provided in the File, View,
    ///                   and Window menu groups.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT InsertMenusSB(HMENU hmenuShared, OleMenuGroupWidths* lpMenuWidths);
    ///Installs the composite menu in the view window.
    ///Params:
    ///    hmenuShared = Type: <b>HMENU</b> A handle to the composite menu constructed by calls to IShellBrowser::InsertMenusSB and
    ///                  the InsertMenu function.
    ///    holemenuRes = Type: <b>HOLEMENU</b>
    ///    hwndActiveObject = Type: <b>HWND</b> The view's window handle.
    ///Returns:
    ///    Type: <b>RESULT</b> Returns <b>S_OK</b> if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT SetMenuSB(HMENU hmenuShared, ptrdiff_t holemenuRes, HWND hwndActiveObject);
    ///Permits the container to remove any of its menu elements from the in-place composite menu and to free all
    ///associated resources.
    ///Params:
    ///    hmenuShared = Type: <b>HMENU</b> A handle to the in-place composite menu that was constructed by calls to
    ///                  IShellBrowser::InsertMenusSB and the InsertMenu function.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT RemoveMenusSB(HMENU hmenuShared);
    ///Sets and displays status text about the in-place object in the container's frame-window status bar.
    ///Params:
    ///    pszStatusText = Type: <b>LPCWSTR</b> A pointer to a null-terminated character string that contains the message to display.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetStatusTextSB(const(wchar)* pszStatusText);
    ///Tells Windows Explorer to enable or disable its modeless dialog boxes.
    ///Params:
    ///    fEnable = Type: <b>BOOL</b> Specifies whether the modeless dialog boxes are to be enabled or disabled. If this
    ///              parameter is nonzero, modeless dialog boxes are enabled. If this parameter is zero, modeless dialog boxes are
    ///              disabled.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT EnableModelessSB(BOOL fEnable);
    ///Translates accelerator keystrokes intended for the browser's frame while the view is active.
    ///Params:
    ///    pmsg = Type: <b>LPMSG</b> The address of an MSG structure containing the keystroke message.
    ///    wID = Type: <b>WORD</b> The command identifier value corresponding to the keystroke in the container-provided
    ///          accelerator table. Containers should use this value instead of translating again.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT TranslateAcceleratorSB(MSG* pmsg, ushort wID);
    ///Informs Windows Explorer to browse to another folder.
    ///Params:
    ///    pidl = Type: <b>PCUIDLIST_RELATIVE</b> The address of an ITEMIDLIST (item identifier list) structure that specifies
    ///           an object's location. This value is dependent on the flag or flags set in the <i>wFlags</i> parameter.
    ///    wFlags = Type: <b>UINT</b> Flags specifying the folder to be browsed. It can be zero or one or more of the following
    ///             values. These flags specify whether another window is to be created.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BrowseObject(ITEMIDLIST* pidl, uint wFlags);
    ///Gets an <b>IStream</b> interface that can be used for storage of view-specific state information.
    ///Params:
    ///    grfMode = Type: <b>DWORD</b> Read/write access of the IStream interface. This may be one of the following values.
    ///    ppStrm = Type: <b>IStream**</b> The address that receives the IStream interface pointer.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT GetViewStateStream(uint grfMode, IStream* ppStrm);
    ///Gets the window handle to a browser control.
    ///Params:
    ///    id = Type: <b>UINT</b> The control handle that is being requested. This parameter can be one of the following
    ///         values:
    ///    phwnd = Type: <b>HWND*</b> The address of the window handle to the Windows Explorer control.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT GetControlWindow(uint id, HWND* phwnd);
    ///Sends control messages to either the toolbar or the status bar in a Windows Explorer window.
    ///Params:
    ///    id = Type: <b>UINT</b> An identifier for either a toolbar (<b>FCW_TOOLBAR</b>) or for a status bar window
    ///         (<b>FCW_STATUS</b>).
    ///    uMsg = Type: <b>UINT</b> The message to be sent to the control.
    ///    wParam = Type: <b>WPARAM</b> The value depends on the message specified in the <i>uMsg</i> parameter.
    ///    lParam = Type: <b>LPARAM</b> The value depends on the message specified in the <i>uMsg</i> parameter.
    ///    pret = Type: <b>LRESULT*</b> The address of the return value of the SendMessage function.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT SendControlMsg(uint id, uint uMsg, WPARAM wParam, LPARAM lParam, LRESULT* pret);
    ///Retrieves the currently active (displayed) Shell view object.
    ///Params:
    ///    ppshv = Type: <b>IShellView**</b> The address of the pointer to the currently active Shell view object.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT QueryActiveShellView(IShellView* ppshv);
    ///Called by the Shell view when the view window or one of its child windows gets the focus or becomes active.
    ///Params:
    ///    pshv = Type: <b>IShellView*</b> Address of the view object's IShellView pointer.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT OnViewWindowActive(IShellView pshv);
    ///<p class="CCE_Message">[This method has no effect on Windows Vista or later operating systems.] Adds toolbar
    ///items to Windows Explorer's toolbar.
    ///Params:
    ///    lpButtons = Type: <b>LPTBBUTTONSB</b> The address of an array of TBBUTTON structures.
    ///    nButtons = Type: <b>UINT</b> The number of TBBUTTON structures in the <i>lpButtons</i> array.
    ///    uFlags = Type: <b>UINT</b> Flags specifying where the toolbar buttons should go. This parameter can be one or more of
    ///             the following values.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error value otherwise.
    ///    
    HRESULT SetToolbarItems(char* lpButtons, uint nButtons, uint uFlags);
}

///Exposes a general mechanism for objects to offer services to other objects on the same host.
@GUID("CB728B20-F786-11CE-92AD-00AA00A74CD0")
interface IProfferService : IUnknown
{
    ///Makes a service available to other objects on the same host.
    ///Params:
    ///    guidService = Type: <b>REFGUID</b> A value of type <b>GUID</b> that specifies the service being offered.
    ///    psp = Type: <b>IServiceProvider*</b> A pointer to an IServiceProvider interface.
    ///    pdwCookie = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> that receives an implementation-defined value used for
    ///                identification purposes. The calling application must keep track of this value for possible use in
    ///                IProfferService::RevokeService.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ProfferService(const(GUID)* guidService, IServiceProvider psp, uint* pdwCookie);
    ///Makes a service unavailable that had previously been available to other objects through
    ///IProfferService::ProfferService.
    ///Params:
    ///    dwCookie = Type: <b>DWORD</b> A value of type <b>DWORD</b> that specifies an implementation-defined value used for
    ///               identification purposes. The calling application receives this value from IProfferService::ProfferService.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RevokeService(uint dwCookie);
}

///Exposes methods that retrieve information about a Shell item. <b>IShellItem</b> and IShellItem2 are the preferred
///representations of items in any new code.
@GUID("43826D1E-E718-42EE-BC55-A1E261C37BFE")
interface IShellItem : IUnknown
{
    ///Binds to a handler for an item as specified by the handler ID value (BHID).
    ///Params:
    ///    pbc = Type: <b>IBindCtx*</b> A pointer to an IBindCtx interface on a bind context object. Used to pass optional
    ///          parameters to the handler. The contents of the bind context are handler-specific. For example, when binding
    ///          to <b>BHID_Stream</b>, the STGM flags in the bind context indicate the mode of access desired (read or
    ///          read/write).
    ///    bhid = Type: <b>REFGUID</b> Reference to a GUID that specifies which handler will be created. One of the following
    ///           values defined in Shlguid.h:
    ///    riid = Type: <b>REFIID</b> IID of the object type to retrieve.
    ///    ppv = Type: <b>void**</b> When this method returns, contains a pointer of type <i>riid</i> that is returned by the
    ///          handler specified by <i>rbhid</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BindToHandler(IBindCtx pbc, const(GUID)* bhid, const(GUID)* riid, void** ppv);
    ///Gets the parent of an IShellItem object.
    ///Params:
    ///    ppsi = Type: <b>IShellItem**</b> The address of a pointer to the parent of an IShellItem interface.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise.
    ///    
    HRESULT GetParent(IShellItem* ppsi);
    ///Gets the display name of the IShellItem object.
    ///Params:
    ///    sigdnName = Type: <b>SIGDN</b> One of the SIGDN values that indicates how the name should look.
    ///    ppszName = Type: <b>LPWSTR*</b> A value that, when this function returns successfully, receives the address of a pointer
    ///               to the retrieved display name.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDisplayName(SIGDN sigdnName, ushort** ppszName);
    ///Gets a requested set of attributes of the IShellItem object.
    ///Params:
    ///    sfgaoMask = Type: <b>SFGAOF</b> Specifies the attributes to retrieve. One or more of the SFGAO values. Use a bitwise OR
    ///                operator to determine the attributes to retrieve.
    ///    psfgaoAttribs = Type: <b>SFGAOF*</b> A pointer to a value that, when this method returns successfully, contains the requested
    ///                    attributes. One or more of the SFGAO values. Only those attributes specified by <i>sfgaoMask</i> are
    ///                    returned; other attribute values are undefined.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the attributes returned exactly match those requested in
    ///    <i>sfgaoMask</i>, S_FALSE if the attributes do not exactly match, or a standard COM error value otherwise.
    ///    
    HRESULT GetAttributes(uint sfgaoMask, uint* psfgaoAttribs);
    ///Compares two IShellItem objects.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to an IShellItem object to compare with the existing <b>IShellItem</b>
    ///          object.
    ///    hint = Type: <b>SICHINTF</b> One of the SICHINTF values that determines how to perform the comparison. See
    ///           <b>SICHINTF</b> for the list of possible values for this parameter.
    ///    piOrder = Type: <b>int*</b> This parameter receives the result of the comparison. If the two items are the same this
    ///              parameter equals zero; if they are different the parameter is nonzero.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the items are the same, S_FALSE if they are different, or an error value
    ///    otherwise.
    ///    
    HRESULT Compare(IShellItem psi, uint hint, int* piOrder);
}

///Extends IShellItem with methods that retrieve various property values of the item. <b>IShellItem</b> and
///<b>IShellItem2</b> are the preferred representations of items in any new code.
@GUID("7E9FB0D3-919F-4307-AB2E-9B1860310C93")
interface IShellItem2 : IShellItem
{
    ///Gets a property store object for specified property store flags.
    ///Params:
    ///    flags = Type: <b>GETPROPERTYSTOREFLAGS</b> The GETPROPERTYSTOREFLAGS constants that modify the property store object.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the object to be retrieved.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the address of an IPropertyStore interface pointer.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPropertyStore(GETPROPERTYSTOREFLAGS flags, const(GUID)* riid, void** ppv);
    ///Uses the specified ICreateObject instead of CoCreateInstance to create an instance of the property handler
    ///associated with the Shell item on which this method is called. Most calling applications do not need to call this
    ///method, and can call IShellItem2::GetPropertyStore instead.
    ///Params:
    ///    flags = Type: <b>GETPROPERTYSTOREFLAGS</b> The GETPROPERTYSTOREFLAGS constants that modify the property store object.
    ///    punkCreateObject = Type: <b>IUnknown*</b> A pointer to a factory for low-rights creation of type ICreateObject. The method
    ///                       CreateObject creates an instance of a COM object. The implementation of
    ///                       <b>IShellItem2::GetPropertyStoreWithCreateObject</b> uses <b>CreateObject</b> instead of CoCreateInstance to
    ///                       create the property handler, which is a Shell extension, for a given file type. The property handler provides
    ///                       many of the important properties in the property store that this method returns. This method is useful only
    ///                       if the ICreateObject object is created in a separate process (as a LOCALSERVER instead of an INPROCSERVER),
    ///                       and also if this other process has lower rights than the process calling
    ///                       <b>IShellItem2::GetPropertyStoreWithCreateObject</b>.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the object to be retrieved.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the address of the requested IPropertyStore interface
    ///          pointer.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPropertyStoreWithCreateObject(GETPROPERTYSTOREFLAGS flags, IUnknown punkCreateObject, 
                                             const(GUID)* riid, void** ppv);
    ///Gets property store object for specified property keys.
    ///Params:
    ///    rgKeys = Type: <b>const PROPERTYKEY*</b> A pointer to an array of PROPERTYKEY structures. Each structure contains a
    ///             unique identifier for each property used in creating the property store.
    ///    cKeys = Type: <b>UINT</b> The number of PROPERTYKEY structures in the array pointed to by <i>rgKeys</i>.
    ///    flags = Type: <b>GETPROPERTYSTOREFLAGS</b> The GETPROPERTYSTOREFLAGS constants that modify the property store object.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the object to be retrieved.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the address of an IPropertyStore interface pointer.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPropertyStoreForKeys(char* rgKeys, uint cKeys, GETPROPERTYSTOREFLAGS flags, const(GUID)* riid, 
                                    void** ppv);
    ///Gets a property description list object given a reference to a property key.
    ///Params:
    ///    keyType = Type: <b>REFPROPERTYKEY</b> A reference to a PROPERTYKEY structure.
    ///    riid = Type: <b>REFIID</b> A reference to a desired IID.
    ///    ppv = Type: <b>void**</b> Contains the address of an IPropertyDescriptionList interface pointer.
    HRESULT GetPropertyDescriptionList(const(PROPERTYKEY)* keyType, const(GUID)* riid, void** ppv);
    ///Ensures that any cached information in this item is updated.
    ///Params:
    ///    pbc = Type: <b>IBindCtx*</b> A pointer to an IBindCtx interface on a bind context object.
    HRESULT Update(IBindCtx pbc);
    ///Gets a PROPVARIANT structure from a specified property key.
    ///Params:
    ///    key = Type: <b>REFPROPERTYKEY</b> A reference to a PROPERTYKEY structure.
    ///    ppropvar = Type: <b>PROPVARIANT*</b> Contains a pointer to a PROPVARIANT structure.
    HRESULT GetProperty(const(PROPERTYKEY)* key, PROPVARIANT* ppropvar);
    ///Gets the class identifier (CLSID) value of specified property key.
    ///Params:
    ///    key = Type: <b>REFPROPERTYKEY</b> A reference to a PROPERTYKEY structure.
    ///    pclsid = Type: <b>CLSID*</b> A pointer to a CLSID value.
    HRESULT GetCLSID(const(PROPERTYKEY)* key, GUID* pclsid);
    ///Gets the date and time value of a specified property key.
    ///Params:
    ///    key = Type: <b>REFPROPERTYKEY</b> A reference to a PROPERTYKEY structure.
    ///    pft = Type: <b>FILETIME*</b> A pointer to a date and time value.
    HRESULT GetFileTime(const(PROPERTYKEY)* key, FILETIME* pft);
    ///Gets the Int32 value of specified property key.
    ///Params:
    ///    key = Type: <b>REFPROPERTYKEY</b> A reference to a PROPERTYKEY structure.
    ///    pi = Type: <b>int*</b> A pointer to an Int32 value.
    HRESULT GetInt32(const(PROPERTYKEY)* key, int* pi);
    ///Gets the string value of a specified property key.
    ///Params:
    ///    key = Type: <b>REFPROPERTYKEY</b> A reference to a PROPERTYKEY structure.
    ///    ppsz = Type: <b>LPWSTR*</b> A pointer to a Unicode string value.
    HRESULT GetString(const(PROPERTYKEY)* key, ushort** ppsz);
    ///Gets the UInt32 value of a specified property key.
    ///Params:
    ///    key = Type: <b>REFPROPERTYKEY</b> A reference to a PROPERTYKEY structure.
    ///    pui = Type: <b>ULONG*</b> Receives a pointer to a UInt32 value.
    HRESULT GetUInt32(const(PROPERTYKEY)* key, uint* pui);
    ///Gets the UInt64 value of a specified property key.
    ///Params:
    ///    key = Type: <b>REFPROPERTYKEY</b> A reference to a PROPERTYKEY structure.
    ///    pull = Type: <b>ULONGLONG*</b> A pointer to a UInt64 value.
    HRESULT GetUInt64(const(PROPERTYKEY)* key, ulong* pull);
    ///Gets the boolean value of a specified property key.
    ///Params:
    ///    key = Type: <b>REFPROPERTYKEY</b> A reference to a PROPERTYKEY structure.
    ///    pf = Type: <b>BOOL*</b> A pointer to a boolean value.
    HRESULT GetBool(const(PROPERTYKEY)* key, int* pf);
}

///Exposes a method to return either icons or thumbnails for Shell items. If no thumbnail or icon is available for the
///requested item, a per-class icon may be provided from the Shell.
@GUID("BCC18B79-BA16-442F-80C4-8A59C30C463B")
interface IShellItemImageFactory : IUnknown
{
    ///Gets an <b>HBITMAP</b> that represents an IShellItem. The default behavior is to load a thumbnail. If there is no
    ///thumbnail for the current <b>IShellItem</b>, it retrieves an <b>HBITMAP</b> for the icon of the item. The
    ///thumbnail or icon is extracted if it is not currently cached.
    ///Params:
    ///    size = Type: <b>SIZE</b> A structure that specifies the size of the image to be received.
    ///    flags = Type: <b>SIIGBF</b> One or more of the following:
    ///    phbm = Type: <b>HBITMAP*</b> Pointer to a value that, when this method returns successfully, receives the handle of
    ///           the retrieved bitmap. It is the responsibility of the caller to free this retrieved resource through
    ///           DeleteObject when it is no longer needed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetImage(SIZE size, int flags, HBITMAP* phbm);
}

///Exposes enumeration of IShellItem interfaces. This interface is typically obtained by calling the
///<b>IEnumShellItems</b> method.
@GUID("70629033-E363-4A28-A567-0DB78006E6D7")
interface IEnumShellItems : IUnknown
{
    ///Gets an array of one or more IShellItem interfaces from the enumeration.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of elements in the array referenced by the <i>rgelt</i> parameter.
    ///    rgelt = Type: <b>IShellItem**</b> The address of an array of pointers to IShellItem interfaces that receive the
    ///            enumerated item or items. The calling application is responsible for freeing the <b>IShellItem</b> interfaces
    ///            by calling the IUnknown::Release method.
    ///    pceltFetched = Type: <b>ULONG*</b> A pointer to a value that receives the number of IShellItem interfaces successfully
    ///                   retrieved. The count can be smaller than the value specified in the <i>celt</i> parameter. This parameter can
    ///                   be <b>NULL</b> on entry only if <i>celt</i> is one, because in that case the method can only retrieve one
    ///                   item and return <b>S_OK</b>, or zero items and return <b>S_FALSE</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> if at
    ///    least IShellItem interface was retrieved. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt>
    ///    </dl> </td> <td width="60%"> if there are no more IShellItem interfaces in the enumeration. </td> </tr> <tr>
    ///    <td width="40%"> </td> <td width="60%"> Returns an error value if the function fails for any other reason.
    ///    </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips a given number of IShellItem interfaces in the enumeration. Used when retrieving interfaces.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of IShellItem interfaces to skip.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Skip(uint celt);
    ///Resets the internal count of retrieved IShellItem interfaces in the enumeration.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Reset();
    ///Gets a copy of the current enumeration.
    ///Params:
    ///    ppenum = Type: <b>IEnumShellItems**</b> The address of a pointer that receives a copy of this enumeration.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Clone(IEnumShellItems* ppenum);
}

///Exposes methods supporting status collection and failure information.
@GUID("D594D0D8-8DA7-457B-B3B4-CE5DBAAC0B88")
interface ITransferAdviseSink : IUnknown
{
    ///Updates the transfer progress status in the UI.
    ///Params:
    ///    ullSizeCurrent = Type: <b>ULONGLONG</b> The number of bytes processed in the current operation.
    ///    ullSizeTotal = Type: <b>ULONGLONG</b> The total number of bytes in the current operation.
    ///    nFilesCurrent = Type: <b>int</b> The number of files processed in the current operation.
    ///    nFilesTotal = Type: <b>int</b> The total number of files in the operation. Set to 0 to indicate that the value has not
    ///                  changed since the last call to this method.
    ///    nFoldersCurrent = Type: <b>int</b> The number of folders processed in the current operation.
    ///    nFoldersTotal = Type: <b>int</b> The total number of folders in the operation. Set to 0 to indicate that the value has not
    ///                    changed since the last call to this method.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UpdateProgress(ulong ullSizeCurrent, ulong ullSizeTotal, int nFilesCurrent, int nFilesTotal, 
                           int nFoldersCurrent, int nFoldersTotal);
    ///Updates the transfer state.
    ///Params:
    ///    ts = Type: <b>TRANSFER_ADVISE_STATE</b> The transfer state. One of the following values.
    HRESULT UpdateTransferState(uint ts);
    ///Displays a message to the user confirming that overwriting existing items is acceptable.
    ///Params:
    ///    psiSource = Type: <b>IShellItem*</b> A pointer to the source IShellItem .
    ///    psiDestParent = Type: <b>IShellItem*</b> A pointer to the destination parent folder IShellItem.
    ///    pszName = Type: <b>LPCWSTR</b> A pointer to a wide-string containing the desired name of the item at the destination.
    ///              If <b>NULL</b>, the name is the same as the Shell item pointed to by <i>psiSource</i>.
    HRESULT ConfirmOverwrite(IShellItem psiSource, IShellItem psiDestParent, const(wchar)* pszName);
    ///Displays a message to the user confirming that loss of encryption is acceptable for this operation.
    ///Params:
    ///    psiSource = Type: <b>IShellItem*</b> A pointer to an IShellItem of the file in which encryption information will be lost.
    HRESULT ConfirmEncryptionLoss(IShellItem psiSource);
    ///Called when there is a failure and user interaction is needed.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> The IShellItem on which the operation failed.
    ///    pszItem = Type: <b>LPCWSTR</b> Optional. A pointer to a null-terminated buffer that contains the name of the file. If
    ///              this value is <b>NULL</b>, the name given by the <i>psi</i> parameter is used.
    ///    hrError = Type: <b>HRESULT</b> The error code generated by the failure. This error must be handled by the copy engine.
    ///    pszRename = Type: <b>LPWSTR</b> Optional. When this method returns, contains a pointer to a null-terminated buffer that
    ///                contains a new name for the file. The name cannot exceed length <i>cchRename</i>. If this parameter is
    ///                <b>NULL</b>, no option to rename will be available.
    ///    cchRename = Type: <b>ULONG</b> The size of the <i>pszRename</i>buffer, in characters.
    HRESULT FileFailure(IShellItem psi, const(wchar)* pszItem, HRESULT hrError, const(wchar)* pszRename, 
                        uint cchRename);
    ///Called when there is a failure that involves secondary streams and user interaction is needed.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the IShellItem that caused the failure.
    ///    pszStreamName = Type: <b>LPCWSTR</b> The name of the data that will be lost in the operation.
    ///    hrError = Type: <b>HRESULT</b> The error code that was generated. It must be handled by the copy engine.
    HRESULT SubStreamFailure(IShellItem psi, const(wchar)* pszStreamName, HRESULT hrError);
    ///Called when there is a failure that involves file properties and user interaction is needed.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the IShellItem that caused the failure.
    ///    pkey = Type: <b>const PROPERTYKEY*</b> A value that corresponds to the property that will be lost. A <b>NULL</b>
    ///           value indicates that all properties were lost.
    ///    hrError = Type: <b>HRESULT</b> The error code generated by the failure. It must be handled by the copy engine.
    HRESULT PropertyFailure(IShellItem psi, const(PROPERTYKEY)* pkey, HRESULT hrError);
}

///Exposes methods to manipulate IShellItem, including copy, move, recycle, and others. This interface is offered to
///provide more control over file operations by providing an ITransferSource::Advise method.
@GUID("00ADB003-BDE9-45C6-8E29-D09F9353E108")
interface ITransferSource : IUnknown
{
    ///Sets up an advisory connection for notifications on the status of file operations.
    ///Params:
    ///    psink = Type: <b>ITransferAdviseSink*</b> A pointer to notification interface ITransferAdviseSink to update the
    ///            calling application using methods on this interface.
    ///    pdwCookie = Type: <b>DWORD*</b> A pointer to a returned token that uniquely identifies this connection. The calling
    ///                application uses this token later to delete the connection by passing it to the ITransferSource::Unadvise
    ///                method. If the connection was not successfully established, this value is zero.
    ///Returns:
    ///    Type: <b>HRESULT</b> Any HRESULTs other than listed indicate a failure. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    Interface successfully associated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> The handler can only handle one sink interface. </td> </tr> </table>
    ///    
    HRESULT Advise(ITransferAdviseSink psink, uint* pdwCookie);
    ///Terminates an advisory connection.
    ///Params:
    ///    dwCookie = Type: <b>DWORD</b> The connection token previously returned from method ITransferSource::Advise.
    ///Returns:
    ///    Type: <b>HRESULT</b> Any HRESULTs other than listed indicate a failure. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    connection was successfully terminated. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CONNECT_E_NOCONNECTION</b></dt> </dl> </td> <td width="60%"> The value in dwCookie does not represent
    ///    a valid connection. </td> </tr> </table>
    ///    
    HRESULT Unadvise(uint dwCookie);
    ///Sets properties that should be applied to an item.
    ///Params:
    ///    pproparray = Type: <b>IPropertyChangeArray*</b> An array of properties and their changed values.
    HRESULT SetProperties(IPropertyChangeArray pproparray);
    ///Opens the item for copying. Returns an object that can be enumerated for resources (IShellItemResources).
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the IShellItem to be opened.
    ///    flags = Type: <b>TRANSFER_SOURCE_FLAGS</b> The flags that control the file operation. One or more of the
    ///            TRANSFER_SOURCE_FLAGS constants.
    ///    riid = Type: <b>REFIID</b> A reference to the IID (the interface ID or GUID) of the interface to return in
    ///           <i>ppv</i>. This should be an IShellItemResources or an interface derived from <b>IShellItemResources</b>.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the address of a pointer to the interface specified by
    ///          <i>riid</i>.
    HRESULT OpenItem(IShellItem psi, uint flags, const(GUID)* riid, void** ppv);
    ///Moves the item within the volume/namespace, returning the IShellItem in its new location.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the IShellItem to be moved.
    ///    psiParentDst = Type: <b>IShellItem*</b> A pointer to the IShellItem that represents the new parent item at the destination.
    ///    pszNameDst = Type: <b>LPCWSTR</b> Pointer to a null-terminated buffer that contains the destination path.
    ///    flags = Type: <b>TRANSFER_SOURCE_FLAGS</b> Flags that control the file operation. One or more of the
    ///            TRANSFER_SOURCE_FLAGS constants.
    ///    ppsiNew = Type: <b>IShellItem**</b> When this method returns successfully, contains an address of a pointer to the
    ///              IShellItem in its new location.
    HRESULT MoveItem(IShellItem psi, IShellItem psiParentDst, const(wchar)* pszNameDst, uint flags, 
                     IShellItem* ppsiNew);
    ///Recycle the item into the provided recycle location and return the item in its new location.
    ///Params:
    ///    psiSource = Type: <b>IShellItem*</b> A pointer to the IShellItem to be recycled.
    ///    psiParentDest = Type: <b>IShellItem*</b> A pointer to the IShellItem of the recycle location (the new parent of the item).
    ///    flags = Type: <b>TRANSFER_SOURCE_FLAGS</b> The flags that control the file operation. One or more of the
    ///            TRANSFER_SOURCE_FLAGS constants.
    ///    ppsiNewDest = Type: <b>IShellItem**</b> When the method returns, contains the address of a pointer to the recycled
    ///                  IShellItem.
    HRESULT RecycleItem(IShellItem psiSource, IShellItem psiParentDest, uint flags, IShellItem* ppsiNewDest);
    ///Removes the item without moving the item to the Recycle Bin.
    ///Params:
    ///    psiSource = Type: <b>IShellItem*</b> A pointer to the IShellItem to be removed.
    ///    flags = Type: <b>TRANSFER_SOURCE_FLAGS</b> Flags that control the file operation. One or more of the
    ///            TRANSFER_SOURCE_FLAGS constants.
    HRESULT RemoveItem(IShellItem psiSource, uint flags);
    ///Changes the name of an item, returning the IShellItem with the new name.
    ///Params:
    ///    psiSource = Type: <b>IShellItem*</b> A pointer to the IShellItem object to be renamed.
    ///    pszNewName = Type: <b>LPCWSTR</b> A pointer to a null-terminated, Unicode string containing the new name.
    ///    flags = Type: <b>TRANSFER_SOURCE_FLAGS</b> Flags that control the file operation. One or more of the
    ///            TRANSFER_SOURCE_FLAGS constants.
    ///    ppsiNewDest = Type: <b>IShellItem**</b> When this method returns, contains the address of a pointer to the IShellItem
    ///                  object.
    HRESULT RenameItem(IShellItem psiSource, const(wchar)* pszNewName, uint flags, IShellItem* ppsiNewDest);
    ///Not implemented.
    ///Params:
    ///    psiSource = Type: <b>IShellItem*</b> A pointer to an IShellItem that represents the source item.
    ///    psiParentDest = Type: <b>IShellItem*</b> A pointer to the IShellItem as parent to link.
    ///    pszNewName = Type: <b>LPCWSTR</b> A pointer to a null-terminated, Unicode string containing the name for the link.
    ///    flags = Type: <b>DWORD</b> The flags that control the file operation. Value is one or more of the
    ///            TRANSFER_SOURCE_FLAGS constants.
    ///    ppsiNewDest = Type: <b>IShellItem**</b> When the method returns, contains the address of a pointer to the IShellItem of the
    ///                  link.
    HRESULT LinkItem(IShellItem psiSource, IShellItem psiParentDest, const(wchar)* pszNewName, uint flags, 
                     IShellItem* ppsiNewDest);
    ///Apply a set of property changes to an item.
    ///Params:
    ///    psiSource = Type: <b>IShellItem*</b> A pointer to the IShellItem to be altered.
    ///    ppsiNew = Type: <b>IShellItem**</b> When this method returns, contains the address of a pointer to the changed
    ///              IShellItem.
    HRESULT ApplyPropertiesToItem(IShellItem psiSource, IShellItem* ppsiNew);
    ///Gets the default name for a Shell item.
    ///Params:
    ///    psiSource = Type: <b>IShellItem*</b> A pointer to the IShellItem.
    ///    psiParentDest = Type: <b>IShellItem*</b> A pointer to the parent IShellItem of the destination target of the file operation.
    ///    ppszDestinationName = Type: <b>LPWSTR*</b> When the method returns, contains a pointer to a null-terminated, Unicode string
    ///                          containing the default name.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDefaultDestinationName(IShellItem psiSource, IShellItem psiParentDest, ushort** ppszDestinationName);
    ///Notifies that a folder is the destination of a file operation.
    ///Params:
    ///    psiChildFolderDest = Type: <b>IShellItem*</b> A pointer to the IShellItem destination folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnterFolder(IShellItem psiChildFolderDest);
    ///Sends notification that a folder is no longer the destination of a file operation.
    ///Params:
    ///    psiChildFolderDest = Type: <b>IShellItem*</b> A pointer to the IShellItem destination folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT LeaveFolder(IShellItem psiChildFolderDest);
}

///Exposes resource enumeration methods.
@GUID("2DD81FE3-A83C-4DA9-A330-47249D345BA1")
interface IEnumResources : IUnknown
{
    ///Gets the next SHELL_ITEM_RESOURCE structure.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of resources requested. Currently, must be 1.
    ///    psir = Type: <b>SHELL_ITEM_RESOURCE*</b> Receives a pointer to a SHELL_ITEM_RESOURCE structure.
    ///    pceltFetched = Type: <b>ULONG*</b> A pointer to the number of resources retrieved. Currently, not used.
    HRESULT Next(uint celt, char* psir, uint* pceltFetched);
    ///Skips a specified number of resources.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of resources to skip.
    HRESULT Skip(uint celt);
    ///Resets the enumeration index to 0.
    HRESULT Reset();
    ///Clones a resource enumerator.
    ///Params:
    ///    ppenumr = Type: <b>IEnumResources**</b> Contains the address of an IEnumResources interface pointer.
    HRESULT Clone(IEnumResources* ppenumr);
}

///Exposes methods to manipulate and query Shell item resources.
@GUID("FF5693BE-2CE0-4D48-B5C5-40817D1ACDB9")
interface IShellItemResources : IUnknown
{
    ///Gets resource attributes.
    ///Params:
    ///    pdwAttributes = Type: <b>DWORD*</b> A pointer to resource attributes. The following are attribute values.
    HRESULT GetAttributes(uint* pdwAttributes);
    ///Gets the source size.
    ///Params:
    ///    pullSize = Type: <b>ULONGLONG*</b> A pointer to the source size.
    HRESULT GetSize(ulong* pullSize);
    ///Gets file times.
    ///Params:
    ///    pftCreation = Type: <b>FILETIME*</b> A pointer to the creation date and time as a FILETIME structure.
    ///    pftWrite = Type: <b>FILETIME*</b> A pointer to write date and time as a FILETIME structure.
    ///    pftAccess = Type: <b>FILETIME*</b> A pointer to access date and time as a FILETIME structure.
    HRESULT GetTimes(FILETIME* pftCreation, FILETIME* pftWrite, FILETIME* pftAccess);
    ///Sets file times.
    ///Params:
    ///    pftCreation = Type: <b>const FILETIME*</b> A pointer to a creation date and time as a FILETIME structure.
    ///    pftWrite = Type: <b>const FILETIME*</b> A pointer to a write date and time as a FILETIME structure.
    ///    pftAccess = Type: <b>const FILETIME*</b> A pointer to an access date and time as a FILETIME structure.
    HRESULT SetTimes(const(FILETIME)* pftCreation, const(FILETIME)* pftWrite, const(FILETIME)* pftAccess);
    ///Gets a resource description.
    ///Params:
    ///    pcsir = Type: <b>const SHELL_ITEM_RESOURCE*</b> A pointer to a SHELL_ITEM_RESOURCE resource.
    ///    ppszDescription = Type: <b>LPWSTR*</b> A pointer to a resource description as a Unicode string.
    HRESULT GetResourceDescription(const(SHELL_ITEM_RESOURCE)* pcsir, ushort** ppszDescription);
    ///Gets a resource enumerator object.
    ///Params:
    ///    ppenumr = Type: <b>IEnumResources**</b> The address of an IEnumResources interface pointer.
    HRESULT EnumResources(IEnumResources* ppenumr);
    ///Retrieves whether an item supports a specified resource.
    ///Params:
    ///    pcsir = Type: <b>const SHELL_ITEM_RESOURCE*</b> A pointer to a SHELL_ITEM_RESOURCE resource.
    HRESULT SupportsResource(const(SHELL_ITEM_RESOURCE)* pcsir);
    ///Opens a specified resource.
    ///Params:
    ///    pcsir = Type: <b>const SHELL_ITEM_RESOURCE*</b> A pointer to a SHELL_ITEM_RESOURCE resource.
    ///    riid = Type: <b>REFIID</b> A reference to a desired IID.
    ///    ppv = Type: <b>void**</b> The address of a pointer to a resource.
    HRESULT OpenResource(const(SHELL_ITEM_RESOURCE)* pcsir, const(GUID)* riid, void** ppv);
    ///Creates a specified resource.
    ///Params:
    ///    pcsir = Type: <b>const SHELL_ITEM_RESOURCE*</b> A pointer to an SHELL_ITEM_RESOURCE resource.
    ///    riid = Type: <b>REFIID</b> A reference to a desired IID.
    ///    ppv = Type: <b>void**</b> The address of a pointer to the resource.
    HRESULT CreateResource(const(SHELL_ITEM_RESOURCE)* pcsir, const(GUID)* riid, void** ppv);
    ///Marks for delete.
    HRESULT MarkForDelete();
}

///Exposes methods that create a destination Shell item for a copy or move operation. This interface is provided to
///allow more control over file operations by providing an ITransferDestination::Advise method.
@GUID("48ADDD32-3CA5-4124-ABE3-B5A72531B207")
interface ITransferDestination : IUnknown
{
    ///Sets up an advisory connection for notifications on the status of file operations.
    ///Params:
    ///    psink = Type: <b>ITransferAdviseSink*</b> A pointer to an ITransferAdviseSink notification interface to update the
    ///            calling application using methods on this interface.
    ///    pdwCookie = Type: <b>DWORD*</b> A pointer to a returned token that uniquely identifies this connection. The calling
    ///                application uses this token later to delete the connection by passing it to the
    ///                ITransferDestination::Unadvise method. If the connection is not successfully established, this value is zero.
    ///Returns:
    ///    Type: <b>HRESULT</b> Any HRESULTs other than listed indicate a failure. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    Interface successfully associated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> The handler can only handle one sink interface. </td> </tr> </table>
    ///    
    HRESULT Advise(ITransferAdviseSink psink, uint* pdwCookie);
    ///Terminates an advisory connection.
    ///Params:
    ///    dwCookie = Type: <b>DWORD</b> A connection token previously returned from ITransferDestination::Advise. Identifies the
    ///               connection to be terminated.
    ///Returns:
    ///    Type: <b>HRESULT</b> Any HRESULTs other than those listed here indicate a failure. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The connection was successfully terminated. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CONNECT_E_NOCONNECTION</b></dt> </dl> </td> <td width="60%"> The value in <i>dwCookie</i> does not
    ///    represent a valid connection. </td> </tr> </table>
    ///    
    HRESULT Unadvise(uint dwCookie);
    ///Creates the specified file.
    ///Params:
    ///    pszName = Type: <b>LPCWSTR</b> A pointer to a null-terminated buffer that contains the name of the file relative to the
    ///              current directory.
    ///    dwAttributes = Type: <b>DWORD</b> One or more of the FILE_ATTRIBUTE flags defined in the BY_HANDLE_FILE_INFORMATION
    ///                   structure. The most significant value is FILE_ATTRIBUTE_DIRECTORY, which indicates that a folder should be
    ///                   created.
    ///    ullSize = Type: <b>ULONGLONG</b> The size, in bytes, of the file to create. This value can be 0 if the size is unknown.
    ///    flags = Type: <b>TRANSFER_SOURCE_FLAGS</b> Flags that control the file operation. One or more of the
    ///            TRANSFER_SOURCE_FLAGS flags.
    ///    riidItem = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppvItem</i>, typically
    ///               IID_IShellItem or another interface that derives from it.
    ///    ppvItem = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riidItem</i>.
    ///              This is typically IShellItem or a derived interface.
    ///    riidResources = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppvResources</i>,
    ///                    typically IID_IShellItemResources or another interface that derives from it.
    ///    ppvResources = Type: <b>void**</b> When this method returns, contains the interface pointer requested in
    ///                   <i>riidResources</i>. This is typically IShellItemResources or a derived interface.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns a success code if successful, or an error value otherwise. Success codes
    ///    include: <ul> <li><b>S_OK</b>: The move succeeded and <i>ppvItem</i> and <i>ppvResources</i> both point to
    ///    valid objects.</li> <li><b>COPYENGINE_S_USER_IGNORED</b>: The destination item already exists and has not
    ///    been overwritten. The values pointed to by <i>ppvItem</i> and <i>ppvResources</i> are <b>NULL</b>. If the
    ///    caller is implementing a move as a copy and delete operation, the caller should complete the move by deleting
    ///    the source item.</li> </ul>
    ///    
    HRESULT CreateItem(const(wchar)* pszName, uint dwAttributes, ulong ullSize, uint flags, const(GUID)* riidItem, 
                       void** ppvItem, const(GUID)* riidResources, void** ppvResources);
}

///Exposes methods that provide a rich notification system used by callers of IFileOperation to monitor the details of
///the operations they are performing through that interface.
@GUID("04B0F1A7-9490-44BC-96E1-4296A31252E2")
interface IFileOperationProgressSink : IUnknown
{
    ///Performs caller-implemented actions before any specific file operations are performed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StartOperations();
    ///Performs caller-implemented actions after the last operation performed by the call to IFileOperation is complete.
    ///Params:
    ///    hrResult = Type: <b>HRESULT</b> The return value of the final operation. Note that this is not the HRESULT returned by
    ///               one of the IFileOperation methods, which simply queue the operations. Instead, this is the result of the
    ///               actual operation, such as copy, delete, or move.
    HRESULT FinishOperations(HRESULT hrResult);
    ///Performs caller-implemented actions before the rename process for each item begins.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> bitwise value that contains flags that control the operation. See TRANSFER_SOURCE_FLAGS
    ///              for flag descriptions.
    ///    psiItem = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the item to be renamed.
    ///    pszNewName = Type: <b>LPCWSTR</b> Pointer to the new display name of the item. This is a null-terminated, Unicode string.
    HRESULT PreRenameItem(uint dwFlags, IShellItem psiItem, const(wchar)* pszNewName);
    ///Performs caller-implemented actions after the rename process for each item is complete.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> bitwise value that contains flags that were used during the rename operation. Some values
    ///              can be set or changed during the rename operation. See TRANSFER_SOURCE_FLAGS for flag descriptions.
    ///    psiItem = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the item before it was renamed.
    ///    pszNewName = Type: <b>LPCWSTR</b> Pointer to the new display name of the item. This is a null-terminated, Unicode string.
    ///                 Note that this might not be the name that you asked for, given collisions and other naming rules.
    ///    hrRename = Type: <b>HRESULT</b> The return value of the rename operation. Note that this is not the HRESULT returned by
    ///               RenameItem, which simply queues the rename operation. Instead, this is the result of the actual rename
    ///               operation.
    ///    psiNewlyCreated = Type: <b>IShellItem*</b> Pointer to an IShellItem that represents the item with its new name.
    HRESULT PostRenameItem(uint dwFlags, IShellItem psiItem, const(wchar)* pszNewName, HRESULT hrRename, 
                           IShellItem psiNewlyCreated);
    ///Performs caller-implemented actions before the move process for each item begins.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> bitwise value that contains flags that control the operation. See TRANSFER_SOURCE_FLAGS
    ///              for flag descriptions.
    ///    psiItem = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the item to be moved.
    ///    psiDestinationFolder = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the destination folder to contain the moved
    ///                           item.
    ///    pszNewName = Type: <b>LPCWSTR</b> Pointer to a new name for the item in its new location. This is a null-terminated
    ///                 Unicode string and can be <b>NULL</b>. If <b>NULL</b>, the name of the destination item is the same as the
    ///                 source.
    HRESULT PreMoveItem(uint dwFlags, IShellItem psiItem, IShellItem psiDestinationFolder, 
                        const(wchar)* pszNewName);
    ///Performs caller-implemented actions after the move process for each item is complete.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> bitwise value that contains flags that were used during the move operation. Some values
    ///              can be set or changed during the move operation. See TRANSFER_SOURCE_FLAGS for flag descriptions.
    ///    psiItem = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the source item.
    ///    psiDestinationFolder = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the destination folder that contains the
    ///                           moved item.
    ///    pszNewName = Type: <b>LPCWSTR</b> Pointer to the name that was given to the item after it was moved. This is a
    ///                 null-terminated Unicode string. Note that this might not be the name that you asked for, given collisions and
    ///                 other naming rules.
    ///    hrMove = Type: <b>HRESULT</b> The return value of the move operation. Note that this is not the HRESULT returned by
    ///             MoveItem, which simply queues the move operation. Instead, this is the result of the actual move.
    ///    psiNewlyCreated = Type: <b>IShellItem*</b> Pointer to an IShellItem that represents the moved item in its new location.
    HRESULT PostMoveItem(uint dwFlags, IShellItem psiItem, IShellItem psiDestinationFolder, 
                         const(wchar)* pszNewName, HRESULT hrMove, IShellItem psiNewlyCreated);
    ///Performs caller-implemented actions before the copy process for each item begins.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> bitwise value that contains flags that control the operation. See TRANSFER_SOURCE_FLAGS
    ///              for flag descriptions.
    ///    psiItem = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the source item.
    ///    psiDestinationFolder = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the destination folder to contain the copy
    ///                           of the item.
    ///    pszNewName = Type: <b>LPCWSTR</b> Pointer to a new name for the item after it has been copied. This is a null-terminated
    ///                 Unicode string and can be <b>NULL</b>. If <b>NULL</b>, the name of the destination item is the same as the
    ///                 source.
    HRESULT PreCopyItem(uint dwFlags, IShellItem psiItem, IShellItem psiDestinationFolder, 
                        const(wchar)* pszNewName);
    ///Performs caller-implemented actions after the copy process for each item is complete.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> bitwise value that contains flags that were used during the copy operation. Some values
    ///              can be set or changed during the copy operation. See TRANSFER_SOURCE_FLAGS for flag descriptions.
    ///    psiItem = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the source item.
    ///    psiDestinationFolder = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the destination folder to which the item was
    ///                           copied.
    ///    pszNewName = Type: <b>LPCWSTR</b> Pointer to the new name that was given to the item after it was copied. This is a
    ///                 null-terminated Unicode string. Note that this might not be the name that you asked for, given collisions and
    ///                 other naming rules.
    ///    hrCopy = Type: <b>HRESULT</b> The return value of the copy operation. Note that this is not the HRESULT returned by
    ///             CopyItem, which simply queues the copy operation. Instead, this is the result of the actual copy.
    ///    psiNewlyCreated = Type: <b>IShellItem*</b> Pointer to an IShellItem that represents the new copy of the item.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. In the case of an error value,
    ///    all subsequent operations pending from the call to IFileOperation are canceled.
    ///    
    HRESULT PostCopyItem(uint dwFlags, IShellItem psiItem, IShellItem psiDestinationFolder, 
                         const(wchar)* pszNewName, HRESULT hrCopy, IShellItem psiNewlyCreated);
    ///Performs caller-implemented actions before the delete process for each item begins.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> bitwise value that contains flags that control the operation. See TRANSFER_SOURCE_FLAGS
    ///              for flag descriptions.
    ///    psiItem = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the item to be deleted.
    HRESULT PreDeleteItem(uint dwFlags, IShellItem psiItem);
    ///Performs caller-implemented actions after the delete process for each item is complete.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> bitwise value that contains flags that were used during the delete operation. Some values
    ///              can be set or changed during the delete operation. See TRANSFER_SOURCE_FLAGS for flag descriptions.
    ///    psiItem = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the item that was deleted.
    ///    hrDelete = Type: <b>HRESULT</b> The return value of the delete operation. Note that this is not the HRESULT returned by
    ///               DeleteItem, which simply queues the delete operation. Instead, this is the result of the actual deletion.
    ///    psiNewlyCreated = Type: <b>IShellItem*</b> A pointer to an IShellItem that specifies the deleted item, now in the Recycle Bin.
    ///                      If the item was fully deleted, this value is <b>NULL</b>.
    HRESULT PostDeleteItem(uint dwFlags, IShellItem psiItem, HRESULT hrDelete, IShellItem psiNewlyCreated);
    ///Performs caller-implemented actions before the process to create a new item begins.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> bitwise value that contains flags that control the operation. See TRANSFER_SOURCE_FLAGS
    ///              for flag descriptions.
    ///    psiDestinationFolder = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the destination folder that will contain the
    ///                           new item.
    ///    pszNewName = Type: <b>LPCWSTR</b> Pointer to the file name of the new item, for instance <b>Newfile.txt</b>. This is a
    ///                 null-terminated, Unicode string.
    HRESULT PreNewItem(uint dwFlags, IShellItem psiDestinationFolder, const(wchar)* pszNewName);
    ///Performs caller-implemented actions after the new item is created.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> bitwise value that contains flags that were used during the creation operation. Some
    ///              values can be set or changed during the creation operation. See TRANSFER_SOURCE_FLAGS for flag descriptions.
    ///    psiDestinationFolder = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the destination folder to which the new item
    ///                           was added.
    ///    pszNewName = Type: <b>LPCWSTR</b> Pointer to the file name of the new item, for instance <b>Newfile.txt</b>. This is a
    ///                 null-terminated, Unicode string.
    ///    pszTemplateName = Type: <b>LPCWSTR</b> Pointer to the name of the template file (for example <b>Excel9.xls</b>) that the new
    ///                      item is based on, stored in one of the following locations: <ul> <li>CSIDL_COMMON_TEMPLATES. The default path
    ///                      for this folder is %ALLUSERSPROFILE%\Templates.</li> <li>CSIDL_TEMPLATES. The default path for this folder is
    ///                      %USERPROFILE%\Templates.</li> <li>%SystemRoot%\shellnew</li> </ul> This is a null-terminated, Unicode string
    ///                      used to specify an existing file of the same type as the new file, containing the minimal content that an
    ///                      application wants to include in any new file. This parameter is normally <b>NULL</b> to specify a new, blank
    ///                      file.
    ///    dwFileAttributes = Type: <b>DWORD</b> The file attributes applied to the new item. One or more of the values found at
    ///                       GetFileAttributes.
    ///    hrNew = Type: <b>HRESULT</b> The return value of the creation operation. Note that this is not the HRESULT returned
    ///            by NewItem, which simply queues the creation operation. Instead, this is the result of the actual creation.
    ///    psiNewItem = Type: <b>IShellItem*</b> Pointer to an IShellItem that represents the new item.
    HRESULT PostNewItem(uint dwFlags, IShellItem psiDestinationFolder, const(wchar)* pszNewName, 
                        const(wchar)* pszTemplateName, uint dwFileAttributes, HRESULT hrNew, IShellItem psiNewItem);
    ///Provides an estimate of the total amount of work currently done in relation to the total amount of work.
    ///Params:
    ///    iWorkTotal = Type: <b>UINT</b> An estimate of the amount of work to be completed.
    ///    iWorkSoFar = Type: <b>UINT</b> The portion of <i>iWorkTotal</i> that has been completed so far.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UpdateProgress(uint iWorkTotal, uint iWorkSoFar);
    ///Not supported.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ResetTimer();
    ///Not supported.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT PauseTimer();
    ///Not supported.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ResumeTimer();
}

///Exposes methods that create and manipulate Shell item arrays.
@GUID("B63EA76D-1F85-456F-A19C-48159EFA858B")
interface IShellItemArray : IUnknown
{
    ///Binds to an object by means of the specified handler.
    ///Params:
    ///    pbc = Type: <b>IBindCtx*</b> A pointer to an IBindCtx interface on a bind context object.
    ///    bhid = Type: <b>REFGUID</b> One of the following values, defined in Shlguid.h, that determine the handler.
    ///    riid = Type: <b>REFIID</b> The IID of the object type to retrieve.
    ///    ppvOut = Type: <b>void**</b> When this methods returns, contains the object specified in <i>riid</i> that is returned
    ///             by the handler specified by <i>rbhid</i>.
    HRESULT BindToHandler(IBindCtx pbc, const(GUID)* bhid, const(GUID)* riid, void** ppvOut);
    ///Gets a property store.
    ///Params:
    ///    flags = Type: <b>GETPROPERTYSTOREFLAGS</b> One of the GETPROPERTYSTOREFLAGS constants.
    ///    riid = Type: <b>REFIID</b> The IID of the object type to retrieve.
    ///    ppv = Type: <b>void**</b> When this method returns, contains interface pointer requested in riid. This is typically
    ///          IPropertyStore or IPropertyStoreCapabilities.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPropertyStore(GETPROPERTYSTOREFLAGS flags, const(GUID)* riid, void** ppv);
    ///Gets a property description list for the items in the shell item array.
    ///Params:
    ///    keyType = Type: <b>REFPROPERTYKEY</b> A reference to the PROPERTYKEY structure specifying which property list to
    ///              retrieve.
    ///    riid = Type: <b>REFIID</b> The IID of the object type to retrieve.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the interface requested in riid. This will typically
    ///          be IPropertyDescriptionList.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPropertyDescriptionList(const(PROPERTYKEY)* keyType, const(GUID)* riid, void** ppv);
    ///Gets the attributes of the set of items contained in an IShellItemArray. If the array contains more than one
    ///item, the attributes retrieved by this method are not the attributes of single items, but a logical combination
    ///of all of the requested attributes of all of the items.
    ///Params:
    ///    AttribFlags = Type: <b>SIATTRIBFLAGS</b> If the array contains a single item, this method provides the same results as
    ///                  GetAttributes. However, if the array contains multiple items, the attribute sets of all the items are
    ///                  combined into a single attribute set and returned in the value pointed to by <i>psfgaoAttribs</i>. This
    ///                  parameter takes one of the following values to define how that final attribute set is determined:
    ///    sfgaoMask = Type: <b>SFGAOF</b> A mask that specifies what particular attributes are being requested. A bitwise OR of one
    ///                or more of the SFGAO values.
    ///    psfgaoAttribs = Type: <b>SFGAOF*</b> A bitmap that, when this method returns successfully, contains the values of the
    ///                    requested attributes.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the attributes returned exactly match those requested in
    ///    <i>sfgaoMask</i>, S_FALSE if the attributes do not exactly match, or a standard COM error value otherwise.
    ///    
    HRESULT GetAttributes(SIATTRIBFLAGS AttribFlags, uint sfgaoMask, uint* psfgaoAttribs);
    ///Gets the number of items in the given IShellItem array.
    ///Params:
    ///    pdwNumItems = Type: <b>DWORD*</b> When this method returns, contains the number of items in the IShellItemArray.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCount(uint* pdwNumItems);
    ///Gets the item at the given index in the IShellItemArray.
    ///Params:
    ///    dwIndex = Type: <b>DWORD</b> The index of the IShellItem requested in the IShellItemArray
    ///    ppsi = Type: <b>IShellItem**</b> When this method returns, contains the requested IShellItem pointer.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetItemAt(uint dwIndex, IShellItem* ppsi);
    ///Gets an enumerator of the items in the array.
    ///Params:
    ///    ppenumShellItems = Type: <b>IEnumShellItems**</b> When this method returns, contains an IEnumShellItems pointer that enumerates
    ///                       the shell items that are in the array.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnumItems(IEnumShellItems* ppenumShellItems);
}

///Exposes a method used to initialize a handler, such as a property handler, thumbnail handler, or preview handler,
///with an IShellItem.
@GUID("7F73BE3F-FB79-493C-A6C7-7EE14E245841")
interface IInitializeWithItem : IUnknown
{
    ///Initializes a handler with an IShellItem.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to an IShellItem.
    ///    grfMode = Type: <b>DWORD</b> One of the following STGM values that indicate the access mode for <i>psi</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(IShellItem psi, uint grfMode);
}

///Exposes methods that get or set selected items represented by a Shell item array.
@GUID("1C9CD5BB-98E9-4491-A60F-31AACC72B83C")
interface IObjectWithSelection : IUnknown
{
    ///Provides the Shell item array that specifies the items included in the selection.
    ///Params:
    ///    psia = Type: <b>IShellItemArray*</b> A pointer to an IShellItemArray that represents the selected items.
    HRESULT SetSelection(IShellItemArray psia);
    ///Gets the Shell item array that contains the selected items.
    ///Params:
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>, typically
    ///           IID_IShellItemArray.
    ///    ppv = Type: <b>void**</b> When this method returns successfully, contains the interface pointer requested in
    ///          <i>riid</i>. This is typically an IShellItemArray.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSelection(const(GUID)* riid, void** ppv);
}

///Provides a method for interacting with back references held by an object.
@GUID("321A6A6A-D61F-4BF3-97AE-14BE2986BB36")
interface IObjectWithBackReferences : IUnknown
{
    ///Removes all back references held by an object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveBackReferences();
}

///Exposes a list of categorizers registered on an IShellFolder.
@GUID("9AF64809-5864-4C26-A720-C1F78C086EE3")
interface ICategoryProvider : IUnknown
{
    ///Determines whether a column can be used as a category.
    ///Params:
    ///    pscid = Type: <b>const SHCOLUMNID*</b> A pointer to a SHCOLUMNID structure that identifies the column. Valid only
    ///            when S_OK is returned. The GUID contained in this structure is then passed to
    ///            ICategoryProvider::CreateCategory.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the column can be used as a category or S_FALSE if not.
    ///    
    HRESULT CanCategorizeOnSCID(const(PROPERTYKEY)* pscid);
    ///Enables the folder to override the default grouping.
    ///Params:
    ///    pguid = Type: <b>GUID*</b> Not used.
    ///    pscid = Type: <b>SHCOLUMNID*</b> When this method returns, contains a pointer to a SHCOLUMNID structure.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> There is no default group. </td> </tr> </table>
    ///    
    HRESULT GetDefaultCategory(GUID* pguid, PROPERTYKEY* pscid);
    ///Gets a GUID that represents the categorizer to use for the specified Shell column.
    ///Params:
    ///    pscid = Type: <b>const SHCOLUMNID*</b> A pointer to a SHCOLUMNID structure.
    ///    pguid = Type: <b>GUID*</b> When this method returns, contains a pointer to a GUID that represents the categorizer to
    ///            use for the SHCOLUMNID pointed to by <i>pscid</i>.
    HRESULT GetCategoryForSCID(const(PROPERTYKEY)* pscid, GUID* pguid);
    ///Gets the enumerator for the list of GUIDs that represent categories.
    ///Params:
    ///    penum = Type: <b>IEnumGUID**</b> When this method returns, contains the address of a pointer to an <b>IEnumGUID</b>
    ///            interface that specifies a list of GUIDs that represent categories.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnumCategories(IEnumGUID* penum);
    ///Gets the name of the specified category.
    ///Params:
    ///    pguid = Type: <b>const GUID*</b> A pointer to a GUID.
    ///    pszName = Type: <b>LPWSTR</b> When this method returns, contains a pointer to a string that receives the name of the
    ///              category.
    ///    cch = Type: <b>UINT</b> An integer that receives the number of characters in the string.
    HRESULT GetCategoryName(const(GUID)* pguid, const(wchar)* pszName, uint cch);
    ///Creates a category object.
    ///Params:
    ///    pguid = Type: <b>const GUID*</b> A pointer to the <b>GUID</b> for the category object.
    ///    riid = Type: <b>REFIID</b> The identifier of the object to return. Currently, the only value supported by the system
    ///           folder view object is IID_ICategorizer.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the address of a pointer to the category object.
    HRESULT CreateCategory(const(GUID)* pguid, const(GUID)* riid, void** ppv);
}

///Exposes methods that are used to obtain information about item identifier lists.
@GUID("A3B14589-9174-49A8-89A3-06A1AE2B9BA7")
interface ICategorizer : IUnknown
{
    ///Gets the name of a categorizer, such as <i>Group By Device Type</i>, that can be displayed in the UI.
    ///Params:
    ///    pszDesc = Type: <b>LPWSTR</b> When this method returns, contains a pointer to a string of length <i>cch</i> that
    ///              contains the categorizer name.
    ///    cch = Type: <b>UINT</b> The number of characters in the <i>pszDesc</i> buffer.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDescription(const(wchar)* pszDesc, uint cch);
    ///Gets a list of categories associated with a list of identifiers.
    ///Params:
    ///    cidl = Type: <b>UINT</b> The number of items in an item identifier list array.
    ///    apidl = Type: <b>PCUITEMID_CHILD_ARRAY*</b> A pointer to an array of <i>cidl</i> item identifier list pointers.
    ///    rgCategoryIds = Type: <b>DWORD*</b> When this method returns, contains a pointer to an array of <i>cidl</i> category
    ///                    identifiers.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCategory(uint cidl, char* apidl, char* rgCategoryIds);
    ///Gets information about a category, such as the default display and the text to display in the UI.
    ///Params:
    ///    dwCategoryId = Type: <b>DWORD</b> A <b>DWORD</b> that specifies a category identifier.
    ///    pci = Type: <b>CATEGORY_INFO*</b> When this method returns, contains a pointer to a CATEGORY_INFO structure that
    ///          contains the category information.
    HRESULT GetCategoryInfo(uint dwCategoryId, CATEGORY_INFO* pci);
    ///Determines the relative order of two items in their item identifier lists, and hence in the UI.
    ///Params:
    ///    csfFlags = Type: <b>CATSORT_FLAGS</b> A flag that specifies how the comparison should be performed. The parameter should
    ///               be one of the values in CATSORT_FLAGS.
    ///    dwCategoryId1 = Type: <b>DWORD</b> A <b>DWORD</b> that specifies the first category identifier to use in the comparison.
    ///    dwCategoryId2 = Type: <b>DWORD</b> A <b>DWORD</b> that specifies the second category identifier to use in the comparison.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method is successful, the CODE field of the HRESULT contains a value that
    ///    specifies the outcome of the comparison, otherwise it returns a COM error code.
    ///    
    HRESULT CompareCategory(CATSORT_FLAGS csfFlags, uint dwCategoryId1, uint dwCategoryId2);
}

///Exposes methods that allow drop targets to display a drag image while the image is over the target window.
@GUID("4657278B-411B-11D2-839A-00C04FD918D0")
interface IDropTargetHelper : IUnknown
{
    ///Notifies the drag-image manager that the drop target's IDropTarget::DragEnter method has been called.
    ///Params:
    ///    hwndTarget = Type: <b>HWND</b> The target's window handle.
    ///    pDataObject = Type: <b>IDataObject*</b> A pointer to the data object's IDataObject interface.
    ///    ppt = Type: <b>POINT*</b> The POINT structure pointer that was received in the IDropTarget::DragEnter method's
    ///          <i>pt</i> parameter.
    ///    dwEffect = Type: <b>DWORD</b> The value pointed to by the IDropTarget::DragEnter method's <i>pdwEffect</i> parameter.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
    ///    
    HRESULT DragEnter(HWND hwndTarget, IDataObject pDataObject, POINT* ppt, uint dwEffect);
    ///Notifies the drag-image manager that the drop target's IDropTarget::DragLeave method has been called.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
    ///    
    HRESULT DragLeave();
    ///Notifies the drag-image manager that the drop target's IDropTarget::DragOver method has been called.
    ///Params:
    ///    ppt = Type: <b>POINT*</b> The POINT structure pointer that was received in the IDropTarget::DragOver method's
    ///          <i>pt</i> parameter.
    ///    dwEffect = Type: <b>DWORD</b> The value pointed to by the IDropTarget::DragOver method's <i>pdwEffect</i> parameter.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
    ///    
    HRESULT DragOver(POINT* ppt, uint dwEffect);
    ///Notifies the drag-image manager that the drop target's IDropTarget::Drop method has been called.
    ///Params:
    ///    pDataObject = Type: <b>IDataObject*</b> A pointer to the data object's IDataObject interface.
    ///    ppt = Type: <b>POINT*</b> A POINT structure pointer that was received in the IDropTarget::Drop method's <i>pt</i>
    ///          parameter.
    ///    dwEffect = Type: <b>DWORD</b> The value pointed to by the IDropTarget::Drop method's <i>pdwEffect</i> parameter.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
    ///    
    HRESULT Drop(IDataObject pDataObject, POINT* ppt, uint dwEffect);
    ///Notifies the drag-image manager to show or hide the drag image.
    ///Params:
    ///    fShow = Type: <b>BOOL</b> A boolean value that is set to <b>TRUE</b> to show the drag image, and <b>FALSE</b> to hide
    ///            it.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
    ///    
    HRESULT Show(BOOL fShow);
}

///Exposed by the Shell to allow an application to specify the image that will be displayed during a Shell drag-and-drop
///operation.
@GUID("DE5BF786-477A-11D2-839D-00C04FD918D0")
interface IDragSourceHelper : IUnknown
{
    ///Initializes the drag-image manager for a windowless control.
    ///Params:
    ///    pshdi = Type: <b>LPSHDRAGIMAGE</b> The SHDRAGIMAGE structure that contains information about the bitmap.
    ///    pDataObject = Type: <b>IDataObject*</b> A pointer to the data object's IDataObject interface.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InitializeFromBitmap(SHDRAGIMAGE* pshdi, IDataObject pDataObject);
    ///Initializes the drag-image manager for a control with a window.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> A handle to the window that receives the <b>DI_GETDRAGIMAGE</b> message. This value can be
    ///           <b>NULL</b>.
    ///    ppt = Type: <b>POINT*</b> A pointer to a POINT structure that specifies the location of the cursor within the drag
    ///          image. The structure should contain the offset from the upper-left corner of the drag image to the location
    ///          of the cursor. This value can be <b>NULL</b>.
    ///    pDataObject = Type: <b>IDataObject*</b> A pointer to the data object's IDataObject interface.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InitializeFromWindow(HWND hwnd, POINT* ppt, IDataObject pDataObject);
}

///Exposes methods that create, modify, and resolve Shell links.
@GUID("000214EE-0000-0000-C000-000000000046")
interface IShellLinkA : IUnknown
{
    ///Gets the path and file name of the target of a Shell link object.
    ///Params:
    ///    pszFile = Type: <b>LPTSTR</b> The address of a buffer that receives the path and file name of the target of the Shell
    ///              link object.
    ///    cch = Type: <b>int</b> The size, in characters, of the buffer pointed to by the <i>pszFile</i> parameter, including
    ///          the terminating null character. The maximum path size that can be returned is MAX_PATH. This parameter is
    ///          commonly set by calling ARRAYSIZE(pszFile). The ARRAYSIZE macro is defined in Winnt.h.
    ///    pfd = Type: <b>WIN32_FIND_DATA*</b> A pointer to a WIN32_FIND_DATA structure that receives information about the
    ///          target of the Shell link object. If this parameter is <b>NULL</b>, then no additional information is
    ///          returned.
    ///    fFlags = Type: <b>DWORD</b> Flags that specify the type of path information to retrieve. This parameter can be a
    ///             combination of the following values.
    HRESULT GetPath(const(char)* pszFile, int cch, WIN32_FIND_DATAA* pfd, uint fFlags);
    ///Gets the list of item identifiers for the target of a Shell link object.
    ///Params:
    ///    ppidl = Type: <b>PIDLIST_ABSOLUTE*</b> When this method returns, contains the address of a PIDL.
    HRESULT GetIDList(ITEMIDLIST** ppidl);
    ///Sets the pointer to an item identifier list (PIDL) for a Shell link object.
    ///Params:
    ///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> The object's fully qualified PIDL.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetIDList(ITEMIDLIST* pidl);
    ///Gets the description string for a Shell link object.
    ///Params:
    ///    pszName = Type: <b>LPTSTR</b> A pointer to the buffer that receives the description string.
    ///    cch = Type: <b>int</b> The maximum number of characters to copy to the buffer pointed to by the <i>pszName</i>
    ///          parameter.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDescription(const(char)* pszName, int cch);
    ///Sets the description for a Shell link object. The description can be any application-defined string.
    ///Params:
    ///    pszName = Type: <b>LPCTSTR</b> A pointer to a buffer containing the new description string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDescription(const(char)* pszName);
    ///Gets the name of the working directory for a Shell link object.
    ///Params:
    ///    pszDir = Type: <b>LPTSTR</b> The address of a buffer that receives the name of the working directory.
    ///    cch = Type: <b>int</b> The maximum number of characters to copy to the buffer pointed to by the <i>pszDir</i>
    ///          parameter. The name of the working directory is truncated if it is longer than the maximum specified by this
    ///          parameter.
    HRESULT GetWorkingDirectory(const(char)* pszDir, int cch);
    ///Sets the name of the working directory for a Shell link object.
    ///Params:
    ///    pszDir = Type: <b>LPCTSTR</b> The address of a buffer that contains the name of the new working directory.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetWorkingDirectory(const(char)* pszDir);
    ///Gets the command-line arguments associated with a Shell link object.
    ///Params:
    ///    pszArgs = Type: <b>LPTSTR</b> A pointer to the buffer that, when this method returns successfully, receives the
    ///              command-line arguments.
    ///    cch = Type: <b>int</b> The maximum number of characters that can be copied to the buffer supplied by the
    ///          <i>pszArgs</i> parameter. In the case of a Unicode string, there is no limitation on maximum string length.
    ///          In the case of an ANSI string, the maximum length of the returned string varies depending on the version of
    ///          Windows—MAX_PATH prior to Windows 2000 and INFOTIPSIZE (defined in Commctrl.h) in Windows 2000 and later.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetArguments(const(char)* pszArgs, int cch);
    ///Sets the command-line arguments for a Shell link object.
    ///Params:
    ///    pszArgs = Type: <b>LPCTSTR</b> A pointer to a buffer that contains the new command-line arguments. In the case of a
    ///              Unicode string, there is no limitation on maximum string length. In the case of an ANSI string, the maximum
    ///              length of the returned string varies depending on the version of Windows—MAX_PATH prior to Windows 2000 and
    ///              INFOTIPSIZE (defined in Commctrl.h) in Windows 2000 and later.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetArguments(const(char)* pszArgs);
    ///Gets the keyboard shortcut (hot key) for a Shell link object.
    ///Params:
    ///    pwHotkey = Type: <b>WORD*</b> The address of the keyboard shortcut. The virtual key code is in the low-order byte, and
    ///               the modifier flags are in the high-order byte. The modifier flags can be a combination of the following
    ///               values.
    HRESULT GetHotkey(ushort* pwHotkey);
    ///Sets a keyboard shortcut (hot key) for a Shell link object.
    ///Params:
    ///    wHotkey = Type: <b>WORD</b> The new keyboard shortcut. The virtual key code is in the low-order byte, and the modifier
    ///              flags are in the high-order byte. The modifier flags can be a combination of the values specified in the
    ///              description of the IShellLink::GetHotkey method.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetHotkey(ushort wHotkey);
    ///Gets the show command for a Shell link object.
    ///Params:
    ///    piShowCmd = Type: <b>int*</b> A pointer to the command. The following commands are supported.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetShowCmd(int* piShowCmd);
    ///Sets the show command for a Shell link object. The show command sets the initial show state of the window.
    ///Params:
    ///    iShowCmd = Type: <b>int</b> Command. <b>SetShowCmd</b> accepts one of the following ShowWindow commands.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetShowCmd(int iShowCmd);
    ///Gets the location (path and index) of the icon for a Shell link object.
    ///Params:
    ///    pszIconPath = Type: <b>LPTSTR</b> The address of a buffer that receives the path of the file containing the icon.
    ///    cch = Type: <b>int</b> The maximum number of characters to copy to the buffer pointed to by the <i>pszIconPath</i>
    ///          parameter.
    ///    piIcon = Type: <b>int*</b> The address of a value that receives the index of the icon.
    HRESULT GetIconLocation(const(char)* pszIconPath, int cch, int* piIcon);
    ///Sets the location (path and index) of the icon for a Shell link object.
    ///Params:
    ///    pszIconPath = Type: <b>LPCTSTR</b> The address of a buffer to contain the path of the file containing the icon.
    ///    iIcon = Type: <b>int</b> The index of the icon.
    HRESULT SetIconLocation(const(char)* pszIconPath, int iIcon);
    ///Sets the relative path to the Shell link object.
    ///Params:
    ///    pszPathRel = Type: <b>LPCTSTR</b> The address of a buffer that contains the fully-qualified path of the shortcut file,
    ///                 relative to which the shortcut resolution should be performed. It should be a file name, not a folder name.
    ///    dwReserved = Type: <b>DWORD</b> Reserved. Set this parameter to zero.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRelativePath(const(char)* pszPathRel, uint dwReserved);
    ///Attempts to find the target of a Shell link, even if it has been moved or renamed.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> A handle to the window that the Shell will use as the parent for a dialog box. The Shell
    ///           displays the dialog box if it needs to prompt the user for more information while resolving a Shell link.
    ///    fFlags = Type: <b>DWORD</b> Action flags. This parameter can be a combination of the following values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Resolve(HWND hwnd, uint fFlags);
    ///Sets the path and file name for the target of a Shell link object.
    ///Params:
    ///    pszFile = Type: <b>LPCTSTR</b> The address of a buffer that contains the new path.
    HRESULT SetPath(const(char)* pszFile);
}

///Exposes methods that create, modify, and resolve Shell links.
@GUID("000214F9-0000-0000-C000-000000000046")
interface IShellLinkW : IUnknown
{
    ///Gets the path and file name of the target of a Shell link object.
    ///Params:
    ///    pszFile = Type: <b>LPTSTR</b> The address of a buffer that receives the path and file name of the target of the Shell
    ///              link object.
    ///    cch = Type: <b>int</b> The size, in characters, of the buffer pointed to by the <i>pszFile</i> parameter, including
    ///          the terminating null character. The maximum path size that can be returned is MAX_PATH. This parameter is
    ///          commonly set by calling ARRAYSIZE(pszFile). The ARRAYSIZE macro is defined in Winnt.h.
    ///    pfd = Type: <b>WIN32_FIND_DATA*</b> A pointer to a WIN32_FIND_DATA structure that receives information about the
    ///          target of the Shell link object. If this parameter is <b>NULL</b>, then no additional information is
    ///          returned.
    ///    fFlags = Type: <b>DWORD</b> Flags that specify the type of path information to retrieve. This parameter can be a
    ///             combination of the following values.
    HRESULT GetPath(const(wchar)* pszFile, int cch, WIN32_FIND_DATAW* pfd, uint fFlags);
    ///Gets the list of item identifiers for the target of a Shell link object.
    ///Params:
    ///    ppidl = Type: <b>PIDLIST_ABSOLUTE*</b> When this method returns, contains the address of a PIDL.
    HRESULT GetIDList(ITEMIDLIST** ppidl);
    ///Sets the pointer to an item identifier list (PIDL) for a Shell link object.
    ///Params:
    ///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> The object's fully qualified PIDL.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetIDList(ITEMIDLIST* pidl);
    ///Gets the description string for a Shell link object.
    ///Params:
    ///    pszName = Type: <b>LPTSTR</b> A pointer to the buffer that receives the description string.
    ///    cch = Type: <b>int</b> The maximum number of characters to copy to the buffer pointed to by the <i>pszName</i>
    ///          parameter.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDescription(const(wchar)* pszName, int cch);
    ///Sets the description for a Shell link object. The description can be any application-defined string.
    ///Params:
    ///    pszName = Type: <b>LPCTSTR</b> A pointer to a buffer containing the new description string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDescription(const(wchar)* pszName);
    ///Gets the name of the working directory for a Shell link object.
    ///Params:
    ///    pszDir = Type: <b>LPTSTR</b> The address of a buffer that receives the name of the working directory.
    ///    cch = Type: <b>int</b> The maximum number of characters to copy to the buffer pointed to by the <i>pszDir</i>
    ///          parameter. The name of the working directory is truncated if it is longer than the maximum specified by this
    ///          parameter.
    HRESULT GetWorkingDirectory(const(wchar)* pszDir, int cch);
    ///Sets the name of the working directory for a Shell link object.
    ///Params:
    ///    pszDir = Type: <b>LPCTSTR</b> The address of a buffer that contains the name of the new working directory.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetWorkingDirectory(const(wchar)* pszDir);
    ///Gets the command-line arguments associated with a Shell link object.
    ///Params:
    ///    pszArgs = Type: <b>LPTSTR</b> A pointer to the buffer that, when this method returns successfully, receives the
    ///              command-line arguments.
    ///    cch = Type: <b>int</b> The maximum number of characters that can be copied to the buffer supplied by the
    ///          <i>pszArgs</i> parameter. In the case of a Unicode string, there is no limitation on maximum string length.
    ///          In the case of an ANSI string, the maximum length of the returned string varies depending on the version of
    ///          Windows—MAX_PATH prior to Windows 2000 and INFOTIPSIZE (defined in Commctrl.h) in Windows 2000 and later.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetArguments(const(wchar)* pszArgs, int cch);
    ///Sets the command-line arguments for a Shell link object.
    ///Params:
    ///    pszArgs = Type: <b>LPCTSTR</b> A pointer to a buffer that contains the new command-line arguments. In the case of a
    ///              Unicode string, there is no limitation on maximum string length. In the case of an ANSI string, the maximum
    ///              length of the returned string varies depending on the version of Windows—MAX_PATH prior to Windows 2000 and
    ///              INFOTIPSIZE (defined in Commctrl.h) in Windows 2000 and later.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetArguments(const(wchar)* pszArgs);
    ///Gets the keyboard shortcut (hot key) for a Shell link object.
    ///Params:
    ///    pwHotkey = Type: <b>WORD*</b> The address of the keyboard shortcut. The virtual key code is in the low-order byte, and
    ///               the modifier flags are in the high-order byte. The modifier flags can be a combination of the following
    ///               values.
    HRESULT GetHotkey(ushort* pwHotkey);
    ///Sets a keyboard shortcut (hot key) for a Shell link object.
    ///Params:
    ///    wHotkey = Type: <b>WORD</b> The new keyboard shortcut. The virtual key code is in the low-order byte, and the modifier
    ///              flags are in the high-order byte. The modifier flags can be a combination of the values specified in the
    ///              description of the IShellLink::GetHotkey method.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetHotkey(ushort wHotkey);
    ///Gets the show command for a Shell link object.
    ///Params:
    ///    piShowCmd = Type: <b>int*</b> A pointer to the command. The following commands are supported.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetShowCmd(int* piShowCmd);
    ///Sets the show command for a Shell link object. The show command sets the initial show state of the window.
    ///Params:
    ///    iShowCmd = Type: <b>int</b> Command. <b>SetShowCmd</b> accepts one of the following ShowWindow commands.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetShowCmd(int iShowCmd);
    ///Gets the location (path and index) of the icon for a Shell link object.
    ///Params:
    ///    pszIconPath = Type: <b>LPTSTR</b> The address of a buffer that receives the path of the file containing the icon.
    ///    cch = Type: <b>int</b> The maximum number of characters to copy to the buffer pointed to by the <i>pszIconPath</i>
    ///          parameter.
    ///    piIcon = Type: <b>int*</b> The address of a value that receives the index of the icon.
    HRESULT GetIconLocation(const(wchar)* pszIconPath, int cch, int* piIcon);
    ///Sets the location (path and index) of the icon for a Shell link object.
    ///Params:
    ///    pszIconPath = Type: <b>LPCTSTR</b> The address of a buffer to contain the path of the file containing the icon.
    ///    iIcon = Type: <b>int</b> The index of the icon.
    HRESULT SetIconLocation(const(wchar)* pszIconPath, int iIcon);
    ///Sets the relative path to the Shell link object.
    ///Params:
    ///    pszPathRel = Type: <b>LPCTSTR</b> The address of a buffer that contains the fully-qualified path of the shortcut file,
    ///                 relative to which the shortcut resolution should be performed. It should be a file name, not a folder name.
    ///    dwReserved = Type: <b>DWORD</b> Reserved. Set this parameter to zero.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRelativePath(const(wchar)* pszPathRel, uint dwReserved);
    ///Attempts to find the target of a Shell link, even if it has been moved or renamed.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> A handle to the window that the Shell will use as the parent for a dialog box. The Shell
    ///           displays the dialog box if it needs to prompt the user for more information while resolving a Shell link.
    ///    fFlags = Type: <b>DWORD</b> Action flags. This parameter can be a combination of the following values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Resolve(HWND hwnd, uint fFlags);
    ///Sets the path and file name for the target of a Shell link object.
    ///Params:
    ///    pszFile = Type: <b>LPCTSTR</b> The address of a buffer that contains the new path.
    HRESULT SetPath(const(wchar)* pszFile);
}

///Exposes methods that allow an application to attach extra data blocks to a Shell link. These methods add, copy, or
///remove data blocks.
@GUID("45E2B4AE-B1C3-11D0-B92F-00A0C90312E1")
interface IShellLinkDataList : IUnknown
{
    ///Adds a data block to a link.
    ///Params:
    ///    pDataBlock = Type: <b>VOID*</b> The data block structure. For a list of supported structures, see IShellLinkDataList.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error code otherwise.
    ///    
    HRESULT AddDataBlock(void* pDataBlock);
    ///Retrieves a copy of a link's data block.
    ///Params:
    ///    dwSig = Type: <b>DWORD</b> The data block's signature. The signature value for a particular type of data block can be
    ///            found in its structure reference. For a list of supported data block types and their associated structures,
    ///            see IShellLinkDataList.
    ///    ppDataBlock = Type: <b>VOID**</b> The address of a pointer to a copy of the data block structure. If
    ///                  <b>IShellLinkDataList::CopyDataBlock</b> returns a successful result, the calling application must free the
    ///                  memory when it is no longer needed by calling LocalFree.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or a COM error code otherwise.
    ///    
    HRESULT CopyDataBlock(uint dwSig, void** ppDataBlock);
    ///Removes a data block from a link.
    ///Params:
    ///    dwSig = Type: <b>DWORD</b> The data block's signature. The signature value for a particular type of data block can be
    ///            found in its structure reference. For a list of supported data block types and their associated structures,
    ///            see IShellLinkDataList.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error code otherwise.
    ///    
    HRESULT RemoveDataBlock(uint dwSig);
    ///Gets the current option settings.
    ///Params:
    ///    pdwFlags = Type: <b>DWORD*</b> Pointer to one or more of the SHELL_LINK_DATA_FLAGS that indicate the current option
    ///               settings.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFlags(uint* pdwFlags);
    ///Sets the current option settings.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> One or more of the SHELL_LINK_DATA_FLAGS that indicate the option settings.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetFlags(uint dwFlags);
}

///Exposes a method that enables an application to request that a Shell folder object resolve a link for one of its
///items.
@GUID("5CD52983-9449-11D2-963A-00C04F79ADF0")
interface IResolveShellLink : IUnknown
{
    ///Requests that a folder object resolve a Shell link.
    ///Params:
    ///    punkLink = Type: <b>IUnknown*</b> Pointer to the object's IShellLink interface. This interface can then be queried to
    ///               determine the contents of the link.
    ///    hwnd = Type: <b>HWND</b> Handle to the window that the Shell uses as the parent for a dialog box. The Shell displays
    ///           the dialog box if it needs to prompt the user for more information while resolving the link.
    ///    fFlags = Type: <b>DWORD</b> Action flags. This parameter can be a combination of the following values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ResolveShellLink(IUnknown punkLink, HWND hwnd, uint fFlags);
}

///Exposes methods that initialize and stop a progress dialog.
@GUID("49FF1172-EADC-446D-9285-156453A6431C")
interface IActionProgressDialog : IUnknown
{
    ///Provides details about the action progress dialog.
    ///Params:
    ///    flags = Type: <b>SPINITF</b> One of the following values.
    ///    pszTitle = Type: <b>LPCWSTR</b> The title of the progress dialog.
    ///    pszCancel = Type: <b>LPCWSTR</b> The string displayed when a user closes the dialog before completion.
    HRESULT Initialize(uint flags, const(wchar)* pszTitle, const(wchar)* pszCancel);
    ///Stops a progress dialog.
    HRESULT Stop();
}

///Represents the abstract base class from which progress-driven operations can inherit.
@GUID("49FF1173-EADC-446D-9285-156453A6431C")
interface IActionProgress : IUnknown
{
    ///Called when an action has begun that requires its progress be displayed to the user.
    ///Params:
    ///    action = Type: <b>SPACTION</b> The action being performed. See SPACTION for a list of acceptable values.
    ///    flags = Type: <b>SPBEGINF</b> Optional flags that request certain UI operations be enabled or disabled. See SPBEGINF
    ///            for a list of acceptable values.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if successful, or an error value otherwise.
    ///    
    HRESULT Begin(SPACTION action, uint flags);
    ///Updates the progress of an action to the UI.
    ///Params:
    ///    ulCompleted = Type: <b>ULONGLONG</b> The amount of the action completed.
    ///    ulTotal = Type: <b>ULONGLONG</b> The total amount of the action.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if successful, or an error value otherwise.
    ///    
    HRESULT UpdateProgress(ulong ulCompleted, ulong ulTotal);
    ///Called if descriptive text associated with the action will be changed.
    ///Params:
    ///    sptext = Type: <b>SPTEXT</b> A value that specifies the type of text displayed. See SPTEXT for acceptable values.
    ///    pszText = Type: <b>LPCWSTR</b> A pointer to a wide character string to display.
    ///    fMayCompact = Type: <b>BOOL</b> A value that specifies whether to allow a text string to be compacted to fit the available
    ///                  space on screen.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if successful, or an error value otherwise.
    ///    
    HRESULT UpdateText(SPTEXT sptext, const(wchar)* pszText, BOOL fMayCompact);
    ///Provides information about whether the action is being canceled.
    ///Params:
    ///    pfCancelled = Type: <b>BOOL*</b> A reference to a <b>BOOL</b> value that specifies whether the action is being canceled.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if successful, or an error value otherwise.
    ///    
    HRESULT QueryCancel(int* pfCancelled);
    ///Resets progress dialog after a cancellation has been completed.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if successful, or an error value otherwise.
    ///    
    HRESULT ResetCancel();
    ///Indicates that the action associated with this progress implementation has ended.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if successful, or an error value otherwise.
    ///    
    HRESULT End();
}

///Exposes a method that initializes Shell extensions for property sheets, shortcut menus, and drag-and-drop handlers
///(extensions that add items to shortcut menus during nondefault drag-and-drop operations).
@GUID("000214E8-0000-0000-C000-000000000046")
interface IShellExtInit : IUnknown
{
    ///Initializes a property sheet extension, shortcut menu extension, or drag-and-drop handler.
    ///Params:
    ///    pidlFolder = Type: <b>PCIDLIST_ABSOLUTE</b> A pointer to an ITEMIDLIST structure that uniquely identifies a folder. For
    ///                 property sheet extensions, this parameter is <b>NULL</b>. For shortcut menu extensions, it is the item
    ///                 identifier list for the folder that contains the item whose shortcut menu is being displayed. For nondefault
    ///                 drag-and-drop menu extensions, this parameter specifies the target folder.
    ///    pdtobj = Type: <b>IDataObject*</b> A pointer to an IDataObject interface object that can be used to retrieve the
    ///             objects being acted upon.
    ///    hkeyProgID = Type: <b>HKEY</b> The registry key for the file object or folder type.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(ITEMIDLIST* pidlFolder, IDataObject pdtobj, HKEY hkeyProgID);
}

///Exposes methods that allow a property sheet handler to add or replace pages in the property sheet displayed for a
///file object.
@GUID("000214E9-0000-0000-C000-000000000046")
interface IShellPropSheetExt : IUnknown
{
    ///Adds one or more pages to a property sheet that the Shell displays for a file object. The Shell calls this method
    ///for each property sheet handler registered to the file type.
    ///Params:
    ///    pfnAddPage = Type: <b>LPFNADDPROPSHEETPAGE</b> A pointer to a function that the property sheet handler calls to add a page
    ///                 to the property sheet. The function takes a property sheet handle returned by the CreatePropertySheetPage
    ///                 function and the <i>lParam</i> parameter passed to this method.
    ///    lParam = Type: <b>LPARAM</b> Handler-specific data to pass to the function pointed to by <i>pfnAddPage</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If successful, returns a one-based index to specify the page that should be initially
    ///    displayed. See Remarks for more information.
    ///    
    HRESULT AddPages(LPFNSVADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
    ///Replaces a page in a property sheet for a Control Panel object.
    ///Params:
    ///    uPageID = Type: <b>UINT</b> Not used. <b>Microsoft Windows XP and earlier:</b> A type EXPPS identifier of the page to
    ///              replace. The values for this parameter for Control Panels can be found in the Cplext.h header file.
    ///    pfnReplaceWith = Type: <b>LPFNADDPROPSHEETPAGE</b> A pointer to a function that the property sheet handler calls to replace a
    ///                     page to the property sheet. The function takes a property sheet handle returned by the
    ///                     CreatePropertySheetPage function and the <i>lParam</i> parameter passed to the <b>ReplacePage</b> method.
    ///    lParam = Type: <b>LPARAM</b> The parameter to pass to the function specified by the <i>pfnReplacePage</i> parameter.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ReplacePage(uint uPageID, LPFNSVADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);
}

///Exposes a method that enumerates or initializes a namespace extension when it is invoked on a remote object. This
///interface is used, for example, to initialize the remote printers virtual folder.
@GUID("000214FE-0000-0000-C000-000000000046")
interface IRemoteComputer : IUnknown
{
    ///Used by Windows Explorer or Windows Internet Explorer when it is initializing or enumerating a namespace
    ///extension invoked on a remote computer.
    ///Params:
    ///    pszMachine = Type: <b>LPCWSTR</b> A pointer to a buffer containing the machine name of the remote computer.
    ///    bEnumerating = Type: <b>BOOL</b> A value that is set to <b>TRUE</b> if Windows Explorer is enumerating the namespace
    ///                   extension, or <b>FALSE</b> if it is initializing it.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or standard OLE error values otherwise.
    ///    
    HRESULT Initialize(const(wchar)* pszMachine, BOOL bEnumerating);
}

///Exposes a method that provides a simple, standard mechanism for objects to query a client for permission to continue
///an operation. Clients of IUserNotification, for example, must pass an implementation of <b>IQueryContinue</b> to the
///IUserNotification::Show method.
@GUID("7307055C-B24A-486B-9F25-163E597A28A9")
interface IQueryContinue : IUnknown
{
    ///Returns <b>S_OK</b> if the operation associated with the current instance of this interface should continue.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if the calling application should continue, <b>S_FALSE</b> if not.
    ///    
    HRESULT QueryContinue();
}

///Not supported. Supplies a caller with an event that will be signaled by the called object to denote cancellation of a
///task.
@GUID("F279B885-0AE9-4B85-AC06-DDECF9408941")
interface IObjectWithCancelEvent : IUnknown
{
    ///Retrieves an event that will be sent when an operation is canceled.
    ///Params:
    ///    phEvent = Type: <b>HANDLE*</b> Pointer to a handle that, when this method successfully returns, is the handle to the
    ///              cancel event. The caller is responsible for closing this handle when it is no longer needed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCancelEvent(HANDLE* phEvent);
}

///Exposes methods that set notification information and then display that notification to the user in a balloon that
///appears in conjunction with the notification area of the taskbar. <div class="alert"><b>Note</b> IUserNotification2
///differs from <b>IUserNotification</b> only in its Show method, which adds an additional parameter for a callback
///interface to communicate with the notification. Otherwise the two interfaces are identical in form and function.
///CLSID_UserNotification implements both versions of <b>Show</b> as an overload.</div><div> </div>
@GUID("BA9711BA-5893-4787-A7E1-41277151550B")
interface IUserNotification : IUnknown
{
    ///Sets the information to be displayed in a balloon notification.
    ///Params:
    ///    pszTitle = Type: <b>LPCWSTR</b> A pointer to a Unicode string that specifies the title of the notification.
    ///    pszText = Type: <b>LPCWSTR</b> A pointer to a Unicode string that specifies the text to be displayed in the body of the
    ///              balloon.
    ///    dwInfoFlags = Type: <b>DWORD</b> One or more of the following values that indicate an icon to display in the notification
    ///                  balloon.
    HRESULT SetBalloonInfo(const(wchar)* pszTitle, const(wchar)* pszText, uint dwInfoFlags);
    ///Specifies the conditions for trying to display user information when the first attempt fails.
    ///Params:
    ///    dwShowTime = Type: <b>DWORD</b> The amount of time, in milliseconds, to display the user information.
    ///    dwInterval = Type: <b>DWORD</b> The interval of time, in milliseconds, between attempts to display the user information.
    ///    cRetryCount = Type: <b>UINT</b> The number of times the system should try to display the user information.
    HRESULT SetBalloonRetry(uint dwShowTime, uint dwInterval, uint cRetryCount);
    ///Sets the notification area icon associated with specific user information.
    ///Params:
    ///    hIcon = Type: <b>HICON</b> A handle to the icon.
    ///    pszToolTip = Type: <b>LPCWSTR</b> A pointer to a string that contains the tooltip text to display for the specified icon.
    ///                 This value can be <b>NULL</b>, although it is not recommended.
    HRESULT SetIconInfo(HICON hIcon, const(wchar)* pszToolTip);
    ///Displays the notification.
    ///Params:
    ///    pqc = Type: <b>IQueryContinue*</b> An IQueryContinue interface pointer, used to determine whether the notification
    ///          display can continue or should stop (for example, if the user closes the notification). This value can be
    ///          <b>NULL</b>.
    ///    dwContinuePollInterval = Type: <b>DWORD</b> The length of time, in milliseconds, to display user information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Show(IQueryContinue pqc, uint dwContinuePollInterval);
    HRESULT PlaySoundA(const(wchar)* pszSoundName);
}

///Retrieves a list of valid and invalid characters or the maximum length of a name in the namespace. Use this interface
///for validation parsing and translation.
@GUID("1DF0D7F1-B267-4D28-8B10-12E23202A5C4")
interface IItemNameLimits : IUnknown
{
    ///Loads a string that contains each of the characters that are valid or invalid in the namespace under which it is
    ///called.
    ///Params:
    ///    ppwszValidChars = Type: <b>LPWSTR*</b> A pointer to a string that contains all valid characters in the namespace. If the
    ///                      namespace provides <i>any</i> invalid characters in <i>ppwszInvalidChars</i>, then this value returns
    ///                      <b>NULL</b>. See Remarks for more details.
    ///    ppwszInvalidChars = Type: <b>LPWSTR*</b> A pointer to a string that contains all invalid characters in the namespace.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetValidCharacters(ushort** ppwszValidChars, ushort** ppwszInvalidChars);
    ///Returns the maximum number of characters allowed for a particular name in the namespace under which it is called.
    ///Params:
    ///    pszName = Type: <b>LPCWSTR</b> A pointer to a string containing a name.
    ///    piMaxNameLen = Type: <b>int*</b> A pointer to the maximum number of characters which can be used in the name.
    HRESULT GetMaxLength(const(wchar)* pszName, int* piMaxNameLen);
}

///Exposes methods that create and modify search folders. The Set methods are called first to set up the parameters of
///the search. When not called, default values will be used instead. ISearchFolderItemFactory::GetIDList and
///ISearchFolderItemFactory::GetShellItem return the two forms of the search specified by these parameters.
@GUID("A0FFBC28-5482-4366-BE27-3E81E78E06C2")
interface ISearchFolderItemFactory : IUnknown
{
    ///Sets the search folder display name, as specified.
    ///Params:
    ///    pszDisplayName = Type: <b>LPCWSTR</b> A pointer to a folder display name as a Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns a success value if successful, or an error value otherwise.
    ///    
    HRESULT SetDisplayName(const(wchar)* pszDisplayName);
    ///Sets a search folder type ID, as specified.
    ///Params:
    ///    ftid = Type: <b>FOLDERTYPEID</b> The FOLDERTYPEID, which is a <b>GUID</b> used to identify folder types within the
    ///           system. The default is <b>FOLDERTYPID_Library</b>
    HRESULT SetFolderTypeID(GUID ftid);
    ///Sets folder logical view mode. The default settings are based on the <code>FolderTypeID</code> which is set by
    ///the ISearchFolderItemFactory::SetFolderTypeID method.
    ///Params:
    ///    flvm = Type: <b>FOLDERLOGICALVIEWMODE</b> The FOLDERLOGICALVIEWMODE value.
    HRESULT SetFolderLogicalViewMode(FOLDERLOGICALVIEWMODE flvm);
    ///Sets the search folder icon size, as specified. The default settings are based on the <code>FolderTypeID</code>
    ///which is set by the ISearchFolderItemFactory::SetFolderTypeID method.
    ///Params:
    ///    iIconSize = Type: <b>int</b> The icon size.
    HRESULT SetIconSize(int iIconSize);
    ///Creates a new column list whose columns are all visible, given an array of PROPERTYKEY structures. The default is
    ///based on <b>FolderTypeID</b>.
    ///Params:
    ///    cVisibleColumns = Type: <b>UINT</b> The number of array elements.
    ///    rgKey = Type: <b>const PROPERTYKEY*</b> A pointer to an array of PROPERTYKEY structures.
    HRESULT SetVisibleColumns(uint cVisibleColumns, char* rgKey);
    ///Creates a list of sort column directions, as specified.
    ///Params:
    ///    cSortColumns = Type: <b>UINT</b> The number of sort columns.
    ///    rgSortColumns = Type: <b>SORTCOLUMN*</b> A pointer to an array of SORTCOLUMN structures containing sort direction. The
    ///                    default is <b>PKEY_ItemNameDisplay</b>.
    HRESULT SetSortColumns(uint cSortColumns, char* rgSortColumns);
    ///Sets a group column, as specified. If no group column is specified, no grouping occurs.
    ///Params:
    ///    keyGroup = Type: <b>REFPROPERTYKEY</b> A reference to a group column PROPERTYKEY.
    HRESULT SetGroupColumn(const(PROPERTYKEY)* keyGroup);
    ///Creates a list of stack keys, as specified. If this method is not called, by default the folder will not be
    ///stacked.
    ///Params:
    ///    cStackKeys = Type: <b>UINT</b> The number of stacks keys.
    ///    rgStackKeys = Type: <b>PROPERTYKEY*</b> A pointer to an array of PROPERTYKEY structures containing stack key information.
    HRESULT SetStacks(uint cStackKeys, char* rgStackKeys);
    ///Sets search scope, as specified.
    ///Params:
    ///    psiaScope = Type: <b>IShellItemArray*</b> A pointer to the list of locations to search. The search will include this
    ///                location and all its subcontainers. The default is <b>FOLDERID_Profile</b>
    HRESULT SetScope(IShellItemArray psiaScope);
    ///Sets the ICondition of the search. When this method is not called, the resulting search will have no filters
    ///applied.
    ///Params:
    ///    pCondition = Type: <b>ICondition*</b> A pointer to an ICondition interface.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or an error value otherwise.
    ///    
    HRESULT SetCondition(ICondition pCondition);
    ///Gets the search folder as a IShellItem.
    ///Params:
    ///    riid = Type: <b>REFIID</b> A reference to the desired IID.
    ///    ppv = Type: <b>void**</b> The IShellItem interface pointer specified in <i>riid</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns a success value if successful, or an error value otherwise.
    ///    
    HRESULT GetShellItem(const(GUID)* riid, void** ppv);
    ///Gets the search folder as an ITEMIDLIST.
    ///Params:
    ///    ppidl = Type: <b>PIDLIST_ABSOLUTE*</b> When this method returns successfully, contains a PIDL.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns a success value if successful, or an error value otherwise.
    ///    
    HRESULT GetIDList(ITEMIDLIST** ppidl);
}

///Exposes methods that request a thumbnail image from a Shell folder.
@GUID("BB2E617C-0920-11D1-9A0B-00C04FC2D6C1")
interface IExtractImage : IUnknown
{
    ///Gets a path to the image that is to be extracted.
    ///Params:
    ///    pszPathBuffer = Type: <b>LPWSTR</b> The buffer used to return the path description. This value identifies the image so you
    ///                    can avoid loading the same one more than once.
    ///    cch = Type: <b>DWORD</b> The size of <i>pszPathBuffer</i> in characters.
    ///    pdwPriority = Type: <b>DWORD*</b> Not used. <b>Microsoft Windows XP and earlier:</b> The pointer used to return the
    ///                  priority of the item when the <b>IEIFLAG_ASYNC</b> flag is set in <i>pdwFlags</i>. This parameter must not be
    ///                  <b>NULL</b>. The function fails if this parameter is <b>NULL</b>, whether <b>IEIFLAG_ASYNC</b> flag is set or
    ///                  not. This parameter is typically used to indicate the amount of time needed to extract the image. If you want
    ///                  more control over the order in which thumbnails are extracted, you can define multiple priority levels, up to
    ///                  32 bits. As long as the integer values assigned to the different priority levels increase from low to high
    ///                  priority, the actual numbers you use aren't important. They are only used to determine the order in which the
    ///                  images will be extracted. There are three standard priority levels:
    ///    prgSize = Type: <b>const SIZE*</b> A pointer to a SIZE structure with the desired width and height of the image. Must
    ///              not be <b>NULL</b>.
    ///    dwRecClrDepth = Type: <b>DWORD</b> The recommended color depth in units of bits per pixel. Must not be <b>NULL</b>.
    ///    pdwFlags = Type: <b>DWORD*</b> Flags that specify how the image is to be handled. Value must be one or more of the
    ///               following:
    ///Returns:
    ///    Type: <b>HRESULT</b> This method may return a COM-defined error code or one of the following: <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PENDING</b></dt> </dl> </td> <td
    ///    width="60%"> <b>Windows XP and earlier:</b> If the <b>IEIFLAG_ASYNC</b> flag is set, this return value is
    ///    used to indicate to the Shell that the object is free-threaded. </td> </tr> </table>
    ///    
    HRESULT GetLocation(const(wchar)* pszPathBuffer, uint cch, uint* pdwPriority, const(SIZE)* prgSize, 
                        uint dwRecClrDepth, uint* pdwFlags);
    ///Requests an image from an object, such as an item in a Shell folder.
    ///Params:
    ///    phBmpThumbnail = Type: <b>HBITMAP*</b> The buffer to hold the bitmapped image.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error code otherwise.
    ///    
    HRESULT Extract(HBITMAP* phBmpThumbnail);
}

///Extends the capabilities of IExtractImage.
@GUID("953BB1EE-93B4-11D1-98A3-00C04FB687DA")
interface IExtractImage2 : IExtractImage
{
    ///Requests the date the image was last modified. This method allows the Shell to determine whether cached images
    ///are out-of-date.
    ///Params:
    ///    pDateStamp = Type: <b>FILETIME*</b> A pointer to a FILETIME structure used to return the last time the image was modified.
    HRESULT GetDateStamp(FILETIME* pDateStamp);
}

///Exposes a method for retrieving the thumbnail handler of an item. Implement this interface if you want to specify
///what extractor is used for a child IDList.
@GUID("E35B4B2E-00DA-4BC1-9F13-38BC11F5D417")
interface IThumbnailHandlerFactory : IUnknown
{
    ///Gets the requested thumbnail handler for the thumbnail of a given item.
    ///Params:
    ///    pidlChild = Type: <b>PCUITEMID_CHILD</b> The item within the namespace for which the thumbnail handler is being
    ///                retrieved.
    ///    pbc = Type: <b>IBindCtx*</b> A pointer to an IBindCtx to be used during the moniker binding operation of this
    ///          process.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the interface requested. This is usually IThumbnailProvider or
    ///           IExtractImage.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the address of a pointer to the requested thumbnail
    ///          handler. If this method fails, this value is <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetThumbnailHandler(ITEMIDLIST* pidlChild, IBindCtx pbc, const(GUID)* riid, void** ppv);
}

///Exposes methods that get and set the parent and the parent's child ID. While <b>IParentAndItem</b> is typically
///implemented on IShellItems, it is not specific to IShellItem.
@GUID("B3A4B685-B685-4805-99D9-5DEAD2873236")
interface IParentAndItem : IUnknown
{
    ///Sets the parent of an item and the parent's child ID.
    ///Params:
    ///    pidlParent = Type: <b>PCIDLIST_ABSOLUTE</b> A pointer of the parent.
    ///    psf = Type: <b>IShellFolder*</b> A pointer to the IShellFolder that is the parent.
    ///    pidlChild = Type: <b>PCUITEMID_CHILD</b> A PIDL that is a child relative to <i>psf</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetParentAndItem(ITEMIDLIST* pidlParent, IShellFolder psf, ITEMIDLIST* pidlChild);
    ///Gets the parent of an item and the parent's child ID.
    ///Params:
    ///    ppidlParent = Type: <b>PIDLIST_ABSOLUTE*</b> When this method returns, contains the address of a PIDL that specifies the
    ///                  parent.
    ///    ppsf = Type: <b>IShellFolder**</b> When this method returns, contains the address of a pointer to the IShellFolder
    ///           that is the parent.
    ///    ppidlChild = Type: <b>PITEMID_CHILD*</b> When this method returns, contains the address of a child PIDL that identifies
    ///                 the IParentAndItem object relative to that specified by <i>ppsf</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetParentAndItem(ITEMIDLIST** ppidlParent, IShellFolder* ppsf, ITEMIDLIST** ppidlChild);
}

///Exposes methods that notify the docking window object of changes, including showing, hiding, and impending removal.
///This interface is implemented by window objects that can be docked within the border space of a Windows Explorer
///window.
@GUID("012DD920-7B26-11D0-8CA9-00A0C92DBFE8")
interface IDockingWindow : IOleWindow
{
    ///Instructs the docking window object to show or hide itself.
    ///Params:
    ///    fShow = Type: <b>BOOL</b> <b>TRUE</b> if the docking window object should show its window. <b>FALSE</b> if the
    ///            docking window object should hide its window and return its border space by calling SetBorderSpaceDW with
    ///            zero values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ShowDW(BOOL fShow);
    ///Notifies the docking window object that it is about to be removed from the frame. The docking window object
    ///should save any persistent information at this time.
    ///Params:
    ///    dwReserved = Type: <b>DWORD</b> Reserved. This parameter should always be zero.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CloseDW(uint dwReserved);
    ///Notifies the docking window object that the frame's border space has changed. In response to this method, the
    ///IDockingWindow implementation must call SetBorderSpaceDW, even if no border space is required or a change is not
    ///necessary.
    ///Params:
    ///    prcBorder = Type: <b>LPCRECT</b> Pointer to a RECT structure that contains the frame's available border space.
    ///    punkToolbarSite = Type: <b>IUnknown*</b> Pointer to the site's IUnknown interface. The docking window object should call the
    ///                      QueryInterface method for this interface, requesting IID_IDockingWindowSite. The docking window object then
    ///                      uses that interface to negotiate its border space. It is the docking window object's responsibility to
    ///                      release this interface when it is no longer needed.
    ///    fReserved = Type: <b>BOOL</b> Reserved. This parameter should always be zero.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ResizeBorderDW(RECT* prcBorder, IUnknown punkToolbarSite, BOOL fReserved);
}

///Used to obtain information about a band object. <div class="alert"><b>Important</b> You should use thumbnail toolbars
///in new development in place of desk bands, which are not supported as of Windows 7.</div><div> </div>
@GUID("EB0FE172-1A3A-11D0-89B3-00A0C90A90AC")
interface IDeskBand : IDockingWindow
{
    ///Gets state information for a band object. <div class="alert"><b>Important</b> You should use thumbnail toolbars
    ///in new development in place of desk bands, which are not supported as of Windows 7.</div><div> </div>
    ///Params:
    ///    dwBandID = Type: <b>DWORD</b> The identifier of the band, assigned by the container. The band object can retain this
    ///               value if it is required.
    ///    dwViewMode = Type: <b>DWORD</b> The view mode of the band object. One of the following values:
    ///    pdbi = Type: <b>DESKBANDINFO*</b> Pointer to a DESKBANDINFO structure that receives the band information for the
    ///           object. The <b>dwMask</b> member of this structure indicates the specific information that is being
    ///           requested.
    HRESULT GetBandInfo(uint dwBandID, uint dwViewMode, DESKBANDINFO* pdbi);
}

///<p class="CCE_Message">[<b>IDeskBandInfo</b> may be altered or unavailable in subsequent versions of the operating
///system or product.] Exposes a method for getting the default Desk Band bandwidth.
@GUID("77E425FC-CBF9-4307-BA6A-BB5727745661")
interface IDeskBandInfo : IUnknown
{
    ///<p class="CCE_Message">[<b>GetDefaultBandWidth</b> may be altered or unavailable in subsequent versions of the
    ///operating system or product.] Gets the band width that the bandsite initially uses to set the default width when
    ///the band is added.
    ///Params:
    ///    dwBandID = Type: <b>DWORD</b> The band ID.
    ///    dwViewMode = Type: <b>DWORD</b> The view mode of the band object. One of the following values:
    ///    pnWidth = Type: <b>int*</b> A pointer to the band width.
    HRESULT GetDefaultBandWidth(uint dwBandID, uint dwViewMode, int* pnWidth);
}

///Exposes methods that control the taskbar. It allows you to dynamically add, remove, and activate items on the
///taskbar.
@GUID("56FDF342-FD6D-11D0-958A-006097C9A090")
interface ITaskbarList : IUnknown
{
    ///Initializes the taskbar list object. This method must be called before any other ITaskbarList methods can be
    ///called.
    HRESULT HrInit();
    ///Adds an item to the taskbar.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> A handle to the window to be added to the taskbar.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddTab(HWND hwnd);
    ///Deletes an item from the taskbar.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> A handle to the window to be deleted from the taskbar.
    HRESULT DeleteTab(HWND hwnd);
    ///Activates an item on the taskbar. The window is not actually activated; the window's item on the taskbar is
    ///merely displayed as active.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> A handle to the window on the taskbar to be displayed as active.
    HRESULT ActivateTab(HWND hwnd);
    ///Marks a taskbar item as active but does not visually activate it.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> A handle to the window to be marked as active.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetActiveAlt(HWND hwnd);
}

///Extends the ITaskbarList interface by exposing a method to mark a window as a full-screen display.
@GUID("602D4995-B13A-429B-A66E-1935E44F4317")
interface ITaskbarList2 : ITaskbarList
{
    ///Marks a window as full-screen.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the window to be marked.
    ///    fFullscreen = Type: <b>BOOL</b> A Boolean value marking the desired full-screen status of the window.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT MarkFullscreenWindow(HWND hwnd, BOOL fFullscreen);
}

///Extends ITaskbarList2 by exposing methods that support the unified launching and switching taskbar button
///functionality added in Windows 7. This functionality includes thumbnail representations and switch targets based on
///individual tabs in a tabbed application, thumbnail toolbars, notification and status overlays, and progress
///indicators.
@GUID("EA1AFB91-9E28-4B86-90E9-9E9F8A5EEFAF")
interface ITaskbarList3 : ITaskbarList2
{
    ///Displays or updates a progress bar hosted in a taskbar button to show the specific percentage completed of the
    ///full operation.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the window whose associated taskbar button is being used as a progress
    ///           indicator.
    ///    ullCompleted = Type: <b>ULONGLONG</b> An application-defined value that indicates the proportion of the operation that has
    ///                   been completed at the time the method is called.
    ///    ullTotal = Type: <b>ULONGLONG</b> An application-defined value that specifies the value <i>ullCompleted</i> will have
    ///               when the operation is complete.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetProgressValue(HWND hwnd, ulong ullCompleted, ulong ullTotal);
    ///Sets the type and state of the progress indicator displayed on a taskbar button.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the window in which the progress of an operation is being shown. This
    ///           window's associated taskbar button will display the progress bar.
    ///    tbpFlags = Type: <b>TBPFLAG</b> Flags that control the current state of the progress button. Specify only one of the
    ///               following flags; all states are mutually exclusive of all others.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetProgressState(HWND hwnd, TBPFLAG tbpFlags);
    ///Informs the taskbar that a new tab or document thumbnail has been provided for display in an application's
    ///taskbar group flyout.
    ///Params:
    ///    hwndTab = Type: <b>HWND</b> Handle of the tab or document window. This value is required and cannot be <b>NULL</b>.
    ///    hwndMDI = Type: <b>HWND</b> Handle of the application's main window. This value tells the taskbar which application's
    ///              preview group to attach the new thumbnail to. This value is required and cannot be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. If either parameter is
    ///    <b>NULL</b>, this method returns an error.
    ///    
    HRESULT RegisterTab(HWND hwndTab, HWND hwndMDI);
    ///Removes a thumbnail from an application's preview group when that tab or document is closed in the application.
    ///Params:
    ///    hwndTab = Type: <b>HWND</b> The handle of the tab window whose thumbnail is being removed. This is the same value with
    ///              which the thumbnail was registered as part the group through ITaskbarList3::RegisterTab. This value is
    ///              required and cannot be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or an error value otherwise. If <i>hwndTab</i> is
    ///    <b>NULL</b>, this method returns an error.
    ///    
    HRESULT UnregisterTab(HWND hwndTab);
    ///Inserts a new thumbnail into a tabbed-document interface (TDI) or multiple-document interface (MDI) application's
    ///group flyout or moves an existing thumbnail to a new position in the application's group.
    ///Params:
    ///    hwndTab = Type: <b>HWND</b> The handle of the tab window whose thumbnail is being placed. This value is required, must
    ///              already be registered through ITaskbarList3::RegisterTab, and cannot be <b>NULL</b>.
    ///    hwndInsertBefore = Type: <b>HWND</b> The handle of the tab window whose thumbnail that <i>hwndTab</i> is inserted to the left
    ///                       of. This handle must already be registered through ITaskbarList3::RegisterTab. If this value is <b>NULL</b>,
    ///                       the new thumbnail is added to the end of the list.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetTabOrder(HWND hwndTab, HWND hwndInsertBefore);
    ///Informs the taskbar that a tab or document window has been made the active window.
    ///Params:
    ///    hwndTab = Type: <b>HWND</b> Handle of the active tab window. This handle must already be registered through
    ///              ITaskbarList3::RegisterTab. This value can be <b>NULL</b> if no tab is active.
    ///    hwndMDI = Type: <b>HWND</b> Handle of the application's main window. This value tells the taskbar which group the
    ///              thumbnail is a member of. This value is required and cannot be <b>NULL</b>.
    ///    dwReserved = Type: <b>DWORD</b> Reserved; set to 0.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetTabActive(HWND hwndTab, HWND hwndMDI, uint dwReserved);
    ///Adds a thumbnail toolbar with a specified set of buttons to the thumbnail image of a window in a taskbar button
    ///flyout.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the window whose thumbnail representation will receive the toolbar. This
    ///           handle must belong to the calling process.
    ///    cButtons = Type: <b>UINT</b> The number of buttons defined in the array pointed to by <i>pButton</i>. The maximum number
    ///               of buttons allowed is 7.
    ///    pButton = Type: <b>LPTHUMBBUTTON</b> A pointer to an array of THUMBBUTTON structures. Each <b>THUMBBUTTON</b> defines
    ///              an individual button to be added to the toolbar. Buttons cannot be added or deleted later, so this must be
    ///              the full defined set. Buttons also cannot be reordered, so their order in the array, which is the order in
    ///              which they are displayed left to right, will be their permanent order.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>hwnd</i> parameter does not specify a handle
    ///    that belongs to the process or does not specify a window that is associated with a taskbar button. This value
    ///    is also returned if <i>pButton</i> is less than 1 or greater than 7. </td> </tr> </table>
    ///    
    HRESULT ThumbBarAddButtons(HWND hwnd, uint cButtons, char* pButton);
    ///Shows, enables, disables, or hides buttons in a thumbnail toolbar as required by the window's current state. A
    ///thumbnail toolbar is a toolbar embedded in a thumbnail image of a window in a taskbar button flyout.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the window whose thumbnail representation contains the toolbar.
    ///    cButtons = Type: <b>UINT</b> The number of buttons defined in the array pointed to by <i>pButton</i>. The maximum number
    ///               of buttons allowed is 7. This array contains only structures that represent existing buttons that are being
    ///               updated.
    ///    pButton = Type: <b>LPTHUMBBUTTON</b> A pointer to an array of THUMBBUTTON structures. Each <b>THUMBBUTTON</b> defines
    ///              an individual button. If the button already exists (the <b>iId</b> value is already defined), then that
    ///              existing button is updated with the information provided in the structure.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ThumbBarUpdateButtons(HWND hwnd, uint cButtons, char* pButton);
    ///Specifies an image list that contains button images for a toolbar embedded in a thumbnail image of a window in a
    ///taskbar button flyout.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the window whose thumbnail representation contains the toolbar to be updated.
    ///           This handle must belong to the calling process.
    ///    himl = Type: <b>HIMAGELIST</b> The handle of the image list that contains all button images to be used in the
    ///           toolbar.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ThumbBarSetImageList(HWND hwnd, HIMAGELIST himl);
    ///Applies an overlay to a taskbar button to indicate application status or a notification to the user.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the window whose associated taskbar button receives the overlay. This handle
    ///           must belong to a calling process associated with the button's application and must be a valid <b>HWND</b> or
    ///           the call is ignored.
    ///    hIcon = Type: <b>HICON</b> The handle of an icon to use as the overlay. This should be a small icon, measuring 16x16
    ///            pixels at 96 dpi. If an overlay icon is already applied to the taskbar button, that existing overlay is
    ///            replaced. This value can be <b>NULL</b>. How a <b>NULL</b> value is handled depends on whether the taskbar
    ///            button represents a single window or a group of windows. <ul> <li>If the taskbar button represents a single
    ///            window, the overlay icon is removed from the display.</li> <li>If the taskbar button represents a group of
    ///            windows and a previous overlay is still available (received earlier than the current overlay, but not yet
    ///            freed by a <b>NULL</b> value), then that previous overlay is displayed in place of the current overlay.</li>
    ///            </ul> It is the responsibility of the calling application to free <i>hIcon</i> when it is no longer needed.
    ///            This can generally be done after you call <b>SetOverlayIcon</b> because the taskbar makes and uses its own
    ///            copy of the icon.
    ///    pszDescription = Type: <b>LPCWSTR</b> A pointer to a string that provides an alt text version of the information conveyed by
    ///                     the overlay, for accessibility purposes.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOverlayIcon(HWND hwnd, HICON hIcon, const(wchar)* pszDescription);
    ///Specifies or updates the text of the tooltip that is displayed when the mouse pointer rests on an individual
    ///preview thumbnail in a taskbar button flyout.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle to the window whose thumbnail displays the tooltip. This handle must belong to
    ///           the calling process.
    ///    pszTip = Type: <b>LPCWSTR</b> The pointer to the text to be displayed in the tooltip. This value can be <b>NULL</b>,
    ///             in which case the title of the window specified by <i>hwnd</i> is used as the tooltip.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetThumbnailTooltip(HWND hwnd, const(wchar)* pszTip);
    ///Selects a portion of a window's client area to display as that window's thumbnail in the taskbar.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle to a window represented in the taskbar.
    ///    prcClip = Type: <b>RECT*</b> A pointer to a RECT structure that specifies a selection within the window's client area,
    ///              relative to the upper-left corner of that client area. To clear a clip that is already in place and return to
    ///              the default display of the thumbnail, set this parameter to <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetThumbnailClip(HWND hwnd, RECT* prcClip);
}

///Extends ITaskbarList3 by providing a method that allows the caller to control two property values for the tab
///thumbnail and peek feature.
@GUID("C43DC798-95D1-4BEA-9030-BB99E2983A1A")
interface ITaskbarList4 : ITaskbarList3
{
    ///Allows a tab to specify whether the main application frame window or the tab window should be used as a thumbnail
    ///or in the peek feature under certain circumstances.
    ///Params:
    ///    hwndTab = Type: <b>HWND</b> The handle of the tab window that is to have properties set. This handle must already be
    ///              registered through RegisterTab.
    ///    stpFlags = Type: <b>STPFLAG</b> One or more members of the STPFLAG enumeration that specify the displayed thumbnail and
    ///               peek image source of the tab thumbnail.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetTabProperties(HWND hwndTab, STPFLAG stpFlags);
}

///Exposes methods for notification of Explorer browser navigation and view creation events.
@GUID("361BBDC7-E6EE-4E13-BE58-58E2240C810F")
interface IExplorerBrowserEvents : IUnknown
{
    ///Notifies clients of a pending Explorer browser navigation to a Shell folder.
    ///Params:
    ///    pidlFolder = Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL that specifies the folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnNavigationPending(ITEMIDLIST* pidlFolder);
    ///Notifies clients that the view of the Explorer browser has been created and can be modified.
    ///Params:
    ///    psv = Type: <b>IShellView*</b> A pointer to an IShellView.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnViewCreated(IShellView psv);
    ///Notifies clients that the Explorer browser has successfully navigated to a Shell folder.
    ///Params:
    ///    pidlFolder = Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL that specifies the folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnNavigationComplete(ITEMIDLIST* pidlFolder);
    ///Notifies clients that the Explorer browser has failed to navigate to a Shell folder.
    ///Params:
    ///    pidlFolder = Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL that specifies the folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnNavigationFailed(ITEMIDLIST* pidlFolder);
}

///<b>IExplorerBrowser</b> is a browser object that can be either navigated or that can host a view of a data object. As
///a full-featured browser object, it also supports an automatic travel log. The Shell provides a default implementation
///of <b>IExplorerBrowser</b> as CLSID_ExplorerBrowser. Typically, a developer does not need to provide a custom
///implemention of this interface. The Windows Software Development Kit (SDK) provides full samples that demonstrate the
///use of and interaction with <b>IExplorerBrowser</b>. Download the Explorer Browser Search Sample and the Explorer
///Browser Custom Contents Sample.
@GUID("DFD3B6B5-C10C-4BE9-85F6-A66969F402F6")
interface IExplorerBrowser : IUnknown
{
    ///Prepares the browser to be navigated.
    ///Params:
    ///    hwndParent = Type: <b>HWND</b> A handle to the owner window or control.
    ///    prc = Type: <b>const RECT*</b> A pointer to a RECT that contains the coordinates of the bounding rectangle that the
    ///          browser will occupy. The coordinates are relative to <i>hwndParent</i>.
    ///    pfs = Type: <b>const FOLDERSETTINGS*</b> A pointer to a FOLDERSETTINGS structure that determines how the folder
    ///          will be displayed in the view. If this parameter is <b>NULL</b>, then you must call
    ///          IExplorerBrowser::SetFolderSettings; otherwise, the default view settings for the folder are used.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(HWND hwndParent, const(RECT)* prc, const(FOLDERSETTINGS)* pfs);
    ///Destroys the browser.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Destroy();
    ///Sets the size and position of the view windows created by the browser.
    ///Params:
    ///    phdwp = Type: <b>HDWP*</b> A pointer to a DeferWindowPos handle. This parameter can be <b>NULL</b>.
    ///    rcBrowser = Type: <b>RECT</b> The coordinates that the browser will occupy.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRect(ptrdiff_t* phdwp, RECT rcBrowser);
    ///Sets the name of the property bag.
    ///Params:
    ///    pszPropertyBag = Type: <b>LPCWSTR</b> A pointer to a constant, null-terminated, Unicode string that contains the name of the
    ///                     property bag. View state information that is specific to the application of the client is stored (persisted)
    ///                     using this name.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPropertyBag(const(wchar)* pszPropertyBag);
    ///Sets the default empty text.
    ///Params:
    ///    pszEmptyText = Type: <b>LPCWSTR</b> A pointer to a constant, null-terminated, Unicode string that contains the empty text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetEmptyText(const(wchar)* pszEmptyText);
    ///Sets the folder settings for the current view.
    ///Params:
    ///    pfs = Type: <b>const FOLDERSETTINGS*</b> A pointer to a FOLDERSETTINGS structure that contains the folder settings
    ///          to be applied.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetFolderSettings(const(FOLDERSETTINGS)* pfs);
    ///Initiates a connection with IExplorerBrowser for event callbacks.
    ///Params:
    ///    psbe = Type: <b>IExplorerBrowserEvents*</b> A pointer to the IExplorerBrowserEvents interface of the object to be
    ///           advised of IExplorerBrowser events.
    ///    pdwCookie = Type: <b>DWORD*</b> When this method returns, contains a token that uniquely identifies the event listener.
    ///                This allows several event listeners to be subscribed at a time.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Advise(IExplorerBrowserEvents psbe, uint* pdwCookie);
    ///Terminates an advisory connection.
    ///Params:
    ///    dwCookie = Type: <b>DWORD</b> A connection token previously returned from IExplorerBrowser::Advise. Identifies the
    ///               connection to be terminated.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Unadvise(uint dwCookie);
    ///Sets the current browser options.
    ///Params:
    ///    dwFlag = Type: <b>EXPLORER_BROWSER_OPTIONS</b> One or more EXPLORER_BROWSER_OPTIONS flags to be set.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOptions(EXPLORER_BROWSER_OPTIONS dwFlag);
    ///Gets the current browser options.
    ///Params:
    ///    pdwFlag = Type: <b>EXPLORER_BROWSER_OPTIONS*</b> When this method returns, contains the current
    ///              EXPLORER_BROWSER_OPTIONS for the browser.
    HRESULT GetOptions(EXPLORER_BROWSER_OPTIONS* pdwFlag);
    ///Browses to a pointer to an item identifier list (PIDL)
    ///Params:
    ///    pidl = Type: <b>PCUIDLIST_RELATIVE</b> A pointer to a const ITEMIDLIST (item identifier list) that specifies an
    ///           object's location as the destination to navigate to. This parameter can be <b>NULL</b>. For more information,
    ///           see Remarks.
    ///    uFlags = Type: <b>UINT</b> A flag that specifies the category of the <i>pidl</i>. This affects how navigation is
    ///             accomplished. Must be the value zero, or a bitwise combination of the following values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BrowseToIDList(ITEMIDLIST* pidl, uint uFlags);
    ///Browses to an object.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to an object to browse to. If the object cannot be browsed, an error value
    ///           is returned.
    ///    uFlags = Type: <b>UINT</b> A flag that specifies the category of the <i>pidl</i>. This affects how navigation is
    ///             accomplished. Must be the value zero, or a bitwise combination of the following values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BrowseToObject(IUnknown punk, uint uFlags);
    ///Creates a results folder and fills it with items.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> An interface pointer on the source object that will fill the IResultsFolder. This can
    ///           be an IDataObject or any object that can be used with INamespaceWalk.
    ///    dwFlags = Type: <b>EXPLORER_BROWSER_FILL_FLAGS</b> One of the EXPLORER_BROWSER_FILL_FLAGS values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT FillFromObject(IUnknown punk, EXPLORER_BROWSER_FILL_FLAGS dwFlags);
    ///Removes all items from the results folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or E_UNEXPECTED if this method is called before a call to
    ///    IExplorerBrowser::FillFromObject.
    ///    
    HRESULT RemoveAll();
    ///Gets an interface for the current view of the browser.
    ///Params:
    ///    riid = Type: <b>REFIID</b> A reference to the desired interface ID.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This
    ///          will typically be IShellView, IShellView2, IFolderView, or a related interface.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCurrentView(const(GUID)* riid, void** ppv);
}

///Exposes methods to enumerate unknown objects.
@GUID("2C1C7E2E-2D0E-4059-831E-1E6F82335C2E")
interface IEnumObjects : IUnknown
{
    ///Gets the next specified number and type of objects.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of objects to retrieve.
    ///    riid = Type: <b>REFIID</b> Reference to the desired interface ID.
    ///    rgelt = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>.
    ///    pceltFetched = Type: <b>ULONG*</b> Pointer to a <b>ULONG</b> value that, when this method returns, states the actual number
    ///                   of objects retrieved. This value can be <b>NULL</b>.
    HRESULT Next(uint celt, const(GUID)* riid, char* rgelt, uint* pceltFetched);
    ///Skips a specified number of objects.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of objects to skip.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Skip(uint celt);
    ///Resets the enumeration index to 0.
    HRESULT Reset();
    ///Not implemented. Not implemented.
    ///Params:
    ///    ppenum = Type: <b>IEnumObjects**</b> Not used.
    HRESULT Clone(IEnumObjects* ppenum);
}

///Exposes methods to get, set, and query a progress dialog.
@GUID("0C9FB851-E5C9-43EB-A370-F0677B13874C")
interface IOperationsProgressDialog : IUnknown
{
    ///Starts the specified progress dialog.
    ///Params:
    ///    hwndOwner = Type: <b>HWND</b> A handle to the parent window.
    ///    flags = Type: <b>DWORD</b> Flags that customize the operation. Note that these flags are declared in Shlobj.h. A
    ///            combination of the following values:
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StartProgressDialog(HWND hwndOwner, uint flags);
    ///Stops current progress dialog.
    HRESULT StopProgressDialog();
    ///Sets which progress dialog operation is occurring, and whether we are in pre-flight or undo mode.
    ///Params:
    ///    action = Type: <b>SPACTION</b> Specifies operation. See SPACTION.
    HRESULT SetOperation(SPACTION action);
    ///Sets progress dialog operations mode.
    ///Params:
    ///    mode = Type: <b>PDMODE</b> Specifies the operation mode. The following are valid values.
    HRESULT SetMode(uint mode);
    ///Updates the current progress dialog, as specified.
    ///Params:
    ///    ullPointsCurrent = Type: <b>ULONGLONG</b> Current points, used for showing progress in points.
    ///    ullPointsTotal = Type: <b>ULONGLONG</b> Total points, used for showing progress in points.
    ///    ullSizeCurrent = Type: <b>ULONGLONG</b> Current size in bytes, used for showing progress in bytes.
    ///    ullSizeTotal = Type: <b>ULONGLONG</b> Total size in bytes, used for showing progress in bytes.
    ///    ullItemsCurrent = Type: <b>ULONGLONG</b> Current items, used for showing progress in items.
    ///    ullItemsTotal = Type: <b>ULONGLONG</b> Specifies total items, used for showing progress in items.
    HRESULT UpdateProgress(ulong ullPointsCurrent, ulong ullPointsTotal, ulong ullSizeCurrent, ulong ullSizeTotal, 
                           ulong ullItemsCurrent, ulong ullItemsTotal);
    ///Called to specify the text elements stating the source and target in the current progress dialog.
    ///Params:
    ///    psiSource = Type: <b>IShellItem*</b> A pointer to an IShellItem that represents the source Shell item.
    ///    psiTarget = Type: <b>IShellItem*</b> A pointer to an IShellItem that represents the target Shell item.
    ///    psiItem = Type: <b>IShellItem*</b> A pointer to an IShellItem that represents the item currently being operated on by
    ///              the operation engine. This parameter is only used in Windows 7 and later. In earlier versions, this parameter
    ///              should be <b>NULL</b>.
    HRESULT UpdateLocations(IShellItem psiSource, IShellItem psiTarget, IShellItem psiItem);
    ///Resets progress dialog timer to 0.
    HRESULT ResetTimer();
    ///Pauses progress dialog timer.
    HRESULT PauseTimer();
    ///Resumes progress dialog timer.
    HRESULT ResumeTimer();
    ///Gets elapsed and remaining time for progress dialog.
    ///Params:
    ///    pullElapsed = Type: <b>ULONGLONG*</b> A pointer to the elapsed time in milliseconds.
    ///    pullRemaining = Type: <b>ULONGLONG*</b> A pointer to the remaining time in milliseconds.
    HRESULT GetMilliseconds(ulong* pullElapsed, ulong* pullRemaining);
    ///Gets operation status for progress dialog.
    ///Params:
    ///    popstatus = Type: <b>PDOPSTATUS*</b> Contains pointer to the operation status. See PDOPSTATUS.
    HRESULT GetOperationStatus(PDOPSTATUS* popstatus);
}

///Exposes methods for posting a cancel window message to the process thread from the Progress Dialog. This interface
///enables the progress dialog to post a thread message through PostThreadMessage to the worker thread to cancel its
///operations. The worker thread must periodically check the message queue through GetMessage, PeekMessage or
///MsgWaitForMultipleObjectsEx. The IIOCancelInformation::SetCancelInformation method tells the progress dialog which
///thread ID and what message to PostThreadMessage when the user clicks <b>Cancel</b>. A thread ID of "zero" disables
///the sending operation for the cancel message.
@GUID("F5B0BF81-8CB5-4B1B-9449-1A159E0C733C")
interface IIOCancelInformation : IUnknown
{
    ///Sets information that is posted when a user selects <b>Cancel</b> from the progress UI. Allows the main object to
    ///tell the progress dialog thread about the process thread so that the progress dialog can send the process thread
    ///the message id when the user clicks <b>Cancel</b>.
    ///Params:
    ///    dwThreadID = Type: <b>DWORD</b> The ID of the process thread to be canceled.
    ///    uMsgCancel = Type: <b>UINT</b> The cancel message to be posted to the thread.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCancelInformation(uint dwThreadID, uint uMsgCancel);
    ///Returns information that is posted when a user selects <b>Cancel</b> from the progress UI. The process thread
    ///uses this method to find out which message the progress dialog will send to the process thread when the user hits
    ///cancel. The process thread then listens for this message and does its own cleanup upon receipt.
    ///Params:
    ///    pdwThreadID = Type: <b>DWORD*</b> When this method returns, contains a pointer to the ID of the process thread.
    ///    puMsgCancel = Type: <b>UINT*</b> When this method returns, contains a pointer to <i>uMsgCancel</i> that the process thread
    ///                  should post if the operation is canceled.
    HRESULT GetCancelInformation(uint* pdwThreadID, uint* puMsgCancel);
}

///Exposes methods to copy, move, rename, create, and delete Shell items as well as methods to provide progress and
///error dialogs. This interface replaces the SHFileOperation function.
@GUID("947AAB5F-0A5C-4C13-B4D6-4BF7836FC9F8")
interface IFileOperation : IUnknown
{
    ///Enables a handler to provide status and error information for all operations.
    ///Params:
    ///    pfops = Type: <b>IFileOperationProgressSink*</b> Pointer to an IFileOperationProgressSink object to be used for
    ///            progress status and error notifications.
    ///    pdwCookie = Type: <b>DWORD*</b> When this method returns, this parameter points to a returned token that uniquely
    ///                identifies this connection. The calling application uses this token later to delete the connection by passing
    ///                it to IFileOperation::Unadvise. If the call to <b>Advise</b> fails, this value is meaningless.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Advise(IFileOperationProgressSink pfops, uint* pdwCookie);
    ///Terminates an advisory connection previously established through IFileOperation::Advise.
    ///Params:
    ///    dwCookie = Type: <b>DWORD</b> The connection token that identifies the connection to delete. This value was originally
    ///               retrieved by Advise when the connection was made.
    ///Returns:
    ///    Type: <b>HRESULT</b> Any value other than those listed here indicate a failure. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The connection was terminated successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CONNECT_E_NOCONNECTION</b></dt> </dl> </td> <td width="60%"> The value in <i>dwCookie</i> does not
    ///    represent a valid connection. </td> </tr> </table>
    ///    
    HRESULT Unadvise(uint dwCookie);
    ///Sets parameters for the current operation.
    ///Params:
    ///    dwOperationFlags = Type: <b>DWORD</b> Flags that control the file operation. This member can be a combination of the following
    ///                       flags. FOF flags are defined in Shellapi.h and FOFX flags are defined in Shobjidl.h. <div
    ///                       class="alert"><b>Note</b> If this method is not called, the default value used by the operation is
    ///                       FOF_ALLOWUNDO | FOF_NOCONFIRMMKDIR.</div> <div> </div>
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOperationFlags(uint dwOperationFlags);
    ///Not implemented.
    ///Params:
    ///    pszMessage = Type: <b>LPCWSTR</b> Pointer to the window title. This is a null-terminated, Unicode string.
    HRESULT SetProgressMessage(const(wchar)* pszMessage);
    ///Specifies a dialog box used to display the progress of the operation.
    ///Params:
    ///    popd = Type: <b>IOperationsProgressDialog*</b> Pointer to an IOperationsProgressDialog object that represents the
    ///           dialog box.
    HRESULT SetProgressDialog(IOperationsProgressDialog popd);
    ///Declares a set of properties and values to be set on an item or items.
    ///Params:
    ///    pproparray = Type: <b>IPropertyChangeArray*</b> Pointer to an IPropertyChangeArray, which accesses a collection of
    ///                 IPropertyChange objects that specify the properties to be set and their new values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetProperties(IPropertyChangeArray pproparray);
    ///Sets the parent or owner window for progress and dialog windows.
    ///Params:
    ///    hwndOwner = Type: <b>HWND</b> A handle to the owner window of the operation. This window will receive error messages.
    HRESULT SetOwnerWindow(HWND hwndOwner);
    ///Declares a single item whose property values are to be set.
    ///Params:
    ///    psiItem = Type: <b>IShellItem*</b> Pointer to the item to receive the new property values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ApplyPropertiesToItem(IShellItem psiItem);
    ///Declares a set of items for which to apply a common set of property values.
    ///Params:
    ///    punkItems = Type: <b>IUnknown*</b> Pointer to the IUnknown of the IShellItemArray, IDataObject, or IEnumShellItems object
    ///                which represents the group of items. You can also point to an IPersistIDList object to represent a single
    ///                item, effectively accomplishing the same function as IFileOperation::ApplyPropertiesToItem.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ApplyPropertiesToItems(IUnknown punkItems);
    ///Declares a single item that is to be given a new display name.
    ///Params:
    ///    psiItem = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the source item.
    ///    pszNewName = Type: <b>LPCWSTR</b> Pointer to the new display name of the item. This is a null-terminated, Unicode string.
    ///    pfopsItem = Type: <b>IFileOperationProgressSink*</b> Pointer to an IFileOperationProgressSink object to be used for
    ///                status and failure notifications. If you call IFileOperation::Advise for the overall operation, progress
    ///                status and error notifications for the rename operation are included there, so set this parameter to
    ///                <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RenameItem(IShellItem psiItem, const(wchar)* pszNewName, IFileOperationProgressSink pfopsItem);
    ///Declares a set of items that are to be given a new display name. All items are given the same name.
    ///Params:
    ///    pUnkItems = Type: <b>IUnknown*</b> Pointer to the IUnknown of the IShellItemArray, IDataObject, or IEnumShellItems object
    ///                which represents the group of items to be renamed. You can also point to an IPersistIDList object to
    ///                represent a single item, effectively accomplishing the same function as IFileOperation::RenameItem.
    ///    pszNewName = Type: <b>LPCWSTR</b> Pointer to the new display name of the items. This is a null-terminated, Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RenameItems(IUnknown pUnkItems, const(wchar)* pszNewName);
    ///Declares a single item that is to be moved to a specified destination.
    ///Params:
    ///    psiItem = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the source item.
    ///    psiDestinationFolder = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the destination folder to contain the moved
    ///                           item.
    ///    pszNewName = Type: <b>LPCWSTR</b> Pointer to a new name for the item in its new location. This is a null-terminated
    ///                 Unicode string and can be <b>NULL</b>. If <b>NULL</b>, the name of the destination item is the same as the
    ///                 source.
    ///    pfopsItem = Type: <b>IFileOperationProgressSink*</b> Pointer to an IFileOperationProgressSink object to be used for
    ///                progress status and error notifications for this specific move operation. If you call IFileOperation::Advise
    ///                for the overall operation, progress status and error notifications for the move operation are included there,
    ///                so set this parameter to <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT MoveItem(IShellItem psiItem, IShellItem psiDestinationFolder, const(wchar)* pszNewName, 
                     IFileOperationProgressSink pfopsItem);
    ///Declares a set of items that are to be moved to a specified destination.
    ///Params:
    ///    punkItems = Type: <b>IUnknown*</b> Pointer to the IUnknown of the IShellItemArray, IDataObject, or IEnumShellItems object
    ///                which represents the group of items to be moved. You can also point to an IPersistIDList object to represent
    ///                a single item, effectively accomplishing the same function as IFileOperation::MoveItem.
    ///    psiDestinationFolder = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the destination folder to contain the moved
    ///                           items.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT MoveItems(IUnknown punkItems, IShellItem psiDestinationFolder);
    ///Declares a single item that is to be copied to a specified destination.
    ///Params:
    ///    psiItem = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the source item.
    ///    psiDestinationFolder = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the destination folder to contain the copy
    ///                           of the item.
    ///    pszCopyName = Type: <b>LPCWSTR</b> Pointer to a new name for the item after it has been copied. This is a null-terminated
    ///                  Unicode string and can be <b>NULL</b>. If <b>NULL</b>, the name of the destination item is the same as the
    ///                  source.
    ///    pfopsItem = Type: <b>IFileOperationProgressSink*</b> Pointer to an IFileOperationProgressSink object to be used for
    ///                progress status and error notifications for this specific copy operation. If you call IFileOperation::Advise
    ///                for the overall operation, progress status and error notifications for the copy operation are included there,
    ///                so set this parameter to <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CopyItem(IShellItem psiItem, IShellItem psiDestinationFolder, const(wchar)* pszCopyName, 
                     IFileOperationProgressSink pfopsItem);
    ///Declares a set of items that are to be copied to a specified destination.
    ///Params:
    ///    punkItems = Type: <b>IUnknown*</b> Pointer to the IUnknown of the IShellItemArray, IDataObject, or IEnumShellItems object
    ///                which represents the group of items to be copied. You can also point to an IPersistIDList object to represent
    ///                a single item, effectively accomplishing the same function as IFileOperation::CopyItem.
    ///    psiDestinationFolder = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the destination folder to contain the copy
    ///                           of the items.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CopyItems(IUnknown punkItems, IShellItem psiDestinationFolder);
    ///Declares a single item that is to be deleted.
    ///Params:
    ///    psiItem = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the item to be deleted.
    ///    pfopsItem = Type: <b>IFileOperationProgressSink*</b> Pointer to an IFileOperationProgressSink object to be used for
    ///                progress status and error notifications for this specific delete operation. If you call
    ///                IFileOperation::Advise for the overall operation, progress status and error notifications for the delete
    ///                operation are included there, so set this parameter to <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DeleteItem(IShellItem psiItem, IFileOperationProgressSink pfopsItem);
    ///Declares a set of items that are to be deleted.
    ///Params:
    ///    punkItems = Type: <b>IUnknown*</b> Pointer to the IUnknown of the IShellItemArray, IDataObject, or IEnumShellItems object
    ///                which represents the group of items to be deleted. You can also point to an IPersistIDList object to
    ///                represent a single item, effectively accomplishing the same function as IFileOperation::DeleteItem.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DeleteItems(IUnknown punkItems);
    ///Declares a new item that is to be created in a specified location.
    ///Params:
    ///    psiDestinationFolder = Type: <b>IShellItem*</b> Pointer to an IShellItem that specifies the destination folder that will contain the
    ///                           new item.
    ///    dwFileAttributes = Type: <b>DWORD</b> A bitwise value that specifies the file system attributes for the file or folder. See
    ///                       GetFileAttributes for possible values.
    ///    pszName = Type: <b>LPCWSTR</b> Pointer to the file name of the new item, for instance <b>Newfile.txt</b>. This is a
    ///              null-terminated, Unicode string.
    ///    pszTemplateName = Type: <b>LPCWSTR</b> Pointer to the name of the template file (for example <b>Excel9.xls</b>) that the new
    ///                      item is based on, stored in one of the following locations: <ul> <li>CSIDL_COMMON_TEMPLATES. The default path
    ///                      for this folder is %ALLUSERSPROFILE%\Templates.</li> <li>CSIDL_TEMPLATES. The default path for this folder is
    ///                      %USERPROFILE%\Templates.</li> <li>%SystemRoot%\shellnew</li> </ul> This is a null-terminated, Unicode string
    ///                      used to specify an existing file of the same type as the new file, containing the minimal content that an
    ///                      application wants to include in any new file. This parameter is normally <b>NULL</b> to specify a new, blank
    ///                      file.
    ///    pfopsItem = Type: <b>IFileOperationProgressSink*</b> Pointer to an IFileOperationProgressSink object to be used for
    ///                status and failure notifications. If you call IFileOperation::Advise for the overall operation, progress
    ///                status and error notifications for the creation operation are included there, so set this parameter to
    ///                <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT NewItem(IShellItem psiDestinationFolder, uint dwFileAttributes, const(wchar)* pszName, 
                    const(wchar)* pszTemplateName, IFileOperationProgressSink pfopsItem);
    ///Executes all selected operations.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. Note that if the operation was
    ///    canceled by the user, this method can still return a success code. Use the GetAnyOperationsAborted method to
    ///    determine if this was the case.
    ///    
    HRESULT PerformOperations();
    ///Gets a value that states whether any file operations initiated by a call to IFileOperation::PerformOperations
    ///were stopped before they were complete. The operations could be stopped either by user action or silently by the
    ///system.
    ///Params:
    ///    pfAnyOperationsAborted = Type: <b>BOOL*</b> When this method returns, points to <b>TRUE</b> if any file operations were aborted before
    ///                             they were complete; otherwise, <b>FALSE</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAnyOperationsAborted(int* pfAnyOperationsAborted);
}

@GUID("CD8F23C1-8F61-4916-909D-55BDD0918753")
interface IFileOperation2 : IFileOperation
{
    HRESULT SetOperationFlags2(FILE_OPERATION_FLAGS2 operationFlags2);
}

///Exposes a method to discover objects that are named with a <b>GUID</b> from another object. Unlike QueryService this
///interface will not delegate its functionality on to other objects.
@GUID("A6087428-3BE3-4D73-B308-7C04A540BF1A")
interface IObjectProvider : IUnknown
{
    ///Queries for a specified object.
    ///Params:
    ///    guidObject = Type: <b>REFGUID</b> A reference to the <b>GUID</b> used to identify the object.
    ///    riid = Type: <b>REFIID</b> Specifies the desired interface ID.
    ///    ppvOut = Type: <b>void**</b> On success, contains the address of a pointer to the object specified by <i>riid</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT QueryObject(const(GUID)* guidObject, const(GUID)* riid, void** ppvOut);
}

///A callback interface exposing methods used with INamespaceWalk. After performing a walk with <b>INamespaceWalk</b>,
///an IShellFolder object representing the walked nodes is passed to the <b>INamespaceWalkCB</b> methods. What those
///methods do with the information depends on the object that is implementing them.
@GUID("D92995F8-CF5E-4A76-BF59-EAD39EA2B97E")
interface INamespaceWalkCB : IUnknown
{
    ///Called when an object is found in the namespace during a namespace walk. Use this method as the main action
    ///function for the class implementing it. Perform your actions as needed inside this method.
    ///Params:
    ///    psf = Type: <b>IShellFolder*</b> A pointer to an IShellFolder object representing the folder containing the item.
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> The item's PIDL, relative to <i>psf</i>.
    HRESULT FoundItem(IShellFolder psf, ITEMIDLIST* pidl);
    ///Called when a folder is about to be entered during a namespace walk. Use this method for any initialization of
    ///the retrieved item.
    ///Params:
    ///    psf = Type: <b>IShellFolder*</b> A pointer to an IShellFolder object representing the parent of the folder
    ///          designated by <i>pidl</i>.
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> The PIDL, relative to <i>psf</i>, of the folder being entered.
    HRESULT EnterFolder(IShellFolder psf, ITEMIDLIST* pidl);
    ///Called after a namespace walk through a folder. Use this method to perform any necessary cleanup following the
    ///actions performed by INamespaceWalkCB::EnterFolder or INamespaceWalkCB::FoundItem.
    ///Params:
    ///    psf = Type: <b>IShellFolder*</b> A pointer to an IShellFolder object representing the parent of the folder
    ///          designated by <i>pidl</i>.
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> A PIDL, relative to <i>psf</i>, of the folder being exited.
    HRESULT LeaveFolder(IShellFolder psf, ITEMIDLIST* pidl);
    ///Initializes the window title and cancel button text of the progress dialog box displayed during the namespace
    ///walk.
    ///Params:
    ///    ppszTitle = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to a null-terminated string that contains
    ///                the title to be used for the dialog box.
    ///    ppszCancel = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to a null-terminated string that contains
    ///                 the text displayed on the button that cancels the namespace walk.
    HRESULT InitializeProgressDialog(ushort** ppszTitle, ushort** ppszCancel);
}

///Extends INamespaceWalkCB with a method that is required in order to complete a namespace walk. This method removes
///data collected during the walk.
@GUID("7AC7492B-C38E-438A-87DB-68737844FF70")
interface INamespaceWalkCB2 : INamespaceWalkCB
{
    ///Removes data collected during a namespace walk.
    ///Params:
    ///    hr = Type: <b>HRESULT</b> The results of Walk.
    HRESULT WalkComplete(HRESULT hr);
}

///Exposes methods that walk a namespace from a given root node. The depth of the walk is specified and an optional
///array is returned containing the IDs of all nodes walked.
@GUID("57CED8A7-3F4A-432C-9350-30F24483F74F")
interface INamespaceWalk : IUnknown
{
    ///Initiates a recursive walk of the namespace from the specified root to the given depth.
    ///Params:
    ///    punkToWalk = Type: <b>IUnknown*</b> The root node from which to begin the walk. This can be represented by one of the
    ///                 following objects. <ul> <li> IShellFolder </li> <li> IDataObject </li> <li> IParentAndItem </li> <li>
    ///                 IEnumFullIDList </li> <li> IShellItem </li> <li> IShellItemArray </li> <li> IShellView </li> </ul> Specifying
    ///                 the desktop's IShellFolder as the root allows the possibility of walking the entire Windows namespace if
    ///                 <i>cDepth</i> is sufficiently large.
    ///    dwFlags = Type: <b>DWORD</b> One or more of the following flags that control the walk operation.
    ///    cDepth = Type: <b>int</b> The maximum depth to descend through the namespace hierarchy. This depth is zero-based. Set
    ///             to 0 to walk only the folder identified by <i>punkToWalk</i> but none of its subfolders.
    ///    pnswcb = Type: <b>INamespaceWalkCB*</b> INamespaceWalkCB callback function used by INamespaceWalk. This parameter can
    ///             be <b>NULL</b>. The object can optionally implement the INamespaceWalkCB2 and IActionProgress interfaces. See
    ///             remarks below.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Walk(IUnknown punkToWalk, uint dwFlags, int cDepth, INamespaceWalkCB pnswcb);
    ///Gets a list of objects found during a namespace walk initiated by INamespaceWalk::Walk.
    ///Params:
    ///    pcItems = Type: <b>UINT*</b> The number of items stored in <i>pppidl</i>
    ///    prgpidl = Type: <b>LPITEMIDLIST**</b> The address of a pointer to an array of PIDLs representing the items found during
    ///              the namespace walk.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetIDArrayResult(uint* pcItems, char* prgpidl);
}

///Exposes methods that control band objects.
@GUID("4CF504B0-DE96-11D0-8B3F-00A0C911E8E5")
interface IBandSite : IUnknown
{
    ///Adds a band to a band site object.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> The interface of a band site object.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns the band ID in ShortFromResult(hresult).
    ///    
    HRESULT AddBand(IUnknown punk);
    ///Enumerates the bands in a band site.
    ///Params:
    ///    uBand = Type: <b>UINT</b> Call the method with this parameter starting at 0 to begin enumerating. If this parameter
    ///            is -1, the <i>pdwBandID</i>parameter is ignored and this method returns the count of the bands in the band
    ///            site.
    ///    pdwBandID = Type: <b>DWORD*</b> The address of a band ID variable that receives the band ID.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error code for errors. If the first
    ///    parameter is -1, the count of the bands in the band site is returned.
    ///    
    HRESULT EnumBands(uint uBand, uint* pdwBandID);
    ///Gets information about a band in a band site.
    ///Params:
    ///    dwBandID = Type: <b>DWORD</b> The ID of the band object to query.
    ///    ppstb = Type: <b>IDeskBand**</b> Address of an IDeskBand interface pointer that, when this method returns
    ///            successfully, points to the <b>IDeskBand</b> object that represents the band. This value can be <b>NULL</b>.
    ///    pdwState = Type: <b>DWORD*</b> Pointer to a <b>DWORD</b> value that, when this method returns successfully, receives the
    ///               state of the band object. This state is a combination of BSSF_VISIBLE, BSSF_NOTITLE, and BSSF_UNDELETEABLE.
    ///               See BANDSITEINFO for more information on those flags. This value can be <b>NULL</b> if the state information
    ///               is not needed.
    ///    pszName = Type: <b>LPWSTR</b> Pointer to a buffer of <i>cchName</i> Unicode characters that, when this method returns
    ///              successfully, receives the name of the band object.
    ///    cchName = Type: <b>int</b> The size of the <i>pszName</i> buffer, in characters.
    HRESULT QueryBand(uint dwBandID, IDeskBand* ppstb, uint* pdwState, const(wchar)* pszName, int cchName);
    ///Set the state of a band in the band site.
    ///Params:
    ///    dwBandID = Type: <b>DWORD</b> The ID of the band to set. If this parameter is -1, then set the state of all bands in the
    ///               band site.
    ///    dwMask = Type: <b>DWORD</b> The mask of the states to set.
    ///    dwState = Type: <b>DWORD</b> The state values to be set. These are combinations of BSSF_* flags. For more information,
    ///              see BANDSITEINFO.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error code otherwise.
    ///    
    HRESULT SetBandState(uint dwBandID, uint dwMask, uint dwState);
    ///Removes a band from the band site.
    ///Params:
    ///    dwBandID = Type: <b>DWORD</b> The ID of the band to remove.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error code otherwise.
    ///    
    HRESULT RemoveBand(uint dwBandID);
    ///Gets a specified band object from a band site.
    ///Params:
    ///    dwBandID = Type: <b>DWORD</b> The ID of the band object to get.
    ///    riid = Type: <b>REFIID</b> The IID of the object to obtain.
    ///    ppv = Type: <b>VOID**</b> The address of a pointer variable that receives a pointer to the object requested.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error code otherwise.
    ///    
    HRESULT GetBandObject(uint dwBandID, const(GUID)* riid, void** ppv);
    ///Sets information about the band site.
    ///Params:
    ///    pbsinfo = Type: <b>BANDSITEINFO*</b> The address of a BANDSITEINFO structure that receives the band site information
    ///              for the object. The <b>dwMask</b> member of this structure specifies what information is being set.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error code otherwise.
    ///    
    HRESULT SetBandSiteInfo(const(BANDSITEINFO)* pbsinfo);
    ///Gets information about a band in the band site.
    ///Params:
    ///    pbsinfo = Type: <b>BANDSITEINFO*</b> The address of a BANDSITEINFO structure that contains the band site information
    ///              for the object. The <b>dwMask</b> member of this structure specifies what information is being requested.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error code otherwise.
    ///    
    HRESULT GetBandSiteInfo(BANDSITEINFO* pbsinfo);
}

///Exposes a method that represents a modal window. This interface is used in the Windows XP Passport Wizard.
@GUID("B4DB1657-70D7-485E-8E3E-6FCB5A5C1802")
interface IModalWindow : IUnknown
{
    ///Launches the modal window.
    ///Params:
    ///    hwndOwner = Type: <b>HWND</b> The handle of the owner window. This value can be <b>NULL</b>.
    HRESULT Show(HWND hwndOwner);
}

///<p class="CCE_Message">[The only method, DoContextMenuPopup, is no longer available for use as of Windows Server
///2003.] Implemented by the default folder view created using SHCreateShellFolderView. An implementation of
///<b>IContextMenuSite</b> supports IContextMenu::QueryContextMenu, IContextMenu::InvokeCommand, and TrackPopupMenu and
///any message forwarding necessary for that function. <b>IContextMenuSite</b> typically updates the status bar as well.
@GUID("0811AEBE-0B87-4C54-9E72-548CF649016B")
interface IContextMenuSite : IUnknown
{
    ///<p class="CCE_Message">[<b>DoContextMenuPopup</b> is no longer available for use as of Windows Server 2003.]
    ///Creates and displays a shortcut menu, tracks the selection of items on that menu, and invokes a chosen command.
    ///Params:
    ///    punkContextMenu = Type: <b>IUnknown*</b> A pointer to the shortcut menu's IUnknown implementation.
    ///    fFlags = Type: <b>UINT</b> Optional flags specifying how the shortcut menu can be changed. This parameter can be set
    ///             to any combination of the following values. The remaining bits of the low-order word are reserved by the
    ///             system. The high-order word can be used for context-specific communications. The CMF_RESERVED value can be
    ///             used to mask out the low-order word.
    ///    pt = Type: <b>POINT</b> Location where you want the shortcut menu to appear. This point specifies the location of
    ///         the menu's upper left corner in screen coordinates.
    HRESULT DoContextMenuPopup(IUnknown punkContextMenu, uint fFlags, POINT pt);
}

///<p class="CCE_Message">[This interface is supported through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be unsupported in subsequent versions of Windows.] Exposes methods that allow a Component Object Model (COM)
///object to receive and translate appropriate messages.
@GUID("568804CD-CBD7-11D0-9816-00C04FD91972")
interface IMenuBand : IUnknown
{
    ///A message pump calls this method to see if any messages should be redirected to the Component Object Model (COM)
    ///object.
    ///Params:
    ///    pmsg = Type: <b>MSG*</b> A pointer to an MSG structure.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> A
    ///    message should be redirected to the COM object. The application should call IMenuBand::TranslateMenuMessage
    ///    with this message. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    The menu has exited the menu mode and can be destroyed. </td> </tr> </table>
    ///    
    HRESULT IsMenuMessage(MSG* pmsg);
    ///Translates a message for a Component Object Model (COM) object.
    ///Params:
    ///    pmsg = Type: <b>MSG*</b> A pointer to an MSG structure that contains the incoming message.
    ///    plRet = Type: <b>LRESULT*</b> A pointer to the translated message.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    message was handled and should be deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt>
    ///    </dl> </td> <td width="60%"> The message was not handled. In this case, *plRet is <b>NULL</b>. </td> </tr>
    ///    </table>
    ///    
    HRESULT TranslateMenuMessage(MSG* pmsg, LRESULT* plRet);
}

///<p class="CCE_Message">[This interface is supported through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be unsupported in subsequent versions of Windows.] Exposes methods that retrieve and set the state of items
///in a tree-view control that have the Tree-View Control Window Styles flag set.
@GUID("A9521922-0812-4D44-9EC3-7FD38C726F3D")
interface IRegTreeItem : IUnknown
{
    ///Gets the state of a check box item in a tree-view control.
    ///Params:
    ///    pbCheck = Type: <b>BOOL*</b> A pointer to a <b>BOOL</b> that contains the state of the check box.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCheckState(int* pbCheck);
    ///Sets the state of a check box item in a tree-view control.
    ///Params:
    ///    bCheck = Type: <b>BOOL</b> A <b>BOOL</b> that sets the state of the check box.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCheckState(BOOL bCheck);
}

///<p class="CCE_Message">[This interface is supported through Windows XPService Pack 2 (SP2) and Windows Server 2003.
///It might be unsupported in subsequent versions of Windows.] Exposes methods that enable desk bar manipulation.
@GUID("EB0FE173-1A3A-11D0-89B3-00A0C90A90AC")
interface IDeskBar : IOleWindow
{
    ///Sets the client specified by <i>punkClient</i>.
    ///Params:
    ///    punkClient = Type: <b>IUnknown*</b> A pointer to a variable of type IUnknown that specifies the client used by the desk
    ///                 bar.
    HRESULT SetClient(IUnknown punkClient);
    ///Gets the client object.
    ///Params:
    ///    ppunkClient = Type: <b>IUnknown**</b> The address of a pointer to a variable of type IUnknown that receives the client used
    ///                  by the desk bar.
    HRESULT GetClient(IUnknown* ppunkClient);
    ///Notifies the object that the rectangle has changed.
    ///Params:
    ///    prc = Type: <b>LPRECT</b> A pointer to a RECT structure that specifies the child bar's desired size.
    HRESULT OnPosRectChangeDB(RECT* prc);
}

///<p class="CCE_Message">[<b>IMenuPopup</b> is available for use in the operating systems specified in the Requirements
///section. It may be altered or unavailable in subsequent versions.] Exposes methods to navigate through a shortcut
///menu.
@GUID("D1E7AFEB-6A2E-11D0-8C78-00C04FD918B4")
interface IMenuPopup : IDeskBar
{
    ///Invokes the shortcut menu at a specified onscreen location.
    ///Params:
    ///    ppt = Type: <b>POINTL*</b> A pointer to a POINTL structure that specifies the location of the pop-up menu in screen
    ///          coordinates. The pop-up menu is displayed in relation to this point as determined by the position flags set
    ///          in <i>dwFlags</i>.
    ///    prcExclude = Type: <b>RECTL*</b> A pointer to a RECTL structure that specifies the rectangle to exclude when positioning
    ///                 the menu. In Windows Vista, the alignment of the menu in relation to this area is determined by the alignment
    ///                 flags set in <i>dwFlags</i>. This parameter can be <b>NULL</b> to include the entire screen.
    ///    dwFlags = Type: <b>MP_POPUPFLAGS</b> One or more of the following constants that control the display of the pop-up
    ///              menu.
    HRESULT Popup(POINTL* ppt, RECTL* prcExclude, int dwFlags);
    ///Handles selection notifications.
    ///Params:
    ///    dwSelectType = Type: <b>DWORD</b> This parameter can be any of the following values.
    HRESULT OnSelect(uint dwSelectType);
    ///Sets the given menu bar interface to be the submenu of the calling application object's interface.
    ///Params:
    ///    pmp = Type: <b>IMenuPopup*</b> A pointer to an IMenuPopup interface that specifies the menu bar of interest.
    ///    fSet = Type: <b>BOOL</b> Removes the submenu if <i>fSet</i> is set to <b>FALSE</b>.
    HRESULT SetSubMenu(IMenuPopup pmp, BOOL fSet);
}

///Exposes methods that can be called to get information on or close a file that is in use by another application. When
///an application attempts to access a file and finds that file already in use, it can use the methods of this interface
///to gather information to present to the user in a dialog box.
@GUID("64A1CBF0-3A1A-4461-9158-376969693950")
interface IFileIsInUse : IUnknown
{
    ///Retrieves the name of the application that is using the file.
    ///Params:
    ///    ppszName = Type: <b>LPWSTR*</b> The address of a pointer to a buffer that, when this method returns successfully,
    ///               receives the application name.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAppName(ushort** ppszName);
    ///Gets a value that indicates how the file in use is being used.
    ///Params:
    ///    pfut = Type: <b>FILE_USAGE_TYPE*</b> Pointer to a value that, when this method returns successfully, receives one of
    ///           the FILE_USAGE_TYPE values.
    HRESULT GetUsage(FILE_USAGE_TYPE* pfut);
    ///Determines whether the file can be closed and whether the UI is capable of switching to the window of the
    ///application that is using the file.
    ///Params:
    ///    pdwCapFlags = Type: <b>DWORD*</b> A pointer to a value that, when this method returns successfully, receives the capability
    ///                  flags. One or both of the following values:
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCapabilities(uint* pdwCapFlags);
    ///Retrieves the handle of the top-level window of the application that is using the file.
    ///Params:
    ///    phwnd = Type: <b>HWND*</b> A pointer to an <b>HWND</b> value that, when this method returns successfully, receives
    ///            the window handle.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSwitchToHWND(HWND* phwnd);
    ///Closes the file currently in use.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CloseFile();
}

///Exposes methods that allow notification of events within a common file dialog.
@GUID("973510DB-7D7F-452B-8975-74A85828D354")
interface IFileDialogEvents : IUnknown
{
    ///Called just before the dialog is about to return with a result.
    ///Params:
    ///    pfd = Type: <b>IFileDialog*</b> A pointer to the interface that represents the dialog.
    ///Returns:
    ///    Type: <b>HRESULT</b> Implementations should return <b>S_OK</b> to accept the current result in the dialog or
    ///    <b>S_FALSE</b> to refuse it. In the case of <b>S_FALSE</b>, the dialog should remain open.
    ///    
    HRESULT OnFileOk(IFileDialog pfd);
    ///Called before IFileDialogEvents::OnFolderChange. This allows the implementer to stop navigation to a particular
    ///location.
    ///Params:
    ///    pfd = Type: <b>IFileDialog*</b> A pointer to the interface that represents the dialog.
    ///    psiFolder = Type: <b>IShellItem*</b> A pointer to an interface that represents the folder to which the dialog is about to
    ///                navigate.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. A return value of S_OK or
    ///    E_NOTIMPL indicates that the folder change can proceed.
    ///    
    HRESULT OnFolderChanging(IFileDialog pfd, IShellItem psiFolder);
    ///Called when the user navigates to a new folder.
    ///Params:
    ///    pfd = Type: <b>IFileDialog*</b> A pointer to the interface that represents the dialog.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnFolderChange(IFileDialog pfd);
    ///Called when the user changes the selection in the dialog's view.
    ///Params:
    ///    pfd = Type: <b>IFileDialog*</b> A pointer to the interface that represents the dialog.
    HRESULT OnSelectionChange(IFileDialog pfd);
    ///Enables an application to respond to sharing violations that arise from Open or Save operations.
    ///Params:
    ///    pfd = Type: <b>IFileDialog*</b> A pointer to the interface that represents the dialog.
    ///    psi = Type: <b>IShellItem*</b> A pointer to the interface that represents the item that has the sharing violation.
    ///    pResponse = Type: <b>FDE_SHAREVIOLATION_RESPONSE*</b> A pointer to a value from the FDE_SHAREVIOLATION_RESPONSE
    ///                enumeration indicating the response to the sharing violation.
    ///Returns:
    ///    Type: <b>HRESULT</b> The implementer should return E_NOTIMPL if this method is not implemented; S_OK or an
    ///    appropriate error code otherwise.
    ///    
    HRESULT OnShareViolation(IFileDialog pfd, IShellItem psi, FDE_SHAREVIOLATION_RESPONSE* pResponse);
    ///Called when the dialog is opened to notify the application of the initial chosen filetype.
    ///Params:
    ///    pfd = Type: <b>IFileDialog*</b> A pointer to the interface that represents the dialog.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnTypeChange(IFileDialog pfd);
    ///Called from the save dialog when the user chooses to overwrite a file.
    ///Params:
    ///    pfd = Type: <b>IFileDialog*</b> A pointer to the interface that represents the dialog.
    ///    psi = Type: <b>IShellItem*</b> A pointer to the interface that represents the item that will be overwritten.
    ///    pResponse = Type: <b>FDE_SHAREVIOLATION_RESPONSE*</b> A pointer to a value from the FDE_OVERWRITE_RESPONSE enumeration
    ///                indicating the response to the potential overwrite action.
    ///Returns:
    ///    Type: <b>HRESULT</b> The implementer should return E_NOTIMPL if this method is not implemented; S_OK or an
    ///    appropriate error code otherwise.
    ///    
    HRESULT OnOverwrite(IFileDialog pfd, IShellItem psi, FDE_OVERWRITE_RESPONSE* pResponse);
}

///Exposes methods that initialize, show, and get results from the common file dialog.
@GUID("42F85136-DB7E-439C-85F1-E4075D135FC8")
interface IFileDialog : IModalWindow
{
    ///Sets the file types that the dialog can open or save.
    ///Params:
    ///    cFileTypes = Type: <b>UINT</b> The number of elements in the array specified by <i>rgFilterSpec</i>.
    ///    rgFilterSpec = Type: <b>const COMDLG_FILTERSPEC*</b> A pointer to an array of COMDLG_FILTERSPEC structures, each
    ///                   representing a file type.
    ///Returns:
    ///    Type: <b>HRESULT</b> If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code,
    ///    including the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> SetFileTypes has already been called. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The
    ///    <b>FOS_PICKFOLDERS</b> flag was set in the IFileDialog::SetOptions method. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>rgFilterSpec</i> parameter is
    ///    <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT SetFileTypes(uint cFileTypes, char* rgFilterSpec);
    ///Sets the file type that appears as selected in the dialog.
    ///Params:
    ///    iFileType = Type: <b>UINT</b> The index of the file type in the file type array passed to IFileDialog::SetFileTypes in
    ///                its <i>cFileTypes</i> parameter. Note that this is a one-based index, not zero-based.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetFileTypeIndex(uint iFileType);
    ///Gets the currently selected file type.
    ///Params:
    ///    piFileType = Type: <b>UINT*</b> A pointer to a <b>UINT</b> value that receives the index of the selected file type in the
    ///                 file type array passed to IFileDialog::SetFileTypes in its <i>cFileTypes</i> parameter. <div
    ///                 class="alert"><b>Note</b> This is a one-based index rather than zero-based.</div> <div> </div>
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFileTypeIndex(uint* piFileType);
    ///Assigns an event handler that listens for events coming from the dialog.
    ///Params:
    ///    pfde = Type: <b>IFileDialogEvents*</b> A pointer to an IFileDialogEvents implementation that will receive events
    ///           from the dialog.
    ///    pdwCookie = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> that receives a value identiying this event handler. When the
    ///                client is finished with the dialog, that client must call the IFileDialog::Unadvise method with this value.
    HRESULT Advise(IFileDialogEvents pfde, uint* pdwCookie);
    ///Removes an event handler that was attached through the IFileDialog::Advise method.
    ///Params:
    ///    dwCookie = Type: <b>DWORD</b> The <b>DWORD</b> value that represents the event handler. This value is obtained through
    ///               the <i>pdwCookie</i> parameter of the IFileDialog::Advise method.
    HRESULT Unadvise(uint dwCookie);
    ///Sets flags to control the behavior of the dialog.
    ///Params:
    ///    fos = Type: <b>FILEOPENDIALOGOPTIONS</b> One or more of the FILEOPENDIALOGOPTIONS values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOptions(uint fos);
    ///Gets the current flags that are set to control dialog behavior.
    ///Params:
    ///    pfos = Type: <b>FILEOPENDIALOGOPTIONS*</b> When this method returns successfully, points to a value made up of one
    ///           or more of the FILEOPENDIALOGOPTIONS values.
    HRESULT GetOptions(uint* pfos);
    ///Sets the folder used as a default if there is not a recently used folder value available.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the interface that represents the folder.
    HRESULT SetDefaultFolder(IShellItem psi);
    ///Sets a folder that is always selected when the dialog is opened, regardless of previous user action.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the interface that represents the folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetFolder(IShellItem psi);
    ///Gets either the folder currently selected in the dialog, or, if the dialog is not currently displayed, the folder
    ///that is to be selected when the dialog is opened.
    ///Params:
    ///    ppsi = Type: <b>IShellItem**</b> The address of a pointer to the interface that represents the folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFolder(IShellItem* ppsi);
    ///Gets the user's current selection in the dialog.
    ///Params:
    ///    ppsi = Type: <b>IShellItem**</b> The address of a pointer to the interface that represents the item currently
    ///           selected in the dialog. This item can be a file or folder selected in the view window, or something that the
    ///           user has entered into the dialog's edit box. The latter case may require a parsing operation (cancelable by
    ///           the user) that blocks the current thread.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCurrentSelection(IShellItem* ppsi);
    ///Sets the file name that appears in the <b>File name</b> edit box when that dialog box is opened.
    ///Params:
    ///    pszName = Type: <b>LPCWSTR</b> A pointer to the name of the file.
    HRESULT SetFileName(const(wchar)* pszName);
    ///Retrieves the text currently entered in the dialog's <b>File name</b> edit box.
    ///Params:
    ///    pszName = Type: <b>WCHAR**</b> The address of a pointer to a buffer that, when this method returns successfully,
    ///              receives the text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFileName(ushort** pszName);
    ///Sets the title of the dialog.
    ///Params:
    ///    pszTitle = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the title text.
    HRESULT SetTitle(const(wchar)* pszTitle);
    ///Sets the text of the <b>Open</b> or <b>Save</b> button.
    ///Params:
    ///    pszText = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the button text.
    HRESULT SetOkButtonLabel(const(wchar)* pszText);
    ///Sets the text of the label next to the file name edit box.
    ///Params:
    ///    pszLabel = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the label text.
    HRESULT SetFileNameLabel(const(wchar)* pszLabel);
    ///Gets the choice that the user made in the dialog.
    ///Params:
    ///    ppsi = Type: <b>IShellItem**</b> The address of a pointer to an IShellItem that represents the user's choice.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetResult(IShellItem* ppsi);
    ///Adds a folder to the list of places available for the user to open or save items.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to an IShellItem that represents the folder to be made available to the
    ///          user. This can only be a folder.
    ///    fdap = Type: <b>FDAP</b> Specifies where the folder is placed within the list. See FDAP.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddPlace(IShellItem psi, FDAP fdap);
    ///Sets the default extension to be added to file names.
    ///Params:
    ///    pszDefaultExtension = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the extension text. This string should not include a
    ///                          leading period. For example, "jpg" is correct, while ".jpg" is not.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDefaultExtension(const(wchar)* pszDefaultExtension);
    ///Closes the dialog.
    ///Params:
    ///    hr = Type: <b>HRESULT</b> The code that will be returned by Show to indicate that the dialog was closed before a
    ///         selection was made.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Close(HRESULT hr);
    ///Enables a calling application to associate a GUID with a dialog's persisted state.
    ///Params:
    ///    guid = Type: <b>REFGUID</b> The GUID to associate with this dialog state.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetClientGuid(const(GUID)* guid);
    ///Instructs the dialog to clear all persisted state information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ClearClientData();
    ///<p class="CCE_Message">[Deprecated. <b>SetFilter</b> is no longer available for use as of Windows 7.] Sets the
    ///filter.
    ///Params:
    ///    pFilter = Type: <b>IShellItemFilter*</b> A pointer to the IShellItemFilter that is to be set.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetFilter(IShellItemFilter pFilter);
}

///Extends the IFileDialog interface by adding methods specific to the save dialog, which include those that provide
///support for the collection of metadata to be persisted with the file.
@GUID("84BCCD23-5FDE-4CDB-AEA4-AF64B83D78AB")
interface IFileSaveDialog : IFileDialog
{
    ///Sets an item to be used as the initial entry in a <b>Save As</b> dialog.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> Pointer to an IShellItem that represents the item.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSaveAsItem(IShellItem psi);
    ///Provides a property store that defines the default values to be used for the item being saved.
    ///Params:
    ///    pStore = Type: <b>IPropertyStore*</b> Pointer to the interface that represents the property store that contains the
    ///             associated metadata.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetProperties(IPropertyStore pStore);
    ///Specifies which properties will be collected in the save dialog.
    ///Params:
    ///    pList = Type: <b>IPropertyDescriptionList*</b> Pointer to the interface that represents the list of properties to
    ///            collect. This parameter can be <b>NULL</b>.
    ///    fAppendDefault = Type: <b>BOOL</b> <b>TRUE</b> to show default properties for the currently selected filetype in addition to
    ///                     the properties specified by <i>pList</i>. <b>FALSE</b> to show only properties specified by <i>pList</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCollectedProperties(IPropertyDescriptionList pList, BOOL fAppendDefault);
    ///Retrieves the set of property values for a saved item or an item in the process of being saved.
    ///Params:
    ///    ppStore = Type: <b>IPropertyStore**</b> Address of a pointer to an IPropertyStore that receives the property values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetProperties(IPropertyStore* ppStore);
    ///Applies a set of properties to an item using the Shell's copy engine.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> Pointer to the IShellItem that represents the file being saved. This is usually the
    ///          item retrieved by GetResult.
    ///    pStore = Type: <b>IPropertyStore*</b> Pointer to the IPropertyStore that represents the property values to be applied
    ///             to the file. This can be the property store returned by IFileSaveDialog::GetProperties.
    ///    hwnd = Type: <b>HWND</b> The handle of the application window.
    ///    pSink = Type: <b>IFileOperationProgressSink*</b> Pointer to an optional <b>IFileOperationProgressSink</b> that the
    ///            calling application can use if they want to be notified of the progress of the property stamping. This value
    ///            may be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ApplyProperties(IShellItem psi, IPropertyStore pStore, HWND hwnd, IFileOperationProgressSink pSink);
}

///Extends the IFileDialog interface by adding methods specific to the open dialog.
@GUID("D57C7288-D4AD-4768-BE02-9D969532D960")
interface IFileOpenDialog : IFileDialog
{
    ///Gets the user's choices in a dialog that allows multiple selection.
    ///Params:
    ///    ppenum = Type: <b>IShellItemArray**</b> The address of a pointer to an <b>IShellItemArray</b> through which the items
    ///             selected in the dialog can be accessed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetResults(IShellItemArray* ppenum);
    ///Gets the currently selected items in the dialog. These items may be items selected in the view, or text selected
    ///in the file name edit box.
    ///Params:
    ///    ppsai = Type: <b>IShellItemArray**</b> The address of a pointer to an IShellItemArray through which the selected
    ///            items can be accessed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSelectedItems(IShellItemArray* ppsai);
}

///Exposes methods that allow an application to add controls to a common file dialog.
@GUID("E6FDD21A-163F-4975-9C8C-A69F1BA37034")
interface IFileDialogCustomize : IUnknown
{
    ///Enables a drop-down list on the <b>Open</b> or <b>Save</b> button in the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the drop-down list.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnableOpenDropDown(uint dwIDCtl);
    ///Adds a menu to the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the menu to add.
    ///    pszLabel = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the menu name as a null-terminated Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddMenu(uint dwIDCtl, const(wchar)* pszLabel);
    ///Adds a button to the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the button to add.
    ///    pszLabel = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the button text as a null-terminated Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddPushButton(uint dwIDCtl, const(wchar)* pszLabel);
    ///Adds a combo box to the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the combo box to add.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddComboBox(uint dwIDCtl);
    ///Adds an option button (also known as radio button) group to the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the option button group to add.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddRadioButtonList(uint dwIDCtl);
    ///Adds a check button (check box) to the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the check button to add.
    ///    pszLabel = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the button text as a null-terminated Unicode string.
    ///    bChecked = Type: <b>BOOL</b> A <b>BOOL</b> indicating the current state of the check button. <b>TRUE</b> if checked;
    ///               <b>FALSE</b> otherwise.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddCheckButton(uint dwIDCtl, const(wchar)* pszLabel, BOOL bChecked);
    ///Adds an edit box control to the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the edit box to add.
    ///    pszText = Type: <b>LPCWSTR</b> A pointer to a null-terminated Unicode string that provides the default text displayed
    ///              in the edit box.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddEditBox(uint dwIDCtl, const(wchar)* pszText);
    ///Adds a separator to the dialog, allowing a visual separation of controls.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The control ID of the separator.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddSeparator(uint dwIDCtl);
    ///Adds text content to the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the text to add.
    ///    pszText = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the text as a null-terminated Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddText(uint dwIDCtl, const(wchar)* pszText);
    ///Sets the text associated with a control, such as button text or an edit box label.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the control whose text is to be changed.
    ///    pszLabel = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the text as a null-terminated Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetControlLabel(uint dwIDCtl, const(wchar)* pszLabel);
    ///Gets the current visibility and enabled states of a given control.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the control in question.
    ///    pdwState = Type: <b>CDCONTROLSTATEF*</b> A pointer to a variable that receives one or more values from the
    ///               CDCONTROLSTATE enumeration that indicate the current state of the control.
    HRESULT GetControlState(uint dwIDCtl, CDCONTROLSTATEF* pdwState);
    ///Sets the current visibility and enabled states of a given control.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the control in question.
    ///    dwState = Type: <b>CDCONTROLSTATEF</b> One or more values from the CDCONTROLSTATE enumeration that indicate the current
    ///              state of the control.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetControlState(uint dwIDCtl, CDCONTROLSTATEF dwState);
    ///Gets the current text in an edit box control.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the edit box.
    ///    ppszText = Type: <b>WCHAR**</b> The address of a pointer to a buffer that receives the text as a null-terminated Unicode
    ///               string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEditBoxText(uint dwIDCtl, ushort** ppszText);
    ///Sets the text in an edit box control found in the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the edit box.
    ///    pszText = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the text as a null-terminated Unicode string.
    HRESULT SetEditBoxText(uint dwIDCtl, const(wchar)* pszText);
    ///Gets the current state of a check button (check box) in the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the check box.
    ///    pbChecked = Type: <b>BOOL*</b> The address of a <b>BOOL</b> value that indicates whether the box is checked. <b>TRUE</b>
    ///                means checked; <b>FALSE</b>, unchecked.
    HRESULT GetCheckButtonState(uint dwIDCtl, int* pbChecked);
    ///Sets the state of a check button (check box) in the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the check box.
    ///    bChecked = Type: <b>BOOL</b> A <b>BOOL</b> value that indicates whether the box is checked. <b>TRUE</b> means checked;
    ///               <b>FALSE</b>, unchecked.
    HRESULT SetCheckButtonState(uint dwIDCtl, BOOL bChecked);
    ///Adds an item to a container control in the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the container control to which the item is to be added.
    ///    dwIDItem = Type: <b>DWORD</b> The ID of the item.
    ///    pszLabel = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the item's text, which can be either a label or, in
    ///               the case of a drop-down list, the item itself. This text is a null-terminated Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddControlItem(uint dwIDCtl, uint dwIDItem, const(wchar)* pszLabel);
    ///Removes an item from a container control in the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the container control from which the item is to be removed.
    ///    dwIDItem = Type: <b>DWORD</b> The ID of the item.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveControlItem(uint dwIDCtl, uint dwIDItem);
    ///Not implemented.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the container control from which to remove the items.
    HRESULT RemoveAllControlItems(uint dwIDCtl);
    ///Gets the current state of an item in a container control found in the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the container control.
    ///    dwIDItem = Type: <b>DWORD</b> The ID of the item.
    ///    pdwState = Type: <b>CDCONTROLSTATEF*</b> A pointer to a variable that receives one of more values from the
    ///               CDCONTROLSTATE enumeration that indicate the current state of the control.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetControlItemState(uint dwIDCtl, uint dwIDItem, CDCONTROLSTATEF* pdwState);
    ///Sets the current state of an item in a container control found in the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the container control.
    ///    dwIDItem = Type: <b>DWORD</b> The ID of the item.
    ///    dwState = Type: <b>CDCONTROLSTATEF</b> One or more values from the CDCONTROLSTATE enumeration that indicate the new
    ///              state of the control.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetControlItemState(uint dwIDCtl, uint dwIDItem, CDCONTROLSTATEF dwState);
    ///Gets a particular item from specified container controls in the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the container control.
    ///    pdwIDItem = Type: <b>DWORD*</b> The ID of the item that the user selected in the control.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSelectedControlItem(uint dwIDCtl, uint* pdwIDItem);
    ///Sets the selected state of a particular item in an option button group or a combo box found in the dialog.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the container control.
    ///    dwIDItem = Type: <b>DWORD</b> The ID of the item to display as selected in the control.
    HRESULT SetSelectedControlItem(uint dwIDCtl, uint dwIDItem);
    ///Declares a visual group in the dialog. Subsequent calls to any "add" method add those elements to this group.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the visual group.
    ///    pszLabel = Type: <b>LPCWSTR</b> A pointer to a buffer that contains text, as a null-terminated Unicode string, that
    ///               appears next to the visual group.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StartVisualGroup(uint dwIDCtl, const(wchar)* pszLabel);
    ///Stops the addition of elements to a visual group in the dialog.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EndVisualGroup();
    ///Places a control in the dialog so that it stands out compared to other added controls.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the control.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT MakeProminent(uint dwIDCtl);
    ///Sets the text of a control item. For example, the text that accompanies a radio button or an item in a menu.
    ///Params:
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the container control.
    ///    dwIDItem = Type: <b>DWORD</b> The ID of the item.
    ///    pszLabel = Type: <b>LPCWSTR</b> A pointer to a null-terminated buffer that contains a Unicode string with the text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetControlItemText(uint dwIDCtl, uint dwIDItem, const(wchar)* pszLabel);
}

///Exposes methods that query and set default applications for specific file Association Type, and protocols at a
///specific Association Level. <div class="alert"><b>Note</b> As of Windows 8, the only functionality of this interface
///that is supported is QueryCurrentDefault.</div><div> </div>
@GUID("4E530B0A-E611-4C77-A3AC-9031D022281B")
interface IApplicationAssociationRegistration : IUnknown
{
    ///Determines the default application for a given association type. This is the default application launched by
    ///ShellExecute for that type.
    ///Params:
    ///    pszQuery = Type: <b>LPCWSTR</b> A pointer to a null-terminated, Unicode string that contains the file name extension or
    ///               protocol, such as .mp3 or http.
    ///    atQueryType = Type: <b>ASSOCIATIONTYPE</b> One of the ASSOCIATIONTYPE enumeration values that specifies the type of
    ///                  association, such as extension or MIME type.
    ///    alQueryLevel = Type: <b>ASSOCIATIONLEVEL</b> One of the ASSOCIATIONLEVEL enumeration values that specifies the level of
    ///                   association, such as per-user or machine. This is typically AL_EFFECTIVE.
    ///    ppszAssociation = Type: <b>LPWSTR*</b> When this method returns, contains the address of a pointer to the ProgID that
    ///                      identifies the current default association. <div class="alert"><b>Note</b> It is the responsibility of the
    ///                      calling application to release the string through CoTaskMemFree.</div> <div> </div>
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT QueryCurrentDefault(const(wchar)* pszQuery, ASSOCIATIONTYPE atQueryType, ASSOCIATIONLEVEL alQueryLevel, 
                                ushort** ppszAssociation);
    ///Determines whether an application owns the registered default association for a given application level and type.
    ///Not intended for use in Windows 8.
    ///Params:
    ///    pszQuery = Type: <b>LPCWSTR</b> A pointer to a <b>null</b>-terminated Unicode string that contains the file name
    ///               extension or protocol of the application, such as .mp3 or http.
    ///    atQueryType = Type: <b>ASSOCIATIONTYPE</b> One of the ASSOCIATIONTYPE enumeration values that specifies the type of the
    ///                  application named in <i>pszQuery</i>, such as file name extension or MIME type.
    ///    alQueryLevel = Type: <b>ASSOCIATIONLEVEL</b> One of the ASSOCIATIONLEVEL enumeration values that specifies the level of
    ///                   association, such as per-user or machine. This is typically AL_EFFECTIVE.
    ///    pszAppRegistryName = Type: <b>LPCWSTR</b> A pointer to a <b>null</b>-terminated Unicode string that specifies the registered name
    ///                         of the application.
    ///    pfDefault = Type: <b>BOOL*</b> When this method returns, contains <b>TRUE</b> if the application is the default; or
    ///                <b>FALSE</b> otherwise.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT QueryAppIsDefault(const(wchar)* pszQuery, ASSOCIATIONTYPE atQueryType, ASSOCIATIONLEVEL alQueryLevel, 
                              const(wchar)* pszAppRegistryName, int* pfDefault);
    ///Determines whether an application owns all of the registered default associations for a given application level.
    ///Not intended for use in Windows 8.
    ///Params:
    ///    alQueryLevel = Type: <b>ASSOCIATIONLEVEL</b> One of the ASSOCIATIONLEVEL enumeration values that specifies the level of
    ///                   association, such as per-user or machine. This is typically AL_EFFECTIVE.
    ///    pszAppRegistryName = Type: <b>LPCWSTR</b> A pointer to a <b>null</b>-terminated Unicode string that specifies the registered name
    ///                         of the application.
    ///    pfDefault = Type: <b>BOOL*</b> When this method returns, contains <b>TRUE</b> if the application is the default for all
    ///                association types at the specified ASSOCIATIONLEVEL; or <b>FALSE</b> otherwise.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT QueryAppIsDefaultAll(ASSOCIATIONLEVEL alQueryLevel, const(wchar)* pszAppRegistryName, int* pfDefault);
    ///Sets an application as the default for a given extension or protocol, provided that the application's publisher
    ///matches the current default's. For more information, see Default Programs. Not intended for use in Windows 8.
    ///Params:
    ///    progId = Type: <b>LPCWSTR</b> A pointer to a <b>null</b>-terminated Unicode string that specifies the application's
    ///             ProgID.
    ///    extOrUriScheme = Type: <b>LPCWSTR</b> A pointer to a <b>null</b>-terminated Unicode string that contains the file name
    ///                     extension or protocol of the application, such as .mp3 or http.
    ///    atSetType = Type: <b>ASSOCIATIONTYPE</b> One of the ASSOCIATIONTYPE enumeration values that specifies the type of the
    ///                application named in <i>extOrUriScheme</i>, such as file name extension or MIME type.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code. In particular, if the application's
    ///    publisher doesn't match the default's, this method returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">E_ACCESSDENIED</b>.
    ///    
    HRESULT SetAppAsDefault(const(wchar)* pszAppRegistryName, const(wchar)* pszSet, ASSOCIATIONTYPE atSetType);
    ///Sets an application as the default for all of the registered associations of any type for that application. Not
    ///intended for use in Windows 8.
    ///Params:
    ///    pszAppRegistryName = Type: <b>LPCWSTR</b> A pointer to a null-terminated Unicode string that specifies the registered name of the
    ///                         application.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetAppAsDefaultAll(const(wchar)* pszAppRegistryName);
    ///Removes all per-user associations for the current user. This results in a reversion to machine defaults, if they
    ///exist. Not intended for use in Windows 8.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ClearUserAssociations();
}

///Exposes a method through which a delegate folder is given the IMalloc interface required to allocate and free item
///IDs.
@GUID("ADD8BA80-002B-11D0-8F0F-00C04FD7D062")
interface IDelegateFolder : IUnknown
{
    ///Provides the delegate folder an IMalloc interface used to allocate and free item IDs.
    ///Params:
    ///    pmalloc = Type: <b>IMalloc*</b> A pointer to an IMalloc interface.
    HRESULT SetItemAlloc(IMalloc pmalloc);
}

///Allows a browser or host to ask IShellView what kind of view behavior is supported.
@GUID("10DF43C8-1DBE-11D3-8B34-006097DF5BD4")
interface IBrowserFrameOptions : IUnknown
{
    ///Retrieves the available browser frame view options.
    ///Params:
    ///    dwMask = Type: <b>BROWSERFRAMEOPTIONS</b> Specifies the options requested as a bitwise combination of one or more of
    ///             the constants of enumeration type BROWSERFRAMEOPTIONS.
    ///    pdwOptions = Type: <b>BROWSERFRAMEOPTIONS*</b> When this method returns, contains the options that the view can enable
    ///                 (for example, IShellView ). This value is not optional and is always equal to, or a subset of, the options
    ///                 specified by <i>dwMask</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFrameOptions(uint dwMask, uint* pdwOptions);
}

///Exposes a method that determines whether a window that is launched by another window should be displayed or blocked,
///allowing control of pop-up windows.
@GUID("D2BC4C84-3F72-4A52-A604-7BCBF3982CBB")
interface INewWindowManager : IUnknown
{
    ///Accepts data about a new window that is attempting to display and determines whether that window should be
    ///allowed to open based on the user's preferences.
    ///Params:
    ///    pszUrl = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the URL of the content that will be displayed in the
    ///             new window.
    ///    pszName = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the name of the new window. This parameter can be
    ///              <b>NULL</b>.
    ///    pszUrlContext = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the URL that has issued the command to open the new
    ///                    window.
    ///    pszFeatures = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the feature string for the new window. This value
    ///                  can be <b>NULL</b>.
    ///    fReplace = Type: <b>BOOL</b> A boolean value used when the new content specified in <i>pszUrl</i> is loaded into the
    ///               existing window instead of creating a new one. <b>TRUE</b> if the new document should replace the current
    ///               document in the history list; <b>FALSE</b> if the new document should be given a new entry.
    ///    dwFlags = Type: <b>DWORD</b> A flag or flags from the NWMF enumeration that provide situational information about the
    ///              call to open the new window. This value can be 0 if no flags are needed.
    ///    dwUserActionTime = Type: <b>DWORD</b> The tick count when the last user action occurred. To find out how long ago the action
    ///                       occurred, call GetTickCount and compare the result with the value in this parameter.
    HRESULT EvaluateNewWindow(const(wchar)* pszUrl, const(wchar)* pszName, const(wchar)* pszUrlContext, 
                              const(wchar)* pszFeatures, BOOL fReplace, uint dwFlags, uint dwUserActionTime);
}

///Exposes methods that work with client applications to present a user environment that provides safe download and
///exchange of files through email and messaging attachments.
@GUID("73DB1241-1E85-4581-8E4F-A81E1D0F8C57")
interface IAttachmentExecute : IUnknown
{
    ///Specifies and stores the title of the prompt window.
    ///Params:
    ///    pszTitle = Type: <b>LPCWSTR</b> A pointer to a string that contains the title text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetClientTitle(const(wchar)* pszTitle);
    ///Specifies and stores the GUID for the client.
    ///Params:
    ///    guid = Type: <b>REFGUID</b> The GUID that represents the client.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetClientGuid(const(GUID)* guid);
    ///Sets and stores the path to the file.
    ///Params:
    ///    pszLocalPath = Type: <b>LPCWSTR</b> A pointer to a string that contains the local path where the attachment file is to be
    ///                   stored.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetLocalPath(const(wchar)* pszLocalPath);
    ///Specifies and stores the proposed name of the file.
    ///Params:
    ///    pszFileName = Type: <b>LPCWSTR</b> A pointer to a string that contains the file name.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b>
    ///    error code, including the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pszFileName</i> value is
    ///    is set to <b>NULL</b>, points to an empty string, or points to a file name longer than <b>MAX_PATH</b>. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The file name
    ///    cannot be stored. </td> </tr> </table>
    ///    
    HRESULT SetFileName(const(wchar)* pszFileName);
    ///Sets an alternate path or URL for the source of a file transfer.
    ///Params:
    ///    pszSource = Type: <b>LPCWSTR</b> A pointer to a string containing the path or URL to use as the source.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSource(const(wchar)* pszSource);
    ///Sets the security zone associated with the attachment file based on the referring file.
    ///Params:
    ///    pszReferrer = Type: <b>LPCWSTR</b> A pointer to a string containing the path of the referring file.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetReferrer(const(wchar)* pszReferrer);
    ///Provides a Boolean test that can be used to make decisions based on the attachment's execution policy.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns one of the following values. <table class="clsStd"> <tr> <th>Value</th>
    ///    <th>Meaning</th> </tr> <tr> <td>S_OK</td> <td>Enable</td> </tr> <tr> <td>S_FALSE</td> <td>Prompt</td> </tr>
    ///    <tr> <td>Any other failure code</td> <td>Disable</td> </tr> </table>
    ///    
    HRESULT CheckPolicy();
    ///Presents a prompt UI to the user.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> A handle to the parent window.
    ///    prompt = Type: <b>ATTACHMENT_PROMPT</b> A member of the ATTACHMENT_PROMPT enumeration that indicates what type of
    ///             prompt UI to display to the user.
    ///    paction = Type: <b>ATTACHMENT_ACTION*</b> A member of the ATTACHMENT_ACTION enumeration that indicates the action to be
    ///              performed upon user confirmation.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Prompt(HWND hwnd, ATTACHMENT_PROMPT prompt, ATTACHMENT_ACTION* paction);
    ///Saves the attachment.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Save();
    ///Executes an action on an attachment.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the parent window.
    ///    pszVerb = Type: <b>LPCWSTR</b> A pointer to a null-terminated string that contains a verb specifying the action to be
    ///              performed on the file. See the <i>lpOperation</i> parameter in ShellExecute for valid strings. This value can
    ///              be <b>NULL</b>.
    ///    phProcess = Type: <b>HANDLE*</b> A pointer to a handle to the source process, used for synchronous operation. This value
    ///                can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Execute(HWND hwnd, const(wchar)* pszVerb, HANDLE* phProcess);
    ///Presents the user with explanatory error UI if the save action fails.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the parent window.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SaveWithUI(HWND hwnd);
    ///Removes any stored state that is based on the client's GUID. An example might be a setting based on a checked box
    ///that indicates a prompt should not be displayed again for a particular file type.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ClearClientState();
}

///A callback interface that exposes a method that receives messages from a menu band.
@GUID("4CA300A1-9B8D-11D1-8B22-00C04FD918D0")
interface IShellMenuCallback : IUnknown
{
    ///Receives messages from a menu band object.
    ///Params:
    ///    psmd = Type: <b>LPSMDATA</b> A pointer to a SMDATA structure that contains information about the menu.
    ///    uMsg = Type: <b>UINT</b> A message ID. This will be one of the SMC_XXX values. See Shell Messages and Notifications
    ///           for a complete list.
    ///    wParam = Type: <b>WPARAM</b> A WPARAM value that contains additional information. See the specific SMC_XXX message
    ///             reference for details.
    ///    lParam = Type: <b>LPARAM</b> An LPARAM value that contains additional information. See the specific SMC_XXX message
    ///             reference for details.
    HRESULT CallbackSM(SMDATA* psmd, uint uMsg, WPARAM wParam, LPARAM lParam);
}

///Exposes methods that interact with Shell menus such as the <b>Start</b> menu, and the <b>Favorites</b> menu.
@GUID("EE1F7637-E138-11D1-8379-00C04FD918D0")
interface IShellMenu : IUnknown
{
    ///Initializes a menu band.
    ///Params:
    ///    psmc = Type: <b>IShellMenuCallback*</b> A pointer to an IShellMenuCallback interface. This interface receives
    ///           notifications from the menu. This value can be <b>NULL</b>.
    ///    uId = Type: <b>UINT</b> The identifier of the selected menu item. Set this parameter to -1 for the menu itself.
    ///    uIdAncestor = Type: <b>UINT</b>
    ///    dwFlags = Type: <b>DWORD</b> Flags that control how the menu operates. A combination of the following option values:
    ///              <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SMINIT_DEFAULT"></a><a
    ///              id="sminit_default"></a><dl> <dt><b>SMINIT_DEFAULT</b></dt> </dl> </td> <td width="60%"> No options. </td>
    ///              </tr> <tr> <td width="40%"><a id="SMINIT_RESTRICT_DRAGDROP"></a><a id="sminit_restrict_dragdrop"></a><dl>
    ///              <dt><b>SMINIT_RESTRICT_DRAGDROP</b></dt> </dl> </td> <td width="60%"> Do not allow drag-and-drop. </td> </tr>
    ///              <tr> <td width="40%"><a id="SMINIT_TOPLEVEL"></a><a id="sminit_toplevel"></a><dl>
    ///              <dt><b>SMINIT_TOPLEVEL</b></dt> </dl> </td> <td width="60%"> This is the top band. </td> </tr> <tr> <td
    ///              width="40%"><a id="SMINIT_CACHED"></a><a id="sminit_cached"></a><dl> <dt><b>SMINIT_CACHED</b></dt> </dl>
    ///              </td> <td width="60%"> Do not destroy the band when the window is closed. </td> </tr> </table> In addition to
    ///              the values above, one of the following layout options: <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///              <tr> <td width="40%"><a id="SMINIT_VERTICAL"></a><a id="sminit_vertical"></a><dl>
    ///              <dt><b>SMINIT_VERTICAL</b></dt> </dl> </td> <td width="60%"> Specifies a vertical band. </td> </tr> <tr> <td
    ///              width="40%"><a id="SMINIT_HORIZONTAL"></a><a id="sminit_horizontal"></a><dl>
    ///              <dt><b>SMINIT_HORIZONTAL</b></dt> </dl> </td> <td width="60%"> Specifies a horizontal band. </td> </tr>
    ///              </table>
    HRESULT Initialize(IShellMenuCallback psmc, uint uId, uint uIdAncestor, uint dwFlags);
    ///Gets information from the IShellMenu::Initialize method.
    ///Params:
    ///    ppsmc = Type: <b>IShellMenuCallback**</b> When this method returns, contains the address of a pointer to the
    ///            IShellMenuCallback interface that you specified when you called IShellMenu::Initialize. This pointer can be
    ///            <b>NULL</b>.
    ///    puId = Type: <b>UINT*</b> When this method returns, contains a pointer to a <b>UINT</b> value that receives the
    ///           <i>uID</i> value that you specified when you called IShellMenu::Initialize. This pointer can be <b>NULL</b>.
    ///    puIdAncestor = Type: <b>UINT*</b> When this method returns, contains a pointer to a <b>UINT</b> value that receives the
    ///                   <i>uIdAncestor</i> value that you specified when you called IShellMenu::Initialize. This pointer can be
    ///                   <b>NULL</b>.
    ///    pdwFlags = Type: <b>DWORD*</b> When this method returns, contains a pointer to a <b>DWORD</b> value that receives the
    ///               <i>dwFlags</i> value that you specified when you called IShellMenu::Initialize. This pointer can be
    ///               <b>NULL</b>.
    HRESULT GetMenuInfo(IShellMenuCallback* ppsmc, uint* puId, uint* puIdAncestor, uint* pdwFlags);
    ///Specifies the folder for the menu band to browse.
    ///Params:
    ///    psf = Type: <b>IShellFolder*</b> A pointer to the folder's IShellFolder interface. This pointer can be <b>NULL</b>.
    ///    pidlFolder = Type: <b>PCIDLIST_ABSOLUTE</b> The folder's fully qualified ITEMIDLIST. This value can be <b>NULL</b>.
    ///    hKey = Type: <b>HKEY</b> An HKEY with an "Order" value that is used to store the order of the menu. This value can
    ///           be <b>NULL</b>.
    ///    dwFlags = Type: <b>DWORD</b> Flags that specify how the menu band operates.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetShellFolder(IShellFolder psf, ITEMIDLIST* pidlFolder, HKEY hKey, uint dwFlags);
    ///Gets the folder that the menu band is set to browse.
    ///Params:
    ///    pdwFlags = Type: <b>DWORD*</b> When this method returns successfully, contains a pointer to a set of flag values that
    ///               specify how the menu band operates. Can return any of the following flags. <table> <tr> <th>Value</th>
    ///               <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SMINIT_DEFAULT"></a><a id="sminit_default"></a><dl>
    ///               <dt><b>SMINIT_DEFAULT</b></dt> </dl> </td> <td width="60%"> No options. </td> </tr> <tr> <td width="40%"><a
    ///               id="SMINIT_RESTRICT_DRAGDROP"></a><a id="sminit_restrict_dragdrop"></a><dl>
    ///               <dt><b>SMINIT_RESTRICT_DRAGDROP</b></dt> </dl> </td> <td width="60%"> Do not allow drag-and-drop. </td> </tr>
    ///               <tr> <td width="40%"><a id="SMINIT_TOPLEVEL"></a><a id="sminit_toplevel"></a><dl>
    ///               <dt><b>SMINIT_TOPLEVEL</b></dt> </dl> </td> <td width="60%"> This is the top band. </td> </tr> <tr> <td
    ///               width="40%"><a id="SMINIT_CACHED"></a><a id="sminit_cached"></a><dl> <dt><b>SMINIT_CACHED</b></dt> </dl>
    ///               </td> <td width="60%"> Do not destroy the band when the window is closed. </td> </tr> </table> Always returns
    ///               one of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///               id="SMINIT_VERTICAL"></a><a id="sminit_vertical"></a><dl> <dt><b>SMINIT_VERTICAL</b></dt> </dl> </td> <td
    ///               width="60%"> Specifies a vertical band. </td> </tr> <tr> <td width="40%"><a id="SMINIT_HORIZONTAL"></a><a
    ///               id="sminit_horizontal"></a><dl> <dt><b>SMINIT_HORIZONTAL</b></dt> </dl> </td> <td width="60%"> Specifies a
    ///               horizontal band. </td> </tr> </table>
    ///    ppidl = Type: <b>PCIDLIST_ABSOLUTE*</b> When this method returns, contains the address of the folder's fully
    ///            qualified ITEMIDLIST.
    ///    riid = Type: <b>REFIID</b> The REFIID for the target folder.
    ///    ppv = Type: <b>void**</b> When this method returns successfully, contains the address of a pointer to the Shell
    ///          folder object referenced by the <i>riid</i>.
    HRESULT GetShellFolder(uint* pdwFlags, ITEMIDLIST** ppidl, const(GUID)* riid, void** ppv);
    ///Appends a static menu to the menu band.
    ///Params:
    ///    hmenu = Type: <b>HMENU</b> The handle of the static menu that is to be appended. This value can be <b>NULL</b>.
    ///    hwnd = Type: <b>HWND</b> The <b>HWND</b> of the owner window. This value can be <b>NULL</b>.
    ///    dwFlags = Type: <b>DWORD</b> Flags that specify how the menu operates.
    HRESULT SetMenu(HMENU hmenu, HWND hwnd, uint dwFlags);
    ///Gets the menu information set by calling IShellMenu::SetMenu.
    ///Params:
    ///    phmenu = Type: <b>HMENU*</b> When this method returns, contains a pointer to an <b>HMENU</b> value that receives the
    ///             <i>hmenu</i> value that you specified when you called IShellMenu::SetMenu. This value can be <b>NULL</b>.
    ///    phwnd = Type: <b>HWND*</b> When this method returns, contains a pointer to an <b>HWND</b> value that receives the
    ///            <i>hwnd</i> value that you specified when you called IShellMenu::SetMenu. This value can be <b>NULL</b>.
    ///    pdwFlags = Type: <b>DWORD*</b> When this method returns, contains a pointer to a <b>DWORD</b> value that receives the
    ///               <i>dwFlags</i> value that you specified when you called IShellMenu::SetMenu. This value can be <b>NULL</b>.
    HRESULT GetMenu(HMENU* phmenu, HWND* phwnd, uint* pdwFlags);
    ///Redraws an item in a menu band.
    ///Params:
    ///    psmd = Type: <b>LPSMDATA</b> A pointer to an SMDATA structure that identifies the item to be redrawn. Set this value
    ///           to <b>NULL</b> to redraw the entire menu.
    ///    dwFlags = Type: <b>DWORD</b> Flags that control how the menu is redrawn. If <i>psmd</i> is <b>NULL</b>, set
    ///              <i>dwFlags</i> to SMINV_REFRESH. If <i>psmd</i> is set to a valid SMDATA structure, set <i>dwFlags</i> to
    ///              SMINV_ID | SMINV_REFRESH.
    HRESULT InvalidateItem(SMDATA* psmd, uint dwFlags);
    ///Gets a filled SMDATA structure.
    ///Params:
    ///    psmd = Type: <b>LPSMDATA</b> When this method returns, contains a pointer to an SMDATA structure that contains
    ///           information about the menu band.
    HRESULT GetState(SMDATA* psmd);
    ///Adds a menu to the menuband.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to an object that supports <b>CLSID_MenuToolbarBase</b> in its
    ///           QueryInterface method.
    ///    dwFlags = Type: <b>DWORD</b> Flags that control how the menu operates.
    HRESULT SetMenuToolbar(IUnknown punk, uint dwFlags);
}

///Exposes methods that allow an application to retrieve information about a known folder's category, type, GUID,
///pointer to an item identifier list (PIDL) value, redirection capabilities, and definition. It provides a method for
///the retrival of a known folder's IShellItem object. It also provides methods to get or set the path of the known
///folder.
@GUID("3AA7AF7E-9B36-420C-A8E3-F77D4674A488")
interface IKnownFolder : IUnknown
{
    ///Gets the ID of the selected folder.
    ///Params:
    ///    pkfid = Type: <b>KNOWNFOLDERID*</b> When this method returns, returns the KNOWNFOLDERID value of the known folder.
    ///            Note, <b>KNOWNFOLDERID</b> values are GUIDs.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetId(GUID* pkfid);
    ///Retrieves the category—virtual, fixed, common, or per-user—of the selected folder.
    ///Params:
    ///    pCategory = Type: <b>KF_CATEGORY*</b> When this method returns, contains a pointer to the KF_CATEGORY of the selected
    ///                folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCategory(KF_CATEGORY* pCategory);
    ///Retrieves the location of a known folder in the Shell namespace in the form of a Shell item (IShellItem or
    ///derived interface).
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> Flags that specify special retrieval options. This value can be 0; otherwise, one or more
    ///              of the KNOWN_FOLDER_FLAG values.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the requested interface.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This
    ///          is typically IShellItem or IShellItem2.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetShellItem(uint dwFlags, const(GUID)* riid, void** ppv);
    ///Retrieves the path of a known folder as a string.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> Flags that specify special retrieval options. This value can be 0; otherwise, one or more
    ///              of the KNOWN_FOLDER_FLAG values.
    ///    ppszPath = Type: <b>LPWSTR*</b> When this method returns, contains the address of a pointer to a null-terminated buffer
    ///               that contains the path. The calling application is responsible for calling CoTaskMemFree to free this
    ///               resource when it is no longer needed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPath(uint dwFlags, ushort** ppszPath);
    ///Assigns a new path to a known folder.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> Either zero or the following value:
    ///    pszPath = Type: <b>LPCWSTR</b> Pointer to the folder's new path. This is a null-terminated Unicode string of length
    ///              MAX_PATH. This path cannot be of zero length. If this value is <b>NULL</b>, the <b>IKnownFolder::SetPath</b>
    ///              sets the path to the default value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPath(uint dwFlags, const(wchar)* pszPath);
    ///Gets the location of the Shell namespace folder in the IDList (ITEMIDLIST) form.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> Flags that specify special retrieval options. This value can be 0; otherwise, one or more
    ///              of the KNOWN_FOLDER_FLAG values.
    ///    ppidl = Type: <b>PIDLIST_ABSOLUTE*</b> When this method returns, contains the address of an absolute PIDL. This
    ///            parameter is passed uninitialized. The calling application is responsible for freeing this resource when it
    ///            is no longer needed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetIDList(uint dwFlags, ITEMIDLIST** ppidl);
    ///Retrieves the folder type.
    ///Params:
    ///    pftid = Type: <b>FOLDERTYPEID*</b> When this returns, contains a pointer to a FOLDERTYPEID (a GUID) that identifies
    ///            the known folder type.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFolderType(GUID* pftid);
    ///Gets a value that states whether the known folder can have its path set to a new value or what specific
    ///restrictions or prohibitions are placed on that redirection.
    ///Params:
    ///    pCapabilities = Type: <b>KF_REDIRECTION_CAPABILITIES*</b> When this method returns, contains a pointer to a
    ///                    KF_REDIRECTION_CAPABILITIES value that indicates the redirection capabilities for this folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRedirectionCapabilities(uint* pCapabilities);
    ///Retrieves a structure that contains the defining elements of a known folder, which includes the folder's
    ///category, name, path, description, tooltip, icon, and other properties.
    ///Params:
    ///    pKFD = Type: <b>KNOWNFOLDER_DEFINITION*</b> When this method returns, contains a pointer to the
    ///           KNOWNFOLDER_DEFINITION structure. When no longer needed, the calling application is responsible for calling
    ///           FreeKnownFolderDefinitionFields to free this resource.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFolderDefinition(KNOWNFOLDER_DEFINITION* pKFD);
}

///Exposes methods that create, enumerate or manage existing known folders.
@GUID("8BE2D872-86AA-4D47-B776-32CCA40C7018")
interface IKnownFolderManager : IUnknown
{
    ///Gets the KNOWNFOLDERID that is the equivalent of a legacy CSIDL value.
    ///Params:
    ///    nCsidl = Type: <b>int</b> The CSIDL value.
    ///    pfid = Type: <b>KNOWNFOLDERID*</b> When this method returns, contains a pointer to the KNOWNFOLDERID. This pointer
    ///           is passed uninitialized.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT FolderIdFromCsidl(int nCsidl, GUID* pfid);
    ///Gets the legacy CSIDL value that is the equivalent of a given KNOWNFOLDERID.
    ///Params:
    ///    rfid = Type: <b>REFKNOWNFOLDERID</b> Reference to the KNOWNFOLDERID.
    ///    pnCsidl = Type: <b>int*</b> When this method returns, contains a pointer to the CSIDL value. This pointer is passed
    ///              uninitialized.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Among other things, this value can indicate that
    ///    the <i>rfid</i> parameter references a KNOWNFOLDERID that is not present on the system. Not all
    ///    <b>KNOWNFOLDERID</b> values are present on all systems. Use IKnownFolderManager::GetFolderIds to retrieve the
    ///    set of <b>KNOWNFOLDERID</b> values for the current system. </td> </tr> </table>
    ///    
    HRESULT FolderIdToCsidl(const(GUID)* rfid, int* pnCsidl);
    ///Gets an array of all registered known folder IDs. This can be used in enumerating all known folders.
    ///Params:
    ///    ppKFId = Type: <b>KNOWNFOLDERID**</b> When this method returns, contains a pointer to an array of all KNOWNFOLDERID
    ///             values registered with the system. Use CoTaskMemFree to free these resources when they are no longer needed.
    ///    pCount = Type: <b>UINT*</b> When this method returns, contains a pointer to the number of KNOWNFOLDERID values in the
    ///             array at <i>ppKFId</i>. The [in] functionality of this parameter is not used.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFolderIds(char* ppKFId, uint* pCount);
    ///Gets an object that represents a known folder identified by its KNOWNFOLDERID. The object allows you to query
    ///certain folder properties, get the current path of the folder, redirect the folder to another location, and get
    ///the path of the folder as an ITEMIDLIST.
    ///Params:
    ///    rfid = Type: <b>REFKNOWNFOLDERID</b> Reference to the KNOWNFOLDERID.
    ///    ppkf = Type: <b>IKnownFolder**</b> When this method returns, contains an interface pointer to the IKnownFolder
    ///           object that represents the folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Among other things, this value can indicate that
    ///    the <i>rfid</i> parameter references a KNOWNFOLDERID that is not present on the system. Not all
    ///    <b>KNOWNFOLDERID</b> values are present on all systems. Use IKnownFolderManager::GetFolderIds to retrieve the
    ///    set of <b>KNOWNFOLDERID</b> values for the current system. </td> </tr> </table>
    ///    
    HRESULT GetFolder(const(GUID)* rfid, IKnownFolder* ppkf);
    ///Gets an object that represents a known folder identified by its canonical name. The object allows you to query
    ///certain folder properties, get the current path of the folder, redirect the folder to another location, and get
    ///the path of the folder as an ITEMIDLIST.
    ///Params:
    ///    pszCanonicalName = Type: <b>LPCWSTR</b> A pointer to the non-localized, canonical name for the known folder, stored as a
    ///                       null-terminated Unicode string. If this folder is a common or per-user folder, this value is also used as the
    ///                       value name of the "User Shell Folders" registry settings. This value is retrieved through the <b>pszName</b>
    ///                       member of the folder's KNOWNFOLDER_DEFINITION structure.
    ///    ppkf = Type: <b>IKnownFolder**</b> When this method returns, contains the address of a pointer to the IKnownFolder
    ///           object that represents the known folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFolderByName(const(wchar)* pszCanonicalName, IKnownFolder* ppkf);
    ///Adds a new known folder to the registry. Used particularly by independent software vendors (ISVs) that are adding
    ///one of their own folders to the known folder system.
    ///Params:
    ///    rfid = Type: <b>REFKNOWNFOLDERID</b> A <b>GUID</b> that represents the known folder.
    ///    pKFD = Type: <b>const KNOWNFOLDER_DEFINITION*</b> A pointer to a valid KNOWNFOLDER_DEFINITION structure that
    ///           provides the details of the new folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RegisterFolder(const(GUID)* rfid, const(KNOWNFOLDER_DEFINITION)* pKFD);
    ///Remove a known folder from the registry, which makes it unknown to the known folder system. This method does not
    ///remove the folder itself.
    ///Params:
    ///    rfid = Type: <b>REFKNOWNFOLDERID</b> <b>GUID</b> or KNOWNFOLDERID that represents the known folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Among other things, this value can indicate that
    ///    the <i>rfid</i> parameter references a KNOWNFOLDERID that is not present on the system. Not all
    ///    <b>KNOWNFOLDERID</b> values are present on all systems. Use IKnownFolderManager::GetFolderIds to retrieve the
    ///    set of <b>KNOWNFOLDERID</b> values known to the current system. </td> </tr> </table>
    ///    
    HRESULT UnregisterFolder(const(GUID)* rfid);
    ///Gets an object that represents a known folder based on a file system path. The object allows you to query certain
    ///folder properties, get the current path of the folder, redirect the folder to another location, and get the path
    ///of the folder as an ITEMIDLIST.
    ///Params:
    ///    pszPath = Type: <b>LPCWSTR</b> Pointer to a null-terminated Unicode string of length MAX_PATH that contains a path to a
    ///              known folder.
    ///    mode = Type: <b>FFFP_MODE</b> One of the following values that specify the precision of the match of path and known
    ///           folder:
    ///    ppkf = Type: <b>IKnownFolder**</b> When this method returns, contains the address of a pointer to the IKnownFolder
    ///           object that represents the known folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT FindFolderFromPath(const(wchar)* pszPath, FFFP_MODE mode, IKnownFolder* ppkf);
    ///Gets an object that represents a known folder based on an IDList. The object allows you to query certain folder
    ///properties, get the current path of the folder, redirect the folder to another location, and get the path of the
    ///folder as an ITEMIDLIST.
    ///Params:
    ///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> A pointer to the IDList.
    ///    ppkf = Type: <b>IKnownFolder**</b> When this method returns, contains the address of a pointer to the IKnownFolder
    ///           object that represents the known folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT FindFolderFromIDList(ITEMIDLIST* pidl, IKnownFolder* ppkf);
    ///Redirects folder requests for common and per-user folders.
    ///Params:
    ///    rfid = Type: <b>REFKNOWNFOLDERID</b> A reference to the KNOWNFOLDERID of the folder to be redirected.
    ///    hwnd = Type: <b>HWND</b> The handle of the parent window used to display copy engine progress UI dialogs when
    ///           KF_REDIRECT_WITH_UI i passed in the <i>flags</i> parameter. If no progress dialog is needed, this value can
    ///           be <b>NULL</b>.
    ///    flags = Type: <b>KF_REDIRECT_FLAGS</b> The KF_REDIRECT_FLAGS options for redirection.
    ///    pszTargetPath = Type: <b>LPCWSTR</b> A pointer to the new path for the folder. This is a null-terminated Unicode string. This
    ///                    value can be <b>NULL</b>.
    ///    cFolders = Type: <b>UINT</b> The number of KNOWNFOLDERID values in the array at <i>pExclusion</i>.
    ///    pExclusion = Type: <b>KNOWNFOLDERID const*</b> Pointer to an array of KNOWNFOLDERID values that refer to subfolders of
    ///                 <i>rfid</i> that should be excluded from the redirection. If no subfolders are excluded, this value can be
    ///                 <b>NULL</b>.
    ///    ppszError = Type: <b>LPWSTR*</b> When this method returns, contains the address of a pointer to a null-terminated Unicode
    ///                string that contains an error message if one was generated. This value can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Among other things, this value can indicate that
    ///    the <i>rfid</i> parameter references a KNOWNFOLDERID that is not present on the system. Not all
    ///    <b>KNOWNFOLDERID</b> values are present on all systems. Use IKnownFolderManager::GetFolderIds to retrieve the
    ///    set of <b>KNOWNFOLDERID</b> values for the current system. </td> </tr> </table>
    ///    
    HRESULT Redirect(const(GUID)* rfid, HWND hwnd, uint flags, const(wchar)* pszTargetPath, uint cFolders, 
                     char* pExclusion, ushort** ppszError);
}

///Exposes methods that set and retrieve information about a computer's default sharing settings for the <b>Users</b>
///(<code>C:\Users</code>) or <b>Public</b> (<code>C:\Users\Public</code>) folder. Also exposes a set of methods that
///allow control of printer sharing.
@GUID("B4CD448A-9C86-4466-9201-2E62105B87AE")
interface ISharingConfigurationManager : IUnknown
{
    ///Shares the <b>Users</b> or <b>Public</b> folder. If the folder is already shared, this method updates its sharing
    ///status.
    ///Params:
    ///    dsid = Type: <b>DEF_SHARE_ID</b> One of the DEF_SHARE_ID values that indicates the folder to share or update.
    ///    role = Type: <b>SHARE_ROLE</b> One of the following SHARE_ROLE values that sets the access permissions of the share
    ///           for the <i>Everyone</i> ACE. <b>CreateShare</b> accepts only these values.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>role</i> parameter specifies a value other
    ///    than SHARE_ROLE_READER or SHARE_ROLE_CO_OWNER. </td> </tr> </table>
    ///    
    HRESULT CreateShare(DEF_SHARE_ID dsid, SHARE_ROLE role);
    ///Removes sharing from either the <b>Users</b> or <b>Public</b> folder.
    ///Params:
    ///    dsid = Type: <b>DEF_SHARE_ID</b> One of the DEF_SHARE_ID values that specifies the folder to no longer share.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DeleteShare(DEF_SHARE_ID dsid);
    ///Queries whether the <b>Users</b> or <b>Public</b> folder is shared.
    ///Params:
    ///    dsid = Type: <b>DEF_SHARE_ID</b> One of the DEF_SHARE_ID values that indicates the folder whose sharing state is
    ///           being checked.
    ///Returns:
    ///    Type: <b>HRESULT</b> S_OK if the folder is shared; otherwise, S_FALSE.
    ///    
    HRESULT ShareExists(DEF_SHARE_ID dsid);
    ///Gets the access permissions currently associated with the <b>User</b> or <b>Public</b> folder for the
    ///<i>Everyone</i> access control entry (ACE).
    ///Params:
    ///    dsid = Type: <b>DEF_SHARE_ID</b> One of the DEF_SHARE_ID values that specifies the folder.
    ///    pRole = Type: <b>SHARE_ROLE*</b> A pointer to a value that, when this method returns successfully, receives one of
    ///            the SHARE_ROLE values that indicate the sharing permissions set for the folder specified in the <i>dsid</i>
    ///            parameter.
    HRESULT GetSharePermissions(DEF_SHARE_ID dsid, SHARE_ROLE* pRole);
    ///Shares all local printers connected to a computer, enabling them to be discovered by other computers on the
    ///network.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SharePrinters();
    ///Stops sharing all local, shared printers connected to a computer.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StopSharingPrinters();
    ///Determines whether any printers connected to this computer are shared.
    HRESULT ArePrintersShared();
}

///Exposes methods that derive related items with specific relationships.
@GUID("A73CE67A-8AB1-44F1-8D43-D2FCBF6B1CD0")
interface IRelatedItem : IUnknown
{
    ///Gets the pointer to an item identifier list (PIDL) for the item that is related.
    ///Params:
    ///    ppidl = Type: <b>PIDLIST_ABSOLUTE*</b> When this method returns, contains the PIDL.
    HRESULT GetItemIDList(ITEMIDLIST** ppidl);
    ///Gets the IShellItem that is related to this item.
    ///Params:
    ///    ppsi = Type: <b>IShellItem**</b> When this method returns, contains the address of a pointer to the IShellItem
    ///           interface for the item that is related to this item.
    HRESULT GetItem(IShellItem* ppsi);
}

///Exposes methods to compare two items to see if they are the same.
@GUID("7D903FCA-D6F9-4810-8332-946C0177E247")
interface IIdentityName : IRelatedItem
{
}

///Used to obtain the immediately underlying representation of an item's path.
@GUID("3C5A1C94-C951-4CB7-BB6D-3B93F30CCE93")
interface IDelegateItem : IRelatedItem
{
}

///Obtained by calling IShellFolder::BindToObject for an item. If the item represents a snapshot of an item at a
///previous time, this interface will obtain the current version of the item.
@GUID("240A7174-D653-4A1D-A6D3-D4943CFBFE3D")
interface ICurrentItem : IRelatedItem
{
}

///Used by a copy engine to get the item on which to call QueryInterface to return a pointer to interface
///ITransferDestination or interface ITransferSource. These interfaces can be queried and enumerated for copy, move, or
///delete operations.
@GUID("77F295D5-2D6F-4E19-B8AE-322F3E721AB5")
interface ITransferMediumItem : IRelatedItem
{
}

///Exposes methods that find a version of the current item to be used to get display properties, such as the item name,
///that will be displayed in the UI. Used by the copy engine dialogs to provide the UI with an appropriate item to
///display. If no other version can be found, the current item is used.
@GUID("C6FD5997-9F6B-4888-8703-94E80E8CDE3F")
interface IDisplayItem : IRelatedItem
{
}

///Provides a canonical persistence item, an item for which view customizations will be remembered.
@GUID("9D264146-A94F-4195-9F9F-3BB12CE0C955")
interface IViewStateIdentityItem : IRelatedItem
{
}

///Identifies an item that will be shown in the preview pane.
@GUID("36149969-0A8F-49C8-8B00-4AECB20222FB")
interface IPreviewItem : IRelatedItem
{
}

///Exposes a method for manually copying a stream or file before applying changes to properties.
@GUID("8A87781B-39A7-4A1F-AAB3-A39B9C34A7D9")
interface IDestinationStreamFactory : IUnknown
{
    ///Gets an empty stream that receives the new version of the file being copied.
    ///Params:
    ///    ppstm = Type: <b>IStream**</b> The address of a pointer to the new stream.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDestinationStream(IStream* ppstm);
}

///Used by the ICreatingProcess interface to alter some parameters of the process that is being created.
@GUID("F6EF6140-E26F-4D82-BAC4-E9BA5FD239A8")
interface ICreateProcessInputs : IUnknown
{
    ///Gets the additional flags that will be passed to CreateProcess.
    ///Params:
    ///    pdwCreationFlags = A pointer to a <b>DWORD</b> which receives the flags that will be passed as the <i>dwCreationFlags</i>
    ///                       parameter to CreateProcess.
    ///Returns:
    ///    <b> S_OK</b> if the method succeeds. Otherwise, an <b>HRESULT</b> error code.
    ///    
    HRESULT GetCreateFlags(uint* pdwCreationFlags);
    ///Set the flags that will be included in the call to CreateProcess.
    ///Params:
    ///    dwCreationFlags = The flags that will be passed to the <i>dwCreationFlags</i> parameter to CreateProcess.
    ///Returns:
    ///    <b> S_OK</b> if the method succeeds. Otherwise, an <b>HRESULT</b> error code.
    ///    
    HRESULT SetCreateFlags(uint dwCreationFlags);
    ///Set additional flags that will be included in the call to CreateProcess.
    ///Params:
    ///    dwCreationFlags = The flags that will be included in the <i>dwCreationFlags</i> parameter passed to CreateProcess.
    ///Returns:
    ///    <b> S_OK</b> if the method succeeds. Otherwise, an <b>HRESULT</b> error code.
    ///    
    HRESULT AddCreateFlags(uint dwCreationFlags);
    ///Sets the hot key for the application.
    ///Params:
    ///    wHotKey = The hotkey to assign to the application. See the documentation of the <b>hStdIn</b> member of the STARTUPINFO
    ///              structure for more information.
    ///Returns:
    ///    <b> S_OK</b> if the method succeeds. Otherwise, an <b>HRESULT</b> error code.
    ///    
    HRESULT SetHotKey(ushort wHotKey);
    ///Additional flags that will be included in the STARTUPINFO structure passed to CreateProcess.
    ///Params:
    ///    dwStartupInfoFlags = The flags that will be included in the <i>dwFlags</i> member of the STARTUPINFO structure passed to
    ///                         CreateProcess.
    ///Returns:
    ///    <b> S_OK</b> if the method succeeds. Otherwise, an <b>HRESULT</b> error code.
    ///    
    HRESULT AddStartupFlags(uint dwStartupInfoFlags);
    ///Sets the title that will be passed CreateProcess.
    ///Params:
    ///    pszTitle = A null-terminated string specifying the title that will be passed in the <b>lpTitle</b> member of the
    ///               STARTUPINFO structure passed to CreateProcess. This parameter may not be <b>NULL</b>.
    ///Returns:
    ///    <b> S_OK</b> if the method succeeds. Otherwise, an <b>HRESULT</b> error code.
    ///    
    HRESULT SetTitle(const(wchar)* pszTitle);
    HRESULT SetEnvironmentVariableA(const(wchar)* pszName, const(wchar)* pszValue);
}

///Used by ShellExecuteEx and IContextMenu to allow the caller to alter some parameters of the process being created.
@GUID("C2B937A9-3110-4398-8A56-F34C6342D244")
interface ICreatingProcess : IUnknown
{
    ///Allows you to modify the parameters of the process being created.
    ///Params:
    ///    pcpi = A pointer to an ICreateProcessInputs interface which allows you to set some parameters for the process that
    ///           is being created.
    ///Returns:
    ///    <b> S_OK</b> if the method succeeds. Otherwise, an <b>HRESULT</b> error code, and the process is not created.
    ///    
    HRESULT OnCreating(ICreateProcessInputs pcpi);
}

@GUID("1791E8F6-21C7-4340-882A-A6A93E3FD73B")
interface ILaunchUIContext : IUnknown
{
    HRESULT SetAssociatedWindow(HWND value);
    HRESULT SetTabGroupingPreference(uint value);
}

@GUID("0D12C4C8-A3D9-4E24-94C1-0E20C5A956C4")
interface ILaunchUIContextProvider : IUnknown
{
    HRESULT UpdateContext(ILaunchUIContext context);
}

///Exposes methods that allow manipulation of items in a Windows 7 menu.
@GUID("DCB07FDC-3BB5-451C-90BE-966644FED7B0")
interface INewMenuClient : IUnknown
{
    ///Allows the view to filter the items shown in the menu.
    ///Params:
    ///    pflags = Type: <b>NMCII_FLAGS*</b> Pointer to a value that, when this method returns successfully, contains one of the
    ///             following values:
    HRESULT IncludeItems(int* pflags);
    ///Selects or edits the specified item in the menu.
    ///Params:
    ///    pidlItem = Type: <b>PCIDLIST_ABSOLUTE</b>
    ///    flags = Type: <b>NMCSAEI_FLAGS</b>
    HRESULT SelectAndEditItem(ITEMIDLIST* pidlItem, int flags);
}

///Exposes a method that initializes a handler, such as a property handler, thumbnail handler, or preview handler, with
///a bind context.
@GUID("71C0D2BC-726D-45CC-A6C0-2E31C1DB2159")
interface IInitializeWithBindCtx : IUnknown
{
    ///Initializes a handler with a bind context.
    ///Params:
    ///    pbc = Type: <b>IBindCtx*</b> Pointer to the IBindCtx object.
    HRESULT Initialize(IBindCtx pbc);
}

///Exposed by a client to specify how to filter the enumeration of a Shell item by a server application.
@GUID("2659B475-EEB8-48B7-8F07-B378810F48CF")
interface IShellItemFilter : IUnknown
{
    ///Sets a given Shell item status to inclusion in the view.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the Shell item that is to be included in the view.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IncludeItem(IShellItem psi);
    ///Allows a client to specify which classes of objects in a Shell item should be enumerated for inclusion in the
    ///view.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the Shell item for which the SHCONTF enum flags are to be retrieved.
    ///    pgrfFlags = Type: <b>SHCONTF*</b> A pointer to the SHCONTF enum flags for the given Shell item that specifies which
    ///                classes of objects to enumerate for inclusion in the view.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEnumFlagsForItem(IShellItem psi, uint* pgrfFlags);
}

///Exposes methods used to view and manipulate nodes in a tree of Shell items.
@GUID("028212A3-B627-47E9-8856-C14265554E4F")
interface INameSpaceTreeControl : IUnknown
{
    ///Initializes an INameSpaceTreeControl object.
    ///Params:
    ///    hwndParent = Type: <b>HWND</b> The handle of the parent window.
    ///    prc = Type: <b>RECT*</b> A pointer to a RECT structure that describes the size and position of the control in the
    ///          client window.
    ///    nsctsFlags = Type: <b>NSTCSTYLE</b> The characteristics of the given namespace tree control. One or more of the following
    ///                 values from the NSTCSTYLE enumeration.
    HRESULT Initialize(HWND hwndParent, RECT* prc, uint nsctsFlags);
    ///Enables a client to register with the control.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to the client IUnknown that registers with the control.
    ///    pdwCookie = Type: <b>DWORD*</b> A pointer to the cookie that is passed back for registration.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT TreeAdvise(IUnknown punk, uint* pdwCookie);
    ///Enables a client to unregister with the control.
    ///Params:
    ///    dwCookie = Type: <b>DWORD*</b> A pointer to the cookie that is to be unregistered.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT TreeUnadvise(uint dwCookie);
    ///Appends a Shell item to the list of roots in a tree.
    ///Params:
    ///    psiRoot = Type: <b>IShellItem*</b> Pointer to the Shell item that is being appended.
    ///    grfEnumFlags = Type: <b>SHCONTF</b> Enumerates the qualities of the root and all of its children. One or more of the values
    ///                   of type SHCONTF. These flags can be combined using a bitwise OR.
    ///    grfRootStyle = Type: <b>NSTCROOTSTYLE</b> Specifies the style of the root that is being appended. One or more of the
    ///                   following values:
    ///    pif = Type: <b>IShellItemFilter*</b> Pointer to the IShellItemFilter that enables you to filter which items in the
    ///          tree are displayed. If supplied, every item is customizable with a SHCONTF flag. This value can be
    ///          <b>NULL</b> if no filter is required.
    HRESULT AppendRoot(IShellItem psiRoot, uint grfEnumFlags, uint grfRootStyle, IShellItemFilter pif);
    ///Inserts a Shell item on a root item in a tree.
    ///Params:
    ///    iIndex = Type: <b>int</b> The index at which to insert the root.
    ///    psiRoot = Type: <b>IShellItem*</b> A pointer to the Shell item that is being inserted.
    ///    grfEnumFlags = Type: <b>SHCONTF</b> Enumerates the qualities of the root and all of its children. One of the values of type
    ///                   SHCONTF.
    ///    grfRootStyle = Type: <b>NSTCROOTSTYLE</b> The style of the root that is being inserted. One or more of the following values
    ///                   (flags can be combined using a bitwise OR).
    ///    pif = Type: <b>IShellItemFilter*</b> A pointer to the IShellItemFilter that enables you to filter which items in
    ///          the tree are displayed. If supplied, every item is customizable with a SHCONTF flag. This value can be
    ///          <b>NULL</b> if no filter is required.
    HRESULT InsertRoot(int iIndex, IShellItem psiRoot, uint grfEnumFlags, uint grfRootStyle, IShellItemFilter pif);
    ///Removes a root and its children from a tree.
    ///Params:
    ///    psiRoot = Type: <b>IShellItem*</b> A pointer to the root that is to be removed.
    HRESULT RemoveRoot(IShellItem psiRoot);
    ///Removes all roots and their children from a tree.
    HRESULT RemoveAllRoots();
    ///Gets an array of the root items.
    ///Params:
    ///    ppsiaRootItems = Type: <b>IShellItemArray**</b> A pointer to an array of root items.
    HRESULT GetRootItems(IShellItemArray* ppsiaRootItems);
    ///Sets state information for a Shell item.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the Shell item for which to set the state.
    ///    nstcisMask = Type: <b>NSTCITEMSTATE</b> Specifies which information is being set, in the form of a bitmap. One or more of
    ///                 the NSTCITEMSTATE constants.
    ///    nstcisFlags = Type: <b>NSTCITEMSTATE</b> A bitmap that contains the values to set for the flags specified in
    ///                  <i>nstcisMask</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetItemState(IShellItem psi, uint nstcisMask, uint nstcisFlags);
    ///Gets state information about a Shell item.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the Shell item from which to retrieve the state.
    ///    nstcisMask = Type: <b>NSTCITEMSTATE</b> Specifies which information is being requested, in the form of a bitmap. One or
    ///                 more of the NSTCITEMSTATE constants.
    ///    pnstcisFlags = Type: <b>NSTCITEMSTATE*</b> When this method returns, points to a bitmap that contains the values requested
    ///                   in <i>nstcisMask</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetItemState(IShellItem psi, uint nstcisMask, uint* pnstcisFlags);
    ///Gets an array of selected Shell items.
    ///Params:
    ///    psiaItems = Type: <b>IShellItemArray**</b> A pointer to an array of selected Shell items.
    HRESULT GetSelectedItems(IShellItemArray* psiaItems);
    ///Gets the state of the checkbox associated with a given Shell item.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the Shell item for which checkbox state is being retrieved.
    ///    piStateNumber = Type: <b>int*</b> A pointer to the state of the checkbox for the Shell item.
    HRESULT GetItemCustomState(IShellItem psi, int* piStateNumber);
    ///Sets the state of the checkbox associated with the Shell item.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the Shell item for which checkbox state is being set.
    ///    iStateNumber = Type: <b>int</b> The desired state of the checkbox for the Shell item.
    HRESULT SetItemCustomState(IShellItem psi, int iStateNumber);
    ///Ensures that the given item is visible.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the Shell item for which the visibility is being ensured.
    HRESULT EnsureItemVisible(IShellItem psi);
    ///Sets the desktop theme for the current window only.
    ///Params:
    ///    pszTheme = Type: <b>LPCWSTR</b> The name of the desktop theme to which the current window is being set.
    HRESULT SetTheme(const(wchar)* pszTheme);
    ///Retrieves the next item in the tree according to which method is requested.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> The Shell item for which the next item is being retrieved. This value can be
    ///          <b>NULL</b>.
    ///    nstcgi = Type: <b>NSTCGNI</b> The type of the next item. This value can be one of the following flags:
    ///    ppsiNext = Type: <b>IShellItem**</b> The address of a pointer to the IShellItem that fits the criteria for the next item
    ///               that was requested.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetNextItem(IShellItem psi, NSTCGNI nstcgi, IShellItem* ppsiNext);
    ///Retrieves the item that a given point is in, if any.
    ///Params:
    ///    ppt = Type: <b>POINT*</b> A pointer to the point to be tested.
    ///    ppsiOut = Type: <b>IShellItem**</b> The address of a pointer to the item in which the point exists, or <b>NULL</b> if
    ///              the point does not exist in an item.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT HitTest(POINT* ppt, IShellItem* ppsiOut);
    ///Gets the RECT structure that describes the size and position of a given item.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the item for which the RECT structure is being retrieved.
    ///    prect = Type: <b>RECT*</b> A pointer to the RECT structure that describes the size and position of the item.
    HRESULT GetItemRect(IShellItem psi, RECT* prect);
    ///Collapses all of the items in the given tree.
    HRESULT CollapseAll();
}

///Exposes a single method that retrieves the status of a folder's System.IsPinnedToNameSpaceTree filtering support.
@GUID("E9701183-E6B3-4FF2-8568-813615FEC7BE")
interface INameSpaceTreeControlFolderCapabilities : IUnknown
{
    ///Gets a folder's capability to be filtered through the System.IsPinnedToNameSpaceTree property key value and
    ///change notification registration status.
    ///Params:
    ///    nfcMask = Type: <b>NSTCFOLDERCAPABILITIES</b> The capabilities for which this method should retrieve values. Specify
    ///              one or both of the following:
    ///    pnfcValue = Type: <b>NSTCFOLDERCAPABILITIES*</b> Pointer to a value that, when this method returns successfully, receives
    ///                the capabilities requested in <i>nfcMask</i>. Except in the case of NSTCFC_NONE, bit values in positions not
    ///                specifically requested in <i>nfcMask</i> do not necessarily reflect the capabilities and should not be used.
    HRESULT GetFolderCapabilities(NSTCFOLDERCAPABILITIES nfcMask, NSTCFOLDERCAPABILITIES* pnfcValue);
}

///Exposes methods for the display of rich previews.
@GUID("8895B1C6-B41F-4C1C-A562-0D564250836F")
interface IPreviewHandler : IUnknown
{
    ///Sets the parent window of the previewer window, as well as the area within the parent to be used for the
    ///previewer window.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> A handle to the parent window.
    ///    prc = Type: <b>const RECT*</b> A pointer to a <b>RECT</b> defining the area for the previewer.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetWindow(HWND hwnd, const(RECT)* prc);
    ///Directs the preview handler to change the area within the parent hwnd that it draws into.
    ///Params:
    ///    prc = Type: <b>const RECT*</b> A pointer to a <b>RECT</b> to be used for the preview.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRect(const(RECT)* prc);
    ///Directs the preview handler to load data from the source specified in an earlier Initialize method call, and to
    ///begin rendering to the previewer window.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    operation completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_PREVIEWHANDLER_DRM_FAIL</b></dt> </dl> </td> <td width="60%"> Blocked by digital rights management.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PREVIEWHANDLER_NOAUTH</b></dt> </dl> </td> <td width="60%">
    ///    Blocked by file permissions. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PREVIEWHANDLER_NOTFOUND</b></dt>
    ///    </dl> </td> <td width="60%"> Item was not found. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_PREVIEWHANDLER_CORRUPT</b></dt> </dl> </td> <td width="60%"> Item was corrupt. </td> </tr> </table>
    ///    
    HRESULT DoPreview();
    ///Directs the preview handler to cease rendering a preview and to release all resources that have been allocated
    ///based on the item passed in during the initialization.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Unload();
    ///Directs the preview handler to set focus to itself.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetFocus();
    ///Directs the preview handler to return the <b>HWND</b> from calling the GetFocus Function.
    ///Params:
    ///    phwnd = Type: <b>HWND*</b> When this method returns, contains a pointer to the HWND returned from calling the
    ///            GetFocus Function from the preview handler's foreground thread.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT QueryFocus(HWND* phwnd);
    HRESULT TranslateAcceleratorA(MSG* pmsg);
}

///Enables preview handlers to pass keyboard shortcuts to the host. This interface retrieves a list of keyboard
///shortcuts and directs the host to handle a keyboard shortcut.
@GUID("FEC87AAF-35F9-447A-ADB7-20234491401A")
interface IPreviewHandlerFrame : IUnknown
{
    ///Gets a list of the keyboard shortcuts for the preview host.
    ///Params:
    ///    pinfo = Type: <b>PREVIEWHANDLERFRAMEINFO*</b> A pointer to a PREVIEWHANDLERFRAMEINFO structure that receives
    ///            accelerator table information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetWindowContext(PREVIEWHANDLERFRAMEINFO* pinfo);
    HRESULT TranslateAcceleratorA(MSG* pmsg);
}

///Used in Windows Explorer by an IShellFolder implementation to give suggestions to the view about what panes are
///visible. Additionally, an IExplorerBrowser host can use this interface to provide information about pane visibility.
///The host should implement QueryService with <b>SID_ExplorerPaneVisibility</b> as the service ID. The host must be in
///the site chain. The <b>IExplorerPaneVisibility</b> implementation is retrieved from the Shell folder. The Shell
///folder, in turn, is retrieved from the view. A namespace extension can elect to provide a custom view (IShellView)
///rather than using the system folder view object (DefView). In that case, the <b>IShellView</b> implementation must
///include an implementation of IFolderView::GetFolder to return the <b>IExplorerPaneVisibility</b> object. A namespace
///extension can provide a custom view by implementing IShellView itself rather than using the system folder view object
///(DefView). In that case, the <b>IShellView</b> implementation must include an implementation of
///IFolderView::GetFolder to make use of <b>IExplorerPaneVisibility</b> .
@GUID("E07010EC-BC17-44C0-97B0-46C7C95B9EDC")
interface IExplorerPaneVisibility : IUnknown
{
    ///Gets the visibility state of the given Windows Explorer pane.
    ///Params:
    ///    ep = Type: <b>REFEXPLORERPANE</b> A reference to a GUID that uniquely identifies a Windows Explorer pane. One of
    ///         the following constants as defined in Shlguid.h.
    ///    peps = Type: <b>EXPLORERPANESTATE*</b> When this method returns, contains the visibility state of the given Windows
    ///           Explorer pane as one of the EXPLORERPANESTATE constants.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPaneState(const(GUID)* ep, uint* peps);
}

///Exposes a method that enables the callback of a context menu. For example, to add a shield icon to a <b>menuItem</b>
///that requires elevation.
@GUID("3409E930-5A39-11D1-83FA-00A0C90DC849")
interface IContextMenuCB : IUnknown
{
    ///Enables the callback function for a context menu.
    ///Params:
    ///    psf = Type: <b>IShellFolder*</b> A pointer to the IShellFolder interface of the object that supports the
    ///          <b>IContextMenuCB::CallBack</b> interface. The context menu interface is returned on a call to GetUIObjectOf.
    ///    hwndOwner = Type: <b>HWND</b> A handle to the owner of the context menu. This value can be <b>NULL</b>.
    ///    pdtobj = Type: <b>IDataObject*</b> A pointer to an IDataObject that contains information about a menu selection.
    ///             Implement interface <b>IDataObject</b>, or call SHCreateDataObject for the default implementation.
    ///    uMsg = Type: <b>UINT</b> A notification from the Shell's default menu implementation. For example, the default menu
    ///           implementation calls DFM_MERGECONTEXTMENU to allow the implementer of <b>IContextMenuCB::CallBack</b> to
    ///           remove, add, or disable context menu items in this callback. Use one of the following notifications. <table
    ///           class="clsStd"> <tr> <td> DFM_MERGECONTEXTMENU </td> </tr> <tr> <td> DFM_INVOKECOMMAND </td> </tr> <tr> <td>
    ///           DFM_GETHELPTEXT </td> </tr> <tr> <td> DFM_GETHELPTEXTW </td> </tr> <tr> <td> DFM_WM_MEASUREITEM </td> </tr>
    ///           <tr> <td> DFM_WM_DRAWITEM </td> </tr> <tr> <td> DFM_WM_INITMENUPOPUP </td> </tr> <tr> <td> DFM_VALIDATECMD
    ///           </td> </tr> <tr> <td> DFM_INVOKECOMMANDEX </td> </tr> <tr> <td> DFM_MAPCOMMANDNAME </td> </tr> <tr> <td>
    ///           DFM_GETDEFSTATICID </td> </tr> <tr> <td> DFM_GETVERB </td> </tr> <tr> <td> DFM_MERGECONTEXTMENU_BOTTOM </td>
    ///           </tr> </table>
    ///    wParam = Type: <b>WPARAM</b> Data specific to the notification specified in <i>uMsg</i>. See the individual
    ///             notification page for specific requirements.
    ///    lParam = Type: <b>LPARAM</b> Data specific to the notification specified in <i>uMsg</i>. See the individual
    ///             notification page for specific requirements.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CallBack(IShellFolder psf, HWND hwndOwner, IDataObject pdtobj, uint uMsg, WPARAM wParam, LPARAM lParam);
}

///Exposes methods to set default icons associated with an object.
@GUID("41DED17D-D6B3-4261-997D-88C60E4B1D58")
interface IDefaultExtractIconInit : IUnknown
{
    ///Sets GIL_XXX flags. See GetIconLocation
    ///Params:
    ///    uFlags = Type: <b>UINT</b> Specifies return flags to get icon location.
    HRESULT SetFlags(uint uFlags);
    ///Sets the registry key from which to load the "DefaultIcon" value.
    ///Params:
    ///    hkey = Type: <b>HKEY</b> A handle to the registry key.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetKey(HKEY hkey);
    ///Sets the normal icon.
    ///Params:
    ///    pszFile = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the full icon path, including the file name and
    ///              extension, as a Unicode string. This pointer can be <b>NULL</b>.
    ///    iIcon = Type: <b>int</b> A Shell icon ID.
    HRESULT SetNormalIcon(const(wchar)* pszFile, int iIcon);
    ///Sets the icon that allows containers to specify an "open" look.
    ///Params:
    ///    pszFile = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the full icon path, including the file name and
    ///              extension, as a Unicode string. This pointer can be <b>NULL</b>.
    ///    iIcon = Type: <b>int</b> Shell icon ID.
    HRESULT SetOpenIcon(const(wchar)* pszFile, int iIcon);
    ///Sets the icon for a shortcut to the object.
    ///Params:
    ///    pszFile = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the full icon path, including the file name and
    ///              extension, as a Unicode string. This pointer can be <b>NULL</b>.
    ///    iIcon = Type: <b>int</b> Shell icon ID.
    HRESULT SetShortcutIcon(const(wchar)* pszFile, int iIcon);
    ///Sets the default icon.
    ///Params:
    ///    pszFile = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the full icon path, including the file name and
    ///              extension, as a Unicode string. This pointer can be <b>NULL</b>.
    ///    iIcon = Type: <b>int</b> The Shell icon ID.
    HRESULT SetDefaultIcon(const(wchar)* pszFile, int iIcon);
}

///Exposes methods that get the command appearance, enumerate subcommands, or invoke the command.
@GUID("A08CE4D0-FA25-44AB-B57C-C7B1C323E0B9")
interface IExplorerCommand : IUnknown
{
    ///Gets the title text of the button or menu item that launches a specified Windows Explorer command item.
    ///Params:
    ///    psiItemArray = Type: <b>IShellItemArray*</b> A pointer to an IShellItemArray.
    ///    ppszName = Type: <b>LPWSTR*</b> Pointer to a buffer that, when this method returns successfully, receives the title
    ///               string.
    HRESULT GetTitle(IShellItemArray psiItemArray, ushort** ppszName);
    ///Gets an icon resource string of the icon associated with the specified Windows Explorer command item.
    ///Params:
    ///    psiItemArray = Type: <b>IShellItemArray*</b> A pointer to an IShellItemArray.
    ///    ppszIcon = Type: <b>LPWSTR*</b> Pointer to a buffer that, when this method returns successfully, receives the resource
    ///               string that identifies the icon source.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetIcon(IShellItemArray psiItemArray, ushort** ppszIcon);
    ///Gets the tooltip string associated with a specified Windows Explorer command item.
    ///Params:
    ///    psiItemArray = Type: <b>IShellItemArray*</b> A pointer to an IShellItemArray.
    ///    ppszInfotip = Type: <b>LPWSTR*</b> Pointer to a buffer that, when this method returns successfully, receives the tooltip
    ///                  string.
    HRESULT GetToolTip(IShellItemArray psiItemArray, ushort** ppszInfotip);
    ///Gets the GUID of an Windows Explorer command.
    ///Params:
    ///    pguidCommandName = Type: <b>GUID*</b> A pointer to a value that, when this method returns successfully, receives the command's
    ///                       GUID, under which it is declared in the registry.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCanonicalName(GUID* pguidCommandName);
    ///Gets state information associated with a specified Windows Explorer command item.
    ///Params:
    ///    psiItemArray = Type: <b>IShellItemArray*</b> A pointer to an IShellItemArray.
    ///    fOkToBeSlow = Type: <b>BOOL</b> <b>FALSE</b> if a verb object should not perform any memory intensive computations that
    ///                  could cause the UI thread to stop responding. The verb object should return E_PENDING in that case. If
    ///                  <b>TRUE</b>, those computations can be completed.
    ///    pCmdState = Type: <b>EXPCMDSTATE*</b> A pointer to a value that, when this method returns successfully, receives one or
    ///                more Windows Explorer command states indicated by the EXPCMDSTATE constants.
    HRESULT GetState(IShellItemArray psiItemArray, BOOL fOkToBeSlow, uint* pCmdState);
    ///Invokes a Windows Explorer command.
    ///Params:
    ///    psiItemArray = Type: <b>IShellItemArray*</b> A pointer to an IShellItemArray.
    ///    pbc = Type: <b>IBindCtx*</b> A pointer to an IBindCtx interface, which provides access to a bind context. This
    ///          value can be <b>NULL</b> if no bind context is needed.
    HRESULT Invoke(IShellItemArray psiItemArray, IBindCtx pbc);
    ///Gets the flags associated with a Windows Explorer command.
    ///Params:
    ///    pFlags = Type: <b>EXPCMDFLAGS*</b> When this method returns, this value points to the current command flags. One of
    ///             more of the following values:
    HRESULT GetFlags(uint* pFlags);
    ///Retrieves an enemerator for a command's subcommands.
    ///Params:
    ///    ppEnum = Type: <b>IEnumExplorerCommand**</b> When this method returns successfully, contains an IEnumExplorerCommand
    ///             interface pointer that can be used to walk the set of subcommands.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnumSubCommands(IEnumExplorerCommand* ppEnum);
}

///Exposes a single method that allows retrieval of the command state.
@GUID("BDDACB60-7657-47AE-8445-D23E1ACF82AE")
interface IExplorerCommandState : IUnknown
{
    ///Gets the command state associated with a specified Shell item.
    ///Params:
    ///    psiItemArray = Type: <b>IShellItemArray*</b> A pointer to an IShellItemArray with a single element that represents the Shell
    ///                   item.
    ///    fOkToBeSlow = Type: <b>BOOL</b> <b>FALSE</b> if a verb object should not perform any memory intensive computations that
    ///                  could cause the UI thread to stop responding. The verb object should return E_PENDING in that case. If
    ///                  <b>TRUE</b>, those computations can be completed.
    ///    pCmdState = Type: <b>EXPCMDSTATE*</b> A pointer to a value that, when this method returns successfully, receives one or
    ///                more Windows Explorer command states indicated by the EXPCMDSTATE constants.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetState(IShellItemArray psiItemArray, BOOL fOkToBeSlow, uint* pCmdState);
}

///Exposes a single method used to initialize objects that implement IExplorerCommandState, IExecuteCommand or
///IDropTarget with the application-specified command name and its registered properties.
@GUID("85075ACF-231F-40EA-9610-D26B7B58F638")
interface IInitializeCommand : IUnknown
{
    ///Initialize objects that share an implementation of IExplorerCommandState, IExecuteCommand or IDropTarget with the
    ///application-specified command name and its registered properties.
    ///Params:
    ///    pszCommandName = Type: <b>LPCWSTR</b> Pointer to a string that contains the command name (the name of the command key as found
    ///                     in the registry). For instance, if the command is registered under <b>...</b>&
    ///    ppb = Type: <b>IPropertyBag*</b> Pointer to an IPropertyBag instance that can be used to read the properties
    ///          related to the command in the registry. For example, a command may registry a string property under its
    ///          <b>...</b>&
    HRESULT Initialize(const(wchar)* pszCommandName, IPropertyBag ppb);
}

///Provided by an IExplorerCommandProvider. This interface contains the enumeration of commands to be put into the
///command bar.
@GUID("A88826F8-186F-4987-AADE-EA0CEF8FBFE8")
interface IEnumExplorerCommand : IUnknown
{
    ///Retrieves a specified number of elements that directly follow the current element.
    ///Params:
    ///    celt = Type: <b>ULONG</b> Specifies the number of elements to fetch.
    ///    pUICommand = Type: <b>IExplorerCommand**</b> Address of an IExplorerCommand interface pointer array of <i>celt</i>
    ///                 elements that, when this method returns, is an array of pointers to the retrieved elements.
    ///    pceltFetched = Type: <b>ULONG*</b> When this method returns, contains a pointer to the number of elements actually
    ///                   retrieved. This pointer can be <b>NULL</b> if this information is not needed.
    HRESULT Next(uint celt, char* pUICommand, uint* pceltFetched);
    ///Not currently implemented.
    ///Params:
    ///    celt = Type: <b>ULONG</b> Currently unused.
    HRESULT Skip(uint celt);
    ///Resets the enumeration to 0.
    HRESULT Reset();
    ///Not currently implemented.
    ///Params:
    ///    ppenum = Type: <b>IEnumExplorerCommand**</b> Currently unused.
    HRESULT Clone(IEnumExplorerCommand* ppenum);
}

///Exposes methods to create Explorer commands and command enumerators.
@GUID("64961751-0835-43C0-8FFE-D57686530E64")
interface IExplorerCommandProvider : IUnknown
{
    ///Gets a specified Explorer command enumerator instance.
    ///Params:
    ///    punkSite = Type: <b>IUnknown*</b> A pointer to an interface used to set a site.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the requested interface.
    ///    ppv = Type: <b>void**</b> When this function returns, contains the interface pointer requested in riid. This will
    ///          typically be IEnumExplorerCommand.
    HRESULT GetCommands(IUnknown punkSite, const(GUID)* riid, void** ppv);
    ///Gets a specified Explorer command instance.
    ///Params:
    ///    rguidCommandId = Type: <b>REFGUID</b> A reference to a command ID as a <b>GUID</b>. Used to obtain a command definition.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the requested interface.
    ///    ppv = Type: <b>void**</b> When this function returns, contains the interface pointer requested in riid. This will
    ///          typically be IExplorerCommand.
    HRESULT GetCommand(const(GUID)* rguidCommandId, const(GUID)* riid, void** ppv);
}

///Exposes methods that retrieve the view state of the Control Panel, the path of individual Control Panel items, and
///that open either the Control Panel itself or an individual Control Panel item.
@GUID("D11AD862-66DE-4DF4-BF6C-1F5621996AF1")
interface IOpenControlPanel : IUnknown
{
    ///Opens the specified Control Panel item, optionally to a specific page.
    ///Params:
    ///    pszName = Type: <b>LPCWSTR</b> A pointer to the item's canonical name as a Unicode string. This parameter is optional
    ///              and can be <b>NULL</b>. If the calling application passes <b>NULL</b>, then the Control Panel itself opens.
    ///              For a complete list of Control Panel item canonical names, see Canonical Names of Control Panel Items.
    ///    pszPage = Type: <b>LPCWSTR</b> A pointer to the name of the page within the item to display. This string is appended to
    ///              the end of the path for Shell folder Control Panel items or appended as a command-line parameter for Control
    ///              Panel (.cpl) file items. This parameter can be <b>NULL</b>, in which case the first page is shown.
    ///    punkSite = Type: <b>IUnknown*</b> A pointer to the site for navigating in-frame for Shell folder Control Panel items.
    ///               This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Open(const(wchar)* pszName, const(wchar)* pszPage, IUnknown punkSite);
    ///Gets the path of a specified Control Panel item.
    ///Params:
    ///    pszName = Type: <b>LPCWSTR</b> A pointer to the item's canonical name or its <b>GUID</b>. This value can be
    ///              <b>NULL</b>. See Remarks for further details. For a complete list of Control Panel item canonical names, see
    ///              Canonical Names of Control Panel Items.
    ///    pszPath = Type: <b>LPWSTR</b> When this method returns, contains the path of the specified Control Panel item as a
    ///              Unicode string.
    ///    cchPath = Type: <b>UINT</b> The size of the buffer pointed to by <i>pszPath</i>, in WCHARs.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPath(const(wchar)* pszName, const(wchar)* pszPath, uint cchPath);
    ///Gets the most recent Control Panel view: Classic view or Category view.
    ///Params:
    ///    pView = Type: <b>CPVIEW*</b> A pointer that receives the most recent view. Valid values are as follows:
    HRESULT GetCurrentView(CPVIEW* pView);
}

///Exposes methods that store file system information for optimizing calls to IShellFolder::ParseDisplayName.
@GUID("01E18D10-4D8B-11D2-855D-006008059367")
interface IFileSystemBindData : IUnknown
{
    ///Stores file system information in a WIN32_FIND_DATA structure. This information is used by ParseDisplayName.
    ///Params:
    ///    pfd = Type: <b>const WIN32_FIND_DATA*</b> A pointer to the WIN32_FIND_DATA structure that specifies the data you
    ///          want to store.
    ///Returns:
    ///    Type: <b>HRESULT</b> Always returns <b>S_OK</b>.
    ///    
    HRESULT SetFindData(const(WIN32_FIND_DATAW)* pfd);
    ///Gets the file system information stored in the WIN32_FIND_DATA structure.
    ///Params:
    ///    pfd = Type: <b>WIN32_FIND_DATA*</b> A pointer to the WIN32_FIND_DATA structure that receives the data.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK.
    ///    
    HRESULT GetFindData(WIN32_FIND_DATAW* pfd);
}

///Extends IFileSystemBindData, which stores file system information for optimizing calls to
///IShellFolder::ParseDisplayName. This interface adds the ability set or get file ID or junction class identifier
///(CLSID).
@GUID("3ACF075F-71DB-4AFA-81F0-3FC4FDF2A5B8")
interface IFileSystemBindData2 : IFileSystemBindData
{
    ///Sets the unique file identifier for the current file.
    ///Params:
    ///    liFileID = Type: <b>LARGE_INTEGER</b> A unique file identifier for the current file. <i>liFileID</i> is a value that is
    ///               a concatenation of the values <i>nFileIndexHigh</i> and <i>nFileIndexlow</i>, noted in structure
    ///               _by_handle_file_information.
    HRESULT SetFileID(LARGE_INTEGER liFileID);
    ///Gets the unique file identifier for the current file.
    ///Params:
    ///    pliFileID = Type: <b>LARGE_INTEGER*</b> When this method returns successfully, receives a pointer to the unique file
    ///                identifier for the current file. <i>pliFileID</i> is a pointer to a value that is a concatenation of the
    ///                values <i>nFileIndexHigh</i> and <i>nFileIndexlow</i>, noted in structure _by_handle_file_information.
    HRESULT GetFileID(LARGE_INTEGER* pliFileID);
    ///Sets the class identifier (CLSID) of the object that implements IShellFolder, if the current item is a junction
    ///point.
    ///Params:
    ///    clsid = Type: <b>REFCLSID</b> The CLSID for the object that implements IShellFolder with a junction point as its
    ///            current item.
    HRESULT SetJunctionCLSID(const(GUID)* clsid);
    ///Gets the class identifier (CLSID) of the object that implements IShellFolder for the item, if the item is a
    ///junction point.
    ///Params:
    ///    pclsid = Type: <b>CLSID*</b> When this method returns successfully, receives a pointer to the CLSID of the object that
    ///             implements IShellFolder for the current item, if the item is a junction point.
    HRESULT GetJunctionCLSID(GUID* pclsid);
}

///Exposes methods that allow an application to provide a custom Jump List, including destinations and tasks, for
///display in the taskbar.
@GUID("6332DEBF-87B5-4670-90C0-5E57B408A49E")
interface ICustomDestinationList : IUnknown
{
    ///Specifies a unique Application User Model ID (AppUserModelID) for the application whose taskbar button will hold
    ///the custom Jump List built through the methods of this interface. This method is optional.
    ///Params:
    ///    pszAppID = Type: <b>LPCWSTR</b> A pointer to the AppUserModelID of the process or application whose taskbar
    ///               representation receives the Jump List.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> This method was called after
    ///    ICustomDestinationList::BeginList. The list-building process is already running with a particular
    ///    AppUserModelID, either inferred by the system or set through a call to SetAppID before the call to
    ///    <b>BeginList</b>. After a list-building operation is in progress, the AppUserModelID cannot be changed until
    ///    after CommitList or AbortList has been called. </td> </tr> </table>
    ///    
    HRESULT SetAppID(const(wchar)* pszAppID);
    ///Initiates a building session for a custom Jump List.
    ///Params:
    ///    pcMinSlots = Type: <b>UINT*</b> A pointer that, when this method returns, points to the current user setting for the
    ///                 <b>Number of recent items to display in Jump Lists</b> option in the <b>Taskbar and Start Menu Properties</b>
    ///                 window. The default value is 10. This is the maximum number of destinations that will be shown, and it is a
    ///                 total of all destinations, regardless of category. More destinations can be added, but they will not be shown
    ///                 in the UI. A Jump List will always show at least this many slots—destinations and, if there is room, tasks.
    ///                 This number does not include separators and section headers as long as the total number of separators and
    ///                 headers does not exceed four. Separators and section headers beyond the first four might reduce the number of
    ///                 destinations displayed if space is constrained. This number does not affect the standard command entries for
    ///                 pinning or unpinning, closing the window, or launching a new instance. It also does not affect tasks or
    ///                 pinned items, the number of which that can be displayed is based on the space available to the Jump List.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of an interface to be retrieved in <i>ppv</i>, typically
    ///           IID_IObjectArray, that will represent all items currently stored in the list of removed destinations for the
    ///           application. This information is used to ensure that removed items are not part of the new Jump List.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This
    ///          is typically an IObjectArray, which represents a collection of IShellItem and IShellLink objects that
    ///          represent the removed items.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BeginList(uint* pcMinSlots, const(GUID)* riid, void** ppv);
    ///Defines a custom category and the destinations that it contains, for inclusion in a custom Jump List.
    ///Params:
    ///    pszCategory = Type: <b>LPCWSTR</b> A pointer to a string that contains the display name of the custom category. This string
    ///                  is shown in the category's header in the Jump List. The string can directly hold the display name or it can
    ///                  be an indirect string representation, such as "@shell32.dll,-1324", to use a stored string. An indirect
    ///                  string enables the category header to be displayed in the user's selected language. <div
    ///                  class="alert"><b>Note</b> Each custom category must have a unique name. Duplicate category names will cause
    ///                  presentation issues in the Jump List.</div> <div> </div>
    ///    poa = Type: <b>IObjectArray*</b> A pointer to an IObjectArray that represents one or more IShellItem objects that
    ///          represent the destinations in the category. Some destinations in the list might also be represented by
    ///          IShellLink objects, although less often. <div class="alert"><b>Note</b> Any IShellLink used here must declare
    ///          an argument list through SetArguments. Adding an <b>IShellLink</b> object with no arguments to a custom
    ///          category is not supported since a user cannot pin or unpin this type of item from a Jump List, nor can they
    ///          be added or removed.</div> <div> </div>
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. If the call to
    ///    <b>AppendCategory</b> attempts to add an item that is in the removed destinations list retrieved by the call
    ///    to BeginList that initiated the session, the call to <b>AppendCategory</b> fails. If <b>AppendCategory</b>
    ///    attempts to add an IShellItem that the application is not registered to handle, the call fails.
    ///    <b>AppendCategory</b> can fail if there is a privacy Group Policy or user privacy setting turned on. Custom
    ///    categories contain user-specific items based on individual usage, which is not allowed under those privacy
    ///    settings. A privacy Group Policy or user privacy setting will not cause a failure in any other
    ///    ICustomDestinationList method. Tasks are not user-specific. AppendKnownCategory will not result in the
    ///    display of the <b>Recent</b> or <b>Frequent</b> categories because they will have no data, but the method
    ///    call will not return a failure code. In the case of a failure code in <b>AppendCategory</b> caused by privacy
    ///    Group Policy or user privacy setting (E_ACCESSDENIED), the application should continue to update tasks and
    ///    call CommitList. If no file type registration was found for the associated application, <b>AppendCategory</b>
    ///    returns HRESULT 0x80040F03. This can result from an application not registering the file type it is trying to
    ///    add to the Jump List or from a problem in the registration, such as not providing the AppUserModelID when the
    ///    application is using an explicit AppUserModelID.
    ///    
    HRESULT AppendCategory(const(wchar)* pszCategory, IObjectArray poa);
    ///Specifies that the <b>Frequent</b> or <b>Recent</b> category should be included in a custom Jump List.
    ///Params:
    ///    category = Type: <b>KNOWNDESTCATEGORY</b> One of the following values that indicate which known category to add to the
    ///               list:
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. If there is a privacy Group
    ///    Policy or user privacy setting present, it can affect the result of this method. Categories that contain
    ///    user-specific items based on individual usage are not allowed under those privacy settings. Due to this, the
    ///    <b>Recent</b> or <b>Frequent</b> categories added through this method will have no data, and categories with
    ///    no data are not displayed. However, in that situation, this method call will not result in a failure code.
    ///    
    HRESULT AppendKnownCategory(KNOWNDESTCATEGORY category);
    ///Specifies items to include in the <b>Tasks</b> category of a custom Jump List.
    ///Params:
    ///    poa = Type: <b>IObjectArray*</b> A pointer to an IObjectArray that represents one or more IShellLink (or, more
    ///          rarely, IShellItem) objects that represent the tasks. <div class="alert"><b>Note</b> Any IShellLink used here
    ///          must declare an argument list through SetArguments. Adding an <b>IShellLink</b> object with no arguments to a
    ///          custom category is not supported. A user cannot pin or unpin this type of item from a Jump List, nor can they
    ///          be added or removed.</div> <div> </div>
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise.
    ///    
    HRESULT AddUserTasks(IObjectArray poa);
    ///Declares that the Jump List initiated by a call to ICustomDestinationList::BeginList is complete and ready for
    ///display.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CommitList();
    ///Retrieves the current list of destinations that have been removed by the user from the existing Jump List that
    ///this custom Jump List is meant to replace.
    ///Params:
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>, typically
    ///           IID_IObjectArray.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This
    ///          is typically an IObjectArray, which represents a collection of IShellItem or IShellLink objects that
    ///          represent the items in the list of removed destinations.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRemovedDestinations(const(GUID)* riid, void** ppv);
    ///Deletes a custom Jump List for a specified application.
    ///Params:
    ///    pszAppID = Type: <b>LPCWSTR</b> A pointer to the AppUserModelID of the process whose taskbar button representation
    ///               displays the custom Jump List. In the beta release of Windows 7, this AppUserModelID must be explicitly
    ///               provided because this method is intended to be called from an uninstaller, which runs in a separate process.
    ///               Because it is in a separate process, the system cannot reliably deduce the AppUserModelID. This restriction
    ///               is expected to be removed in later releases.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DeleteList(const(wchar)* pszAppID);
    ///Discontinues a Jump List building session initiated by ICustomDestinationList::BeginList without committing any
    ///changes.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AbortList();
}

///Exposes methods that allow an application to remove one or all destinations from the <b>Recent</b> or <b>Frequent</b>
///categories in a Jump List.
@GUID("12337D35-94C6-48A0-BCE7-6A9C69D4D600")
interface IApplicationDestinations : IUnknown
{
    ///Specifies a unique Application User Model ID (AppUserModelID) for the application from whose taskbar button's
    ///Jump List the methods of this interface will remove destinations. This method is optional.
    ///Params:
    ///    pszAppID = Type: <b>LPCWSTR</b> Pointer to the AppUserModelID of the process whose taskbar button representation
    ///               receives the Jump List.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetAppID(const(wchar)* pszAppID);
    ///Removes a single destination from the <b>Recent</b> and <b>Frequent</b> categories in a Jump List.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to the IShellItem or IShellLink that represents the destination to remove.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a standard COM error value otherwise. If the object
    ///    pointed to by <i>punk</i> is not an IShellItem or IShellLink, the method returns E_INVALIDARG.
    ///    
    HRESULT RemoveDestination(IUnknown punk);
    ///Clears all destination entries from the <b>Recent</b> and <b>Frequent</b> categories in an application's Jump
    ///List.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveAllDestinations();
}

///Exposes methods that allow an application to retrieve the contents of the <b>Recent</b> or <b>Frequent</b> categories
///in a Jump List.
@GUID("3C594F9F-9F30-47A1-979A-C9E83D3D0A06")
interface IApplicationDocumentLists : IUnknown
{
    ///Specifies a unique Application User Model ID (AppUserModelID) for the application whose destination lists are
    ///being retrieved. This method is optional.
    ///Params:
    ///    pszAppID = Type: <b>LPCWSTR</b> A pointer to the AppUserModelID of the process whose taskbar button representation
    ///               receives the Jump List.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetAppID(const(wchar)* pszAppID);
    ///Retrieves an object that represents the collection of destinations listed in the <b>Recent</b> or <b>Frequent</b>
    ///category in a Jump List.
    ///Params:
    ///    listtype = Type: <b>APPDOCLISTTYPE</b> One of the following values that specifies from which category the list of
    ///               destinations should be retrieved.
    ///    cItemsDesired = Type: <b>UINT</b> The number of items to retrieve from the list specified in <i>listtype</i>. Set this
    ///                    parameter to 0 to retrieve the full list.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>, typically
    ///           IID_IObjectArray or IID_IEnumObjects.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This
    ///          is typically an IObjectArray or IEnumObjects which represents a collection of IShellItem or IShellLink
    ///          objects (or a mix of the two) that represent the retrieved items from the list.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetList(APPDOCLISTTYPE listtype, uint cItemsDesired, const(GUID)* riid, void** ppv);
}

///Exposes methods that allow implementers of a custom IAssocHandler object to provide access to its explicit
///Application User Model ID (AppUserModelID). This information is used to determine whether a particular file type can
///be added to an application's Jump List.
@GUID("36DB0196-9665-46D1-9BA7-D3709EECF9ED")
interface IObjectWithAppUserModelID : IUnknown
{
    ///Specifies a unique application-defined Application User Model ID (AppUserModelID) that identifies the object as a
    ///handler for a specific file type. This method is used by applications that require dynamic AppUserModelIDs.
    ///Params:
    ///    pszAppID = Type: <b>LPCWSTR</b> A pointer to the AppUserModelID string to assign to an application.
    ///Returns:
    ///    Type: <b>HRESULT</b> Custom implementations that do not require dynamic AppUserModelIDs can return E_NOTIMPL.
    ///    Custom implementations that require dynamic AppUserModelIDs should return S_OK if successful, or an error
    ///    value otherwise.
    ///    
    HRESULT SetAppID(const(wchar)* pszAppID);
    ///Retrieves a file type handler's explicit Application User Model ID (AppUserModelID), if one has been declared.
    ///Params:
    ///    ppszAppID = Type: <b>LPWSTR*</b> When this method returns, contains the address of the AppUserModelID string assigned to
    ///                the object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAppID(ushort** ppszAppID);
}

///Exposes methods that provide access to the ProgID associated with an object.
@GUID("71E806FB-8DEE-46FC-BF8C-7748A8A1AE13")
interface IObjectWithProgID : IUnknown
{
    ///Sets the ProgID of an object.
    ///Params:
    ///    pszProgID = Type: <b>LPCWSTR</b> A pointer to a string that contains the new ProgID.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetProgID(const(wchar)* pszProgID);
    ///Retrieves the ProgID associated with an object.
    ///Params:
    ///    ppszProgID = Type: <b>LPWSTR*</b> A pointer to a string that, when this method returns successfully, contains the ProgID.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetProgID(ushort** ppszProgID);
}

///Provides a method to update the ITEMIDLIST of the child of an folder object.
@GUID("6589B6D2-5F8D-4B9E-B7E0-23CDD9717D8C")
interface IUpdateIDList : IUnknown
{
    ///Updates the provided child ITEMIDLIST based on the parameters specified by the provided IBindCtx.
    ///Params:
    ///    pbc = Type: <b>IBindCtx*</b> An IBindCtx interface on a bind context object. Used to specify parameters for
    ///          updating the child ITEMIDLIST. This value can be <b>NULL</b>.
    ///    pidlIn = Type: <b>PCUITEMID_CHILD</b> The child ITEMIDLIST.
    ///    ppidlOut = Type: <b>PITEMID_CHILD*</b> A pointer to the child ITEMIDLIST relative to the parent folder.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Update(IBindCtx pbc, ITEMIDLIST* pidlIn, ITEMIDLIST** ppidlOut);
}

///Provides methods for managing the desktop wallpaper.
@GUID("B92B56A9-8B55-4E14-9A89-0199BBB6F93B")
interface IDesktopWallpaper : IUnknown
{
    ///Sets the desktop wallpaper.
    ///Params:
    ///    monitorID = The ID of the monitor. This value can be obtained through GetMonitorDevicePathAt. Set this value to NULL to
    ///                set the wallpaper image on all monitors.
    ///    wallpaper = The full path of the wallpaper image file.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetWallpaper(const(wchar)* monitorID, const(wchar)* wallpaper);
    ///Gets the current desktop wallpaper.
    ///Params:
    ///    monitorID = The ID of the monitor. This value can be obtained through GetMonitorDevicePathAt. This value can be set to
    ///                <b>NULL</b>. In that case, if a single wallpaper image is displayed on all of the system's monitors, the
    ///                method returns successfully. If this value is set to <b>NULL</b> and different monitors are displaying
    ///                different wallpapers or a slideshow is running, the method returns S_FALSE and an empty string in the
    ///                <i>wallpaper</i> parameter.
    ///    wallpaper = The address of a pointer to a buffer that, when this method returns successfully, receives the path to the
    ///                wallpaper image file. Note that this image could be currently displayed on all of the system's monitors, not
    ///                just the monitor specified in the <i>monitorID</i> parameter. This string will be empty if no wallpaper image
    ///                is being displayed or if a monitor is displaying a solid color. The string will also be empty if the method
    ///                fails.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetWallpaper(const(wchar)* monitorID, ushort** wallpaper);
    ///Retrieves the unique ID of one of the system's monitors.
    ///Params:
    ///    monitorIndex = The number of the monitor. Call GetMonitorDevicePathCount to determine the total number of monitors.
    ///    monitorID = A pointer to the address of a buffer that, when this method returns successfully, receives the monitor's ID.
    ///Returns:
    ///    If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code,
    ///    including the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> A <b>NULL</b> pointer was provided in
    ///    <i>monitorID</i>. </td> </tr> </table>
    ///    
    HRESULT GetMonitorDevicePathAt(uint monitorIndex, ushort** monitorID);
    ///Retrieves the number of monitors that are associated with the system.
    ///Params:
    ///    count = A pointer to a value that, when this method returns successfully, receives the number of monitors.
    ///Returns:
    ///    If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code,
    ///    including the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> A <b>NULL</b> pointer was provided in
    ///    <i>monitorID</i>. </td> </tr> </table>
    ///    
    HRESULT GetMonitorDevicePathCount(uint* count);
    ///Retrieves the display rectangle of the specified monitor.
    ///Params:
    ///    monitorID = The ID of the monitor to query. You can get this value through GetMonitorDevicePathAt.
    ///    displayRect = A pointer to a RECT structure that, when this method returns successfully, receives the display rectangle of
    ///                  the monitor specified by <i>monitorID</i>, in screen coordinates.
    ///Returns:
    ///    If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code,
    ///    including the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The monitor specified by <i>monitorID</i> is not
    ///    currently attached to the system. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> A <b>NULL</b> pointer was provided in <i>displayRect</i>. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The ID supplied in
    ///    <i>monitorID</i> cannot be found. </td> </tr> </table>
    ///    
    HRESULT GetMonitorRECT(const(wchar)* monitorID, RECT* displayRect);
    ///Sets the color that is visible on the desktop when no image is displayed or when the desktop background has been
    ///disabled. This color is also used as a border when the desktop wallpaper does not fill the entire screen.
    ///Params:
    ///    color = A COLORREF value that specifies the background RGB color value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetBackgroundColor(uint color);
    ///Retrieves the color that is visible on the desktop when no image is displayed or when the desktop background has
    ///been disabled. This color is also used as a border when the desktop wallpaper does not fill the entire screen.
    ///Params:
    ///    color = A pointer to a COLORREF value that, when this method returns successfully, receives the RGB color value. If
    ///            this method fails, this value is set to 0.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBackgroundColor(uint* color);
    ///Sets the display option for the desktop wallpaper image, determining whether the image should be centered, tiled,
    ///or stretched.
    ///Params:
    ///    position = One of the DESKTOP_WALLPAPER_POSITION enumeration values that specify how the image will be displayed on the
    ///               system's monitors.
    ///Returns:
    ///    If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code,
    ///    including the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The desktop wallpaper is already displayed as asked
    ///    for in <i>position</i>. </td> </tr> </table>
    ///    
    HRESULT SetPosition(DESKTOP_WALLPAPER_POSITION position);
    ///Retrieves the current display value for the desktop background image.
    ///Params:
    ///    position = A pointer to a value that, when this method returns successfully, receives one of the
    ///               DESKTOP_WALLPAPER_POSITION enumeration values that specify how the image is being displayed on the system's
    ///               monitors.
    ///Returns:
    ///    If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code,
    ///    including the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> A <b>NULL</b> pointer was provided in
    ///    <i>position</i>. </td> </tr> </table>
    ///    
    HRESULT GetPosition(DESKTOP_WALLPAPER_POSITION* position);
    ///Specifies the images to use for the desktop wallpaper slideshow.
    ///Params:
    ///    items = A pointer to an IShellItemArray that contains the slideshow images. This array can contain individual items
    ///            stored in the same container (files stored in a folder), or it can contain a single item which is the
    ///            container itself (a folder that contains images). Any other configuration of the array will cause this method
    ///            to fail.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSlideshow(IShellItemArray items);
    ///Gets the path to the directory where the slideshow images are stored.
    ///Params:
    ///    items = The address of a pointer to an IShellItemArray object that, when this method returns successfully, receives
    ///            the items that make up the slideshow. This array can contain individual items stored in the same container,
    ///            or it can contain a single item which is the container itself.
    ///Returns:
    ///    If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code,
    ///    including the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> A <b>NULL</b> pointer was provided in
    ///    <i>position</i>. </td> </tr> </table>
    ///    
    HRESULT GetSlideshow(IShellItemArray* items);
    ///Sets the desktop wallpaper slideshow settings for shuffle and timing.
    ///Params:
    ///    options = Set to either 0 to disable shuffle or the following value.
    ///    slideshowTick = The amount of time, in milliseconds, between image transitions.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSlideshowOptions(DESKTOP_SLIDESHOW_OPTIONS options, uint slideshowTick);
    ///Gets the current desktop wallpaper slideshow settings for shuffle and timing.
    ///Params:
    ///    options = Type: <b>DESKTOP_SLIDESHOW_OPTIONS*</b> A pointer to a value that, when this method returns successfully,
    ///              receives either 0 to indicate that shuffle is disabled or the following value.
    ///    slideshowTick = Type: <b>UINT*</b> A pointer to a value that, when this method returns successfully, receives the interval
    ///                    between image transitions, in milliseconds.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b>
    ///    error code, including the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> A <b>NULL</b> pointer was provided
    ///    in one of the parameters. </td> </tr> </table>
    ///    
    HRESULT GetSlideshowOptions(DESKTOP_SLIDESHOW_OPTIONS* options, uint* slideshowTick);
    ///Switches the wallpaper on a specified monitor to the next image in the slideshow.
    ///Params:
    ///    monitorID = The ID of the monitor on which to change the wallpaper image. This ID can be obtained through the
    ///                GetMonitorDevicePathAt method. If this parameter is set to <b>NULL</b>, the monitor scheduled to change next
    ///                is used.
    ///    direction = The direction that the slideshow should advance. One of the following DESKTOP_SLIDESHOW_DIRECTION values:
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AdvanceSlideshow(const(wchar)* monitorID, DESKTOP_SLIDESHOW_DIRECTION direction);
    ///Gets the current status of the slideshow.
    ///Params:
    ///    state = A pointer to a DESKTOP_SLIDESHOW_STATE value that, when this method returns successfully, receives one or
    ///            more of the following flags.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStatus(DESKTOP_SLIDESHOW_STATE* state);
    ///Enables or disables the desktop background.
    ///Params:
    ///    enable = <b>TRUE</b> to enable the desktop background, <b>FALSE</b> to disable it.
    ///Returns:
    ///    If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code,
    ///    including the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The desktop wallpaper is already in the state
    ///    you're asking for through this call. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FILE_NOT_FOUND</b></dt>
    ///    </dl> </td> <td width="60%"> The desktop wallpaper that would be used when the background is enabled is
    ///    missing from its expected location. Call SetWallpaper to specify a new wallpaper. </td> </tr> </table>
    ///    
    HRESULT Enable(BOOL enable);
}

///Exposes methods that determine a computer's HomeGroup membership status and display the sharing wizard.
@GUID("7A3BD1D9-35A9-4FB3-A467-F48CAC35E2D0")
interface IHomeGroup : IUnknown
{
    ///Determines whether the local computer is a member of a HomeGroup.
    ///Params:
    ///    member = Type: <b>BOOL*</b> When this method returns successfully, receives <b>TRUE</b> if the local computer is a
    ///             member of a HomeGroup; otherwise, <b>FALSE</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsMember(int* member);
    ///Displays a wizard that allows a user to create a Home Group, and then retrieves the sharing options that the user
    ///selected through the wizard.
    ///Params:
    ///    owner = Type: <b>HWND</b> Handle of the owner window of the wizard, used for notifications. This value can be
    ///            <b>NULL</b>.
    ///    sharingchoices = Type: <b>HOMEGROUPSHARINGCHOICES*</b> Pointer to a value that, when this method returns successfully,
    ///                     receives one or more of the following values that indicate the libraries and devices chosen through the
    ///                     wizard to be shared with the Home Group.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a standard error value otherwise, including the
    ///    following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_CANCELLED</b></dt> </dl> </td> <td width="60%"> The user canceled the wizard. Use
    ///    HRESULT_FROM_WIN32 to extract this error code. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The computer is not joined to a Home Group or the
    ///    network or Home Group is not in a state that allows sharing (such as not being connected to the network or
    ///    having another sharing operation in progress). </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The method was launched from a multithreaded
    ///    apartment (MTA) thread. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>sharingchoices</i> parameter is <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT ShowSharingWizard(HWND owner, HOMEGROUPSHARINGCHOICES* sharingchoices);
}

///Exposes a method that initializes a handler, such as a property handler, thumbnail handler, or preview handler, with
///a property store.
@GUID("C3E12EB5-7D8D-44F8-B6DD-0E77B34D6DE4")
interface IInitializeWithPropertyStore : IUnknown
{
    ///Initializes a handler with an IPropertyStore.
    ///Params:
    ///    pps = Type: <b>IPropertyStore*</b> A pointer to an IPropertyStore.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(IPropertyStore pps);
}

///Exposes a method to get search results from a custom client-side OpenSearch data source.
@GUID("F0EE7333-E6FC-479B-9F25-A860C234A38E")
interface IOpenSearchSource : IUnknown
{
    ///Returns search results, from an OpenSearch data source, formatted in RSS or Atom format.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The window handle of the caller.
    ///    pszQuery = Type: <b>LPCWSTR</b> The query as entered by the user. This parameter is equivalent to the OpenSearch
    ///               {searchTerms} parameter and may be empty.
    ///    dwStartIndex = Type: <b>DWORD</b> The index of the first result being requested. Equivalent to the OpenSearch {startIndex}
    ///                   parameter. See Remarks below.
    ///    dwCount = Type: <b>DWORD</b> The number of results being requested. Equivalent to the OpenSearch {count} parameter.
    ///    riid = Type: <b>REFIID</b> The IID of the interface being requested. Typically IID_IStream.
    ///    ppv = Type: <b>void**</b> An interface pointer, of type specified by RIID, to the object containing the results in
    ///          Atom or RSS format.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. B_S_ENDOFROWSET optionally
    ///    signifies the end of the results. The following errors display appropriate error messages in the info bar:
    ///    <ul> <li>INET_E_AUTHENTICATION_REQUIRED (user does not have permission to access this resource)</li>
    ///    <li>INET_E_RESOURCE_NOT_FOUND (location was unavailable)</li> <li>INET_E_DOWNLOAD_FAILURE (server error)</li>
    ///    </ul>
    ///    
    HRESULT GetResults(HWND hwnd, const(wchar)* pszQuery, uint dwStartIndex, uint dwCount, const(GUID)* riid, 
                       void** ppv);
}

///Exposes methods for creating and managing libraries.
@GUID("11A66EFA-382E-451A-9234-1E0E12EF3085")
interface IShellLibrary : IUnknown
{
    ///Loads the library from a specified library definition file.
    ///Params:
    ///    psiLibrary = Type: <b>IShellItem*</b> An IShellItem object for the library definition file to load. An error is returned
    ///                 if this object is not a library.
    ///    grfMode = Type: <b>DWORD</b> One or more STGM storage medium flags that specify access and sharing modes for the
    ///              library object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT LoadLibraryFromItem(IShellItem psiLibrary, uint grfMode);
    ///Loads the library that is referenced by a KNOWNFOLDERID.
    ///Params:
    ///    kfidLibrary = Type: <b>REFKNOWNFOLDERID</b> The KNOWNFOLDERID value that identifies the library to load.
    ///    grfMode = Type: <b>DWORD</b> One or more STGM storage medium flags that specify access and sharing modes for the
    ///              library object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT LoadLibraryFromKnownFolder(const(GUID)* kfidLibrary, uint grfMode);
    ///Adds a folder to the library.
    ///Params:
    ///    psiLocation = Type: <b>IShellItem*</b> An IShellItem object that represents the folder to be added to the library.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddFolder(IShellItem psiLocation);
    ///Removes a folder from the library.
    ///Params:
    ///    psiLocation = Type: <b>IShellItem*</b> An IShellItem object that represents the folder to remove.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveFolder(IShellItem psiLocation);
    ///Gets the set of child folders that are contained in the library.
    ///Params:
    ///    lff = Type: <b>LIBRARYFOLDERFILTER</b> One of the following LIBRARYFOLDERFILTER values that determines the folders
    ///          to get. These flags cannot be combined.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to get in <i>ppv</i>. This value is typically
    ///           IID_IShellItemArray, but it can also be IID_IObjectCollection, IID_IObjectArray, or the IID of any other
    ///           interface that is implemented by CShellItemArray.
    ///    ppv = Type: <b>void**</b> A pointer to the interface requested in <i>riid</i>. If this call fails, this value is
    ///          <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    call was successful and the specified folders were returned in <i>ppv</i>. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The call was successful but not all specified
    ///    folders were returned in <i>ppv</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_</b></dt> </dl> </td>
    ///    <td width="60%"> This method can return other error values. </td> </tr> </table>
    ///    
    HRESULT GetFolders(LIBRARYFOLDERFILTER lff, const(GUID)* riid, void** ppv);
    ///Resolves the target location of a library folder, even if the folder has been moved or renamed.
    ///Params:
    ///    psiFolderToResolve = Type: <b>IShellItem*</b> An IShellItem object that represents the library folder to locate.
    ///    dwTimeout = Type: <b>DWORD</b> The maximum time, in milliseconds, the method will attempt to locate the folder before
    ///                returning. If the folder could not be located before the specified time elapses, an error is returned.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to get in <i>ppv</i> that will represent the
    ///           resolved target location. This value is typically IID_IShellItem, but it can also be IID_IShellItem2 or the
    ///           IID of any other interface that is implemented by CShellItem.
    ///    ppv = Type: <b>void**</b> A pointer to the interface requested in <i>riid</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    target folder was located and returned in <i>ppv</i>; however, the library has been updated so
    ///    IShellLibrary::Commit or IShellLibrary::Save should be called to persist these changes. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The target folder was located and
    ///    returned in <i>ppv</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_</b></dt> </dl> </td> <td
    ///    width="60%"> This method can return other error values. </td> </tr> </table>
    ///    
    HRESULT ResolveFolder(IShellItem psiFolderToResolve, uint dwTimeout, const(GUID)* riid, void** ppv);
    ///Retrieves the default target folder that the library uses for save operations.
    ///Params:
    ///    dsft = Type: <b>DEFAULTSAVEFOLDERTYPE</b> The DEFAULTSAVEFOLDERTYPE value that specifies the save folder to get.
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to get in <i>ppv</i> that will represent the save
    ///           location. This value is typically IID_IShellItem, but it can also be IID_IShellItem2 or the IID of any other
    ///           interface that is implemented by CShellItem.
    ///    ppv = Type: <b>void**</b> A pointer to the interface requested in <i>riid</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDefaultSaveFolder(DEFAULTSAVEFOLDERTYPE dsft, const(GUID)* riid, void** ppv);
    ///Sets the default target folder that the library will use for save operations.
    ///Params:
    ///    dsft = Type: <b>DEFAULTSAVEFOLDERTYPE</b> The DEFAULTSAVEFOLDERTYPE value that specifies the default save location
    ///           to set.
    ///    psi = Type: <b>IShellItem*</b> An IShellItem object that represents the folder that to use as the default save
    ///          location. The folder that this object represents must be a folder that is already in the library.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDefaultSaveFolder(DEFAULTSAVEFOLDERTYPE dsft, IShellItem psi);
    ///Gets the library's options.
    ///Params:
    ///    plofOptions = Type: <b>LIBRARYOPTIONFLAGS*</b> The library options for this library. LIBRARYOPTIONFLAGS is a bitwise
    ///                  enumerator, which means that more than one flag could be set.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOptions(LIBRARYOPTIONFLAGS* plofOptions);
    ///Sets the library options.
    ///Params:
    ///    lofMask = Type: <b>LIBRARYOPTIONFLAGS</b> A bitmask that specifies the LIBRARYOPTIONFLAGS values to change in this
    ///              call.
    ///    lofOptions = Type: <b>LIBRARYOPTIONFLAGS</b> A bitmask that specifies the new value of each LIBRARYOPTIONFLAGS value to
    ///                 change. <b>LIBRARYOPTIONFLAGS</b> values that are not set in <i>lofMask</i> are not changed by this call.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOptions(LIBRARYOPTIONFLAGS lofMask, LIBRARYOPTIONFLAGS lofOptions);
    ///Gets the library's folder type.
    ///Params:
    ///    pftid = Type: <b>FOLDERTYPEID*</b> The view template that is applied to a folder, usually based on its intended use
    ///            and contents.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFolderType(GUID* pftid);
    ///Sets the library's folder type.
    ///Params:
    ///    ftid = Type: <b>REFFOLDERTYPEID</b> The <b>GUID</b> or FOLDERTYPEID that represents the view template that is
    ///           applied to a folder, usually based on its intended use and contents.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetFolderType(const(GUID)* ftid);
    ///Gets the default icon for the library.
    ///Params:
    ///    ppszIcon = Type: <b>LPWSTR*</b> A null-terminated Unicode string that describes the location of the default icon. The
    ///               string is returned as <code>ModuleFileName,ResourceIndex</code> or <code>ModuleFileName,-ResourceID</code>.
    ///               <table> <tr> <th>Value</th> <th>Description</th> </tr> <tr> <td>ModuleFileName</td> <td>The file name of the
    ///               module file that contains the icon resource.</td> </tr> <tr> <td>ResourceIndex</td> <td>If the number that
    ///               follows the comma is positive, the index of the resource in the module file.</td> </tr> <tr>
    ///               <td>-ResourceID</td> <td>If the number that follows the comma is negative, the absolute value of the number
    ///               is the resource ID of the icon in the module file.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetIcon(ushort** ppszIcon);
    ///Sets the default icon for the library.
    ///Params:
    ///    pszIcon = Type: <b>LPCWSTR</b> A null-terminated Unicode string that describes the location of the default icon. The
    ///              string must be formatted as <code>ModuleFileName,ResourceIndex</code> or
    ///              <code>ModuleFileName,-ResourceID</code>. <table> <tr> <th>Value</th> <th>Description</th> </tr> <tr>
    ///              <td>ModuleFileName</td> <td>The file name of the module file that contains the icon resource.</td> </tr> <tr>
    ///              <td>ResourceIndex</td> <td>A positive decimal number that specifies the index of the icon resource in the
    ///              module file.</td> </tr> <tr> <td>-ResourceID</td> <td>A negative decimal number whose absolute value is the
    ///              resource ID of the icon resource in the module file.</td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetIcon(const(wchar)* pszIcon);
    ///Commits library updates to an existing Library Description file.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Commit();
    ///Saves the library to a new Library Description (*.library-ms) file.
    ///Params:
    ///    psiFolderToSaveIn = Type: <b>IShellItem*</b> The IShellItem object that specifies the folder in which to save the library, or
    ///                        <b>NULL</b> to save the library with the user's default libraries in the FOLDERID_Libraries known folder.
    ///    pszLibraryName = Type: <b>LPCWSTR</b> The file name under which to save the library. The file name must not include the file
    ///                     name extension; the file name extension is added automatically.
    ///    lsf = Type: <b>LIBRARYSAVEFLAGS</b> The LIBRARYSAVEFLAGS value that specifies how to handle a library name
    ///          collision.
    ///    ppsiSavedTo = Type: <b>IShellItem**</b> The IShellItem object that represents the library description file into which the
    ///                  library was saved.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Save(IShellItem psiFolderToSaveIn, const(wchar)* pszLibraryName, LIBRARYSAVEFLAGS lsf, 
                 IShellItem* ppsiSavedTo);
    ///Saves the library to a new file in a specified known folder.
    ///Params:
    ///    kfidToSaveIn = Type: <b>REFKNOWNFOLDERID</b> The ID of the known folder in which to save the IShellLibrary object. For more
    ///                   information, see KNOWNFOLDERID.
    ///    pszLibraryName = Type: <b>LPCWSTR</b> The file name under which to save the library. The file name must not include the file
    ///                     name extension; the file name extension is added automatically.
    ///    lsf = Type: <b>LIBRARYSAVEFLAGS</b> The LIBRARYSAVEFLAGS value that specifies how to handle a library name
    ///          collision.
    ///    ppsiSavedTo = Type: <b>IShellItem**</b> The IShellItem object that represents the library description file into which the
    ///                  library was saved.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SaveInKnownFolder(const(GUID)* kfidToSaveIn, const(wchar)* pszLibraryName, LIBRARYSAVEFLAGS lsf, 
                              IShellItem* ppsiSavedTo);
}

///Provides methods used to get and set shortcut menu information. This information is the same as that provided to
///SHCreateDefaultContextMenu through the DEFCONTEXTMENU structure. <div class="alert"><b>Note</b> Do not use this
///method to reinitialize a shortcut menu; use IShellExtInit::Initialize instead.</div><div> </div>
@GUID("7690AA79-F8FC-4615-A327-36F7D18F5D91")
interface IDefaultFolderMenuInitialize : IUnknown
{
    ///Sets context menu info for the [IDefaultFolderMenuInitialize](nn-shobjidl_core-idefaultfoldermenuinitialize.md)
    ///object.
    ///Params:
    ///    hwnd = A handle to the shortcut menu.
    ///    pcmcb = Type: <b>IContextMenuCB*</b> The address of the object that defines the callback for the shortcut menu.
    ///    pidlFolder = Type: **PCIDLIST_ABSOLUTE** The address of an item identifier list that specifies the folder of the items. If
    ///                 NULL, this is computed from the *psf* parameter.
    ///    psf = Type: <b>IShellFolder*</b> The folder of the items.
    ///    cidl = Type: <b>UINT</b> The count of items in the *apidl* parameter.
    ///    apidl = Type: <b>PCUITEMID_CHILD_ARRAY</b> A pointer to an array of PIDL structures, each of which is an item to be
    ///            operated on.
    ///    punkAssociation = Type: <b>IUnknown*</b> The address of an IQueryAssociations object that specifies where to load extensions
    ///                      from.
    ///    cKeys = Type: <b>UINT</b> The count of items in the *aKeys* parameter. May be zero.
    ///    aKeys = Type: <b>const HKEY*</b> Specifies where to load extensions from.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(HWND hwnd, IContextMenuCB pcmcb, ITEMIDLIST* pidlFolder, IShellFolder psf, uint cidl, 
                       ITEMIDLIST** apidl, IUnknown punkAssociation, uint cKeys, const(ptrdiff_t)* aKeys);
    ///Sets shortcut menu restrictions for the
    ///[IDefaultFolderMenuInitialize](nn-shobjidl_core-idefaultfoldermenuinitialize.md) object.
    ///Params:
    ///    dfmrValues = A bitwise combination of the
    ///                 [DEFAULT_FOLDER_MENU_RESTRICTIONS](ne-shobjidl_core-default_folder_menu_restrictions.md) values that specify
    ///                 the restrictions to set.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetMenuRestrictions(DEFAULT_FOLDER_MENU_RESTRICTIONS dfmrValues);
    ///Gets shortcut menu restrictions that are currently set for the
    ///[IDefaultFolderMenuInitialize](nn-shobjidl_core-idefaultfoldermenuinitialize.md) object.
    ///Params:
    ///    dfmrMask = A bitwise combination of the
    ///               [DEFAULT_FOLDER_MENU_RESTRICTIONS](ne-shobjidl_core-default_folder_menu_restrictions.md) values that specify
    ///               the mask of the restrictions to get.
    ///    pdfmrValues = A bitwise combination of the
    ///                  [DEFAULT_FOLDER_MENU_RESTRICTIONS](ne-shobjidl_core-default_folder_menu_restrictions.md) values that specify
    ///                  the restrictions.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMenuRestrictions(DEFAULT_FOLDER_MENU_RESTRICTIONS dfmrMask, 
                                DEFAULT_FOLDER_MENU_RESTRICTIONS* pdfmrValues);
    ///Sets the shortcut menu handler for the
    ///[IDefaultFolderMenuInitialize](nn-shobjidl_core-idefaultfoldermenuinitialize.md) object.
    ///Params:
    ///    rclsid = Type: <b>REFCLSID</b> The CLSID for the object defines the shortcut menu handler.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetHandlerClsid(const(GUID)* rclsid);
}

///Provides methods which activate Windows Store apps for the Launch, File, and Protocol extensions. You will normally
///use this interface in debuggers and design tools.
@GUID("2E941141-7F97-4756-BA1D-9DECDE894A3D")
interface IApplicationActivationManager : IUnknown
{
    ///Activates the specified Windows Store app for the generic launch contract (Windows.Launch) in the current
    ///session.
    ///Params:
    ///    appUserModelId = The application user model ID of the Windows Store app.
    ///    arguments = A pointer to an optional, app-specific, argument string.
    ///    options = One or more of the following flags used to support design mode, debugging, and testing scenarios.
    ///    processId = A pointer to a value that, when this method returns successfully, receives the process ID of the app instance
    ///                that fulfils this contract.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ActivateApplication(const(wchar)* appUserModelId, const(wchar)* arguments, ACTIVATEOPTIONS options, 
                                uint* processId);
    ///Activates the specified Windows Store app for the file contract (Windows.File).
    ///Params:
    ///    appUserModelId = The application user model ID of the Windows Store app.
    ///    itemArray = A pointer to an array of Shell items, each representing a file. This value is converted to a VectorView of
    ///                StorageItem objects that is passed to the app through FileActivatedEventArgs.
    ///    verb = The verb being applied to the file or files specified by <i>itemArray</i>.
    ///    processId = A pointer to a value that, when this method returns successfully, receives the process ID of the app instance
    ///                that fulfils this contract.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ActivateForFile(const(wchar)* appUserModelId, IShellItemArray itemArray, const(wchar)* verb, 
                            uint* processId);
    ///Activates the specified Windows Store app for the protocol contract (Windows.Protocol).
    ///Params:
    ///    appUserModelId = The application user model ID of the Windows Store app.
    ///    itemArray = A pointer to an array of a single Shell item. The first item in the array is converted into a Uri object that
    ///                is passed to the app through ProtocolActivatedEventArgs. Any items in the array except for the first element
    ///                are ignored.
    ///    processId = A pointer to a value that, when this method returns successfully, receives the process ID of the app instance
    ///                that fulfils this contract.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ActivateForProtocol(const(wchar)* appUserModelId, IShellItemArray itemArray, uint* processId);
}

///Exposes methods that enable an application to interact with groups of windows that form virtual workspaces.
@GUID("A5CD92FF-29BE-454C-8D04-D82879FB3F1B")
interface IVirtualDesktopManager : IUnknown
{
    ///Indicates whether the provided window is on the currently active virtual desktop.
    ///Params:
    ///    topLevelWindow = The window of interest.
    ///    onCurrentDesktop = <b>True</b> if the <i>topLevelWindow</i> is on the currently active virtual desktop, otherwise <b>false</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsWindowOnCurrentVirtualDesktop(HWND topLevelWindow, int* onCurrentDesktop);
    ///Gets the identifier for the virtual desktop hosting the provided top-level window.
    ///Params:
    ///    topLevelWindow = The top level window for the virtual desktop you are interested in.
    ///    desktopId = The identifier for the virtual desktop hosting the <i>topLevelWindow</i>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetWindowDesktopId(HWND topLevelWindow, GUID* desktopId);
    ///Moves a window to the specified virtual desktop.
    ///Params:
    ///    topLevelWindow = The window to move.
    ///    desktopId = The identifier of the virtual desktop to move the
    ///                [GetWindowDesktopId](./nf-shobjidl_core-ivirtualdesktopmanager-getwindowdesktopid.md) to get a window's
    ///                identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT MoveWindowToDesktop(HWND topLevelWindow, const(GUID)* desktopId);
}

///Exposes methods that invoke an associated application handler.
@GUID("92218CAB-ECAA-4335-8133-807FD234C2EE")
interface IAssocHandlerInvoker : IUnknown
{
    ///Determines whether an invoker supports its selection.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if this instance supports its selection, or <b>S_FALSE</b>
    ///    otherwise.
    ///    
    HRESULT SupportsSelection();
    ///Invokes an associated application handler.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Invoke();
}

///Exposes methods for operations with a file association dialog box or menu.
@GUID("F04061AC-1659-4A3F-A954-775AA57FC083")
interface IAssocHandler : IUnknown
{
    ///Retrieves the full path and file name of the executable file associated with the file type.
    ///Params:
    ///    ppsz = Type: <b>LPWSTR*</b> When this method returns, contains the address of a pointer to a null-terminated,
    ///           Unicode string that contains the full path of the file, including the file name.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetName(ushort** ppsz);
    ///Retrieves the display name of an application.
    ///Params:
    ///    ppsz = Type: <b>LPWSTR*</b> When this method returns, contains the address of a pointer to a null-terminated,
    ///           Unicode string that contains the display name of the application.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetUIName(ushort** ppsz);
    ///Retrieves the location of the icon associated with the application.
    ///Params:
    ///    ppszPath = Type: <b>LPWSTR*</b> When this method returns, contains the address of a pointer to a null-terminated,
    ///               Unicode string that contains the path to the application's icon.
    ///    pIndex = Type: <b>int*</b> When this method returns, contains a pointer to the index of the icon within the resource
    ///             named in <i>ppszPath</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetIconLocation(ushort** ppszPath, int* pIndex);
    ///Indicates whether the application is registered as a recommended handler for the queried file type.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the program is recommended; otherwise, S_FALSE.
    ///    
    HRESULT IsRecommended();
    ///Sets an application as the default application for this file type.
    ///Params:
    ///    pszDescription = Type: <b>LPCWSTR</b> A pointer to a null-terminated, Unicode string that contains the display name of the
    ///                     application.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT MakeDefault(const(wchar)* pszDescription);
    ///Directly invokes the associated handler.
    ///Params:
    ///    pdo = Type: <b>IDataObject*</b> A pointer to an IDataObject that represents the selected item on which to invoke
    ///          the handler. Note that you should not call <b>IAssocHandler::Invoke</b> with a selection of multiple items.
    ///          If you have multiple items, call IAssocHandler::CreateInvoker instead. See Remarks for more details.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Invoke(IDataObject pdo);
    ///Retrieves an object that enables the invocation of the associated handler on the current selection. The invoker
    ///includes the ability to verify whether the current selection is supported.
    ///Params:
    ///    pdo = Type: <b>IDataObject*</b> A pointer to an IDataObject that represents the selected item or items on which to
    ///          invoke the handler. Note that if you have only a single item, IAssocHandler::Invoke could be the better
    ///          choice. See Remarks for more details.
    ///    ppInvoker = Type: <b>IAssocHandlerInvoker**</b> When this method returns, contains the address of a pointer to an
    ///                IAssocHandlerInvoker object. This object is used to invoke the menu item after ensuring that the selected
    ///                items are supported by the associated handler.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateInvoker(IDataObject pdo, IAssocHandlerInvoker* ppInvoker);
}

///Exposes a method that allows enumeration of a collection of handlers associated with particular file name extensions.
@GUID("973810AE-9599-4B88-9E4D-6EE98C9552DA")
interface IEnumAssocHandlers : IUnknown
{
    ///Retrieves a specified number of elements.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of elements to retrieve.
    ///    rgelt = Type: <b>IAssocHandler**</b> When this method returns, contains the address of an array of IAssocHandler
    ///            pointers. Each <b>IAssocHandler</b> represents a single handler.
    ///    pceltFetched = Type: <b>ULONG*</b> When this method returns, contains a pointer to the number of elements retrieved.
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
}

///Provides methods that enable you to set or retrieve a DataPackage object's IDataObject interface, which the
///DataPackage uses to support interoperability. The DataPackage object is used by an app to provide data to another
///app.
@GUID("3D25F6D6-4B2A-433C-9184-7C33AD35D001")
interface IDataObjectProvider : IUnknown
{
    ///Gets an IDataObject representation of the current DataPackage object.
    ///Params:
    ///    dataObject = Type: <b>IDataObject**</b> The address of an IDataObject interface pointer that, when this method returns
    ///                 successfully, points to the <b>IDataObject</b> representation of the DataPackage object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDataObject(IDataObject* dataObject);
    ///Wraps an IDataObject instance as a Windows Runtime DataPackage.
    ///Params:
    ///    dataObject = An IDataObject interface pointer to the data object from which to build the DataPackage object.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDataObject(IDataObject dataObject);
}

///Enables access to DataTransferManager methods in a Windows Store app that manages multiple windows.
@GUID("3A3DCD6C-3EAB-43DC-BCDE-45671CE800C8")
interface IDataTransferManagerInterop : IUnknown
{
    ///Gets the DataTransferManager instance for the specified window.
    ///Params:
    ///    appWindow = The window whose DataTransferManager instance is to be retrieved.
    ///    riid = The requested interface ID of the DataTransferManager instance.
    ///    dataTransferManager = Receives the DataTransferManager instance.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetForWindow(HWND appWindow, const(GUID)* riid, void** dataTransferManager);
    ///Displays the UI for sharing content for the specified window.
    ///Params:
    ///    appWindow = The window to show the share UI for.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ShowShareUIForWindow(HWND appWindow);
}

///Enables an app to be notified when the input pane (the on-screen keyboard or handwriting panel) is being shown or
///hidden. This allows the app window to adjust its display so that no input areas (such as a text box) are obscured by
///the input pane.
@GUID("226C537B-1E76-4D9E-A760-33DB29922F18")
interface IFrameworkInputPaneHandler : IUnknown
{
    ///Called before the input pane is shown, to allow the app window to make any necessary adjustments to its UI in
    ///response to the reduced screen space available to it. This is particularly important for input elements, such as
    ///text boxes, that are used in conjunction with the input pane.
    ///Params:
    ///    prcInputPaneScreenLocation = Type: <b>RECT*</b> A pointer to a RECT structure that supplies the screen coordinates that the input pane
    ///                                 will occupy.
    ///    fEnsureFocusedElementInView = Type: <b>BOOL*</b> A pointer to a value that is set to <b>true</b> if the app should attempt to keep its
    ///                                  currently focused element (such as a text box) in view, which could require the app to move the element or
    ///                                  rearrange its UI.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Showing(RECT* prcInputPaneScreenLocation, BOOL fEnsureFocusedElementInView);
    ///Called when the input pane is about to leave the display.
    ///Params:
    ///    fEnsureFocusedElementInView = Type: <b>BOOL*</b> A pointer to a value that is set to <b>true</b> if the app should attempt to keep its
    ///                                  currently focused element (such as a text box) in view, which could require the app to rearrange its UI or
    ///                                  move the element, usually back to its layout before the input pane was shown.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Hiding(BOOL fEnsureFocusedElementInView);
}

///Provides methods that enable apps to be informed of state changes and location for the input pane. The input pane is
///a UI element, an on-screen keyboard or handwriting panel, that appears when the user performs an action that requires
///them to enter information, such as selecting a search box or an entry field in a form. Apps can then adjust their UI
///so that the input pane does not obscure items that the user might need to access while the input pane is shown.
@GUID("5752238B-24F0-495A-82F1-2FD593056796")
interface IFrameworkInputPane : IUnknown
{
    ///Registers the app's input pane handler object to receive notifications on behalf of a window when an event
    ///triggers the input pane. This method differs from AdviseWithHWND in that it references its window through an
    ///object that implements ICoreWindow.
    ///Params:
    ///    pWindow = Type: <b>IUnknown*</b> A pointer to the window (an object that implements ICoreWindow) for which the handler
    ///              should listen for input pane events.
    ///    pHandler = Type: <b>IFrameworkInputPaneHandler*</b> An IFrameworkInputPaneHandler interface pointer to the handler
    ///               instance for this app.
    ///    pdwCookie = Type: <b>DWORD*</b> A pointer to a value that, when this method returns successfully, receives a cookie for
    ///                that can be used later to unregister the handler through the Unadvise method.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Advise(IUnknown pWindow, IFrameworkInputPaneHandler pHandler, uint* pdwCookie);
    ///Registers the app's input pane handler object to receive notifications on behalf of a window when an event
    ///triggers the input pane. This method differs from Advise in that it references its window through an <b>HWND</b>.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the window for which the handler should listen for input pane events.
    ///    pHandler = Type: <b>IFrameworkInputPaneHandler*</b> An IFrameworkInputPaneHandler interface pointer to the handler
    ///               instance for this app.
    ///    pdwCookie = Type: <b>DWORD*</b> A pointer to a value that, when this method returns successfully, receives a cookie for
    ///                that can be used later to unregister the handler through the Unadvise method.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AdviseWithHWND(HWND hwnd, IFrameworkInputPaneHandler pHandler, uint* pdwCookie);
    ///Unregisters an app's input pane handler object so that it no longer receives notifications.
    ///Params:
    ///    dwCookie = Type: <b>DWORD</b> A cookie that identifies the handler. This value was obtained when you registered the
    ///               handler through the Advise method.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Unadvise(uint dwCookie);
    ///Gets the current location of the input pane.
    ///Params:
    ///    prcInputPaneScreenLocation = Type: <b>RECT*</b> A pointer to a RECT structure that, when this method returns successfully, receives the
    ///                                 location of the input pane, in screen coordinates. If the input pane is not visible, this structure receives
    ///                                 an empty rectangle.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Location(RECT* prcInputPaneScreenLocation);
}

///Enables applications to receive notifications of state changes in a display and of changes in Start screen
///visibility.
@GUID("6584CE6B-7D82-49C2-89C9-C6BC02BA8C38")
interface IAppVisibilityEvents : IUnknown
{
    ///Notifies a client that the mode of a display has changed.
    ///Params:
    ///    hMonitor = The display that has a changing mode.
    ///    previousMode = The previous mode of <i>hMonitor</i>, which may be <b>MAV_UNKNOWN</b> if the client was unaware of the
    ///                   display previously.
    ///    currentMode = The current mode of <i>hMonitor</i>, which will not be <b>MAV_UNKNOWN</b>.
    ///Returns:
    ///    The return value is ignored.
    ///    
    HRESULT AppVisibilityOnMonitorChanged(ptrdiff_t hMonitor, MONITOR_APP_VISIBILITY previousMode, 
                                          MONITOR_APP_VISIBILITY currentMode);
    ///Notifies a client that visibility of the Start screen has changed.
    ///Params:
    ///    currentVisibleState = <b>TRUE</b> if the Start screen is displayed; otherwise, <b>FALSE.</b>
    ///Returns:
    ///    The return value is ignored.
    ///    
    HRESULT LauncherVisibilityChange(BOOL currentVisibleState);
}

///Provides functionality to determine whether the display is showing Windows Store apps.
@GUID("2246EA2D-CAEA-4444-A3C4-6DE827E44313")
interface IAppVisibility : IUnknown
{
    ///Queries the current mode of the specified monitor.
    ///Params:
    ///    hMonitor = The monitor to query.
    ///    pMode = The current mode of <i>hMonitor</i>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pMode</i> is <b>NULL</b>.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetAppVisibilityOnMonitor(ptrdiff_t hMonitor, MONITOR_APP_VISIBILITY* pMode);
    ///Gets a value that indicates whether the Start screen is displayed.
    ///Params:
    ///    pfVisible = <b>TRUE</b> if the Start screen is displayed; otherwise, <b>FALSE.</b>
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pfVisible</i> is
    ///    <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT IsLauncherVisible(int* pfVisible);
    ///Registers an advise sink object to receive notification of changes to the display.
    ///Params:
    ///    pCallback = The client's advise sink that receives outgoing calls from the connection point.
    ///    pdwCookie = A token that uniquely identifies this connection. Use this token to delete the connection by passing it to
    ///                the Unadvise method.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pdwCookie</i> is
    ///    <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT Advise(IAppVisibilityEvents pCallback, uint* pdwCookie);
    ///Cancels a connection that was previously established by using Advise.
    ///Params:
    ///    dwCookie = A token that uniquely identifies the connection to cancel, which is provided by a previous call to to the
    ///               Advise method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Unadvise(uint dwCookie);
}

///Enables receiving package state-change notifications during Windows Store app debugging.
@GUID("1BB12A62-2AD8-432B-8CCF-0C2C52AFCD5B")
interface IPackageExecutionStateChangeNotification : IUnknown
{
    ///Called when package state changes during Windows Store app debugging.
    ///Params:
    ///    pszPackageFullName = The package full name.
    ///    pesNewState = The new state that the package changed to.
    ///Returns:
    ///    Return <b>S_OK</b> when you implement the <b>OnStateChanged</b>method.
    ///    
    HRESULT OnStateChanged(const(wchar)* pszPackageFullName, PACKAGE_EXECUTION_STATE pesNewState);
}

///Enables debugger developers to control the life cycle of a Windows Store app, such as suspending or resuming.
@GUID("F27C3930-8029-4AD1-94E3-3DBA417810C1")
interface IPackageDebugSettings : IUnknown
{
    ///Enables debug mode for the processes of the specified package.
    ///Params:
    ///    packageFullName = The package full name.
    ///    debuggerCommandLine = The command line to use to launch processes from this package. This parameter is optional.
    ///    environment = Any environment strings to pass to processes. This parameter is optional.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnableDebugging(const(wchar)* packageFullName, const(wchar)* debuggerCommandLine, 
                            const(wchar)* environment);
    ///Disables debug mode for the processes of the specified package.
    ///Params:
    ///    packageFullName = The package full name.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DisableDebugging(const(wchar)* packageFullName);
    ///Suspends the processes of the package if they are currently running.
    ///Params:
    ///    packageFullName = The package full name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_ILLEGAL_STATECHANGE</b></dt> </dl> </td> <td width="60%"> The process is
    ///    not currently running. </td> </tr> </table>
    ///    
    HRESULT Suspend(const(wchar)* packageFullName);
    ///Resumes the processes of the package if they are currently suspended.
    ///Params:
    ///    packageFullName = The package full name.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Resume(const(wchar)* packageFullName);
    ///Terminates all processes for the specified package.
    ///Params:
    ///    packageFullName = The package full name.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT TerminateAllProcesses(const(wchar)* packageFullName);
    ///Sets the session identifier.
    ///Params:
    ///    sessionId = The session identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetTargetSessionId(uint sessionId);
    ///Gets the background tasks that are provided by the specified package.
    ///Params:
    ///    packageFullName = The package full name to query for background tasks.
    ///    taskCount = The count of <i>taskIds</i> and <i>taskNames</i> entries.
    ///    taskIds = An array of background task identifiers. You can use these identifiers in the ActivateBackgroundTask method
    ///              to activate specified tasks.
    ///    taskNames = An array of task names that corresponds with background <i>taskIds</i>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnumerateBackgroundTasks(const(wchar)* packageFullName, uint* taskCount, GUID** taskIds, 
                                     ushort*** taskNames);
    ///Activates the specified background task.
    ///Params:
    ///    taskId = The identifier of the background task to activate.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ActivateBackgroundTask(GUID* taskId);
    ///Suspends and terminates the non-background portion of the apps associated with the specified package and cancels
    ///the background tasks associated with the package.
    ///Params:
    ///    packageFullName = The package full name.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StartServicing(const(wchar)* packageFullName);
    ///Completes the previous servicing operation that was started by a call to the StartServicing method.
    ///Params:
    ///    packageFullName = The package full name.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StopServicing(const(wchar)* packageFullName);
    ///Causes background tasks for the specified package to activate in the specified user session.
    ///Params:
    ///    packageFullName = The package full name.
    ///    sessionId = The identifier of the session which background tasks are redirected to.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StartSessionRedirection(const(wchar)* packageFullName, uint sessionId);
    ///Stops redirection of background tasks for the specified package.
    ///Params:
    ///    packageFullName = The package full name.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StopSessionRedirection(const(wchar)* packageFullName);
    ///Returns the current execution state of the specified package.
    ///Params:
    ///    packageFullName = Type: <b>LPCWSTR</b> The package full name.
    ///    packageExecutionState = Type: <b>PACKAGE_EXECUTION_STATE*</b>
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPackageExecutionState(const(wchar)* packageFullName, PACKAGE_EXECUTION_STATE* packageExecutionState);
    ///Register for package state-change notifications.
    ///Params:
    ///    packageFullName = The package full name.
    ///    pPackageExecutionStateChangeNotification = Package state-change notifications are delivered by the OnStateChanged function on
    ///                                               <i>pPackageExecutionStateChangeNotification</i>.
    ///    pdwCookie = A unique registration identifier for the current listener. Use this identifier to unregister for package
    ///                state-change notifications by using the UnregisterForPackageStateChanges method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RegisterForPackageStateChanges(const(wchar)* packageFullName, 
                                           IPackageExecutionStateChangeNotification pPackageExecutionStateChangeNotification, 
                                           uint* pdwCookie);
    ///Stops receiving package state-change notifications associated with a previous call to
    ///RegisterForPackageStateChanges.
    ///Params:
    ///    dwCookie = The notification to cancel. This identifier is returned by a previous call to the
    ///               RegisterForPackageStateChanges method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UnregisterForPackageStateChanges(uint dwCookie);
}

@GUID("6E3194BB-AB82-4D22-93F5-FABDA40E7B16")
interface IPackageDebugSettings2 : IPackageDebugSettings
{
    HRESULT EnumerateApps(const(wchar)* packageFullName, uint* appCount, ushort*** appUserModelIds, 
                          ushort*** appDisplayNames);
}

///Exposes methods to manage dependencies in process suspension scenarios. This interface is no longer supported on
///Windows 10, version 1809, and later versions.
@GUID("52B83A42-2543-416A-81D9-C0DE7969C8B3")
interface ISuspensionDependencyManager : IUnknown
{
    ///Registers the specified process as a child. This method is no longer supported on Windows 10, version 1809, and
    ///later versions.
    ///Params:
    ///    processHandle = Type: <b>HANDLE</b> The process to be registered as a child.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RegisterAsChild(HANDLE processHandle);
    ///Groups the specified child process with the parent process. This method is no longer supported on Windows 10,
    ///version 1809, and later versions.
    ///Params:
    ///    childProcessHandle = Type: <b>HANDLE</b> The child process to group with the parent process.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GroupChildWithParent(HANDLE childProcessHandle);
    ///Ungroups the specified child process from the parent process. This method is no longer supported on Windows 10,
    ///version 1809, and later versions.
    ///Params:
    ///    childProcessHandle = Type: <b>HANDLE</b> The child process to ungroup from the parent.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UngroupChildFromParent(HANDLE childProcessHandle);
}

///Provides a single method that enables an application to determine whether its host is in desktop or immersive mode.
@GUID("18B21AA9-E184-4FF0-9F5E-F882D03771B3")
interface IExecuteCommandApplicationHostEnvironment : IUnknown
{
    ///Determines whether the current application host environment is in the desktop or immersive mode.
    ///Params:
    ///    pahe = A pointer to a <b>AHE_TYPE</b> value that, when this method returns successfully, receives one of the
    ///           following values to indicate the current host environment.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetValue(AHE_TYPE* pahe);
}

///Provides a method that enables an IExplorerCommand-based Shell verb handler to query the UI mode of the host
///component from which the application was invoked.
@GUID("4B6832A2-5F04-4C9D-B89D-727A15D103E7")
interface IExecuteCommandHost : IUnknown
{
    ///Enables an IExplorerCommand-based Shell verb handler to query the UI mode of the host component from which the
    ///application was invoked.
    ///Params:
    ///    pUIMode = Type: <b>EC_HOST_UI_MODE*</b>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetUIMode(EC_HOST_UI_MODE* pUIMode);
}

///Enables development tool applications to dynamically spoof system and user states, such as native display resolution,
///device scale factor, and application view state, for the purpose of testing Windows Store apps running in design mode
///for a wide range of form factors without the need for the actual hardware. Also enables testing of changes in
///normally user-controlled state to test Windows Store apps under a variety of scenarios.
@GUID("2A3DEE9A-E31D-46D6-8508-BCC597DB3557")
interface IApplicationDesignModeSettings : IUnknown
{
    ///Sets a spoofed native display size to be used for a Windows Store app running in design mode. You must call
    ///IInitializeWithWindow::Initialize to set a proxy core window before calling this method.
    ///<b>SetNativeDisplaySize</b> must be called before calling ComputeApplicationSize.
    ///Params:
    ///    nativeDisplaySizePixels = The native size of the display to spoof, as a SIZE structure. The specified size will be normalized to a
    ///                              landscape orientation. To spoof orientation, see SetApplicationViewState.
    ///Returns:
    ///    If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code, including the
    ///    following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOT_SET</b></dt> </dl> </td> <td width="60%"> IInitializeWithWindow::Initialize has not been called
    ///    to set a proxy core window. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_MONITOR_RESOLUTION_TOO_LOW
    ///    </b></dt> </dl> </td> <td width="60%"> You cannot launch or switch to an immersive app when the resolution is
    ///    this low. This is currently defined as any resolution below 800 horizontal or 600 vertical pixels when in
    ///    landscape orientation. </td> </tr> </table>
    ///    
    HRESULT SetNativeDisplaySize(SIZE nativeDisplaySizePixels);
    ///Sets a spoofed device scale factor to be used for a Windows Store app running in design mode. You must call
    ///IInitializeWithWindow::Initialize to set a proxy core window before calling this method. <b>SetScaleFactor</b>
    ///must be called before calling ComputeApplicationSize.
    ///Params:
    ///    scaleFactor = One of the DEVICE_SCALE_FACTOR enumeration values that indicates the device scale factor to spoof.
    ///Returns:
    ///    If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code, including the
    ///    following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOT_SET</b></dt> </dl> </td> <td width="60%"> IInitializeWithWindow::Initialize has not been called
    ///    to set a proxy core window. </td> </tr> </table>
    ///    
    HRESULT SetScaleFactor(DEVICE_SCALE_FACTOR scaleFactor);
    ///Sets a spoofed application view state (full-screen landscape, full-screen portrait, filled, or snapped) to be
    ///used for a Windows Store app running in design mode. You must call IInitializeWithWindow::Initialize to set a
    ///proxy core window before calling this method. <b>SetApplicationViewState</b> must be called before calling
    ///ComputeApplicationSize.
    ///Params:
    ///    viewState = One of the APPLICATION_VIEW_STATE enumeration values that indicates the application view state to spoof.
    ///Returns:
    ///    If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code, including the
    ///    following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOT_SET</b></dt> </dl> </td> <td width="60%"> IInitializeWithWindow::Initialize has not been called
    ///    to set a proxy core window. </td> </tr> </table>
    ///    
    HRESULT SetApplicationViewState(APPLICATION_VIEW_STATE viewState);
    ///Gets the size of the Windows Store app, based on the current set of spoofed settings. You must call
    ///IInitializeWithWindow::Initialize to set a proxy core window before calling this method. In addition, each of
    ///these methods must be called before calling <b>ComputeApplicationSize</b>, or the call will fail. <ul> <li>
    ///SetApplicationViewState </li> <li> SetNativeDisplaySize </li> <li> SetScaleFactor </li> </ul>
    ///Params:
    ///    applicationSizePixels = When this method returns successfully, receives a pointer to the size that the Windows Store app should
    ///                            occupy, based on the current set of spoofed settings.
    ///Returns:
    ///    If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code, including the
    ///    following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOT_SET</b></dt> </dl> </td> <td width="60%"> IInitializeWithWindow::Initialize has not been called
    ///    to set a proxy core window. </td> </tr> </table>
    ///    
    HRESULT ComputeApplicationSize(SIZE* applicationSizePixels);
    ///Determines whether a particular application view state is supported for specific spoofed display size and scale
    ///factor settings. You must call IInitializeWithWindow::Initialize to set a proxy core window before calling this
    ///method.
    ///Params:
    ///    viewState = One of the enumeration values that indicates the application view state for which support is being
    ///                determined.
    ///    nativeDisplaySizePixels = The native size of the display to spoof.
    ///    scaleFactor = One of the enumeration values that indicates the device scale factor to spoof.
    ///    supported = When this method returns successfully, receives a pointer to a Boolean value which is set to <b>TRUE</b> if
    ///                the application view state is supported for the given display size and scale factor, and <b>FALSE</b> if it
    ///                is not.
    ///Returns:
    ///    If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code, including the
    ///    following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOT_SET</b></dt> </dl> </td> <td width="60%"> IInitializeWithWindow::Initialize has not been called
    ///    to set a proxy core window. </td> </tr> </table>
    ///    
    HRESULT IsApplicationViewStateSupported(APPLICATION_VIEW_STATE viewState, SIZE nativeDisplaySizePixels, 
                                            DEVICE_SCALE_FACTOR scaleFactor, int* supported);
    ///Sends a spoofed edge gesture event to the proxy core window on the caller's thread. This gesture toggles the
    ///app's app bar, if the app supports one. The caller can specify the type of input that triggered the edge gesture.
    ///You must call IInitializeWithWindow::Initialize to set a proxy core window before calling this method.
    ///Params:
    ///    edgeGestureKind = Indicates the <b>EDGE_GESTURE_KIND</b> input type that generated the spoofed edge gesture. If touch
    ///                      (<b>EGK_TOUCH</b>) is specified, both the <b>Starting</b> and <b>Completed</b> edge gesture events are sent.
    ///                      Otherwise, only the <b>Completed</b> event is sent. One of the following values:
    ///Returns:
    ///    If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code, including the
    ///    following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOT_SET</b></dt> </dl> </td> <td width="60%"> IInitializeWithWindow::Initialize has not been called
    ///    to set a proxy core window. </td> </tr> </table>
    ///    
    HRESULT TriggerEdgeGesture(EDGE_GESTURE_KIND edgeGestureKind);
}

///Enables development tool applications to dynamically control system and user states, such as native display
///resolution, device scale factor, and application view layout, reported to Windows Store apps for the purpose of
///testing Windows Store apps running in design mode for a wide range of form factors without the need for the actual
///hardware. Also enables testing of changes in normally user-controlled state to test Windows Store apps under a
///variety of scenarios.
@GUID("490514E1-675A-4D6E-A58D-E54901B4CA2F")
interface IApplicationDesignModeSettings2 : IApplicationDesignModeSettings
{
    ///Sets the orientation of the emulated display for the design mode window.
    ///Params:
    ///    nativeDisplayOrientation = Type: <b>NATIVE_DISPLAY_ORIENTATION</b> The native orientation of the display to emulate.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetNativeDisplayOrientation(NATIVE_DISPLAY_ORIENTATION nativeDisplayOrientation);
    ///Sets the window orientation used for the design mode window.
    ///Params:
    ///    viewOrientation = Type: <b>APPLICATION_VIEW_ORIENTATION</b> The orientation of the design mode window to use. Either
    ///                      <b>AVO_LANDSCAPE</b> or <b>AVO_PORTRAIT</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetApplicationViewOrientation(APPLICATION_VIEW_ORIENTATION viewOrientation);
    ///Sets whether the application window will be adjacent to the edge of the emulated display.
    ///Params:
    ///    adjacentDisplayEdges = Type: <b>ADJACENT_DISPLAY_EDGES</b> The edge which should be adjacent.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetAdjacentDisplayEdges(ADJACENT_DISPLAY_EDGES adjacentDisplayEdges);
    ///This method determines whether or not the application, in design mode, can display information on the Windows 8
    ///lock screen.
    ///Params:
    ///    isOnLockScreen = Type: <b>BOOL</b> When set to <b>TRUE</b>, the application will display information on the lock screen. When
    ///                     set to <b>FALSE</b>, information will not be displayed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetIsOnLockScreen(BOOL isOnLockScreen);
    ///Sets the desired minimum width of the application design mode window.
    ///Params:
    ///    viewMinWidth = Type: <b>APPLICATION_VIEW_MIN_WIDTH</b> The minimum width value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetApplicationViewMinWidth(APPLICATION_VIEW_MIN_WIDTH viewMinWidth);
    ///This methods retrieves the size bounds supported by the application.
    ///Params:
    ///    minApplicationSizePixels = Type: <b>SIZE*</b> When this method returns successfully, receives a pointer to a SIZE structure that defines
    ///                               the minimum possible window size.
    ///    maxApplicationSizePixels = Type: <b>SIZE*</b> When this method returns successfully, receives a pointer to a SIZE structure that defines
    ///                               the maximum possible window size.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetApplicationSizeBounds(SIZE* minApplicationSizePixels, SIZE* maxApplicationSizePixels);
    ///Gets the orientation of the application design mode window.
    ///Params:
    ///    applicationSizePixels = Type: <b>SIZE</b> The application window size.
    ///    viewOrientation = Type: <b>APPLICATION_VIEW_ORIENTATION*</b> When this method returns successfully, receives a pointer to an
    ///                      APPLICATION_VIEW_ORIENTATION structure.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetApplicationViewOrientation(SIZE applicationSizePixels, 
                                          APPLICATION_VIEW_ORIENTATION* viewOrientation);
}

///Provides a method for retrieving the target monitor for the application being launched.
@GUID("266FBC7E-490D-46ED-A96B-2274DB252003")
interface ILaunchTargetMonitor : IUnknown
{
    ///Retrieves the target monitor for the application being launched.
    ///Params:
    ///    monitor = Type: <b>HMONITOR*</b> Contains the address of a pointer to the target monitor's handle.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMonitor(ptrdiff_t* monitor);
}

///Provides methods for retrieving information about the source application.
@GUID("E5AA01F7-1FB8-4830-8720-4E6734CBD5F3")
interface ILaunchSourceViewSizePreference : IUnknown
{
    ///Retrieves the position of the source application window.
    ///Params:
    ///    hwnd = Type: <b>HWND*</b> Contains the address of a pointer to a window handle.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSourceViewToPosition(HWND* hwnd);
    ///Retrieves the view size preference of the application after the application has launched.
    ///Params:
    ///    sourceSizeAfterLaunch = Type: <b>APPLICATION_VIEW_SIZE_PREFERENCE*</b> Contains the address of a pointer to an
    ///                            APPLICATION_VIEW_SIZE_PREFERENCE.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSourceViewSizePreference(APPLICATION_VIEW_SIZE_PREFERENCE* sourceSizeAfterLaunch);
}

///Provides a method for retrieving the preferred view size for a new application window.
@GUID("2F0666C6-12F7-4360-B511-A394A0553725")
interface ILaunchTargetViewSizePreference : IUnknown
{
    ///Retrieves the preferred view size of the application being launched.
    ///Params:
    ///    targetSizeOnLaunch = Type: <b>APPLICATION_VIEW_SIZE_PREFERENCE*</b> Contains the address of a pointer to an
    ///                         APPLICATION_VIEW_SIZE_PREFERENCE for the target application.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTargetViewSizePreference(APPLICATION_VIEW_SIZE_PREFERENCE* targetSizeOnLaunch);
}

///Provides a method for retrieving an AppUserModelId.
@GUID("989191AC-28FF-4CF0-9584-E0D078BC2396")
interface ILaunchSourceAppUserModelId : IUnknown
{
    ///Retrieves an AppUserModelId from the source application.
    ///Params:
    ///    launchingApp = Type: <b>LPWSTR*</b> Contains a pointer to a string that contains the AppUserModelId.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAppUserModelId(ushort** launchingApp);
}

///Exposes a method through which a client can provide an owner window to a Windows Runtime object used in a desktop
///application.
@GUID("3E68D4BD-7135-4D10-8018-9FB6D9F33FA1")
interface IInitializeWithWindow : IUnknown
{
    ///Specifies an owner window to be used by a Windows Runtime object that is used in a desktop app.
    ///Params:
    ///    hwnd = The handle of the window to be used as the owner window.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(HWND hwnd);
}

///Supplies methods that provide information about the handler to methods of the IHandlerActivationHost interface.
@GUID("997706EF-F880-453B-8118-39E1A2D2655A")
interface IHandlerInfo : IUnknown
{
    ///Retrieves the display name of the application that implemented the handler.
    ///Params:
    ///    value = Type: <b>LPWSTR*</b> A pointer to a string that, when this method returns successfully, receives the display
    ///            name. If no display name could be found, the name of the application's .exe file is used.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetApplicationDisplayName(ushort** value);
    ///Retrieves the name of the publisher of the application that implemented the handler.
    ///Params:
    ///    value = Type: <b>LPWSTR*</b> A pointer to a string that, when this method returns successfully, receives the
    ///            publisher's name.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetApplicationPublisher(ushort** value);
    ///Retrieves the icon of the application that implemented the handler.
    ///Params:
    ///    value = Type: <b>LPWSTR*</b> A pointer to a string that, when this method returns successfully, receives the path of
    ///            the icon.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetApplicationIconReference(ushort** value);
}

@GUID("31CCA04C-04D3-4EA9-90DE-97B15E87A532")
interface IHandlerInfo2 : IHandlerInfo
{
    HRESULT GetApplicationId(ushort** value);
}

///Enables a client of Shell item activation (including callers of
///[ShellExecuteEx](../shellapi/nf-shellapi-shellexecuteexw.md) and
///[IContextMenu::InvokeCommand](./nf-shobjidl_core-icontextmenu-invokecommand.md)) to be given a chance to veto or
///perform some action before the activation of verb handlers.
@GUID("35094A87-8BB1-4237-96C6-C417EEBDB078")
interface IHandlerActivationHost : IUnknown
{
    ///Notifies a client of [ShellExecuteEx](../shellapi/nf-shellapi-shellexecuteexw.md) that a handler is about to be
    ///created, giving that client the opportunity to display UI confirming the use of that handler or reject it by
    ///returning a specific error code.
    ///Params:
    ///    clsidHandler = Identifies the handler.
    ///    itemsBeingActivated = The Shell item objects that will be passed to the handler. Typically there is only one, but in some cases
    ///                          there can be more than one.
    ///    handlerInfo = Provides access to information about the handler that will be invoked. This object also supports
    ///                  **IHandlerInfo2** on versions of Windows that support that interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code,
    ///    <b>HRESULT_FROM_WIN32(ERROR_CANCELLED)</b> inciates that the ShellExecute call should be canceled,
    ///    <b>EXECUTE_E_LAUNCH_APPLICATION</b> indicates that this handler should not be used, but if there is another
    ///    it should be used.
    ///    
    HRESULT BeforeCoCreateInstance(const(GUID)* clsidHandler, IShellItemArray itemsBeingActivated, 
                                   IHandlerInfo handlerInfo);
    ///Notifies a client of [ShellExecuteEx](../shellapi/nf-shellapi-shellexecuteexw.md) that a process is about to
    ///created, giving that client the opportunity to display UI confirming that or reject it by returning a specific
    ///error code.
    ///Params:
    ///    applicationPath = The fully qualified path to the process executable, or in some cases a DLL path.
    ///    commandLine = The full command line that will be passed to **CreateProcess** including the arguments that the handler
    ///                  requested via its registration.
    ///    handlerInfo = Provides access to information about the handler that will be invoked. This object also supports
    ///                  **IHandlerInfo2** on versions of windows that support that interface. This object also implements
    ///                  [IObjectWithSelection](./nn-shobjidl_core-iobjectwithselection.md). This can be used to get the Shell item,
    ///                  or items in some cases, that are being launched.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code,
    ///    <b>HRESULT_FROM_WIN32(ERROR_CANCELLED)</b> inciates that the ShellExecute call should be canceled.
    ///    
    HRESULT BeforeCreateProcess(const(wchar)* applicationPath, const(wchar)* commandLine, IHandlerInfo handlerInfo);
}

@GUID("ABAD189D-9FA3-4278-B3CA-8CA448A88DCB")
interface IAppActivationUIInfo : IUnknown
{
    HRESULT GetMonitor(ptrdiff_t* value);
    HRESULT GetInvokePoint(POINT* value);
    HRESULT GetShowCommand(int* value);
    HRESULT GetShowUI(int* value);
    HRESULT GetKeyState(uint* value);
}

///Enables access to <b>ContactManager</b> methods in an app that manages multiple windows.
@GUID("99EACBA7-E073-43B6-A896-55AFE48A0833")
interface IContactManagerInterop : IUnknown
{
    ///Displays the UI for a contact on the specified window.
    ///Params:
    ///    appWindow = Type: <b>HWND</b> The HWND of the foreground window of the app from which the contact card is launched and
    ///                where focus is returned when the contact card is dismissed.
    ///    contact = Type: <b>IUnknown*</b> A pointer to the contact object. Use a Windows.ApplicationModel.Contacts.Contact
    ///              object but cast to IUnknown here because classic COM IDL can't use Windows Runtime types.
    ///    selection = Type: <b>RECT const*</b> The Rect is the rectangular area of user selection (for example, pressing a button),
    ///                around which the operating system displays the contact card, not within that rectangular area. For example,
    ///                if an app uses a button to show the contact card, pass the <b>Rect</b> of the button so the contact card
    ///                displays around the button, not overlapping it.
    ///    preferredPlacement = Type: <b>FLYOUT_PLACEMENT</b> A <b>FLYOUT_PLACEMENT</b>-typed value that describes the preferred placement of
    ///                         the contact card. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                         id="FP_DEFAULT"></a><a id="fp_default"></a><dl> <dt><b>FP_DEFAULT</b></dt> <dt>0</dt> </dl> </td> <td
    ///                         width="60%"> Use the default. </td> </tr> <tr> <td width="40%"><a id="FP_ABOVE"></a><a id="fp_above"></a><dl>
    ///                         <dt><b>FP_ABOVE</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Prefer to place the contact card above the
    ///                         rectangular area of user selection specified by the <i>selection</i> parameter. </td> </tr> <tr> <td
    ///                         width="40%"><a id="FP_BELOW"></a><a id="fp_below"></a><dl> <dt><b>FP_BELOW</b></dt> <dt>2</dt> </dl> </td>
    ///                         <td width="60%"> Prefer to place the contact card below the rectangular area of user selection specified by
    ///                         the <i>selection</i> parameter. </td> </tr> <tr> <td width="40%"><a id="FP_LEFT"></a><a id="fp_left"></a><dl>
    ///                         <dt><b>FP_LEFT</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> Prefer to place the contact card to the left
    ///                         of the rectangular area of user selection specified by the <i>selection</i> parameter. </td> </tr> <tr> <td
    ///                         width="40%"><a id="FP_RIGHT"></a><a id="fp_right"></a><dl> <dt><b>FP_RIGHT</b></dt> <dt>4</dt> </dl> </td>
    ///                         <td width="60%"> Prefer to place the contact card to the right of the rectangular area of user selection
    ///                         specified by the <i>selection</i> parameter. </td> </tr> </table>
    ///Returns:
    ///    Type: <b>HRESULT</b> ShowContactCardForWindow returns: <ul> <li>S_OK if the contact card is successfully
    ///    displayed</li> <li>E_POINTER if <i>appWindow</i> is NULL or <i>contact</i> is NULL or <i>selection</i> is
    ///    NULL</li> <li>E_INVALIDARG if <i>contact</i> isn't a Windows.ApplicationModel.Contacts.Contact object or
    ///    <i>preferredPlacement</i> is an invalid enumeration value</li> </ul> Other HRESULT values are possible.
    ///    
    HRESULT ShowContactCardForWindow(HWND appWindow, IUnknown contact, const(RECT)* selection, 
                                     FLYOUT_PLACEMENT preferredPlacement);
}

///Exposes methods that handle all communication between icon overlay handlers and the Shell.
@GUID("0C6C4200-C589-11D0-999A-00C04FD655E1")
interface IShellIconOverlayIdentifier : IUnknown
{
    ///Specifies whether an icon overlay should be added to a Shell object's icon.
    ///Params:
    ///    pwszPath = Type: <b>PCWSTR</b> A Unicode string that contains the fully qualified path of the Shell object.
    ///    dwAttrib = Type: <b>DWORD</b> The object's attributes. For a complete list of file attributes and their associated
    ///               flags, see IShellFolder::GetAttributesOf.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns one of the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    icon overlay should be displayed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td>
    ///    <td width="60%"> The icon overlay should not be displayed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> </table>
    ///    
    HRESULT IsMemberOf(const(wchar)* pwszPath, uint dwAttrib);
    ///Provides the location of the icon overlay's bitmap.
    ///Params:
    ///    pwszIconFile = Type: <b>PWSTR</b> A null-terminated Unicode string that contains the fully qualified path of the file
    ///                   containing the icon. The .dll, .exe, and .ico file types are all acceptable. You must set the
    ///                   <b>ISIOI_ICONFILE</b> flag in <i>pdwFlags</i> if you return a file name.
    ///    cchMax = Type: <b>int</b> The size of the <i>pwszIconFile</i> buffer, in Unicode characters.
    ///    pIndex = Type: <b>int*</b> Pointer to an index value used to identify the icon in a file that contains multiple icons.
    ///             You must set the <b>ISIOI_ICONINDEX</b> flag in <i>pdwFlags</i> if you return an index.
    ///    pdwFlags = Type: <b>DWORD*</b> Pointer to a bitmap that specifies the information that is being returned by the method.
    ///               This parameter can be one or both of the following values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOverlayInfo(const(wchar)* pwszIconFile, int cchMax, int* pIndex, uint* pdwFlags);
    ///Specifies the priority of an icon overlay.
    ///Params:
    ///    pPriority = Type: <b>int*</b> The address of a value that indicates the priority of the overlay identifier. Possible
    ///                values range from zero to 100, with zero the highest priority.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error code otherwise.
    ///    
    HRESULT GetPriority(int* pPriority);
}

@GUID("8D7B2BA7-DB05-46A8-823C-D2B6DE08EE91")
interface IBannerNotificationHandler : IUnknown
{
    HRESULT OnBannerEvent(const(BANNER_NOTIFICATION)* notification);
}

@GUID("6DFC60FB-F2E9-459B-BEB5-288F1A7C7D54")
interface ISortColumnArray : IUnknown
{
    HRESULT GetCount(uint* columnCount);
    HRESULT GetAt(uint index, SORTCOLUMN* sortcolumn);
    HRESULT GetSortType(SORT_ORDER_TYPE* type);
}

@GUID("75BD59AA-F23B-4963-ABA4-0B355752A91B")
interface IPropertyKeyStore : IUnknown
{
    HRESULT GetKeyCount(int* keyCount);
    HRESULT GetKeyAt(int index, PROPERTYKEY* pkey);
    HRESULT AppendKey(const(PROPERTYKEY)* key);
    HRESULT DeleteKey(int index);
    HRESULT IsKeyInStore(const(PROPERTYKEY)* key);
    HRESULT RemoveKey(const(PROPERTYKEY)* key);
}

///Gets and sets the numeric value (Code Page identifier) of the ANSI code page.
@GUID("C7B236CE-EE80-11D0-985F-006008059382")
interface IQueryCodePage : IUnknown
{
    ///Retrieves the numeric value (Code Page identifier) of the ANSI code page.
    ///Params:
    ///    puiCodePage = Type: <b>UINT*</b> The numeric value (Code Page identifier) of the ANSI code page.
    HRESULT GetCodePage(uint* puiCodePage);
    ///Sets the numeric value of the ANSI code page to a specified code page identifier.
    ///Params:
    ///    uiCodePage = Type: <b>UINT</b> The numeric value of the ANSI code page you want to set.
    HRESULT SetCodePage(uint uiCodePage);
}

///Exposes methods that allow control of folder view options specific to the Windows 7 and later views.
@GUID("3CC974D2-B302-4D36-AD3E-06D93F695D3F")
interface IFolderViewOptions : IUnknown
{
    ///Sets specified options for the view.
    ///Params:
    ///    fvoMask = Type: <b>FOLDERVIEWOPTIONS</b> A bitmask made up of one or more of the FOLDERVIEWOPTIONS flags to indicate
    ///              which options' are being changed. Values in <i>fvoFlags</i> not included in this mask are ignored.
    ///    fvoFlags = Type: <b>FOLDERVIEWOPTIONS</b> A bitmask that contains the new values for the options specified in
    ///               <i>fvoMask</i>. To enable an option, the bitmask should include the FOLDERVIEWOPTIONS flag for that option.
    ///               To disable an option, the bit used for that <b>FOLDERVIEWOPTIONS</b> flag should be 0.
    HRESULT SetFolderViewOptions(FOLDERVIEWOPTIONS fvoMask, FOLDERVIEWOPTIONS fvoFlags);
    ///Retrieves the current set of options for the view.
    ///Params:
    ///    pfvoFlags = Type: <b>FOLDERVIEWOPTIONS*</b> A bitmask that, when this method returns successfully, receives the
    ///                FOLDERVIEWOPTIONS values that are currently set.
    HRESULT GetFolderViewOptions(FOLDERVIEWOPTIONS* pfvoFlags);
}

///Extends the capabilities of IShellView2 by providing a method to replace IShellView2::CreateViewWindow2.
@GUID("EC39FA88-F8AF-41C5-8421-38BED28F4673")
interface IShellView3 : IShellView2
{
    ///Requests the creation of a new Shell view window. The view can be either the right pane of Windows Explorer or
    ///the client window of a folder window. This method replaces CreateViewWindow2.
    ///Params:
    ///    psbOwner = Type: <b>IShellBrowser*</b> A pointer to an IShellBrowser interface to provide namespace extension services.
    ///    psvPrev = Type: <b>IShellView*</b> A pointer to an IShellView interface that represents the previous view in the
    ///              Windows Explorer or folder window.
    ///    dwViewFlags = Type: <b>SV3CVW3_FLAGS</b> Flags that specify details of the view being created.
    ///    dwMask = Type: <b>FOLDERFLAGS</b> A bitwise mask that specifies which folder options specified in <i>dwFlags</i> are
    ///             to be used.
    ///    dwFlags = Type: <b>FOLDERFLAGS</b> A bitwise value that contains the folder options, as FOLDERFLAGS, to use in the new
    ///              view.
    ///    fvMode = Type: <b>FOLDERVIEWMODE</b> A bitwise value that contains the folder view mode options, as FOLDERVIEWMODE, to
    ///             use in the new view.
    ///    pvid = Type: <b>const SHELLVIEWID*</b> A pointer to Shell view ID as a <b>GUID</b>.
    ///    prcView = Type: <b>const RECT*</b> A pointer to a <b>RECT</b> structure that provides the dimensions of the view
    ///              window.
    ///    phwndView = Type: <b>HWND*</b> A value that receives a pointer to the handle of the new Shell view window.
    HRESULT CreateViewWindow3(IShellBrowser psbOwner, IShellView psvPrev, uint dwViewFlags, FOLDERFLAGS dwMask, 
                              FOLDERFLAGS dwFlags, FOLDERVIEWMODE fvMode, const(GUID)* pvid, const(RECT)* prcView, 
                              HWND* phwndView);
}

///Exposes methods that allow the caller to retrieve information entered into a search box.
@GUID("6AF6E03F-D664-4EF4-9626-F7E0ED36755E")
interface ISearchBoxInfo : IUnknown
{
    ///Retrieves the contents of the search box as an ICondition object.
    ///Params:
    ///    riid = Type: <b>REFIID</b> A reference to the IID of the interface to retrieve through <i>ppv</i>, typically
    ///           IID_ICondition.
    ///    ppv = Type: <b>void**</b> When this method returns successfully, contains the interface pointer requested in
    ///          <i>riid</i>. This is typically ICondition.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCondition(const(GUID)* riid, void** ppv);
    ///Retrieves the contents of the search box as plain text.
    ///Params:
    ///    ppsz = Type: <b>LPWSTR*</b> Pointer to a buffer that, when this method returns successfully, receives the full text
    ///           entered in the search box.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetText(ushort** ppsz);
}

///Exposes methods that set and get visual properties.
@GUID("E693CF68-D967-4112-8763-99172AEE5E5A")
interface IVisualProperties : IUnknown
{
    ///Provides a bitmap to use as a watermark.
    ///Params:
    ///    hbmp = Type: <b>HBITMAP</b> A handle to the bitmap.
    ///    vpwf = Type: <b>VPWATERMARKFLAGS</b> VPWATERMARKFLAGS flags that customize the watermark.
    HRESULT SetWatermark(HBITMAP hbmp, VPWATERMARKFLAGS vpwf);
    ///Sets the color, as specified.
    ///Params:
    ///    vpcf = Type: <b>VPCOLORFLAGS</b> The color flags. See VPCOLORFLAGS.
    ///    cr = Type: <b>COLORREF</b> A value of type COLORREF
    HRESULT SetColor(VPCOLORFLAGS vpcf, uint cr);
    ///Gets the color, as specified.
    ///Params:
    ///    vpcf = Type: <b>VPCOLORFLAGS</b> The color flags. See VPCOLORFLAGS
    ///    pcr = Type: <b>COLORREF*</b> A pointer to a value of type COLORREF.
    HRESULT GetColor(VPCOLORFLAGS vpcf, uint* pcr);
    ///Sets the specified item height.
    ///Params:
    ///    cyItemInPixels = Type: <b>int</b> The item height, in pixels.
    HRESULT SetItemHeight(int cyItemInPixels);
    ///Gets the item height.
    ///Params:
    ///    cyItemInPixels = Type: <b>int*</b> A pointer to the item height, in pixels.
    HRESULT GetItemHeight(int* cyItemInPixels);
    ///Sets attributes of the font.
    ///Params:
    ///    plf = Type: <b>const LOGFONTW*</b> A pointer to a LOGFONT structure that contains the attributes to set.
    ///    bRedraw = Type: <b>BOOL</b> <b>TRUE</b> if the item should be redrawn after the new attributes are set; otherwise
    ///              <b>FALSE</b>.
    HRESULT SetFont(const(LOGFONTW)* plf, BOOL bRedraw);
    ///Gets the current attributes set on the font.
    ///Params:
    ///    plf = Type: <b>LOGFONTW*</b> A pointer to a LOGFONT structure that, when this method returns successfully, receives
    ///          the current attributes of the font.
    HRESULT GetFont(LOGFONTW* plf);
    ///Sets the specified theme.
    ///Params:
    ///    pszSubAppName = Type: <b>LPCWSTR</b> A pointer to a Unicode string that contains the application name to use in place of the
    ///                    calling application's name. If this parameter is <b>NULL</b>, the calling application's name is used.
    ///    pszSubIdList = Type: <b>LPCWSTR</b> A pointer to a Unicode string that contains a semicolon-separated list of CLSID names
    ///                   for use in place of the actual list passed by the window's class. If this parameter is <b>NULL</b>, the ID
    ///                   list from the calling class is used.
    HRESULT SetTheme(const(wchar)* pszSubAppName, const(wchar)* pszSubIdList);
}

///Extends the capabilities of ICommDlgBrowser2, and used by the common file dialog boxes when they host a Shell
///browser.
@GUID("C8AD25A1-3294-41EE-8165-71174BD01C57")
interface ICommDlgBrowser3 : ICommDlgBrowser2
{
    ///Called after a specified column is clicked in the IShellView interface.
    ///Params:
    ///    ppshv = Type: <b>IShellView*</b> A pointer to the IShellView interface of the hosted view.
    ///    iColumn = Type: <b>int</b> The index of the column clicked.
    HRESULT OnColumnClicked(IShellView ppshv, int iColumn);
    ///Gets the current filter as a Unicode string.
    ///Params:
    ///    pszFileSpec = Type: <b>LPWSTR</b> Contains a pointer to the current filter path/file as a Unicode string.
    ///    cchFileSpec = Type: <b>int</b> Specifies the path/file length, in characters.
    HRESULT GetCurrentFilter(const(wchar)* pszFileSpec, int cchFileSpec);
    ///Called after a specified preview is created in the IShellView interface.
    ///Params:
    ///    ppshv = Type: <b>IShellView*</b> A pointer to the IShellView interface of the hosted view.
    HRESULT OnPreViewCreated(IShellView ppshv);
}

///Exposes a method which is called when the picture that represents a user account is changed.
@GUID("A561E69A-B4B8-4113-91A5-64C6BCCA3430")
interface IUserAccountChangeCallback : IUnknown
{
    ///Called to send notifications when the picture that represents a user account is changed.
    ///Params:
    ///    pszUserName = Type: <b>LPCWSTR</b> Pointer to a string that contains the user name. Set this parameter to <b>NULL</b> to
    ///                  specify the current user.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnPictureChange(const(wchar)* pszUserName);
}

///Exposes methods to manage input/outpout (I/O) to an asynchronous stream.
@GUID("FE0B6665-E0CA-49B9-A178-2B5CB48D92A5")
interface IStreamAsync : IStream
{
    ///Reads information from a stream asynchronously. For example, the Shell implements this interface on file items
    ///when transferring them asynchronously.
    ///Params:
    ///    pv = Type: <b>void*</b> When this method returns successfully, returns a buffer that is <i>cb</i> bytes long and
    ///         contains <i>pcbRead</i> bytes of information from the read operation.
    ///    cb = Type: <b>DWORD</b> The number of bytes to read from the stream.
    ///    pcbRead = Type: <b>LPDWORD</b> Pointer to a <b>DWORD</b> value that, when this method returns successfully, states the
    ///              actual number of bytes read to the buffer pointed to by <i>pv</i>. This value can be <b>NULL</b>.
    ///    lpOverlapped = Type: <b>LPOVERLAPPED</b> A pointer to an OVERLAPPED structure that contains information used in the
    ///                   asynchronous read operation.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ReadAsync(char* pv, uint cb, uint* pcbRead, OVERLAPPED* lpOverlapped);
    ///Writes information to a stream asynchronously. For example, the Shell implements this method on file items when
    ///transferring them asynchronously.
    ///Params:
    ///    lpBuffer = Type: <b>const void*</b> A pointer to a buffer of size <i>cb</i> bytes that contains the information to be
    ///               written to the stream.
    ///    cb = Type: <b>DWORD</b> The size of the buffer pointed to by <i>lpBuffer</i>, in bytes.
    ///    pcbWritten = Type: <b>LPDWORD</b> Pointer to a <b>DWORD</b> value that, when the method returns successfully, states the
    ///                 actual number of bytes written to the stream. This value can be <b>NULL</b> if this information is not
    ///                 needed.
    ///    lpOverlapped = Type: <b>LPOVERLAPPED</b> A pointer to an OVERLAPPED structure that contains information used in the
    ///                   asynchronous write operation.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT WriteAsync(char* lpBuffer, uint cb, uint* pcbWritten, OVERLAPPED* lpOverlapped);
    ///Retrieves the results of an overlapped operation.
    ///Params:
    ///    lpOverlapped = Type: <b>LPOVERLAPPED*</b> A pointer to the OVERLAPPED structure that was specified when the overlapped
    ///                   operation was started.
    ///    lpNumberOfBytesTransferred = Type: <b>LPDWORD</b> When this method returns, contains the number of bytes that were actually transferred by
    ///                                 a read or write operation.
    ///    bWait = Type: <b>BOOL</b> If <b>TRUE</b> the method does not return until the operation has been completed. If
    ///            <b>FALSE</b> and an operation is pending, the method returns the HRESULT equivalent to ERROR_IO_INCOMPLETE.
    HRESULT OverlappedResult(OVERLAPPED* lpOverlapped, uint* lpNumberOfBytesTransferred, BOOL bWait);
    ///Marks all pending input/output (I/O) operations as canceled.
    HRESULT CancelIo();
}

///Exposes a method that determines the sector size as an aid to byte alignment.
@GUID("8A68FDDA-1FDC-4C20-8CEB-416643B5A625")
interface IStreamUnbufferedInfo : IUnknown
{
    ///Retrieves the number of bytes per sector on the disk currently being used. When using unbuffered input/output
    ///(I/O), it is important to know the size of the sectors on the disk being read in order to ensure proper byte
    ///alignment.
    ///Params:
    ///    pcbSectorSize = Type: <b>ULONG*</b> When this method returns successfully, contains a pointer to a <b>ULONG</b> value that
    ///                    represents the number of bytes per sector for the disk.
    HRESULT GetSectorSize(uint* pcbSectorSize);
}

///Exposes a method that adds functionality to IDragSourceHelper. This method sets the characteristics of a
///drag-and-drop operation over an <b>IDragSourceHelper</b> object.
@GUID("83E07D0D-0C5F-4163-BF1A-60B274051E40")
interface IDragSourceHelper2 : IDragSourceHelper
{
    ///Sets the characteristics of a drag-and-drop operation over an IDragSourceHelper object.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> The flags that determine the characteristics of a drag-and-drop operation over an
    ///              IDragSourceHelper object.
    HRESULT SetFlags(uint dwFlags);
}

///Called by AutoPlay to implement the handling of registered media types.
@GUID("C1FB73D0-EC3A-4BA2-B512-8CDB9187B6D1")
interface IHWEventHandler : IUnknown
{
    ///Initializes an object that contains an implementation of the IHWEventHandler interface.
    ///Params:
    ///    pszParams = Type: <b>LPCWSTR</b> A pointer to a string buffer that contains the string from the following registry value.
    ///                <pre xml:space="preserve"><b>HKEY_LOCAL_MACHINE</b> <b>Software</b> <b>Microsoft</b> <b>Windows</b>
    ///                <b>CurrentVersion</b> <b>Explorer</b> <b>AutoPlayHandlers</b> <b>Handlers</b> <i>HandlerName</i>
    ///                <b>InitCmdLine</b> = string</pre>
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(const(wchar)* pszParams);
    ///Handles AutoPlay device events for which there is no content of the type the application is registered to handle.
    ///Params:
    ///    pszDeviceID = Type: <b>LPCWSTR</b> A pointer to a string buffer that contains the device ID.
    ///    pszAltDeviceID = Type: <b>LPCWSTR</b> A pointer to a string buffer that contains the alternate device ID. The alternate device
    ///                     ID is more human-readable than the primary device ID.
    ///    pszEventType = Type: <b>LPCWSTR</b> A pointer to a string buffer that contains the event type. The event types include
    ///                   DeviceArrival, DeviceRemoval, MediaArrival, and MediaRemoval.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT HandleEvent(const(wchar)* pszDeviceID, const(wchar)* pszAltDeviceID, const(wchar)* pszEventType);
    ///Not implemented.
    ///Params:
    ///    pszDeviceID = This parameter is unused.
    ///    pszAltDeviceID = This parameter is unused.
    ///    pszEventType = This parameter is unused.
    ///    pszContentTypeHandler = This parameter is unused.
    ///    pdataobject = This parameter is unused.
    HRESULT HandleEventWithContent(const(wchar)* pszDeviceID, const(wchar)* pszAltDeviceID, 
                                   const(wchar)* pszEventType, const(wchar)* pszContentTypeHandler, 
                                   IDataObject pdataobject);
}

///Extends the IHWEventHandler interface to address User Account Control (UAC) elevation for device handlers.
@GUID("CFCC809F-295D-42E8-9FFC-424B33C487E6")
interface IHWEventHandler2 : IHWEventHandler
{
    ///Handles AutoPlay device events that contain content types that the application is not registered to handle. This
    ///method provides a handle to the owner window so that UI can be displayed if the process requires elevated
    ///privileges.
    ///Params:
    ///    pszDeviceID = Type: <b>LPCWSTR</b> A pointer to a string buffer that contains the device ID.
    ///    pszAltDeviceID = Type: <b>LPCWSTR</b> A pointer to a string buffer that contains the alternate device ID. The alternate device
    ///                     ID is more human-readable than the primary device ID.
    ///    pszEventType = Type: <b>LPCWSTR</b> A pointer to a string buffer that contains the event type. The event types include
    ///                   DeviceArrival, DeviceRemoval, MediaArrival, and MediaRemoval.
    ///    hwndOwner = Type: <b>HWND</b> A handle to the AutoPlay dialog that was displayed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT HandleEventWithHWND(const(wchar)* pszDeviceID, const(wchar)* pszAltDeviceID, 
                                const(wchar)* pszEventType, HWND hwndOwner);
}

///Exposes a method that programmatically overrides AutoPlay or AutoRun. This allows you to customize the location and
///type of content that is launched when media is inserted.
@GUID("DDEFE873-6997-4E68-BE26-39B633ADBE12")
interface IQueryCancelAutoPlay : IUnknown
{
    ///Determines whether to play media inserted by a user and if so using what restrictions.
    ///Params:
    ///    pszPath = Type: <b>LPCWSTR</b> The drive letter in the form <b>D:\\</b>
    ///    dwContentType = Type: <b>DWORD</b> The type of content as specified by the following flags.
    ///    pszLabel = Type: <b>LPCWSTR</b> The media label.
    ///    dwSerialNumber = Type: <b>DWORD</b> The media serial number.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK to allow AutoRun or S_FALSE to cancel AutoRun.
    ///    
    HRESULT AllowAutoPlay(const(wchar)* pszPath, uint dwContentType, const(wchar)* pszLabel, uint dwSerialNumber);
}

///Called by AutoPlay. Exposes methods that get dynamic information regarding a registered handler prior to displaying
///it to the user.
@GUID("DC2601D7-059E-42FC-A09D-2AFD21B6D5F7")
interface IDynamicHWHandler : IUnknown
{
    ///Called by the system to determine whether a particular handler will be shown before the AutoPlay dialog is
    ///displayed.
    ///Params:
    ///    pszDeviceID = Type: <b>LPCWSTR</b> A pointer to a string that indicates the device path or drive root.
    ///    dwContentType = Type: <b>DWORD</b> The content type.
    ///    ppszAction = Type: <b>LPWSTR*</b> A pointer to the new action string, or <b>NULL</b> if the default action string is to be
    ///                 used.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if this handler is to be displayed, S_FALSE if it is to be hidden, or an
    ///    error value otherwise.
    ///    
    HRESULT GetDynamicInfo(const(wchar)* pszDeviceID, uint dwContentType, ushort** ppszAction);
}

///Exposes a method for the handling of a mouse click or shortcut menu access in a notification balloon. Used with
///IUserNotification2::Show.
@GUID("19108294-0441-4AFF-8013-FA0A730B0BEA")
interface IUserNotificationCallback : IUnknown
{
    ///Called when the user clicks the balloon. The application may respond with an action that is suitable for the
    ///balloon being clicked.
    ///Params:
    ///    pt = Type: <b>POINT*</b> Takes a pointer to the POINT structure which, upon method return, points to the position
    ///         of the mouse in screen space where the mouse click occurred.
    HRESULT OnBalloonUserClick(POINT* pt);
    ///Called when the user clicks the icon in the notification area. The applications may launch some customary UI in
    ///response.
    ///Params:
    ///    pt = Type: <b>POINT*</b> Takes a pointer to the POINT structure which, when the method returns, points to the
    ///         position of the mouse in the screen space where the mouse click occurred.
    HRESULT OnLeftClick(POINT* pt);
    ///Called when the user right-clicks (or presses SHIFT+F10) the icon in the notification area. The application
    ///should show its context menu in response.
    ///Params:
    ///    pt = Type: <b>POINT*</b> When returned by the method, takes a pointer to the POINT structure at the position of
    ///         the mouse in the screen space where the click occurred. In the case where user presses SHIFT+F10, the pointer
    ///         points to the center of the icon in the screen space.
    HRESULT OnContextMenu(POINT* pt);
}

///Exposes methods that set notification information and then display that notification to the user in a balloon that
///appears in conjunction with the notification area of the taskbar. <div class="alert"><b>Note</b>
///<b>IUserNotification2</b> does not inherit from IUserNotification. <b>IUserNotification2</b> differs from
///<b>IUserNotification</b> only in its Show method, which adds an additional parameter for a callback interface to
///communicate with the notification. Otherwise the two interfaces are identical in form and function.
///CLSID_UserNotification implements both versions of <b>Show</b> as an overload.</div><div> </div>
@GUID("215913CC-57EB-4FAB-AB5A-E5FA7BEA2A6C")
interface IUserNotification2 : IUnknown
{
    ///Sets the information to be displayed in a balloon notification.
    ///Params:
    ///    pszTitle = Type: <b>LPCWSTR</b> A pointer to a Unicode string that specifies the title of the notification.
    ///    pszText = Type: <b>LPCWSTR</b> A pointer to a Unicode string that specifies the text to be displayed in the body of the
    ///              balloon.
    ///    dwInfoFlags = Type: <b>DWORD</b> One or more of the following values that indicate an icon to display in the notification
    ///                  balloon.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetBalloonInfo(const(wchar)* pszTitle, const(wchar)* pszText, uint dwInfoFlags);
    ///Specifies the conditions for trying to display user information when the first attempt fails.
    ///Params:
    ///    dwShowTime = Type: <b>DWORD</b> The amount of time, in milliseconds, to display the user information.
    ///    dwInterval = Type: <b>DWORD</b> The interval of time, in milliseconds, between attempts to display the user information.
    ///    cRetryCount = Type: <b>UINT</b> The number of times the system should try to display the user information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetBalloonRetry(uint dwShowTime, uint dwInterval, uint cRetryCount);
    ///Sets the notification area icon associated with specific user information.
    ///Params:
    ///    hIcon = Type: <b>HICON</b> A handle to the icon.
    ///    pszToolTip = Type: <b>LPCWSTR</b> A pointer to a string that contains the tooltip text to display for the specified icon.
    ///                 This value can be <b>NULL</b>, although it is not recommended.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetIconInfo(HICON hIcon, const(wchar)* pszToolTip);
    ///Displays the user information in a balloon-style tooltip.
    ///Params:
    ///    pqc = Type: <b>IQueryContinue*</b> An IQueryContinue interface pointer, used to determine whether the notification
    ///          display can continue or should stop (for example, if the user closes the notification). This value can be
    ///          <b>NULL</b>.
    ///    dwContinuePollInterval = Type: <b>DWORD</b> The length of time, in milliseconds, to display user information.
    ///    pSink = Type: <b>IUserNotificationCallback*</b> A pointer to an IUserNotificationCallback interface, used to handle
    ///            mouse click and hover actions on the notification area icon and within the notification itself. This value
    ///            can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Show(IQueryContinue pqc, uint dwContinuePollInterval, IUserNotificationCallback pSink);
    HRESULT PlaySoundA(const(wchar)* pszSoundName);
}

///Exposes methods to enable and query translucency effects in a deskband object. <div class="alert"><b>Important</b>
///You should use thumbnail toolbars in new development in place of desk bands, which are not supported as of Windows
///7.</div><div> </div>
@GUID("79D16DE4-ABEE-4021-8D9D-9169B261D657")
interface IDeskBand2 : IDeskBand
{
    ///Indicates the deskband's ability to be displayed as translucent. <div class="alert"><b>Important</b> You should
    ///use thumbnail toolbars in new development in place of desk bands, which are not supported as of Windows
    ///7.</div><div> </div>
    ///Params:
    ///    pfCanRenderComposited = Type: <b>BOOL*</b> When this method returns, contains a <b>BOOL</b> indicating ability.
    HRESULT CanRenderComposited(int* pfCanRenderComposited);
    ///Sets the composition state. <div class="alert"><b>Important</b> You should use thumbnail toolbars in new
    ///development in place of desk bands, which are not supported as of Windows 7.</div><div> </div>
    ///Params:
    ///    fCompositionEnabled = Type: <b>BOOL</b> <b>TRUE</b> to enable the composition state; otherwise, <b>FALSE</b>.
    HRESULT SetCompositionState(BOOL fCompositionEnabled);
    ///Gets the composition state. <div class="alert"><b>Important</b> You should use thumbnail toolbars in new
    ///development in place of desk bands, which are not supported as of Windows 7.</div><div> </div>
    ///Params:
    ///    pfCompositionEnabled = Type: <b>BOOL*</b> When this method returns, contains a <b>BOOL</b> that indicates state.
    HRESULT GetCompositionState(int* pfCompositionEnabled);
}

///Exposes a method that unpins an application shortcut from the <b>Start</b> menu or the taskbar.
@GUID("4CD19ADA-25A5-4A32-B3B7-347BEE5BE36B")
interface IStartMenuPinnedList : IUnknown
{
    ///<b>Windows Vista</b>: Removes an item from the <b>Start</b> menu pinned list, which is the list in the upper left
    ///position of the <b>Start</b> menu. <b>Windows 7</b>: Removes an item from the <b>Start</b> menu pinned list and
    ///unpins the item from the taskbar. <b>Windows 8</b>: Unpins the item from the taskbar but does not remove the item
    ///from the Start screen. Items cannot be programmatically removed from Start; they can only be unpinned by the user
    ///or removed as part of a program's uninstallation.
    ///Params:
    ///    pitem = Type: <b>IShellItem*</b> A pointer to an IShellItem object that represents the item to unpin.
    ///Returns:
    ///    Type: <b>HRESULT</b> <ul> <li>Returns S_OK if the item was successfully removed from the list of pinned items
    ///    and/or the taskbar.</li> <li>Returns S_OK if the item was not pinned at all.</li> <li>Returns a standard
    ///    error code otherwise.</li> </ul>
    ///    
    HRESULT RemoveFromList(IShellItem pitem);
}

///Exposes methods that determine whether a system has hardware for writing to CD, the drive letter of a CD writer
///device, and programmatically initiate a CD writing session.
@GUID("3D73A659-E5D0-4D42-AFC0-5121BA425C8D")
interface ICDBurn : IUnknown
{
    ///Gets the drive letter of a CD drive that has been marked as write-enabled.
    ///Params:
    ///    pszDrive = Type: <b>LPWSTR</b> A pointer to a string containing the drive letter, for example "F:\".
    ///    cch = Type: <b>UINT</b> The size of the string, in characters, pointed to by pszDrive. This value will normally be
    ///          4. Values larger than 4 are allowed, but the extra characters will be ignored by this method. Values less
    ///          than 4 will generate an E_INVALIDARG error.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecorderDriveLetter(const(wchar)* pszDrive, uint cch);
    ///Instructs data to be copied from the staging area to a writable CD.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the parent window of the UI.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Burn(HWND hwnd);
    ///Scans the system for a CD drive with write-capability, returning <b>TRUE</b> if one is found.
    ///Params:
    ///    pfHasRecorder = Type: <b>BOOL*</b> A pointer to a Boolean value containing <b>TRUE</b> if a suitable device is located,
    ///                    <b>FALSE</b> otherwise.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT HasRecordableDrive(int* pfHasRecorder);
}

///Exposes methods used by a wizard extension to navigate the borders between itself and the rest of the wizard.
@GUID("88960F5B-422F-4E7B-8013-73415381C3C3")
interface IWizardSite : IUnknown
{
    ///Called when the user navigates backward out of the wizard extension. Gets the handle of the PROPSHEETPAGE that
    ///represents the wizard page that is before the wizard extension page.
    ///Params:
    ///    phpage = Type: <b>HPROPSHEETPAGE*</b> A pointer to a variable handle of type PROPSHEETPAGE that represents the wizard
    ///             page that comes immediately before the wizard extension page.
    HRESULT GetPreviousPage(HPROPSHEETPAGE* phpage);
    ///Called when the user navigates forward past the wizard extension pages. Gets the handle of the PROPSHEETPAGE that
    ///represents the wizard page immediately following the wizard extension page.
    ///Params:
    ///    phpage = Type: <b>HPROPSHEETPAGE*</b> A pointer to a handle variable of type PROPSHEETPAGE for the wizard page
    ///             following the extension page.
    HRESULT GetNextPage(HPROPSHEETPAGE* phpage);
    ///Called when the user cancels navigation through the wizard extension. Gets the handle of the PROPSHEETPAGE that
    ///represents the wizard page to display when the user cancels navigation while in the wizard extension.
    ///Params:
    ///    phpage = Type: <b>HPROPSHEETPAGE*</b> A pointer to a handle variable of type PROPSHEETPAGE that receives the wizard
    ///             page to display when the user cancels navigation while in the wizard extension.
    HRESULT GetCancelledPage(HPROPSHEETPAGE* phpage);
}

///Used by wizards such as the Web Publishing Wizard and Online Print Ordering Wizard which host server-side content
///pages. This interface exposes methods to specify supported extension pages and to navigate into and out of those
///pages.
@GUID("C02EA696-86CC-491E-9B23-74394A0444A8")
interface IWizardExtension : IUnknown
{
    ///Adds extension pages to the wizard by filling an array with handles to PROPSHEETPAGE structures representing
    ///those pages.
    ///Params:
    ///    aPages = Type: <b>HPROPSHEETPAGE*</b> A pointer to an array of PROPSHEETPAGE handles that represent the wizard dialog
    ///             pages. Handles to <b>PROPSHEETPAGE</b> structures for the extension pages are added to this array.
    ///    cPages = Type: <b>UINT</b> The count of elements in <i>aPages</i>.
    ///    pnPagesAdded = Type: <b>UINT*</b> The count of handles successfully added.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddPages(char* aPages, uint cPages, uint* pnPagesAdded);
    ///Gets a handle to the first page of the wizard extension.
    ///Params:
    ///    phpage = Type: <b>HPROPSHEETPAGE*</b> A pointer to a PROPSHEETPAGE handle representing the first page of any wizard
    ///             extension pages.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFirstPage(HPROPSHEETPAGE* phpage);
    ///Gets a handle to the final page of the wizard extension pages.
    ///Params:
    ///    phpage = Type: <b>HPROPSHEETPAGE*</b> A pointer to a PROPSHEETPAGE handle representing the wizard extension's final
    ///             page.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLastPage(HPROPSHEETPAGE* phpage);
}

///Extends the IWizardExtension interface by exposing methods to set the wizard extension's initial URL, and a specific
///URL in case of an error.
@GUID("0E6B3F66-98D1-48C0-A222-FBDE74E2FBC5")
interface IWebWizardExtension : IWizardExtension
{
    ///Sets the URL of the initial server-provided HTML page in a hosted wizard.
    ///Params:
    ///    pszURL = Type: <b>LPCWSTR</b> The URL of the initial server-provided HTML page.
    HRESULT SetInitialURL(const(wchar)* pszURL);
    ///Specifies the URL of a page that displays when a user experiences an error while navigating through the wizard
    ///extension pages.
    ///Params:
    ///    pszErrorURL = Type: <b>LPCWSTR</b> The URL of the page to display.
    HRESULT SetErrorURL(const(wchar)* pszErrorURL);
}

///Exposes methods for working with the Online Print Wizard, the Web Publishing Wizard, and the Add Network Place
///Wizard. In Windows Vista, <b>IPublishingWizard</b> no longer supports the Web Publishing Wizard or Online Print
///Wizard.
@GUID("AA9198BB-CCEC-472D-BEED-19A4F6733F7A")
interface IPublishingWizard : IWizardExtension
{
    ///Initializes the Publishing Wizard object with the files to transfer, the settings to use, and the type of wizard
    ///to create. <div class="alert"><b>Note</b> Windows Vista no longer supports the Online Print Wizard. However, this
    ///method can still be used to generate the Add Network Place Wizard.</div><div> </div>
    ///Params:
    ///    pdo = Type: <b>IDataObject*</b> A pointer to an instance of IDataObject that represents the files or folder to be
    ///          transferred, if <i>pszServiceProvider</i> is <code>InternetPhotoPrinting</code>. If <i>pszServiceProvider</i>
    ///          is <code>AddNetPlace</code>, this parameter is <b>NULL</b>.
    ///    dwOptions = Type: <b>DWORD</b> A combination of the following flags.
    ///    pszServiceScope = Type: <b>LPCWSTR</b> Unicode string that indicates the type of wizard to display. The following
    ///                      case-sensitive values are supported in Windows Vista.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful or an error value otherwise, including the following: <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> In Windows Vista, may indicate an attempt to initialize the unsupported Online
    ///    Print Wizard by passing <code>InternetPhotoPrinting</code> in <i>pszServiceProvider</i>. In Windows XP, may
    ///    indicate that when initializing the Online Print Wizard, the <i>pdo</i> parameter is <b>NULL</b> or points to
    ///    an empty selection. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pszServiceProvider</i> parameter is not one of the supported values or the
    ///    <i>dwOptions</i> parameter contains an unsupported combination of flags. </td> </tr> </table>
    ///    
    HRESULT Initialize(IDataObject pdo, uint dwOptions, const(wchar)* pszServiceScope);
    ///Gets a transfer manifest for a file transfer operation performed by a publishing wizard, such as the Online Print
    ///Wizard or the Add Network Place Wizard. <div class="alert"><b>Note</b> This method is deprecated for Windows
    ///Vista, as it is not supported for Online Print Wizard or Add Network Place Wizard.</div><div> </div>
    ///Params:
    ///    phrFromTransfer = Type: <b>HRESULT*</b> A pointer to a variable of type <b>HRESULT</b> that, when this method returns, is set
    ///                      to S_OK if the transfer operation was successful, S_FALSE if the transfer has not yet begun, or a standard
    ///                      error value if the transfer has failed or has been canceled. This value can be <b>NULL</b> if you do not
    ///                      require this information.
    ///    pdocManifest = Type: <b>IXMLDOMDocument**</b> Address of an IXMLDOMDocument interface pointer that, when this method
    ///                   returns, points to the <b>IXMLDOMDocument interface</b> object that represents the manifest. This value can
    ///                   be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the manifest is successfully retrieved or a standard COM error value
    ///    otherwise, including the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The transfer manifest has not yet
    ///    been created. </td> </tr> </table>
    ///    
    HRESULT GetTransferManifest(int* phrFromTransfer, IXMLDOMDocument* pdocManifest);
}

///Exposes a method that hosts an IFolderView object in a window.
@GUID("1EA58F02-D55A-411D-B09E-9E65AC21605B")
interface IFolderViewHost : IUnknown
{
    ///Initializes the object that hosts an IFolderView object.
    ///Params:
    ///    hwndParent = Type: <b>HWND</b> The handle of the window that contains the IFolderViewHost object.
    ///    pdo = Type: <b>IDataObject*</b> The address of a pointer to a data object.
    ///    prc = Type: <b>RECT*</b> The address of a pointer to a <b>RECT</b> structure that specifies the dimensions of the
    ///          folder view.
    HRESULT Initialize(HWND hwndParent, IDataObject pdo, RECT* prc);
}

///Exposes a method that can be used by an accessibility application.
@GUID("95A391C5-9ED4-4C28-8401-AB9E06719E11")
interface IAccessibleObject : IUnknown
{
    ///Sets text that is retrieved by IAccessible::get_accName which accessibility tools use to obtain the Name Property
    ///of an object.
    ///Params:
    ///    pszName = Type: <b>LPCWSTR</b> A pointer to a null-terminated, Unicode string containing the name.
    HRESULT SetAccessibleName(const(wchar)* pszName);
}

///Exposes methods that hold items from a data object. An <b>IResultsFolder</b> is a folder that can hold items from all
///over the namespace and represent them to the user in a single folder.
@GUID("96E5AE6D-6AE1-4B1C-900C-C6480EAA8828")
interface IResultsFolder : IUnknown
{
    ///Adds an item to a results folder.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to an IShellItem.
    HRESULT AddItem(IShellItem psi);
    ///Inserts a pointer to an item identifier list (PIDL) into a results folder.
    ///Params:
    ///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> A pointer to the IDList of the given object relative to the Desktop.
    ///    ppidlAdded = Type: <b>PITEMID_CHILD*</b> A PIDL consisting of 0 or 1 SHITEMID structures, relative to a parent folder.
    ///                 This parameter maybe <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddIDList(ITEMIDLIST* pidl, ITEMIDLIST** ppidlAdded);
    ///Removes an item from a results folder.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to an IShellItem.
    HRESULT RemoveItem(IShellItem psi);
    ///Removes a pointer to an item identifier list (PIDL) from a results folder.
    ///Params:
    ///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL relative to the Desktop.
    HRESULT RemoveIDList(ITEMIDLIST* pidl);
    ///Removes all items from a results folder.
    HRESULT RemoveAll();
}

///Exposes methods that allow clients to reset or query the display state of the autocomplete drop-down list, which
///contains possible completions to a string entered by the user in an edit control.
@GUID("3CD141F4-3C6A-11D2-BCAA-00C04FD929DB")
interface IAutoCompleteDropDown : IUnknown
{
    ///Gets the current display status of the autocomplete drop-down list.
    ///Params:
    ///    pdwFlags = Type: <b>DWORD*</b> A pointer to a value indicating whether the autocomplete drop-down list is currently
    ///               displayed. This parameter can be <b>NULL</b> on entry if this information is not needed. The following values
    ///               are recognized as the target of this pointer.
    ///    ppwszString = Type: <b>LPWSTR*</b> A pointer to a buffer containing the first select item in the drop-down list, if the
    ///                  value pointed to by <i>pdwFlags</i> is <b>ACDD_VISIBLE</b>. This value can be <b>NULL</b> on entry if this
    ///                  information is not needed. If <i>pdwFlags</i> is zero on exit, then this value will be <b>NULL</b>. If this
    ///                  value is not <b>NULL</b> on exit, the buffer it points to must be freed using CoTaskMemFree when it is no
    ///                  longer needed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDropDownStatus(uint* pdwFlags, ushort** ppwszString);
    ///Forces the autocomplete object to refresh its list of suggestions when the list is visible.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ResetEnumerator();
}

///<p class="CCE_Message">[<b>ICDBurnExt</b> is available for use in the operating systems specified in the Requirements
///section. It may be altered or unavailable in subsequent versions.] Exposes a single method that determines content
///types supported by a CD writing extension.
@GUID("2271DCCA-74FC-4414-8FB7-C56B05ACE2D7")
interface ICDBurnExt : IUnknown
{
    ///Determines the supported data type for a CD writing extension.
    ///Params:
    ///    pdwActions = Type: <b>CDBE_ACTIONS*</b> One of the following values indicating the supported type.
    HRESULT GetSupportedActionTypes(uint* pdwActions);
}

///Exposes methods that enable the view to notify the implementer when the enumeration has completed. The view calls
///this method to tell the implementer that the enumeration can be retrieved via
///IEnumerableView::CreateEnumIDListFromContents. The callback allows the implementer to share the views enumeration.
@GUID("61E00D45-8FFF-4E60-924E-6537B61612DD")
interface IEnumReadyCallback : IUnknown
{
    ///Notifies the implementer that the view's item enumeration has completed. This callback interface is provided to
    ///the view via SetEnumReadyCallback
    HRESULT EnumReady();
}

///Exposes methods that enumerate the contents of a view and receive notification from callback upon enumeration
///completion. This interface enables clients of a view to attempt to share the view's list of folder contents.
@GUID("8C8BF236-1AEC-495F-9894-91D57C3C686F")
interface IEnumerableView : IUnknown
{
    ///Sets a callback on the view that is notified when the initial view enumeration is complete.
    ///Params:
    ///    percb = Type: <b>IEnumReadyCallback*</b> A pointer to the IEnumReadyCallback interface.
    HRESULT SetEnumReadyCallback(IEnumReadyCallback percb);
    ///Creates an enumerator of ID lists from the contents of the view.
    ///Params:
    ///    pidlFolder = Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL that is relative to the Desktop.
    ///    dwEnumFlags = Type: <b>DWORD</b> Specifies enumeration flags. See the SHCONTF enumerated type.
    ///    ppEnumIDList = Type: <b>IEnumIDList**</b> When this method returns, contains an IEnumIDList interface pointer.
    HRESULT CreateEnumIDListFromContents(ITEMIDLIST* pidlFolder, uint dwEnumFlags, IEnumIDList* ppEnumIDList);
}

///<p class="CCE_Message">[<b>IInsertItem</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Exposes a method that inserts an
///ITEMIDLIST structure into a list of such structures.
@GUID("D2B57227-3D23-4B95-93C0-492BD454C356")
interface IInsertItem : IUnknown
{
    ///Adds an ITEMIDLIST structure to a list of such structures.
    ///Params:
    ///    pidl = Type: <b>LPCITEMIDLIST</b> A pointer to an ITEMIDLIST structure that corresponds to an item in a Shell
    ///           folder.
    HRESULT InsertItem(ITEMIDLIST* pidl);
}

///<p class="CCE_Message">[<b>IFolderBandPriv</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Exposes methods that set folder
///items.
@GUID("47C01F95-E185-412C-B5C5-4F27DF965AEA")
interface IFolderBandPriv : IUnknown
{
    ///Sets a cascade folder.
    ///Params:
    ///    fCascade = Type: <b>BOOL</b> <b>TRUE</b> to enable cascade folders; <b>FALSE</b> to disable them.
    HRESULT SetCascade(BOOL fCascade);
    ///Sets accelerators.
    ///Params:
    ///    fAccelerators = Type: <b>BOOL</b> <b>TRUE</b> to enable accelerators; <b>FALSE</b> to disable them.
    HRESULT SetAccelerators(BOOL fAccelerators);
    ///Sets whether icons are displayed in a folder band.
    ///Params:
    ///    fNoIcons = Type: <b>BOOL</b> <b>TRUE</b> to display icons; otherwise, <b>FALSE</b>.
    HRESULT SetNoIcons(BOOL fNoIcons);
    ///Sets whether text is displayed in a folder band.
    ///Params:
    ///    fNoText = Type: <b>BOOL</b> <b>TRUE</b> to display text; otherwise, <b>FALSE</b>.
    HRESULT SetNoText(BOOL fNoText);
}

///Exposes a method that recompress images.
@GUID("505F1513-6B3E-4892-A272-59F8889A4D3E")
interface IImageRecompress : IUnknown
{
    ///Recompresses an image. Implemented in an ImageRecompress object, this method accepts x and y dimensions with a
    ///designation of quality. The method creates a stream containing the new image that has been recompressed to the
    ///specified size.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the object containing the stream of the image to read.
    ///    cx = Type: <b>int</b> The x dimension of the image to return.
    ///    cy = Type: <b>int</b> The y dimension of the image to return.
    ///    iQuality = Type: <b>int</b> An indication of recompression quality that can range from 0 to 100.
    ///    pstg = Type: <b>IStorage*</b> A pointer to an IStorage interface on the object that contains the stream to be
    ///           written to.
    ///    ppstrmOut = Type: <b>IStream**</b> The address of an IStream interface pointer variable that receives the output stream
    ///                written to.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM-defined error code otherwise. If the image in the
    ///    input stream is less than the size specified by <i>cx</i> and <i>cy</i>, then S_FALSE is returned.
    ///    
    HRESULT RecompressImage(IShellItem psi, int cx, int cy, int iQuality, IStorage pstg, IStream* ppstrmOut);
}

///Exposes methods that allow an application to be notified of events that are related to controls that the application
///has added to a common file dialog.
@GUID("36116642-D713-4B97-9B83-7484A9D00433")
interface IFileDialogControlEvents : IUnknown
{
    ///Called when an item is selected in a combo box, when a user clicks an option button (also known as a radio
    ///button), or an item is chosen from the <b>Tools</b> menu.
    ///Params:
    ///    pfdc = Type: <b>IFileDialogCustomize*</b> A pointer to the interface through which the application added controls to
    ///           the dialog.
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the control in which the user made a selection.
    ///    dwIDItem = Type: <b>DWORD</b> The ID of the selection.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnItemSelected(IFileDialogCustomize pfdc, uint dwIDCtl, uint dwIDItem);
    ///Called when the user clicks a command button.
    ///Params:
    ///    pfdc = Type: <b>IFileDialogCustomize*</b> A pointer to the interface through which the application added controls to
    ///           the dialog.
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the button that the user clicked.
    HRESULT OnButtonClicked(IFileDialogCustomize pfdc, uint dwIDCtl);
    ///Called when the user changes the state of a check button (check box).
    ///Params:
    ///    pfdc = Type: <b>IFileDialogCustomize*</b> A pointer to the interface through which the application added controls to
    ///           the dialog.
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the button that the user clicked.
    ///    bChecked = Type: <b>BOOL</b> A <b>BOOL</b> indicating the current state of the check button. <b>TRUE</b> if checked;
    ///               <b>FALSE</b> otherwise.
    HRESULT OnCheckButtonToggled(IFileDialogCustomize pfdc, uint dwIDCtl, BOOL bChecked);
    ///Called when an <b>Open</b> button drop-down list customized through EnableOpenDropDown or a <b>Tools</b> menu is
    ///about to display its contents.
    ///Params:
    ///    pfdc = Type: <b>IFileDialogCustomize*</b> A pointer to an IFileDialogCustomize object through which the application
    ///           adds controls to the dialog.
    ///    dwIDCtl = Type: <b>DWORD</b> The ID of the list or menu about to display.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnControlActivating(IFileDialogCustomize pfdc, uint dwIDCtl);
}

///Extends the IFileDialog interface by providing methods that allow the caller to name a specific, restricted location
///that can be browsed in the common file dialog as well as to specify alternate text to display as a label on the
///<b>Cancel</b> button.
@GUID("61744FC7-85B5-4791-A9B0-272276309B13")
interface IFileDialog2 : IFileDialog
{
    ///Replaces the default text "Cancel" on the common file dialog's <b>Cancel</b> button.
    ///Params:
    ///    pszLabel = Type: <b>LPCWSTR</b> Pointer to a string that contains the new text to display on the button.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCancelButtonLabel(const(wchar)* pszLabel);
    ///Specifies a top-level location from which to begin browsing a namespace, for instance in the <b>Save</b> dialog's
    ///<b>Browse folder</b> option. Users cannot navigate above this location.
    ///Params:
    ///    psi = Type: <b>IShellItem</b> Pointer to an IShellItem object that represents the navigation root.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetNavigationRoot(IShellItem psi);
}

///Exposes a method that launches an advanced association dialog box through which the user can customize their
///associations.
@GUID("1F76A169-F994-40AC-8FC8-0959E8874710")
interface IApplicationAssociationRegistrationUI : IUnknown
{
    ///Launches an advanced association dialog box through which the user can customize the associations for the
    ///application specified in <i>pszAppRegName</i>.
    ///Params:
    ///    pszAppRegistryName = Type: <b>LPCWSTR</b> A pointer to a null-terminated Unicode string that specifies the registered name of the
    ///                         application. This value is only valid if it matches one of the application strings registered under
    ///                         <b>HKCU\Software\RegisteredApplications</b> or under <b>HKLM\Software\RegisteredApplications</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT LaunchAdvancedAssociationUI(const(wchar)* pszAppRegistryName);
}

///Not supported.
@GUID("FCE4BDE0-4B68-4B80-8E9C-7426315A7388")
interface IShellRunDll : IUnknown
{
    ///Not supported.
    ///Params:
    ///    pszArgs = Type: <b>LPCWSTR</b>
    HRESULT Run(const(wchar)* pszArgs);
}

///Exposes a method that checks for previous versions of server files or folders, stored for the purpose of reversion by
///the <i>shadow copies</i> technology provided with Windows Server 2003.
@GUID("76E54780-AD74-48E3-A695-3BA9A0AFF10D")
interface IPreviousVersionsInfo : IUnknown
{
    ///Queries for the availablilty of a Windows Server 2003 volume image recorded by the system at an earlier time.
    ///Params:
    ///    pszPath = Type: <b>LPCWSTR</b> A null-terminated Unicode string containing the fully qualified path to a file or folder
    ///              on the volume in question. <div class="alert"><b>Note</b> Only paths to files and folders stored on a Windows
    ///              Server 2003 volume are currently supported. </div> <div> </div>
    ///    fOkToBeSlow = Type: <b>BOOL</b> A boolean value specifying whether a server should be contacted to determine the
    ///                  availability of stored volume images. For more details, see the Remarks section.
    ///    pfAvailable = Type: <b>BOOL*</b> A pointer to a boolean variable containing the result. This value is valid only if the
    ///                  method call succeeds; otherwise, it is undefined.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns standard error values, including, but not limited to, the following: <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PENDING</b></dt> </dl> </td>
    ///    <td width="60%"> <i>fOkToBeSlow</i> is <b>FALSE</b> and the result is not currently cached. </td> </tr>
    ///    </table>
    ///    
    HRESULT AreSnapshotsAvailable(const(wchar)* pszPath, BOOL fOkToBeSlow, int* pfAvailable);
}

///This interface is not supported. Do not use.
@GUID("05EDDA5C-98A3-4717-8ADB-C5E7DA991EB1")
interface IUseToBrowseItem : IRelatedItem
{
}

///Extends the INameSpaceTreeControl interface by providing methods that get and set the display styles of treeview
///controls for use with Shell namespace items.
@GUID("7CC7AED8-290E-49BC-8945-C1401CC9306C")
interface INameSpaceTreeControl2 : INameSpaceTreeControl
{
    ///Sets the display styles for the namespace object's treeview controls.
    ///Params:
    ///    nstcsMask = Type: <b>NSTCSTYLE</b> One or more of the NSTCSTYLE constants that specify the styles for which the method
    ///                should set new values.
    ///    nstcsStyle = Type: <b>NSTCSTYLE</b> A bitmap that contains the new values for the styles specified in <i>nstcsMask</i>. If
    ///                 the bit that represents the individual NSTCSTYLE value is 0, that style is not used. If the value is 1, the
    ///                 style is applied to the treeview. Styles in positions not specified in <i>nstcsMask</i> are left at their
    ///                 current setting regardless of their bit's value in this bitmap.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetControlStyle(uint nstcsMask, uint nstcsStyle);
    ///Gets the display styles set for the namespace object's treeview controls.
    ///Params:
    ///    nstcsMask = Type: <b>NSTCSTYLE</b> One or more of the NSTCSTYLE constants that specify the values for which the method
    ///                should retrieve the current settings.
    ///    pnstcsStyle = Type: <b>NSTCSTYLE*</b> Pointer to a value that, when this method returns successfully, receives the values
    ///                  requested in <i>nstcsMask</i>. If the bit that represents the individual NSTCSTYLE value is 0, that value is
    ///                  not set. If the value is 1, it is the current setting. Bit values in positions not specifically requested in
    ///                  <i>nstcsMask</i> do not necessarily reflect the current settings and should not be used.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetControlStyle(uint nstcsMask, uint* pnstcsStyle);
    ///Sets the extended display styles for the namespace object's treeview controls.
    ///Params:
    ///    nstcsMask = Type: <b>NSTCSTYLE2</b> One or more of the NSTCSTYLE2 constants that specify the styles for which the method
    ///                should set new values.
    ///    nstcsStyle = Type: <b>NSTCSTYLE2</b> A bitmap that contains the new values for the styles specified in <i>nstcsMask</i>.
    ///                 If the bit that represents the individual NSTCSTYLE2 value is 0, that style is not used. If the value is 1,
    ///                 the style is applied to the treeview. Styles in positions not specified in <i>nstcsMask</i> are left at their
    ///                 current setting regardless of their bit's value in this bitmap.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetControlStyle2(NSTCSTYLE2 nstcsMask, NSTCSTYLE2 nstcsStyle);
    ///Gets the extended display styles set for the namespace object's treeview controls.
    ///Params:
    ///    nstcsMask = Type: <b>NSTCSTYLE2</b> One or more of the NSTCSTYLE2 constants that specify the values for which the method
    ///                should retrieve the current settings.
    ///    pnstcsStyle = Type: <b>NSTCSTYLE2*</b> Pointer to a value that, when this method returns successfully, receives the values
    ///                  requested in <i>nstcsMask</i>. If the bit that represents the individual NSTCSTYLE2 value is 0, that value is
    ///                  not set. If the value is 1, it is the current setting. Bit values in positions not specifically requested in
    ///                  <i>nstcsMask</i> do not necessarily reflect the current settings and should not be used.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetControlStyle2(NSTCSTYLE2 nstcsMask, NSTCSTYLE2* pnstcsStyle);
}

///Exposes methods for handling INameSpaceTreeControl events.
@GUID("93D77985-B3D8-4484-8318-672CDDA002CE")
interface INameSpaceTreeControlEvents : IUnknown
{
    ///Called when the user clicks a button on the mouse.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> The IShellItem that was clicked.
    ///    nstceHitTest = Type: <b>NSTCEHITTEST</b> The location on the IShellItem that was clicked. One of the following values:
    ///    nstceClickType = Type: <b>NSTCSTYLE</b> Indicates which button was clicked and the kind of click. One of the following values:
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnItemClick(IShellItem psi, uint nstceHitTest, uint nstceClickType);
    ///Not implemented.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> Not used.
    HRESULT OnPropertyItemCommit(IShellItem psi);
    ///Called before the state of an item changes.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the Shell item for which the state is going to change.
    ///    nstcisMask = Type: <b>NSTCITEMSTATE</b> One or more values from the NSTCITEMSTATE enumeration that indicate which pieces
    ///                 of information the calling application wants to set.
    ///    nstcisState = Type: <b>NSTCITEMSTATE</b> One or more values from the NSTCITEMSTATE enumeration that indicate the values
    ///                  that are to be set.
    HRESULT OnItemStateChanging(IShellItem psi, uint nstcisMask, uint nstcisState);
    ///Not implemented.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the shell item for which the state has changed.
    ///    nstcisMask = Type: <b>NSTCITEMSTATE</b> One or more values from the NSTCITEMSTATE enumeration that indicates what pieces
    ///                 of information the caller wants to set.
    ///    nstcisState = Type: <b>NSTCITEMSTATE</b> One or more values from the NSTCITEMSTATE enumeration that indicates the values
    ///                  that are to be set.
    HRESULT OnItemStateChanged(IShellItem psi, uint nstcisMask, uint nstcisState);
    ///Called when the selection changes.
    ///Params:
    ///    psiaSelection = Type: <b>IShellItemArray*</b> An array of IShellItem objects that contains the new selection.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnSelectionChanged(IShellItemArray psiaSelection);
    ///Called when the user presses a key on the keyboard.
    ///Params:
    ///    uMsg = Type: <b>UINT</b> The message value.
    ///    wParam = Type: <b>WPARAM</b> Specifies the WParam parameters of the message.
    ///    lParam = Type: <b>LPARAM</b> Specifies the LParam parameters of the message.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnKeyboardInput(uint uMsg, WPARAM wParam, LPARAM lParam);
    ///Called before an IShellItem is expanded.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the IShellItem that is to be expanded.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnBeforeExpand(IShellItem psi);
    ///Called after an IShellItem is expanded.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the IShellItem that was expanded.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnAfterExpand(IShellItem psi);
    ///Called before the IShellItem goes into edit mode.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> Pointer to the IShellItem for which the text is to be edited.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnBeginLabelEdit(IShellItem psi);
    ///Called after the IShellItem leaves edit mode.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the IShellItem for which the text was edited.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnEndLabelEdit(IShellItem psi);
    ///Enables you to provide a tooltip.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> Pointer to the IShellItem that contains the tooltip.
    ///    pszTip = Type: <b>LPWSTR</b> When this method returns, contains the text of the tooltip.
    ///    cchTip = Type: <b>int</b> The size of the tooltip in characters.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnGetToolTip(IShellItem psi, const(wchar)* pszTip, int cchTip);
    ///Called before an IShellItem and all of its children are deleted.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the IShellItem that is to be deleted.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnBeforeItemDelete(IShellItem psi);
    ///Called after an IShellItem has been added.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the IShellItem that was added.
    ///    fIsRoot = Type: <b>BOOL</b> Specifies whether the IShellItem that was added is a root.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnItemAdded(IShellItem psi, BOOL fIsRoot);
    ///Called after an IShellItem has been deleted.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the IShellItem that was deleted.
    ///    fIsRoot = Type: <b>BOOL</b> Specifies whether the IShellItem that was deleted is a root.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnItemDeleted(IShellItem psi, BOOL fIsRoot);
    ///Called before a context menu is displayed; allows client to add additional menu entries.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the IShellItem from which the context menu is generated. This value can
    ///          be <b>NULL</b>.
    ///    riid = Type: <b>REFIID</b> Reference to the IID of the context menu.
    ///    ppv = Type: <b>void**</b> When this methods returns, contains the address of a pointer to the interface specified
    ///          by <i>riid</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnBeforeContextMenu(IShellItem psi, const(GUID)* riid, void** ppv);
    ///Called after a context menu is displayed.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> A pointer to the IShellItem from which the context menu is generated. This value can
    ///          be <b>NULL</b> only if the NSTCS2_SHOWNULLSPACEMENU flag is set.
    ///    pcmIn = Type: <b>IContextMenu*</b> A pointer to the context menu.
    ///    riid = Type: <b>REFIID</b> Reference to the IID of the context menu.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the address of a pointer to the interface specified in
    ///          <i>riid</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnAfterContextMenu(IShellItem psi, IContextMenu pcmIn, const(GUID)* riid, void** ppv);
    ///Called before the state icon of the given IShellItem is changed.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> Pointer to the IShellItem in which the state image is changing.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnBeforeStateImageChange(IShellItem psi);
    HRESULT OnGetDefaultIconIndex(IShellItem psi, int* piDefaultIcon, int* piOpenIcon);
}

///Exposes handler methods for drag-and-drop. Used by the namespace tree control to notify the client of any
///drag-and-drop operation happening within the control. Provides a way for a client to intercept a drop operation and
///perform its own action, or to return the desired drop effect.
@GUID("F9C665D6-C2F2-4C19-BF33-8322D7352F51")
interface INameSpaceTreeControlDropHandler : IUnknown
{
    ///Called on drag enter to set drag effect, as specified.
    ///Params:
    ///    psiOver = Type: <b>IShellItem*</b> A pointer to an IShellItem interface representing the item underneath the mouse
    ///              cursor. Optional.
    ///    psiaData = Type: <b>IShellItemArray*</b> A pointer to an IShellItem array containing the items being dragged.
    ///    fOutsideSource = Type: <b>BOOL</b> Specifies whether drag started outside target area.
    ///    grfKeyState = Type: <b>DWORD</b> The current state of keyboard modifier keys.
    ///    pdwEffect = Type: <b>DWORD*</b> On success, contains a pointer to the drag effect value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnDragEnter(IShellItem psiOver, IShellItemArray psiaData, BOOL fOutsideSource, uint grfKeyState, 
                        uint* pdwEffect);
    ///Called on drag over to set drag effect, as specified.
    ///Params:
    ///    psiOver = Type: <b>IShellItem*</b> A pointer to an IShellItem interface representing the item underneath the mouse
    ///              cursor. Optional.
    ///    psiaData = Type: <b>IShellItemArray*</b> A pointer to an IShellItem array containing the items being dragged.
    ///    grfKeyState = Type: <b>DWORD</b> The current state of keyboard modifier keys.
    ///    pdwEffect = Type: <b>DWORD*</b> On success, contains a pointer to the drag effect value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnDragOver(IShellItem psiOver, IShellItemArray psiaData, uint grfKeyState, uint* pdwEffect);
    ///Called when the item is being dragged within the same level (within the same parent folder) in the tree.
    ///Params:
    ///    psiOver = Type: <b>IShellItem*</b> A pointer to an IShellItem interface representing the item underneath the mouse
    ///              cursor. Optional.
    ///    psiaData = Type: <b>IShellItemArray*</b> A pointer to an IShellItem array containing the items being dragged.
    ///    iNewPosition = Type: <b>int</b> The index if the item being dragged is between items; otherwise, NSTCDHPOS_ONTOP (-1).
    ///    iOldPosition = Type: <b>int</b> The old position.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnDragPosition(IShellItem psiOver, IShellItemArray psiaData, int iNewPosition, int iOldPosition);
    ///Called on drop to set drop effect, as specified.
    ///Params:
    ///    psiOver = Type: <b>IShellItem*</b> A pointer to an IShellItem interface representing the item underneath the mouse
    ///              cursor. Optional.
    ///    psiaData = Type: <b>IShellItemArray*</b> A pointer to an IShellItem array representing a data object.
    ///    iPosition = Type: <b>int</b> Specifies drop position.
    ///    grfKeyState = Type: <b>DWORD</b> The current state of keyboard modifier keys.
    ///    pdwEffect = Type: <b>DWORD*</b> A pointer to the drop effect value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnDrop(IShellItem psiOver, IShellItemArray psiaData, int iPosition, uint grfKeyState, uint* pdwEffect);
    ///Called when the item is being dropped within the same level (within the same parent folder) in the tree.
    ///Params:
    ///    psiOver = Type: <b>IShellItem*</b> A pointer to an IShellItem interface representing the item underneath the mouse
    ///              cursor. Optional.
    ///    psiaData = Type: <b>IShellItemArray*</b> A pointer to an IShellItem array representing a data object.
    ///    iNewPosition = Type: <b>int</b> The index if the item being dropped is between items; otherwise, NSTCDHPOS_ONTOP (-1).
    ///    iOldPosition = Type: <b>int</b> Specifies old position.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnDropPosition(IShellItem psiOver, IShellItemArray psiaData, int iNewPosition, int iOldPosition);
    ///Called on drag leave for a specified item.
    ///Params:
    ///    psiOver = Type: <b>IShellItem*</b> A pointer to an IShellItem interface representing the item underneath the mouse
    ///              cursor. Optional.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnDragLeave(IShellItem psiOver);
}

///Exposes methods that perform accessibility actions on a Shell item from a namespace tree control.
@GUID("71F312DE-43ED-4190-8477-E9536B82350B")
interface INameSpaceTreeAccessible : IUnknown
{
    ///Gets the default accessibility action for a Shell item.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> Pointer to the IShellItem.
    ///    pbstrDefaultAction = Type: <b>BSTR*</b> When this method returns, contains a BSTR that specifies the default, accessibility
    ///                         action.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or E_OUTOFMEMORY otherwise.
    ///    
    HRESULT OnGetDefaultAccessibilityAction(IShellItem psi, BSTR* pbstrDefaultAction);
    ///Invokes the default accessibility action on a Shell item.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> Pointer to the IShellItem.
    HRESULT OnDoDefaultAccessibilityAction(IShellItem psi);
    ///Gets the accessibility role for a Shell item.
    ///Params:
    ///    psi = Type: <b>IShellItem*</b> Pointer to the IShellItem.
    ///    pvarRole = Type: <b>VARIANT*</b> When this method returns, contains a VARIANT that specifies the role.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnGetAccessibilityRole(IShellItem psi, VARIANT* pvarRole);
}

///Exposes methods that enable the user to draw a custom namespace tree control and its items.
@GUID("2D3BA758-33EE-42D5-BB7B-5F3431D86C78")
interface INameSpaceTreeControlCustomDraw : IUnknown
{
    ///Called before the namespace tree control is drawn.
    ///Params:
    ///    hdc = Type: <b>HDC</b> A handle to the control's device context. Use this HDC to perform any GDI functions.
    ///    prc = Type: <b>RECT*</b> A pointer to the RECT structure that describes the bounding rectangle of the area being
    ///          drawn.
    ///    plres = Type: <b>LRESULT*</b> When this method returns, contains a pointer to an <b>LRESULT</b>, which contains one
    ///            or more of the values from the CDRF Constants enumeration.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT PrePaint(HDC hdc, RECT* prc, LRESULT* plres);
    ///Called after the namespace tree control is drawn.
    ///Params:
    ///    hdc = Type: <b>HDC</b> A handle to the control's device context. Use this HDC to perform any GDI functions.
    ///    prc = Type: <b>RECT*</b> A pointer to the RECT structure that describes the bounding rectangle of the area being
    ///          drawn.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT PostPaint(HDC hdc, RECT* prc);
    ///Called before an item in the namespace tree control is drawn.
    ///Params:
    ///    hdc = Type: <b>HDC</b> A handle to the control's device context. Use this HDC to perform any GDI functions.
    ///    prc = Type: <b>RECT*</b> A pointer to the RECT structure that describes the bounding rectangle of the area being
    ///          drawn.
    ///    pnstccdItem = Type: <b>NSTCCUSTOMDRAW*</b> A pointer to the NSTCCUSTOMDRAW structure that determines the details of the
    ///                  drawing.
    ///    pclrText = Type: <b>COLORREF*</b> On entry, a pointer to a COLORREF structure that declares the default color of the
    ///               text. When this method returns, contains a pointer to a <b>COLORREF</b> structure that declares the color
    ///               that should be used in its place, if any. This allows the client to provide their own color if they do not
    ///               want to use the default.
    ///    pclrTextBk = Type: <b>COLORREF*</b> On entry, a pointer to a COLORREF structure that declares the default color of the
    ///                 background. When this method returns, contains a pointer to a <b>COLORREF</b> structure that declares the
    ///                 color that should be used in its place, if any. This allows the client to provide their own color if they do
    ///                 not want to use the default.
    ///    plres = Type: <b>LRESULT*</b> When this method returns, contains a pointer to an <b>LRESULT</b>, which points to one
    ///            or more of the values from the CDRF Constants enumeration.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ItemPrePaint(HDC hdc, RECT* prc, NSTCCUSTOMDRAW* pnstccdItem, uint* pclrText, uint* pclrTextBk, 
                         LRESULT* plres);
    ///Called after an item in the namespace tree control is drawn.
    ///Params:
    ///    hdc = Type: <b>HDC</b> A handle to the control's device context. Use this HDC to perform any GDI functions.
    ///    prc = Type: <b>RECT*</b> A pointer to the RECT structure that describes the bounding rectangle of the area being
    ///          drawn.
    ///    pnstccdItem = Type: <b>NSTCCUSTOMDRAW*</b> A pointer to the NSTCCUSTOMDRAW struct that determines the details of the
    ///                  drawing.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ItemPostPaint(HDC hdc, RECT* prc, NSTCCUSTOMDRAW* pnstccdItem);
}

///Exposes methods that show, hide, and query deskbands.
@GUID("6D67E846-5B9C-4DB8-9CBC-DDE12F4254F1")
interface ITrayDeskBand : IUnknown
{
    ///Shows a specified deskband.
    ///Params:
    ///    clsid = Type: <b>REFCLSID</b> A reference to a deskband CLSID.
    HRESULT ShowDeskBand(const(GUID)* clsid);
    ///Hides a specified deskband.
    ///Params:
    ///    clsid = Type: <b>REFCLSID</b> A reference to a deskband CLSID.
    HRESULT HideDeskBand(const(GUID)* clsid);
    ///Indicates whether a deskband is shown.
    ///Params:
    ///    clsid = Type: <b>REFCLSID</b> A reference to a deskband CLSID.
    HRESULT IsDeskBandShown(const(GUID)* clsid);
    ///Refreshes the deskband registration cache.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DeskBandRegistrationChanged();
}

///Exposes methods that create and destroy bands and specifiy their availability.
@GUID("B9075C7C-D48E-403F-AB99-D6C77A1084AC")
interface IBandHost : IUnknown
{
    ///Creates a specified band.
    ///Params:
    ///    rclsidBand = Type: <b>REFCLSID</b> A reference to a CLSID. Used to ensure a duplicate band is not created.
    ///    fAvailable = Type: <b>BOOL</b> Specifies band availability.
    ///    fVisible = Type: <b>BOOL</b> Specifies band visibility.
    ///    riid = Type: <b>REFIID</b> A reference to a desired IID.
    ///    ppv = Type: <b>void**</b> Contains the address of a pointer to a band specified by <i>riid</i>.
    HRESULT CreateBand(const(GUID)* rclsidBand, BOOL fAvailable, BOOL fVisible, const(GUID)* riid, void** ppv);
    ///Sets the availability of a specified band.
    ///Params:
    ///    rclsidBand = Type: <b>REFCLSID</b> A reference to a CLSID.
    ///    fAvailable = Type: <b>BOOL</b> Specifies band availability.
    HRESULT SetBandAvailability(const(GUID)* rclsidBand, BOOL fAvailable);
    ///Destroys a specified band.
    ///Params:
    ///    rclsidBand = Type: <b>REFCLSID</b> A reference to the CLSID of a band.
    HRESULT DestroyBand(const(GUID)* rclsidBand);
}

///Not supported. This interface may be absent in later versions of Windows.
@GUID("0DF60D92-6818-46D6-B358-D66170DDE466")
interface IComputerInfoChangeNotify : IUnknown
{
    ///Not supported. This interface may be absent in later versions of Windows.
    HRESULT ComputerInfoChanged();
}

///Exposes a method that allows the programmatic addition of an installed gadget to the user's desktop.
@GUID("C1646BC4-F298-4F91-A204-EB2DD1709D1A")
interface IDesktopGadget : IUnknown
{
    ///Adds an installed gadget to the desktop.
    ///Params:
    ///    gadgetPath = Type: <b>LPCWSTR</b> Pointer to the full (absolute) path of a .gadget folder. A gadget that is not packaged
    ///                 with Windows can only be run from one of the two following locations. Installation of the gadget in any other
    ///                 location will cause this method to fail with an access denied error. <div class="alert"><b>Note</b> This path
    ///                 should not contain environment variables; the fully expanded path must be provided. ExpandEnvironmentStrings
    ///                 can be used to expand the path to the form required in this parameter.</div> <div> </div>
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>SCHED_E_ALREADY_RUNNING</b></dt> </dl> </td> <td width="60%"> The gadget is already running. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An error occurred
    ///    involving the path of the gadget folder pointed to by <i>gadgetPath</i>. </td> </tr> </table>
    ///    
    HRESULT RunGadget(const(wchar)* gadgetPath);
}

@GUID("5EFB46D7-47C0-4B68-ACDA-DED47C90EC91")
interface IStorageProviderBanners : IUnknown
{
    HRESULT SetBanner(const(wchar)* providerIdentity, const(wchar)* subscriptionId, const(wchar)* contentId);
    HRESULT ClearBanner(const(wchar)* providerIdentity, const(wchar)* subscriptionId);
    HRESULT ClearAllBanners(const(wchar)* providerIdentity);
    HRESULT GetBanner(const(wchar)* providerIdentity, const(wchar)* subscriptionId, ushort** contentId);
}

@GUID("9BA05970-F6A8-11CF-A442-00A0C90A8F39")
interface IFolderViewOC : IDispatch
{
    HRESULT SetFolderView(IDispatch pdisp);
}

@GUID("62112AA2-EBE4-11CF-A5FB-0020AFE7292D")
interface DShellFolderViewEvents : IDispatch
{
}

@GUID("4A3DF050-23BD-11D2-939F-00A0C91EEDBA")
interface DFConstraint : IDispatch
{
    HRESULT get_Name(BSTR* pbs);
    HRESULT get_Value(VARIANT* pv);
}

@GUID("FAC32C80-CBE4-11CE-8350-444553540000")
interface FolderItem : IDispatch
{
    HRESULT get_Application(IDispatch* ppid);
    HRESULT get_Parent(IDispatch* ppid);
    HRESULT get_Name(BSTR* pbs);
    HRESULT put_Name(BSTR bs);
    HRESULT get_Path(BSTR* pbs);
    HRESULT get_GetLink(IDispatch* ppid);
    HRESULT get_GetFolder(IDispatch* ppid);
    HRESULT get_IsLink(short* pb);
    HRESULT get_IsFolder(short* pb);
    HRESULT get_IsFileSystem(short* pb);
    HRESULT get_IsBrowsable(short* pb);
    HRESULT get_ModifyDate(double* pdt);
    HRESULT put_ModifyDate(double dt);
    HRESULT get_Size(int* pul);
    HRESULT get_Type(BSTR* pbs);
    HRESULT Verbs(FolderItemVerbs* ppfic);
    HRESULT InvokeVerb(VARIANT vVerb);
}

@GUID("744129E0-CBE5-11CE-8350-444553540000")
interface FolderItems : IDispatch
{
    HRESULT get_Count(int* plCount);
    HRESULT get_Application(IDispatch* ppid);
    HRESULT get_Parent(IDispatch* ppid);
    HRESULT Item(VARIANT index, FolderItem* ppid);
    HRESULT _NewEnum(IUnknown* ppunk);
}

@GUID("08EC3E00-50B0-11CF-960C-0080C7F4EE85")
interface FolderItemVerb : IDispatch
{
    HRESULT get_Application(IDispatch* ppid);
    HRESULT get_Parent(IDispatch* ppid);
    HRESULT get_Name(BSTR* pbs);
    HRESULT DoIt();
}

@GUID("1F8352C0-50B0-11CF-960C-0080C7F4EE85")
interface FolderItemVerbs : IDispatch
{
    HRESULT get_Count(int* plCount);
    HRESULT get_Application(IDispatch* ppid);
    HRESULT get_Parent(IDispatch* ppid);
    HRESULT Item(VARIANT index, FolderItemVerb* ppid);
    HRESULT _NewEnum(IUnknown* ppunk);
}

@GUID("BBCBDE60-C3FF-11CE-8350-444553540000")
interface Folder : IDispatch
{
    HRESULT get_Title(BSTR* pbs);
    HRESULT get_Application(IDispatch* ppid);
    HRESULT get_Parent(IDispatch* ppid);
    HRESULT get_ParentFolder(Folder* ppsf);
    HRESULT Items(FolderItems* ppid);
    HRESULT ParseName(BSTR bName, FolderItem* ppid);
    HRESULT NewFolder(BSTR bName, VARIANT vOptions);
    HRESULT MoveHere(VARIANT vItem, VARIANT vOptions);
    HRESULT CopyHere(VARIANT vItem, VARIANT vOptions);
    HRESULT GetDetailsOf(VARIANT vItem, int iColumn, BSTR* pbs);
}

@GUID("F0D2D8EF-3890-11D2-BF8B-00C04FB93661")
interface Folder2 : Folder
{
    HRESULT get_Self(FolderItem* ppfi);
    HRESULT get_OfflineStatus(int* pul);
    HRESULT Synchronize();
    HRESULT get_HaveToShowWebViewBarricade(short* pbHaveToShowWebViewBarricade);
    HRESULT DismissedWebViewBarricade();
}

@GUID("A7AE5F64-C4D7-4D7F-9307-4D24EE54B841")
interface Folder3 : Folder2
{
    HRESULT get_ShowWebViewBarricade(short* pbShowWebViewBarricade);
    HRESULT put_ShowWebViewBarricade(short bShowWebViewBarricade);
}

@GUID("EDC817AA-92B8-11D1-B075-00C04FC33AA5")
interface FolderItem2 : FolderItem
{
    HRESULT InvokeVerbEx(VARIANT vVerb, VARIANT vArgs);
    HRESULT ExtendedProperty(BSTR bstrPropName, VARIANT* pvRet);
}

@GUID("C94F0AD0-F363-11D2-A327-00C04F8EEC7F")
interface FolderItems2 : FolderItems
{
    HRESULT InvokeVerbEx(VARIANT vVerb, VARIANT vArgs);
}

@GUID("EAA7C309-BBEC-49D5-821D-64D966CB667F")
interface FolderItems3 : FolderItems2
{
    HRESULT Filter(int grfFlags, BSTR bstrFileSpec);
    HRESULT get_Verbs(FolderItemVerbs* ppfic);
}

@GUID("88A05C00-F000-11CE-8350-444553540000")
interface IShellLinkDual : IDispatch
{
    HRESULT get_Path(BSTR* pbs);
    HRESULT put_Path(BSTR bs);
    HRESULT get_Description(BSTR* pbs);
    HRESULT put_Description(BSTR bs);
    HRESULT get_WorkingDirectory(BSTR* pbs);
    HRESULT put_WorkingDirectory(BSTR bs);
    HRESULT get_Arguments(BSTR* pbs);
    HRESULT put_Arguments(BSTR bs);
    HRESULT get_Hotkey(int* piHK);
    HRESULT put_Hotkey(int iHK);
    HRESULT get_ShowCommand(int* piShowCommand);
    HRESULT put_ShowCommand(int iShowCommand);
    HRESULT Resolve(int fFlags);
    HRESULT GetIconLocation(BSTR* pbs, int* piIcon);
    HRESULT SetIconLocation(BSTR bs, int iIcon);
    HRESULT Save(VARIANT vWhere);
}

@GUID("317EE249-F12E-11D2-B1E4-00C04F8EEB3E")
interface IShellLinkDual2 : IShellLinkDual
{
    HRESULT get_Target(FolderItem* ppfi);
}

///Exposes methods that modify the view and select items in the current folder.
@GUID("E7A1AF80-4D96-11CF-960C-0080C7F4EE85")
interface IShellFolderViewDual : IDispatch
{
    ///Gets the application object.
    ///Params:
    ///    ppid = Type: <b>IDispatch**</b> The application object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Application(IDispatch* ppid);
    ///Not implemented.
    ///Params:
    ///    ppid = Type: <b>IDispatch**</b> The application object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Parent(IDispatch* ppid);
    ///Gets the Folder object that represents the view.
    ///Params:
    ///    ppid = Type: <b>Folder**</b> The folder object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Folder(Folder* ppid);
    ///Gets a FolderItems object that represents all of the selected items in the view.
    ///Params:
    ///    ppid = Type: <b>FolderItems**</b> The FolderItems object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SelectedItems(FolderItems* ppid);
    ///Gets the FolderItem object that represents the item that has input focus.
    ///Params:
    ///    ppid = Type: <b>FolderItem**</b> The FolderItem object with input focus.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_FocusedItem(FolderItem* ppid);
    ///Sets the selection state of an item in the view.
    ///Params:
    ///    pvfi = Type: <b>VARIANT*</b> A VARIANT object.
    ///    dwFlags = Type: <b>int</b> The flags representing the state of the object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SelectItem(VARIANT* pvfi, int dwFlags);
    ///Creates a shortcut menu for the specified item and returns the selected command string.
    ///Params:
    ///    pfi = Type: <b>FolderItem*</b> The FolderItem for which to create a shortcut menu.
    ///    vx = Type: <b>VARIANT</b> Optional.
    ///    vy = Type: <b>VARIANT</b> Optional.
    ///    pbs = Type: <b>BSTR*</b> The command string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT PopupItemMenu(FolderItem pfi, VARIANT vx, VARIANT vy, BSTR* pbs);
    ///Gets the scripting object for the view.
    ///Params:
    ///    ppDisp = Type: <b>IDispatch**</b> The scripting object for the view. This represents the scripting automation model.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Script(IDispatch* ppDisp);
    ///Gets a set of flags that indicate the current options of the view.
    ///Params:
    ///    plViewOptions = Type: <b>long*</b> The set of flags that indicate the current options of the view.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_ViewOptions(int* plViewOptions);
}

///Exposes methods that modify the view and select items in the current folder.
@GUID("31C147B6-0ADE-4A3C-B514-DDF932EF6D17")
interface IShellFolderViewDual2 : IShellFolderViewDual
{
    ///Gets the current view mode of the current folder.
    ///Params:
    ///    pViewMode = Type: <b>uint*</b> When this method returns, contains a pointer to an unsigned integer that represents the
    ///                current view mode. For a list of possible values see FOLDERVIEWMODE.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_CurrentViewMode(uint* pViewMode);
    ///Sets the current view mode of the current folder.
    ///Params:
    ///    ViewMode = Type: <b>uint</b> Sets the current view mode. For a list of possible values see FOLDERVIEWMODE.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_CurrentViewMode(uint ViewMode);
    ///Selects an item relative to the current item.
    ///Params:
    ///    iRelative = Type: <b>int</b> The offset of the item to be selected in relation to the current item.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SelectItemRelative(int iRelative);
}

///Exposes methods that modify the current folder view.
@GUID("29EC8E6C-46D3-411F-BAAA-611A6C9CAC66")
interface IShellFolderViewDual3 : IShellFolderViewDual2
{
    ///Gets the column used for grouping the folder view.
    ///Params:
    ///    pbstrGroupBy = Type: <b>BSTR*</b> When this method returns, contains a pointer to the column name.
    HRESULT get_GroupBy(BSTR* pbstrGroupBy);
    ///Sets the column used in grouping the folder view.
    ///Params:
    ///    bstrGroupBy = Type: <b>BSTR</b> A <b>BSTR</b> that contains the column name.
    HRESULT put_GroupBy(BSTR bstrGroupBy);
    ///Gets the settings for the current folder.
    ///Params:
    ///    pdwFlags = Type: <b>DWORD*</b> When this method returns, contains a pointer to the current setting flags. For a list of
    ///               possible values, see FOLDERFLAGS.
    HRESULT get_FolderFlags(uint* pdwFlags);
    ///Sets the current folders settings.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> Flags that determine the folder settings. For a list of possible values, see FOLDERFLAGS.
    HRESULT put_FolderFlags(uint dwFlags);
    ///Gets the names of the columns used to sort the current folder.
    ///Params:
    ///    pbstrSortColumns = Type: <b>BSTR*</b> A <b>BSTR</b> that contains the column names.
    HRESULT get_SortColumns(BSTR* pbstrSortColumns);
    ///Sets the names of the columns to be sorted.
    ///Params:
    ///    bstrSortColumns = Type: <b>BSTR</b> The <b>BSTR</b> that contains the names of the columns to be sorted for the current folder.
    HRESULT put_SortColumns(BSTR bstrSortColumns);
    ///Sets the icon size setting for the current folder.
    ///Params:
    ///    iIconSize = Type: <b>int</b> The icon size value.
    HRESULT put_IconSize(int iIconSize);
    ///Gets the icon size setting for the current folder.
    ///Params:
    ///    piIconSize = Type: <b>int*</b> When this method returns, contains a pointer to the icon size value.
    HRESULT get_IconSize(int* piIconSize);
    ///Sets the filter on the contents of the current view.
    ///Params:
    ///    bstrFilterText = Type: <b>BSTR</b> The BSTR that names the filter view for the current folder.
    HRESULT FilterView(BSTR bstrFilterText);
}

@GUID("D8F015C0-C278-11CE-A49E-444553540000")
interface IShellDispatch : IDispatch
{
    HRESULT get_Application(IDispatch* ppid);
    HRESULT get_Parent(IDispatch* ppid);
    HRESULT NameSpace(VARIANT vDir, Folder* ppsdf);
    HRESULT BrowseForFolder(int Hwnd, BSTR Title, int Options, VARIANT RootFolder, Folder* ppsdf);
    HRESULT Windows(IDispatch* ppid);
    HRESULT Open(VARIANT vDir);
    HRESULT Explore(VARIANT vDir);
    HRESULT MinimizeAll();
    HRESULT UndoMinimizeALL();
    HRESULT FileRun();
    HRESULT CascadeWindows();
    HRESULT TileVertically();
    HRESULT TileHorizontally();
    HRESULT ShutdownWindows();
    HRESULT Suspend();
    HRESULT EjectPC();
    HRESULT SetTime();
    HRESULT TrayProperties();
    HRESULT Help();
    HRESULT FindFiles();
    HRESULT FindComputer();
    HRESULT RefreshMenu();
    HRESULT ControlPanelItem(BSTR bstrDir);
}

@GUID("A4C6892C-3BA9-11D2-9DEA-00C04FB16162")
interface IShellDispatch2 : IShellDispatch
{
    HRESULT IsRestricted(BSTR Group, BSTR Restriction, int* plRestrictValue);
    HRESULT ShellExecuteA(BSTR File, VARIANT vArgs, VARIANT vDir, VARIANT vOperation, VARIANT vShow);
    HRESULT FindPrinter(BSTR name, BSTR location, BSTR model);
    HRESULT GetSystemInformation(BSTR name, VARIANT* pv);
    HRESULT ServiceStart(BSTR ServiceName, VARIANT Persistent, VARIANT* pSuccess);
    HRESULT ServiceStop(BSTR ServiceName, VARIANT Persistent, VARIANT* pSuccess);
    HRESULT IsServiceRunning(BSTR ServiceName, VARIANT* pRunning);
    HRESULT CanStartStopService(BSTR ServiceName, VARIANT* pCanStartStop);
    HRESULT ShowBrowserBar(BSTR bstrClsid, VARIANT bShow, VARIANT* pSuccess);
}

@GUID("177160CA-BB5A-411C-841D-BD38FACDEAA0")
interface IShellDispatch3 : IShellDispatch2
{
    HRESULT AddToRecent(VARIANT varFile, BSTR bstrCategory);
}

@GUID("EFD84B2D-4BCF-4298-BE25-EB542A59FBDA")
interface IShellDispatch4 : IShellDispatch3
{
    HRESULT WindowsSecurity();
    HRESULT ToggleDesktop();
    HRESULT ExplorerPolicy(BSTR bstrPolicyName, VARIANT* pValue);
    HRESULT GetSetting(int lSetting, short* pResult);
}

@GUID("866738B9-6CF2-4DE8-8767-F794EBE74F4E")
interface IShellDispatch5 : IShellDispatch4
{
    HRESULT WindowSwitcher();
}

@GUID("286E6F1B-7113-4355-9562-96B7E9D64C54")
interface IShellDispatch6 : IShellDispatch5
{
    HRESULT SearchCommand();
}

@GUID("2D91EEA1-9932-11D2-BE86-00A0C9A83DA1")
interface IFileSearchBand : IDispatch
{
    HRESULT SetFocus();
    HRESULT SetSearchParameters(BSTR* pbstrSearchID, short bNavToResults, VARIANT* pvarScope, 
                                VARIANT* pvarQueryFile);
    HRESULT get_SearchID(BSTR* pbstrSearchID);
    HRESULT get_Scope(VARIANT* pvarScope);
    HRESULT get_QueryFile(VARIANT* pvarFile);
}

@GUID("18BCC359-4990-4BFB-B951-3C83702BE5F9")
interface IWebWizardHost : IDispatch
{
    HRESULT FinalBack();
    HRESULT FinalNext();
    HRESULT Cancel();
    HRESULT put_Caption(BSTR bstrCaption);
    HRESULT get_Caption(BSTR* pbstrCaption);
    HRESULT put_Property(BSTR bstrPropertyName, VARIANT* pvProperty);
    HRESULT get_Property(BSTR bstrPropertyName, VARIANT* pvProperty);
    HRESULT SetWizardButtons(short vfEnableBack, short vfEnableNext, short vfLastPage);
    HRESULT SetHeaderText(BSTR bstrHeaderTitle, BSTR bstrHeaderSubtitle);
}

@GUID("F9C013DC-3C23-4041-8E39-CFB402F7EA59")
interface IWebWizardHost2 : IWebWizardHost
{
    HRESULT SignString(BSTR value, BSTR* signedValue);
}

@GUID("0751C551-7568-41C9-8E5B-E22E38919236")
interface INewWDEvents : IWebWizardHost
{
    HRESULT PassportAuthenticate(BSTR bstrSignInUrl, short* pvfAuthenitcated);
}

///Exposed by the autocomplete object (CLSID_AutoComplete). This interface allows applications to initialize, enable,
///and disable the object.
@GUID("00BB2762-6A77-11D0-A535-00C04FD7D062")
interface IAutoComplete : IUnknown
{
    ///Initializes the autocomplete object.
    ///Params:
    ///    hwndEdit = Type: <b>HWND</b> A handle to the window for the system edit control for which autocompletion will be
    ///               enabled.
    ///    punkACL = Type: <b>IUnknown*</b> A pointer to the IUnknown interface of the string list object that generates
    ///              candidates for the completed string. The object must expose an IEnumString interface.
    ///    pwszRegKeyPath = Type: <b>LPCWSTR</b> A pointer to an optional, null-terminated Unicode string that gives the registry path,
    ///                     including the value name, where the format string is stored as a <b>REG_SZ</b> value. The autocomplete object
    ///                     first looks for the path under <b>HKEY_CURRENT_USER</b>. If it fails, it tries <b>HKEY_LOCAL_MACHINE</b>. For
    ///                     a discussion of the format string, see the definition of <i>pwszQuickComplete</i>.
    ///    pwszQuickComplete = Type: <b>LPCWSTR</b> A pointer to an optional null-terminated Unicode string that specifies the format to be
    ///                        used if the user enters text and presses CTRL+ENTER. Set this parameter to <b>NULL</b> to disable quick
    ///                        completion. Otherwise, the autocomplete object treats <i>pwszQuickComplete</i> as a StringCchPrintf format
    ///                        string and the text in the edit box as its associated argument, to produce a new string. For example, set
    ///                        <i>pwszQuickComplete</i> to "http://www.%s.com/". When a user enters "MyURL" into the edit box and presses
    ///                        CTRL+ENTER, the text in the edit box is updated to "http://www.MyURL.com/".
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Init(HWND hwndEdit, IUnknown punkACL, const(wchar)* pwszRegKeyPath, const(wchar)* pwszQuickComplete);
    ///Enables or disables autocompletion.
    ///Params:
    ///    fEnable = Type: <b>BOOL</b> A value that is set to <b>TRUE</b> to enable autocompletion, or <b>FALSE</b> to disable it.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
    ///    
    HRESULT Enable(BOOL fEnable);
}

///Extends IAutoComplete. This interface enables clients of the autocomplete object to retrieve and set a number of
///options that control how autocompletion operates.
@GUID("EAC04BC0-3791-11D2-BB95-0060977B464C")
interface IAutoComplete2 : IAutoComplete
{
    ///Sets the current autocomplete options.
    ///Params:
    ///    dwFlag = Type: <b>DWORD</b> One or more flags from the AUTOCOMPLETEOPTIONS enumeration that specify autocomplete
    ///             options.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOptions(uint dwFlag);
    ///Gets the current autocomplete options.
    ///Params:
    ///    pdwFlag = Type: <b>DWORD*</b> One or more flags from the AUTOCOMPLETEOPTIONS enumeration that indicate the options that
    ///              are currently set.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOptions(uint* pdwFlag);
}

@GUID("8E74C210-CF9D-4EAF-A403-7356428F0A5A")
interface IEnumACString : IEnumString
{
    HRESULT NextItem(const(wchar)* pszUrl, uint cchMax, uint* pulSortIndex);
    HRESULT SetEnumOptions(uint dwOptions);
    HRESULT GetEnumOptions(uint* pdwOptions);
}

///Enables interfaces that are usually synchronous to function asynchronously. <div class="alert"><b>Note</b> This
///interface is the current, renamed version of IAsyncOperation.</div><div> </div>
@GUID("3D8B0590-F691-11D2-8EA9-006097DF5BD4")
interface IDataObjectAsyncCapability : IUnknown
{
    ///Called by a drop source to specify whether the data object supports asynchronous data extraction.
    ///Params:
    ///    fDoOpAsync = Type: <b>BOOL</b> <b>VARIANT_TRUE</b> if an asynchronous operation is supported; otherwise,
    ///                 <b>VARIANT_FALSE</b>. The default value is <b>VARIANT_FALSE</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetAsyncMode(BOOL fDoOpAsync);
    ///Called by a drop target to determine whether the data object supports asynchronous data extraction.
    ///Params:
    ///    pfIsOpAsync = Type: <b>BOOL*</b> <b>VARIANT_TRUE</b> if an asynchronous operation is supported; otherwise,
    ///                  <b>VARIANT_FALSE</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAsyncMode(int* pfIsOpAsync);
    ///Called by a drop target to indicate that asynchronous data extraction is starting.
    ///Params:
    ///    pbcReserved = Type: <b>IBindCtx*</b> Reserved. Set this value to <b>nullptr</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StartOperation(IBindCtx pbcReserved);
    ///Called by the drop source to determine whether the target is extracting data asynchronously.
    ///Params:
    ///    pfInAsyncOp = Type: <b>BOOL*</b> <b>VARIANT_TRUE</b> if data extraction is being handled asynchronously; otherwise,
    ///                  <b>VARIANT_FALSE</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InOperation(int* pfInAsyncOp);
    ///Notifies the data object that the asynchronous data extraction has ended.
    ///Params:
    ///    hResult = Type: <b>HRESULT</b> Indicates the outcome of the data extraction. Set this value to S_OK if successful, or a
    ///              COM error code otherwise.
    ///    pbcReserved = Type: <b>IBindCtx*</b> Reserved. Set to <b>nullptr</b>.
    ///    dwEffects = Type: <b>DWORD</b> A DROPEFFECT value that indicates the result of an optimized move. This should be the same
    ///                value that would be passed to the data object as a CFSTR_PERFORMEDDROPEFFECT format with a normal data
    ///                extraction operation.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EndOperation(HRESULT hResult, IBindCtx pbcReserved, uint dwEffects);
}

///Exposes methods that allow a client to retrieve the icon that is associated with one of the objects in a folder.
@GUID("000214EB-0000-0000-C000-000000000046")
interface IExtractIconA : IUnknown
{
    ///Gets the location and index of an icon.
    ///Params:
    ///    uFlags = Type: <b>UINT</b> One or more of the following values. This parameter can also be <b>NULL</b>.
    ///    pszIconFile = Type: <b>PTSTR</b> A pointer to a buffer that receives the icon location. The icon location is a
    ///                  null-terminated string that identifies the file that contains the icon.
    ///    cchMax = Type: <b>UINT</b> The size of the buffer, in characters, pointed to by <i>pszIconFile</i>.
    ///    piIndex = Type: <b>int*</b> A pointer to an <b>int</b> that receives the index of the icon in the file pointed to by
    ///              <i>pszIconFile</i>.
    ///    pwFlags = Type: <b>UINT*</b> A pointer to a <b>UINT</b> value that receives zero or a combination of the following
    ///              values.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the function returned a valid location, or S_FALSE if the Shell should
    ///    use a default icon. If the <b>GIL_ASYNC</b> flag is set in <i>uFlags</i>, the method can return E_PENDING to
    ///    indicate that icon extraction will be time-consuming.
    ///    
    HRESULT GetIconLocation(uint uFlags, const(char)* pszIconFile, uint cchMax, int* piIndex, uint* pwFlags);
    ///Extracts an icon image from the specified location.
    ///Params:
    ///    pszFile = Type: <b>PCTSTR</b> A pointer to a null-terminated string that specifies the icon location.
    ///    nIconIndex = Type: <b>UINT</b> The index of the icon in the file pointed to by <i>pszFile</i>.
    ///    phiconLarge = Type: <b>HICON*</b> A pointer to an <b>HICON</b> value that receives the handle to the large icon. This
    ///                  parameter may be <b>NULL</b>.
    ///    phiconSmall = Type: <b>HICON*</b> A pointer to an <b>HICON</b> value that receives the handle to the small icon. This
    ///                  parameter may be <b>NULL</b>.
    ///    nIconSize = Type: <b>UINT</b> The desired size of the icon, in pixels. The low word contains the size of the large icon,
    ///                and the high word contains the size of the small icon. The size specified can be the width or height. The
    ///                width of an icon always equals its height.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the function extracted the icon, or S_FALSE if the calling application
    ///    should extract the icon.
    ///    
    HRESULT Extract(const(char)* pszFile, uint nIconIndex, HICON* phiconLarge, HICON* phiconSmall, uint nIconSize);
}

///Exposes methods that allow a client to retrieve the icon that is associated with one of the objects in a folder.
@GUID("000214FA-0000-0000-C000-000000000046")
interface IExtractIconW : IUnknown
{
    ///Gets the location and index of an icon.
    ///Params:
    ///    uFlags = Type: <b>UINT</b> One or more of the following values. This parameter can also be <b>NULL</b>.
    ///    pszIconFile = Type: <b>PTSTR</b> A pointer to a buffer that receives the icon location. The icon location is a
    ///                  null-terminated string that identifies the file that contains the icon.
    ///    cchMax = Type: <b>UINT</b> The size of the buffer, in characters, pointed to by <i>pszIconFile</i>.
    ///    piIndex = Type: <b>int*</b> A pointer to an <b>int</b> that receives the index of the icon in the file pointed to by
    ///              <i>pszIconFile</i>.
    ///    pwFlags = Type: <b>UINT*</b> A pointer to a <b>UINT</b> value that receives zero or a combination of the following
    ///              values.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the function returned a valid location, or S_FALSE if the Shell should
    ///    use a default icon. If the <b>GIL_ASYNC</b> flag is set in <i>uFlags</i>, the method can return E_PENDING to
    ///    indicate that icon extraction will be time-consuming.
    ///    
    HRESULT GetIconLocation(uint uFlags, const(wchar)* pszIconFile, uint cchMax, int* piIndex, uint* pwFlags);
    ///Extracts an icon image from the specified location.
    ///Params:
    ///    pszFile = Type: <b>PCTSTR</b> A pointer to a null-terminated string that specifies the icon location.
    ///    nIconIndex = Type: <b>UINT</b> The index of the icon in the file pointed to by <i>pszFile</i>.
    ///    phiconLarge = Type: <b>HICON*</b> A pointer to an <b>HICON</b> value that receives the handle to the large icon. This
    ///                  parameter may be <b>NULL</b>.
    ///    phiconSmall = Type: <b>HICON*</b> A pointer to an <b>HICON</b> value that receives the handle to the small icon. This
    ///                  parameter may be <b>NULL</b>.
    ///    nIconSize = Type: <b>UINT</b> The desired size of the icon, in pixels. The low word contains the size of the large icon,
    ///                and the high word contains the size of the small icon. The size specified can be the width or height. The
    ///                width of an icon always equals its height.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the function extracted the icon, or S_FALSE if the calling application
    ///    should extract the icon.
    ///    
    HRESULT Extract(const(wchar)* pszFile, uint nIconIndex, HICON* phiconLarge, HICON* phiconSmall, uint nIconSize);
}

///<p class="CCE_Message">[<b>IShellIconOverlayManager</b> is available for use in the operating systems specified in
///the Requirements section. It may be altered or unavailable in subsequent versions.] Exposes methods that retrieve the
///icon overlay information, including the overlay index and the image index for an IShellFolder object. This interface
///iterates through all the icon overlay IDs and keeps the information in an array.
@GUID("F10B5E34-DD3B-42A7-AA7D-2F4EC54BB09B")
interface IShellIconOverlayManager : IUnknown
{
    ///Gets the index of the icon overlay or the icon image for the specified file with the specified attributes.
    ///Params:
    ///    pwszPath = Type: <b>PCWSTR</b> The full path of the file.
    ///    dwAttrib = Type: <b>DWORD</b> The attributes of the file. This parameter can be a combination of any of the file
    ///               attribute flags (FILE_ATTRIBUTE_*) defined in the Windows header files. See File Attribute Constants.
    ///    pIndex = Type: <b>int*</b> A pointer to the icon index in the system image list.
    ///    dwflags = Type: <b>DWORD</b> For the index of the icon overlay, use SIOM_OVERLAYINDEX. For the index of the icon image,
    ///              use SIOM_ICONINDEX.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    appropriate index was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure for any reason. </td> </tr> </table>
    ///    
    HRESULT GetFileOverlayInfo(const(wchar)* pwszPath, uint dwAttrib, int* pIndex, uint dwflags);
    ///Gets the index of the icon overlay or the icon image for the specified file with the specified attributes from
    ///one of the reserved overlays.
    ///Params:
    ///    pwszPath = Type: <b>PCWSTR</b> The full path of the file.
    ///    dwAttrib = Type: <b>DWORD</b> The attributes of the file. This parameter can be a combination of any of the file
    ///               attribute flags (FILE_ATTRIBUTE_*) defined in the Windows header files. See File Attribute Constants.
    ///    pIndex = Type: <b>int*</b> The index of the icon image or icon overlay, depending on the value of <i>dwflags</i>.
    ///    dwflags = Type: <b>DWORD</b> For the index of the icon overlay, use SIOM_OVERLAYINDEX. For the index of the icon image,
    ///              use SIOM_ICONINDEX.
    ///    iReservedID = Type: <b>int</b> The reserved icon overlay ID.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    appropriate index was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure, for any reason. </td> </tr> </table>
    ///    
    HRESULT GetReservedOverlayInfo(const(wchar)* pwszPath, uint dwAttrib, int* pIndex, uint dwflags, 
                                   int iReservedID);
    ///Refreshes the overlay cache, the image list, or both.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> Determines what to refresh. It can be a bitwise OR one of the following:
    ///Returns:
    ///    Type: <b>HRESULT</b> This method always returns S_OK.
    ///    
    HRESULT RefreshOverlayImages(uint dwFlags);
    ///Loads any registered overlay identifiers, or handlers, that are not currently loaded.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Not
    ///    out of memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Out of memory. </td> </tr> </table>
    ///    
    HRESULT LoadNonloadedOverlayIdentifiers();
    ///Finds the index of an overlay image for the specified icon image. It can add an overlay if one is not found for
    ///the icon.
    ///Params:
    ///    iImage = Type: <b>int</b> The existing shell image list index to look for.
    ///    piIndex = Type: <b>int</b> The returned overlay index.
    ///    fAdd = Type: <b>BOOL</b> Whether to add an image if one is not already present.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    image index was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> An error occurred or the image was not found. </td> </tr> </table>
    ///    
    HRESULT OverlayIndexFromImageIndex(int iImage, int* piIndex, BOOL fAdd);
}

///Exposes methods that are used by a namespace extension to specify icon overlays for the objects it contains.
@GUID("7D688A70-C613-11D0-999B-00C04FD655E1")
interface IShellIconOverlay : IUnknown
{
    ///Gets the overlay index in the system image list.
    ///Params:
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> Pointer to an ITEMIDLIST structure that identifies the object whose icon is
    ///           being displayed.
    ///    pIndex = Type: <b>int*</b> Pointer to a value that states the overlay index (one-based) in the system image list. This
    ///             index is equivalent to the <i>iOverlay</i> value that is specified when you add an overlay image to a private
    ///             image list with the ImageList::SetOverlayImage function.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    index of an overlay was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> No overlay exists for this file. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt>
    ///    </dl> </td> <td width="60%"> The PIDL is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The argument is invalid, for example, if
    ///    <i>pIndex</i> is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PENDING</b></dt> </dl> </td>
    ///    <td width="60%"> The calling application passed OI_ASYNC to signify that the operation of calculating the
    ///    overlay index will take some time. </td> </tr> </table>
    ///    
    HRESULT GetOverlayIndex(ITEMIDLIST* pidl, int* pIndex);
    ///Gets the index of the icon overlay in the system image list.
    ///Params:
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> Pointer to an ITEMIDLIST structure that identifies the object whose icon is
    ///           being displayed.
    ///    pIconIndex = Type: <b>int*</b> Pointer to the index of the icon overlay's image in the system image list. This index is
    ///                 equivalent to the <i>iImage</i> value that is specified when you add an overlay image to a private image list
    ///                 with the ImageList::SetOverlayImage function.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    index of an overlay was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> No overlay exists for this file. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt>
    ///    </dl> </td> <td width="60%"> The PIDL is invalid. </td> </tr> </table>
    ///    
    HRESULT GetOverlayIconIndex(ITEMIDLIST* pidl, int* pIconIndex);
}

@GUID("000214F5-0000-0000-C000-000000000046")
interface IShellExecuteHookA : IUnknown
{
    HRESULT Execute(SHELLEXECUTEINFOA* pei);
}

@GUID("000214FB-0000-0000-C000-000000000046")
interface IShellExecuteHookW : IUnknown
{
    HRESULT Execute(SHELLEXECUTEINFOW* pei);
}

///Exposes a method that is used by the browser to translate the address of an unknown URL protocol.
@GUID("AC60F6A0-0FD9-11D0-99CB-00C04FD64497")
interface IURLSearchHook : IUnknown
{
    ///Called by the browser when the browser cannot determine the protocol of a URL address.
    ///Params:
    ///    pwszSearchURL = Type: <b>PWSTR</b> The address of a wide character buffer that, on entry, contains the URL address for which
    ///                    the browser is trying to determine the protocol. On exit, this buffer contains the modified URL address if
    ///                    the method was successful. See the return value for more information.
    ///    cchBufferSize = Type: <b>DWORD</b> The size, in characters, of the buffer at <i>pwszSearchURL</i>.
    HRESULT Translate(const(wchar)* pwszSearchURL, uint cchBufferSize);
}

///Exposes methods that channel customization information to the search hooks.
@GUID("09F656A2-41AF-480C-88F7-16CC0D164615")
interface ISearchContext : IUnknown
{
    ///Retrieves the URL that is being searched for.
    ///Params:
    ///    pbstrSearchUrl = Type: <b>BSTR</b> The <b>BSTR</b> that receives the URL.
    HRESULT GetSearchUrl(BSTR* pbstrSearchUrl);
    ///Retrieves the text that is in the browser's Address bar.
    ///Params:
    ///    pbstrSearchText = Type: <b>BSTR</b> The <b>BSTR</b> that receives the text in the Address bar.
    HRESULT GetSearchText(BSTR* pbstrSearchText);
    ///Overrides the registry settings that determine how an autosearch is performed.
    ///Params:
    ///    pdwSearchStyle = Type: <b>DWORD</b> A pointer to a <b>DWORD</b> value that indicates how the search is performed.
    HRESULT GetSearchStyle(uint* pdwSearchStyle);
}

///Exposes a method that is used by the browser to translate the address of an unknown URL protocol by using a search
///context object.
@GUID("5EE44DA4-6D32-46E3-86BC-07540DEDD0E0")
interface IURLSearchHook2 : IURLSearchHook
{
    ///Called by the browser when the browser cannot determine the protocol of a URL address. This method uses a search
    ///context to determine the protocol.
    ///Params:
    ///    pwszSearchURL = Type: <b>PWSTR</b> The address of a wide character buffer that, on entry, contains the URL address for which
    ///                    the browser is trying to determine the protocol. On exit, this buffer contains the modified URL address if
    ///                    the method was successful.
    ///    cchBufferSize = Type: <b>DWORD</b> The size, in characters, of the buffer at <i>lpwszSearchURL</i>.
    ///    pSearchContext = Type: <b>ISearchContext*</b> A pointer to an ISearchContext object. This parameter can be <b>NULL</b>.
    HRESULT TranslateWithSearchContext(const(wchar)* pwszSearchURL, uint cchBufferSize, 
                                       ISearchContext pSearchContext);
}

///Exposed by Shell folders to provide detailed information about the items in a folder. This is the same information
///that is displayed by the Windows Explorer when the view of the folder is set to Details. For Windows 2000 and later
///systems, <b>IShellDetails</b> is superseded by IShellFolder2.
@GUID("000214EC-0000-0000-C000-000000000046")
interface IShellDetails : IUnknown
{
    ///Gets detailed information on an item in a Shell folder.
    ///Params:
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> The PIDL of the item that you are requesting information for. If this parameter
    ///           is set to <b>NULL</b>, the title of the information field specified by <i>iColumn</i> will be returned in the
    ///           SHELLDETAILS structure pointed to by <i>pDetails</i>.
    ///    iColumn = Type: <b>UINT</b> The zero-based index of the desired information field. It is identical to column number of
    ///              the information as it is displayed in a Windows Explorer Details view.
    ///    pDetails = Type: <b>SHELLDETAILS*</b> A pointer to a SHELLDETAILS structure with the detail information.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful. Returns E_FAIL if <i>iColumn</i> exceeds the number of
    ///    columns supported by the folder. Otherwise, returns a standard COM error code.
    ///    
    HRESULT GetDetailsOf(ITEMIDLIST* pidl, uint iColumn, SHELLDETAILS* pDetails);
    ///Rearranges a column.
    ///Params:
    ///    iColumn = Type: <b>UINT</b> The index of the column to be rearranged.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_FALSE to tell the calling application to sort the selected column. Otherwise,
    ///    returns S_OK if successful, a COM error code otherwise.
    ///    
    HRESULT ColumnClick(uint iColumn);
}

///Exposes methods that allow a client to append or remove an object from a collection of objects managed by a server
///object.
@GUID("00BB2761-6A77-11D0-A535-00C04FD7D062")
interface IObjMgr : IUnknown
{
    ///Appends an object to the collection of managed objects.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> The address of the IUnknown interface of the object to be added to the list.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error code otherwise.
    ///    
    HRESULT Append(IUnknown punk);
    ///Removes an object from the collection of managed objects.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> The address of the IUnknown interface of the object to be removed from the list.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error code otherwise.
    ///    
    HRESULT Remove(IUnknown punk);
}

///Exposes a method that improves the efficiency of autocompletion when the candidate strings are organized in a
///hierarchy.
@GUID("77A130B0-94FD-11D0-A544-00C04FD7D062")
interface IACList : IUnknown
{
    ///Requests that the autocompletion client generate candidate strings associated with a specified item in its
    ///namespace.
    ///Params:
    ///    pszExpand = Type: <b>PCWSTR</b> A pointer to a null-terminated, Unicode string to be expanded by the autocomplete object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Expand(const(wchar)* pszExpand);
}

///Extends the IACList interface to enable clients of an autocomplete object to retrieve and set option flags.
@GUID("470141A0-5186-11D2-BBB6-0060977B464C")
interface IACList2 : IACList
{
    ///Sets the current autocomplete options.
    ///Params:
    ///    dwFlag = Type: <b>DWORD</b> New option flags. Use these flags to ask the client to include the names of the files and
    ///             subfolders of the specified folders the next time the client's IEnumString interface is called. This
    ///             parameter can contain one or more of the following flags.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
    ///    
    HRESULT SetOptions(uint dwFlag);
    ///Gets the current autocomplete options.
    ///Params:
    ///    pdwFlag = Type: <b>DWORD*</b> A pointer to a value that will hold the current option flag when the method returns. This
    ///              can be a combination of the following values.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or a COM error value otherwise.
    ///    
    HRESULT GetOptions(uint* pdwFlag);
}

///Exposes methods that provide options for an application to display a progress dialog box. This interface is exported
///by the progress dialog box object (CLSID_ProgressDialog). This object is a generic way to show a user how an
///operation is progressing. It is typically used when deleting, uploading, copying, moving, or downloading large
///numbers of files.
@GUID("EBBC7C04-315E-11D2-B62F-006097DF5BD4")
interface IProgressDialog : IUnknown
{
    ///Starts the progress dialog box.
    ///Params:
    ///    hwndParent = Type: <b>HWND</b> A handle to the dialog box's parent window.
    ///    punkEnableModless = Type: <b>IUnknown*</b> Reserved. Set to <b>NULL</b>.
    ///    dwFlags = Type: <b>DWORD</b> Flags that control the operation of the progress dialog box. A combination of the
    ///              following values:
    ///    pvResevered = Type: <b>LPCVOID</b> Reserved. Set to <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StartProgressDialog(HWND hwndParent, IUnknown punkEnableModless, uint dwFlags, void* pvResevered);
    ///Stops the progress dialog box and removes it from the screen.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StopProgressDialog();
    ///Sets the title of the progress dialog box.
    ///Params:
    ///    pwzTitle = Type: <b>PCWSTR</b> A pointer to a null-terminated Unicode string that contains the dialog box title.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetTitle(const(wchar)* pwzTitle);
    ///<p class="CCE_Message">[This method is not supported in Windows Vista or later versions.] Specifies an
    ///Audio-Video Interleaved (AVI) clip that runs in the dialog box.
    ///Params:
    ///    hInstAnimation = Type: <b>HINSTANCE</b> An instance handle to the module from which the AVI resource should be loaded.
    ///    idAnimation = Type: <b>UINT</b> An AVI resource identifier. To create this value, use the MAKEINTRESOURCE macro. The
    ///                  control loads the AVI resource from the module specified by <i>hInstAnimation</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or an error value otherwise. In Windows Vista and
    ///    later versions, always returns <b>S_OK</b>.
    ///    
    HRESULT SetAnimation(HINSTANCE hInstAnimation, uint idAnimation);
    ///Checks whether the user has canceled the operation.
    ///Returns:
    ///    Type: <b>BOOL</b> <b>TRUE</b> if the user has canceled the operation; otherwise, <b>FALSE</b>.
    ///    
    BOOL    HasUserCancelled();
    ///Updates the progress dialog box with the current state of the operation.
    ///Params:
    ///    dwCompleted = Type: <b>DWORD</b> An application-defined value that indicates what proportion of the operation has been
    ///                  completed at the time the method was called.
    ///    dwTotal = Type: <b>DWORD</b> An application-defined value that specifies what value <i>dwCompleted</i> will have when
    ///              the operation is complete.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetProgress(uint dwCompleted, uint dwTotal);
    ///Updates the progress dialog box with the current state of the operation.
    ///Params:
    ///    ullCompleted = Type: <b>ULONGLONG</b> An application-defined value that indicates what proportion of the operation has been
    ///                   completed at the time the method was called.
    ///    ullTotal = Type: <b>ULONGLONG</b> An application-defined value that specifies what value <i>ullCompleted</i> will have
    ///               when the operation is complete.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetProgress64(ulong ullCompleted, ulong ullTotal);
    ///Displays a message in the progress dialog.
    ///Params:
    ///    dwLineNum = Type: <b>DWORD</b> The line number on which the text is to be displayed. Currently there are three lines—1,
    ///                2, and 3. If the <b>PROGDLG_AUTOTIME</b> flag was included in the <i>dwFlags</i> parameter when
    ///                IProgressDialog::StartProgressDialog was called, only lines 1 and 2 can be used. The estimated time will be
    ///                displayed on line 3.
    ///    pwzString = Type: <b>PCWSTR</b> A null-terminated Unicode string that contains the text.
    ///    fCompactPath = Type: <b>BOOL</b> <b>TRUE</b> to have path strings compacted if they are too large to fit on a line. The
    ///                   paths are compacted with PathCompactPath.
    ///    pvResevered = Type: <b>LPCVOID</b> Reserved. Set to <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetLine(uint dwLineNum, const(wchar)* pwzString, BOOL fCompactPath, void* pvResevered);
    ///Sets a message to be displayed if the user cancels the operation.
    ///Params:
    ///    pwzCancelMsg = Type: <b>PCWSTR</b> A pointer to a null-terminated Unicode string that contains the message to be displayed.
    ///    pvResevered = Type: <b>LPCVOID</b> Reserved. Set to <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCancelMsg(const(wchar)* pwzCancelMsg, void* pvResevered);
    ///Resets the progress dialog box timer to zero.
    ///Params:
    ///    dwTimerAction = Type: <b>DWORD</b> Flags that indicate the action to be taken by the timer. One of the following values:
    ///    pvResevered = Type: <b>LPCVOID</b> Reserved. Set to <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Timer(uint dwTimerAction, void* pvResevered);
}

///Exposes methods that manage the border space for one or more IDockingWindow objects. This interface is implemented by
///the browser and is similar to the IOleInPlaceUIWindow interface.
@GUID("2A342FC2-7B26-11D0-8CA9-00A0C92DBFE8")
interface IDockingWindowSite : IOleWindow
{
    ///Gets the border space allocated for the specified IDockingWindow object.
    ///Params:
    ///    punkObj = Type: <b>IUnknown*</b> Pointer to the IDockingWindow object for which the border space is being requested.
    ///    prcBorder = Type: <b>RECT*</b> Pointer to a structure that, when this method returns successfully, receives the entire
    ///                available border space for the browser. The docking window object should use this information to determine
    ///                where to place itself. See the IDockingWindow::ResizeBorderDW method for more information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBorderDW(IUnknown punkObj, RECT* prcBorder);
    ///Approves, modifies, or refuses a request for an IDockingWindow object's border space. The border space is not
    ///allocated until the SetBorderSpaceDW method is called.
    ///Params:
    ///    punkObj = Type: <b>IUnknown*</b> Pointer to the IDockingWindow object for which the border space is being requested.
    ///    pbw = Type: <b>LPCBORDERWIDTHS</b> A pointer to a BORDERWIDTHS structure. Before calling this method, the structure
    ///          must be filled with the desired border space. After the method returns successfully, the structure contains
    ///          the approved border space. The IDockingWindowSite object may change these values. If border space is
    ///          critical, it is the caller's responsibility to determine if the returned border space is sufficient.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the border space request is approved or modified, or an error value
    ///    otherwise.
    ///    
    HRESULT RequestBorderSpaceDW(IUnknown punkObj, RECT* pbw);
    ///Allocates and reserves border space for an IDockingWindow object.
    ///Params:
    ///    punkObj = Type: <b>IUnknown*</b> A pointer to the IDockingWindow object for which the border space is being set.
    ///    pbw = Type: <b>LPCBORDERWIDTHS</b> A pointer to a BORDERWIDTHS structure that contains the coordinates of the
    ///          IDockingWindow object's border space. The border space should be approved through a successful call to the
    ///          IDockingWindowSite::RequestBorderSpaceDW method before <b>SetBorderSpaceDW</b> is called with these
    ///          coordinates.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetBorderSpaceDW(IUnknown punkObj, RECT* pbw);
}

///Exposes a method that notifies a Shell namespace extension when the ID of an item has changed.
@GUID("D82BE2B1-5764-11D0-A96E-00C04FD705A2")
interface IShellChangeNotify : IUnknown
{
    ///Informs a namespace extension that an event has taken place that affects its items.
    ///Params:
    ///    lEvent = Type: <b>LONG</b> A value that describes the event that has occurred. Typically, only one event is specified
    ///             at a time. If more than one event is specified, the values contained in the <i>pidl1</i> and <i>pidl2</i>
    ///             parameters must be the same, respectively, for all specified events.The <i>lEvent</i> parameter may contain
    ///             one or more of the following flags.
    ///    pidl1 = Type: <b>PCIDLIST_ABSOLUTE</b> The first event-dependent item identifier.
    ///    pidl2 = Type: <b>PCIDLIST_ABSOLUTE</b> The second event-dependent item identifier.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnChange(int lEvent, ITEMIDLIST* pidl1, ITEMIDLIST* pidl2);
}

///Exposes methods that the Shell uses to retrieve flags and info tip information for an item that resides in an
///IShellFolder implementation. Info tips are usually displayed inside a tooltip control.
@GUID("00021500-0000-0000-C000-000000000046")
interface IQueryInfo : IUnknown
{
    ///Gets the info tip text for an item.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> Flags that direct the handling of the item from which you're retrieving the info tip text.
    ///              This value is commonly zero (<b>QITIPF_DEFAULT</b>). The following values are recognized.
    ///    ppwszTip = Type: <b>PWSTR*</b> The address of a Unicode string pointer that, when this method returns successfully,
    ///               receives the tip string pointer. Applications that implement this method must allocate memory for
    ///               <i>ppwszTip</i> by calling CoTaskMemAlloc. Calling applications must call CoTaskMemFree to free the memory
    ///               when it is no longer needed.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the function succeeds. If no info tip text is available, <i>ppwszTip</i>
    ///    is set to <b>NULL</b>. Otherwise, returns a COM-defined error value.
    ///    
    HRESULT GetInfoTip(uint dwFlags, ushort** ppwszTip);
    ///Gets the information flags for an item. This method is not currently used.
    ///Params:
    ///    pdwFlags = Type: <b>DWORD*</b> A pointer to a value that receives the flags for the item. If no flags are to be
    ///               returned, this value should be set to zero.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if <i>pdwFlags</i> returns any flag values, or a COM-defined error value
    ///    otherwise.
    ///    
    HRESULT GetInfoFlags(uint* pdwFlags);
}

///Exposes a method that allows communication between Windows Explorer and a folder view implemented using the system
///folder view object (the IShellView object returned through SHCreateShellFolderView) so that the folder view can be
///notified of events and modify its view accordingly.
@GUID("2047E320-F2A9-11CE-AE65-08002B2E1262")
interface IShellFolderViewCB : IUnknown
{
    ///Allows communication between the system folder view object and a system folder view callback object.
    ///Params:
    ///    uMsg = Type: <b>UINT</b> One of the following notifications. <table class="clsStd"> <tr> <th>Notification</th>
    ///           <th>Usage</th> </tr> <tr> <td> SFVM_ADDPROPERTYPAGES </td> <td>Allows the callback object to provide a page
    ///           to add to the <b>Properties</b> property sheet of the selected object.</td> </tr> <tr> <td>
    ///           SFVM_BACKGROUNDENUM </td> <td>Allows the callback object to request that enumeration be done on a background
    ///           thread.</td> </tr> <tr> <td> SFVM_BACKGROUNDENUMDONE </td> <td>Notifies the callback object that background
    ///           enumeration is complete.</td> </tr> <tr> <td> SFVM_COLUMNCLICK </td> <td>Notifies the callback object that
    ///           the user has clicked a column header to sort the list of objects in the folder view.</td> </tr> <tr> <td>
    ///           SFVM_DEFITEMCOUNT </td> <td>Allows the callback object to specify the number of items in the folder
    ///           view.</td> </tr> <tr> <td> SFVM_DEFVIEWMODE </td> <td>Allows the callback object to specify the view
    ///           mode.</td> </tr> <tr> <td> SFVM_DIDDRAGDROP </td> <td>Notifies the callback function that a drag-and-drop
    ///           operation has begun.</td> </tr> <tr> <td> SFVM_FSNOTIFY </td> <td>Notifies the callback object that an event
    ///           has taken place that affects one of its items.</td> </tr> <tr> <td> SFVM_GETANIMATION </td> <td>Allows the
    ///           callback object to specify that an animation be displayed while items are enumerated on a background
    ///           thread.</td> </tr> <tr> <td> SFVM_GETBUTTONINFO </td> <td>Allows the callback object to add buttons to the
    ///           toolbar.</td> </tr> <tr> <td> SFVM_GETBUTTONS </td> <td>Allows the callback object to specify the buttons to
    ///           be added to the toolbar.</td> </tr> <tr> <td> SFVM_GETDETAILSOF </td> <td>Allows the callback object to
    ///           provide the details for an item in a Shell folder. Use only if a call to GetDetailsOf fails and there is no
    ///           GetDetailsOf method available to call.</td> </tr> <tr> <td> SFVM_GETHELPTEXT </td> <td>Allows the callback
    ///           object to specify a help text string for menu items or toolbar buttons.</td> </tr> <tr> <td>
    ///           SFVM_GETHELPTOPIC </td> <td>Allows the callback object to specify a Help file and topic.</td> </tr> <tr> <td>
    ///           SFVM_GETNOTIFY </td> <td>Specifies which events will generate an SFVM_FSNOTIFY message for a given item.</td>
    ///           </tr> <tr> <td> SFVM_GETPANE </td> <td>Allows the callback object to provide the status bar pane in which to
    ///           display the Internet zone information.</td> </tr> <tr> <td> SFVM_GETSORTDEFAULTS </td> <td>Allows the
    ///           callback object to specify default sorting parameters.</td> </tr> <tr> <td> SFVM_GETTOOLTIPTEXT </td>
    ///           <td>Allows the callback object to specify a tooltip text string for menu items or toolbar buttons.</td> </tr>
    ///           <tr> <td> SFVM_GETZONE </td> <td>Allows the callback object to provide Internet zone information.</td> </tr>
    ///           <tr> <td> SFVM_INITMENUPOPUP </td> <td>Allows the callback object to modify an item's context menu.</td>
    ///           </tr> <tr> <td> SFVM_INVOKECOMMAND </td> <td>Notifies the callback object that one of its toolbar or menu
    ///           commands has been invoked.</td> </tr> <tr> <td> SFVM_MERGEMENU </td> <td>Allows the callback object to merge
    ///           menu items into the Windows Explorer menus.</td> </tr> <tr> <td> SFVM_QUERYFSNOTIFY </td> <td>Allows the
    ///           callback object to register a folder so that changes to that folder's view will generate notifications.</td>
    ///           </tr> <tr> <td> SFVM_SETISFV </td> <td>Notifies the callback object of the container site. This is used only
    ///           when IObjectWithSite::SetSite is not supported and SHCreateShellFolderViewEx is used.</td> </tr> <tr> <td>
    ///           SFVM_SIZE </td> <td>Notifies the callback object that the folder view has been resized.</td> </tr> <tr> <td>
    ///           SFVM_THISIDLIST </td> <td>Allows the callback object to specify the view's PIDL. This is used only when
    ///           SetIDList and IPersistFolder2::GetCurFolder have failed.</td> </tr> <tr> <td> SFVM_UNMERGEMENU </td>
    ///           <td>Notifies the callback object that a menu is being removed.</td> </tr> <tr> <td> SFVM_UPDATESTATUSBAR
    ///           </td> <td>Allows the callback object to request that the status bar be updated.</td> </tr> <tr> <td>
    ///           SFVM_WINDOWCREATED </td> <td>Notifies the callback object that the folder view window is being created.</td>
    ///           </tr> </table>
    ///    wParam = Type: <b>WPARAM</b> Additional information. See the individual notification pages for specific requirements.
    ///    lParam = Type: <b>LPARAM</b> Additional information. See the individual notification pages for specific requirements.
    HRESULT MessageSFVCB(uint uMsg, WPARAM wParam, LPARAM lParam);
}

///<p class="CCE_Message">[<b>IShellFolderView</b> is no longer available for use as of Windows 7. Instead, use
///IFolderView2 and IFolderView.] Exposes methods that manipulate Shell folder views.
@GUID("37A378C0-F82D-11CE-AE65-08002B2E1262")
interface IShellFolderView : IUnknown
{
    ///<p class="CCE_Message">[<b>Rearrange</b> is available for use in the operating systems specified in the
    ///Requirements section. It may be altered or unavailable in subsequent versions. Instead, use GetSortColumns.]
    ///Rearranges the items in a view according to a sorting rule.
    ///Params:
    ///    lParamSort = Type: <b>LPARAM</b> Specifies how the rearrangement should be performed. The lower sixteen bits of
    ///                 <i>lParamSort</i> define the sorting rule. Most applications set the sorting rule to the default value of
    ///                 zero, indicating that the items should be sorted by name. The system does not define any other sorting rules.
    ///                 Some folder objects might allow calling applications to use the lower sixteen bits of <i>lParamSort</i> to
    ///                 specify folder-specific sorting rules. The rules and their associated <i>lParamSort</i> values are defined by
    ///                 the folder. When the system folder view object calls <b>IShellFolderView::Rearrange</b>, the lower sixteen
    ///                 bits of <i>lParamSort</i> are used to specify the column to be used for the arranging. The upper sixteen bits
    ///                 of <i>lParamSort</i> are used for flags that modify the sorting rule. The system currently defines the
    ///                 following modifier flags.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Rearrange(LPARAM lParamSort);
    ///Gets the arrangement parameter of the view, which is how the view has been sorted. <div class="alert"><b>Note</b>
    ///This method is deprecated as of Windows Vista. It might be altered or unavailable in subsequent versions of
    ///Windows. We recommend that you use IFolderView2::GetSortColumns instead.</div><div> </div>
    ///Params:
    ///    plParamSort = Type: <b>LPARAM*</b> The lower sixteen bits of <i>plParamSort</i> define the sorting rule. Most applications
    ///                  set the sorting rule to the default value of zero, indicating that the items should be sorted by name. The
    ///                  system does not define any other sorting rules. Some folder objects might allow calling applications to use
    ///                  the lower sixteen bits of <i>plParamSort</i> to specify folder-specific sorting rules. The rules and their
    ///                  associated <i>plParamSort</i> values are defined by the folder. When the system folder view object calls
    ///                  <b>IShellFolderView::GetArrangeParam</b>, the lower sixteen bits of <i>plParamSort</i> are used to specify
    ///                  the column to be used for the arranging. The upper sixteen bits of <i>plParamSort</i> are used for flags that
    ///                  modify the sorting rule. The system currently defines the following modifier flags.
    HRESULT GetArrangeParam(LPARAM* plParamSort);
    ///<p class="CCE_Message">[<b>ArrangeGrid</b> is available for use in the operating systems specified in the
    ///Requirements section. It may be altered or unavailable in subsequent versions.] Arranges moved icons so that they
    ///align to an invisible grid.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ArrangeGrid();
    ///<p class="CCE_Message">[<b>AutoArrange</b> is available for use in the operating systems specified in the
    ///Requirements section. It may be altered or unavailable in subsequent versions.] Arranges moved icons so that they
    ///tend toward the left side of the viewing area and displace other icons with which they come into contact.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, S_FALSE if the view is not in Auto Arrange mode, or an error
    ///    value otherwise.
    ///    
    HRESULT AutoArrange();
    ///<p class="CCE_Message">[<b>GetAutoArrange</b> is available for use in the operating systems specified in the
    ///Requirements section. It may be altered or unavailable in subsequent versions. Instead, use
    ///IFolderView::GetAutoArrange.] Gets the current state of the folder's Auto Arrange mode.
    HRESULT GetAutoArrange();
    ///<p class="CCE_Message">[<b>AddObject</b> is available for use in the operating systems specified in the
    ///Requirements section. It may be altered or unavailable in subsequent versions.] Adds an item to the view.
    ///Params:
    ///    pidl = Type: <b>PUITEMID_CHILD</b> A pointer to an ItemID that specifies the item to add to the view.
    ///    puItem = Type: <b>UINT*</b> A pointer to a value that, when this method returns successfully, receives the index
    ///             position of the added item.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddObject(ITEMIDLIST* pidl, uint* puItem);
    HRESULT GetObjectA(ITEMIDLIST** ppidl, uint uItem);
    ///<p class="CCE_Message">[<b>RemoveObject</b> is available for use in the operating systems specified in the
    ///Requirements section. It may be altered or unavailable in subsequent versions.] Removes an item from the view.
    ///Params:
    ///    pidl = Type: <b>PUITEMID_CHILD</b> A pointer to the item to remove from the view. This value can be <b>NULL</b>.
    ///           When using the system folder view object (DefView) under Windows XP and Windows Vista, a <b>NULL</b> value
    ///           results in the removal of all objects from the view.
    ///    puItem = Type: <b>UINT*</b> When this method returns, contains a pointer to the index position of the removed item.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveObject(ITEMIDLIST* pidl, uint* puItem);
    ///<p class="CCE_Message">[<b>GetObjectCount</b> is no longer available for use as of Windows Vista. Instead, use
    ///ItemCount.] Gets the number of items in the folder view.
    ///Params:
    ///    puCount = Type: <b>UINT*</b> When this method returns, contains a pointer to the number of items displayed in the
    ///              folder view.
    HRESULT GetObjectCount(uint* puCount);
    ///<p class="CCE_Message">[<b>SetObjectCount</b> is no longer available for use as of Windows Vista.] Sets the
    ///number of items in the ListView control that the view contains.
    ///Params:
    ///    uCount = Type: <b>UINT</b> The number of items to set the ListView control to.
    ///    dwFlags = Type: <b>UINT</b> Flags that control the behavior of the ListView control when the number of items is set.
    ///              Includes the following:
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. Starting with Windows Vista,
    ///    calls to <b>SetObjectCount</b> always return E_NOTIMPL.
    ///    
    HRESULT SetObjectCount(uint uCount, uint dwFlags);
    ///<p class="CCE_Message">[<b>UpdateObject</b> is available for use in the operating systems specified in the
    ///Requirements section. It may be altered or unavailable in subsequent versions.] Replaces an item in a view with
    ///another item.
    ///Params:
    ///    pidlOld = Type: <b>PUITEMID_CHILD</b> The original item.
    ///    pidlNew = Type: <b>PUITEMID_CHILD</b> The new item.
    ///    puItem = Type: <b>UINT*</b> When this method returns, contains a pointer to the index of the item that was replaced.
    ///             You can use this value to call IShellFolderView::GetObject on later to get back the PITEMID_CHILD that you
    ///             just added.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UpdateObject(ITEMIDLIST* pidlOld, ITEMIDLIST* pidlNew, uint* puItem);
    ///<p class="CCE_Message">[<b>RefreshObject</b> is available for use in the operating systems specified in the
    ///Requirements section. It may be altered or unavailable in subsequent versions.] Redraws the given item.
    ///Params:
    ///    pidl = Type: <b>PUITEMID_CHILD</b> The item to be redrawn.
    ///    puItem = Type: <b>UINT*</b> A pointer to a value that, when this method returns successfully, receives the index of
    ///             the item that was redrawn. You can use this value to call IShellFolderView::GetObject to retrieve the
    ///             PITEMID_CHILD that you just redrew.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RefreshObject(ITEMIDLIST* pidl, uint* puItem);
    ///<p class="CCE_Message">[This method is available through Windows Vista. It might be altered or unavailable in
    ///subsequent versions of Windows.] Allows a view to be redrawn or prevents it from being redrawn.
    ///Params:
    ///    bRedraw = Type: <b>BOOL</b> <b>TRUE</b> if the content can be redrawn after a change; <b>FALSE</b> if the content
    ///              cannot be redrawn after a change.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRedraw(BOOL bRedraw);
    ///<p class="CCE_Message">[<b>GetSelectedCount</b> is no longer available for use as of Windows Vista. Instead, use
    ///IFolderView2::GetSelection.] Gets the number of items in the view that are selected.
    ///Params:
    ///    puSelected = Type: <b>UINT*</b> A pointer to a value that, when this method returns successfully, receives the number of
    ///                 selected items in the view.
    HRESULT GetSelectedCount(uint* puSelected);
    ///<p class="CCE_Message">[This method has been deprecated. Use IFolderView2::GetSelection instead.] Gets an array
    ///of the objects in the view that are selected and the number of those objects.
    ///Params:
    ///    pppidl = Type: <b>PCUITEMID_CHILD**</b> The address of a pointer that, when this method returns successfully, points
    ///             to an array of the currently selected items in the view. The calling application is expected to free the
    ///             array at <i>pppidl</i> using LocalFree. The calling application must not free the individual items contained
    ///             in the array.
    ///    puItems = Type: <b>UINT*</b> A pointer to a value that, when this method returns successfully, receives the number of
    ///              items in the <i>pppidl</i> array.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSelectedObjects(ITEMIDLIST*** pppidl, uint* puItems);
    ///<p class="CCE_Message">[This method has been deprecated. Use IFolderView2::IsMoveInSameFolder instead.] Checks
    ///whether the destination of the current drag-and-drop or cut-and-paste operation is the same as the source.
    ///Params:
    ///    pDropTarget = Type: <b>IDropTarget*</b> A pointer to a destination drop target object.
    HRESULT IsDropOnSource(IDropTarget pDropTarget);
    ///<p class="CCE_Message">[This method is available through Windows Vista. It might be altered or unavailable in
    ///subsequent versions of Windows.] Gets the point at which the current drag-and-drop operation was initiated.
    ///Params:
    ///    ppt = Type: <b>POINT*</b> A pointer to a structure that, when this method returns successfully, receives the
    ///          coordinates from which the current drag-and-drop operation was initiated.
    HRESULT GetDragPoint(POINT* ppt);
    ///<p class="CCE_Message">[This method is available through Windows Vista. It might be altered or unavailable in
    ///subsequent versions of Windows.] Gets the point at which the current drag-and-drop operation was terminated.
    ///Params:
    ///    ppt = Type: <b>POINT*</b> A pointer to a structure that, when this method returns successfully, receives the
    ///          coordinates at which the current drag-and-drop operation was terminated.
    HRESULT GetDropPoint(POINT* ppt);
    ///This method is not implemented.
    ///Params:
    ///    pDataObject = Type: <b>IDataObject*</b>
    HRESULT MoveIcons(IDataObject pDataObject);
    ///<p class="CCE_Message">[This method has been deprecated. Use IFolderView::SelectAndPositionItems instead.] Sets
    ///the position of the given item.
    ///Params:
    ///    pidl = Type: <b>PCUITEMID_CHILD</b> A PIDL that corresponds to the item for which the position is being set.
    ///    ppt = Type: <b>POINT*</b> A pointer to a structure that contains the new coordinates of the item relative to the
    ///          ListView contained in the view.
    HRESULT SetItemPos(ITEMIDLIST* pidl, POINT* ppt);
    ///<p class="CCE_Message">[<b>IsBkDropTarget</b> is available for use in the operating systems specified in the
    ///Requirements section. It may be altered or unavailable in subsequent versions.] Checks if the target of a
    ///drag-and-drop operation is the background of the view.
    ///Params:
    ///    pDropTarget = Type: <b>IDropTarget*</b> A pointer to the target of the drag-and-drop operation.
    HRESULT IsBkDropTarget(IDropTarget pDropTarget);
    ///<p class="CCE_Message">[<b>SetClipboard</b> is available for use in the operating systems specified in the
    ///Requirements section. It may be altered or unavailable in subsequent versions.] Performs a cut operation on the
    ///current selection.
    ///Params:
    ///    bMove = Type: <b>BOOL</b> Must be <b>TRUE</b>.
    HRESULT SetClipboard(BOOL bMove);
    ///<p class="CCE_Message">[<b>SetPoints</b> is available for use in the operating systems specified in the
    ///Requirements section. It may be altered or unavailable in subsequent versions.] Copies the points at which the
    ///current selection is located into a data object.
    ///Params:
    ///    pDataObject = Type: <b>IDataObject*</b> A pointer to the data object. This data object contains the points of location of
    ///                  the current selection. These points are given in coordinates relative to the ListView control that the view
    ///                  contains. These points can be used for positioning the object at the end of a drag-and-drop operation.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPoints(IDataObject pDataObject);
    ///<p class="CCE_Message">[This method has been deprecated. Use IFolderView::GetSpacing instead.] Gets the spacing
    ///for small and large view modes only.
    ///Params:
    ///    pSpacing = Type: <b>ITEMSPACING*</b> A pointer to a structure that, when this method returns successfully, receives the
    ///               information that describes the view mode spacing.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if the current view mode is positionable; otherwise, <b>S_FALSE</b>.
    ///    
    HRESULT GetItemSpacing(ITEMSPACING* pSpacing);
    ///<p class="CCE_Message">[<b>IShellFolderView::SetCallback</b> is available for use in the operating systems
    ///specified in the Requirements section. It may be altered or unavailable in subsequent versions.] Replaces the
    ///callback object used by the view.
    ///Params:
    ///    pNewCB = Type: <b>IShellFolderViewCB*</b> A pointer to the new IShellFolderViewCB callback object.
    ///    ppOldCB = Type: <b>IShellFolderViewCB**</b> The address of an interface pointer that, when this method returns
    ///              successfully, points to the original IShellFolderViewCB object.
    HRESULT SetCallback(IShellFolderViewCB pNewCB, IShellFolderViewCB* ppOldCB);
    ///<p class="CCE_Message">[<b>IShellFolderView::Select</b> is available for use in the operating systems specified
    ///in the Requirements section. It may be altered or unavailable in subsequent versions.] Selects and unselects
    ///items in the view.
    ///Params:
    ///    dwFlags = Type: <b>UINT</b> Determines which items in the view are selected, if any. One of the following values.
    HRESULT Select(uint dwFlags);
    ///<p class="CCE_Message">[<b>QuerySupport</b> is available for use in the operating systems specified in the
    ///Requirements section. It may be altered or unavailable in subsequent versions.] This method is not implemented.
    ///Params:
    ///    pdwSupport = Type: <b>UINT*</b> Reserved. Must be <b>NULL</b>.
    HRESULT QuerySupport(uint* pdwSupport);
    ///<p class="CCE_Message">[This method is available through Windows Vista. It might be altered or unavailable in
    ///subsequent versions of Windows.] Replaces the internal automation object of the IShellView.
    ///Params:
    ///    pdisp = Type: <b>IDispatch*</b> A pointer to the new automation object.
    HRESULT SetAutomationObject(IDispatch pdisp);
}

///Exposes methods that provide an object with a specified property bag in which the object can save its properties.
@GUID("FB700430-952C-11D1-946F-000000000000")
interface INamedPropertyBag : IUnknown
{
    ///Causes a property to be read from the named property bag.
    ///Params:
    ///    pszBagname = Type: <b>PCWSTR</b> A pointer to a string that contains the name of the property bag.
    ///    pszPropName = Type: <b>PCWSTR</b> A pointer to a string that contains the name of the property to be read.
    ///    pVar = Type: <b>PROPVARIANT*</b> The address of a <b>VARIANT</b> that, when this method returns successfully,
    ///           receives the property value.
    HRESULT ReadPropertyNPB(const(wchar)* pszBagname, const(wchar)* pszPropName, PROPVARIANT* pVar);
    ///Saves a property to the named property bag.
    ///Params:
    ///    pszBagname = Type: <b>PCWSTR</b> A pointer to a string that contains the name of the property bag.
    ///    pszPropName = Type: <b>PCWSTR</b> A pointer to a string that contains the name of the property to write.
    ///    pVar = Type: <b>PROPVARIANT*</b> A pointer to a <b>VARIANT</b> that holds the new property value.
    HRESULT WritePropertyNPB(const(wchar)* pszBagname, const(wchar)* pszPropName, PROPVARIANT* pVar);
    ///Removes a property from a named property bag.
    ///Params:
    ///    pszBagname = Type: <b>PCWSTR</b> A pointer to a string that contains the name of the property bag from which a property is
    ///                 to be removed.
    ///    pszPropName = Type: <b>PCWSTR</b> A pointer to a string that contains the name of the property to remove.
    HRESULT RemovePropertyNPB(const(wchar)* pszBagname, const(wchar)* pszPropName);
}

///Exposes methods to create a new Internet shortcut.
@GUID("000214E1-0000-0000-C000-000000000046")
interface INewShortcutHookA : IUnknown
{
    ///Sets the referent of the shortcut object.
    ///Params:
    ///    pcszReferent = TBD
    ///    hwnd = TBD
    ///    hWnd = Type: <b>HWND</b> A handle to the window that will be used as the parent if the object needs to display a
    ///           message box or dialog box. This value can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetReferent(const(char)* pcszReferent, HWND hwnd);
    ///Gets the referent of the shortcut object.
    ///Params:
    ///    pszReferent = Type: <b>PTSTR</b> A pointer to a string that receives the referent.
    ///    cchReferent = Type: <b>int</b> The size of the buffer at <i>pszReferent</i>, in characters.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetReferent(const(char)* pszReferent, int cchReferent);
    ///Sets the folder name for the shortcut object.
    ///Params:
    ///    pcszFolder = TBD
    HRESULT SetFolder(const(char)* pcszFolder);
    ///Gets the folder name for the shortcut object.
    ///Params:
    ///    pszFolder = Type: <b>PTSTR</b> The address of a character buffer that receives the folder name.
    ///    cchFolder = Type: <b>int</b> The size of the buffer at <i>pszFolder</i>, in characters.
    HRESULT GetFolder(const(char)* pszFolder, int cchFolder);
    ///Gets the file name of the shortcut object, without the extension.
    ///Params:
    ///    pszName = Type: <b>PTSTR</b> A pointer to a string that receives the name.
    ///    cchName = Type: <b>int</b> The size of the buffer at <i>pszName</i>, in characters.
    HRESULT GetName(const(char)* pszName, int cchName);
    ///Gets the file name extension for the shortcut object.
    ///Params:
    ///    pszExtension = Type: <b>PTSTR</b> Pointer to a string that receives the extension.
    ///    cchExtension = Type: <b>int</b> The size of the buffer at <i>pszExtension</i>, in characters.
    HRESULT GetExtension(const(char)* pszExtension, int cchExtension);
}

///Exposes methods to create a new Internet shortcut.
@GUID("000214F7-0000-0000-C000-000000000046")
interface INewShortcutHookW : IUnknown
{
    ///Sets the referent of the shortcut object.
    ///Params:
    ///    pcszReferent = TBD
    ///    hwnd = TBD
    ///    hWnd = Type: <b>HWND</b> A handle to the window that will be used as the parent if the object needs to display a
    ///           message box or dialog box. This value can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetReferent(const(wchar)* pcszReferent, HWND hwnd);
    ///Gets the referent of the shortcut object.
    ///Params:
    ///    pszReferent = Type: <b>PTSTR</b> A pointer to a string that receives the referent.
    ///    cchReferent = Type: <b>int</b> The size of the buffer at <i>pszReferent</i>, in characters.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetReferent(const(wchar)* pszReferent, int cchReferent);
    ///Sets the folder name for the shortcut object.
    ///Params:
    ///    pcszFolder = TBD
    HRESULT SetFolder(const(wchar)* pcszFolder);
    ///Gets the folder name for the shortcut object.
    ///Params:
    ///    pszFolder = Type: <b>PTSTR</b> The address of a character buffer that receives the folder name.
    ///    cchFolder = Type: <b>int</b> The size of the buffer at <i>pszFolder</i>, in characters.
    HRESULT GetFolder(const(wchar)* pszFolder, int cchFolder);
    ///Gets the file name of the shortcut object, without the extension.
    ///Params:
    ///    pszName = Type: <b>PTSTR</b> A pointer to a string that receives the name.
    ///    cchName = Type: <b>int</b> The size of the buffer at <i>pszName</i>, in characters.
    HRESULT GetName(const(wchar)* pszName, int cchName);
    ///Gets the file name extension for the shortcut object.
    ///Params:
    ///    pszExtension = Type: <b>PTSTR</b> Pointer to a string that receives the extension.
    ///    cchExtension = Type: <b>int</b> The size of the buffer at <i>pszExtension</i>, in characters.
    HRESULT GetExtension(const(wchar)* pszExtension, int cchExtension);
}

///Exposes a method that creates a *copy hook handler*. A copy hook handler is a Shell extension that determines if a
///Shell folder or printer object can be moved, copied, renamed, or deleted. The Shell calls the
///[ICopyHookA::CopyCallback](nf-shlobj-icopyhooka-copycallback.md) method prior to performing one of these operations.
@GUID("000214EF-0000-0000-C000-000000000046")
interface ICopyHookA : IUnknown
{
    ///Determines whether the Shell will be allowed to move, copy, delete, or rename a folder or printer object.
    ///Params:
    ///    hwnd = A handle to the window that the copy hook handler should use as the parent for any user interface elements
    ///           the handler may need to display. If **FOF_SILENT** is specified in *wFunc*, the method should ignore this
    ///           parameter.
    ///    wFunc = The operation to perform. This parameter can be one of the values listed under the **wFunc** member of the
    ///            [SHFILEOPSTRUCT](/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa) structure.
    ///    wFlags = The flags that control the operation. This parameter can be one or more of the values listed under the
    ///             *fFlags* member of the [SHFILEOPSTRUCT](/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa) structure.
    ///             For printer copy hooks, this value is one of the following values defined in Shellapi.h. | Value |
    ///             Description | |-------------|------------| | **PO_DELETE** | A printer is being deleted. *pszSrcFile* points
    ///             to the full path to the specified printer. | | **PO_RENAME** | A printer is being renamed. The *pszSrcFile*
    ///             parameter points to the printer's new name. The *pszDestFile* parameter points to the old name. | |
    ///             **PO_PORTCHANGE** | Not supported. Do not use. | | **PO_REN_PORT** | Not supported. Do not use. |
    ///    pszSrcFile = A pointer to a string that contains the name of the source folder.
    ///    dwSrcAttribs = The attributes of the source folder. This parameter can be a combination of any of the file attribute flags
    ///                   (FILE_ATTRIBUTE_*) defined in the header files. See
    ///                   [https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants](File Attribute Constants).
    ///    pszDestFile = A pointer to a string that contains the name of the destination folder.
    ///    dwDestAttribs = The attributes of the destination folder. This parameter can be a combination of any of the file attribute
    ///                    flags (FILE_ATTRIBUTE_*) defined in the header files. See
    ///                    [https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants](File Attribute Constants).
    ///Returns:
    ///    Returns an integer value that indicates whether the Shell should perform the operation. One of the following:
    ///    | Value | Description | |-------------|------------| | **IDYES** | Allows the operation. | | **IDNO** |
    ///    Prevents the operation on this folder but continues with any other operations that have been approved (for
    ///    example, a batch copy operation). | | **IDCANCEL** | Prevents the current operation and cancels any pending
    ///    operations. |
    ///    
    uint CopyCallback(HWND hwnd, uint wFunc, uint wFlags, const(char)* pszSrcFile, uint dwSrcAttribs, 
                      const(char)* pszDestFile, uint dwDestAttribs);
}

///Exposes a method that creates a *copy hook handler*. A copy hook handler is a Shell extension that determines if a
///Shell folder or printer object can be moved, copied, renamed, or deleted. The Shell calls the
///[ICopyHookW::CopyCallback](nf-shlobj-icopyhookw-copycallback.md) method prior to performing one of these operations.
@GUID("000214FC-0000-0000-C000-000000000046")
interface ICopyHookW : IUnknown
{
    ///Determines whether the Shell will be allowed to move, copy, delete, or rename a folder or printer object.
    ///Params:
    ///    hwnd = A handle to the window that the copy hook handler should use as the parent for any user interface elements
    ///           the handler may need to display. If **FOF_SILENT** is specified in *wFunc*, the method should ignore this
    ///           parameter.
    ///    wFunc = The operation to perform. This parameter can be one of the values listed under the **wFunc** member of the
    ///            [SHFILEOPSTRUCT](/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa) structure.
    ///    wFlags = The flags that control the operation. This parameter can be one or more of the values listed under the
    ///             *fFlags* member of the [SHFILEOPSTRUCT](/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa) structure.
    ///             For printer copy hooks, this value is one of the following values defined in Shellapi.h. | Value |
    ///             Description | |-------------|------------| | **PO_DELETE** | A printer is being deleted. *pszSrcFile* points
    ///             to the full path to the specified printer. | | **PO_RENAME** | A printer is being renamed. The *pszSrcFile*
    ///             parameter points to the printer's new name. The *pszDestFile* parameter points to the old name. | |
    ///             **PO_PORTCHANGE** | Not supported. Do not use. | | **PO_REN_PORT** | Not supported. Do not use. |
    ///    pszSrcFile = A pointer to a string that contains the name of the source folder.
    ///    dwSrcAttribs = The attributes of the source folder. This parameter can be a combination of any of the file attribute flags
    ///                   (FILE_ATTRIBUTE_*) defined in the header files. See
    ///                   [https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants](File Attribute Constants).
    ///    pszDestFile = A pointer to a string that contains the name of the destination folder.
    ///    dwDestAttribs = The attributes of the destination folder. This parameter can be a combination of any of the file attribute
    ///                    flags (FILE_ATTRIBUTE_*) defined in the header files. See
    ///                    [https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants](File Attribute Constants).
    ///Returns:
    ///    Returns an integer value that indicates whether the Shell should perform the operation. One of the following:
    ///    | Value | Description | |-------------|------------| | **IDYES** | Allows the operation. | | **IDNO** |
    ///    Prevents the operation on this folder but continues with any other operations that have been approved (for
    ///    example, a batch copy operation). | | **IDCANCEL** | Prevents the current operation and cancels any pending
    ///    operations. |
    ///    
    uint CopyCallback(HWND hwnd, uint wFunc, uint wFlags, const(wchar)* pszSrcFile, uint dwSrcAttribs, 
                      const(wchar)* pszDestFile, uint dwDestAttribs);
}

///Exposes methods that enable a client to retrieve or set an object's current working directory.
@GUID("91956D21-9276-11D1-921A-006097DF5BD4")
interface ICurrentWorkingDirectory : IUnknown
{
    ///Gets the current working directory.
    ///Params:
    ///    pwzPath = Type: <b>PWSTR</b> Pointer to a buffer that, when this method returns successfully, receives the current
    ///              working directory's fully qualified path as a null-terminated Unicode string.
    ///    cchSize = Type: <b>DWORD</b> The size of the buffer in Unicode characters, including the terminating <b>NULL</b>
    ///              character.
    HRESULT GetDirectory(const(wchar)* pwzPath, uint cchSize);
    ///Sets the current working directory.
    ///Params:
    ///    pwzPath = Type: <b>PCWSTR</b> A pointer to the fully qualified path of the new working directory, as a null-terminated
    ///              Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDirectory(const(wchar)* pwzPath);
}

///Exposes methods that support the addition of IDockingWindow objects to a frame. Implemented by the browser.
@GUID("47D2657A-7B27-11D0-8CA9-00A0C92DBFE8")
interface IDockingWindowFrame : IOleWindow
{
    ///Adds the specified IDockingWindow object to the frame.
    ///Params:
    ///    punkSrc = Type: <b>IUnknown*</b> A pointer to the IDockingWindow object to be added.
    ///    pwszItem = Type: <b>PCWSTR</b> A pointer to a null-terminated, Unicode, application-defined string that is used to
    ///               identify the docking window object.
    ///    dwAddFlags = Type: <b>DWORD</b> Flags that apply to the docking window object that is being added. One or more of the
    ///                 following values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddToolbar(IUnknown punkSrc, const(wchar)* pwszItem, uint dwAddFlags);
    ///Removes the specified IDockingWindow from the toolbar frame.
    ///Params:
    ///    punkSrc = Type: <b>IUnknown*</b> Pointer to the IDockingWindow object to be removed. The IDockingWindowFrame
    ///              implementation calls the IDockingWindow::CloseDW and IDockingWindow::Release methods.
    ///    dwRemoveFlags = Type: <b>DWORD</b> Option flags for removing the docking window object. This parameter can be one or more of
    ///                    the following values:
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveToolbar(IUnknown punkSrc, uint dwRemoveFlags);
    ///Finds the specified IDockingWindow object in the toolbar frame and returns an interface pointer to it.
    ///Params:
    ///    pwszItem = Type: <b>PCWSTR</b> A pointer to a null-terminated, Unicode, application-defined string used to identify the
    ///               object. This is the same string that was passed to the AddToolbar method.
    ///    riid = Type: <b>REFIID</b> A reference to the desired interface ID. This is typically IID_IDockingWindow.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>. This
    ///          is typically IDockingWindow. If an error occurs, this value receives a null pointer.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT FindToolbar(const(wchar)* pwszItem, const(GUID)* riid, void** ppv);
}

///Exposes a method that obtains a thumbnail representation of an HTML wallpaper. <div class="alert"><b>Note</b> This
///interface is deprecated as of Windows 7. The feature it supported is no longer present in Windows.</div><div> </div>
@GUID("4EA39266-7211-409F-B622-F63DBD16C533")
interface IThumbnailCapture : IUnknown
{
    ///Retrieves a thumbnail representation of an IHTMLDocument2 document. <div class="alert"><b>Note</b> This method is
    ///deprecated as of Windows 7. The feature it supported is no longer present in Windows.</div><div> </div>
    ///Params:
    ///    pMaxSize = Type: <b>const SIZE*</b> A pointer to a SIZE structure that specifies the maximum size of the bitmap, in
    ///               pixels.
    ///    pHTMLDoc2 = Type: <b>IUnknown*</b> A pointer to an IHTMLDocument2 interface's IUnknown interface.
    ///    phbmThumbnail = Type: <b>HBITMAP*</b> A handle to a bitmap that represents the document object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CaptureThumbnail(const(SIZE)* pMaxSize, IUnknown pHTMLDoc2, HBITMAP* phbmThumbnail);
}

///<p class="CCE_Message">[<b>IShellFolderBand</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Exposes methods that manage folder
///bands. The Quick Launch bar is an example of a folder band.
@GUID("7FE80CC8-C247-11D0-B93A-00A0C90312E1")
interface IShellFolderBand : IUnknown
{
    ///Initializes an IShellFolderBand object.
    ///Params:
    ///    psf = Type: <b>IShellFolder*</b> A pointer to an IShellFolder object.
    ///    pidl = Type: <b>PCIDLIST_ABSOLUTE</b> A PIDL.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InitializeSFB(IShellFolder psf, ITEMIDLIST* pidl);
    ///Uses the information in a BANDINFOSFB structure to set the band information for a IShellFolderBand object.
    ///Params:
    ///    pbi = Type: <b>PBANDINFOSFB</b> A pointer to a BANDINFOSFB structure.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT SetBandInfoSFB(BANDINFOSFB* pbi);
    ///Gets information concerning an IShellFolderBand object and places it in a BANDINFOSFB structure.
    ///Params:
    ///    pbi = Type: <b>PBANDINFOSFB</b> A pointer to a BANDINFOSFB structure.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT GetBandInfoSFB(BANDINFOSFB* pbi);
}

@GUID("EB0FE175-1A3A-11D0-89B3-00A0C90A90AC")
interface IDeskBarClient : IOleWindow
{
    HRESULT SetDeskBarSite(IUnknown punkSite);
    HRESULT SetModeDBC(uint dwMode);
    HRESULT UIActivateDBC(uint dwState);
    HRESULT GetSize(uint dwWhich, RECT* prc);
}

///Exposes methods that enable the addition of custom columns in the Windows Explorer Details view. <div
///class="alert"><b>Note</b> Support for <b>IColumnProvider</b> has been removed as of Windows Vista. The Windows
///property system is used in its place. See Windows Property System for conceptual materials that explain the use of
///the new system.</div><div> </div>
@GUID("E8025004-1C42-11D2-BE2C-00A0C9A83DA1")
interface IColumnProvider : IUnknown
{
    ///Initializes an IColumnProvider interface.
    ///Params:
    ///    psci = Type: <b>LPCSHCOLUMNINIT</b> An SHCOLUMNINIT structure with initialization information, including the folder
    ///           whose contents are to be displayed.
    HRESULT Initialize(SHCOLUMNINIT* psci);
    ///Requests information about a column.
    ///Params:
    ///    dwIndex = Type: <b>DWORD</b> The column's zero-based index. It is an arbitrary value that is used to enumerate columns.
    ///    psci = Type: <b>SHCOLUMNINFO*</b> A pointer to an SHCOLUMNINFO structure to hold the column information.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns a COM error value to indicate that the request was unsuccessful or one of the
    ///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Request successful. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Column index out of range. </td> </tr> </table>
    ///    
    HRESULT GetColumnInfo(uint dwIndex, SHCOLUMNINFO* psci);
    ///Requests column data for a specified file.
    ///Params:
    ///    pscid = Type: <b>LPCSHCOLUMNID</b> An SHCOLUMNID structure that identifies the column.
    ///    pscd = Type: <b>LPCSHCOLUMNDATA</b> An SHCOLUMNDATA structure that specifies the file.
    ///    pvarData = Type: <b>VARIANT*</b> A pointer to a <b>VARIANT</b> with the data for the file specified by <i>pscd</i> that
    ///               belongs in the column specified by <i>pscid</i>. Set this value if the file is a member of the class
    ///               supported by the column provider.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if file data is returned, S_FALSE if the file is not supported by the
    ///    column provider and no data is returned, or a COM error value otherwise.
    ///    
    HRESULT GetItemData(PROPERTYKEY* pscid, SHCOLUMNDATA* pscd, VARIANT* pvarData);
}

///<p class="CCE_Message">[This interface is supported through Windows XP Service Pack 2 (SP2) and Windows Server 2003.
///It might be unsupported in subsequent versions of Windows.] Used as a site object by the IShellView interface.
@GUID("87D605E0-C511-11CF-89A9-00A0C9054129")
interface IDocViewSite : IUnknown
{
    ///Sets or retrieves the title of the site object.
    ///Params:
    ///    pvTitle = Type: <b>VARIANTARG*</b> Specifies the view title.
    HRESULT OnSetTitle(VARIANT* pvTitle);
}

@GUID("4622AD16-FF23-11D0-8D34-00A0C90F2719")
interface IInitializeObject : IUnknown
{
    HRESULT Initialize();
}

@GUID("596A9A94-013E-11D1-8D34-00A0C90F2719")
interface IBanneredBar : IUnknown
{
    HRESULT SetIconSize(uint iIcon);
    HRESULT GetIconSize(uint* piIcon);
    HRESULT SetBitmap(HBITMAP hBitmap);
    HRESULT GetBitmap(HBITMAP* phBitmap);
}

///Exposes methods that simplify the process of retrieving information stored in the registry in association with
///defining a file type or protocol and associating it with an application.
@GUID("C46CA590-3C3F-11D2-BEE6-0000F805CA57")
interface IQueryAssociations : IUnknown
{
    ///Initializes the IQueryAssociations interface and sets the root key to the appropriate ProgID.
    ///Params:
    ///    flags = Type: <b>ASSOCF</b> A flag that specifies how the search is to be initialized. It is typically set to zero,
    ///            but it can also take one of the following ASSOCF values. <ul> <li> ASSOCF_INIT_BYEXENAME </li> <li>
    ///            ASSOCF_INIT_DEFAULTTOFOLDER </li> <li> ASSOCF_INIT_DEFAULTTOSTAR </li> </ul>
    ///    pszAssoc = Type: <b>LPCWSTR</b> A Unicode string that is used to determine the root key. If a value is specified for
    ///               <i>hkProgid</i>, set this parameter to <b>NULL</b>. Four types of string can be used:
    ///    hkProgid = Type: <b>HKEY</b> The HKEY value of the subkey that is used as a root key. The search looks only below this
    ///               key. If a value is specified for <i>pwszAssoc</i>, set this parameter to <b>NULL</b>.
    ///    hwnd = Type: <b>HWND</b>
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Init(uint flags, const(wchar)* pszAssoc, HKEY hkProgid, HWND hwnd);
    ///Searches for and retrieves a file or protocol association-related string from the registry.
    ///Params:
    ///    flags = Type: <b>ASSOCF</b> A flag that can be used to control the search. It can be any combination of the following
    ///            ASSOCF values. <ul> <li> ASSOCF_IGNOREBASECLASS </li> <li> ASSOCF_NOFIXUPS </li> <li> ASSOCF_NOTRUNCATE </li>
    ///            <li> ASSOCF_NOUSERSETTINGS </li> <li> ASSOCF_REMAPRUNDLL </li> <li> ASSOCF_VERIFY </li> </ul>
    ///    str = Type: <b>ASSOCSTR</b> An ASSOCSTR value that specifies the type of string that is to be returned.
    ///    pszExtra = Type: <b>LPCWSTR</b> A pointer to an optional, null-terminated Unicode string with information about the
    ///               location of the string. It is typically set to a Shell verb such as <b>open</b>. Set this parameter to
    ///               <b>NULL</b> if it is not used.
    ///    pszOut = Type: <b>LPWSTR</b> A pointer to a null-terminated Unicode string used to return the requested string. Set
    ///             this parameter to <b>NULL</b> to retrieve the required buffer size.
    ///    pcchOut = Type: <b>DWORD*</b> A pointer to a value that, on entry, is set to the number of characters in the
    ///              <i>pwszOut</i> buffer. When the function returns successfully, it points to the number of characters placed
    ///              in the buffer. If the ASSOCF_NOTRUNCATE flag is set in <i>flags</i> and the buffer specified in
    ///              <i>pwszOut</i> is too small, the function returns E_POINTER and <i>pcchOut</i> points to the required size of
    ///              the buffer. If <i>pwszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the
    ///              required size of the buffer.
    HRESULT GetString(uint flags, ASSOCSTR str, const(wchar)* pszExtra, const(wchar)* pszOut, uint* pcchOut);
    ///Searches for and retrieves a file or protocol association-related key from the registry.
    ///Params:
    ///    flags = Type: <b>ASSOCF</b> The ASSOCF value that can be used to control the search.
    ///    key = Type: <b>ASSOCKEY</b> The ASSOCKEY value that specifies the type of key that is to be returned.
    ///    pszExtra = Type: <b>LPCWSTR</b> A pointer to an optional null-terminated Unicode string with information about the
    ///               location of the key. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to
    ///               <b>NULL</b> if it is not used.
    ///    phkeyOut = Type: <b>HKEY*</b> A pointer to the key's HKEY value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetKey(uint flags, ASSOCKEY key, const(wchar)* pszExtra, HKEY* phkeyOut);
    ///Searches for and retrieves file or protocol association-related binary data from the registry.
    ///Params:
    ///    flags = Type: <b>ASSOCF</b> The ASSOCF value that can be used to control the search.
    ///    data = Type: <b>ASSOCDATA</b> The ASSOCDATA value that specifies the type of data that is to be returned.
    ///    pszExtra = Type: <b>LPCWSTR</b> A pointer to an optional, null-terminated Unicode string with information about the
    ///               location of the data. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to
    ///               <b>NULL</b> if it is not used.
    ///    pvOut = Type: <b>void*</b> A pointer to a value that, when this method returns successfully, receives the requested
    ///            data value.
    ///    pcbOut = Type: <b>DWORD*</b> A pointer to a value that, when this method is called, holds the size of <i>pvOut</i>, in
    ///             bytes. When this method returns successfully, the value contains the size of the data actually retrieved.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetData(uint flags, ASSOCDATA data, const(wchar)* pszExtra, char* pvOut, uint* pcbOut);
    ///This method is not implemented.
    ///Params:
    ///    flags = TBD
    ///    assocenum = TBD
    ///    pszExtra = TBD
    ///    riid = TBD
    ///    ppvOut = TBD
    HRESULT GetEnum(uint flags, ASSOCENUM assocenum, const(wchar)* pszExtra, const(GUID)* riid, void** ppvOut);
}

///Exposes methods that provide general information about an application to the Add/Remove Programs Application. You
///cannot use it outside the Add/Remove Programs application. The information given by this interface includes a list of
///supported management actions and whether the application is currently installed.
@GUID("A3E14960-935F-11D1-B8B8-006008059382")
interface IShellApp : IUnknown
{
    ///Gets general information about an application.
    ///Params:
    ///    pai = Type: <b>APPINFODATA*</b> A pointer to an APPINFODATA structure that returns the application information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAppInfo(APPINFODATA* pai);
    ///Gets a bitmask of management actions allowed for an application.
    ///Params:
    ///    pdwActions = Type: <b>DWORD*</b> A pointer to a variable of type <b>DWORD</b> that returns the bitmask of supported
    ///                 actions. The bit flags are described in APPACTIONFLAGS.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPossibleActions(uint* pdwActions);
    ///Returns information to the application that originates from a slow source. This method is not applicable to
    ///published applications.
    ///Params:
    ///    psaid = Type: <b>PSLOWAPPINFO</b> A pointer to a SLOWAPPINFO structure in which to return application information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSlowAppInfo(SLOWAPPINFO* psaid);
    ///Returns information to the application that originates from a slow source. Unlike IShellApp::GetSlowAppInfo, this
    ///method can return information that has been cached. This method is not applicable to published applications.
    ///Params:
    ///    psaid = Type: <b>PSLOWAPPINFO</b> A pointer to a SLOWAPPINFO structure in which to return application information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCachedSlowAppInfo(SLOWAPPINFO* psaid);
    ///Gets a value indicating whether a specified application is currently installed.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    application is installed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> The application is not installed. </td> </tr> </table>
    ///    
    HRESULT IsInstalled();
}

///Exposes methods that represent applications to Add/Remove Programs in Control Panel.
@GUID("1BC752E0-9046-11D1-B8B3-006008059382")
interface IPublishedApp : IShellApp
{
    ///Installs an application published by an application publisher. This method is invoked when the user selects
    ///<b>Add</b> or <b>Add Later</b> in <b>Add/Remove Programs</b> in Control Panel.
    ///Params:
    ///    pstInstall = Type: <b>LPSYSTEMTIME</b> A pointer to a SYSTEMTIME structure that specifies the time the user elected to
    ///                 schedule installation through the <b>Add Later</b> button in <b>Add/Remove Programs</b>. This option is only
    ///                 available if the application supports scheduled installation (compare GetPossibleActions). If this parameter
    ///                 is <b>NULL</b>, the application should be installed immediately.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Install(SYSTEMTIME* pstInstall);
    ///Gets publishing-related information about an application published by an application publisher.
    ///Params:
    ///    ppai = Type: <b>PUBAPPINFO*</b> A pointer to an PUBAPPINFO structure that returns the application information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPublishedAppInfo(PUBAPPINFO* ppai);
    ///Cancels the installation of an application published by an application publisher.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Unschedule();
}

///Extends the IPublishedApp interface by providing an additional installation method.
@GUID("12B81347-1B3A-4A04-AA61-3F768B67FD7E")
interface IPublishedApp2 : IPublishedApp
{
    ///Installs an application published by an application publisher, while preventing multiple windows from being
    ///active on the same thread.
    ///Params:
    ///    pstInstall = Type: <b>LPSYSTEMTIME</b> A pointer to a SYSTEMTIME structure.
    ///    hwndParent = Type: <b>HWND</b> A handle to the parent window.
    HRESULT Install2(SYSTEMTIME* pstInstall, HWND hwndParent);
}

///Exposes methods that enumerate published applications to Add/Remove Programs in the Control Panel. The object
///exposing this interface is requested through IAppPublisher::EnumApps.
@GUID("0B124F8C-91F0-11D1-B8B5-006008059382")
interface IEnumPublishedApps : IUnknown
{
    ///Gets the next IPublishedApp object in the enumeration.
    ///Params:
    ///    pia = Type: <b>IPublishedApp**</b> A pointer to an IPublishedApp interface reference variable that returns the next
    ///          application object. Note that the category of the application object returned must match that passed into
    ///          EnumApps.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if an item is returned, S_FALSE if there are no more items to enumerate, a
    ///    COM-defined error value otherwise.
    ///    
    HRESULT Next(IPublishedApp* pia);
    ///Resets the enumeration of IPublishedApp objects to the first item.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns the following value. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> This method only returns
    ///    S_OK. </td> </tr> </table>
    ///    
    HRESULT Reset();
}

///Exposes methods for publishing applications through <b>Add/Remove Programs</b> in Control Panel. This is the
///principal interface implemented for this purpose.
@GUID("07250A10-9CF9-11D1-9076-006008059382")
interface IAppPublisher : IUnknown
{
    ///Obsolete. Clients of the Add/Remove Programs Control Panel Application may return E_NOTIMPL.
    ///Params:
    ///    pdwCat = This parameter is unused.
    ///Returns:
    ///    This method does not return a value.
    ///    
    HRESULT GetNumberOfCategories(uint* pdwCat);
    ///Retrieves a structure listing the categories provided by an application publisher.
    ///Params:
    ///    pAppCategoryList = Type: <b>APPCATEGORYINFOLIST*</b> A pointer to an APPCATEGORYINFOLIST structure. This structure's
    ///                       <b>cCategory</b> member returns the count of supported categories. The <b>pCategoryInfo</b> member returns a
    ///                       pointer to an array of APPCATEGORYINFO structures. This array contains all the categories an application
    ///                       publisher supports and must be allocated using CoTaskMemAlloc and freed using CoTaskMemFree.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCategories(APPCATEGORYINFOLIST* pAppCategoryList);
    ///Obsolete. Clients of Add/Remove Programs Control Panel Application can return E_NOTIMPL.
    ///Params:
    ///    pdwApps = This parameter is unused.
    ///Returns:
    ///    This method does not return a value.
    ///    
    HRESULT GetNumberOfApps(uint* pdwApps);
    ///Creates an enumerator for enumerating all applications published by an application publisher for a given
    ///category.
    ///Params:
    ///    pAppCategoryId = Type: <b>GUID*</b> A pointer to a GUID that specifies the application category to be enumerated. This must be
    ///                     one of the categories provided through IAppPublisher::GetCategories. If <i>pAppCategoryID</i> identifies a
    ///                     category not provided through <b>IAppPublisher::GetCategories</b>, creation of the enumerator succeeds with
    ///                     the enumerator returning zero items. If this parameter value is <b>NULL</b>, the enumerator returns
    ///                     applications published for all categories.
    ///    ppepa = Type: <b>IEnumPublishedApps**</b> The address of a pointer to an IEnumPublishedApps reference variable that
    ///            points to a <b>IEnumPublishedApps</b> interface. Application publishers must create an enumeration object
    ///            that supports the <b>IEnumPublishedApps</b> interface, and return its pointer value through this parameter.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnumApps(GUID* pAppCategoryId, IEnumPublishedApps* ppepa);
}

///Exposes methods that enable the handling of a credential.
@GUID("63913A93-40C1-481A-818D-4072FF8C70CC")
interface ICredentialProviderCredential : IUnknown
{
    ///Enables a credential to initiate events in the Logon UI or Credential UI through a callback interface. This
    ///method should be called before other methods in ICredentialProviderCredential interface.
    ///Params:
    ///    pcpce = Type: <b>ICredentialProviderCredentialEvents*</b> A pointer to an ICredentialProviderCredentialEvents
    ///            callback interface to be used as the notification mechanism.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Advise(ICredentialProviderCredentialEvents pcpce);
    ///Used by the Logon UI or Credential UI to advise the credential that event callbacks are no longer accepted.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UnAdvise();
    ///Called when a credential is selected. Enables the implementer to set logon characteristics.
    ///Params:
    ///    pbAutoLogon = Type: <b>BOOL*</b> When this method returns, contains <b>TRUE</b> if selection of the credential indicates
    ///                  that it should attempt to logon immediately and automatically, otherwise <b>FALSE</b>. For example, a
    ///                  credential provider that enumerates an account without a password may want to return this as true.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSelected(int* pbAutoLogon);
    ///Called when a credential loses selection.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDeselected();
    ///Retrieves the field state. The Logon UI and Credential UI use this to gain information about a field of a
    ///credential to display this information in the user tile.
    ///Params:
    ///    dwFieldID = Type: <b>DWORD</b> The identifier for the field.
    ///    pcpfs = Type: <b>CREDENTIAL_PROVIDER_FIELD_STATE*</b> A pointer to the credential provider field state. This
    ///            indicates when the field should be displayed on the user tile.
    ///    pcpfis = Type: <b>CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE*</b> A pointer to the credential provider field
    ///             interactive state. This indicates when the user can interact with the field.
    HRESULT GetFieldState(uint dwFieldID, CREDENTIAL_PROVIDER_FIELD_STATE* pcpfs, 
                          CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE* pcpfis);
    ///Enables retrieval of text from a credential with a text field.
    ///Params:
    ///    dwFieldID = Type: <b>DWORD</b> The identifier for the field.
    ///    ppsz = Type: <b>LPWSTR*</b> A pointer to the memory containing a null-terminated Unicode string to return to the
    ///           Logon UI or Credential UI.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStringValue(uint dwFieldID, ushort** ppsz);
    ///Enables retrieval of bitmap data from a credential with a bitmap field.
    ///Params:
    ///    dwFieldID = Type: <b>DWORD</b> The identifier for the field.
    ///    phbmp = Type: <b>HBITMAP*</b> Contains a pointer to the handle of the bitmap.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBitmapValue(uint dwFieldID, HBITMAP* phbmp);
    ///Retrieves the checkbox value.
    ///Params:
    ///    dwFieldID = Type: <b>DWORD</b> The identifier for the field.
    ///    pbChecked = Type: <b>BOOL*</b> Indicates the state of the checkbox. <b>TRUE</b> indicates the checkbox is checked,
    ///                otherwise <b>FALSE</b>.
    ///    ppszLabel = Type: <b>LPWSTR*</b> Points to the label on the checkbox.
    HRESULT GetCheckboxValue(uint dwFieldID, int* pbChecked, ushort** ppszLabel);
    ///Retrieves the identifier of a field that the submit button should be placed next to in the Logon UI. The
    ///Credential UI does not call this method.
    ///Params:
    ///    dwFieldID = Type: <b>DWORD</b> The identifier for the field a submit button value is needed for.
    ///    pdwAdjacentTo = Type: <b>DWORD*</b> A pointer to a value that receives the field ID of the field that the submit button
    ///                    should be placed next to. <b>Note to implementers:</b> Do not return the field ID of a bitmap in this
    ///                    parameter. It is not good UI design to place the submit button next to a bitmap, and doing so can cause a
    ///                    failure in the Logon UI.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSubmitButtonValue(uint dwFieldID, uint* pdwAdjacentTo);
    ///Gets a count of the items in the specified combo box and designates which item should have initial selection.
    ///Params:
    ///    dwFieldID = Type: <b>DWORD</b> The identifier for the combo box to gather information about.
    ///    pcItems = Type: <b>DWORD*</b> A pointer to the number of items in the given combo box.
    ///    pdwSelectedItem = Type: <b>DWORD*</b> Contains a pointer to the item that receives initial selection.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetComboBoxValueCount(uint dwFieldID, uint* pcItems, uint* pdwSelectedItem);
    ///Gets the string label for a combo box entry at the given index.
    ///Params:
    ///    dwFieldID = Type: <b>DWORD</b> The identifier for the combo box to query.
    ///    dwItem = Type: <b>DWORD</b> The index of the desired item.
    ///    ppszItem = Type: <b>LPWSTR*</b> A pointer to the string value that receives the combo box label.
    HRESULT GetComboBoxValueAt(uint dwFieldID, uint dwItem, ushort** ppszItem);
    ///Enables a Logon UI or Credential UI to update the text for a <b>CPFT_EDIT_TEXT</b> fields as the user types in
    ///them.
    ///Params:
    ///    dwFieldID = Type: <b>DWORD</b> The identifier for the field that needs to be updated.
    ///    psz = Type: <b>LPCWSTR</b> A pointer to a buffer containing the new text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetStringValue(uint dwFieldID, const(wchar)* psz);
    ///Enables a Logon UI and Credential UI to indicate that a checkbox value has changed.
    ///Params:
    ///    dwFieldID = Type: <b>DWORD</b> The identifier for the field to update.
    ///    bChecked = Type: <b>BOOL</b> Indicates the new value for the checkbox. <b>TRUE</b> means the checkbox should be checked,
    ///               <b>FALSE</b> means unchecked.
    HRESULT SetCheckboxValue(uint dwFieldID, BOOL bChecked);
    ///Enables a Logon UI and Credential UI to indicate that a combo box value has been selected.
    ///Params:
    ///    dwFieldID = Type: <b>DWORD</b> The identifier for the combo box that is affected.
    ///    dwSelectedItem = Type: <b>DWORD</b> The specific item selected.
    HRESULT SetComboBoxSelectedValue(uint dwFieldID, uint dwSelectedItem);
    ///Enables the Logon UI and Credential UI to indicate that a link was clicked.
    ///Params:
    ///    dwFieldID = Type: <b>DWORD</b> The identifier for the field clicked on.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CommandLinkClicked(uint dwFieldID);
    ///Called in response to an attempt to submit this credential to the underlying authentication engine.
    ///Params:
    ///    pcpgsr = Type: <b>CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE*</b> Indicates the success or failure of the attempt
    ///             to serialize credentials.
    ///    pcpcs = Type: <b>CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION*</b> A pointer to the credential. Depending on the
    ///            result, there may be no valid credential.
    ///    ppszOptionalStatusText = Type: <b>LPWSTR*</b> A pointer to a Unicode string value that will be displayed by the Logon UI after
    ///                             serialization. May be <b>NULL</b>.
    ///    pcpsiOptionalStatusIcon = Type: <b>CREDENTIAL_PROVIDER_STATUS_ICON*</b> A pointer to an icon that will be displayed by the credential
    ///                              after the call to <b>GetSerialization</b> returns. This value can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSerialization(CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE* pcpgsr, 
                             CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION* pcpcs, ushort** ppszOptionalStatusText, 
                             CREDENTIAL_PROVIDER_STATUS_ICON* pcpsiOptionalStatusIcon);
    ///Translates a received error status code into the appropriate user-readable message. The Credential UI does not
    ///call this method.
    ///Params:
    ///    ntsStatus = Type: <b>NTSTATUS</b> The NTSTATUS value that reflects the return value of the Winlogon call to LsaLogonUser.
    ///    ntsSubstatus = Type: <b>NTSTATUS</b> The NTSTATUS value that reflects the value pointed to by the <i>SubStatus</i> parameter
    ///                   of LsaLogonUser when that function returns after being called by Winlogon.
    ///    ppszOptionalStatusText = Type: <b>LPWSTR*</b> A pointer to the error message that will be displayed to the user. May be <b>NULL</b>.
    ///    pcpsiOptionalStatusIcon = Type: <b>CREDENTIAL_PROVIDER_STATUS_ICON*</b> A pointer to an icon that will shown on the credential. May be
    ///                              <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ReportResult(NTSTATUS ntsStatus, NTSTATUS ntsSubstatus, ushort** ppszOptionalStatusText, 
                         CREDENTIAL_PROVIDER_STATUS_ICON* pcpsiOptionalStatusIcon);
}

///Exposes methods that provide a standard mechanism for credential providers to call QueryContinue while attempting to
///connect to the network to determine if they should continue these attempts. Credential providers can also use this
///interface to display messages to the user while attempting to establish a network connection.
@GUID("9090BE5B-502B-41FB-BCCC-0049A6C7254B")
interface IQueryContinueWithStatus : IQueryContinue
{
    ///Enables the credential provider to set status messages as it attempts to complete
    ///IConnectableCredentialProviderCredential::Connect.
    ///Params:
    ///    psz = Type: <b>LPCWSTR</b> A pointer to the status message.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetStatusMessage(const(wchar)* psz);
}

///Exposes methods for connecting and disconnecting <b>IConnectableCredentialProviderCredential</b> objects.
@GUID("9387928B-AC75-4BF9-8AB2-2B93C4A55290")
interface IConnectableCredentialProviderCredential : ICredentialProviderCredential
{
    ///Connects an IConnectableCredentialProviderCredential object. This method is called after the user clicks the
    ///<b>Submit</b> button within the Pre-Logon-Access Provider screen and before
    ///ICredentialProviderCredential::GetSerialization is called.
    ///Params:
    ///    pqcws = Type: <b>IQueryContinueWithStatus*</b> A pointer to an IQueryContinueWithStatus object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Connect(IQueryContinueWithStatus pqcws);
    ///Disconnects an IConnectableCredentialProviderCredential object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Disconnect();
}

///Provides an asynchronous callback mechanism used by a credential to notify it of state or text change events in the
///Logon UI or Credential UI.
@GUID("FA6FA76B-66B7-4B11-95F1-86171118E816")
interface ICredentialProviderCredentialEvents : IUnknown
{
    ///Communicates to the Logon UI or Credential UI that a field state has changed and that the UI should be updated.
    ///Params:
    ///    pcpc = Type: <b>ICredentialProviderCredential*</b> The credential containing a field whose state is being set. This
    ///           value should be set to <b>this</b>. See ICredentialProviderCredentialEvents for more information.
    ///    dwFieldID = Type: <b>DWORD</b> The unique ID of the field where the change occurred to generate the event.
    ///    cpfs = Type: <b>CREDENTIAL_PROVIDER_FIELD_STATE</b> The value from the CREDENTIAL_PROVIDER_FIELD_STATE enumeration
    ///           that specifies the new field state.
    HRESULT SetFieldState(ICredentialProviderCredential pcpc, uint dwFieldID, CREDENTIAL_PROVIDER_FIELD_STATE cpfs);
    ///Communicates to the Logon UI or Credential UI that the interactivity state of a field has changed and that the UI
    ///should be updated.
    ///Params:
    ///    pcpc = Type: <b>ICredentialProviderCredential*</b> The credential containing a field whose interactivity state is
    ///           being set. This value should be set to <b>this</b>. See ICredentialProviderCredentialEvents for more
    ///           information.
    ///    dwFieldID = Type: <b>DWORD</b> The unique ID of the field.
    ///    cpfis = Type: <b>CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE</b> The new interactive state of the field.
    HRESULT SetFieldInteractiveState(ICredentialProviderCredential pcpc, uint dwFieldID, 
                                     CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE cpfis);
    ///Communicates to the Logon UI or Credential UI that the string associated with a field has changed and that the UI
    ///should be updated.
    ///Params:
    ///    pcpc = Type: <b>ICredentialProviderCredential*</b> The credential containing a field whose interactivity state is
    ///           being set. This value should be set to <b>this</b>. See ICredentialProviderCredentialEvents for more
    ///           information.
    ///    dwFieldID = Type: <b>DWORD</b> The unique ID of the field for which the string is being set.
    ///    psz = Type: <b>LPCWSTR</b> A pointer to the new string for the field.
    HRESULT SetFieldString(ICredentialProviderCredential pcpc, uint dwFieldID, const(wchar)* psz);
    ///Communicates to the Logon UI or Credential UI that a checkbox field has changed and that the UI should be
    ///updated.
    ///Params:
    ///    pcpc = Type: <b>ICredentialProviderCredential*</b> The credential containing the checkbox field that is being set.
    ///           This value should be set to <b>this</b>. See ICredentialProviderCredentialEvents for more information.
    ///    dwFieldID = Type: <b>DWORD</b> The unique field ID for the checkbox.
    ///    bChecked = Type: <b>BOOL</b> The new state of the checkbox. <b>TRUE</b> indicates the checkbox should be checked,
    ///               <b>FALSE</b> indicates it should not.
    ///    pszLabel = Type: <b>LPCWSTR</b> The new string for the checkbox label.
    HRESULT SetFieldCheckbox(ICredentialProviderCredential pcpc, uint dwFieldID, BOOL bChecked, 
                             const(wchar)* pszLabel);
    ///Communicates to the Logon UI or Credential UI that a tile image field has changed and that the UI should be
    ///updated.
    ///Params:
    ///    pcpc = Type: <b>ICredentialProviderCredential*</b> The credential containing the tile image field that is being set.
    ///           This value should be set to <b>this</b>. See ICredentialProviderCredentialEvents for more information.
    ///    dwFieldID = Type: <b>DWORD</b> The unique ID of the tile image field.
    ///    hbmp = Type: <b>HBITMAP</b> The new tile image.
    HRESULT SetFieldBitmap(ICredentialProviderCredential pcpc, uint dwFieldID, HBITMAP hbmp);
    ///Communicates to the Logon UI or Credential UI that the selected item in a combo box has changed and that the UI
    ///should be updated.
    ///Params:
    ///    pcpc = Type: <b>ICredentialProviderCredential*</b> The credential containing the combo box being set. This value
    ///           should be set to <b>this</b>. See ICredentialProviderCredentialEvents for more information.
    ///    dwFieldID = Type: <b>DWORD</b> The unique ID of the combo box.
    ///    dwSelectedItem = Type: <b>DWORD</b> The index of the item to select in the combo box.
    HRESULT SetFieldComboBoxSelectedItem(ICredentialProviderCredential pcpc, uint dwFieldID, uint dwSelectedItem);
    ///Communicates to the Logon UI or Credential UI that an item should be deleted from a combo box and that the UI
    ///should be updated.
    ///Params:
    ///    pcpc = Type: <b>ICredentialProviderCredential*</b> The credential containing the combo box that needs to be updated.
    ///           This value should be set to <b>this</b>. See ICredentialProviderCredentialEvents for more information.
    ///    dwFieldID = Type: <b>DWORD</b> The unique ID of the combo box.
    ///    dwItem = Type: <b>DWORD</b> The index of the item that is deleted.
    HRESULT DeleteFieldComboBoxItem(ICredentialProviderCredential pcpc, uint dwFieldID, uint dwItem);
    ///Communicates to the Logon UI or Credential UI that a combo box needs an item appended and that the UI should be
    ///updated.
    ///Params:
    ///    pcpc = Type: <b>ICredentialProviderCredential*</b> The credential containing the combo box that needs an item added.
    ///           This value should be set to <b>this</b>. See ICredentialProviderCredentialEvents for more information.
    ///    dwFieldID = Type: <b>DWORD</b> The unique ID of the combo box.
    ///    pszItem = Type: <b>LPCWSTR</b> The string that will be appended to the combo box as a new option.
    HRESULT AppendFieldComboBoxItem(ICredentialProviderCredential pcpc, uint dwFieldID, const(wchar)* pszItem);
    ///Enables credentials to set the field that the submit button appears adjacent to.
    ///Params:
    ///    pcpc = Type: <b>ICredentialProviderCredential*</b> The credential whose submit button location is being set. This
    ///           value should be set to <b>this</b>. See ICredentialProviderCredentialEvents for more information.
    ///    dwFieldID = Type: <b>DWORD</b> The unique field ID of the submit button.
    ///    dwAdjacentTo = Type: <b>DWORD</b> The unique field ID of the field that the submit button should be adjacent to when this
    ///                   method completes.
    HRESULT SetFieldSubmitButton(ICredentialProviderCredential pcpc, uint dwFieldID, uint dwAdjacentTo);
    ///Called when the window is created. Enables credentials to retrieve the HWND of the parent window after Advise is
    ///called.
    ///Params:
    ///    phwndOwner = Type: <b>HWND*</b> A pointer to the handle of the parent window.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnCreatingWindow(HWND* phwndOwner);
}

///Exposes methods used in the setup and manipulation of a credential provider. All credential providers must implement
///this interface.
@GUID("D27C3481-5A1C-45B2-8AAA-C20EBBE8229E")
interface ICredentialProvider : IUnknown
{
    ///Defines the scenarios for which the credential provider is valid. Called whenever the credential provider is
    ///initialized.
    ///Params:
    ///    cpus = Type: <b>CREDENTIAL_PROVIDER_USAGE_SCENARIO</b> The scenario the credential provider has been created in.
    ///           This is the usage scenario that needs to be supported. See the Remarks for more information.
    ///    dwFlags = Type: <b>DWORD</b> A value that affects the behavior of the credential provider. This value can be a
    ///              bitwise-OR combination of one or more of the following values defined in Wincred.h. See
    ///              CredUIPromptForWindowsCredentials for more information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetUsageScenario(CREDENTIAL_PROVIDER_USAGE_SCENARIO cpus, uint dwFlags);
    ///Sets the serialization characteristics of the credential provider.
    ///Params:
    ///    pcpcs = Type: <b>const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION*</b> A pointer to a
    ///            CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION structure that stores the serialization characteristics of the
    ///            credential provider.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSerialization(const(CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION)* pcpcs);
    ///Allows a credential provider to initiate events in the Logon UI or Credential UI through a callback interface.
    ///Params:
    ///    pcpe = Type: <b>ICredentialProviderEvents*</b> A pointer to an ICredentialProviderEvents callback interface to be
    ///           used as the notification mechanism.
    ///    upAdviseContext = Type: <b>UINT_PTR</b> A pointer to an integer that uniquely identifies which credential provider has
    ///                      requested re-enumeration.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Advise(ICredentialProviderEvents pcpe, size_t upAdviseContext);
    ///Used by the Logon UI or Credential UI to advise the credential provider that event callbacks are no longer
    ///accepted.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UnAdvise();
    ///Retrieves the count of fields in the needed to display this provider's credentials.
    ///Params:
    ///    pdwCount = Type: <b>DWORD*</b> Pointer to the field count.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFieldDescriptorCount(uint* pdwCount);
    ///Gets metadata that describes a specified field.
    ///Params:
    ///    dwIndex = Type: <b>DWORD</b> The zero-based index of the field for which the information should be retrieved.
    ///    ppcpfd = Type: <b>CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR**</b> The address of a pointer to a
    ///             CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR structure which receives the information about the field.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFieldDescriptorAt(uint dwIndex, CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR** ppcpfd);
    ///Gets the number of available credentials under this credential provider.
    ///Params:
    ///    pdwCount = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> value that receives the count of credentials.
    ///    pdwDefault = Type: <b>DWORD*</b> A pointer to a <b>DWORD</b> value that receives the index of the credential to be used as
    ///                 the default. If no default value has been set, this value should be set to
    ///                 <b>CREDENTIAL_PROVIDER_NO_DEFAULT</b>.
    ///    pbAutoLogonWithDefault = Type: <b>BOOL*</b> A pointer to a <b>BOOL</b> value indicating if the default credential identified by
    ///                             <i>pdwDefault</i> should be used for an auto logon attempt. An auto logon attempt means the Logon UI or
    ///                             Credential UI will immediately call GetSerialization on the provider's default tile.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCredentialCount(uint* pdwCount, uint* pdwDefault, int* pbAutoLogonWithDefault);
    ///Gets a specific credential.
    ///Params:
    ///    dwIndex = Type: <b>DWORD</b> The zero-based index of the credential within the set of credentials enumerated for this
    ///              credential provider.
    ///    ppcpc = Type: <b>ICredentialProviderCredential**</b> The address of a pointer to a ICredentialProviderCredential
    ///            instance representing the credential.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCredentialAt(uint dwIndex, ICredentialProviderCredential* ppcpc);
}

///Provides an asynchronous callback mechanism used by a credential provider to notify it of changes in the list of
///credentials or their fields.
@GUID("34201E5A-A787-41A3-A5A4-BD6DCF2A854E")
interface ICredentialProviderEvents : IUnknown
{
    ///Signals the Logon UI or Credential UI that the enumerated list of credentials has changed. This happens when the
    ///number of credentials change, the individual credentials change, or the number of fields available change. This
    ///is an asynchronous method.
    ///Params:
    ///    upAdviseContext = Type: <b>UINT_PTR</b> A pointer to an integer that uniquely identifies which credential provider has
    ///                      requested re-enumeration. The credential provider should pass back the interface pointer it received from
    ///                      Advise in this parameter.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CredentialsChanged(size_t upAdviseContext);
}

///Used to dynamically filter credential providers based on information available at runtime.
@GUID("A5DA53F9-D475-4080-A120-910C4A739880")
interface ICredentialProviderFilter : IUnknown
{
    ///Evaluates whether a list of credential providers should be allowed to provide credential tiles.
    ///Params:
    ///    cpus = Type: <b>CREDENTIAL_PROVIDER_USAGE_SCENARIO</b> A pointer to a CREDENTIAL_PROVIDER_USAGE_SCENARIO value that
    ///           declares the scenarios in which a credential provider is supported.
    ///    dwFlags = Type: <b>DWORD</b> Usage scenario flags. This parameter is valid only if <i>cpus</i> is CPUS_CREDUI. They are
    ///              defined in Wincred.h.
    ///    rgclsidProviders = Type: <b>GUID*</b> A pointer to an array of credential provider CLSIDs.
    ///    rgbAllow = Type: <b>BOOL*</b> On entry, a pointer to an array of <b>BOOL</b> values, one for each corresponding member
    ///               of the <i>rgclsidProviders</i> array, all initialized to <b>TRUE</b>. On exit, contains <b>TRUE</b> if the
    ///               corresponding credential provider in <i>rgclsidProviders</i> is allowed to provide a credential tile;
    ///               otherwise, <b>FALSE</b>.
    ///    cProviders = Type: <b>DWORD</b> The number of members in <i>rgbAllow</i> or <i>rgclsidProviders</i> (they should be the
    ///                 same).
    ///Returns:
    ///    Type: <b>HRESULT</b> Always returns S_OK.
    ///    
    HRESULT Filter(CREDENTIAL_PROVIDER_USAGE_SCENARIO cpus, uint dwFlags, char* rgclsidProviders, char* rgbAllow, 
                   uint cProviders);
    ///Updates a credential from a remote session.
    ///Params:
    ///    pcpcsIn = Type: <b>const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION*</b> A constant pointer to a
    ///              CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION structure.
    ///    pcpcsOut = Type: <b>CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION*</b> A pointer to a
    ///               CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION structure.
    HRESULT UpdateRemoteCredential(const(CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION)* pcpcsIn, 
                                   CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION* pcpcsOut);
}

///Extends the ICredentialProviderCredential interface by adding a method that retrieves the security identifier (SID)
///of a user. The credential is associated with that user and can be grouped under the user's tile.
@GUID("FD672C54-40EA-4D6E-9B49-CFB1A7507BD7")
interface ICredentialProviderCredential2 : ICredentialProviderCredential
{
    ///Retrieves the security identifier (SID) of the user that is associated with this credential.
    ///Params:
    ///    sid = The address of a pointer to a buffer that, when this method returns successfully, receives the user's SID.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetUserSid(ushort** sid);
}

///Provides a method that enables the credential provider framework to determine whether you've made a customization to
///a field's option in a logon or credential UI.
@GUID("DBC6FB30-C843-49E3-A645-573E6F39446A")
interface ICredentialProviderCredentialWithFieldOptions : IUnknown
{
    ///Retrieves the current option set for a specified field in a logon or credential UI. Called by the credential
    ///provider framework.
    ///Params:
    ///    fieldID = The ID of the field in the logon or credential UI.
    ///    options = A pointer to an CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS value that, when this method returns
    ///              successfully, receives one or more flags that specify the current options for the field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFieldOptions(uint fieldID, CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS* options);
}

///Extends the ICredentialProviderCredentialEvents interface by adding methods that enable batch updating of fields in
///theLogon UI or Credential UI.
@GUID("B53C00B6-9922-4B78-B1F4-DDFE774DC39B")
interface ICredentialProviderCredentialEvents2 : ICredentialProviderCredentialEvents
{
    ///Starts a batch update to fields in the logon or credential UI.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BeginFieldUpdates();
    ///Finishes and commits the batch updates started by BeginFieldUpdates.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EndFieldUpdates();
    ///Specifies whether a specified field in the logon or credential UI should display a "password reveal" glyph or is
    ///expected to receive an e-mail address.
    ///Params:
    ///    credential = An ICredentialProviderCredential interface pointer to the credential object.
    ///    fieldID = The ID of the field in the logon or credential UI for which this option applies.
    ///    options = One or more of the CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS values, which specify the field options.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetFieldOptions(ICredentialProviderCredential credential, uint fieldID, 
                            CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS options);
}

///Provides methods used to retrieve certain properties of an individual user included in a logon or credential UI.
@GUID("13793285-3EA6-40FD-B420-15F47DA41FBB")
interface ICredentialProviderUser : IUnknown
{
    ///Retrieves the user's security identifier (SID).
    ///Params:
    ///    sid = The address of a pointer to a buffer that, when this method returns successfully, receives the user's SID. It
    ///          is the responsibility of the caller to free this resource by calling the CoTaskMemFree function.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSid(ushort** sid);
    ///Retrieves the ID of the account provider for this user.
    ///Params:
    ///    providerID = A pointer to a value that, when this method returns successfully, receives the GUID of the user's account
    ///                 provider.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetProviderID(GUID* providerID);
    ///Retrieves string properties from the ICredentialProviderUser object based on the input value.
    ///Params:
    ///    key = One of the following values that specify the property to retrieve. <table> <tr> <th>REFPROPERTYKEY</th>
    ///          <th>Description</th> <th>Applies to...</th> </tr> <tr> <td> PKEY_Identity_DisplayName </td> <td>The friendly
    ///          user name.</td> <td>Logon UI and Credential UI</td> </tr> <tr> <td> PKEY_Identity_LogonStatusString </td>
    ///          <td>A localized string that indicates the user's logged on status.</td> <td>Logon UI only</td> </tr> <tr>
    ///          <td> PKEY_Identity_PrimarySid </td> <td>The user's SID.</td> <td>Logon UI and Credential UI</td> </tr> <tr>
    ///          <td> PKEY_Identity_ProviderID </td> <td>The user's provider ID.</td> <td>Logon UI and Credential UI</td>
    ///          </tr> <tr> <td> PKEY_Identity_QualifiedUserName </td> <td>The name used to pack an authentication
    ///          buffer.</td> <td>Logon UI and Credential UI</td> </tr> <tr> <td> PKEY_Identity_UserName </td> <td>The user
    ///          name.</td> <td>Logon UI and Credential UI</td> </tr> </table>
    ///    stringValue = The address of a pointer to a buffer that, when this method returns successfully, receives the requested
    ///                  string.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStringValue(const(PROPERTYKEY)* key, ushort** stringValue);
    ///Retrieves a specified property value set for the user.
    ///Params:
    ///    key = One of the following values that specify the property to retrieve. <table class="clsStd"> <tr>
    ///          <th>REFPROPERTYKEY</th> <th>Applies to...</th> </tr> <tr> <td> PKEY_Identity_DisplayName </td> <td>Logon and
    ///          credential UI</td> </tr> <tr> <td> PKEY_Identity_UserName </td> <td>Logon and credential UI</td> </tr> <tr>
    ///          <td> PKEY_Identity_QualifiedUserName </td> <td>Logon and credential UI</td> </tr> <tr> <td>
    ///          PKEY_Identity_LogonStatusString </td> <td>Logon UI only</td> </tr> <tr> <td> PKEY_Identity_PrimarySid </td>
    ///          <td>Logon and credential UI</td> </tr> <tr> <td> PKEY_Identity_ProviderID </td> <td>Logon and credential
    ///          UI</td> </tr> </table>
    ///    value = A pointer to a value that, when this method returns successfully, receives the requested property value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetValue(const(PROPERTYKEY)* key, PROPVARIANT* value);
}

///Represents the set of users that will appear in the logon or credential UI. This information enables the credential
///provider to enumerate the set to retrieve property information about each user to populate fields or filter the set.
@GUID("90C119AE-0F18-4520-A1F1-114366A40FE8")
interface ICredentialProviderUserArray : IUnknown
{
    ///Limits the set of users in the array to either local accounts or Microsoft accounts.
    ///Params:
    ///    guidProviderToFilterTo = Set this parameter to Identity_LocalUserProvider for the local accounts credential provider; otherwise set it
    ///                             to the GUID of the Microsoft account provider.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetProviderFilter(const(GUID)* guidProviderToFilterTo);
    ///Retrieves a value that indicates whether the "Other user" tile for local or Microsoft accounts is shown in the
    ///logon or credential UI. This information can be used by a credential provider to show the same behavior as the
    ///password or Microsoft account provider.
    ///Params:
    ///    credentialProviderAccountOptions = A pointer to a value that, when this method returns successfully, receives one or more flags that specify
    ///                                       which empty tiles are shown by the logon or credential UI.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAccountOptions(CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS* credentialProviderAccountOptions);
    ///Retrieves the number of ICredentialProviderUser objects in the user array.
    ///Params:
    ///    userCount = A pointer to a value that, when this method returns successfully, receives the number of users in the array.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCount(uint* userCount);
    ///Retrieves a specified user from the array.
    ///Params:
    ///    userIndex = The 0-based array index of the user. The size of the array can be obtained through the GetCount method.
    ///    user = The address of a pointer to an object that, when this method returns successfully, represents the specified
    ///           user. It is the responsibility of the caller to free this object when it is no longer needed by calling its
    ///           Release method.
    ///Returns:
    ///    If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code, including the
    ///    following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The index specified in <i>userIndex</i> is out of
    ///    range. </td> </tr> </table>
    ///    
    HRESULT GetAt(uint userIndex, ICredentialProviderUser* user);
}

///Provides a method that enables a credential provider to receive the set of users that will be shown in the logon or
///credential UI.
@GUID("095C1484-1C0C-4388-9C6D-500E61BF84BD")
interface ICredentialProviderSetUserArray : IUnknown
{
    ///Called by the system during the initialization of a logon or credential UI to retrieve the set of users to show
    ///in that UI.
    ///Params:
    ///    users = A pointer to an array object that contains a set of ICredentialProviderUser objects, each representing a user
    ///            that will appear in the logon or credential UI. This array enables the credential provider to enumerate and
    ///            query each of the user objects for their SID, their associated credential provider's ID, various forms of the
    ///            user name, and their logon status string.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetUserArray(ICredentialProviderUserArray users);
}

///Exposes methods that provide an enumerator of sync handler IDs and instantiate those sync handlers.
@GUID("A7F337A3-D20B-45CB-9ED7-87D094CA5045")
interface ISyncMgrHandlerCollection : IUnknown
{
    ///Gets an enumerator that provides access to the IDs of sync handlers exposed to and managed by the user.
    ///Params:
    ///    ppenum = Type: <b>IEnumString**</b> When this method returns, contains an address of a pointer to an instance of
    ///             IEnumString that enumerates the IDs of known sync handlers.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetHandlerEnumerator(IEnumString* ppenum);
    ///Instantiates a specified sync handler when called by Sync Center.
    ///Params:
    ///    pszHandlerID = Type: <b>LPCWSTR</b> The ID of the sync handler.
    ///    riid = Type: <b>REFIID</b> The IID of the requested interface. This will typically be IID_ISyncMgrHandler. If the
    ///           method fails when passed IID_ISyncMgrHandler, it is recalled using IID_ISyncMgrSynchronize, the IID of the
    ///           older ISyncMgrSynchronize interface. When the method returns successfully, a pointer to the requested
    ///           interface is referenced in the <i>ppv</i> parameter.
    ///    ppv = Type: <b>void**</b> When this method returns, contains an address of a pointer to an interface representing
    ///          the sync handler.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BindToHandler(const(wchar)* pszHandlerID, const(GUID)* riid, void** ppv);
}

///Exposes methods that make up the primary interface implemented by a sync handler. Sync Center creates one instance of
///the handler through this interface to get properties, enumerate sync items, and modify state. Sync Center creates a
///separate instance of the handler on a separate thread to perform a synchronization or a UI operation.
@GUID("04EC2E43-AC77-49F9-9B98-0307EF7A72A2")
interface ISyncMgrHandler : IUnknown
{
    ///Gets the display name of the handler.
    ///Params:
    ///    ppszName = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to a <b>null</b>-terminated buffer that
    ///               receives the handler name. The name can be of maximum length MAX_SYNCMGR_NAME, including the terminating
    ///               <b>null</b> character. If the name exceeds that length, it is truncated.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetName(ushort** ppszName);
    ///Gets properties that describe the handler.
    ///Params:
    ///    ppHandlerInfo = Type: <b>ISyncMgrHandlerInfo**</b> When this method returns, contains the address of a pointer to an instance
    ///                    of the ISyncMgrHandlerInfo interface that provides access to the handler properties.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetHandlerInfo(ISyncMgrHandlerInfo* ppHandlerInfo);
    HRESULT GetObjectA(const(GUID)* rguidObjectID, const(GUID)* riid, void** ppv);
    ///Gets a set of flags describing the handler's defined capabilities.
    ///Params:
    ///    pmCapabilities = Type: <b>SYNCMGR_HANDLER_CAPABILITIES*</b> When this method returns, contains a pointer to a bitwise
    ///                     combination of values from the SYNCMGR_HANDLER_CAPABILITIES enumeration that defines the capabilities of the
    ///                     handler. Compare against SYNCMGR_HCM_VALID_MASK to verify a valid value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCapabilities(SYNCMGR_HANDLER_CAPABILITIES* pmCapabilities);
    ///Gets a set of flags describing the policies set by the handler.
    ///Params:
    ///    pmPolicies = Type: <b>SYNCMGR_HANDLER_POLICIES*</b> When this method returns, contains a pointer to a bitwise combination
    ///                 of values from the SYNCMGR_HANDLER_POLICIES enumeration that define the handler's policies.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPolicies(SYNCMGR_HANDLER_POLICIES* pmPolicies);
    ///Requests that the handler is activated or deactivated. An active handler can be synchronized; an inactive handler
    ///cannot.
    ///Params:
    ///    fActivate = Type: <b>BOOL</b> <b>TRUE</b> to activate; <b>FALSE</b> to deactivate.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Activate(BOOL fActivate);
    ///Requests that an active handler be enabled or disabled. An enabled handler can be synchronized and a disabled
    ///handler cannot.
    ///Params:
    ///    fEnable = Type: <b>BOOL</b> <b>TRUE</b> to enable; <b>FALSE</b> to disable.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Enable(BOOL fEnable);
    ///Initiates a synchronization of a selection of the handler's sync items.
    ///Params:
    ///    ppszItemIDs = Type: <b>LPCWSTR*</b> A pointer to an array of item IDs representing the items to be synchronized. Each item
    ///                  ID is of maximum length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    cItems = Type: <b>ULONG</b> The number of items in <i>ppszItemIDs</i>.
    ///    hwndOwner = Type: <b>HWND</b> A handle to the window that the item uses to display any necessary UI. This value can be
    ///                <b>NULL</b>.
    ///    pSessionCreator = Type: <b>ISyncMgrSessionCreator*</b> A pointer to an ISyncMgrSessionCreator interface. This interface enables
    ///                      the handler itself to report progress and events, or to signal a background process to report progress and
    ///                      events.
    ///    punk = Type: <b>IUnknown*</b> A pointer to an interface to be passed to ISyncMgrControl.
    ///           <b>ISyncMgrHandler::Synchronize</b> is called either when a user requests a synchronization from the Sync
    ///           Center folder or when one of the <b>ISyncMgrControl</b> synchronize methods is called, such as StartSyncAll.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Synchronize(char* ppszItemIDs, uint cItems, HWND hwndOwner, ISyncMgrSessionCreator pSessionCreator, 
                        IUnknown punk);
}

///Exposes methods that allow a handler to provide property and state information to Sync Center.
@GUID("4FF1D798-ECF7-4524-AA81-1E362A0AEF3A")
interface ISyncMgrHandlerInfo : IUnknown
{
    ///Gets the handler type for Sync Center.
    ///Params:
    ///    pnType = Type: <b>SYNCMGR_HANDLER_TYPE*</b> When this method returns, points to a value from the SYNCMGR_HANDLER_TYPE
    ///             enumeration that specifies the handler type. If the method fails, this parameter points to
    ///             SYNCMGR_HT_UNSPECIFIED.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. If the method fails,
    ///    <i>pnType</i> is set to SYNCMGR_HT_UNSPECIFIED.
    ///    
    HRESULT GetType(SYNCMGR_HANDLER_TYPE* pnType);
    ///Gets a label for the handler type. This typically provides the model of the device or an equivalent
    ///handler-specific identity string.
    ///Params:
    ///    ppszTypeLabel = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to a buffer containing the label string.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. If the method fails,
    ///    <i>ppszTypeLabel</i> contains an empty string.
    ///    
    HRESULT GetTypeLabel(ushort** ppszTypeLabel);
    ///Gets a string that contains commentary regarding the handler.
    ///Params:
    ///    ppszComment = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to a buffer containing the comment string.
    ///                  This string is of maximum length MAX_SYNCMGR_NAME including the terminating null character.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. If the method fails,
    ///    <i>ppszComment</i> contains an empty string.
    ///    
    HRESULT GetComment(ushort** ppszComment);
    ///Gets the date and time when the handler was last synchronized.
    ///Params:
    ///    pftLastSync = Type: <b>FILETIME*</b> When this method returns, contains a pointer to a FILETIME structure containing the
    ///                  date and time information.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. If the method fails,
    ///    <i>pftLastSync</i> points to the value from the previous synchronization.
    ///    
    HRESULT GetLastSyncTime(FILETIME* pftLastSync);
    ///Gets a value that indicates whether the handler can be synchronized.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the handler is active; otherwise, S_FALSE. If the handler wants Sync
    ///    Center to maintain the current state, it can return E_NOTIMPL. If any other value is returned, Sync Center
    ///    sets the handler's state to the last known value. If the handler's last known value in that situation was
    ///    inactive, Sync Center disables the <b>Setup</b> task. If the handler's last known value was active, the
    ///    <b>Delete</b> task is not disabled. If either the SYNCMGR_HCM_QUERY_BEFORE_ACTIVATE or
    ///    SYNCMGR_HCM_QUERY_BEFORE_DEACTIVE flag is set in the mask returned from GetCapabilities, the handler must
    ///    manage its own activation state and therefore must return either S_OK or S_FALSE. Any other return value will
    ///    be considered an error.
    ///    
    HRESULT IsActive();
    ///Gets a value that indicates whether the handler is enabled.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the handler is enabled; otherwise, S_FALSE. If the handler wants Sync
    ///    Center to maintain the current state, it can return E_NOTIMPL. If any other value is returned, Sync Center
    ///    sets the handler's enabled state to the last known value and enables or disables the associated tasks as
    ///    appropriate. If either the SYNCMGR_HCM_QUERY_BEFORE_ENABLE or SYNCMGR_HCM_QUERY_BEFORE_DISABLE flag is set in
    ///    the mask returned from GetCapabilities, the handler must manage its own enabled state and therefore must
    ///    return either S_OK or S_FALSE. Any other return value will be considered an error.
    ///    
    HRESULT IsEnabled();
    ///Gets a value that indicates whether the handler—typically some type of external device—is connected.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the handler is connected; otherwise, S_FALSE. An error returned by this
    ///    method will be interpreted as S_OK.
    ///    
    HRESULT IsConnected();
}

///Exposes methods that provide information to handlers about the items they contain.
@GUID("90701133-BE32-4129-A65C-99E616CAFFF4")
interface ISyncMgrSyncItemContainer : IUnknown
{
    ///Gets a specified sync item.
    ///Params:
    ///    pszItemID = Type: <b>LPCWSTR*</b> A pointer to a buffer containing the item ID representing the desired item. The ID is
    ///                of maximum length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    ppItem = Type: <b>ISyncMgrSyncItem**</b> When this method returns, contains the address of a pointer to an
    ///             ISyncMgrSyncItem instance representing the sync item.
    HRESULT GetSyncItem(const(wchar)* pszItemID, ISyncMgrSyncItem* ppItem);
    ///Gets an interface that enumerates the handler's sync items.
    ///Params:
    ///    ppenum = Type: <b>IEnumSyncMgrSyncItems**</b> When this method returns, contains the address of a pointer to an
    ///             IEnumSyncMgrSyncItems instance. <b>IEnumSyncMgrSyncItems</b> can be used to retrieve an interface for each
    ///             sync item in the set.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSyncItemEnumerator(IEnumSyncMgrSyncItems* ppenum);
    ///Gets a count of the sync items in the container.
    ///Params:
    ///    pcItems = Type: <b>ULONG*</b> When this method returns, contains a pointer to the number of items in the container.
    ///              This is the number of items enumerated by IEnumSyncMgrSyncItems.
    HRESULT GetSyncItemCount(uint* pcItems);
}

///Exposes methods that act on and retrieve information from a single sync item, allowing handlers to manage sync items
///as independent objects.
@GUID("B20B24CE-2593-4F04-BD8B-7AD6C45051CD")
interface ISyncMgrSyncItem : IUnknown
{
    ///Gets the unique ID of a sync item.
    ///Params:
    ///    ppszItemID = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to a buffer containing the item's ID. This
    ///                 string is of maximum length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetItemID(ushort** ppszItemID);
    ///Gets the UI display name of the sync item.
    ///Params:
    ///    ppszName = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to a buffer containing the item's display
    ///               name. This string is of maximum length MAX_SYNCMGR_NAME including the terminating <b>null</b> character.
    ///               Longer strings are truncated.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetName(ushort** ppszName);
    ///Gets the properties of a sync item.
    ///Params:
    ///    ppItemInfo = Type: <b>ISyncMgrSyncItemInfo*</b> When this method returns, contains the address of a pointer to an instance
    ///                 of the ISyncMgrSyncItemInfo interface, representing the item.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetItemInfo(ISyncMgrSyncItemInfo* ppItemInfo);
    HRESULT GetObjectA(const(GUID)* rguidObjectID, const(GUID)* riid, void** ppv);
    ///Gets a set of flags describing the item's defined capabilities.
    ///Params:
    ///    pmCapabilities = Type: <b>SYNCMGR_ITEM_CAPABILITIES*</b> When this method returns, contains a pointer to a bitwise combination
    ///                     of values from the SYNCMGR_ITEM_CAPABILITIES enumeration that defines the capabilities of the item.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCapabilities(SYNCMGR_ITEM_CAPABILITIES* pmCapabilities);
    ///Gets a set of flags describing the policies set by the item.
    ///Params:
    ///    pmPolicies = Type: <b>SYNCMGR_ITEM_POLICIES*</b> When this method returns, contains a pointer to a bitwise combination of
    ///                 values from the SYNCMGR_ITEM_POLICIES enumeration that defines the item's policies.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPolicies(SYNCMGR_ITEM_POLICIES* pmPolicies);
    ///Enables or disables the sync item.
    ///Params:
    ///    fEnable = Type: <b>BOOL</b> <b>TRUE</b> to enable; <b>FALSE</b> to disable.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Enable(BOOL fEnable);
    ///Deletes a sync item.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Delete();
}

///Exposes methods that provide property and state information for a single sync item.
@GUID("E7FD9502-BE0C-4464-90A1-2B5277031232")
interface ISyncMgrSyncItemInfo : IUnknown
{
    ///Gets a label for the item type. This typically provides the model of the device or an equivalent item-specific
    ///identity string.
    ///Params:
    ///    ppszTypeLabel = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to a buffer containing the label string.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. If the method fails,
    ///    <i>ppszTypeLabel</i> contains an empty string.
    ///    
    HRESULT GetTypeLabel(ushort** ppszTypeLabel);
    ///Gets a string that contains commentary regarding the item.
    ///Params:
    ///    ppszComment = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to a buffer containing the comment string.
    ///                  This string is of maximum length MAX_SYNCMGR_NAME including the terminating null character.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. If the method fails,
    ///    <i>ppszComment</i> contains an empty string.
    ///    
    HRESULT GetComment(ushort** ppszComment);
    ///Gets the date and time when the item was last synchronized.
    ///Params:
    ///    pftLastSync = Type: <b>FILETIME*</b> When this method returns, contains a pointer to a FILETIME structure containing the
    ///                  date and time information.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. If the method fails,
    ///    <i>pftLastSync</i> points to the value from the previous synchronization.
    ///    
    HRESULT GetLastSyncTime(FILETIME* pftLastSync);
    ///Generates a value that indicates whether the item is enabled.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the item is enabled; otherwise, S_FALSE. If the item wants Sync Center
    ///    to maintain the current state, it can return E_NOTIMPL. If any other value is returned, Sync Center sets the
    ///    item's enabled state to the last known value and enables or disables the associated tasks as appropriate. If
    ///    either the SYNCMGR_ICM_QUERY_BEFORE_ENABLE or SYNCMGR_ICM_QUERY_BEFORE_DISABLE flags are set in the mask
    ///    returned from GetCapabilities, the handler must manage its own enabled state and therefore must return either
    ///    S_OK or S_FALSE. Any other return value will be considered an error.
    ///    
    HRESULT IsEnabled();
    ///Generates a value that indicates whether the item—typically some type of external device—is connected.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if the item is connected; otherwise, S_FALSE. An error returned by this
    ///    method will be interpreted as S_OK.
    ///    
    HRESULT IsConnected();
}

///Exposes methods that enumerate the sync item objects managed by the handler.
@GUID("54B3ABF3-F085-4181-B546-E29C403C726B")
interface IEnumSyncMgrSyncItems : IUnknown
{
    ///Gets the next batch of sync items from the handler.
    ///Params:
    ///    celt = Type: <b>ULONG</b> This value must be 1.
    ///    rgelt = Type: <b>ISyncMgrSyncItem**</b> The address of an ISyncMgrSyncItem interface pointer.
    ///    pceltFetched = Type: <b>ULONG*</b> A pointer to the number of items fetched.
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips forward in the enumeration the specified number of items.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of items to skip.
    HRESULT Skip(uint celt);
    ///Resets the current position in the enumeration to 0.
    HRESULT Reset();
    ///Not used. Clones an IEnumSyncMgrSyncItems object.
    ///Params:
    ///    ppenum = Type: <b>IEnumSyncMgrSyncItems**</b> The address of the cloned IEnumSyncMgrSyncItems interface pointer.
    HRESULT Clone(IEnumSyncMgrSyncItems* ppenum);
}

///Exposes a single method through which a handler or external application can notify Sync Center that synchronization
///has begun, as well as report progress and events.
@GUID("17F48517-F305-4321-A08D-B25A834918FD")
interface ISyncMgrSessionCreator : IUnknown
{
    ///Notifies Sync Center that synchronization of the specified items has begun.
    ///Params:
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the handler. This string is of maximum
    ///                   length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    ppszItemIDs = Type: <b>LPCWSTR*</b> The address of a pointer to a buffer containing an array of item IDs, managed by the
    ///                  handler specified in <i>pszHandlerID</i>, to be synchronized. Each ID is of maximum length MAX_SYNCMGR_ID
    ///                  including the terminating <b>null</b> character.
    ///    cItems = Type: <b>ULONG</b> The number of item IDs contained in the buffer referenced in <i>ppszItemIDs</i>.
    ///    ppCallback = Type: <b>ISyncMgrSyncCallback**</b> The address of a pointer to an instance of ISyncMgrSyncCallback used to
    ///                 report progress and events. This value can be <b>NULL</b> if no callback is needed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateSession(const(wchar)* pszHandlerID, char* ppszItemIDs, uint cItems, 
                          ISyncMgrSyncCallback* ppCallback);
}

///Exposes methods that allow a synchronization process to report progress and events to Sync Center, or to query
///whether the process has been canceled.
@GUID("884CCD87-B139-4937-A4BA-4F8E19513FBE")
interface ISyncMgrSyncCallback : IUnknown
{
    ///Reports the progress of the synchronization of a single sync item to Sync Center.
    ///Params:
    ///    pszItemID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the item currently being synchronized.
    ///                This string is of maximum length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    pszProgressText = Type: <b>LPCWSTR</b> A pointer to a buffer containing a Unicode string for any custom progress messaging for
    ///                      this item.
    ///    nStatus = Type: <b>SYNCMGR_PROGRESS_STATUS</b> A value from the SYNCMGR_PROGRESS_STATUS enumeration stating the current
    ///              progress status of the synchronization.
    ///    uCurrentStep = Type: <b>ULONG</b> The current step in the synchronization. If the SYNCMGR_PS_UPDATING_INDETERMINATE flag is
    ///                   set in <i>nStatus</i>, this parameter is ignored.
    ///    uMaxStep = Type: <b>ULONG</b> The total number of steps required to complete the synchronization of the item. If the
    ///               SYNCMGR_PS_UPDATING_INDETERMINATE flag is set in <i>nStatus</i>, this parameter is ignored.
    ///    pnCancelRequest = Type: <b>SYNCMGR_CANCEL_REQUEST*</b> When this method returns, points to a value from the
    ///                      SYNCMGR_CANCEL_REQUEST enumeration specifying the nature of a cancel request, if any.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ReportProgress(const(wchar)* pszItemID, const(wchar)* pszProgressText, SYNCMGR_PROGRESS_STATUS nStatus, 
                           uint uCurrentStep, uint uMaxStep, SYNCMGR_CANCEL_REQUEST* pnCancelRequest);
    ///Sets the content of an information field for the handler while that handler is performing a synchronization.
    ///Params:
    ///    pszProgressText = Type: <b>LPCWSTR</b> Pointer to a buffer containing the comment text.
    ///    pnCancelRequest = Type: <b>SYNCMGR_CANCEL_REQUEST*</b> A value from the SYNCMGR_CANCEL_REQUEST enumeration specifying the
    ///                      nature of a cancel request, if any.
    HRESULT SetHandlerProgressText(const(wchar)* pszProgressText, SYNCMGR_CANCEL_REQUEST* pnCancelRequest);
    HRESULT ReportEventA(const(wchar)* pszItemID, SYNCMGR_EVENT_LEVEL nLevel, SYNCMGR_EVENT_FLAGS nFlags, 
                         const(wchar)* pszName, const(wchar)* pszDescription, const(wchar)* pszLinkText, 
                         const(wchar)* pszLinkReference, const(wchar)* pszContext, GUID* pguidEventID);
    ///Determines whether the synchronization has been canceled.
    ///Params:
    ///    pszItemID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the ID of the item.
    ///Returns:
    ///    Type: <b>HRESULT</b> <table class="clsStd"> <tr> <th>Return Value</th> <th>Meaning</th> </tr> <tr>
    ///    <td>S_OK</td> <td>A cancellation has not been requested. The synchronization can continue.</td> </tr> <tr>
    ///    <td>S_FALSE</td> <td>A cancellation has been requested. The handler should call
    ///    ISyncMgrSyncCallback::ReportProgress, specifying SYNCMGR_PS_CANCELED in the <i>nStatus</i> parameter.</td>
    ///    </tr> <tr> <td>E_INVALIDARG</td> <td>The value pointed to by <i>pszItemID</i> is either unknown to Sync
    ///    Center or is not an item managed by this handler.</td> </tr> </table> If <i>pszItemID</i> is <b>NULL</b> or
    ///    an empty string, the return value depends on whether a cancellation has been requested for the entire
    ///    handler.
    ///    
    HRESULT CanContinue(const(wchar)* pszItemID);
    ///Retrieves an enumerator of the set of items that have a pending request to be synchronized. This is the set of
    ///items that will be synchronized after the current synchronization is finished.
    ///Params:
    ///    ppenumItemIDs = Type: <b>IEnumString**</b> When this method returns, contains the address of a pointer to an instance of
    ///                    IEnumString that enumerates sync item IDs. This value is <b>NULL</b> if no items are pending.
    ///    ppenumPunks = Type: <b>IEnumUnknown**</b> When this method returns, contains the address of a pointer to an instance of
    ///                  IEnumUnknown enumerating IUnknown interfaces that are passed to StartHandlerSync or StartItemSync. This value
    ///                  is <b>NULL</b> if no interfaces are pending.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful, or an error value otherwise. Returns <b>S_FALSE</b>
    ///    if no items are pending.
    ///    
    HRESULT QueryForAdditionalItems(IEnumString* ppenumItemIDs, IEnumUnknown* ppenumPunks);
    ///Adds a specified item to the set of items currently being synchronized.
    ///Params:
    ///    pszItemID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the item to add. This string is of
    ///                maximum length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. Returns E_INVALIDARG if
    ///    <i>pszItemID</i> is already part of the session.
    ///    
    HRESULT AddItemToSession(const(wchar)* pszItemID);
    HRESULT AddIUnknownToSession(IUnknown punk);
    ///Proposes the addition of a new item to the set of items previously enumerated.
    ///Params:
    ///    pNewItem = Type: <b>ISyncMgrSyncItem*</b> A pointer to an instance of ISyncMgrSyncItem representing the new item.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. Returns E_INVALIDARG if
    ///    <i>pszItemID</i> already exists.
    ///    
    HRESULT ProposeItem(ISyncMgrSyncItem pNewItem);
    ///Confirms a specified item as a member of the handler's sync set and confirms that it should be shown in the UI.
    ///Params:
    ///    pszItemID = Type: <b>LPCWSTR*</b> A pointer to a buffer containing the unique ID of the item to confirm. This string is
    ///                of maximum length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    HRESULT CommitItem(const(wchar)* pszItemID);
    ///Reports that a synchronization operation is being performed that was requested manually from outside the Sync
    ///Center UI.
    HRESULT ReportManualSync();
}

///Exposes a method through which a sync handler or sync item can display a UI object when requested to do so by Sync
///Center.
@GUID("FC7CFA47-DFE1-45B5-A049-8CFD82BEC271")
interface ISyncMgrUIOperation : IUnknown
{
    ///Performs the actual display of UI for a handler or sync item when requested to do so by Sync Center.
    ///Params:
    ///    hwndOwner = Type: <b>HWND</b> A handle to the window used to display the UI.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise. Returns S_FALSE or another
    ///    error code if this method is called to confirm an operation, such as activating a handler or disabling a sync
    ///    item, but that operation should not be executed.
    ///    
    HRESULT Run(HWND hwndOwner);
}

///Provides a method that is called when event links are clicked in the sync results folder.
@GUID("64522E52-848B-4015-89CE-5A36F00B94FF")
interface ISyncMgrEventLinkUIOperation : ISyncMgrUIOperation
{
    ///Enables Sync Center to provide the event to link to so ISyncMgrUIOperation::Run knows which event to operate
    ///upon.
    ///Params:
    ///    rguidEventID = Type: <b>REFGUID</b> A reference to the event ID that is being stored. This parameter is the same as what is
    ///                   returned from the GetEventID method of the <i>pEvent</i> parameter.
    ///    pEvent = Type: <b>ISyncMgrEvent*</b> A pointer to the ISyncMgrEvent object for Run to use. This is the event object
    ///             that owns the link.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Init(const(GUID)* rguidEventID, ISyncMgrEvent pEvent);
}

///Exposes a method that allows a handler to display the sync schedule wizard for the handler.
@GUID("459A6C84-21D2-4DDC-8A53-F023A46066F2")
interface ISyncMgrScheduleWizardUIOperation : ISyncMgrUIOperation
{
    ///Initializes the sync schedule wizard.
    ///Params:
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to a handler ID as a Unicode string.
    HRESULT InitWizard(const(wchar)* pszHandlerID);
}

///Exposes a method that applications calling ISyncMgrControl can use to get the result of a
///ISyncMgrControl::StartHandlerSync or ISyncMgrControl::StartItemSync call.
@GUID("2B90F17E-5A3E-4B33-BB7F-1BC48056B94D")
interface ISyncMgrSyncResult : IUnknown
{
    ///Gets the result of a StartHandlerSync or StartItemSync call.
    ///Params:
    ///    nStatus = Type: <b>SYNCMGR_PROGRESS_STATUS</b> The current status of the progress report. See SYNCMGR_PROGRESS_STATUS.
    ///    cError = Type: <b>UINT</b> An error.
    ///    cConflicts = Type: <b>UINT</b> Specifies conflicts.
    HRESULT Result(SYNCMGR_PROGRESS_STATUS nStatus, uint cError, uint cConflicts);
}

///Exposes methods that allow an application or handler to start or stop a synchronization, notify Sync Center of
///changes to the set of handlers or items, or notify of changes to property values.
@GUID("9B63616C-36B2-46BC-959F-C1593952D19B")
interface ISyncMgrControl : IUnknown
{
    ///Initiates the synchronization of all items managed by a particular handler.
    ///Params:
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the handler to synchronize. This
    ///                   string is of maximum length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    hwndOwner = Type: <b>HWND</b> A handle to the window that the handler can use to display any necessary UI. This value can
    ///                be <b>NULL</b>.
    ///    punk = Type: <b>IUnknown*</b> A pointer to an IUnknown to be passed to Synchronize. This parameter can be
    ///           <b>NULL</b>.
    ///    nSyncControlFlags = Type: <b>SYNCMGR_SYNC_CONTROL_FLAGS</b> A member of the SYNCMGR_SYNC_CONTROL_FLAGS enumeration that specifies
    ///                        whether an item found in both a current sync and a queued sync should be synchronized again when the queued
    ///                        sync is performed.
    ///    pResult = Type: <b>ISyncMgrSyncResult*</b> A pointer to an instance of ISyncMgrSyncResult, whose Result method is
    ///              called when the synchronization ends, either through success, failure, or cancellation. The <b>Result</b>
    ///              method is called with the aggregated state of the handler synchronization. This parameter can be <b>NULL</b>.
    HRESULT StartHandlerSync(const(wchar)* pszHandlerID, HWND hwndOwner, IUnknown punk, 
                             SYNCMGR_SYNC_CONTROL_FLAGS nSyncControlFlags, ISyncMgrSyncResult pResult);
    ///Initiates the synchronization of specified items managed by a particular handler.
    ///Params:
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the handler that manages the items.
    ///                   This string is of maximum length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    ppszItemIDs = Type: <b>LPCWSTR*</b> The address of a pointer to a buffer containing an array of IDs of the items to be
    ///                  synchronized. Each ID is of maximum length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///                  This array is passed to Synchronize.
    ///    cItems = Type: <b>DWORD</b> The number of IDs in <i>ppszItemIDs</i>.
    ///    hwndOwner = Type: <b>HWND</b> A handle to the window that the item can use to display any necessary UI. This value can be
    ///                <b>NULL</b>.
    ///    punk = Type: <b>IUnknown*</b> A pointer to an IUnknown to be passed to Synchronize. This parameter can be
    ///           <b>NULL</b>.
    ///    nSyncControlFlags = Type: <b>SYNCMGR_SYNC_CONTROL_FLAGS</b> A member of the SYNCMGR_SYNC_CONTROL_FLAGS enumeration that specifies
    ///                        whether an item found in both a current sync and a queued sync should be synchronized again when the queued
    ///                        sync is performed.
    ///    pResult = Type: <b>ISyncMgrSyncResult*</b> A pointer to an instance of ISyncMgrSyncResult, whose Result method is
    ///              called when the synchronization ends, either through success, failure, or cancellation. The <b>Result</b>
    ///              method is called with the aggregated state of the handler synchronization. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StartItemSync(const(wchar)* pszHandlerID, char* ppszItemIDs, uint cItems, HWND hwndOwner, 
                          IUnknown punk, SYNCMGR_SYNC_CONTROL_FLAGS nSyncControlFlags, ISyncMgrSyncResult pResult);
    ///Synchronizes all items managed by all handlers.
    ///Params:
    ///    hwndOwner = Type: <b>HWND</b> A handle to a window that can be used by a handler or item to display any necessary UI.
    ///                This value can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StartSyncAll(HWND hwndOwner);
    ///Stops the synchronization of a specified handler.
    ///Params:
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the handler. This string is of maximum
    ///                   length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    HRESULT StopHandlerSync(const(wchar)* pszHandlerID);
    ///Stops the synchronization of specified items managed by a particular handler.
    ///Params:
    ///    pszHandlerID = Type: <b>LPCWSTR</b> a pointer to a buffer containing the unique ID of the handler. This string is of maximum
    ///                   length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    ppszItemIDs = Type: <b>LPCWSTR*</b> The address of a pointer to a buffer containing an array of IDs of the items to stop
    ///                  synchronizing. Each ID is of maximum length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    cItems = Type: <b>DWORD</b> The number of IDs in <i>ppszItemIDs</i>.
    HRESULT StopItemSync(const(wchar)* pszHandlerID, char* ppszItemIDs, uint cItems);
    ///Stops the synchronization of all items managed by all handlers.
    HRESULT StopSyncAll();
    ///Instructs Sync Center to reenumerate the handler collection, or informs it that properties of a handler in the
    ///handler collection have changed.
    ///Params:
    ///    rclsidCollectionID = Type: <b>REFCLSID</b> A reference to the handler collection's CLSID.
    ///    nControlFlags = Type: <b>SYNCMGR_CONTROL_FLAGS</b> A value from the SYNCMGR_CONTROL_FLAGS enumeration specifying whether the
    ///                    update should be performed synchronously or asynchronously.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UpdateHandlerCollection(const(GUID)* rclsidCollectionID, SYNCMGR_CONTROL_FLAGS nControlFlags);
    ///Instructs Sync Center to reenumerate the items managed by a handler or informs it that properties of the handler
    ///have changed.
    ///Params:
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the handler. This string is of maximum
    ///                   length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    nControlFlags = Type: <b>SYNCMGR_CONTROL_FLAGS</b> A value from the SYNCMGR_CONTROL_FLAGS enumeration specifying whether the
    ///                    update should be performed synchronously or asynchronously.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UpdateHandler(const(wchar)* pszHandlerID, SYNCMGR_CONTROL_FLAGS nControlFlags);
    ///Informs Sync Center that properties of a sync item have changed.
    ///Params:
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the handler that manages the item.
    ///                   This string is of maximum length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    pszItemID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the item. This string is of maximum
    ///                length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    nControlFlags = Type: <b>SYNCMGR_CONTROL_FLAGS</b> A value from the SYNCMGR_CONTROL_FLAGS enumeration specifying whether the
    ///                    update should be performed synchronously or asynchronously.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UpdateItem(const(wchar)* pszHandlerID, const(wchar)* pszItemID, SYNCMGR_CONTROL_FLAGS nControlFlags);
    ///Informs Sync Center that events have been added for a specific handler or item.
    ///Params:
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the handler that manages the item.
    ///                   This string is of maximum length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    pszItemID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the item. This string is of maximum
    ///                length MAX_SYNCMGR_ID including the terminating <b>null</b> character. This parameter can be <b>NULL</b> if
    ///                the event occurred on the handler rather than on a specific item.
    ///    nControlFlags = Type: <b>SYNCMGR_CONTROL_FLAGS</b> A value from the SYNCMGR_CONTROL_FLAGS enumeration specifying whether the
    ///                    update should be performed synchronously or asynchronously.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UpdateEvents(const(wchar)* pszHandlerID, const(wchar)* pszItemID, SYNCMGR_CONTROL_FLAGS nControlFlags);
    HRESULT UpdateConflict(const(wchar)* pszHandlerID, const(wchar)* pszItemID, ISyncMgrConflict pConflict, 
                           SYNCMGR_UPDATE_REASON nReason);
    ///Informs Sync Center that conflicts have been added for a specific handler or item.
    ///Params:
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the handler that manages the item.
    ///                   This string is of maximum length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    pszItemID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the item. This string is of maximum
    ///                length MAX_SYNCMGR_ID including the terminating <b>null</b> character. This parameter can be <b>NULL</b> if
    ///                the event occurred on the handler rather than on a specific item.
    ///    nControlFlags = Type: <b>SYNCMGR_CONTROL_FLAGS</b> A value from the SYNCMGR_CONTROL_FLAGS enumeration specifying whether the
    ///                    update should be performed synchronously or asynchronously.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UpdateConflicts(const(wchar)* pszHandlerID, const(wchar)* pszItemID, 
                            SYNCMGR_CONTROL_FLAGS nControlFlags);
    ///Activates or deactivates a handler.
    ///Params:
    ///    fActivate = Type: <b>BOOL</b> <b>TRUE</b> to activate; <b>FALSE</b> to deactivate.
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the handler. This string is of maximum
    ///                   length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    hwndOwner = Type: <b>HWND</b> A handle to a window that can be used by the handler to display any necessary UI. This
    ///                value can be <b>NULL</b>.
    ///    nControlFlags = Type: <b>SYNCMGR_CONTROL_FLAGS</b> A value from the SYNCMGR_CONTROL_FLAGS enumeration specifying whether the
    ///                    activation or deactivation of the handler should be performed synchronously or asynchronously.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ActivateHandler(BOOL fActivate, const(wchar)* pszHandlerID, HWND hwndOwner, 
                            SYNCMGR_CONTROL_FLAGS nControlFlags);
    ///Enables or disables a handler.
    ///Params:
    ///    fEnable = Type: <b>BOOL</b> <b>TRUE</b> to enable; <b>FALSE</b> to disable.
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the handler. This string is of maximum
    ///                   length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    hwndOwner = Type: <b>HWND</b> A handle to a window that can be used by the handler to display any necessary UI. This
    ///                value can be <b>NULL</b>.
    ///    nControlFlags = Type: <b>SYNCMGR_CONTROL_FLAGS</b> A value from the SYNCMGR_CONTROL_FLAGS enumeration specifying whether the
    ///                    enabling or disabling of the handler should be performed synchronously or asynchronously.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnableHandler(BOOL fEnable, const(wchar)* pszHandlerID, HWND hwndOwner, 
                          SYNCMGR_CONTROL_FLAGS nControlFlags);
    ///Enables or disables a sync item managed by a specified handler.
    ///Params:
    ///    fEnable = Type: <b>BOOL</b> <b>TRUE</b> to enable; <b>FALSE</b> to disable.
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the handler. This string is of maximum
    ///                   length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    pszItemID = Type: <b>LPCWSTR</b> A pointer to a buffer containing the unique ID of the item. This string is of maximum
    ///                length MAX_SYNCMGR_ID including the terminating <b>null</b> character.
    ///    hwndOwner = Type: <b>HWND</b> A handle to a window that can be used by the item to display any necessary UI. This value
    ///                can be <b>NULL</b>.
    ///    nControlFlags = Type: <b>SYNCMGR_CONTROL_FLAGS</b> A value from the SYNCMGR_CONTROL_FLAGS enumeration specifying whether the
    ///                    enabling or disabling of the item should be performed synchronously or asynchronously.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnableItem(BOOL fEnable, const(wchar)* pszHandlerID, const(wchar)* pszItemID, HWND hwndOwner, 
                       SYNCMGR_CONTROL_FLAGS nControlFlags);
}

///Exposes methods that allow a handler to provide its own event store and manage its own sync events, instead of using
///the default Sync Center event store. These events are displayed in the Sync Results folder.
@GUID("37E412F9-016E-44C2-81FF-DB3ADD774266")
interface ISyncMgrEventStore : IUnknown
{
    ///Gets an enumerator for a handler's events.
    ///Params:
    ///    ppenum = Type: <b>IEnumSyncMgrEvents**</b> When this method returns, contains the address of a pointer to an
    ///             IEnumSyncMgrEvents instance that can be used to access the handler's events.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEventEnumerator(IEnumSyncMgrEvents* ppenum);
    ///Gets the event count.
    ///Params:
    ///    pcEvents = Type: <b>ULONG*</b> A pointer to event count value.
    HRESULT GetEventCount(uint* pcEvents);
    ///Gets a specified event object.
    ///Params:
    ///    rguidEventID = Type: <b>REFGUID</b> A reference to event <b>GUID</b>.
    ///    ppEvent = Type: <b>ISyncMgrEvent**</b> The address of ISyncMgrEvent interface pointer.
    HRESULT GetEvent(const(GUID)* rguidEventID, ISyncMgrEvent* ppEvent);
    ///Removes events, as specified.
    ///Params:
    ///    pguidEventIDs = Type: <b>GUID*</b> A pointer to event <b>GUID</b>.
    ///    cEvents = Type: <b>ULONG</b> The count of events to remove.
    HRESULT RemoveEvent(char* pguidEventIDs, uint cEvents);
}

///Exposes methods that retrieve data from an event store. An event store allows Sync Center to get an enumerator of all
///events in the store, as well as to retrieve individual events.
@GUID("FEE0EF8B-46BD-4DB4-B7E6-FF2C687313BC")
interface ISyncMgrEvent : IUnknown
{
    ///Gets the event ID.
    ///Params:
    ///    pguidEventID = Type: <b>GUID*</b> When this method returns, contains a pointer to an event ID.
    HRESULT GetEventID(GUID* pguidEventID);
    ///Gets the ID of the handler for which the event was logged.
    ///Params:
    ///    ppszHandlerID = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to a handler ID as a Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetHandlerID(ushort** ppszHandlerID);
    ///Gets the ID of the item for which the event was logged.
    ///Params:
    ///    ppszItemID = Type: <b>LPWSTR*</b> Contains a pointer to an item ID as a Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetItemID(ushort** ppszItemID);
    ///Gets the log level of the event.
    ///Params:
    ///    pnLevel = Type: <b>SYNCMGR_EVENT_LEVEL*</b> When this method returns, contains a pointer to a member of the
    ///              SYNCMGR_EVENT_LEVEL enumeration that indicates the log level.
    HRESULT GetLevel(SYNCMGR_EVENT_LEVEL* pnLevel);
    ///Gets event flags.
    ///Params:
    ///    pnFlags = Type: <b>SYNCMGR_EVENT_FLAGS*</b> When this method returns, contains a pointer to a value that indicates the
    ///              currently set flags, taken from members of the SYNCMGR_EVENT_FLAGS enumeration.
    HRESULT GetFlags(SYNCMGR_EVENT_FLAGS* pnFlags);
    ///Gets the creation time.
    ///Params:
    ///    pfCreationTime = Type: <b>FILETIME*</b> When this method returns, contains a pointer to a creation time as a FILETIME
    ///                     structure.
    HRESULT GetTime(FILETIME* pfCreationTime);
    ///Gets the name of the event. This string can be a simple name for the event or a short summary. It is displayed in
    ///the folder and in the property sheet for the event.
    ///Params:
    ///    ppszName = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to a name as a Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetName(ushort** ppszName);
    ///Gets the event description.
    ///Params:
    ///    ppszDescription = Type: <b>LPWSTR*</b> When this method returns, contains the address of a pointer to a null-terminated Unicode
    ///                      buffer that contains the description.
    HRESULT GetDescription(ushort** ppszDescription);
    ///Gets the text for the hot link for the event. The hot link is a displayed property that the user can click to
    ///execute an action. This allows the handler to show an available action that the user can see at a glance in the
    ///folder. The link text is the text that is displayed to the user.
    ///Params:
    ///    ppszLinkText = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to the link text as a Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLinkText(ushort** ppszLinkText);
    ///Gets the reference for the hot link for the event. The hot link is a displayed property that the user can click
    ///to execute an action. This allows the handler to show an available action that the user can see at a glance in
    ///the folder.
    ///Params:
    ///    ppszLinkReference = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to a link reference as a Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLinkReference(ushort** ppszLinkReference);
    ///Gets a context object that can be used by a handler to display properties or execute a context menu action.
    ///Params:
    ///    ppszContext = Type: <b>LPWSTR*</b> When this method returns, contains a pointer to the context as a Unicode string.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetContext(ushort** ppszContext);
}

///Exposes sync event enumeration methods.
@GUID("C81A1D4E-8CF7-4683-80E0-BCAE88D677B6")
interface IEnumSyncMgrEvents : IUnknown
{
    ///Gets the next batch of events from the event store.
    ///Params:
    ///    celt = Type: <b>ULONG</b> This value must be 1.
    ///    rgelt = Type: <b>ISyncMgrEvent**</b> The address of an ISyncMgrEvent interface pointer.
    ///    pceltFetched = Type: <b>ULONG*</b> A pointer to the number of events fetched.
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips forward the specified number of events in the enumeration.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of events to skip.
    HRESULT Skip(uint celt);
    ///Resets the current location in the enumeration to zero.
    HRESULT Reset();
    ///Clones an IEnumSyncMgrEvents object.
    ///Params:
    ///    ppenum = Type: <b>IEnumSyncMgrEvents**</b> The address of the cloned IEnumSyncMgrEvents interface pointer.
    HRESULT Clone(IEnumSyncMgrEvents* ppenum);
}

///Exposes methods that allow a handler to provide conflicts that appear in the Conflicts folder.
@GUID("CF8FC579-C396-4774-85F1-D908A831156E")
interface ISyncMgrConflictStore : IUnknown
{
    ///Enumerates conflicts scoped to the provided sync handler and sync item.
    ///Params:
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to the sync handler ID as a Unicode string.
    ///    pszItemID = Type: <b>LPCWSTR</b> A pointer to the sync item ID as a Unicode string.
    ///    ppEnum = Type: <b>IEnumSyncMgrConflict**</b> The address of an IEnumSyncMgrConflict interface pointer.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnumConflicts(const(wchar)* pszHandlerID, const(wchar)* pszItemID, IEnumSyncMgrConflict* ppEnum);
    ///Binds to a particular conflict specified by IID.
    ///Params:
    ///    pConflictIdInfo = Type: <b>const SYNCMGR_CONFLICT_ID_INFO*</b> A pointer to a SYNCMGR_CONFLICT_ID_INFO structure.
    ///    riid = Type: <b>REFIID</b> A reference to a desired conflict IID.
    ///    ppv = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BindToConflict(const(SYNCMGR_CONFLICT_ID_INFO)* pConflictIdInfo, const(GUID)* riid, void** ppv);
    ///Deletes a set of conflicts, specified by conflict ID, from the store.
    ///Params:
    ///    rgConflictIdInfo = Type: <b>const SYNCMGR_CONFLICT_ID_INFO*</b> A pointer to a SYNCMGR_CONFLICT_ID_INFO structure.
    ///    cConflicts = Type: <b>DWORD</b> The conflict set.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveConflicts(char* rgConflictIdInfo, uint cConflicts);
    ///Gets the number of conflicts in the store.
    ///Params:
    ///    pszHandlerID = Type: <b>LPCWSTR</b> A pointer to a sync handler ID as a Unicode string.
    ///    pszItemID = Type: <b>LPCWSTR</b> A pointer to a sync item ID as a Unicode string.
    ///    pnConflicts = Type: <b>DWORD*</b> When this method returns, contains the conflict count.
    HRESULT GetCount(const(wchar)* pszHandlerID, const(wchar)* pszItemID, uint* pnConflicts);
}

///Exposes conflict enumeration methods.
@GUID("82705914-DDA3-4893-BA99-49DE6C8C8036")
interface IEnumSyncMgrConflict : IUnknown
{
    ///Gets the next batch of conflicts from the conflicts store.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The value must be 1.
    ///    rgelt = Type: <b>ISyncMgrConflict**</b> The address of an ISyncMgrConflict interface pointer.
    ///    pceltFetched = Type: <b>ULONG*</b> A pointer to the number of conflicts fetched.
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips forward the specified number of conflicts in the enumeration.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of conflicts to skip.
    HRESULT Skip(uint celt);
    ///Resets the current position in the enumeration to zero.
    HRESULT Reset();
    ///Not used. Clones an IEnumSyncMgrConflict object.
    ///Params:
    ///    ppenum = Type: <b>IEnumSyncMgrConflict**</b> The address of the cloned IEnumSyncMgrConflict interface pointer.
    HRESULT Clone(IEnumSyncMgrConflict* ppenum);
}

///Exposes methods that provide information about a conflict retrieved from a conflict store, and allows the conflict to
///be resolved.
@GUID("9C204249-C443-4BA4-85ED-C972681DB137")
interface ISyncMgrConflict : IUnknown
{
    ///Gets a conflict property, given a property key.
    ///Params:
    ///    propkey = Type: <b>REFPROPERTYKEY</b> A reference to the property key for which the property is being requested. Any
    ///              property key is valid here, including but not limited to the following values.
    ///    ppropvar = Type: <b>PROPVARIANT*</b> When this method returns, contains a PROPVARIANT structure that contains the
    ///               requested property.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetProperty(const(PROPERTYKEY)* propkey, PROPVARIANT* ppropvar);
    ///Gets information that identifies a conflict within a conflict store.
    ///Params:
    ///    pConflictIdInfo = Type: <b>SYNCMGR_CONFLICT_ID_INFO*</b> A pointer to a conflict ID info structure. See
    ///                      SYNCMGR_CONFLICT_ID_INFO.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetConflictIdInfo(SYNCMGR_CONFLICT_ID_INFO* pConflictIdInfo);
    ///Retrieves a conflict items array.
    ///Params:
    ///    ppArray = Type: <b>ISyncMgrConflictItems**</b> The address of a pointer to an ISyncMgrConflictItems array.
    HRESULT GetItemsArray(ISyncMgrConflictItems* ppArray);
    ///Resolves the conflict using its own sync handler, controls UI.
    ///Params:
    ///    pResolveInfo = Type: <b>ISyncMgrConflictResolveInfo*</b> A pointer to a ISyncMgrConflictResolveInfo.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Resolve(ISyncMgrConflictResolveInfo pResolveInfo);
    ///Gets the resolution handler for the conflict.
    ///Params:
    ///    riid = Type: <b>REFIID</b> A reference to the ID for the resolution handler.
    ///    ppvResolutionHandler = Type: <b>void**</b> When this method returns, contains the interface pointer requested in <i>riid</i>.
    HRESULT GetResolutionHandler(const(GUID)* riid, void** ppvResolutionHandler);
}

///Exposes methods that manage synchronizing conflicts. Implement this interface to construct a sync conflict handler.
///The conflict resolution user interface (UI) will call this interface to resolve the conflict presented to the user.
@GUID("40A3D052-8BFF-4C4B-A338-D4A395700DE9")
interface ISyncMgrResolutionHandler : IUnknown
{
    ///Determines what options the conflict presenter will display.
    ///Params:
    ///    pdwAbilities = Type: <b>SYNCMGR_RESOLUTION_ABILITIES_FLAGS*</b> When this method returns, contains one of the
    ///                   SYNCMGR_RESOLUTION_ABILITIES enumerated type.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT QueryAbilities(uint* pdwAbilities);
    ///Replaces the versions in conflict with a different Shell item that is usually a merged version of the originals.
    ///Params:
    ///    psiOther = Type: <b>IShellItem*</b> A pointer to the substitute IShellItem.
    ///    pFeedback = Type: <b>SYNCMGR_RESOLUTION_FEEDBACK*</b> When this method returns, contains a SYNCMGR_RESOLUTION_FEEDBACK
    ///                value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT KeepOther(IShellItem psiOther, SYNCMGR_RESOLUTION_FEEDBACK* pFeedback);
    ///Keeps the more recent copy.
    ///Params:
    ///    pFeedback = Type: <b>SYNCMGR_RESOLUTION_FEEDBACK*</b> When this method returns, contains a SYNCMGR_RESOLUTION_FEEDBACK
    ///                value.
    HRESULT KeepRecent(SYNCMGR_RESOLUTION_FEEDBACK* pFeedback);
    ///Deletes the conflict and removes the IShellItem from synchronization.
    ///Params:
    ///    pFeedback = Type: <b>SYNCMGR_RESOLUTION_FEEDBACK*</b> A pointer to a SYNCMGR_RESOLUTION_FEEDBACK value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveFromSyncSet(SYNCMGR_RESOLUTION_FEEDBACK* pFeedback);
    ///Keeps the Shell items that are passed in.
    ///Params:
    ///    pArray = Type: <b>ISyncMgrConflictResolutionItems*</b> A pointer to an array ofISyncMgrConflictResolutionItems. The
    ///             array will contain more than one item if method ISyncMgrResolutionHandler::QueryAbilities returned
    ///             SYNCMGR_RA_KEEP_MULTIPLE in parameter <i>pdwAbilities</i>.
    ///    pFeedback = Type: <b>SYNCMGR_RESOLUTION_FEEDBACK*</b> When this method returns, contains a SYNCMGR_RESOLUTION_FEEDBACK
    ///                value.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT KeepItems(ISyncMgrConflictResolutionItems pArray, SYNCMGR_RESOLUTION_FEEDBACK* pFeedback);
}

///Exposes a method that presents a conflict to the user.
@GUID("0B4F5353-FD2B-42CD-8763-4779F2D508A3")
interface ISyncMgrConflictPresenter : IUnknown
{
    ///Presents the conflict to the user.
    ///Params:
    ///    pConflict = Type: <b>ISyncMgrConflict*</b> Specifies the conflict. See ISyncMgrConflict.
    ///    pResolveInfo = Type: <b>ISyncMgrConflictResolveInfo*</b>
    HRESULT PresentConflict(ISyncMgrConflict pConflict, ISyncMgrConflictResolveInfo pResolveInfo);
}

///Exposes methods that get and set information about sync manager conflict resolution.
@GUID("C405A219-25A2-442E-8743-B845A2CEE93F")
interface ISyncMgrConflictResolveInfo : IUnknown
{
    ///Gets information about which conflict in a set of conflicts is being resolved.
    ///Params:
    ///    pnCurrentConflict = Type: <b>UINT*</b> When this method returns, contains a pointer to the index of the conflict in the set that
    ///                        is being resolved.
    ///    pcConflicts = Type: <b>UINT*</b> When this method returns, contains a pointer to the number of conflicts that are being
    ///                  resolved.
    ///    pcRemainingForApplyToAll = Type: <b>UINT*</b> When this method returns, contains a pointer to the number of the remaining conflicts to
    ///                               which an "apply to all" response would be applied.
    HRESULT GetIterationInfo(uint* pnCurrentConflict, uint* pcConflicts, uint* pcRemainingForApplyToAll);
    ///Gets what the presenter wants to do as the next step in the sync manager conflict resolution.
    ///Params:
    ///    pnPresenterNextStep = Type: <b>SYNCMGR_PRESENTER_NEXT_STEP*</b> When this method returns, contains a pointer to the next step in
    ///                          conflict resolution. One of the members of the SYNCMGR_PRESENTER_NEXT_STEP enumeration.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPresenterNextStep(SYNCMGR_PRESENTER_NEXT_STEP* pnPresenterNextStep);
    ///Gets what kind of choice was made and whether to apply the choice to all subsequent conflicts in the set.
    ///Params:
    ///    pnPresenterChoice = Type: <b>SYNCMGR_PRESENTER_CHOICE*</b> When this method returns, contains a pointer to the choice that was
    ///                        made about the conflict resolution. One of the members of the SYNCMGR_PRESENTER_CHOICE enumeration.
    ///    pfApplyToAll = Type: <b>BOOL*</b> When this method returns, contains a pointer to a flag. If <b>TRUE</b>, then the given
    ///                   choice is to be applied to all subsequent conflicts in the set, and
    ///                   ISyncMgrConflictResolveInfo::GetItemChoice and ISyncMgrConflictResolveInfo::GetItemChoiceCount have
    ///                   information on how to apply this choice. Otherwise <b>FALSE</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPresenterChoice(SYNCMGR_PRESENTER_CHOICE* pnPresenterChoice, int* pfApplyToAll);
    ///Gets the number of items that the user wants to keep.
    ///Params:
    ///    pcChoices = Type: <b>UINT*</b> When this method returns, contains a pointer to the number of items that the user wants to
    ///                keep.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetItemChoiceCount(uint* pcChoices);
    ///Gets the index of an item that the user wants to keep.
    ///Params:
    ///    iChoice = Type: <b>UINT</b> The item that the user wants to keep.
    ///    piChoiceIndex = Type: <b>UINT*</b> The index into the conflict's item array. This value is passed to the resolver for
    ///                    subsequent conflicts in the same conflict set if the user chooses to apply the same operation to all selected
    ///                    conflicts of the same type from the same handler.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetItemChoice(uint iChoice, uint* piChoiceIndex);
    ///Sets what the presenter wants to do as the next step in the sync manager conflict resolution.
    ///Params:
    ///    nPresenterNextStep = Type: <b>SYNCMGR_PRESENTER_NEXT_STEP</b> The next step in the conflict resolution. One of the members of the
    ///                         SYNCMGR_PRESENTER_NEXT_STEP enumeration.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPresenterNextStep(SYNCMGR_PRESENTER_NEXT_STEP nPresenterNextStep);
    ///Sets what kind of choice was made about a sync manager conflict resolution and whether to apply the choice to all
    ///subsequent conflicts in the set.
    ///Params:
    ///    nPresenterChoice = Type: <b>SYNCMGR_PRESENTER_CHOICE</b> The choice that was made about the conflict resolution. One of the
    ///                       members of the SYNCMGR_PRESENTER_CHOICE enumeration.
    ///    fApplyToAll = Type: <b>BOOL</b> If <b>TRUE</b>, then apply the given choice to all subsequent conflicts in the set. In this
    ///                  case, ISyncMgrConflictResolveInfo::SetItemChoices must also be called.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPresenterChoice(SYNCMGR_PRESENTER_CHOICE nPresenterChoice, BOOL fApplyToAll);
    ///Sets the array of indexes that represents which items the user wants to keep. This method is used when the user
    ///chooses to apply the same operation to all selected conflicts of the same type from the same handler.
    ///Params:
    ///    prgiConflictItemIndexes = Type: <b>UINT*</b> The array of indexes of items that the user wants to keep.
    ///    cChoices = Type: <b>UINT</b> The number of item choices in <i>prgiConflictItemIndexes</i>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetItemChoices(uint* prgiConflictItemIndexes, uint cChoices);
}

///Exposes a method that gets the conflict ID list for a conflict object.
@GUID("59287F5E-BC81-4FCA-A7F1-E5A8ECDB1D69")
interface ISyncMgrConflictFolder : IUnknown
{
    ///Maps a conflict to its IShellItem.
    ///Params:
    ///    pConflict = Type: <b>ISyncMgrConflict*</b> A pointer to an ISyncMgrConflict interface.
    ///    ppidlConflict = Type: <b>PIDLIST_RELATIVE*</b> A pointer to a PIDL, specified relative to the folder.
    HRESULT GetConflictIDList(ISyncMgrConflict pConflict, ITEMIDLIST** ppidlConflict);
}

///Exposes methods that get conflict item data and item count.
@GUID("9C7EAD52-8023-4936-A4DB-D2A9A99E436A")
interface ISyncMgrConflictItems : IUnknown
{
    ///Gets the conflict item count.
    ///Params:
    ///    pCount = Type: <b>UINT*</b> A pointer to the item count.
    HRESULT GetCount(uint* pCount);
    ///Gets a specified conflict data item.
    ///Params:
    ///    iIndex = Type: <b>UINT</b> The index of the conflict item to retrieve.
    ///    pItemInfo = Type: <b>CONFIRM_CONFLICT_ITEM*</b> When this method returns successfully, contains a pointer to a
    ///                CONFIRM_CONFLICT_ITEM structure that contains information about the conflict.
    HRESULT GetItem(uint iIndex, CONFIRM_CONFLICT_ITEM* pItemInfo);
}

///Exposes methods that get item info and item count.
@GUID("458725B9-129D-4135-A998-9CEAFEC27007")
interface ISyncMgrConflictResolutionItems : IUnknown
{
    ///Gets item count.
    ///Params:
    ///    pCount = Type: <b>UINT*</b> A pointer to an item count.
    HRESULT GetCount(uint* pCount);
    ///Gets result information for a specified item, when successful.
    ///Params:
    ///    iIndex = Type: <b>UINT</b> The index of the item.
    ///    pItemInfo = Type: <b>CONFIRM_CONFLICT_RESULT_INFO*</b> On success, contains a pointer to a CONFIRM_CONFLICT_RESULT_INFO
    ///                structure.
    HRESULT GetItem(uint iIndex, CONFIRM_CONFLICT_RESULT_INFO* pItemInfo);
}

///Provides functionality for desktop apps to opt in to the focus tracking mechanism used in Windows Store apps.
@GUID("41C81592-514C-48BD-A22E-E6AF638521A6")
interface IInputPanelConfiguration : IUnknown
{
    ///Enables a client process to opt-in to the focus tracking mechanism for Windows Store apps that controls the
    ///invoking and dismissing semantics of the touch keyboard.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnableFocusTracking();
}

///Enables Windows Store apps to opt out of the automatic invocation behavior.
@GUID("A213F136-3B45-4362-A332-EFB6547CD432")
interface IInputPanelInvocationConfiguration : IUnknown
{
    ///Requires an explicit user tap in an edit field before the touch keyboard invokes.
    ///Returns:
    ///    The <b>RequireTouchInEditControl</b> method always returns <b>S_OK</b>.
    ///    
    HRESULT RequireTouchInEditControl();
}

///Exposes memory-efficient methods for accessing bitmaps. This interface is used as a thin wrapper around HBITMAP
///objects, allowing those objects to be reference counted and protected from having their underlying data changed.
@GUID("091162A4-BC96-411F-AAE8-C5122CD03363")
interface ISharedBitmap : IUnknown
{
    ///Retrieves the bitmap contained in an ISharedBitmap object.
    ///Params:
    ///    phbm = Type: <b>HBITMAP*</b> A pointer to a handle to the bitmap.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSharedBitmap(HBITMAP* phbm);
    ///Retrieves the size of the bitmap contained in an ISharedBitmap object.
    ///Params:
    ///    pSize = Type: <b>SIZE*</b> When this method returns, contains a pointer to a value that specifies the size, in
    ///            pixels, of the contained bitmap.
    HRESULT GetSize(SIZE* pSize);
    ///Retrieves the alpha type of the bitmap image.
    ///Params:
    ///    pat = Type: <b>WTS_ALPHATYPE*</b> When this method returns, contains a pointer to the alpha type of the bitmap
    ///          image. One of the following values.
    HRESULT GetFormat(WTS_ALPHATYPE* pat);
    ///Initializes a new ISharedBitmap object with a given bitmap.
    ///Params:
    ///    hbm = Type: <b>HBITMAP</b> A handle to the bitmap with which to initialize a new ISharedBitmap object. The bitmap
    ///          must be a DIB.
    ///    wtsAT = Type: <b>WTS_ALPHATYPE</b> The alpha type of the bitmap image. May be one of the following values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InitializeBitmap(HBITMAP hbm, WTS_ALPHATYPE wtsAT);
    ///Retrieves the bitmap contained in an ISharedBitmap object, and returns a copy if the contained bitmap resides in
    ///shared memory. After calling this method the bitmap is no longer associated with this <b>ISharedBitmap</b> and
    ///you cannot call ISharedBitmap::GetSharedBitmap or <b>ISharedBitmap::Detach</b> on it again.
    ///Params:
    ///    phbm = Type: <b>HBITMAP*</b> When this method returns, contains a pointer to a handle to the bitmap to retrieve.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Detach(HBITMAP* phbm);
}

///Exposes methods for a system thumbnail cache that is shared across applications.
@GUID("F676C15D-596A-4CE2-8234-33996F445DB1")
interface IThumbnailCache : IUnknown
{
    ///Gets a cached thumbnail for a given Shell item.
    ///Params:
    ///    pShellItem = Type: <b>IShellItem*</b> A pointer to the Shell item for which to retrieve a thumbnail.
    ///    cxyRequestedThumbSize = Type: <b>UINT</b> The requested thumbnail size in pixels. The maximum value is 1024.
    ///    flags = Type: <b>WTS_FLAGS</b> A combination of values from the WTS_FLAGS enumeration. See the Remarks section for
    ///            rules and a list of possible combinations.
    ///    ppvThumb = Type: <b>ISharedBitmap**</b> The address of an ISharedBitmap pointer that, when this method returns
    ///               successfully, receives the object used to access the thumbnail. This parameter may be <b>NULL</b>.
    ///    pOutFlags = Type: <b>WTS_CACHEFLAGS*</b> A pointer to a value that, when this method returns successfully, receives a
    ///                combination of the following flags from the WTS_CACHEFLAGS enumeration.
    ///    pThumbnailID = Type: <b>WTS_THUMBNAILID*</b> A pointer to a value that, when this method returns successfully, receives a
    ///                   unique ID for the returned thumbnail. This parameter may be <b>NULL</b>, in which case the thumbnail ID is
    ///                   discarded.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful or a standard COM error value otherwise, including the
    ///    following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> A parameter is invalid. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>WTS_E_FAILEDEXTRACTION</b></dt> </dl> </td> <td width="60%"> The Shell item does not
    ///    support thumbnail extraction. For example, .exe or .lnk items. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>WTS_E_EXTRACTIONTIMEDOUT</b></dt> </dl> </td> <td width="60%"> The extraction took longer than the
    ///    maximum allowable time. The extraction was not completed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>WTS_E_SURROGATEUNAVAILABLE</b></dt> </dl> </td> <td width="60%"> A surrogate process was not available
    ///    to be used for the extraction process. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>WTS_E_FASTEXTRACTIONNOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> The WTS_FASTEXTRACT flag was
    ///    set, but fast extraction is not available. </td> </tr> </table>
    ///    
    HRESULT GetThumbnail(IShellItem pShellItem, uint cxyRequestedThumbSize, WTS_FLAGS flags, 
                         ISharedBitmap* ppvThumb, WTS_CACHEFLAGS* pOutFlags, WTS_THUMBNAILID* pThumbnailID);
    ///Gets a thumbnail from the thumbnail cache, given its ID.
    ///Params:
    ///    thumbnailID = Type: <b>WTS_THUMBNAILID</b> The ID of the thumbnail to retrieve. The ID is obtained by calling GetThumbnail.
    ///    cxyRequestedThumbSize = Type: <b>UINT</b> The requested thumbnail size in pixels. This value cannot be larger than 1024.
    ///    ppvThumb = Type: <b>ISharedBitmap**</b> The address of a ISharedBitmap interface pointer that, when this method returns
    ///               successfully, receives the object for accessing the requested thumbnail. This parameter can be <b>NULL</b>.
    ///    pOutFlags = Type: <b>WTS_CACHEFLAGS*</b> A pointer to a value that, when this method returns successfully, receives a
    ///                combination of the following flags. This value can be set to <b>NULL</b> if this information is not needed.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> A parameter is invalid. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>WTS_E_FAILEDEXTRACTION</b></dt> </dl> </td> <td width="60%"> The Shell item does not
    ///    support thumbnail extraction. For example, .exe or .lnk items. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>WTS_E_EXTRACTIONTIMEDOUT</b></dt> </dl> </td> <td width="60%"> The extraction took longer than the
    ///    maximum allowable time. The extraction was not completed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>WTS_E_SURROGATEUNAVAILABLE</b></dt> </dl> </td> <td width="60%"> A surrogate process was not available
    ///    to be used for the extraction process. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>WTS_E_FASTEXTRACTIONNOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> The WTS_FASTEXTRACT flag was
    ///    set, but fast extraction is not available. </td> </tr> </table>
    ///    
    HRESULT GetThumbnailByID(WTS_THUMBNAILID thumbnailID, uint cxyRequestedThumbSize, ISharedBitmap* ppvThumb, 
                             WTS_CACHEFLAGS* pOutFlags);
}

///Exposes a method for getting a thumbnail image and is intended to be implemented for thumbnail handlers. The object
///that implements this interface must also implement IInitializeWithStream.
@GUID("E357FCCD-A995-4576-B01F-234630154E96")
interface IThumbnailProvider : IUnknown
{
    ///Gets a thumbnail image and alpha type.
    ///Params:
    ///    cx = Type: <b>UINT</b> The maximum thumbnail size, in pixels. The Shell draws the returned bitmap at this size or
    ///         smaller. The returned bitmap should fit into a square of width and height <i>cx</i>, though it does not need
    ///         to be a square image. The Shell scales the bitmap to render at lower sizes. For example, if the image has a
    ///         6:4 aspect ratio, then the returned bitmap should also have a 6:4 aspect ratio.
    ///    phbmp = Type: <b>HBITMAP*</b> When this method returns, contains a pointer to the thumbnail image handle. The image
    ///            must be a DIB section and 32 bits per pixel. The Shell scales down the bitmap if its width or height is
    ///            larger than the size specified by <i>cx</i>. The Shell always respects the aspect ratio and never scales a
    ///            bitmap larger than its original size.
    ///    pdwAlpha = Type: <b>WTS_ALPHATYPE*</b> When this method returns, contains a pointer to one of the following values from
    ///               the WTS_ALPHATYPE enumeration:
    HRESULT GetThumbnail(uint cx, HBITMAP* phbmp, WTS_ALPHATYPE* pdwAlpha);
}

///Provides a method that enables a thumbnail provider to determine the user context of a thumbnail request.
@GUID("F4376F00-BEF5-4D45-80F3-1E023BBF1209")
interface IThumbnailSettings : IUnknown
{
    ///Enables a thumbnail provider to return a thumbnail specific to the user's context. Initially, a thumbnail
    ///provider receives a request for a thumbnail image through a call to the IThumbnailCache::GetThumbnail method. In
    ///response, before the provider calls IExtractImage::Extract or IThumbnailProvider::GetThumbnail, the thumbnail
    ///cache can call <b>IThumbnailSettings::SetContext</b> to ensure that the thumbnail that is returned is appropriate
    ///to the user's context. For example, the provider could detect the new <b>WTS_APPSTYLE</b> flag and return a
    ///thumbnail that conforms to the Windows 8 UI guidelines.
    ///Params:
    ///    dwContext = Type: <b>WTS_CONTEXTFLAGS</b> One or more flags that specify the context. This value is based on the
    ///                WTS_FLAGS values that are received by the thumbnail provider through the call to
    ///                IThumbnailProvider::GetThumbnail.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetContext(WTS_CONTEXTFLAGS dwContext);
}

///Not supported.
@GUID("0F03F8FE-2B26-46F0-965A-212AA8D66B76")
interface IThumbnailCachePrimer : IUnknown
{
    ///Not supported.
    ///Params:
    ///    psi = 
    ///    wtsFlags = 
    ///    cxyRequestedThumbSize = 
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT PageInThumbnail(IShellItem psi, WTS_FLAGS wtsFlags, uint cxyRequestedThumbSize);
}

///Exposes methods that create IShellImageData instances based on various image sources.
@GUID("9BE8ED5C-EDAB-4D75-90F3-BD5BDBB21C82")
interface IShellImageDataFactory : IUnknown
{
    ///Creates an instance of the IShellImageData interface.
    ///Params:
    ///    ppshimg = Type: <b>IShellImageData**</b> The address of a pointer to an instance of IShellImageData.
    HRESULT CreateIShellImageData(IShellImageData* ppshimg);
    ///Creates an instance of the IShellImageData interface based on a given file.
    ///Params:
    ///    pszPath = Type: <b>LPCWSTR</b> The path of the file containing the image. If this parameter is <b>NULL</b>, an
    ///              unhandled exception results.
    ///    ppshimg = Type: <b>IShellImageData**</b> The address of a pointer to an instance of IShellImageData.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The internal object cannot be instantiated. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The internal
    ///    object does not support the IShellImageData or IPersistFile interfaces. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppshimg</i> parameter is <b>NULL</b>.
    ///    </td> </tr> </table>
    ///    
    HRESULT CreateImageFromFile(const(wchar)* pszPath, IShellImageData* ppshimg);
    ///Creates an instance of the IShellImageData interface based on a given file stream.
    ///Params:
    ///    pStream = Type: <b>IStream*</b> A pointer to the image stream.
    ///    ppshimg = Type: <b>IShellImageData**</b> The address of a pointer to an instance of IShellImageData.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The internal object cannot be instantiated. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The internal
    ///    object does not support the IShellImageData or IPersistFile interfaces. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppshimg</i> parameter is <b>NULL</b>.
    ///    </td> </tr> </table>
    ///    
    HRESULT CreateImageFromStream(IStream pStream, IShellImageData* ppshimg);
    ///Determines a file's format based on its extension.
    ///Params:
    ///    pszPath = Type: <b>LPCWSTR</b> A path to the file.
    ///    pDataFormat = Type: <b>GUID*</b> A pointer to a GUID identifying the image format of the file.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The <i>pszPath</i> parameter is <b>NULL</b>, the file
    ///    name extension does not correspond to any defined GDI+ decoder, or an internal error has occurred. In any of
    ///    these cases, <i>pDataFormat</i> is set to GUID_NULL. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The internal object cannot be instantiated. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetDataFormatFromPath(const(wchar)* pszPath, GUID* pDataFormat);
}

///<p class="CCE_Message">[This interface will eventually be unsupported. It is recommended that Windows GDI+ APIs be
///used in place of <b>IShellImageData</b> methods.] Exposes methods and properties that display, manipulate, and
///describe image data.
@GUID("BFDEEC12-8040-4403-A5EA-9E07DAFCF530")
interface IShellImageData : IUnknown
{
    ///Decodes the image file, setting state.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> One of the following flags.
    ///    cxDesired = Type: <b>ULONG</b> The desired horizontal size of the decoded image. This parameter is only used if the
    ///                <b>SHIMGDEC_THUMBNAIL</b> flag is set. If the <b>SHIMGDEC_DEFAULT</b> flag is set instead, this value is
    ///                ignored.
    ///    cyDesired = Type: <b>ULONG</b> The desired vertical size of the decoded image. This parameter is only used if the
    ///                <b>SHIMGDEC_THUMBNAIL</b> flag is set. If the <b>SHIMGDEC_DEFAULT</b> flag is set instead, this value is
    ///                ignored.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The file could not be loaded or the calling application
    ///    stopped the decode process through a call to a registered IShellImageDataAbort (see
    ///    IShellImageData::RegisterAbort for more information). </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The internal object cannot be instantiated. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The path used to
    ///    create this instance of IShellImageData was a URL. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The image has already been decoded. </td> </tr> </table>
    ///    
    HRESULT Decode(uint dwFlags, uint cxDesired, uint cyDesired);
    ///Draws a decoded image.
    ///Params:
    ///    hdc = Type: <b>HDC</b> The handle of the image.
    ///    prcDest = Type: <b>LPRECT</b> A pointer to a RECT, measured in pixels, that specifies the bounds of the rendered image.
    ///              The portion of the image specified by <i>prcSrc</i> is scaled to fill the rectangle specified by
    ///              <i>prcDest</i>.
    ///    prcSrc = Type: <b>LPRECT</b> A pointer to a RECT that specifies the portion of the image to be drawn.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful or an error value otherwise, including the following: <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> The image was not previously decoded, the call to IShellImageData::Decode failed, or
    ///    <i>hdc</i> is <b>NULL</b>. Other internal calls also can cause this error to be returned. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>prcDest</i> parameter
    ///    is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%">
    ///    The process was terminated by the calling application through a registered instance of IShellImageDataAbort.
    ///    </td> </tr> </table>
    ///    
    HRESULT Draw(HDC hdc, RECT* prcDest, RECT* prcSrc);
    ///Switches to the next frame of an animated image.
    HRESULT NextFrame();
    ///Switches to the next page of a multipage image. Any associated animations are reset.
    HRESULT NextPage();
    ///Switches to the previous page of a multipage image. Any associated animations are reset.
    HRESULT PrevPage();
    ///Determines whether the image is transparent.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns one of the following: <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The image has
    ///    transparency. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The
    ///    image does not have transparency. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The image has not been decoded. </td> </tr> </table>
    ///    
    HRESULT IsTransparent();
    ///Determines whether the image is animated.
    HRESULT IsAnimated();
    ///Determines whether the image is a vector image.
    HRESULT IsVector();
    ///Determines whether the image is a multipage Tagged Image File Format (TIFF) image.
    HRESULT IsMultipage();
    ///Determines whether the image can be edited.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns one of the following: <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The image can be edited.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The image cannot
    ///    be edited, the image has not been decoded, or the decoding process failed. </td> </tr> </table>
    ///    
    HRESULT IsEditable();
    ///Determines whether the image can be printed.
    HRESULT IsPrintable();
    ///Determines whether the image has been decoded by calling IShellImageData::Decode. Many operations return a
    ///failure code if the image is not first decoded.
    HRESULT IsDecoded();
    ///Gets the current page of a multipage image.
    ///Params:
    ///    pnPage = Type: <b>ULONG*</b> A pointer to the page number.
    HRESULT GetCurrentPage(uint* pnPage);
    ///Gets the number of pages in a multipage image.
    ///Params:
    ///    pcPages = Type: <b>ULONG*</b> A pointer to the page count. This value is valid only when the method returns S_OK.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful or an error value otherwise, including the following: <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> The image has not been decoded or the decoding process failed. </td> </tr> </table>
    ///    
    HRESULT GetPageCount(uint* pcPages);
    ///Selects a specified page in a multipage image.
    ///Params:
    ///    iPage = Type: <b>ULONG</b> The page number of the page to select.
    HRESULT SelectPage(uint iPage);
    ///Gets the dimensions of the image file.
    ///Params:
    ///    pSize = Type: <b>SIZE*</b> A pointer to a SIZE structure containing the size of the image. This value is valid only
    ///            when the method returns <b>S_OK</b>.
    HRESULT GetSize(SIZE* pSize);
    ///Retrieves a GUID that identifies the format of the image.
    ///Params:
    ///    pDataFormat = Type: <b>GUID*</b> A pointer to a value indicating the format. This value is valid only when the method
    ///                  returns S_OK.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful or an error value otherwise, including the following: <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> The image has not been decoded or the decoding process failed. </td> </tr> </table>
    ///    
    HRESULT GetRawDataFormat(GUID* pDataFormat);
    ///Gets the pixel format of the image.
    ///Params:
    ///    pFormat = Type: <b>PixelFormat*</b> A pointer to a value of type PixelFormat indicating the pixel format. This value is
    ///              valid only when the method returns <b>S_OK</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful or an error value otherwise, including the following:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The image has not been decoded or the decoding process
    ///    failed. </td> </tr> </table>
    ///    
    HRESULT GetPixelFormat(uint* pFormat);
    ///Gets the delay value for the current frame of an animation.
    ///Params:
    ///    pdwDelay = Type: <b>DWORD*</b> A pointer to the delay value, in milliseconds. This value is valid only when the method
    ///               returns S_OK.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful or an error value otherwise, including the following: <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> The image has not been decoded or the decoding process failed. </td> </tr> </table>
    ///    
    HRESULT GetDelay(uint* pdwDelay);
    ///Gets an IPropertySetStorage through which the properties of the image can be accessed.
    ///Params:
    ///    dwMode = Type: <b>DWORD</b> Not used, set to 0.
    ///    ppPropSet = Type: <b>IPropertySetStorage**</b> The address of a pointer to the IPropertySetStorage interface.
    HRESULT GetProperties(uint dwMode, IPropertySetStorage* ppPropSet);
    ///Rotates an image in increments of 90 degrees.
    ///Params:
    ///    dwAngle = Type: <b>DWORD</b> The angle of rotation. Only angles of 0, 90, 180, and 270 are recognized.
    HRESULT Rotate(uint dwAngle);
    ///Adjusts the size of an image.
    ///Params:
    ///    cx = Type: <b>ULONG</b> The horizontal (x) dimension. If this value is 0, the x dimension is set to a scaled value
    ///         based on the point specified in <i>cy</i>.
    ///    cy = Type: <b>ULONG</b> The vertical (y) dimension. If this value is 0, the y dimension is set to a scaled value
    ///         based on the point specified in <i>cx</i>.
    ///    hints = Type: <b>InterpolationMode</b> A member of the InterpolationMode enumeration, specifying the algorithm that
    ///            is used when the image is scaled.
    HRESULT Scale(uint cx, uint cy, uint hints);
    ///Discards edits made to an image.
    HRESULT DiscardEdit();
    ///Sets encoder parameters.
    ///Params:
    ///    pbagEnc = Type: <b>IPropertyBag*</b> A pointer to an IPropertyBag containing the encoder properties.
    ///Returns:
    ///    Type: <b>HRESULT</b> Always returns<b> S_OK</b>.
    ///    
    HRESULT SetEncoderParams(IPropertyBag pbagEnc);
    ///Gets the name of the file if IShellImageData was initialized on a file path. Otherwise, gets the name of the data
    ///stream.
    ///Params:
    ///    wszName = Type: <b>LPWSTR</b> A pointer to a buffer containing the display name as a Unicode string. On exit, the
    ///              contents of the buffer are only valid when the method returns S_OK.
    ///    cch = Type: <b>UINT</b> The size, in characters, of the buffer pointed to by <i>wszName</i>.
    HRESULT DisplayName(const(wchar)* wszName, uint cch);
    ///Gets the resolution, in dots per inch (dpi), of the image.
    ///Params:
    ///    puResolutionX = Type: <b>ULONG*</b> A pointer to the horizontal resolution.
    ///    puResolutionY = Type: <b>ULONG*</b> A pointer to the vertical resolution.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful or an error value otherwise, including the following: <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> The image has not been decoded, the decode process failed, or the resolution cannot be
    ///    retrieved. In the latter case, both <i>puResolutionX</i> and <i>puResolutionY</i> are set to 0. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Both
    ///    <i>puResolutionX</i> and <i>puResolutionY</i> are <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT GetResolution(uint* puResolutionX, uint* puResolutionY);
    ///Gets the current set of encoder parameters.
    ///Params:
    ///    pguidFmt = Type: <b>GUID*</b> A pointer to a GUID that specifies the encoder. This must be an encoder supported by GDI+.
    ///               If this parameter is <b>NULL</b>, an unhandled exception results.
    ///    ppEncParams = Type: <b>EncoderParameters**</b> The address of a pointer to an array of EncoderParameter objects.
    HRESULT GetEncoderParams(GUID* pguidFmt, ubyte** ppEncParams);
    ///Sets a callback abort object, optionally returning a pointer to the previous object.
    ///Params:
    ///    pAbort = Type: <b>IShellImageDataAbort*</b> A pointer to an abort object. If this parameter is <b>NULL</b>, an
    ///             unhandled exception results.
    ///    ppAbortPrev = Type: <b>IShellImageDataAbort**</b> The address of a pointer to the previous abort object. This parameter can
    ///                  be <b>NULL</b> if the previous object is not of interest.
    HRESULT RegisterAbort(IShellImageDataAbort pAbort, IShellImageDataAbort* ppAbortPrev);
    ///Retrieves a clone of the current image or frame.
    ///Params:
    ///    ppImg = Type: <b>Image**</b> The address that receives a pointer to the clone image. If this parameter is <b>NULL</b>
    ///            on entry, an unhandled exception results.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful or an error value otherwise, including the following: <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> The <i>ppImg</i> parameter is <b>NULL</b> on entry or the image cannot be cloned. In
    ///    the latter case, <i>ppImg</i> is set to <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT CloneFrame(ubyte** ppImg);
    ///Replaces the current frame with a new image.
    ///Params:
    ///    pImg = Type: <b>Image*</b> The address of the new image.
    ///Returns:
    ///    Type: <b>HRESULT</b> Always returns S_OK.
    ///    
    HRESULT ReplaceFrame(ubyte* pImg);
}

///Exposes a single method used to abort IShellImageData processes.
@GUID("53FB8E58-50C0-4003-B4AA-0C8DF28E7F3A")
interface IShellImageDataAbort : IUnknown
{
    ///Aborts an IShellImageData process such as Decode, Draw, or Scale. This is a callback method.
    HRESULT QueryAbort();
}

///Provides a collection of properties associated with a file or folder.
@GUID("301DFBE5-524C-4B0F-8B2D-21C40B3A2988")
interface IStorageProviderPropertyHandler : IUnknown
{
    ///Gets the properties managed by the sync engine.
    ///Params:
    ///    propertiesToRetrieve = The identifier for the properties to retrieve.
    ///    propertiesToRetrieveCount = The number of properties to retrieve.
    ///    retrievedProperties = A collection of properties.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RetrieveProperties(char* propertiesToRetrieve, uint propertiesToRetrieveCount, 
                               IPropertyStore* retrievedProperties);
    ///Saves properties associated with a file or folder.
    ///Params:
    ///    propertiesToSave = The properties to save.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SaveProperties(IPropertyStore propertiesToSave);
}

///Retrieves the IStorageProviderPropertyHandler associated with a specific file or folder.
@GUID("162C6FB5-44D3-435B-903D-E613FA093FB5")
interface IStorageProviderHandler : IUnknown
{
    ///Gets an instance of IStorageProviderPropertyHandler associated with the provided path.
    ///Params:
    ///    path = The path for the relevant file.
    ///    propertyHandler = An IStorageProviderPropertyHandler instance associated with the file specified by <i>path</i>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPropertyHandlerFromPath(const(wchar)* path, IStorageProviderPropertyHandler* propertyHandler);
    ///Gets an instance of IStorageProviderPropertyHandler associated with the provided URI.
    ///Params:
    ///    uri = The URI for the relevant file.
    ///    propertyHandler = An IStorageProviderPropertyHandler instance associated with the file specified by <i>uri</i>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPropertyHandlerFromUri(const(wchar)* uri, IStorageProviderPropertyHandler* propertyHandler);
    ///Gets an instance of IStorageProviderPropertyHandler associated with the provided file identifier.
    ///Params:
    ///    fileId = The identifier for the relevant file.
    ///    propertyHandler = An IStorageProviderPropertyHandler instance associated with the file specified by <i>fileId</i>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPropertyHandlerFromFileId(const(wchar)* fileId, IStorageProviderPropertyHandler* propertyHandler);
}

///Exposes methods that manage the synchronization process.
@GUID("6295DF41-35EE-11D1-8707-00C04FD93327")
interface ISyncMgrSynchronizeCallback : IUnknown
{
    ///Called by the registered application's handler before or after its ShowProperties operation is completed.
    ///Params:
    ///    hr = Type: <b>HRESULT</b> Whether the ShowProperties was successful.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Call
    ///    was completed successfully. </td> </tr> </table>
    ///    
    HRESULT ShowPropertiesCompleted(HRESULT hr);
    ///Called by a registered handler of an application after the PrepareForSync method is complete.
    ///Params:
    ///    hr = Type: <b>HRESULT</b> The return value of the PrepareForSync method. If S_OK is returned, the synchronization
    ///         manager calls Synchronize for the item. If the <b>HRESULT</b> is set to anything other than S_OK, the
    ///         synchronization manager releases the handler without calling the <b>Synchronize</b> method.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    call is completed successfully. </td> </tr> </table>
    ///    
    HRESULT PrepareForSyncCompleted(HRESULT hr);
    ///Called by an application when its Synchronize method is complete.
    ///Params:
    ///    hr = Type: <b>HRESULT</b> The returned result from the Synchronize method.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    call is completed successfully. </td> </tr> </table>
    ///    
    HRESULT SynchronizeCompleted(HRESULT hr);
    ///Called by the registered application's handler before or after its PrepareForSync operation has been completed.
    ///Params:
    ///    hr = Type: <b>HRESULT</b> Whether ShowError was successful. This value is S_SYNCMGR_RETRYSYNC if the registered
    ///         application's handler requires SyncMgr to retry the synchronization. When this value is returned to SyncMgr
    ///         both the PrepareForSync and Synchronize methods are called again.
    ///    cItems = Type: <b>ULONG</b> The number of items in the array pointed to by the <i>pItemIDs</i> parameter. This
    ///             parameter is ignored unless <i>hrResult</i> is S_SYNCMGR_RETRYSYNC.
    ///    pItemIDs = Type: <b>const GUID*</b> A pointer to the array of item IDs to pass to PrepareForSync in the event of a
    ///               retry. This parameter is ignored unless <i>hrResult</i> is S_SYNCMGR_RETRYSYNC.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    operation completed successfully. </td> </tr> </table>
    ///    
    HRESULT ShowErrorCompleted(HRESULT hr, uint cItems, char* pItemIDs);
    ///Called by the registered application before and after any dialog boxes are displayed from within the
    ///PrepareForSync and Synchronize methods.
    ///Params:
    ///    fEnable = Type: <b>BOOL</b> <b>TRUE</b> if the registered application is requesting permission to display a dialog box
    ///              or <b>FALSE</b> if the registered application has finished displaying a dialog box.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Continue the synchronization. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> The dialog box should not be displayed. </td> </tr> </table>
    ///    
    HRESULT EnableModeless(BOOL fEnable);
    ///Called by a registered application to update the progress information and determine whether an operation should
    ///continue.
    ///Params:
    ///    ItemID = Type: <b>REFGUID</b> A reference to the item identifier for an item that is being updated.
    ///    pSyncProgressItem = Type: <b>const SYNCMGRPROGRESSITEM*</b> A pointer to a SYNCMGRPROGRESSITEM structure that contains the
    ///                        updated progress information.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Continues the synchronization. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_SYNCMGR_CANCELITEM</b></dt>
    ///    </dl> </td> <td width="60%"> Cancels the synchronization on a specified item, as soon as possible. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_SYNCMGR_CANCELALL</b></dt> </dl> </td> <td width="60%"> Cancels the
    ///    synchronization on all items that are associated with this application, as soon as possible. </td> </tr>
    ///    </table>
    ///    
    HRESULT Progress(const(GUID)* ItemID, const(SYNCMGRPROGRESSITEM)* pSyncProgressItem);
    ///Called by a registered application to log information, warning, or an error message into the error tab on the
    ///synchronization manager status dialog box.
    ///Params:
    ///    dwErrorLevel = Type: <b>DWORD</b> The error level. Values are taken from the SYNCMGRLOGLEVEL enumeration.
    ///    pszErrorText = Type: <b>LPCWSTR</b> A pointer to error text to be displayed in the error tab.
    ///    pSyncLogError = Type: <b>const SYNCMGRLOGERRORINFO*</b> A pointer to the SYNCMGRLOGERRORINFO structure that contains
    ///                    additional error information. Registered applications that do not provide this data can pass <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, and the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The error information is logged
    ///    successfully. </td> </tr> </table>
    ///    
    HRESULT LogError(uint dwErrorLevel, const(wchar)* pszErrorText, const(SYNCMGRLOGERRORINFO)* pSyncLogError);
    ///Called by the registered application's handler to delete a previously logged ErrorInformation, warning, or error
    ///message in the error tab on the synchronization manager status dialog box.
    ///Params:
    ///    ErrorID = Type: <b>REFGUID</b> The LogError to be deleted. If <i>ErrorID</i> is GUID_NULL all errors logged by the
    ///              instance of the registered application's handler will be deleted.
    ///    dwReserved = Type: <b>DWORD</b>
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, as well as the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The item was successfully deleted
    ///    from the log. </td> </tr> </table>
    ///    
    HRESULT DeleteLogError(const(GUID)* ErrorID, uint dwReserved);
    ///Called by the registered application's handler when a network connection is required.
    ///Params:
    ///    pwszConnection = Type: <b>LPCWSTR</b> The name of the connection to dial.
    ///    dwReserved = Type: <b>DWORD</b>
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, as well as the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The connection was successfully
    ///    established. </td> </tr> </table>
    ///    
    HRESULT EstablishConnection(const(wchar)* pwszConnection, uint dwReserved);
}

///Exposes methods that enumerate through an array of SYNCMGRITEM structures. Each of these structures provides
///information about an item that can be synchronized. <b>ISyncMgrEnumItems</b> has the same methods as all standard
///enumerator interfaces: Next, Skip, Reset, and Clone.
@GUID("6295DF2A-35EE-11D1-8707-00C04FD93327")
interface ISyncMgrEnumItems : IUnknown
{
    ///Enumerates the next <i>celt</i> elements in the enumerator's list, returning them in <i>rgelt</i> along with the
    ///actual number of enumerated elements in <i>pceltFetched</i>.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of items in the array.
    ///    rgelt = Type: <b>SYNCMGRITEM*</b> The address of array containing items.
    ///    pceltFetched = Type: <b>ULONG*</b> The address of variable containing actual number of items.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if the method succeeds.
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Instructs the enumerator to skip the next <i>celt</i> elements in the enumeration so that the next call to
    ///ISyncMgrEnumItems::Next does not return those elements.
    ///Params:
    ///    celt = Type: <b>ULONG</b> The number of items to skip.
    HRESULT Skip(uint celt);
    ///Instructs the enumerator to position itself at the beginning of the list of elements.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if the method succeeds.
    ///    
    HRESULT Reset();
    ///Creates another items enumerator with the same state as the current enumerator to iterate over the same list.
    ///This method makes it possible to record a point in the enumeration sequence in order to return to that point at a
    ///later time.
    ///Params:
    ///    ppenum = Type: <b>ppenum**</b> The address of a variable that receives the ISyncMgrEnumItems interface pointer.
    ///Returns:
    ///    Type: <b>HRESULT</b> Return S_OK if the method succeeds.
    ///    
    HRESULT Clone(ISyncMgrEnumItems* ppenum);
}

///Exposes methods that enable the registered application or service to receive notifications from the synchronization
///manager.
@GUID("6295DF40-35EE-11D1-8707-00C04FD93327")
interface ISyncMgrSynchronize : IUnknown
{
    ///Called by the synchronization manager in a registered application handler to determine whether the handler
    ///processes the synchronization event.
    ///Params:
    ///    dwReserved = Type: <b>DWORD</b> Reserved; must be 0 (zero).
    ///    dwSyncMgrFlags = Type: <b>DWORD</b> The SYNCMGRFLAG enumeration values that describe how a synchronization event is initiated.
    ///    cbCookie = Type: <b>DWORD</b> The size of the <i>lpCookie</i> data, in bytes.
    ///    lpCookie = Type: <b>BYTE const*</b> A pointer to the token that identifies an application. This token is passed when an
    ///               application invokes the synchronization manager programmatically.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, and the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Initialization is successful. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Application handler does not
    ///    process a synchronization event. </td> </tr> </table>
    ///    
    HRESULT Initialize(uint dwReserved, uint dwSyncMgrFlags, uint cbCookie, char* lpCookie);
    ///Obtains handler information.
    ///Params:
    ///    ppSyncMgrHandlerInfo = Type: <b>SYNCMGRHANDLERINFO**</b> A pointer to a SYNCMGRHANDLERINFO structure.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, and the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Handler information is returned
    ///    successfully. </td> </tr> </table>
    ///    
    HRESULT GetHandlerInfo(SYNCMGRHANDLERINFO** ppSyncMgrHandlerInfo);
    ///Obtains the ISyncMgrEnumItems interface for the items that are handled by a registered application.
    ///Params:
    ///    ppSyncMgrEnumItems = Type: <b>ISyncMgrEnumItems**</b> The address of the variable that receives a pointer to a valid
    ///                         ISyncMgrEnumItems interface.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, and the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The enumeration interface is returned
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_SYNCMGR_MISSINGITEMS</b></dt> </dl> </td> <td
    ///    width="60%"> The enumeration interface object is returned successfully, but some items are missing. When this
    ///    success code is returned, the synchronization manager does not remove any stored preferences for ItemIds that
    ///    are not returned in the enumerator. </td> </tr> </table>
    ///    
    HRESULT EnumSyncMgrItems(ISyncMgrEnumItems* ppSyncMgrEnumItems);
    ///Obtains an interface on a specified item that a registered application handles.
    ///Params:
    ///    ItemID = Type: <b>REFGUID</b> An identifier for a requested item.
    ///    riid = Type: <b>REFIID</b> An identifier for a requested interface.
    ///    ppv = Type: <b>void**</b> An address of a variable that receives a pointer to a requested interface.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%">
    ///    The requested interface is not found. </td> </tr> </table>
    ///    
    HRESULT GetItemObject(const(GUID)* ItemID, const(GUID)* riid, void** ppv);
    ///Called by the synchronization manager when a user selects an item in the choice dialog box, and then clicks the
    ///<b>Properties</b> button.
    ///Params:
    ///    hWndParent = Type: <b>HWND</b> The parent <b>HWND</b> for any user interface that a registered application displays to set
    ///                 properties. This value can be <b>NULL</b>.
    ///    ItemID = Type: <b>REFGUID</b> The item ID for properties that are requested.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, and the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The properties dialog for an item is
    ///    handled successfully. </td> </tr> </table>
    ///    
    HRESULT ShowProperties(HWND hWndParent, const(GUID)* ItemID);
    ///Sets the ISyncMgrSynchronizeCallback interface. Registered applications use this callback interface to give
    ///status information from within the ISyncMgrSynchronize::PrepareForSync and ISyncMgrSynchronize::Synchronize
    ///methods.
    ///Params:
    ///    lpCallBack = Type: <b>ISyncMgrSynchronizeCallback*</b> A pointer to ISyncMgrSynchronizeCallback interface the registered
    ///                 application uses to provide feedback to SyncMgr about the synchronization status and to notify SyncMgr when
    ///                 the synchronization is complete.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values, E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, as well as the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Synchronization callback interface
    ///    was successfully set. </td> </tr> </table>
    ///    
    HRESULT SetProgressCallback(ISyncMgrSynchronizeCallback lpCallBack);
    ///Allows a registered application to display any user interface, and perform any necessary initialization before
    ///the ISyncMgrSynchronize::Synchronize method is called. For example, an application such as the Microsoft Outlook
    ///email client may need to display the password dialog box to enable a user to log on to a mail server.
    ///Params:
    ///    cbNumItems = Type: <b>ULONG</b> The number of items in the array pointed to by <i>pItemIDs</i>.
    ///    pItemIDs = Type: <b>GUID*</b> An array of item IDs that a user chooses to synchronize.
    ///    hWndParent = Type: <b>HWND</b> A handle to the parent <b>HWND</b> that a registered application should use for any user
    ///                 interface element displayed. This value may be <b>NULL</b>.
    ///    dwReserved = Type: <b>DWORD</b> Reserved. Registered applications should ignore this value.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, and the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Preparation is successful. </td> </tr>
    ///    </table>
    ///    
    HRESULT PrepareForSync(uint cbNumItems, char* pItemIDs, HWND hWndParent, uint dwReserved);
    ///Called by the synchronization manager once for each selected group after the user has chosen the registered
    ///applications to be synchronized.
    ///Params:
    ///    hWndParent = Type: <b>HWND</b> A handle to the parent <b>HWND</b> the registered application should use for any user
    ///                 interface elements that it displays. This value may be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values, E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, as well as the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Synchronization was successful. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Synchronization failed.
    ///    </td> </tr> </table>
    ///    
    HRESULT Synchronize(HWND hWndParent);
    ///Called by the synchronization manager in a registered application's handler to change the status of an item in
    ///the following two cases: between the time the handler has returned from the ISyncMgrSynchronize::PrepareForSync
    ///method and called the PrepareForSyncCompleted callback method, or after the handler has returned from the
    ///ISyncMgrSynchronize::Synchronize method but has not yet called the SynchronizeCompleted callback method.
    ///Params:
    ///    pItemID = Type: <b>REFGUID</b> Identifies the item with changed status.
    ///    dwSyncMgrStatus = Type: <b>DWORD</b> The new status for the specified item taken from the SYNCMGRSTATUS enumeration.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values, E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, as well as the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Status was set. </td> </tr> </table>
    ///    
    HRESULT SetItemStatus(const(GUID)* pItemID, uint dwSyncMgrStatus);
    ///Called by the synchronization manager in a registered application handler when a user double-clicks an associated
    ///message in the error tab.
    ///Params:
    ///    hWndParent = Type: <b>HWND</b> A handle to the parent <b>HWND</b> that a registered application should use to display a
    ///                 user interface. This value can be <b>NULL</b>.
    ///    ErrorID = Type: <b>REFGUID</b> An error identifier that is associated with this error message. This value is passed in
    ///              the LogError method.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, and the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The call is completed successfully. </td>
    ///    </tr> </table>
    ///    
    HRESULT ShowError(HWND hWndParent, const(GUID)* ErrorID);
}

///Exposes methods that enable a registered application to invoke the synchronization manager to update items.
@GUID("6295DF2C-35EE-11D1-8707-00C04FD93327")
interface ISyncMgrSynchronizeInvoke : IUnknown
{
    ///Programmatically starts an update for specified items.
    ///Params:
    ///    dwInvokeFlags = Type: <b>DWORD</b> Specifies how an item should be invoked using the SYNCMGRINVOKEFLAGS enumeration values.
    ///    clsid = Type: <b>REFCLSID</b> The CLSID of a registered application to be invoked for an update.
    ///    cbCookie = Type: <b>DWORD</b> The size of <i>pCookie</i> data, in bytes.
    ///    pCookie = Type: <b>const BYTE*</b> A pointer to a private token that identifies an application. The token is passed in
    ///              the Initialize method.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values E_INVALIDARG, E_UNEXPECTED and
    ///    E_OUTOFMEMORY, and the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The synchronization is successfully
    ///    updated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The
    ///    errors occur during a synchronization update. </td> </tr> </table>
    ///    
    HRESULT UpdateItems(uint dwInvokeFlags, const(GUID)* clsid, uint cbCookie, char* pCookie);
    ///Programmatically starts an update for all items.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method can return one of these values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Call
    ///    was completed successfully. </td> </tr> </table>
    ///    
    HRESULT UpdateAll();
}

///Exposes methods so that an application can register with the synchronization manager. This can be achieved either
///through the <b>ISyncMgrRegister</b> interface or by registering directly in the registry.
@GUID("6295DF42-35EE-11D1-8707-00C04FD93327")
interface ISyncMgrRegister : IUnknown
{
    ///Registers a handler with the synchronization manager when the handler has items to synchronize.
    ///Params:
    ///    clsidHandler = Type: <b>REFCLSID</b> The CLSID of the handler that should be registered to do synchronizations.
    ///    pwszDescription = Type: <b>LPCWSTR</b> Text identifying the handler. This parameter may be <b>NULL</b>.
    ///    dwSyncMgrRegisterFlags = Type: <b>DWORD</b>
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, as well as the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The handler was successfully
    ///    registered. </td> </tr> </table>
    ///    
    HRESULT RegisterSyncMgrHandler(const(GUID)* clsidHandler, const(wchar)* pwszDescription, 
                                   uint dwSyncMgrRegisterFlags);
    ///Removes a handler's class identifier (CLSID) from the registration. A handler should call this when it no longer
    ///has any items to synchronize.
    ///Params:
    ///    clsidHandler = Type: <b>REFCLSID</b> The CLSID of the handler that should be unregistered.
    ///    dwReserved = Type: <b>DWORD</b>
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, as well as the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The handler was successfully removed
    ///    from the registry with SyncMgr. </td> </tr> </table>
    ///    
    HRESULT UnregisterSyncMgrHandler(const(GUID)* clsidHandler, uint dwReserved);
    ///Called by the registered application's handler to get current registration information.
    ///Params:
    ///    clsidHandler = Type: <b>REFCLSID</b> The CLSID of the handler.
    ///    pdwSyncMgrRegisterFlags = Type: <b>LPDWORD</b> Returns registration flags from the SYNCMGRREGISTERFLAGS enumeration that indicate
    ///                              events for which the handler is registered to be notified.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method supports the standard return values E_INVALIDARG, E_UNEXPECTED, and
    ///    E_OUTOFMEMORY, as well as the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Call was successful, the handler is
    ///    registered. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Call
    ///    was not successful, the handler is not registered. </td> </tr> </table>
    ///    
    HRESULT GetHandlerRegistrationInfo(const(GUID)* clsidHandler, uint* pdwSyncMgrRegisterFlags);
}

///Gets or sets the thumbnail stream. This interface is for internal use only and can only be called by the photos
///application.
@GUID("90E11430-9569-41D8-AE75-6D4D2AE7CCA0")
interface IThumbnailStreamCache : IUnknown
{
    ///Gets the thumbnail stream. This method is for internal use only and can only be called by the photos application.
    ///Params:
    ///    path = The path to the thumbnail.
    ///    cacheId = The identifier of the thumbnail.
    ///    options = The cache options for the thumbnail stream.
    ///    requestedThumbnailSize = The requested size of the thumbnail.
    ///    thumbnailSize = The actual size of the returned thumbnail.
    ///    thumbnailStream = The requested thumbnail.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetThumbnailStream(const(wchar)* path, ulong cacheId, ThumbnailStreamCacheOptions options, 
                               uint requestedThumbnailSize, SIZE* thumbnailSize, IStream* thumbnailStream);
    ///Sets the thumbnail stream. This method is for internal use only and can only be called by the photos application.
    ///Params:
    ///    path = The path to the thumbnail.
    ///    cacheId = The identifier of the thumbnail.
    ///    thumbnailSize = The size of the thumbnail.
    ///    thumbnailStream = The pointer to the thumbnail stream.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetThumbnailStream(const(wchar)* path, ulong cacheId, SIZE thumbnailSize, IStream thumbnailStream);
}

@GUID("7EBFDD87-AD18-11D3-A4C5-00C04F72D6B8")
interface ITravelLogEntry : IUnknown
{
    HRESULT GetTitle(ushort** ppszTitle);
    HRESULT GetURL(ushort** ppszURL);
}

@GUID("241C033E-E659-43DA-AA4D-4086DBC4758D")
interface ITravelLogClient : IUnknown
{
    HRESULT FindWindowByIndex(uint dwID, IUnknown* ppunk);
    HRESULT GetWindowData(IStream pStream, WINDOWDATA* pWinData);
    HRESULT LoadHistoryPosition(const(wchar)* pszUrlLocation, uint dwPosition);
}

@GUID("7EBFDD85-AD18-11D3-A4C5-00C04F72D6B8")
interface IEnumTravelLogEntry : IUnknown
{
    HRESULT Next(uint cElt, char* rgElt, uint* pcEltFetched);
    HRESULT Skip(uint cElt);
    HRESULT Reset();
    HRESULT Clone(IEnumTravelLogEntry* ppEnum);
}

@GUID("7EBFDD80-AD18-11D3-A4C5-00C04F72D6B8")
interface ITravelLogStg : IUnknown
{
    HRESULT CreateEntry(const(wchar)* pszUrl, const(wchar)* pszTitle, ITravelLogEntry ptleRelativeTo, 
                        BOOL fPrepend, ITravelLogEntry* pptle);
    HRESULT TravelTo(ITravelLogEntry ptle);
    HRESULT EnumEntries(uint flags, IEnumTravelLogEntry* ppenum);
    HRESULT FindEntries(uint flags, const(wchar)* pszUrl, IEnumTravelLogEntry* ppenum);
    HRESULT GetCount(uint flags, uint* pcEntries);
    HRESULT RemoveEntry(ITravelLogEntry ptle);
    HRESULT GetRelativeEntry(int iOffset, ITravelLogEntry* ptle);
}

@GUID("79EAC9C3-BAF9-11CE-8C82-00AA004BA90B")
interface IHlink : IUnknown
{
    HRESULT SetHlinkSite(IHlinkSite pihlSite, uint dwSiteData);
    HRESULT GetHlinkSite(IHlinkSite* ppihlSite, uint* pdwSiteData);
    HRESULT SetMonikerReference(uint grfHLSETF, IMoniker pimkTarget, const(wchar)* pwzLocation);
    HRESULT GetMonikerReference(uint dwWhichRef, IMoniker* ppimkTarget, ushort** ppwzLocation);
    HRESULT SetStringReference(uint grfHLSETF, const(wchar)* pwzTarget, const(wchar)* pwzLocation);
    HRESULT GetStringReference(uint dwWhichRef, ushort** ppwzTarget, ushort** ppwzLocation);
    HRESULT SetFriendlyName(const(wchar)* pwzFriendlyName);
    HRESULT GetFriendlyName(uint grfHLFNAMEF, ushort** ppwzFriendlyName);
    HRESULT SetTargetFrameName(const(wchar)* pwzTargetFrameName);
    HRESULT GetTargetFrameName(ushort** ppwzTargetFrameName);
    HRESULT GetMiscStatus(uint* pdwStatus);
    HRESULT Navigate(uint grfHLNF, IBindCtx pibc, IBindStatusCallback pibsc, IHlinkBrowseContext pihlbc);
    HRESULT SetAdditionalParams(const(wchar)* pwzAdditionalParams);
    HRESULT GetAdditionalParams(ushort** ppwzAdditionalParams);
}

@GUID("79EAC9C2-BAF9-11CE-8C82-00AA004BA90B")
interface IHlinkSite : IUnknown
{
    HRESULT QueryService(uint dwSiteData, const(GUID)* guidService, const(GUID)* riid, IUnknown* ppiunk);
    HRESULT GetMoniker(uint dwSiteData, uint dwAssign, uint dwWhich, IMoniker* ppimk);
    HRESULT ReadyToNavigate(uint dwSiteData, uint dwReserved);
    HRESULT OnNavigationComplete(uint dwSiteData, uint dwreserved, HRESULT hrError, const(wchar)* pwzError);
}

@GUID("79EAC9C4-BAF9-11CE-8C82-00AA004BA90B")
interface IHlinkTarget : IUnknown
{
    HRESULT SetBrowseContext(IHlinkBrowseContext pihlbc);
    HRESULT GetBrowseContext(IHlinkBrowseContext* ppihlbc);
    HRESULT Navigate(uint grfHLNF, const(wchar)* pwzJumpLocation);
    HRESULT GetMoniker(const(wchar)* pwzLocation, uint dwAssign, IMoniker* ppimkLocation);
    HRESULT GetFriendlyName(const(wchar)* pwzLocation, ushort** ppwzFriendlyName);
}

@GUID("79EAC9C5-BAF9-11CE-8C82-00AA004BA90B")
interface IHlinkFrame : IUnknown
{
    HRESULT SetBrowseContext(IHlinkBrowseContext pihlbc);
    HRESULT GetBrowseContext(IHlinkBrowseContext* ppihlbc);
    HRESULT Navigate(uint grfHLNF, IBindCtx pbc, IBindStatusCallback pibsc, IHlink pihlNavigate);
    HRESULT OnNavigate(uint grfHLNF, IMoniker pimkTarget, const(wchar)* pwzLocation, const(wchar)* pwzFriendlyName, 
                       uint dwreserved);
    HRESULT UpdateHlink(uint uHLID, IMoniker pimkTarget, const(wchar)* pwzLocation, const(wchar)* pwzFriendlyName);
}

@GUID("79EAC9C6-BAF9-11CE-8C82-00AA004BA90B")
interface IEnumHLITEM : IUnknown
{
    HRESULT Next(uint celt, HLITEM* rgelt, uint* pceltFetched);
    HRESULT Skip(uint celt);
    HRESULT Reset();
    HRESULT Clone(IEnumHLITEM* ppienumhlitem);
}

@GUID("79EAC9C7-BAF9-11CE-8C82-00AA004BA90B")
interface IHlinkBrowseContext : IUnknown
{
    HRESULT Register(uint reserved, IUnknown piunk, IMoniker pimk, uint* pdwRegister);
    HRESULT GetObjectA(IMoniker pimk, BOOL fBindIfRootRegistered, IUnknown* ppiunk);
    HRESULT Revoke(uint dwRegister);
    HRESULT SetBrowseWindowInfo(HLBWINFO* phlbwi);
    HRESULT GetBrowseWindowInfo(HLBWINFO* phlbwi);
    HRESULT SetInitialHlink(IMoniker pimkTarget, const(wchar)* pwzLocation, const(wchar)* pwzFriendlyName);
    HRESULT OnNavigateHlink(uint grfHLNF, IMoniker pimkTarget, const(wchar)* pwzLocation, 
                            const(wchar)* pwzFriendlyName, uint* puHLID);
    HRESULT UpdateHlink(uint uHLID, IMoniker pimkTarget, const(wchar)* pwzLocation, const(wchar)* pwzFriendlyName);
    HRESULT EnumNavigationStack(uint dwReserved, uint grfHLFNAMEF, IEnumHLITEM* ppienumhlitem);
    HRESULT QueryHlink(uint grfHLQF, uint uHLID);
    HRESULT GetHlink(uint uHLID, IHlink* ppihl);
    HRESULT SetCurrentHlink(uint uHLID);
    HRESULT Clone(IUnknown piunkOuter, const(GUID)* riid, IUnknown* ppiunkObj);
    HRESULT Close(uint reserved);
}

@GUID("79EAC9CB-BAF9-11CE-8C82-00AA004BA90B")
interface IExtensionServices : IUnknown
{
    HRESULT SetAdditionalHeaders(const(wchar)* pwzAdditionalHeaders);
    HRESULT SetAuthenticateData(HWND phwnd, const(wchar)* pwzUsername, const(wchar)* pwzPassword);
}

///Deprecated. Exposes methods to identify, invoke, and update an individual item in the browser's travel history.
@GUID("F46EDB3B-BC2F-11D0-9412-00AA00A3EBD3")
interface ITravelEntry : IUnknown
{
    ///Deprecated. Invokes the travel entry, navigating to that page.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> The IUnknown representing the browser or frame within which the travel operation
    ///           generating the entry is taking place.
    HRESULT Invoke(IUnknown punk);
    ///Deprecated. Updates the travel entry.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> The IUnknown representing the browser or frame within which the travel operation
    ///           generating the entry is taking place.
    ///    fIsLocalAnchor = Type: <b>BOOL</b> The value specifying whether the new entry is a local anchor.
    HRESULT Update(IUnknown punk, BOOL fIsLocalAnchor);
    ///Deprecated. Gets the pointer to an item identifier list (PIDL) associated with the travel entry.
    ///Params:
    ///    ppidl = Type: <b>LPITEMIDLIST*</b> The travel entry's PIDL.
    HRESULT GetPidl(ITEMIDLIST** ppidl);
}

///<p class="CCE_Message">[ITravelEntry may not be supported in versions of Windows later than Windows XP.] Deprecated.
///Exposes methods that maintain and manipulate a record of travel in the browser.
@GUID("66A9CB08-4802-11D2-A561-00A0C92DBFE8")
interface ITravelLog : IUnknown
{
    ///Deprecated. Adds a new entry for a pending navigation to the travel log.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to an IUnknown representing the nearest browser or frame within which the
    ///           travel generating the log is taking place.
    ///    fIsLocalAnchor = Type: <b>BOOL</b> A value specifying whether the new entry is a local anchor.
    HRESULT AddEntry(IUnknown punk, BOOL fIsLocalAnchor);
    ///Deprecated. Saves the browser state of the current entry in preparation for a pending navigation.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to an IUnknown that represents the nearest browser or frame within which the
    ///           travel generating the log is taking place.
    ///    fIsLocalAnchor = Type: <b>BOOL</b> A value specifying whether the new entry is a local anchor.
    HRESULT UpdateEntry(IUnknown punk, BOOL fIsLocalAnchor);
    ///Deprecated. Updates an entry that originated out of the current procedure through IHlinkFrame.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to an IUnknown representing the nearest browser or frame within which the
    ///           travel generating the log is taking place.
    ///    punkHLBrowseContext = Type: <b>IUnknown*</b> A pointer to the IUnknown of an IHlinkBrowseContext retrieved through
    ///                          IHlinkFrame::GetBrowseContext.
    HRESULT UpdateExternal(IUnknown punk, IUnknown punkHLBrowseContext);
    ///Deprecated. Navigates to a travel entry in the travel log relative to the position of the current entry.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to an IUnknown that represents the nearest browser or frame within which the
    ///           travel generating the log is taking place.
    ///    iOffset = Type: <b>int</b> The number of travel entries forward (a positive value) or backward (a negative value) to
    ///              move in the travel log.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Travel(IUnknown punk, int iOffset);
    ///Deprecated. Gets a travel entry in the travel log relative to the position of the current entry.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to an IUnknown representing the nearest browser or frame within which the
    ///           travel generating the log is taking place.
    ///    iOffset = Type: <b>int</b> The number of travel entries forward (a positive value) or backward (a negative value) to
    ///              move in the travel log.
    ///    ppte = Type: <b>ITravelEntry**</b> The address of a pointer to the ITravelEntry interface representing the travel
    ///           entry at the offset specified in <i>iOffset</i>. This value is only valid if the method returns successfully.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTravelEntry(IUnknown punk, int iOffset, ITravelEntry* ppte);
    ///Deprecated. Determines whether a specific travel entry is present in the travel log.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to an IUnknown representing the nearest browser or frame within which the
    ///           travel generating the log is taking place.
    ///    pidl = Type: <b>LPCITEMIDLIST</b> A PIDL of the travel entry, typically obtained through GetPidl.
    ///    ppte = Type: <b>ITravelEntry**</b> The address of a pointer to the ITravelEntry interface representing the travel
    ///           entry, if found.
    HRESULT FindTravelEntry(IUnknown punk, ITEMIDLIST* pidl, ITravelEntry* ppte);
    ///Deprecated. Gets tooltip text for a travel entry, which is used as a Unicode display string in the UI.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to an IUnknown representing the nearest browser or frame within which the
    ///           travel generating the log is taking place.
    ///    iOffset = Type: <b>int</b> The number of travel entries forward (a positive value) or backward (a negative value) to
    ///              move in the travel log to arrive at the travel entry from which text should be retrieved.
    ///    idsTemplate = Type: <b>int</b> Not used.
    ///    pwzText = Type: <b>LPWSTR</b> A pointer to a buffer that receives the Unicode tooltip text string.
    ///    cchText = Type: <b>DWORD</b> The number of characters in the buffer pointed to by <i>pwzText</i>.
    HRESULT GetToolTipText(IUnknown punk, int iOffset, int idsTemplate, const(wchar)* pwzText, uint cchText);
    ///Deprecated. Inserts entries into the specified menu.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to an IUnknown representing the nearest browser or frame within which the
    ///           travel generating the log is taking place.
    ///    hmenu = Type: <b>HMENU</b> The handle of the menu.
    ///    nPos = Type: <b>int</b> The position in the menu to insert the entries.
    ///    idFirst = Type: <b>int</b> The ID of the first entry to be inserted.
    ///    idLast = Type: <b>int</b> The ID of the last entry to be inserted. The difference between <i>idFirst</i> and
    ///             <i>idLast</i> is the maximum number of entries that can be inserted into the menu.
    ///    dwFlags = Type: <b>DWORD</b> The types of entries to add to the menu. Includes the following:
    HRESULT InsertMenuEntries(IUnknown punk, HMENU hmenu, int nPos, int idFirst, int idLast, uint dwFlags);
    ///Deprecated. Duplicates the contents of the current travel log.
    ///Params:
    ///    pptl = Type: <b>ITravelLog**</b> The address of a pointer to the interface representing the cloned travel log.
    HRESULT Clone(ITravelLog* pptl);
    ///Deprecated. Generates the number of entries in the travel log.
    ///Params:
    ///    punk = Type: <b>IUnknown*</b> A pointer to an IUnknown representing the nearest browser or frame within which the
    ///           travel generating the log is taking place.
    uint    CountEntries(IUnknown punk);
    ///Deprecated. Reverts to the current entry, dropping the result of ITravelLog::AddEntry in the case of a failed
    ///navigation.
    HRESULT Revert();
}

interface CIE4ConnectionPoint : IConnectionPoint
{
    HRESULT DoInvokeIE4(int* pf, void** ppv, int dispid, DISPPARAMS* pdispparams);
    HRESULT DoInvokePIDLIE4(int dispid, ITEMIDLIST* pidl, BOOL fCanCancel);
}

///Deprecated. Exposes methods that allow the retrieval of properties, translation of keyboard accelerators, and
///determination of a connection point for certain events.
@GUID("2F0DD58C-F789-4F14-99FB-9293B3C9C212")
interface IExpDispSupportXP : IUnknown
{
    ///Deprecated. Gets a connection point for browser events.
    ///Params:
    ///    riid = Type: <b>REFIID</b> Specifies an interface ID.
    ///    ppccp = Type: <b>CIE4ConnectionPoint**</b> Receives the address of pointer to connection point.
    HRESULT FindCIE4ConnectionPoint(const(GUID)* riid, CIE4ConnectionPoint* ppccp);
    ///Not implemented.
    ///Params:
    ///    pMsg = Type: <b>MSG*</b> Specifies a pointer to the MSG structure describing the keystroke to be processed.
    ///    grfModifiers = Type: <b>DWORD</b> Specifies the flags describing the state of the Control, Alt, and Shift keys. The value of
    ///                   the flag can be any valid KEYMODIFIERS enumeration values.
    HRESULT OnTranslateAccelerator(MSG* pMsg, uint grfModifiers);
    ///Not implemented.
    ///Params:
    ///    dispidMember = Type: <b>DISPID</b> Specifies a dispatch ID that identifies the member being invoked.
    ///    iid = Type: <b>REFIID</b> Reserved. Must be IID_NULL.
    ///    lcid = Type: <b>LCID</b> Specifies a locale ID providing a locale context in which to interpret arguments.
    ///           Applications that do not support multiple national languages can ignore this parameter.
    ///    wFlags = Type: <b>WORD</b> Specifies flags describing the context of the call.
    ///    pdispparams = Type: <b>DISPPARAMS*</b> Specifies a pointer to a DISPPARAMS structure containing an array of arguments, an
    ///                  array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.
    ///    pVarResult = Type: <b>VARIANT*</b> Receives a pointer to the location where the result is to be stored, or <b>NULL</b> if
    ///                 the calling application expects no result. This argument is ignored if DISPATCH_PROPERTYPUT or
    ///                 DISPATCH_PROPERTYPUTREF is specified.
    ///    pexcepinfo = Type: <b>EXCEPINFO*</b> Receives a pointer to a structure that contains exception information. This structure
    ///                 should be filled in if DISP_E_EXCEPTION is returned. Can be <b>NULL</b>.
    ///    puArgErr = Type: <b>UINT*</b> Receives the index within the <b>rgvarg</b> member of the DISPPARAMS structure of the
    ///               first argument that has an error.
    HRESULT OnInvoke(int dispidMember, const(GUID)* iid, uint lcid, ushort wFlags, DISPPARAMS* pdispparams, 
                     VARIANT* pVarResult, EXCEPINFO* pexcepinfo, uint* puArgErr);
}

///Deprecated. Exposes methods that allow the retrieval of properties, translation of keyboard accelerators, and
///determination of a connection point for certain events.
@GUID("0D7D1D00-6FC0-11D0-A974-00C04FD705A2")
interface IExpDispSupport : IUnknown
{
    ///Deprecated. Gets connection points for browser events.
    ///Params:
    ///    riid = Type: <b>REFIID</b> The IID of the interface on the connection point container whose connection point object
    ///           is being requested. One of the following values.
    ///    ppccp = Type: <b>CIE4ConnectionPoint**</b> The address of a pointer to the browser connection point.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT FindConnectionPoint(const(GUID)* riid, IConnectionPoint* ppccp);
    ///Deprecated. Instructs the control site to process the keystroke described in <i>pMsg</i> and modified by the
    ///flags in <i>grfModifiers</i>.
    ///Params:
    ///    pMsg = Type: <b>MSG*</b> A pointer to an MSG structure that describes the keystroke to be processed.
    ///    grfModifiers = Type: <b>DWORD</b> Flags describing the state of the CTRL, ALT, and SHIFT keys. The value of the flags can be
    ///                   any valid KEYMODIFIERS enumeration value or values.
    HRESULT OnTranslateAccelerator(MSG* pMsg, uint grfModifiers);
    ///Deprecated. Gets ambient properties.
    ///Params:
    ///    dispidMember = Type: <b>DISPID</b> A dispatch ID that identifies the member being invoked.
    ///    iid = Type: <b>REFIID</b> Reserved. Must be IID_NULL.
    ///    lcid = Type: <b>LCID</b> A locale ID providing a locale context in which to interpret arguments. Applications that
    ///           do not support multiple languages can ignore this parameter.
    ///    wFlags = Type: <b>WORD</b> Flags describing the context of the call, including the following.
    ///    pdispparams = Type: <b>DISPPARAMS*</b> A pointer to a DISPPARAMS structure containing an array of arguments, an array of
    ///                  argument DISPIDs for named arguments, and counts for the number of elements in the arrays.
    ///    pVarResult = Type: <b>VARIANT*</b> A pointer to the location where the result is to be stored, or <b>NULL</b> if the
    ///                 caller expects no result. This argument is ignored if DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYPUTREF is
    ///                 specified.
    ///    pexcepinfo = Type: <b>EXCEPINFO*</b> A pointer to a structure that contains exception information. This structure should
    ///                 be filled in if DISP_E_EXCEPTION is returned. Can be <b>NULL</b>.
    ///    puArgErr = Type: <b>UINT*</b> The index within the <b>rgvarg</b> member of the DISPPARAMS structure of the first
    ///               argument that has an error. Arguments are stored in <b>rgvarg</b> in reverse order, so the first argument is
    ///               the one with the highest index in the array. This parameter is returned only when the resulting return value
    ///               is DISP_E_TYPEMISMATCH or DISP_E_PARAMNOTFOUND. This argument can be set to <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnInvoke(int dispidMember, const(GUID)* iid, uint lcid, ushort wFlags, DISPPARAMS* pdispparams, 
                     VARIANT* pVarResult, EXCEPINFO* pexcepinfo, uint* puArgErr);
}

///Deprecated. The methods exposed by this interface are analogous to virtual protected methods in normal C++
///inheritance. The objects' inheritance hierarchy spans multiple DLLs. The hierarchy is made up of a base class and
///several derived classes that correspond to controls, including CLSID_WebBrowser and the user's desktop. Objects not
///in the hierarchy should not implement this interface or use most of its methods.
@GUID("02BA3B52-0547-11D1-B833-00C04FC9B31F")
interface IBrowserService : IUnknown
{
    ///Deprecated. Retrieves the browser parent's in-place client site.
    ///Params:
    ///    ppipsite = Type: <b>IOleInPlaceSite**</b> The address of a pointer to an IOleInPlaceSite that indicates the browser
    ///               parent's in-place client site.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetParentSite(IOleInPlaceSite* ppipsite);
    ///Deprecated. Sets the title of a browser window.
    ///Params:
    ///    psv = Type: <b>IShellView*</b> A pointer to an IShellView that represents the browser's view. The view must be
    ///          either the browser's current view or the pending view.
    ///    pszName = Type: <b>LPCWSTR</b> A pointer to a buffer containing the browser window's title as a Unicode string.
    HRESULT SetTitle(IShellView psv, const(wchar)* pszName);
    ///Deprecated. Retrieves the title of a browser window.
    ///Params:
    ///    psv = Type: <b>IShellView*</b> A pointer to an IShellView that represents the browser's current view.
    ///    pszName = Type: <b>LPWSTR</b> A pointer to a buffer that receives the title.
    ///    cchName = Type: <b>DWORD</b> The size, in characters, of the buffer pointed to by <i>pszName</i>.
    HRESULT GetTitle(IShellView psv, const(wchar)* pszName, uint cchName);
    ///Deprecated. Retrieves an IOleObject for the browser.
    ///Params:
    ///    ppobjv = Type: <b>IOleObject**</b> The address that receives a pointer to the retrieved IOleObject.
    HRESULT GetOleObject(IOleObject* ppobjv);
    ///Deprecated. Retrieves the browser's ITravelLog.
    ///Params:
    ///    pptl = Type: <b>ITravelLog**</b> The address that receives a pointer to the browser's ITravelLog.
    HRESULT GetTravelLog(ITravelLog* pptl);
    ///Deprecated. Shows or hides various frame controls.
    ///Params:
    ///    id = Type: <b>UINT</b> A value that indicates the frame control to show or hide. One of the following values as
    ///         defined in Shobjidl.h or -1 for fullscreen/kiosk mode. <div class="alert"><b>Note</b> These frame controls
    ///         may not be supported in future versions of Windows.</div> <div> </div>
    ///    fShow = Type: <b>BOOL</b> A value that indicates whether to show or hide the frame control.
    HRESULT ShowControlWindow(uint id, BOOL fShow);
    ///Deprecated. Retrieves a value that indicates whether a specified frame control is currently visible.
    ///Params:
    ///    id = Type: <b>UINT</b> The frame control to check. <div class="alert"><b>Note</b> These frame controls may not be
    ///         supported in future versions of Windows.</div> <div> </div>
    ///    pfShown = Type: <b>BOOL*</b> A value of type <b>BOOL</b> that indicates whether the specified frame control is visible.
    HRESULT IsControlWindowShown(uint id, int* pfShown);
    ///Deprecated. Retrieves the URL that corresponds to a pointer to an item identifier list (PIDL).
    ///Params:
    ///    pidl = Type: <b>LPCITEMIDLIST</b> The PIDL for which to get the corresponding URL.
    ///    pwszName = Type: <b>LPWSTR</b> A pointer to a buffer of at least INTERNET_MAX_URL_LENGTH characters to receive the URL.
    ///    uFlags = Type: <b>UINT</b> One of the following values specifying the form of the retrieved URL.
    HRESULT IEGetDisplayName(ITEMIDLIST* pidl, const(wchar)* pwszName, uint uFlags);
    ///Deprecated. Parses a URL into a pointer to an item identifier list (PIDL).
    ///Params:
    ///    uiCP = Type: <b>UINT</b> A value of type <b>UINT</b> that indicates the code page (for example, CP_ACP, the system
    ///           default code page) to use in the parsing.
    ///    pwszPath = Type: <b>LPCWSTR</b> A pointer to a buffer containing the URL as a Unicode string.
    ///    ppidlOut = Type: <b>LPITEMIDLIST*</b> The PIDL created from the parsed URL.
    HRESULT IEParseDisplayName(uint uiCP, const(wchar)* pwszPath, ITEMIDLIST** ppidlOut);
    ///Deprecated. Displays a URL that failed to be successfully parsed by IBrowserService::IEParseDisplayName.
    ///Params:
    ///    hres = Type: <b>HRESULT</b> An <b>HRESULT</b> returned by IBrowserService::IEParseDisplayName. If this parameter is
    ///           a success code, E_OUTOFMEMORY, or HRESULT_FROM_WIN32(ERROR_CANCELLED), this method does nothing.
    ///    pwszPath = Type: <b>LPCWSTR</b> A pointer to a buffer containing the URL that failed to parse. This method displays the
    ///               failed URL in an error dialog box.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DisplayParseError(HRESULT hres, const(wchar)* pwszPath);
    ///Deprecated. Navigates the browser to the location indicated by a pointer to an item identifier list (PIDL).
    ///Params:
    ///    pidl = Type: <b>LPCITEMIDLIST</b> The PIDL of the location.
    ///    grfHLNF = Type: <b>DWORD</b> One or more of the following flags.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT NavigateToPidl(ITEMIDLIST* pidl, uint grfHLNF);
    ///Deprecated. Sets the current navigation state. This method affects the cursor and animation.
    ///Params:
    ///    bnstate = Type: <b>BNSTATE</b> The value from the BNSTATE enumeration that indicates the navigation state.
    HRESULT SetNavigateState(BNSTATE bnstate);
    ///Deprecated. Retrieves the browser's current navigation state.
    ///Params:
    ///    pbnstate = Type: <b>BNSTATE*</b> A pointer to a value from the BNSTATE enumeration indicating the current navigation
    ///               state.
    HRESULT GetNavigateState(BNSTATE* pbnstate);
    ///Deprecated. Updates the browser to the specified pointer to an item identifier list (PIDL), navigating if
    ///necessary. This method is called when a page is redirected.
    ///Params:
    ///    psv = Type: <b>IShellView*</b> A pointer to an IShellView that indicates the browser's view. The view must be
    ///          either the browser's current view or the pending view.
    ///    pidl = Type: <b>LPCITEMIDLIST</b> The PIDL to use in the update.
    ///    pfDidBrowse = Type: <b>BOOL*</b> Optional. A pointer to a value of type <b>BOOL</b> that indicates whether navigation
    ///                  occurred.
    HRESULT NotifyRedirect(IShellView psv, ITEMIDLIST* pidl, int* pfDidBrowse);
    ///Deprecated. Instructs the browser to update the pointer to an item identifier list (PIDL) in the window list.
    ///This method is called after navigation.
    HRESULT UpdateWindowList();
    ///Deprecated. Updates the state of the browser's <b>Back</b> and <b>Forward</b> buttons.
    HRESULT UpdateBackForwardState();
    ///Deprecated. Sets flags that indicate browser status.
    ///Params:
    ///    dwFlags = Type: <b>DWORD</b> A bitmask used in conjunction with the flags indicated in <i>dwFlagMask</i>. For each
    ///              <i>dwFlagMask</i> bit, the corresponding bit in this value sets (1) or disables (0) that state.
    ///    dwFlagMask = Type: <b>DWORD</b> One or more of the following values.
    HRESULT SetFlags(uint dwFlags, uint dwFlagMask);
    ///Deprecated. Retrieves the current set of browser flags.
    ///Params:
    ///    pdwFlags = Type: <b>DWORD*</b> A pointer to an object of type <b>DWORD</b> that represents the current set of flags. A
    ///               combination of the following values.
    HRESULT GetFlags(uint* pdwFlags);
    ///Deprecated. Returns a value that indicates whether navigation is currently allowed.
    HRESULT CanNavigateNow();
    ///Deprecated. Retrieves a copy of the current pointer to an item identifier list (PIDL).
    ///Params:
    ///    ppidl = Type: <b>LPITEMIDLIST*</b> A pointer to the current PIDL.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPidl(ITEMIDLIST** ppidl);
    ///Deprecated. Sets the pointer to an item identifier list (PIDL) used for zone checking when creating a new window.
    ///Params:
    ///    pidl = Type: <b>LPITEMIDLIST</b> A pointer to the ITEMIDLIST structure (PIDL) used for zone checking.
    HRESULT SetReferrer(ITEMIDLIST* pidl);
    ///Deprecated. Retrieves the index of the browser in the window hierarchy.
    ///Returns:
    ///    Type: <b>DWORD</b> The index of the browser. A value of -1 indicates the top frame browser.
    ///    
    uint    GetBrowserIndex();
    ///Deprecated. Retrieves the browser with the given index.
    ///Params:
    ///    dwID = Type: <b>DWORD</b> A value of type <b>DWORD</b> that indicates the index of the browser.
    ///    ppunk = Type: <b>IUnknown**</b> The address of a pointer to an IUnknown that indicates the browser with the given
    ///            index. The calling application must release this resource when it is no longer needed.
    HRESULT GetBrowserByIndex(uint dwID, IUnknown* ppunk);
    ///Deprecated. Retrieves an IOleObject that represents the browser's history object.
    ///Params:
    ///    ppole = Type: <b>IOleObject**</b> The address of a pointer to an IOleObject that represents the browser's history
    ///            object.
    ///    pstm = Type: <b>IStream**</b> The address of a pointer to the history object's IStream. This parameter may be
    ///           <b>NULL</b>.
    ///    ppbc = Type: <b>IBindCtx**</b> The address of a pointer to the history object stream's IBindCtx. This parameter may
    ///           be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetHistoryObject(IOleObject* ppole, IStream* pstm, IBindCtx* ppbc);
    ///Deprecated. Sets the browser's history object.
    ///Params:
    ///    pole = Type: <b>IOleObject*</b> A pointer to an IOleObject that represents the history object to set.
    ///    fIsLocalAnchor = Type: <b>BOOL</b> A value that specifies whether the new entry is a local or a remote file. Used in the case
    ///                     of the reuse of an inner object.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetHistoryObject(IOleObject pole, BOOL fIsLocalAnchor);
    ///Deprecated. Caches a reference to an external object to avoid reloading the server on reuse.
    ///Params:
    ///    pole = Type: <b>IOleObject*</b> A pointer to an IOleObject interface that represents the external object.
    HRESULT CacheOLEServer(IOleObject pole);
    ///Deprecated. Sets a new character code page and retrieves a pointer to the previous code page.
    ///Params:
    ///    pvarIn = Type: <b>VARIANT*</b> A pointer to a <b>VARIANT</b> that represents the new character code page. Only VT_I4
    ///             is supported. This parameter can be <b>NULL</b>.
    ///    pvarOut = Type: <b>VARIANT*</b> A pointer to a <b>VARIANT</b> that represents the previous character code page. Only
    ///              VT_I4 is supported. This parameter can be <b>NULL</b>.
    HRESULT GetSetCodePage(VARIANT* pvarIn, VARIANT* pvarOut);
    ///Deprecated. Called when the document object responds to an HTTP-EQUIV metatag by issuing either the
    ///<b>OLECMDID_HTTPEQUIV</b> or <b>OLECMDID_HTTPEQUIV_DONE</b> command through IOleCommandTarget::Exec.
    ///Params:
    ///    psv = Type: <b>IShellView*</b> A pointer to an IShellView that indicates the browser's view. The view must be
    ///          either the browser's current view or the pending view.
    ///    fDone = Type: <b>BOOL</b> A value of type <b>BOOL</b> that indicates which command to issue.
    ///    pvarargIn = Type: <b>VARIANT*</b> =A pointer to an object of type <b>VARIANT</b>. This is the equivalent of the
    ///                IOleCommandTarget::Exec parameter <i>pvaIn</i>.
    ///    pvarargOut = Type: <b>VARIANT*</b> A pointer to an object of type <b>VARIANT</b>. This is the equivalent of the
    ///                 IOleCommandTarget::Exec parameter <i>pvaOut</i>.
    HRESULT OnHttpEquiv(IShellView psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut);
    ///Deprecated. Retrieves the browser's palette.
    ///Params:
    ///    hpal = Type: <b>HPALETTE*</b> A pointer to the browser's palette handle, if one exists.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns S_OK if successful, or E_FAIL if there is no palette.
    ///    
    HRESULT GetPalette(HPALETTE* hpal);
    ///Deprecated. Registers the browser in the list of browser windows.
    ///Params:
    ///    fForceRegister = Type: <b>BOOL</b> A value of type <b>BOOL</b> that indicates whether to reregister the browser window if it
    ///                     was previously registered. If set to <b>TRUE</b> and the window was previously registered, this method will
    ///                     unregister and reregister the browser window.
    ///    swc = Type: <b>int</b> One of the ShellWindowTypeConstants values to indicate the nature of the window. Note that
    ///          these values are defined in Expdisp.h.
    HRESULT RegisterWindow(BOOL fForceRegister, int swc);
}

///Deprecated. <b>IShellService</b> Exposes one method that declares ownership when a service component implementing a
///certain interface is shared among multiple clients, such as Windows Internet Explorer and Windows Explorer.
@GUID("5836FB00-8187-11CF-A12B-00AA004AE837")
interface IShellService : IUnknown
{
    ///Deprecated. Declares an owner reference to the service object.
    ///Params:
    ///    punkOwner = Type: <b>IUnknown*</b> The address of an interface pointer to the owner object. If <b>NULL</b>, the object
    ///                should call IUnknown::Release to release the existing reference.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOwner(IUnknown punkOwner);
}

///Deprecated. <b>IBrowserService2</b> extends IBrowserService. The methods exposed by this interface are analogous to
///virtual protected methods in normal C++ inheritance. The objects' inheritance hierarchy spans multiple DLLs. The
///hierarchy is made up of a base class and several derived classes that correspond to controls including
///CLSID_WebBrowser and the user's desktop. Objects not in the hierarchy should not implement this interface or use most
///of its methods.
@GUID("68BD21CC-438B-11D2-A560-00A0C92DBFE8")
interface IBrowserService2 : IBrowserService
{
    ///Deprecated. Allows a derived class to call the <b>WinProc</b> function of the base class.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the window receiving the message.
    ///    uMsg = Type: <b>UINT</b> The message received by the window.
    ///    wParam = Type: <b>WPARAM</b> Additional message information specific to the message type.
    ///    lParam = Type: <b>LPARAM</b> Additional message information specific to the message type.
    LRESULT WndProcBS(HWND hwnd, uint uMsg, WPARAM wParam, LPARAM lParam);
    ///Deprecated. Sets the folder's current view mode as the default view mode for all folders. Used by the <b>Folder
    ///Options</b> dialog.
    HRESULT SetAsDefFolderSettings();
    ///Deprecated. Retrieves a value that is used to negotiate the allowed size of the window.
    ///Params:
    ///    prc = Type: <b>RECT*</b> A pointer to a <b>RECT</b> structure that receives the allowed dimensions.
    HRESULT GetViewRect(RECT* prc);
    ///Deprecated. Calls the derived class from the base class on receipt of a WM_SIZE message. The derived class
    ///handles the message.
    ///Params:
    ///    wParam = Type: <b>WPARAM</b> Additional information provided by the WM_SIZE message.
    HRESULT OnSize(WPARAM wParam);
    ///Deprecated. Calls the derived class from the base class on receipt of a WM_CREATE message. The derived class
    ///handles the message.
    ///Params:
    ///    pcs = Type: <b>tagCREATESTRUCTW*</b> A pointer to a CREATESTRUCT structure that receives the initialization
    ///          parameters passed to the window procedure (WinProc) of the class.
    HRESULT OnCreate(CREATESTRUCTW* pcs);
    ///Deprecated. Calls the derived class from the base class on receipt of a WM_COMMAND message. The derived class
    ///handles the message.
    ///Params:
    ///    wParam = Type: <b>WPARAM</b> Additional information taken from the WM_COMMAND message. The high-order word specifies
    ///             the notification code if the message is from a control. If the message is from an accelerator, this value is
    ///             1. If the message is from a menu, this value is zero. The low-order word specifies the identifier of the menu
    ///             item, control, or accelerator.
    ///    lParam = Type: <b>LPARAM</b> Additional information taken from the WM_COMMAND message. Handle to the control sending
    ///             the message if the message is from a control. Otherwise, this parameter is <b>NULL</b>.
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    ///Deprecated. Calls the derived class from the base class on receipt of a WM_DESTROY message. The derived class
    ///handles the message.
    HRESULT OnDestroy();
    ///Deprecated. Calls the derived class from the base class on receipt of a WM_NOTIFY message. The derived class
    ///handles the message.
    ///Params:
    ///    pnm = Type: <b>tagNMHDR*</b> A pointer to a NMHDR structure that receives the initialization parameters passed to
    ///          the window procedure (WinProc) of the class.
    LRESULT OnNotify(NMHDR* pnm);
    ///Deprecated. Calls the derived class from the base class on receipt of a WM_SETFOCUS message. The derived class
    ///handles the message.
    HRESULT OnSetFocus();
    ///Deprecated. Calls the derived class from the base class in response to a subframe window being activated or
    ///deactivated. The derived class determines what to do in response to the action.
    ///Params:
    ///    fActive = Type: <b>BOOL</b> The state of the subframe window.
    HRESULT OnFrameWindowActivateBS(BOOL fActive);
    ///Deprecated. Coordinates the view lifetime between the base class and its derived class.
    HRESULT ReleaseShellView();
    ///Deprecated. Coordinates state updating while the browser is switching between a current and a pending view.
    HRESULT ActivatePendingView();
    ///Deprecated. Coordinates the updating of state when creating a new browser view window.
    ///Params:
    ///    psvNew = Type: <b>IShellView*</b> A pointer to the IShellView of the new browser window.
    ///    psvOld = Type: <b>IShellView*</b> A pointer to the IShellView of the old browser window.
    ///    prcView = Type: <b>LPRECT</b> A pointer to a RECT structure that specifies the current dimensions of the browser view.
    ///    phwnd = Type: <b>HWND*</b> A pointer to the new browser window handle.
    HRESULT CreateViewWindow(IShellView psvNew, IShellView psvOld, RECT* prcView, HWND* phwnd);
    ///Deprecated. Allows the derived class to add <b>Folder Options</b> property sheets to the base class.
    ///Params:
    ///    riid = Type: <b>REFIID</b> The IID of the interface pointer that should be returned in the <i>ppv</i> parameter.
    ///    ppv = Type: <b>void**</b> The address of a pointer to the interface pointer requested in the <i>riid</i> parameter.
    HRESULT CreateBrowserPropSheetExt(const(GUID)* riid, void** ppv);
    ///Deprecated. Provides direct access to the browser view window created by IBrowserService2::CreateViewWindow.
    ///Params:
    ///    phwndView = Type: <b>HWND*</b> A pointer to the handle of the browser window.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetViewWindow(HWND* phwndView);
    ///Deprecated. Gets a read-only structure containing the protected elements owned by the base class, for the purpose
    ///of determining state.
    ///Params:
    ///    pbbd = Type: <b>LPCBASEBROWSERDATA*</b> A pointer to a BASEBROWSERDATA structure that receives the read-only state
    ///           of the base browser.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBaseBrowserData(BASEBROWSERDATALH** pbbd);
    ///Deprecated. Gets a structure that allows read/write access to protected members of the base class. Note, however,
    ///that state should only be updated by the base browser.
    BASEBROWSERDATALH* PutBaseBrowserData();
    ///Deprecated. Allows the derived class to specify a navigation record to be used in a new window.
    ///Params:
    ///    ptl = Type: <b>ITravelLog*</b> A pointer to an existing ITravelLog object to be used for the new window.
    ///    dw = Type: <b>DWORD</b> The new browser window's ID.
    HRESULT InitializeTravelLog(ITravelLog ptl, uint dw);
    ///Deprecated. Informs the base class when it becomes the topmost browser instance.
    HRESULT SetTopBrowser();
    ///Deprecated. Checks for and updates the browser's offline status, synchronzing the state between the base class
    ///and any derived classes.
    ///Params:
    ///    iCmd = Type: <b>int</b> One of the following commands.
    HRESULT Offline(int iCmd);
    ///Deprecated. Informs the base class whether to allow view resizing.
    ///Params:
    ///    f = Type: <b>BOOL</b> A value of type <b>BOOL</b> that indicates whether to allow view resizing.
    HRESULT AllowViewResize(BOOL f);
    ///Deprecated. Updates the value of the <b>_uActivateState</b> member of the BASEBROWSERDATA structure, which tracks
    ///whether the browser view window is in an activated state. The derived class makes this call to the base class.
    ///Params:
    ///    u = Type: <b>UINT</b> The activation state of the window. This is always the SVUIA_ACTIVATE_FOCUS (0x0002) value
    ///        from the SVUIA_STATUS enumeration defined in Shobjidl.h.
    HRESULT SetActivateState(uint u);
    ///Deprecated. Updates the value of the <b>_eSecureLockIcon</b> member of the BASEBROWSERDATA structure, which
    ///tracks the icon indicating a secure site, as well as updating the icon itself in the UI.
    ///Params:
    ///    eSecureLock = Type: <b>int</b> One of the following values indicating the secure lock status. Note that each value is
    ///                  provided in a SET and SUGGEST form. For more details, see BASEBROWSERDATA.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UpdateSecureLockIcon(int eSecureLock);
    ///Deprecated. Enables the download manager in the base class.
    HRESULT InitializeDownloadManager();
    ///Deprecated. Enables transitions in the browser view window.
    HRESULT InitializeTransitionSite();
    ///Deprecated. Coordinates the initializing of state between the base and the derived classes.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> A handle to the current window.
    ///    pauto = Type: <b>IUnknown*</b> A pointer to the IUnknown of the outer object's IWebBrowser2 automation interface.
    HRESULT _Initialize(HWND hwnd, IUnknown pauto);
    ///Deprecated. Enables a derived class to request that the base class cancel any pending navigation.
    HRESULT _CancelPendingNavigationAsync();
    ///Deprecated. Enables a derived class to request that the base class cancel any pending views.
    HRESULT _CancelPendingView();
    ///Deprecated. Enables the base class to check whether the browser view needs to save changes before closing.
    HRESULT _MaySaveChanges();
    ///Deprecated. Enables a derived class to request the base class to either pause (such as before a minimize
    ///operation) or resume the browser view.
    ///Params:
    ///    fPaused = Type: <b>BOOL</b> <b>TRUE</b> to indicate that the view is to be paused, <b>FALSE</b> otherwise.
    HRESULT _PauseOrResumeView(BOOL fPaused);
    ///Deprecated. Enables a derived class to ask the base class whether a modal UI is visible. A modal UI blocks
    ///minimize and close behavior in the browser window.
    HRESULT _DisableModeless();
    HRESULT _NavigateToPidl2(ITEMIDLIST* pidl, uint grfHLNF, uint dwFlags);
    ///Deprecated. Coordinates the renaming of the current browser view when the browser is redirected.
    ///Params:
    ///    psv = Type: <b>IShellView*</b> A pointer to an IShellView representing the current browser view.
    ///    pidlNew = Type: <b>LPCITEMIDLIST</b> A PIDL that indicates the new name of the browser view.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT _TryShell2Rename(IShellView psv, ITEMIDLIST* pidlNew);
    ///Deprecated. Coordinates state updates while switching between current and pending browser views.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT _SwitchActivationNow();
    ///Deprecated. Enables the derived class to issue a command through the IOleCommandTarget::Exec method directly,
    ///instead of relying on the base class.
    ///Params:
    ///    punkBar = Type: <b>IUnknown*</b> A pointer to the IUnknown of the IOleCommandTarget interface.
    ///    fBroadcast = Type: <b>BOOL</b> <b>TRUE</b> to broadcast the command; <b>FALSE</b> otherwise.
    ///    pguidCmdGroup = Type: <b>const GUID*</b> A pointer to the unique identifier of the command group; can be <b>NULL</b> to
    ///                    specify the standard group.
    ///    nCmdID = Type: <b>DWORD</b> The command to be executed. This command must belong to the group specified with
    ///             <i>pguidCmdGroup</i>.
    ///    nCmdexecopt = Type: <b>DWORD</b> The values taken from the OLECMDEXECOPT enumeration, which describe how the object should
    ///                  execute the command.
    ///    pvarargIn = Type: <b>VARIANTARG*</b> A pointer to a <b>VARIANTARG</b> structure containing input arguments. Can be
    ///                <b>NULL</b>.
    ///    pvarargOut = Type: <b>VARIANTARG*</b> A pointer to a <b>VARIANTARG</b> structure to receive command output. Can be
    ///                 <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT _ExecChildren(IUnknown punkBar, BOOL fBroadcast, const(GUID)* pguidCmdGroup, uint nCmdID, 
                          uint nCmdexecopt, VARIANT* pvarargIn, VARIANT* pvarargOut);
    ///Deprecated. Allows the derived class to send a message through the SendMessage function directly instead of
    ///relying on the base class.
    ///Params:
    ///    hwndBar = Type: <b>HWND</b> A handle to the browser window whose window procedure receives the message.
    ///    fBroadcast = Type: <b>BOOL</b> The <b>BOOL</b> that indicates whether to allow the derived class to broadcast the
    ///                 SendMessage function. <b>TRUE</b> to allow broadcasting; <b>FALSE</b> otherwise.
    ///    uMsg = Type: <b>UINT</b> The message to be sent.
    ///    wParam = Type: <b>WPARAM</b> Additional message-specific information.
    ///    lParam = Type: <b>LPARAM</b> Additional message-specific information.
    HRESULT _SendChildren(HWND hwndBar, BOOL fBroadcast, uint uMsg, WPARAM wParam, LPARAM lParam);
    ///Deprecated. Gets a structure containing folder information.
    ///Params:
    ///    pfsd = Type: <b>tagFolderSetData*</b> A pointer to a FOLDERSETDATA structure that receives the folder information.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFolderSetData(FOLDERSETDATA* pfsd);
    ///Deprecated. Coordinates focus between the base and the derived class when the focus shifts between the derived
    ///class's browser toolbars and its view.
    ///Params:
    ///    itb = Type: <b>UINT</b> The ID of the toolbar gaining focus, or ITB_VIEW if the view is gaining focus.
    HRESULT _OnFocusChange(uint itb);
    ///Deprecated. Allows a derived class to update its child windows after a sizing event.
    ///Params:
    ///    fChildOnly = Type: <b>BOOL</b> A value of type <b>BOOL</b> that indicates whether child windows should be shown or hidden.
    HRESULT v_ShowHideChildWindows(BOOL fChildOnly);
    ///Deprecated. Gets the ID of the last toolbar or view that had focus.
    uint    _get_itbLastFocus();
    ///Deprecated. Sets the last toolbar or the last view with focus.
    ///Params:
    ///    itbLastFocus = Type: <b>UINT</b> The index of the last toolbar with focus. Set this parameter to ITB_VIEW to indicate that
    ///                   the view had the last focus.
    HRESULT _put_itbLastFocus(uint itbLastFocus);
    ///Deprecated. Allows a derived class to request that the base class update the browser view.
    ///Params:
    ///    uState = Type: <b>UINT</b> A member of the SVUIA_STATUS enumeration declaring the browser view's state value.
    HRESULT _UIActivateView(uint uState);
    ///Deprecated. Used with IBrowserService2::_GetEffectiveClientArea to negotiate the size and position of the browser
    ///view.
    ///Params:
    ///    prc = Type: <b>RECT*</b> A pointer to the RECT structure stating the dimensions of the browser view's border.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT _GetViewBorderRect(RECT* prc);
    ///Deprecated. Called to inform other functions involved in the browser view size negotiations that the allowable
    ///browser view dimensions have changed.
    HRESULT _UpdateViewRectSize();
    ///Deprecated. Resizes the border of the browser view in response to the addition or removal of toolbars.
    ///Params:
    ///    itb = Type: <b>UINT</b> The index of the toolbar that was added or removed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT _ResizeNextBorder(uint itb);
    ///Deprecated. Calls IBrowserService2::_UpdateViewRectSize, then updates the browser view by using
    ///IOleInPlaceActiveObject::ResizeBorder.
    HRESULT _ResizeView();
    ///Deprecated. Used with IBrowserService2::_GetViewBorderRect to negotiate the dimensions of the browser view.
    ///Params:
    ///    lprectBorder = Type: <b>LPRECT</b> A pointer to a RECT structure indicating the dimensions of the available client area.
    ///    hmon = Type: <b>HMONITOR</b> The handle of the monitor on which the view is displayed.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT _GetEffectiveClientArea(RECT* lprectBorder, ptrdiff_t hmon);
    ///Deprecated. Returns a stream used to load or save the view state.
    ///Params:
    ///    pidl = Type: <b>LPCITEMIDLIST</b> A PIDL that identifies the view.
    ///    grfMode = Type: <b>DWORD</b> Not used.
    ///    pwszName = Type: <b>LPCWSTR</b> A pointer to a buffer that contains the Unicode name of the window.
    IStream v_GetViewStream(ITEMIDLIST* pidl, uint grfMode, const(wchar)* pwszName);
    ///Deprecated. Calls the SendMessage function with a message received by the view, using the <b>_hwndView</b> member
    ///of the BASEBROWSERDATA structure as the <b>SendMessage</b> <i>hWnd</i> parameter.
    ///Params:
    ///    uMsg = Type: <b>UINT</b> The message to be sent.
    ///    wParam = Type: <b>WPARAM</b> Additional message-specific information.
    ///    lParam = Type: <b>LPARAM</b> Additional message-specific information.
    LRESULT ForwardViewMsg(uint uMsg, WPARAM wParam, LPARAM lParam);
    ///Deprecated. Implemented by a derived class to define menu accelerators that can be used in a call to
    ///TranslateAcceleratorSB.
    ///Params:
    ///    hacc = Type: <b>HACCEL</b> A handle to an array of ACCEL structures, each structure describing a keyboard mnemonic.
    HRESULT SetAcceleratorMenu(HACCEL hacc);
    ///Deprecated. Returns the number of toolbars in the browser window.
    ///Returns:
    ///    Type: <b>int</b> The number of toolbars in the browser window.
    ///    
    int     _GetToolbarCount();
    ///Deprecated. Gets a specific item from a toolbar.
    ///Params:
    ///    itb = Type: <b>int</b> The index of the toolbar item to retrieve.
    ///Returns:
    ///    Type: <b>LPTOOLBARITEM</b> A pointer to a [TOOLBARITEM](./ns-shdeprecated-toolbaritem.md) structure that
    ///    represents a toolbar item.
    ///    
    TOOLBARITEM* _GetToolbarItem(int itb);
    ///Deprecated. Saves the state of browser toolbars.
    ///Params:
    ///    pstm = Type: <b>IStream*</b> A pointer to an IStream used to store the browser toolbar's state.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT _SaveToolbars(IStream pstm);
    ///Deprecated. Loads the saved state of the browser's toolbars.
    ///Params:
    ///    pstm = Type: <b>IStream*</b> A pointer to an IStream from which to load the state of the browser's toolbars.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT _LoadToolbars(IStream pstm);
    ///Deprecated. Requests the closing of the browser toolbars hosted by the derived class.
    ///Params:
    ///    fClose = Type: <b>BOOL</b> <b>TRUE</b> to close the toolbar through IDockingWindow::CloseDW; <b>FALSE</b> to release
    ///             the toolbar.
    HRESULT _CloseAndReleaseToolbars(BOOL fClose);
    ///Deprecated. Used when translating accelerators through TranslateAcceleratorSB and in checking the cycle of focus
    ///between the view and the browser's toolbars.
    ///Params:
    ///    lpMsg = Type: <b>LPMSG</b> A pointer to a MSG that contains the keystroke message.
    ///    itbNext = Type: <b>UINT</b> The index of the next toolbar, or ITB_VIEW if focus is shifting to the view.
    ///    citb = Type: <b>int</b> The ID of the current toolbar with focus, or ITB_VIEW if the view has focus.
    ///    pptbi = Type: <b>LPTOOLBARITEM*</b> A pointer to a [TOOLBARITEM](./ns-shdeprecated-toolbaritem.md) structure that
    ///            represents the toolbar receiving the focus.
    ///    phwnd = Type: <b>HWND*</b> A pointer to the handle of the window that contains the toolbar.
    HRESULT v_MayGetNextToolbarFocus(MSG* lpMsg, uint itbNext, int citb, TOOLBARITEM** pptbi, HWND* phwnd);
    ///Deprecated. A helper method used by the implementation of IBrowserService2::_ResizeNextBorder.
    ///Params:
    ///    itb = Type: <b>UINT</b> The index of the browser toolbar.
    ///    bUseHmonitor = Type: <b>BOOL</b> A value of type <b>BOOL</b> that indicates whether to use an <b>HMONITOR</b> to determine
    ///                   the display. <b>TRUE</b> to use the <b>HMONITOR</b>; <b>FALSE</b> to ignore the particular display in the
    ///                   size determination.
    HRESULT _ResizeNextBorderHelper(uint itb, BOOL bUseHmonitor);
    ///Deprecated. Returns the index of a browser toolbar item based on Component Object Model (COM) identity rules.
    ///Params:
    ///    punkSrc = Type: <b>IUnknown*</b> A pointer to the IUnknown of the browser toolbar item.
    uint    _FindTBar(IUnknown punkSrc);
    ///Deprecated. Sets the focus on a toolbar or on the browser's view window. Called when translating accelerators
    ///through TranslateAcceleratorSB or when IBrowserService2::v_MayGetNextToolbarFocus fails.
    ///Params:
    ///    ptbi = Type: <b>LPTOOLBARITEM</b> A pointer to a [TOOLBARITEM](./ns-shdeprecated-toolbaritem.md) structure that
    ///           specifies a browser toolbar item.
    ///    hwnd = Type: <b>HWND</b> The handle of the browser window in which the focus shift is taking place.
    ///    lpMsg = Type: <b>LPMSG</b> A pointer to a MSG that contains a keystroke message that indicates an accelerator.
    HRESULT _SetFocus(TOOLBARITEM* ptbi, HWND hwnd, MSG* lpMsg);
    ///Deprecated. Called by a derived class to instruct the base class to proceed with the translation of keyboard
    ///mnemonics.
    ///Params:
    ///    pmsg = Type: <b>MSG*</b> A pointer to a MSG that contains the keystroke message.
    HRESULT v_MayTranslateAccelerator(MSG* pmsg);
    ///Deprecated. A helper method for the implementation of GetBorderDW.
    ///Params:
    ///    punkSrc = Type: <b>IUnknown*</b> A pointer to an IUnknown that represents the object for which the border space is
    ///              being requested.
    ///    lprectBorder = Type: <b>LPRECT</b> A pointer to a RECT structure that contains the dimensions of the available border space
    ///                   for the browser.
    ///    bUseHmonitor = Type: <b>BOOL</b> A value of type <b>BOOL</b> that indicates whether to use an <b>HMONITOR</b> to determine
    ///                   the display. <b>TRUE</b> to use the <b>HMONITOR</b>; <b>FALSE</b> to ignore the particular display in the
    ///                   size determination.
    HRESULT _GetBorderDWHelper(IUnknown punkSrc, RECT* lprectBorder, BOOL bUseHmonitor);
    ///Deprecated. Called by the base class to validate a zone crossing when navigating from one page to another.
    ///Params:
    ///    pidl = Type: <b>LPCITEMIDLIST</b> The PIDL of the navigation destination.
    HRESULT v_CheckZoneCrossing(ITEMIDLIST* pidl);
}

///Deprecated. The methods exposed by this interface are analogous to virtual protected methods in normal C++
///inheritance. The inheritance hierarchy of the objects spans multiple DLLs. The hierarchy is made up of a base class
///and several derived classes that correspond to controls, including CLSID_WebBrowser and the user's desktop. Objects
///not in the hierarchy should not implement this interface, nor use most of its methods.
@GUID("27D7CE21-762D-48F3-86F3-40E2FD3749C4")
interface IBrowserService3 : IBrowserService2
{
    ///Deprecated. Used in view size negotiations. This method is called by _UpdateViewRectSize after determining the
    ///available dimensions.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the view window.
    ///    prc = Type: <b>LPRECT</b> A pointer to a RECT structure that contains the available dimensions.
    HRESULT _PositionViewWindow(HWND hwnd, RECT* prc);
    ///Deprecated. Parses a URL into a pointer to an item identifier list (PIDL).
    ///Params:
    ///    uiCP = Type: <b>UINT</b> The code page (for example, CP_ACP, the system default code page).
    ///    pwszPath = Type: <b>LPCWSTR</b> A pointer to a buffer containing the URL to parse, as a Unicode string.
    ///    dwFlags = Type: <b>DWORD</b> The following value, if desired.
    ///    ppidlOut = Type: <b>LPITEMIDLIST*</b> The PIDL created from the parsed URL.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IEParseDisplayNameEx(uint uiCP, const(wchar)* pwszPath, uint dwFlags, ITEMIDLIST** ppidlOut);
}

///Deprecated.
@GUID("639F1BFF-E135-4096-ABD8-E0F504D649A4")
interface IBrowserService4 : IBrowserService3
{
    ///Deprecated.
    ///Params:
    ///    fPendingView = Type: <b>BOOL</b> Specifies whether the view is pending.
    HRESULT ActivateView(BOOL fPendingView);
    ///Deprecated.
    HRESULT SaveViewState();
    ///Deprecated.
    HRESULT _ResizeAllBorders();
}

///Exposes methods that extend the IShellMenu interface by providing the ability to coordinate toolbar buttons with a
///menu as well as display a pop-up menu.
@GUID("8278F932-2A3E-11D2-838F-00C04FD918D0")
interface ITrackShellMenu : IShellMenu
{
    ///Coordinates obscured items on a toolbar with items in a menu.
    ///Params:
    ///    hwndTB = Type: <b>HWND</b> A handle to a toolbar control whose buttons have command IDs that correspond to menu IDs in
    ///             the tracked menu.
    ///    punkBand = Type: <b>IUnknown*</b> If this parameter points to a COM object that supports the IShellMenu interface, menu
    ///               items that correspond to visible toolbar buttons are filtered out of the menu so that they do not appear in
    ///               both places. If this parameter is <b>NULL</b> or points to a COM object that does not support the IShellMenu
    ///               interface, then the obscured buttons in the toolbar are added to the shell menu in the position specified in
    ///               <i>dwSMSetFlags</i>.
    ///    dwSMSetFlags = Type: <b>DWORD</b> One of the following values.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetObscured(HWND hwndTB, IUnknown punkBand, uint dwSMSetFlags);
    ///Displays a modal pop-up menu at a specific location.
    ///Params:
    ///    hwnd = Type: <b>HWND</b> The handle of the parent window of the pop-up menu.
    ///    ppt = Type: <b>POINTL*</b> A pointer to a POINTL structure that specifies an initial point in screen coordinates.
    ///          The pop-up menu is displayed in relation to this point as determined by the position flags set in
    ///          <i>dwFlags</i>.
    ///    prcExclude = Type: <b>RECTL*</b> A pointer to a RECTL structure that specifies the rectangle to exclude when positioning
    ///                 the menu. The alignment of the menu in relation to this area is determined by the alignment flags set in
    ///                 <i>dwFlags</i>. This parameter can be set to <b>NULL</b>.
    ///    dwFlags = Type: <b>MP_POPUPFLAGS</b> One or more of the MP_POPUPFLAGS constants that specify options involved in the
    ///              display of the pop-up menu.
    HRESULT Popup(HWND hwnd, POINTL* ppt, RECTL* prcExclude, int dwFlags);
}

///Exposes a method that allows conversion to JPEG or bitmap (BMP) image formats from any image type supported by
///Windows.
@GUID("BAE86DDD-DC11-421C-B7AB-CC55D1D65C44")
interface ITranscodeImage : IUnknown
{
    ///Converts an image to JPEG or bitmap (BMP) image format.
    ///Params:
    ///    pShellItem = Type: <b>IShellItem*</b> The Shell Item for the image to convert.
    ///    uiMaxWidth = Type: <b>UINT</b> The requested height in pixels. Should be less than or equal to the actual height of the
    ///                 original image. See Remarks.
    ///    uiMaxHeight = Type: <b>UINT</b> The requested width in pixels. Should be less than or equal to the actual width of the
    ///                  original image. See Remarks.
    ///    flags = Type: <b>TI_FLAGS</b> One of the following flags.
    ///    pvImage = Type: <b>IStream*</b> A stream to receive the converted image. The stream must be created by the calling code
    ///              prior to calling <b>TranscodeImage</b>.
    ///    puiWidth = Type: <b>UINT*</b> The actual width of the converted image.
    ///    puiHeight = Type: <b>UINT*</b> The actual height of the converted image.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT TranscodeImage(IShellItem pShellItem, uint uiMaxWidth, uint uiMaxHeight, uint flags, IStream pvImage, 
                           uint* puiWidth, uint* puiHeight);
}

@GUID("FBF23B80-E3F0-101B-8488-00AA003E56F8")
interface IUniformResourceLocatorA : IUnknown
{
    HRESULT SetURL(const(char)* pcszURL, uint dwInFlags);
    HRESULT GetURL(byte** ppszURL);
    HRESULT InvokeCommand(urlinvokecommandinfoA* purlici);
}

@GUID("CABB0DA0-DA57-11CF-9974-0020AFD79762")
interface IUniformResourceLocatorW : IUnknown
{
    HRESULT SetURL(const(wchar)* pcszURL, uint dwInFlags);
    HRESULT GetURL(ushort** ppszURL);
    HRESULT InvokeCommand(urlinvokecommandinfoW* purlici);
}

@GUID("08C03412-F96B-11D0-A475-00AA006BCC59")
interface IEnumRegisterWordA : IUnknown
{
    HRESULT Clone(IEnumRegisterWordA* ppEnum);
    HRESULT Next(uint ulCount, REGISTERWORDA* rgRegisterWord, uint* pcFetched);
    HRESULT Reset();
    HRESULT Skip(uint ulCount);
}

@GUID("4955DD31-B159-11D0-8FCF-00AA006BCC59")
interface IEnumRegisterWordW : IUnknown
{
    HRESULT Clone(IEnumRegisterWordW* ppEnum);
    HRESULT Next(uint ulCount, REGISTERWORDW* rgRegisterWord, uint* pcFetched);
    HRESULT Reset();
    HRESULT Skip(uint ulCount);
}

@GUID("09B5EAB0-F997-11D1-93D4-0060B067B86E")
interface IEnumInputContext : IUnknown
{
    HRESULT Clone(IEnumInputContext* ppEnum);
    HRESULT Next(uint ulCount, HIMC__** rgInputContext, uint* pcFetched);
    HRESULT Reset();
    HRESULT Skip(uint ulCount);
}

@GUID("B3458082-BD00-11D1-939B-0060B067B86E")
interface IActiveIMMRegistrar : IUnknown
{
    HRESULT RegisterIME(const(GUID)* rclsid, ushort lgid, const(wchar)* pszIconFile, const(wchar)* pszDesc);
    HRESULT UnregisterIME(const(GUID)* rclsid);
}

@GUID("B5CF2CFA-8AEB-11D1-9364-0060B067B86E")
interface IActiveIMMMessagePumpOwner : IUnknown
{
    HRESULT Start();
    HRESULT End();
    HRESULT OnTranslateMessage(const(MSG)* pMsg);
    HRESULT Pause(uint* pdwCookie);
    HRESULT Resume(uint dwCookie);
}

@GUID("08C0E040-62D1-11D1-9326-0060B067B86E")
interface IActiveIMMApp : IUnknown
{
    HRESULT AssociateContext(HWND hWnd, HIMC__* hIME, HIMC__** phPrev);
    HRESULT ConfigureIMEA(ptrdiff_t hKL, HWND hWnd, uint dwMode, REGISTERWORDA* pData);
    HRESULT ConfigureIMEW(ptrdiff_t hKL, HWND hWnd, uint dwMode, REGISTERWORDW* pData);
    HRESULT CreateContext(HIMC__** phIMC);
    HRESULT DestroyContext(HIMC__* hIME);
    HRESULT EnumRegisterWordA(ptrdiff_t hKL, const(char)* szReading, uint dwStyle, const(char)* szRegister, 
                              void* pData, IEnumRegisterWordA* pEnum);
    HRESULT EnumRegisterWordW(ptrdiff_t hKL, const(wchar)* szReading, uint dwStyle, const(wchar)* szRegister, 
                              void* pData, IEnumRegisterWordW* pEnum);
    HRESULT EscapeA(ptrdiff_t hKL, HIMC__* hIMC, uint uEscape, void* pData, LRESULT* plResult);
    HRESULT EscapeW(ptrdiff_t hKL, HIMC__* hIMC, uint uEscape, void* pData, LRESULT* plResult);
    HRESULT GetCandidateListA(HIMC__* hIMC, uint dwIndex, uint uBufLen, CANDIDATELIST* pCandList, uint* puCopied);
    HRESULT GetCandidateListW(HIMC__* hIMC, uint dwIndex, uint uBufLen, CANDIDATELIST* pCandList, uint* puCopied);
    HRESULT GetCandidateListCountA(HIMC__* hIMC, uint* pdwListSize, uint* pdwBufLen);
    HRESULT GetCandidateListCountW(HIMC__* hIMC, uint* pdwListSize, uint* pdwBufLen);
    HRESULT GetCandidateWindow(HIMC__* hIMC, uint dwIndex, CANDIDATEFORM* pCandidate);
    HRESULT GetCompositionFontA(HIMC__* hIMC, LOGFONTA* plf);
    HRESULT GetCompositionFontW(HIMC__* hIMC, LOGFONTW* plf);
    HRESULT GetCompositionStringA(HIMC__* hIMC, uint dwIndex, uint dwBufLen, int* plCopied, void* pBuf);
    HRESULT GetCompositionStringW(HIMC__* hIMC, uint dwIndex, uint dwBufLen, int* plCopied, void* pBuf);
    HRESULT GetCompositionWindow(HIMC__* hIMC, COMPOSITIONFORM* pCompForm);
    HRESULT GetContext(HWND hWnd, HIMC__** phIMC);
    HRESULT GetConversionListA(ptrdiff_t hKL, HIMC__* hIMC, const(char)* pSrc, uint uBufLen, uint uFlag, 
                               CANDIDATELIST* pDst, uint* puCopied);
    HRESULT GetConversionListW(ptrdiff_t hKL, HIMC__* hIMC, const(wchar)* pSrc, uint uBufLen, uint uFlag, 
                               CANDIDATELIST* pDst, uint* puCopied);
    HRESULT GetConversionStatus(HIMC__* hIMC, uint* pfdwConversion, uint* pfdwSentence);
    HRESULT GetDefaultIMEWnd(HWND hWnd, HWND* phDefWnd);
    HRESULT GetDescriptionA(ptrdiff_t hKL, uint uBufLen, const(char)* szDescription, uint* puCopied);
    HRESULT GetDescriptionW(ptrdiff_t hKL, uint uBufLen, const(wchar)* szDescription, uint* puCopied);
    HRESULT GetGuideLineA(HIMC__* hIMC, uint dwIndex, uint dwBufLen, const(char)* pBuf, uint* pdwResult);
    HRESULT GetGuideLineW(HIMC__* hIMC, uint dwIndex, uint dwBufLen, const(wchar)* pBuf, uint* pdwResult);
    HRESULT GetIMEFileNameA(ptrdiff_t hKL, uint uBufLen, const(char)* szFileName, uint* puCopied);
    HRESULT GetIMEFileNameW(ptrdiff_t hKL, uint uBufLen, const(wchar)* szFileName, uint* puCopied);
    HRESULT GetOpenStatus(HIMC__* hIMC);
    HRESULT GetProperty(ptrdiff_t hKL, uint fdwIndex, uint* pdwProperty);
    HRESULT GetRegisterWordStyleA(ptrdiff_t hKL, uint nItem, STYLEBUFA* pStyleBuf, uint* puCopied);
    HRESULT GetRegisterWordStyleW(ptrdiff_t hKL, uint nItem, STYLEBUFW* pStyleBuf, uint* puCopied);
    HRESULT GetStatusWindowPos(HIMC__* hIMC, POINT* pptPos);
    HRESULT GetVirtualKey(HWND hWnd, uint* puVirtualKey);
    HRESULT InstallIMEA(const(char)* szIMEFileName, const(char)* szLayoutText, ptrdiff_t* phKL);
    HRESULT InstallIMEW(const(wchar)* szIMEFileName, const(wchar)* szLayoutText, ptrdiff_t* phKL);
    HRESULT IsIME(ptrdiff_t hKL);
    HRESULT IsUIMessageA(HWND hWndIME, uint msg, WPARAM wParam, LPARAM lParam);
    HRESULT IsUIMessageW(HWND hWndIME, uint msg, WPARAM wParam, LPARAM lParam);
    HRESULT NotifyIME(HIMC__* hIMC, uint dwAction, uint dwIndex, uint dwValue);
    HRESULT RegisterWordA(ptrdiff_t hKL, const(char)* szReading, uint dwStyle, const(char)* szRegister);
    HRESULT RegisterWordW(ptrdiff_t hKL, const(wchar)* szReading, uint dwStyle, const(wchar)* szRegister);
    HRESULT ReleaseContext(HWND hWnd, HIMC__* hIMC);
    HRESULT SetCandidateWindow(HIMC__* hIMC, CANDIDATEFORM* pCandidate);
    HRESULT SetCompositionFontA(HIMC__* hIMC, LOGFONTA* plf);
    HRESULT SetCompositionFontW(HIMC__* hIMC, LOGFONTW* plf);
    HRESULT SetCompositionStringA(HIMC__* hIMC, uint dwIndex, void* pComp, uint dwCompLen, void* pRead, 
                                  uint dwReadLen);
    HRESULT SetCompositionStringW(HIMC__* hIMC, uint dwIndex, void* pComp, uint dwCompLen, void* pRead, 
                                  uint dwReadLen);
    HRESULT SetCompositionWindow(HIMC__* hIMC, COMPOSITIONFORM* pCompForm);
    HRESULT SetConversionStatus(HIMC__* hIMC, uint fdwConversion, uint fdwSentence);
    HRESULT SetOpenStatus(HIMC__* hIMC, BOOL fOpen);
    HRESULT SetStatusWindowPos(HIMC__* hIMC, POINT* pptPos);
    HRESULT SimulateHotKey(HWND hWnd, uint dwHotKeyID);
    HRESULT UnregisterWordA(ptrdiff_t hKL, const(char)* szReading, uint dwStyle, const(char)* szUnregister);
    HRESULT UnregisterWordW(ptrdiff_t hKL, const(wchar)* szReading, uint dwStyle, const(wchar)* szUnregister);
    HRESULT Activate(BOOL fRestoreLayout);
    HRESULT Deactivate();
    HRESULT OnDefWindowProc(HWND hWnd, uint Msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);
    HRESULT FilterClientWindows(ushort* aaClassList, uint uSize);
    HRESULT GetCodePageA(ptrdiff_t hKL, uint* uCodePage);
    HRESULT GetLangId(ptrdiff_t hKL, ushort* plid);
    HRESULT AssociateContextEx(HWND hWnd, HIMC__* hIMC, uint dwFlags);
    HRESULT DisableIME(uint idThread);
    HRESULT GetImeMenuItemsA(HIMC__* hIMC, uint dwFlags, uint dwType, IMEMENUITEMINFOA* pImeParentMenu, 
                             IMEMENUITEMINFOA* pImeMenu, uint dwSize, uint* pdwResult);
    HRESULT GetImeMenuItemsW(HIMC__* hIMC, uint dwFlags, uint dwType, IMEMENUITEMINFOW* pImeParentMenu, 
                             IMEMENUITEMINFOW* pImeMenu, uint dwSize, uint* pdwResult);
    HRESULT EnumInputContext(uint idThread, IEnumInputContext* ppEnum);
}

@GUID("08C03411-F96B-11D0-A475-00AA006BCC59")
interface IActiveIMMIME : IUnknown
{
    HRESULT AssociateContext(HWND hWnd, HIMC__* hIME, HIMC__** phPrev);
    HRESULT ConfigureIMEA(ptrdiff_t hKL, HWND hWnd, uint dwMode, REGISTERWORDA* pData);
    HRESULT ConfigureIMEW(ptrdiff_t hKL, HWND hWnd, uint dwMode, REGISTERWORDW* pData);
    HRESULT CreateContext(HIMC__** phIMC);
    HRESULT DestroyContext(HIMC__* hIME);
    HRESULT EnumRegisterWordA(ptrdiff_t hKL, const(char)* szReading, uint dwStyle, const(char)* szRegister, 
                              void* pData, IEnumRegisterWordA* pEnum);
    HRESULT EnumRegisterWordW(ptrdiff_t hKL, const(wchar)* szReading, uint dwStyle, const(wchar)* szRegister, 
                              void* pData, IEnumRegisterWordW* pEnum);
    HRESULT EscapeA(ptrdiff_t hKL, HIMC__* hIMC, uint uEscape, void* pData, LRESULT* plResult);
    HRESULT EscapeW(ptrdiff_t hKL, HIMC__* hIMC, uint uEscape, void* pData, LRESULT* plResult);
    HRESULT GetCandidateListA(HIMC__* hIMC, uint dwIndex, uint uBufLen, CANDIDATELIST* pCandList, uint* puCopied);
    HRESULT GetCandidateListW(HIMC__* hIMC, uint dwIndex, uint uBufLen, CANDIDATELIST* pCandList, uint* puCopied);
    HRESULT GetCandidateListCountA(HIMC__* hIMC, uint* pdwListSize, uint* pdwBufLen);
    HRESULT GetCandidateListCountW(HIMC__* hIMC, uint* pdwListSize, uint* pdwBufLen);
    HRESULT GetCandidateWindow(HIMC__* hIMC, uint dwIndex, CANDIDATEFORM* pCandidate);
    HRESULT GetCompositionFontA(HIMC__* hIMC, LOGFONTA* plf);
    HRESULT GetCompositionFontW(HIMC__* hIMC, LOGFONTW* plf);
    HRESULT GetCompositionStringA(HIMC__* hIMC, uint dwIndex, uint dwBufLen, int* plCopied, void* pBuf);
    HRESULT GetCompositionStringW(HIMC__* hIMC, uint dwIndex, uint dwBufLen, int* plCopied, void* pBuf);
    HRESULT GetCompositionWindow(HIMC__* hIMC, COMPOSITIONFORM* pCompForm);
    HRESULT GetContext(HWND hWnd, HIMC__** phIMC);
    HRESULT GetConversionListA(ptrdiff_t hKL, HIMC__* hIMC, const(char)* pSrc, uint uBufLen, uint uFlag, 
                               CANDIDATELIST* pDst, uint* puCopied);
    HRESULT GetConversionListW(ptrdiff_t hKL, HIMC__* hIMC, const(wchar)* pSrc, uint uBufLen, uint uFlag, 
                               CANDIDATELIST* pDst, uint* puCopied);
    HRESULT GetConversionStatus(HIMC__* hIMC, uint* pfdwConversion, uint* pfdwSentence);
    HRESULT GetDefaultIMEWnd(HWND hWnd, HWND* phDefWnd);
    HRESULT GetDescriptionA(ptrdiff_t hKL, uint uBufLen, const(char)* szDescription, uint* puCopied);
    HRESULT GetDescriptionW(ptrdiff_t hKL, uint uBufLen, const(wchar)* szDescription, uint* puCopied);
    HRESULT GetGuideLineA(HIMC__* hIMC, uint dwIndex, uint dwBufLen, const(char)* pBuf, uint* pdwResult);
    HRESULT GetGuideLineW(HIMC__* hIMC, uint dwIndex, uint dwBufLen, const(wchar)* pBuf, uint* pdwResult);
    HRESULT GetIMEFileNameA(ptrdiff_t hKL, uint uBufLen, const(char)* szFileName, uint* puCopied);
    HRESULT GetIMEFileNameW(ptrdiff_t hKL, uint uBufLen, const(wchar)* szFileName, uint* puCopied);
    HRESULT GetOpenStatus(HIMC__* hIMC);
    HRESULT GetProperty(ptrdiff_t hKL, uint fdwIndex, uint* pdwProperty);
    HRESULT GetRegisterWordStyleA(ptrdiff_t hKL, uint nItem, STYLEBUFA* pStyleBuf, uint* puCopied);
    HRESULT GetRegisterWordStyleW(ptrdiff_t hKL, uint nItem, STYLEBUFW* pStyleBuf, uint* puCopied);
    HRESULT GetStatusWindowPos(HIMC__* hIMC, POINT* pptPos);
    HRESULT GetVirtualKey(HWND hWnd, uint* puVirtualKey);
    HRESULT InstallIMEA(const(char)* szIMEFileName, const(char)* szLayoutText, ptrdiff_t* phKL);
    HRESULT InstallIMEW(const(wchar)* szIMEFileName, const(wchar)* szLayoutText, ptrdiff_t* phKL);
    HRESULT IsIME(ptrdiff_t hKL);
    HRESULT IsUIMessageA(HWND hWndIME, uint msg, WPARAM wParam, LPARAM lParam);
    HRESULT IsUIMessageW(HWND hWndIME, uint msg, WPARAM wParam, LPARAM lParam);
    HRESULT NotifyIME(HIMC__* hIMC, uint dwAction, uint dwIndex, uint dwValue);
    HRESULT RegisterWordA(ptrdiff_t hKL, const(char)* szReading, uint dwStyle, const(char)* szRegister);
    HRESULT RegisterWordW(ptrdiff_t hKL, const(wchar)* szReading, uint dwStyle, const(wchar)* szRegister);
    HRESULT ReleaseContext(HWND hWnd, HIMC__* hIMC);
    HRESULT SetCandidateWindow(HIMC__* hIMC, CANDIDATEFORM* pCandidate);
    HRESULT SetCompositionFontA(HIMC__* hIMC, LOGFONTA* plf);
    HRESULT SetCompositionFontW(HIMC__* hIMC, LOGFONTW* plf);
    HRESULT SetCompositionStringA(HIMC__* hIMC, uint dwIndex, void* pComp, uint dwCompLen, void* pRead, 
                                  uint dwReadLen);
    HRESULT SetCompositionStringW(HIMC__* hIMC, uint dwIndex, void* pComp, uint dwCompLen, void* pRead, 
                                  uint dwReadLen);
    HRESULT SetCompositionWindow(HIMC__* hIMC, COMPOSITIONFORM* pCompForm);
    HRESULT SetConversionStatus(HIMC__* hIMC, uint fdwConversion, uint fdwSentence);
    HRESULT SetOpenStatus(HIMC__* hIMC, BOOL fOpen);
    HRESULT SetStatusWindowPos(HIMC__* hIMC, POINT* pptPos);
    HRESULT SimulateHotKey(HWND hWnd, uint dwHotKeyID);
    HRESULT UnregisterWordA(ptrdiff_t hKL, const(char)* szReading, uint dwStyle, const(char)* szUnregister);
    HRESULT UnregisterWordW(ptrdiff_t hKL, const(wchar)* szReading, uint dwStyle, const(wchar)* szUnregister);
    HRESULT GenerateMessage(HIMC__* hIMC);
    HRESULT LockIMC(HIMC__* hIMC, __MIDL___MIDL_itf_dimm_0000_0000_0012** ppIMC);
    HRESULT UnlockIMC(HIMC__* hIMC);
    HRESULT GetIMCLockCount(HIMC__* hIMC, uint* pdwLockCount);
    HRESULT CreateIMCC(uint dwSize, HIMCC__** phIMCC);
    HRESULT DestroyIMCC(HIMCC__* hIMCC);
    HRESULT LockIMCC(HIMCC__* hIMCC, void** ppv);
    HRESULT UnlockIMCC(HIMCC__* hIMCC);
    HRESULT ReSizeIMCC(HIMCC__* hIMCC, uint dwSize, HIMCC__** phIMCC);
    HRESULT GetIMCCSize(HIMCC__* hIMCC, uint* pdwSize);
    HRESULT GetIMCCLockCount(HIMCC__* hIMCC, uint* pdwLockCount);
    HRESULT GetHotKey(uint dwHotKeyID, uint* puModifiers, uint* puVKey, ptrdiff_t* phKL);
    HRESULT SetHotKey(uint dwHotKeyID, uint uModifiers, uint uVKey, ptrdiff_t hKL);
    HRESULT CreateSoftKeyboard(uint uType, HWND hOwner, int x, int y, HWND* phSoftKbdWnd);
    HRESULT DestroySoftKeyboard(HWND hSoftKbdWnd);
    HRESULT ShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow);
    HRESULT GetCodePageA(ptrdiff_t hKL, uint* uCodePage);
    HRESULT GetLangId(ptrdiff_t hKL, ushort* plid);
    HRESULT KeybdEvent(ushort lgidIME, ubyte bVk, ubyte bScan, uint dwFlags, uint dwExtraInfo);
    HRESULT LockModal();
    HRESULT UnlockModal();
    HRESULT AssociateContextEx(HWND hWnd, HIMC__* hIMC, uint dwFlags);
    HRESULT DisableIME(uint idThread);
    HRESULT GetImeMenuItemsA(HIMC__* hIMC, uint dwFlags, uint dwType, IMEMENUITEMINFOA* pImeParentMenu, 
                             IMEMENUITEMINFOA* pImeMenu, uint dwSize, uint* pdwResult);
    HRESULT GetImeMenuItemsW(HIMC__* hIMC, uint dwFlags, uint dwType, IMEMENUITEMINFOW* pImeParentMenu, 
                             IMEMENUITEMINFOW* pImeMenu, uint dwSize, uint* pdwResult);
    HRESULT EnumInputContext(uint idThread, IEnumInputContext* ppEnum);
    HRESULT RequestMessageA(HIMC__* hIMC, WPARAM wParam, LPARAM lParam, LRESULT* plResult);
    HRESULT RequestMessageW(HIMC__* hIMC, WPARAM wParam, LPARAM lParam, LRESULT* plResult);
    HRESULT SendIMCA(HWND hWnd, uint uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);
    HRESULT SendIMCW(HWND hWnd, uint uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);
    HRESULT IsSleeping();
}

@GUID("6FE20962-D077-11D0-8FE7-00AA006BCC59")
interface IActiveIME : IUnknown
{
    HRESULT Inquire(uint dwSystemInfoFlags, __MIDL___MIDL_itf_dimm_0000_0000_0014* pIMEInfo, 
                    const(wchar)* szWndClass, uint* pdwPrivate);
    HRESULT ConversionList(HIMC__* hIMC, const(wchar)* szSource, uint uFlag, uint uBufLen, CANDIDATELIST* pDest, 
                           uint* puCopied);
    HRESULT Configure(ptrdiff_t hKL, HWND hWnd, uint dwMode, REGISTERWORDW* pRegisterWord);
    HRESULT Destroy(uint uReserved);
    HRESULT Escape(HIMC__* hIMC, uint uEscape, void* pData, LRESULT* plResult);
    HRESULT SetActiveContext(HIMC__* hIMC, BOOL fFlag);
    HRESULT ProcessKey(HIMC__* hIMC, uint uVirKey, uint lParam, ubyte* pbKeyState);
    HRESULT Notify(HIMC__* hIMC, uint dwAction, uint dwIndex, uint dwValue);
    HRESULT Select(HIMC__* hIMC, BOOL fSelect);
    HRESULT SetCompositionString(HIMC__* hIMC, uint dwIndex, void* pComp, uint dwCompLen, void* pRead, 
                                 uint dwReadLen);
    HRESULT ToAsciiEx(uint uVirKey, uint uScanCode, ubyte* pbKeyState, uint fuState, HIMC__* hIMC, 
                      uint* pdwTransBuf, uint* puSize);
    HRESULT RegisterWord(const(wchar)* szReading, uint dwStyle, const(wchar)* szString);
    HRESULT UnregisterWord(const(wchar)* szReading, uint dwStyle, const(wchar)* szString);
    HRESULT GetRegisterWordStyle(uint nItem, STYLEBUFW* pStyleBuf, uint* puBufSize);
    HRESULT EnumRegisterWord(const(wchar)* szReading, uint dwStyle, const(wchar)* szRegister, void* pData, 
                             IEnumRegisterWordW* ppEnum);
    HRESULT GetCodePageA(uint* uCodePage);
    HRESULT GetLangId(ushort* plid);
}

@GUID("E1C4BF0E-2D53-11D2-93E1-0060B067B86E")
interface IActiveIME2 : IActiveIME
{
    HRESULT Sleep();
    HRESULT Unsleep(BOOL fDead);
}

///Provides access to the collection of open Shell windows.
@GUID("85CB6900-4D95-11CF-960C-0080C7F4EE85")
interface IShellWindows : IDispatch
{
    ///Gets the number of windows in the Shell windows collection.
    ///Params:
    ///    Count = Type: <b>long*</b> The number of windows in the Shell windows collection.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Count(int* Count);
    ///Returns the registered Shell window for a specified index.
    ///Params:
    ///    index = Type: <b>VARIANT</b> A VARIANT of type VT_UI4, VT_I2, or VT_I4. If the type is VT_UI4, the value of
    ///            <i>index</i> is interpreted as a member of ShellWindowTypeConstants; in this case, <b>Item</b> returns the
    ///            window that is closest to the foreground window and has a matching type. If the type is VT_I, or VT_I4,
    ///            <i>index</i> is treated as an index into the Shell windows collection.
    ///    Folder = Type: <b>IDispatch**</b> A reference to the window's IDispatch interface, or <b>NULL</b> if the specified
    ///             window was not found.
    ///Returns:
    ///    Type: <b>HRESULT</b> One of the following values, or a standard result code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The specified window was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt>
    ///    </dl> </td> <td width="60%"> The specified window was not found. </td> </tr> </table>
    ///    
    HRESULT Item(VARIANT index, IDispatch* Folder);
    ///Retrieves an enumerator for the collection of Shell windows.
    ///Params:
    ///    ppunk = Type: <b>IUnknown**</b> When this method returns, contains an interface pointer to an object that implements
    ///            the IEnumVARIANT interface.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT _NewEnum(IUnknown* ppunk);
    ///Registers an open window as a Shell window; the window is specified by handle.
    ///Params:
    ///    pid = Type: <b>IDispatch*</b> The window's IDispatch interface.
    ///    hwnd = Type: <b>long</b> A handle that specifies the window to register.
    ///    swClass = Type: <b>int</b> A member of ShellWindowTypeConstants that specifies the type of window.
    ///    plCookie = Type: <b>long*</b> The window's cookie.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Register(IDispatch pid, int hwnd, int swClass, int* plCookie);
    ///Registers a pending window as a Shell window; the window is specified by an absolute PIDL.
    ///Params:
    ///    lThreadId = A thread ID.
    ///    pvarloc = Type: <b>VARIANT*</b> A VARIANT of type VT_VARIANT | VT_BYREF. Set the value of <i>pvarloc</i> to an absolute
    ///              PIDL (PIDLIST_ABSOLUTE) that specifies the window to register.
    ///    pvarlocRoot = Type: <b>VARIANT*</b> Must be <b>NULL</b> or of type VT_EMPTY.
    ///    swClass = Type: <b>int</b> A member of ShellWindowTypeConstants that specifies the type of window.
    ///    plCookie = Type: <b>long*</b> The window's cookie.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RegisterPending(int lThreadId, VARIANT* pvarloc, VARIANT* pvarlocRoot, int swClass, int* plCookie);
    ///Revokes a Shell window's registration and removes the window from the Shell windows collection.
    ///Params:
    ///    lCookie = Type: <b>long*</b> The cookie that identifies the window to un-register.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Revoke(int lCookie);
    ///Occurs when a Shell window is navigated to a new location.
    ///Params:
    ///    lCookie = Type: <b>long</b> The cookie that identifies the window.
    ///    pvarLoc = Type: <b>VARIANT*</b> A VARIANT of type VT_VARIANT | VT_BYREF. Set the value of <i>pvarLoc</i> to an absolute
    ///              PIDL (PIDLIST_ABSOLUTE) that specifies the new location.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnNavigate(int lCookie, VARIANT* pvarLoc);
    ///Occurs when a Shell window's activation state changes.
    ///Params:
    ///    lCookie = Type: <b>long</b> The cookie that identifies the window.
    ///    fActive = Type: <b>VARIANT_BOOL</b> <b>TRUE</b> if the window is being activated; <b>FALSE</b> if the window is being
    ///              deactivated.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnActivated(int lCookie, short fActive);
    ///Finds a window in the Shell windows collection and returns the window's handle and IDispatch interface.
    ///Params:
    ///    pvarLoc = Type: <b>VARIANT*</b> A VARIANT of type VT_VARIANT | VT_BYREF. Set the value of <i>pvarLoc</i> to an absolute
    ///              PIDL (PIDLIST_ABSOLUTE) that specifies the window to find. (See remarks.)
    ///    pvarLocRoot = Type: <b>VARIANT*</b> Must be <b>NULL</b> or of type VT_EMPTY.
    ///    swClass = Type: <b>int</b> One or more ShellWindowTypeConstants flags that specify window types to include in the
    ///              search.
    ///    phwnd = Type: <b>long*</b> A handle for the window matching the specified search criteria, or <b>NULL</b> if no such
    ///            window was found.
    ///    swfwOptions = Type: <b>int</b> One or more ShellWindowFindWindowOptions flags that specify search options.
    ///    ppdispOut = Type: <b>IDispatch**</b> A reference to the window's IDispatch interface, or <b>NULL</b> if no such window
    ///                was found.
    ///Returns:
    ///    Type: <b>HRESULT</b> One of the following values, or a standard result code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> A window matching the specified search criteria was found. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> A window matching the specified search criteria was
    ///    not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%">
    ///    A window was found, but a reference to the window's IDispatch interface could not be obtained. Only occurs if
    ///    the SWFO_NEEDDISPATCH flag is set. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PENDING</b></dt> </dl>
    ///    </td> <td width="60%"> A window was found, but the window is pending open. Only occurs if the
    ///    SWFO_INCLUDEPENDING flag is set. </td> </tr> </table>
    ///    
    HRESULT FindWindowSW(VARIANT* pvarLoc, VARIANT* pvarLocRoot, int swClass, int* phwnd, int swfwOptions, 
                         IDispatch* ppdispOut);
    ///Occurs when a new Shell window is created for a frame.
    ///Params:
    ///    lCookie = Type: <b>long</b> The cookie that identifies the window.
    ///    punk = Type: <b>IUnknown*</b> The address of the new window's IUnknown interface.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnCreated(int lCookie, IUnknown punk);
    ///Deprecated. Always returns S_OK.
    ///Params:
    ///    fAttach = Type: <b>VARIANT_BOOL</b> Not used.
    HRESULT ProcessAttachDetach(short fAttach);
}


// GUIDs

const GUID CLSID_AccessibilityDockingService          = GUIDOF!AccessibilityDockingService;
const GUID CLSID_AlphabeticalCategorizer              = GUIDOF!AlphabeticalCategorizer;
const GUID CLSID_AppShellVerbHandler                  = GUIDOF!AppShellVerbHandler;
const GUID CLSID_AppStartupLink                       = GUIDOF!AppStartupLink;
const GUID CLSID_AppVisibility                        = GUIDOF!AppVisibility;
const GUID CLSID_ApplicationActivationManager         = GUIDOF!ApplicationActivationManager;
const GUID CLSID_ApplicationAssociationRegistration   = GUIDOF!ApplicationAssociationRegistration;
const GUID CLSID_ApplicationAssociationRegistrationUI = GUIDOF!ApplicationAssociationRegistrationUI;
const GUID CLSID_ApplicationDesignModeSettings        = GUIDOF!ApplicationDesignModeSettings;
const GUID CLSID_ApplicationDestinations              = GUIDOF!ApplicationDestinations;
const GUID CLSID_ApplicationDocumentLists             = GUIDOF!ApplicationDocumentLists;
const GUID CLSID_AttachmentServices                   = GUIDOF!AttachmentServices;
const GUID CLSID_CActiveIMM                           = GUIDOF!CActiveIMM;
const GUID CLSID_CDBurn                               = GUIDOF!CDBurn;
const GUID CLSID_ConflictFolder                       = GUIDOF!ConflictFolder;
const GUID CLSID_DefFolderMenu                        = GUIDOF!DefFolderMenu;
const GUID CLSID_DesktopGadget                        = GUIDOF!DesktopGadget;
const GUID CLSID_DesktopWallpaper                     = GUIDOF!DesktopWallpaper;
const GUID CLSID_DestinationList                      = GUIDOF!DestinationList;
const GUID CLSID_DocPropShellExtension                = GUIDOF!DocPropShellExtension;
const GUID CLSID_DriveSizeCategorizer                 = GUIDOF!DriveSizeCategorizer;
const GUID CLSID_DriveTypeCategorizer                 = GUIDOF!DriveTypeCategorizer;
const GUID CLSID_EnumerableObjectCollection           = GUIDOF!EnumerableObjectCollection;
const GUID CLSID_ExecuteFolder                        = GUIDOF!ExecuteFolder;
const GUID CLSID_ExecuteUnknown                       = GUIDOF!ExecuteUnknown;
const GUID CLSID_ExplorerBrowser                      = GUIDOF!ExplorerBrowser;
const GUID CLSID_FSCopyHandler                        = GUIDOF!FSCopyHandler;
const GUID CLSID_FileOpenDialog                       = GUIDOF!FileOpenDialog;
const GUID CLSID_FileOperation                        = GUIDOF!FileOperation;
const GUID CLSID_FileSaveDialog                       = GUIDOF!FileSaveDialog;
const GUID CLSID_FileSearchBand                       = GUIDOF!FileSearchBand;
const GUID CLSID_FolderViewHost                       = GUIDOF!FolderViewHost;
const GUID CLSID_FrameworkInputPane                   = GUIDOF!FrameworkInputPane;
const GUID CLSID_FreeSpaceCategorizer                 = GUIDOF!FreeSpaceCategorizer;
const GUID CLSID_GenericCredentialProvider            = GUIDOF!GenericCredentialProvider;
const GUID CLSID_HomeGroup                            = GUIDOF!HomeGroup;
const GUID CLSID_IENamespaceTreeControl               = GUIDOF!IENamespaceTreeControl;
const GUID CLSID_ImageProperties                      = GUIDOF!ImageProperties;
const GUID CLSID_ImageRecompress                      = GUIDOF!ImageRecompress;
const GUID CLSID_ImageTranscode                       = GUIDOF!ImageTranscode;
const GUID CLSID_InputPanelConfiguration              = GUIDOF!InputPanelConfiguration;
const GUID CLSID_InternetPrintOrdering                = GUIDOF!InternetPrintOrdering;
const GUID CLSID_KnownFolderManager                   = GUIDOF!KnownFolderManager;
const GUID CLSID_LocalThumbnailCache                  = GUIDOF!LocalThumbnailCache;
const GUID CLSID_MailRecipient                        = GUIDOF!MailRecipient;
const GUID CLSID_MergedCategorizer                    = GUIDOF!MergedCategorizer;
const GUID CLSID_NPCredentialProvider                 = GUIDOF!NPCredentialProvider;
const GUID CLSID_NamespaceTreeControl                 = GUIDOF!NamespaceTreeControl;
const GUID CLSID_NamespaceWalker                      = GUIDOF!NamespaceWalker;
const GUID CLSID_NetworkConnections                   = GUIDOF!NetworkConnections;
const GUID CLSID_NetworkExplorerFolder                = GUIDOF!NetworkExplorerFolder;
const GUID CLSID_NetworkPlaces                        = GUIDOF!NetworkPlaces;
const GUID CLSID_OnexCredentialProvider               = GUIDOF!OnexCredentialProvider;
const GUID CLSID_OnexPlapSmartcardCredentialProvider  = GUIDOF!OnexPlapSmartcardCredentialProvider;
const GUID CLSID_OpenControlPanel                     = GUIDOF!OpenControlPanel;
const GUID CLSID_PINLogonCredentialProvider           = GUIDOF!PINLogonCredentialProvider;
const GUID CLSID_PackageDebugSettings                 = GUIDOF!PackageDebugSettings;
const GUID CLSID_PasswordCredentialProvider           = GUIDOF!PasswordCredentialProvider;
const GUID CLSID_PreviousVersions                     = GUIDOF!PreviousVersions;
const GUID CLSID_PropertiesUI                         = GUIDOF!PropertiesUI;
const GUID CLSID_PublishDropTarget                    = GUIDOF!PublishDropTarget;
const GUID CLSID_PublishingWizard                     = GUIDOF!PublishingWizard;
const GUID CLSID_QueryCancelAutoPlay                  = GUIDOF!QueryCancelAutoPlay;
const GUID CLSID_RASProvider                          = GUIDOF!RASProvider;
const GUID CLSID_ScheduledTasks                       = GUIDOF!ScheduledTasks;
const GUID CLSID_SearchFolderItemFactory              = GUIDOF!SearchFolderItemFactory;
const GUID CLSID_SharedBitmap                         = GUIDOF!SharedBitmap;
const GUID CLSID_SharingConfigurationManager          = GUIDOF!SharingConfigurationManager;
const GUID CLSID_Shell                                = GUIDOF!Shell;
const GUID CLSID_ShellDesktop                         = GUIDOF!ShellDesktop;
const GUID CLSID_ShellDispatchInproc                  = GUIDOF!ShellDispatchInproc;
const GUID CLSID_ShellFSFolder                        = GUIDOF!ShellFSFolder;
const GUID CLSID_ShellFolderItem                      = GUIDOF!ShellFolderItem;
const GUID CLSID_ShellFolderView                      = GUIDOF!ShellFolderView;
const GUID CLSID_ShellFolderViewOC                    = GUIDOF!ShellFolderViewOC;
const GUID CLSID_ShellImageDataFactory                = GUIDOF!ShellImageDataFactory;
const GUID CLSID_ShellItem                            = GUIDOF!ShellItem;
const GUID CLSID_ShellLibrary                         = GUIDOF!ShellLibrary;
const GUID CLSID_ShellLink                            = GUIDOF!ShellLink;
const GUID CLSID_ShellLinkObject                      = GUIDOF!ShellLinkObject;
const GUID CLSID_SimpleConflictPresenter              = GUIDOF!SimpleConflictPresenter;
const GUID CLSID_SizeCategorizer                      = GUIDOF!SizeCategorizer;
const GUID CLSID_SmartcardCredentialProvider          = GUIDOF!SmartcardCredentialProvider;
const GUID CLSID_SmartcardPinProvider                 = GUIDOF!SmartcardPinProvider;
const GUID CLSID_SmartcardReaderSelectionProvider     = GUIDOF!SmartcardReaderSelectionProvider;
const GUID CLSID_SmartcardWinRTProvider               = GUIDOF!SmartcardWinRTProvider;
const GUID CLSID_StartMenuPin                         = GUIDOF!StartMenuPin;
const GUID CLSID_StorageProviderBanners               = GUIDOF!StorageProviderBanners;
const GUID CLSID_SuspensionDependencyManager          = GUIDOF!SuspensionDependencyManager;
const GUID CLSID_SyncMgr                              = GUIDOF!SyncMgr;
const GUID CLSID_SyncMgrClient                        = GUIDOF!SyncMgrClient;
const GUID CLSID_SyncMgrControl                       = GUIDOF!SyncMgrControl;
const GUID CLSID_SyncMgrFolder                        = GUIDOF!SyncMgrFolder;
const GUID CLSID_SyncMgrScheduleWizard                = GUIDOF!SyncMgrScheduleWizard;
const GUID CLSID_SyncResultsFolder                    = GUIDOF!SyncResultsFolder;
const GUID CLSID_SyncSetupFolder                      = GUIDOF!SyncSetupFolder;
const GUID CLSID_TaskbarList                          = GUIDOF!TaskbarList;
const GUID CLSID_ThumbnailStreamCache                 = GUIDOF!ThumbnailStreamCache;
const GUID CLSID_TimeCategorizer                      = GUIDOF!TimeCategorizer;
const GUID CLSID_TrackShellMenu                       = GUIDOF!TrackShellMenu;
const GUID CLSID_TrayBandSiteService                  = GUIDOF!TrayBandSiteService;
const GUID CLSID_TrayDeskBand                         = GUIDOF!TrayDeskBand;
const GUID CLSID_UserNotification                     = GUIDOF!UserNotification;
const GUID CLSID_V1PasswordCredentialProvider         = GUIDOF!V1PasswordCredentialProvider;
const GUID CLSID_V1SmartcardCredentialProvider        = GUIDOF!V1SmartcardCredentialProvider;
const GUID CLSID_V1WinBioCredentialProvider           = GUIDOF!V1WinBioCredentialProvider;
const GUID CLSID_VaultProvider                        = GUIDOF!VaultProvider;
const GUID CLSID_VirtualDesktopManager                = GUIDOF!VirtualDesktopManager;
const GUID CLSID_WebWizardHost                        = GUIDOF!WebWizardHost;
const GUID CLSID_WinBioCredentialProvider             = GUIDOF!WinBioCredentialProvider;

const GUID IID_DFConstraint                                  = GUIDOF!DFConstraint;
const GUID IID_DShellFolderViewEvents                        = GUIDOF!DShellFolderViewEvents;
const GUID IID_Folder                                        = GUIDOF!Folder;
const GUID IID_Folder2                                       = GUIDOF!Folder2;
const GUID IID_Folder3                                       = GUIDOF!Folder3;
const GUID IID_FolderItem                                    = GUIDOF!FolderItem;
const GUID IID_FolderItem2                                   = GUIDOF!FolderItem2;
const GUID IID_FolderItemVerb                                = GUIDOF!FolderItemVerb;
const GUID IID_FolderItemVerbs                               = GUIDOF!FolderItemVerbs;
const GUID IID_FolderItems                                   = GUIDOF!FolderItems;
const GUID IID_FolderItems2                                  = GUIDOF!FolderItems2;
const GUID IID_FolderItems3                                  = GUIDOF!FolderItems3;
const GUID IID_IACList                                       = GUIDOF!IACList;
const GUID IID_IACList2                                      = GUIDOF!IACList2;
const GUID IID_IAccessibleObject                             = GUIDOF!IAccessibleObject;
const GUID IID_IActionProgress                               = GUIDOF!IActionProgress;
const GUID IID_IActionProgressDialog                         = GUIDOF!IActionProgressDialog;
const GUID IID_IActiveIME                                    = GUIDOF!IActiveIME;
const GUID IID_IActiveIME2                                   = GUIDOF!IActiveIME2;
const GUID IID_IActiveIMMApp                                 = GUIDOF!IActiveIMMApp;
const GUID IID_IActiveIMMIME                                 = GUIDOF!IActiveIMMIME;
const GUID IID_IActiveIMMMessagePumpOwner                    = GUIDOF!IActiveIMMMessagePumpOwner;
const GUID IID_IActiveIMMRegistrar                           = GUIDOF!IActiveIMMRegistrar;
const GUID IID_IAppActivationUIInfo                          = GUIDOF!IAppActivationUIInfo;
const GUID IID_IAppPublisher                                 = GUIDOF!IAppPublisher;
const GUID IID_IAppVisibility                                = GUIDOF!IAppVisibility;
const GUID IID_IAppVisibilityEvents                          = GUIDOF!IAppVisibilityEvents;
const GUID IID_IApplicationActivationManager                 = GUIDOF!IApplicationActivationManager;
const GUID IID_IApplicationAssociationRegistration           = GUIDOF!IApplicationAssociationRegistration;
const GUID IID_IApplicationAssociationRegistrationUI         = GUIDOF!IApplicationAssociationRegistrationUI;
const GUID IID_IApplicationDesignModeSettings                = GUIDOF!IApplicationDesignModeSettings;
const GUID IID_IApplicationDesignModeSettings2               = GUIDOF!IApplicationDesignModeSettings2;
const GUID IID_IApplicationDestinations                      = GUIDOF!IApplicationDestinations;
const GUID IID_IApplicationDocumentLists                     = GUIDOF!IApplicationDocumentLists;
const GUID IID_IAssocHandler                                 = GUIDOF!IAssocHandler;
const GUID IID_IAssocHandlerInvoker                          = GUIDOF!IAssocHandlerInvoker;
const GUID IID_IAttachmentExecute                            = GUIDOF!IAttachmentExecute;
const GUID IID_IAutoComplete                                 = GUIDOF!IAutoComplete;
const GUID IID_IAutoComplete2                                = GUIDOF!IAutoComplete2;
const GUID IID_IAutoCompleteDropDown                         = GUIDOF!IAutoCompleteDropDown;
const GUID IID_IBandHost                                     = GUIDOF!IBandHost;
const GUID IID_IBandSite                                     = GUIDOF!IBandSite;
const GUID IID_IBannerNotificationHandler                    = GUIDOF!IBannerNotificationHandler;
const GUID IID_IBanneredBar                                  = GUIDOF!IBanneredBar;
const GUID IID_IBrowserFrameOptions                          = GUIDOF!IBrowserFrameOptions;
const GUID IID_IBrowserService                               = GUIDOF!IBrowserService;
const GUID IID_IBrowserService2                              = GUIDOF!IBrowserService2;
const GUID IID_IBrowserService3                              = GUIDOF!IBrowserService3;
const GUID IID_IBrowserService4                              = GUIDOF!IBrowserService4;
const GUID IID_ICDBurn                                       = GUIDOF!ICDBurn;
const GUID IID_ICDBurnExt                                    = GUIDOF!ICDBurnExt;
const GUID IID_ICategorizer                                  = GUIDOF!ICategorizer;
const GUID IID_ICategoryProvider                             = GUIDOF!ICategoryProvider;
const GUID IID_IColumnManager                                = GUIDOF!IColumnManager;
const GUID IID_IColumnProvider                               = GUIDOF!IColumnProvider;
const GUID IID_ICommDlgBrowser                               = GUIDOF!ICommDlgBrowser;
const GUID IID_ICommDlgBrowser2                              = GUIDOF!ICommDlgBrowser2;
const GUID IID_ICommDlgBrowser3                              = GUIDOF!ICommDlgBrowser3;
const GUID IID_IComputerInfoChangeNotify                     = GUIDOF!IComputerInfoChangeNotify;
const GUID IID_IConnectableCredentialProviderCredential      = GUIDOF!IConnectableCredentialProviderCredential;
const GUID IID_IContactManagerInterop                        = GUIDOF!IContactManagerInterop;
const GUID IID_IContextMenu                                  = GUIDOF!IContextMenu;
const GUID IID_IContextMenu2                                 = GUIDOF!IContextMenu2;
const GUID IID_IContextMenu3                                 = GUIDOF!IContextMenu3;
const GUID IID_IContextMenuCB                                = GUIDOF!IContextMenuCB;
const GUID IID_IContextMenuSite                              = GUIDOF!IContextMenuSite;
const GUID IID_ICopyHookA                                    = GUIDOF!ICopyHookA;
const GUID IID_ICopyHookW                                    = GUIDOF!ICopyHookW;
const GUID IID_ICreateObject                                 = GUIDOF!ICreateObject;
const GUID IID_ICreateProcessInputs                          = GUIDOF!ICreateProcessInputs;
const GUID IID_ICreatingProcess                              = GUIDOF!ICreatingProcess;
const GUID IID_ICredentialProvider                           = GUIDOF!ICredentialProvider;
const GUID IID_ICredentialProviderCredential                 = GUIDOF!ICredentialProviderCredential;
const GUID IID_ICredentialProviderCredential2                = GUIDOF!ICredentialProviderCredential2;
const GUID IID_ICredentialProviderCredentialEvents           = GUIDOF!ICredentialProviderCredentialEvents;
const GUID IID_ICredentialProviderCredentialEvents2          = GUIDOF!ICredentialProviderCredentialEvents2;
const GUID IID_ICredentialProviderCredentialWithFieldOptions = GUIDOF!ICredentialProviderCredentialWithFieldOptions;
const GUID IID_ICredentialProviderEvents                     = GUIDOF!ICredentialProviderEvents;
const GUID IID_ICredentialProviderFilter                     = GUIDOF!ICredentialProviderFilter;
const GUID IID_ICredentialProviderSetUserArray               = GUIDOF!ICredentialProviderSetUserArray;
const GUID IID_ICredentialProviderUser                       = GUIDOF!ICredentialProviderUser;
const GUID IID_ICredentialProviderUserArray                  = GUIDOF!ICredentialProviderUserArray;
const GUID IID_ICurrentItem                                  = GUIDOF!ICurrentItem;
const GUID IID_ICurrentWorkingDirectory                      = GUIDOF!ICurrentWorkingDirectory;
const GUID IID_ICustomDestinationList                        = GUIDOF!ICustomDestinationList;
const GUID IID_IDataObjectAsyncCapability                    = GUIDOF!IDataObjectAsyncCapability;
const GUID IID_IDataObjectProvider                           = GUIDOF!IDataObjectProvider;
const GUID IID_IDataTransferManagerInterop                   = GUIDOF!IDataTransferManagerInterop;
const GUID IID_IDefaultExtractIconInit                       = GUIDOF!IDefaultExtractIconInit;
const GUID IID_IDefaultFolderMenuInitialize                  = GUIDOF!IDefaultFolderMenuInitialize;
const GUID IID_IDelayedPropertyStoreFactory                  = GUIDOF!IDelayedPropertyStoreFactory;
const GUID IID_IDelegateFolder                               = GUIDOF!IDelegateFolder;
const GUID IID_IDelegateItem                                 = GUIDOF!IDelegateItem;
const GUID IID_IDeskBand                                     = GUIDOF!IDeskBand;
const GUID IID_IDeskBand2                                    = GUIDOF!IDeskBand2;
const GUID IID_IDeskBandInfo                                 = GUIDOF!IDeskBandInfo;
const GUID IID_IDeskBar                                      = GUIDOF!IDeskBar;
const GUID IID_IDeskBarClient                                = GUIDOF!IDeskBarClient;
const GUID IID_IDesktopGadget                                = GUIDOF!IDesktopGadget;
const GUID IID_IDesktopWallpaper                             = GUIDOF!IDesktopWallpaper;
const GUID IID_IDestinationStreamFactory                     = GUIDOF!IDestinationStreamFactory;
const GUID IID_IDisplayItem                                  = GUIDOF!IDisplayItem;
const GUID IID_IDocViewSite                                  = GUIDOF!IDocViewSite;
const GUID IID_IDockingWindow                                = GUIDOF!IDockingWindow;
const GUID IID_IDockingWindowFrame                           = GUIDOF!IDockingWindowFrame;
const GUID IID_IDockingWindowSite                            = GUIDOF!IDockingWindowSite;
const GUID IID_IDragSourceHelper                             = GUIDOF!IDragSourceHelper;
const GUID IID_IDragSourceHelper2                            = GUIDOF!IDragSourceHelper2;
const GUID IID_IDropTargetHelper                             = GUIDOF!IDropTargetHelper;
const GUID IID_IDynamicHWHandler                             = GUIDOF!IDynamicHWHandler;
const GUID IID_IEnumACString                                 = GUIDOF!IEnumACString;
const GUID IID_IEnumAssocHandlers                            = GUIDOF!IEnumAssocHandlers;
const GUID IID_IEnumExplorerCommand                          = GUIDOF!IEnumExplorerCommand;
const GUID IID_IEnumExtraSearch                              = GUIDOF!IEnumExtraSearch;
const GUID IID_IEnumFullIDList                               = GUIDOF!IEnumFullIDList;
const GUID IID_IEnumHLITEM                                   = GUIDOF!IEnumHLITEM;
const GUID IID_IEnumIDList                                   = GUIDOF!IEnumIDList;
const GUID IID_IEnumInputContext                             = GUIDOF!IEnumInputContext;
const GUID IID_IEnumObjects                                  = GUIDOF!IEnumObjects;
const GUID IID_IEnumPublishedApps                            = GUIDOF!IEnumPublishedApps;
const GUID IID_IEnumReadyCallback                            = GUIDOF!IEnumReadyCallback;
const GUID IID_IEnumRegisterWordA                            = GUIDOF!IEnumRegisterWordA;
const GUID IID_IEnumRegisterWordW                            = GUIDOF!IEnumRegisterWordW;
const GUID IID_IEnumResources                                = GUIDOF!IEnumResources;
const GUID IID_IEnumShellItems                               = GUIDOF!IEnumShellItems;
const GUID IID_IEnumSyncMgrConflict                          = GUIDOF!IEnumSyncMgrConflict;
const GUID IID_IEnumSyncMgrEvents                            = GUIDOF!IEnumSyncMgrEvents;
const GUID IID_IEnumSyncMgrSyncItems                         = GUIDOF!IEnumSyncMgrSyncItems;
const GUID IID_IEnumTravelLogEntry                           = GUIDOF!IEnumTravelLogEntry;
const GUID IID_IEnumerableView                               = GUIDOF!IEnumerableView;
const GUID IID_IExecuteCommand                               = GUIDOF!IExecuteCommand;
const GUID IID_IExecuteCommandApplicationHostEnvironment     = GUIDOF!IExecuteCommandApplicationHostEnvironment;
const GUID IID_IExecuteCommandHost                           = GUIDOF!IExecuteCommandHost;
const GUID IID_IExpDispSupport                               = GUIDOF!IExpDispSupport;
const GUID IID_IExpDispSupportXP                             = GUIDOF!IExpDispSupportXP;
const GUID IID_IExplorerBrowser                              = GUIDOF!IExplorerBrowser;
const GUID IID_IExplorerBrowserEvents                        = GUIDOF!IExplorerBrowserEvents;
const GUID IID_IExplorerCommand                              = GUIDOF!IExplorerCommand;
const GUID IID_IExplorerCommandProvider                      = GUIDOF!IExplorerCommandProvider;
const GUID IID_IExplorerCommandState                         = GUIDOF!IExplorerCommandState;
const GUID IID_IExplorerPaneVisibility                       = GUIDOF!IExplorerPaneVisibility;
const GUID IID_IExtensionServices                            = GUIDOF!IExtensionServices;
const GUID IID_IExtractIconA                                 = GUIDOF!IExtractIconA;
const GUID IID_IExtractIconW                                 = GUIDOF!IExtractIconW;
const GUID IID_IExtractImage                                 = GUIDOF!IExtractImage;
const GUID IID_IExtractImage2                                = GUIDOF!IExtractImage2;
const GUID IID_IFileDialog                                   = GUIDOF!IFileDialog;
const GUID IID_IFileDialog2                                  = GUIDOF!IFileDialog2;
const GUID IID_IFileDialogControlEvents                      = GUIDOF!IFileDialogControlEvents;
const GUID IID_IFileDialogCustomize                          = GUIDOF!IFileDialogCustomize;
const GUID IID_IFileDialogEvents                             = GUIDOF!IFileDialogEvents;
const GUID IID_IFileIsInUse                                  = GUIDOF!IFileIsInUse;
const GUID IID_IFileOpenDialog                               = GUIDOF!IFileOpenDialog;
const GUID IID_IFileOperation                                = GUIDOF!IFileOperation;
const GUID IID_IFileOperation2                               = GUIDOF!IFileOperation2;
const GUID IID_IFileOperationProgressSink                    = GUIDOF!IFileOperationProgressSink;
const GUID IID_IFileSaveDialog                               = GUIDOF!IFileSaveDialog;
const GUID IID_IFileSearchBand                               = GUIDOF!IFileSearchBand;
const GUID IID_IFileSyncMergeHandler                         = GUIDOF!IFileSyncMergeHandler;
const GUID IID_IFileSystemBindData                           = GUIDOF!IFileSystemBindData;
const GUID IID_IFileSystemBindData2                          = GUIDOF!IFileSystemBindData2;
const GUID IID_IFolderBandPriv                               = GUIDOF!IFolderBandPriv;
const GUID IID_IFolderFilter                                 = GUIDOF!IFolderFilter;
const GUID IID_IFolderFilterSite                             = GUIDOF!IFolderFilterSite;
const GUID IID_IFolderView                                   = GUIDOF!IFolderView;
const GUID IID_IFolderView2                                  = GUIDOF!IFolderView2;
const GUID IID_IFolderViewHost                               = GUIDOF!IFolderViewHost;
const GUID IID_IFolderViewOC                                 = GUIDOF!IFolderViewOC;
const GUID IID_IFolderViewOptions                            = GUIDOF!IFolderViewOptions;
const GUID IID_IFolderViewSettings                           = GUIDOF!IFolderViewSettings;
const GUID IID_IFrameworkInputPane                           = GUIDOF!IFrameworkInputPane;
const GUID IID_IFrameworkInputPaneHandler                    = GUIDOF!IFrameworkInputPaneHandler;
const GUID IID_IHWEventHandler                               = GUIDOF!IHWEventHandler;
const GUID IID_IHWEventHandler2                              = GUIDOF!IHWEventHandler2;
const GUID IID_IHandlerActivationHost                        = GUIDOF!IHandlerActivationHost;
const GUID IID_IHandlerInfo                                  = GUIDOF!IHandlerInfo;
const GUID IID_IHandlerInfo2                                 = GUIDOF!IHandlerInfo2;
const GUID IID_IHlink                                        = GUIDOF!IHlink;
const GUID IID_IHlinkBrowseContext                           = GUIDOF!IHlinkBrowseContext;
const GUID IID_IHlinkFrame                                   = GUIDOF!IHlinkFrame;
const GUID IID_IHlinkSite                                    = GUIDOF!IHlinkSite;
const GUID IID_IHlinkTarget                                  = GUIDOF!IHlinkTarget;
const GUID IID_IHomeGroup                                    = GUIDOF!IHomeGroup;
const GUID IID_IIOCancelInformation                          = GUIDOF!IIOCancelInformation;
const GUID IID_IIdentityName                                 = GUIDOF!IIdentityName;
const GUID IID_IImageRecompress                              = GUIDOF!IImageRecompress;
const GUID IID_IInitializeCommand                            = GUIDOF!IInitializeCommand;
const GUID IID_IInitializeNetworkFolder                      = GUIDOF!IInitializeNetworkFolder;
const GUID IID_IInitializeObject                             = GUIDOF!IInitializeObject;
const GUID IID_IInitializeWithBindCtx                        = GUIDOF!IInitializeWithBindCtx;
const GUID IID_IInitializeWithFile                           = GUIDOF!IInitializeWithFile;
const GUID IID_IInitializeWithItem                           = GUIDOF!IInitializeWithItem;
const GUID IID_IInitializeWithPropertyStore                  = GUIDOF!IInitializeWithPropertyStore;
const GUID IID_IInitializeWithStream                         = GUIDOF!IInitializeWithStream;
const GUID IID_IInitializeWithWindow                         = GUIDOF!IInitializeWithWindow;
const GUID IID_IInputObject                                  = GUIDOF!IInputObject;
const GUID IID_IInputObject2                                 = GUIDOF!IInputObject2;
const GUID IID_IInputObjectSite                              = GUIDOF!IInputObjectSite;
const GUID IID_IInputPanelConfiguration                      = GUIDOF!IInputPanelConfiguration;
const GUID IID_IInputPanelInvocationConfiguration            = GUIDOF!IInputPanelInvocationConfiguration;
const GUID IID_IInsertItem                                   = GUIDOF!IInsertItem;
const GUID IID_IItemNameLimits                               = GUIDOF!IItemNameLimits;
const GUID IID_IKnownFolder                                  = GUIDOF!IKnownFolder;
const GUID IID_IKnownFolderManager                           = GUIDOF!IKnownFolderManager;
const GUID IID_ILaunchSourceAppUserModelId                   = GUIDOF!ILaunchSourceAppUserModelId;
const GUID IID_ILaunchSourceViewSizePreference               = GUIDOF!ILaunchSourceViewSizePreference;
const GUID IID_ILaunchTargetMonitor                          = GUIDOF!ILaunchTargetMonitor;
const GUID IID_ILaunchTargetViewSizePreference               = GUIDOF!ILaunchTargetViewSizePreference;
const GUID IID_ILaunchUIContext                              = GUIDOF!ILaunchUIContext;
const GUID IID_ILaunchUIContextProvider                      = GUIDOF!ILaunchUIContextProvider;
const GUID IID_IMenuBand                                     = GUIDOF!IMenuBand;
const GUID IID_IMenuPopup                                    = GUIDOF!IMenuPopup;
const GUID IID_IModalWindow                                  = GUIDOF!IModalWindow;
const GUID IID_INameSpaceTreeAccessible                      = GUIDOF!INameSpaceTreeAccessible;
const GUID IID_INameSpaceTreeControl                         = GUIDOF!INameSpaceTreeControl;
const GUID IID_INameSpaceTreeControl2                        = GUIDOF!INameSpaceTreeControl2;
const GUID IID_INameSpaceTreeControlCustomDraw               = GUIDOF!INameSpaceTreeControlCustomDraw;
const GUID IID_INameSpaceTreeControlDropHandler              = GUIDOF!INameSpaceTreeControlDropHandler;
const GUID IID_INameSpaceTreeControlEvents                   = GUIDOF!INameSpaceTreeControlEvents;
const GUID IID_INameSpaceTreeControlFolderCapabilities       = GUIDOF!INameSpaceTreeControlFolderCapabilities;
const GUID IID_INamedPropertyBag                             = GUIDOF!INamedPropertyBag;
const GUID IID_INamedPropertyStore                           = GUIDOF!INamedPropertyStore;
const GUID IID_INamespaceWalk                                = GUIDOF!INamespaceWalk;
const GUID IID_INamespaceWalkCB                              = GUIDOF!INamespaceWalkCB;
const GUID IID_INamespaceWalkCB2                             = GUIDOF!INamespaceWalkCB2;
const GUID IID_INetworkFolderInternal                        = GUIDOF!INetworkFolderInternal;
const GUID IID_INewMenuClient                                = GUIDOF!INewMenuClient;
const GUID IID_INewShortcutHookA                             = GUIDOF!INewShortcutHookA;
const GUID IID_INewShortcutHookW                             = GUIDOF!INewShortcutHookW;
const GUID IID_INewWDEvents                                  = GUIDOF!INewWDEvents;
const GUID IID_INewWindowManager                             = GUIDOF!INewWindowManager;
const GUID IID_INotifyReplica                                = GUIDOF!INotifyReplica;
const GUID IID_IObjMgr                                       = GUIDOF!IObjMgr;
const GUID IID_IObjectArray                                  = GUIDOF!IObjectArray;
const GUID IID_IObjectCollection                             = GUIDOF!IObjectCollection;
const GUID IID_IObjectProvider                               = GUIDOF!IObjectProvider;
const GUID IID_IObjectWithAppUserModelID                     = GUIDOF!IObjectWithAppUserModelID;
const GUID IID_IObjectWithBackReferences                     = GUIDOF!IObjectWithBackReferences;
const GUID IID_IObjectWithCancelEvent                        = GUIDOF!IObjectWithCancelEvent;
const GUID IID_IObjectWithFolderEnumMode                     = GUIDOF!IObjectWithFolderEnumMode;
const GUID IID_IObjectWithProgID                             = GUIDOF!IObjectWithProgID;
const GUID IID_IObjectWithPropertyKey                        = GUIDOF!IObjectWithPropertyKey;
const GUID IID_IObjectWithSelection                          = GUIDOF!IObjectWithSelection;
const GUID IID_IOpenControlPanel                             = GUIDOF!IOpenControlPanel;
const GUID IID_IOpenSearchSource                             = GUIDOF!IOpenSearchSource;
const GUID IID_IOperationsProgressDialog                     = GUIDOF!IOperationsProgressDialog;
const GUID IID_IPackageDebugSettings                         = GUIDOF!IPackageDebugSettings;
const GUID IID_IPackageDebugSettings2                        = GUIDOF!IPackageDebugSettings2;
const GUID IID_IPackageExecutionStateChangeNotification      = GUIDOF!IPackageExecutionStateChangeNotification;
const GUID IID_IParentAndItem                                = GUIDOF!IParentAndItem;
const GUID IID_IParseAndCreateItem                           = GUIDOF!IParseAndCreateItem;
const GUID IID_IPersistFolder                                = GUIDOF!IPersistFolder;
const GUID IID_IPersistFolder2                               = GUIDOF!IPersistFolder2;
const GUID IID_IPersistFolder3                               = GUIDOF!IPersistFolder3;
const GUID IID_IPersistIDList                                = GUIDOF!IPersistIDList;
const GUID IID_IPersistSerializedPropStorage                 = GUIDOF!IPersistSerializedPropStorage;
const GUID IID_IPersistSerializedPropStorage2                = GUIDOF!IPersistSerializedPropStorage2;
const GUID IID_IPreviewHandler                               = GUIDOF!IPreviewHandler;
const GUID IID_IPreviewHandlerFrame                          = GUIDOF!IPreviewHandlerFrame;
const GUID IID_IPreviewHandlerVisuals                        = GUIDOF!IPreviewHandlerVisuals;
const GUID IID_IPreviewItem                                  = GUIDOF!IPreviewItem;
const GUID IID_IPreviousVersionsInfo                         = GUIDOF!IPreviousVersionsInfo;
const GUID IID_IProfferService                               = GUIDOF!IProfferService;
const GUID IID_IProgressDialog                               = GUIDOF!IProgressDialog;
const GUID IID_IPropertyKeyStore                             = GUIDOF!IPropertyKeyStore;
const GUID IID_IPublishedApp                                 = GUIDOF!IPublishedApp;
const GUID IID_IPublishedApp2                                = GUIDOF!IPublishedApp2;
const GUID IID_IPublishingWizard                             = GUIDOF!IPublishingWizard;
const GUID IID_IQueryAssociations                            = GUIDOF!IQueryAssociations;
const GUID IID_IQueryCancelAutoPlay                          = GUIDOF!IQueryCancelAutoPlay;
const GUID IID_IQueryCodePage                                = GUIDOF!IQueryCodePage;
const GUID IID_IQueryContinue                                = GUIDOF!IQueryContinue;
const GUID IID_IQueryContinueWithStatus                      = GUIDOF!IQueryContinueWithStatus;
const GUID IID_IQueryInfo                                    = GUIDOF!IQueryInfo;
const GUID IID_IRegTreeItem                                  = GUIDOF!IRegTreeItem;
const GUID IID_IRelatedItem                                  = GUIDOF!IRelatedItem;
const GUID IID_IRemoteComputer                               = GUIDOF!IRemoteComputer;
const GUID IID_IResolveShellLink                             = GUIDOF!IResolveShellLink;
const GUID IID_IResultsFolder                                = GUIDOF!IResultsFolder;
const GUID IID_IRunnableTask                                 = GUIDOF!IRunnableTask;
const GUID IID_ISearchBoxInfo                                = GUIDOF!ISearchBoxInfo;
const GUID IID_ISearchContext                                = GUIDOF!ISearchContext;
const GUID IID_ISearchFolderItemFactory                      = GUIDOF!ISearchFolderItemFactory;
const GUID IID_ISharedBitmap                                 = GUIDOF!ISharedBitmap;
const GUID IID_ISharingConfigurationManager                  = GUIDOF!ISharingConfigurationManager;
const GUID IID_IShellApp                                     = GUIDOF!IShellApp;
const GUID IID_IShellBrowser                                 = GUIDOF!IShellBrowser;
const GUID IID_IShellChangeNotify                            = GUIDOF!IShellChangeNotify;
const GUID IID_IShellDetails                                 = GUIDOF!IShellDetails;
const GUID IID_IShellDispatch                                = GUIDOF!IShellDispatch;
const GUID IID_IShellDispatch2                               = GUIDOF!IShellDispatch2;
const GUID IID_IShellDispatch3                               = GUIDOF!IShellDispatch3;
const GUID IID_IShellDispatch4                               = GUIDOF!IShellDispatch4;
const GUID IID_IShellDispatch5                               = GUIDOF!IShellDispatch5;
const GUID IID_IShellDispatch6                               = GUIDOF!IShellDispatch6;
const GUID IID_IShellExecuteHookA                            = GUIDOF!IShellExecuteHookA;
const GUID IID_IShellExecuteHookW                            = GUIDOF!IShellExecuteHookW;
const GUID IID_IShellExtInit                                 = GUIDOF!IShellExtInit;
const GUID IID_IShellFolder                                  = GUIDOF!IShellFolder;
const GUID IID_IShellFolder2                                 = GUIDOF!IShellFolder2;
const GUID IID_IShellFolderBand                              = GUIDOF!IShellFolderBand;
const GUID IID_IShellFolderView                              = GUIDOF!IShellFolderView;
const GUID IID_IShellFolderViewCB                            = GUIDOF!IShellFolderViewCB;
const GUID IID_IShellFolderViewDual                          = GUIDOF!IShellFolderViewDual;
const GUID IID_IShellFolderViewDual2                         = GUIDOF!IShellFolderViewDual2;
const GUID IID_IShellFolderViewDual3                         = GUIDOF!IShellFolderViewDual3;
const GUID IID_IShellIcon                                    = GUIDOF!IShellIcon;
const GUID IID_IShellIconOverlay                             = GUIDOF!IShellIconOverlay;
const GUID IID_IShellIconOverlayIdentifier                   = GUIDOF!IShellIconOverlayIdentifier;
const GUID IID_IShellIconOverlayManager                      = GUIDOF!IShellIconOverlayManager;
const GUID IID_IShellImageData                               = GUIDOF!IShellImageData;
const GUID IID_IShellImageDataAbort                          = GUIDOF!IShellImageDataAbort;
const GUID IID_IShellImageDataFactory                        = GUIDOF!IShellImageDataFactory;
const GUID IID_IShellItem                                    = GUIDOF!IShellItem;
const GUID IID_IShellItem2                                   = GUIDOF!IShellItem2;
const GUID IID_IShellItemArray                               = GUIDOF!IShellItemArray;
const GUID IID_IShellItemFilter                              = GUIDOF!IShellItemFilter;
const GUID IID_IShellItemImageFactory                        = GUIDOF!IShellItemImageFactory;
const GUID IID_IShellItemResources                           = GUIDOF!IShellItemResources;
const GUID IID_IShellLibrary                                 = GUIDOF!IShellLibrary;
const GUID IID_IShellLinkA                                   = GUIDOF!IShellLinkA;
const GUID IID_IShellLinkDataList                            = GUIDOF!IShellLinkDataList;
const GUID IID_IShellLinkDual                                = GUIDOF!IShellLinkDual;
const GUID IID_IShellLinkDual2                               = GUIDOF!IShellLinkDual2;
const GUID IID_IShellLinkW                                   = GUIDOF!IShellLinkW;
const GUID IID_IShellMenu                                    = GUIDOF!IShellMenu;
const GUID IID_IShellMenuCallback                            = GUIDOF!IShellMenuCallback;
const GUID IID_IShellPropSheetExt                            = GUIDOF!IShellPropSheetExt;
const GUID IID_IShellRunDll                                  = GUIDOF!IShellRunDll;
const GUID IID_IShellService                                 = GUIDOF!IShellService;
const GUID IID_IShellTaskScheduler                           = GUIDOF!IShellTaskScheduler;
const GUID IID_IShellView                                    = GUIDOF!IShellView;
const GUID IID_IShellView2                                   = GUIDOF!IShellView2;
const GUID IID_IShellView3                                   = GUIDOF!IShellView3;
const GUID IID_IShellWindows                                 = GUIDOF!IShellWindows;
const GUID IID_ISortColumnArray                              = GUIDOF!ISortColumnArray;
const GUID IID_IStartMenuPinnedList                          = GUIDOF!IStartMenuPinnedList;
const GUID IID_IStorageProviderBanners                       = GUIDOF!IStorageProviderBanners;
const GUID IID_IStorageProviderHandler                       = GUIDOF!IStorageProviderHandler;
const GUID IID_IStorageProviderPropertyHandler               = GUIDOF!IStorageProviderPropertyHandler;
const GUID IID_IStreamAsync                                  = GUIDOF!IStreamAsync;
const GUID IID_IStreamUnbufferedInfo                         = GUIDOF!IStreamUnbufferedInfo;
const GUID IID_ISuspensionDependencyManager                  = GUIDOF!ISuspensionDependencyManager;
const GUID IID_ISyncMgrConflict                              = GUIDOF!ISyncMgrConflict;
const GUID IID_ISyncMgrConflictFolder                        = GUIDOF!ISyncMgrConflictFolder;
const GUID IID_ISyncMgrConflictItems                         = GUIDOF!ISyncMgrConflictItems;
const GUID IID_ISyncMgrConflictPresenter                     = GUIDOF!ISyncMgrConflictPresenter;
const GUID IID_ISyncMgrConflictResolutionItems               = GUIDOF!ISyncMgrConflictResolutionItems;
const GUID IID_ISyncMgrConflictResolveInfo                   = GUIDOF!ISyncMgrConflictResolveInfo;
const GUID IID_ISyncMgrConflictStore                         = GUIDOF!ISyncMgrConflictStore;
const GUID IID_ISyncMgrControl                               = GUIDOF!ISyncMgrControl;
const GUID IID_ISyncMgrEnumItems                             = GUIDOF!ISyncMgrEnumItems;
const GUID IID_ISyncMgrEvent                                 = GUIDOF!ISyncMgrEvent;
const GUID IID_ISyncMgrEventLinkUIOperation                  = GUIDOF!ISyncMgrEventLinkUIOperation;
const GUID IID_ISyncMgrEventStore                            = GUIDOF!ISyncMgrEventStore;
const GUID IID_ISyncMgrHandler                               = GUIDOF!ISyncMgrHandler;
const GUID IID_ISyncMgrHandlerCollection                     = GUIDOF!ISyncMgrHandlerCollection;
const GUID IID_ISyncMgrHandlerInfo                           = GUIDOF!ISyncMgrHandlerInfo;
const GUID IID_ISyncMgrRegister                              = GUIDOF!ISyncMgrRegister;
const GUID IID_ISyncMgrResolutionHandler                     = GUIDOF!ISyncMgrResolutionHandler;
const GUID IID_ISyncMgrScheduleWizardUIOperation             = GUIDOF!ISyncMgrScheduleWizardUIOperation;
const GUID IID_ISyncMgrSessionCreator                        = GUIDOF!ISyncMgrSessionCreator;
const GUID IID_ISyncMgrSyncCallback                          = GUIDOF!ISyncMgrSyncCallback;
const GUID IID_ISyncMgrSyncItem                              = GUIDOF!ISyncMgrSyncItem;
const GUID IID_ISyncMgrSyncItemContainer                     = GUIDOF!ISyncMgrSyncItemContainer;
const GUID IID_ISyncMgrSyncItemInfo                          = GUIDOF!ISyncMgrSyncItemInfo;
const GUID IID_ISyncMgrSyncResult                            = GUIDOF!ISyncMgrSyncResult;
const GUID IID_ISyncMgrSynchronize                           = GUIDOF!ISyncMgrSynchronize;
const GUID IID_ISyncMgrSynchronizeCallback                   = GUIDOF!ISyncMgrSynchronizeCallback;
const GUID IID_ISyncMgrSynchronizeInvoke                     = GUIDOF!ISyncMgrSynchronizeInvoke;
const GUID IID_ISyncMgrUIOperation                           = GUIDOF!ISyncMgrUIOperation;
const GUID IID_ITaskbarList                                  = GUIDOF!ITaskbarList;
const GUID IID_ITaskbarList2                                 = GUIDOF!ITaskbarList2;
const GUID IID_ITaskbarList3                                 = GUIDOF!ITaskbarList3;
const GUID IID_ITaskbarList4                                 = GUIDOF!ITaskbarList4;
const GUID IID_IThumbnailCache                               = GUIDOF!IThumbnailCache;
const GUID IID_IThumbnailCachePrimer                         = GUIDOF!IThumbnailCachePrimer;
const GUID IID_IThumbnailCapture                             = GUIDOF!IThumbnailCapture;
const GUID IID_IThumbnailHandlerFactory                      = GUIDOF!IThumbnailHandlerFactory;
const GUID IID_IThumbnailProvider                            = GUIDOF!IThumbnailProvider;
const GUID IID_IThumbnailSettings                            = GUIDOF!IThumbnailSettings;
const GUID IID_IThumbnailStreamCache                         = GUIDOF!IThumbnailStreamCache;
const GUID IID_ITrackShellMenu                               = GUIDOF!ITrackShellMenu;
const GUID IID_ITranscodeImage                               = GUIDOF!ITranscodeImage;
const GUID IID_ITransferAdviseSink                           = GUIDOF!ITransferAdviseSink;
const GUID IID_ITransferDestination                          = GUIDOF!ITransferDestination;
const GUID IID_ITransferMediumItem                           = GUIDOF!ITransferMediumItem;
const GUID IID_ITransferSource                               = GUIDOF!ITransferSource;
const GUID IID_ITravelEntry                                  = GUIDOF!ITravelEntry;
const GUID IID_ITravelLog                                    = GUIDOF!ITravelLog;
const GUID IID_ITravelLogClient                              = GUIDOF!ITravelLogClient;
const GUID IID_ITravelLogEntry                               = GUIDOF!ITravelLogEntry;
const GUID IID_ITravelLogStg                                 = GUIDOF!ITravelLogStg;
const GUID IID_ITrayDeskBand                                 = GUIDOF!ITrayDeskBand;
const GUID IID_IURLSearchHook                                = GUIDOF!IURLSearchHook;
const GUID IID_IURLSearchHook2                               = GUIDOF!IURLSearchHook2;
const GUID IID_IUniformResourceLocatorA                      = GUIDOF!IUniformResourceLocatorA;
const GUID IID_IUniformResourceLocatorW                      = GUIDOF!IUniformResourceLocatorW;
const GUID IID_IUpdateIDList                                 = GUIDOF!IUpdateIDList;
const GUID IID_IUseToBrowseItem                              = GUIDOF!IUseToBrowseItem;
const GUID IID_IUserAccountChangeCallback                    = GUIDOF!IUserAccountChangeCallback;
const GUID IID_IUserNotification                             = GUIDOF!IUserNotification;
const GUID IID_IUserNotification2                            = GUIDOF!IUserNotification2;
const GUID IID_IUserNotificationCallback                     = GUIDOF!IUserNotificationCallback;
const GUID IID_IViewStateIdentityItem                        = GUIDOF!IViewStateIdentityItem;
const GUID IID_IVirtualDesktopManager                        = GUIDOF!IVirtualDesktopManager;
const GUID IID_IVisualProperties                             = GUIDOF!IVisualProperties;
const GUID IID_IWebWizardExtension                           = GUIDOF!IWebWizardExtension;
const GUID IID_IWebWizardHost                                = GUIDOF!IWebWizardHost;
const GUID IID_IWebWizardHost2                               = GUIDOF!IWebWizardHost2;
const GUID IID_IWizardExtension                              = GUIDOF!IWizardExtension;
const GUID IID_IWizardSite                                   = GUIDOF!IWizardSite;
