// Written in the D programming language.

module windows.directshow;

public import windows.core;
public import windows.audio : IDirectSound, IDirectSoundBuffer;
public import windows.automation : BSTR, IDispatch, IEnumVARIANT, IErrorLog,
                                   IPropertyBag, SAFEARRAY, VARIANT;
public import windows.com : HRESULT, IBindCtx, IEnumGUID, IEnumMoniker, IMoniker,
                            IPersist, IPictureDisp, IUnknown;
public import windows.coreaudio : DDVIDEOPORTCONNECT, KSDATAFORMAT, KSEVENTDATA,
                                  KSIDENTIFIER, KSM_NODE, KSP_NODE, KS_COMPRESSION,
                                  KS_FRAMING_RANGE, KS_FRAMING_RANGE_WEIGHTED;
public import windows.direct2d : IDirect3DDevice9, IDirect3DSurface9, PALETTEENTRY;
public import windows.direct3d9 : D3DFORMAT, D3DPOOL;
public import windows.directdraw : DDCAPS_DX7, DDCOLORCONTROL, DDPIXELFORMAT, DDSCAPS2,
                                   DDSURFACEDESC, IDirectDraw, IDirectDraw7,
                                   IDirectDrawPalette, IDirectDrawSurface,
                                   IDirectDrawSurface7;
public import windows.displaydevices : POINT, RECT, SIZE;
public import windows.gdi : BITMAPINFO, HDC, RGBQUAD, RGNDATA;
public import windows.mediafoundation : IMFVideoPresenter;
public import windows.menusandresources : HACCEL;
public import windows.multimedia : WAVEFORMATEX;
public import windows.systemservices : BOOL, HANDLE, LARGE_INTEGER, PAPCFUNC;
public import windows.windowsandmessaging : HWND;
public import windows.windowsmediaformat : IWMProfile;
public import windows.windowsprogramming : HKEY, IXMLElement;

extern(Windows):


// Enums


///<div class="alert"><b>Note</b> This component is available for use in the Microsoft Windows 2000, Windows XP, and
///Windows Server 2003 operating systems. It may be altered or unavailable in subsequent versions.</div><div> </div>The
///<code>ReadyState</code> property retrieves the ReadyState of the <b>MSWebDVD</b> object.
alias READYSTATE = int;
enum : int
{
    ///Default initialization state.
    READYSTATE_UNINITIALIZED = 0x00000000,
    ///Object is loading its properties.
    READYSTATE_LOADING       = 0x00000001,
    ///Object has been initialized.
    READYSTATE_LOADED        = 0x00000002,
    ///Object is interactive, but not all its data is available.
    READYSTATE_INTERACTIVE   = 0x00000003,
    ///Object has received all its data.
    READYSTATE_COMPLETE      = 0x00000004,
}

///Specifies the criteria that the Overlay Mixer Filter should use to select the video format.
alias AMVP_SELECT_FORMAT_BY = int;
enum : int
{
    ///Format does not matter.
    AMVP_DO_NOT_CARE          = 0x00000000,
    ///Use the largest bandwidth.
    AMVP_BEST_BANDWIDTH       = 0x00000001,
    ///Use the same input format as output format.
    AMVP_INPUT_SAME_AS_OUTPUT = 0x00000002,
}

///Specifies the various modes for video ports.
alias AMVP_MODE = int;
enum : int
{
    ///Weave.
    AMVP_MODE_WEAVE             = 0x00000000,
    ///Interleaved bob. Bob mode in which resources are allocated to switch to weave mode, for example, on the next
    ///frame.
    AMVP_MODE_BOBINTERLEAVED    = 0x00000001,
    AMVP_MODE_BOBNONINTERLEAVED = 0x00000002,
    ///Skip even fields.
    AMVP_MODE_SKIPEVEN          = 0x00000003,
    ///Skip odd fields.
    AMVP_MODE_SKIPODD           = 0x00000004,
}

///Indicates a pin's direction.
alias PIN_DIRECTION = int;
enum : int
{
    ///Input pin.
    PINDIR_INPUT  = 0x00000000,
    ///Output pin.
    PINDIR_OUTPUT = 0x00000001,
}

///Specifies a filter's state or the state of the filter graph.
alias FILTER_STATE = int;
enum : int
{
    ///Stopped. The filter is not processing data.
    State_Stopped = 0x00000000,
    ///Paused. The filter is processing data, but not rendering it.
    State_Paused  = 0x00000001,
    ///Running. The filter is processing and rendering data.
    State_Running = 0x00000002,
}

///Specifies values for the [AM_SAMPLE2_PROPERTIES](/windows/desktop/api/strmif/ns-strmif-am_sample2_properties)
///structure. These values describe the properties of media samples.
alias tagAM_SAMPLE_PROPERTY_FLAGS = int;
enum : int
{
    ///Sample is a splice point (it can be decoded without reference to previous data).
    AM_SAMPLE_SPLICEPOINT       = 0x00000001,
    ///Sample is a preroll sample.
    AM_SAMPLE_PREROLL           = 0x00000002,
    ///Initial data in this sample is a splice point. The data in the previous sample was not intended to be followed by
    ///data in this sample. For more information, see Remarks.
    AM_SAMPLE_DATADISCONTINUITY = 0x00000004,
    ///Sample type changed.
    AM_SAMPLE_TYPECHANGED       = 0x00000008,
    ///Time is valid.
    AM_SAMPLE_TIMEVALID         = 0x00000010,
    ///A time gap in the data starts after this sample. The
    ///[AM_SAMPLE2_PROPERTIES](/windows/desktop/api/strmif/ns-strmif-am_sample2_properties) structure can be <b>NULL</b>
    ///in this case.
    AM_SAMPLE_TIMEDISCONTINUITY = 0x00000040,
    ///For live data only; indicates discard in the paused state.
    AM_SAMPLE_FLUSH_ON_PAUSE    = 0x00000080,
    ///Stop time is valid.
    AM_SAMPLE_STOPVALID         = 0x00000100,
    ///End of stream occurs after this sample. This flag is reserved for kernel streaming. DirectShow currently does not
    ///use it.
    AM_SAMPLE_ENDOFSTREAM       = 0x00000200,
    ///Normal data stream identifier.
    AM_STREAM_MEDIA             = 0x00000000,
    ///Control stream identifier. A value greater than 0x7FFFFFFF indicates an application-defined stream.
    AM_STREAM_CONTROL           = 0x00000001,
}

alias AM_SEEKING_SeekingFlags = int;
enum : int
{
    AM_SEEKING_NoPositioning          = 0x00000000,
    AM_SEEKING_AbsolutePositioning    = 0x00000001,
    AM_SEEKING_RelativePositioning    = 0x00000002,
    AM_SEEKING_IncrementalPositioning = 0x00000003,
    AM_SEEKING_PositioningBitsMask    = 0x00000003,
    AM_SEEKING_SeekToKeyFrame         = 0x00000004,
    AM_SEEKING_ReturnTime             = 0x00000008,
    AM_SEEKING_Segment                = 0x00000010,
    AM_SEEKING_NoFlush                = 0x00000020,
}

///Specifies the seeking capabilities of a media stream.
alias AM_SEEKING_SEEKING_CAPABILITIES = int;
enum : int
{
    ///The stream can seek to an absolute position.
    AM_SEEKING_CanSeekAbsolute  = 0x00000001,
    ///The stream can seek forward.
    AM_SEEKING_CanSeekForwards  = 0x00000002,
    ///The stream can seek backward.
    AM_SEEKING_CanSeekBackwards = 0x00000004,
    ///The stream can report its current position. See Remarks.
    AM_SEEKING_CanGetCurrentPos = 0x00000008,
    ///The stream can report its stop position.
    AM_SEEKING_CanGetStopPos    = 0x00000010,
    ///The stream can report its duration.
    AM_SEEKING_CanGetDuration   = 0x00000020,
    ///The stream can play backward.
    AM_SEEKING_CanPlayBackwards = 0x00000040,
    ///The stream can do seamless looping (see IMediaSeeking::SetPositions).
    AM_SEEKING_CanDoSegments    = 0x00000080,
    ///Reserved.
    AM_SEEKING_Source           = 0x00000100,
}

alias tagAM_MEDIAEVENT_FLAGS = int;
enum : int
{
    AM_MEDIAEVENT_NONOTIFY = 0x00000001,
}

alias __MIDL_IFilterMapper_0001 = int;
enum : int
{
    MERIT_PREFERRED     = 0x00800000,
    MERIT_NORMAL        = 0x00600000,
    MERIT_UNLIKELY      = 0x00400000,
    MERIT_DO_NOT_USE    = 0x00200000,
    MERIT_SW_COMPRESSOR = 0x00100000,
    MERIT_HW_COMPRESSOR = 0x00100050,
}

alias __MIDL___MIDL_itf_strmif_0000_0023_0001 = int;
enum : int
{
    REG_PINFLAG_B_ZERO     = 0x00000001,
    REG_PINFLAG_B_RENDERER = 0x00000002,
    REG_PINFLAG_B_MANY     = 0x00000004,
    REG_PINFLAG_B_OUTPUT   = 0x00000008,
}

///Describes a quality message type.
enum QualityMessageType : int
{
    ///Downstream filter needs more data.
    Famine  = 0x00000000,
    ///Downstream filter needs less data.
    Flood   = 0x00000001,
}

alias __MIDL___MIDL_itf_strmif_0000_0026_0001 = int;
enum : int
{
    CK_NOCOLORKEY = 0x00000000,
    CK_INDEX      = 0x00000001,
    CK_RGB        = 0x00000002,
}

alias __MIDL___MIDL_itf_strmif_0000_0026_0002 = int;
enum : int
{
    ADVISE_NONE           = 0x00000000,
    ADVISE_CLIPPING       = 0x00000001,
    ADVISE_PALETTE        = 0x00000002,
    ADVISE_COLORKEY       = 0x00000004,
    ADVISE_POSITION       = 0x00000008,
    ADVISE_DISPLAY_CHANGE = 0x00000010,
}

alias AM_FILESINK_FLAGS = int;
enum : int
{
    AM_FILE_OVERWRITE = 0x00000001,
}

alias _AM_RENSDEREXFLAGS = int;
enum : int
{
    AM_RENDEREX_RENDERTOEXISTINGRENDERERS = 0x00000001,
}

///The <b>AM_STREAM_INFO_FLAGS</b> enumeration defines flags that indicate a pin's stream-control status.
alias AM_STREAM_INFO_FLAGS = int;
enum : int
{
    ///Indicates that the pin's start time is set.
    AM_STREAM_INFO_START_DEFINED   = 0x00000001,
    ///Indicates that the pin's stop time is been set.
    AM_STREAM_INFO_STOP_DEFINED    = 0x00000002,
    ///Indicates that the pin is currently discarding data.
    AM_STREAM_INFO_DISCARDING      = 0x00000004,
    ///Indicates that the pin will send one extra sample after it reaches the stop time.
    AM_STREAM_INFO_STOP_SEND_EXTRA = 0x00000010,
}

///Specifies how video frames and audio samples will be written to disk.
enum InterleavingMode : int
{
    ///Noninterleaved. Frames are written in the order they arrive. Files must be interleaved for playback at a later
    ///time. In this mode, the AVI Mux filter attempts to use unbuffered, overlapped write operations, to increase
    ///throughput.
    INTERLEAVE_NONE          = 0x00000000,
    ///Approximate interleaving with less overhead than <b>INTERLEAVE_FULL</b>. This mode is suitable for video capture.
    ///The AVI Mux attempts to use unbuffered, overlapped write operations. Unless the interleaving parameters are
    ///configured properly, however, frames may be dropped if one stream blocks while it waits for data from another
    ///stream. In particular, audio buffers should be less than .5 second, or else the video stream will block for
    ///excessive periods of time.
    INTERLEAVE_CAPTURE       = 0x00000001,
    ///Full, precise interleaving of audio samples and video frames. Streams will block indefinitely, waiting for equal
    ///amounts of data before interleaving. This mode is suitable for authoring and playback.
    INTERLEAVE_FULL          = 0x00000002,
    ///Noninterleaved. This mode is equivalent to <b>INTERLEAVE_NONE</b> but uses less file space and system overhead.
    INTERLEAVE_NONE_BUFFERED = 0x00000003,
}

///Indicates video compression capabilities.
enum CompressionCaps : int
{
    ///Video compressor supports the IAMVideoCompression::put_Quality and IAMVideoCompression::get_Quality methods.
    CompressionCaps_CanQuality  = 0x00000001,
    ///Video compressor can compress video to a specified data rate. If the compressor has this capability then the
    ///output pins media type will contain the data rate in the VIDEOINFOHEADER structure's <b>dwBitRate</b> member. The
    ///only way to set the data rate is to set <b>dwBitRate</b>.
    CompressionCaps_CanCrunch   = 0x00000002,
    ///Video compressor supports the IAMVideoCompression::put_KeyFrameRate and IAMVideoCompression::get_KeyFrameRate
    ///methods.
    CompressionCaps_CanKeyFrame = 0x00000004,
    ///Video compressor supports the IAMVideoCompression::put_PFramesPerKeyFrame and
    ///IAMVideoCompression::get_PFramesPerKeyFrame methods.
    CompressionCaps_CanBFrame   = 0x00000008,
    ///Video compressor supports the IAMVideoCompression::put_WindowSize and IAMVideoCompression::get_WindowSize
    ///methods.
    CompressionCaps_CanWindow   = 0x00000010,
}

///Specifies a dialog box that might exist in a Video for Windows capture driver.
enum VfwCaptureDialogs : int
{
    ///Video source dialog box.
    VfwCaptureDialog_Source  = 0x00000001,
    ///Video format dialog box.
    VfwCaptureDialog_Format  = 0x00000002,
    ///Video display dialog box.
    VfwCaptureDialog_Display = 0x00000004,
}

///Specifies a dialog box that might exist in a Video for Windows compression (codec) driver.
enum VfwCompressDialogs : int
{
    ///Configure dialog box.
    VfwCompressDialog_Config      = 0x00000001,
    ///About dialog box.
    VfwCompressDialog_About       = 0x00000002,
    ///Specifies whether the Configure dialog box is available.
    VfwCompressDialog_QueryConfig = 0x00000004,
    ///Specifies whether the About dialog box is available.
    VfwCompressDialog_QueryAbout  = 0x00000008,
}

///The <b>AnalogVideoStandard</b> enumeration specifies the format of an analog television signal.
enum AnalogVideoStandard : int
{
    ///Digital sensor.
    AnalogVideo_None          = 0x00000000,
    ///NTSC (M) standard, 7.5 IRE black.
    AnalogVideo_NTSC_M        = 0x00000001,
    ///NTSC (M) standard, 0 IRE black (Japan).
    AnalogVideo_NTSC_M_J      = 0x00000002,
    ///NTSC-433.
    AnalogVideo_NTSC_433      = 0x00000004,
    ///PAL-B standard.
    AnalogVideo_PAL_B         = 0x00000010,
    ///PAL (D) standard.
    AnalogVideo_PAL_D         = 0x00000020,
    AnalogVideo_PAL_G         = 0x00000040,
    ///PAL (H) standard.
    AnalogVideo_PAL_H         = 0x00000080,
    ///PAL (I) standard.
    AnalogVideo_PAL_I         = 0x00000100,
    ///PAL (M) standard.
    AnalogVideo_PAL_M         = 0x00000200,
    ///PAL (N) standard.
    AnalogVideo_PAL_N         = 0x00000400,
    ///PAL-60 standard.
    AnalogVideo_PAL_60        = 0x00000800,
    ///SECAM (B) standard.
    AnalogVideo_SECAM_B       = 0x00001000,
    ///SECAM (D) standard.
    AnalogVideo_SECAM_D       = 0x00002000,
    ///SECAM (G) standard.
    AnalogVideo_SECAM_G       = 0x00004000,
    ///SECAM (H) standard.
    AnalogVideo_SECAM_H       = 0x00008000,
    ///SECAM (K) standard.
    AnalogVideo_SECAM_K       = 0x00010000,
    ///SECAM (K1) standard.
    AnalogVideo_SECAM_K1      = 0x00020000,
    ///SECAM (L) standard.
    AnalogVideo_SECAM_L       = 0x00040000,
    ///SECAM (L1) standard.
    AnalogVideo_SECAM_L1      = 0x00080000,
    ///Combination (N) PAL standard (Argentina).
    AnalogVideo_PAL_N_COMBO   = 0x00100000,
    AnalogVideoMask_MCE_NTSC  = 0x00100e07,
    AnalogVideoMask_MCE_PAL   = 0x000001f0,
    AnalogVideoMask_MCE_SECAM = 0x000ff000,
}

///Specifies the frequency of a TV tuner (cable or antenna).
enum TunerInputType : int
{
    ///Indicates cable frequency.
    TunerInputCable   = 0x00000000,
    ///Indicates broadcast antenna frequency.
    TunerInputAntenna = 0x00000001,
}

enum VideoCopyProtectionType : int
{
    VideoCopyProtectionMacrovisionBasic = 0x00000000,
    VideoCopyProtectionMacrovisionCBI   = 0x00000001,
}

///Specifies the physical type of pin (audio or video).
enum PhysicalConnectorType : int
{
    ///Specifies a tuner pin for video.
    PhysConn_Video_Tuner           = 0x00000001,
    ///Specifies a composite pin for video.
    PhysConn_Video_Composite       = 0x00000002,
    ///Specifies an S-Video (Y/C video) pin.
    PhysConn_Video_SVideo          = 0x00000003,
    ///Specifies an RGB pin for video.
    PhysConn_Video_RGB             = 0x00000004,
    ///Specifies a YRYBY (Y, R–Y, B–Y) pin for video.
    PhysConn_Video_YRYBY           = 0x00000005,
    ///Specifies a serial digital pin for video.
    PhysConn_Video_SerialDigital   = 0x00000006,
    ///Specifies a parallel digital pin for video.
    PhysConn_Video_ParallelDigital = 0x00000007,
    ///Specifies a SCSI (Small Computer System Interface) pin for video.
    PhysConn_Video_SCSI            = 0x00000008,
    ///Specifies an AUX (auxiliary) pin for video.
    PhysConn_Video_AUX             = 0x00000009,
    ///Specifies an IEEE 1394 pin for video.
    PhysConn_Video_1394            = 0x0000000a,
    ///Specifies a USB (Universal Serial Bus) pin for video.
    PhysConn_Video_USB             = 0x0000000b,
    ///Specifies a video decoder pin.
    PhysConn_Video_VideoDecoder    = 0x0000000c,
    ///Specifies a video encoder pin.
    PhysConn_Video_VideoEncoder    = 0x0000000d,
    ///Specifies a SCART (Peritel) pin for video.
    PhysConn_Video_SCART           = 0x0000000e,
    ///Not used.
    PhysConn_Video_Black           = 0x0000000f,
    ///Specifies a tuner pin for audio.
    PhysConn_Audio_Tuner           = 0x00001000,
    ///Specifies a line pin for audio.
    PhysConn_Audio_Line            = 0x00001001,
    ///Specifies a microphone pin.
    PhysConn_Audio_Mic             = 0x00001002,
    ///Specifies an AES/EBU (Audio Engineering Society/European Broadcast Union) digital pin for audio.
    PhysConn_Audio_AESDigital      = 0x00001003,
    ///Specifies an S/PDIF (Sony/Philips Digital Interface Format) digital pin for audio.
    PhysConn_Audio_SPDIFDigital    = 0x00001004,
    ///Specifies a SCSI pin for audio.
    PhysConn_Audio_SCSI            = 0x00001005,
    ///Specifies an AUX pin for audio.
    PhysConn_Audio_AUX             = 0x00001006,
    ///Specifies an IEEE 1394 pin for audio.
    PhysConn_Audio_1394            = 0x00001007,
    ///Specifies a USB pin for audio.
    PhysConn_Audio_USB             = 0x00001008,
    ///Specifies an audio decoder pin.
    PhysConn_Audio_AudioDecoder    = 0x00001009,
}

///The <b>VideoProcAmpProperty</b> enumeration specifies video properties on a video capture device.
enum VideoProcAmpProperty : int
{
    ///Specifies the brightness, also called the <i>black level</i>. For NTSC, the value is expressed in IRE units *
    ///100. For non-NTSC sources, the units are arbitrary, with zero representing blanking and 10,000 representing pure
    ///white. Values range from –10,000 to 10,000.
    VideoProcAmp_Brightness            = 0x00000000,
    ///Specifies the contrast, expressed as gain factor * 100. Values range from zero to 10,000.
    VideoProcAmp_Contrast              = 0x00000001,
    ///Specifies the hue, in degrees * 100. Values range from -180,000 to 180,000 (-180 to +180 degrees).
    VideoProcAmp_Hue                   = 0x00000002,
    ///Specifies the saturation. Values range from 0 to 10,000.
    VideoProcAmp_Saturation            = 0x00000003,
    ///Specifies the sharpness. Values range from 0 to 100.
    VideoProcAmp_Sharpness             = 0x00000004,
    ///Specifies the gamma, as gamma * 100. Values range from 1 to 500.
    VideoProcAmp_Gamma                 = 0x00000005,
    ///Specifies the color enable setting. The possible values are 0 (off) and 1 (on).
    VideoProcAmp_ColorEnable           = 0x00000006,
    ///Specifies the white balance, as a color temperature in degrees Kelvin. The range of values depends on the device.
    VideoProcAmp_WhiteBalance          = 0x00000007,
    ///Specifies the backlight compensation setting. Possible values are 0 (off) and 1 (on).
    VideoProcAmp_BacklightCompensation = 0x00000008,
    ///Specifies the gain adjustment. Zero is normal. Positive values are brighter and negative values are darker. The
    ///range of values depends on the device.
    VideoProcAmp_Gain                  = 0x00000009,
}

///The <b>VideoProcAmpFlags</b> enumeration indicates whether a particular video property is controlled manually or
///automatically.
enum VideoProcAmpFlags : int
{
    ///The setting is controlled automatically.
    VideoProcAmp_Flags_Auto   = 0x00000001,
    ///The setting is controlled manually.
    VideoProcAmp_Flags_Manual = 0x00000002,
}

///The <code>CameraControlProperty</code> enumeration specifies a setting on a camera.
enum CameraControlProperty : int
{
    ///Specifies the camera's pan setting, in degrees. Values range from –180 to +180, with the default set to zero.
    ///Positive values are clockwise from the origin (the camera rotates clockwise when viewed from above), and negative
    ///values are counterclockwise from the origin.
    CameraControl_Pan      = 0x00000000,
    ///Specifies the camera's tilt setting, in degrees. Values range from –180 to +180, with the default set to zero.
    ///Positive values point the imaging plane up, and negative values point the imaging plane down.
    CameraControl_Tilt     = 0x00000001,
    ///Specifies the camera's roll setting, in degrees. Values range from –180 to +180, with the default set to zero.
    ///Positive values cause a clockwise rotation of the camera along the image-viewing axis, and negative values cause
    ///a counterclockwise rotation of the camera.
    CameraControl_Roll     = 0x00000002,
    ///Specifies the camera's zoom setting, in millimeters. Values range from 10 to 600, and the default is specific to
    ///the device.
    CameraControl_Zoom     = 0x00000003,
    ///Specifies the exposure setting, in log base 2 seconds. In other words, for values less than zero, the exposure
    ///time is 1/2^n seconds, and for values zero or above, the exposure time is 2^n seconds. For example: <table> <tr>
    ///<th>Value </th> <th>Seconds </th> </tr> <tr> <td>-3</td> <td>1/8</td> </tr> <tr> <td>-2</td> <td>1/4</td> </tr>
    ///<tr> <td>-1</td> <td>1/2</td> </tr> <tr> <td>0</td> <td>1</td> </tr> <tr> <td>1</td> <td>2</td> </tr> <tr>
    ///<td>2</td> <td>4</td> </tr> </table>
    CameraControl_Exposure = 0x00000004,
    ///Specifies the camera's iris setting, in units of fₛₜₒₚ* 10.
    CameraControl_Iris     = 0x00000005,
    ///Specifies the camera's focus setting, as the distance to the optimally focused target, in millimeters. The range
    ///and default value are specific to the device.
    CameraControl_Focus    = 0x00000006,
}

///The <b>CameraControlFlags</b> enumeration defines whether a camera setting is controlled manually or automatically.
enum CameraControlFlags : int
{
    ///The setting is controlled automatically.
    CameraControl_Flags_Auto   = 0x00000001,
    ///The setting is controlled manually.
    CameraControl_Flags_Manual = 0x00000002,
}

///Specifies the video mode of operation for a video device.
enum VideoControlFlags : int
{
    ///Specifies that the picture is flipped horizontally.
    VideoControlFlag_FlipHorizontal        = 0x00000001,
    ///Specifies that the picture is flipped vertically.
    VideoControlFlag_FlipVertical          = 0x00000002,
    ///Sets up a stream to capture a trigger from an external source, for example, a push button on a camera. Buffers
    ///can be queued to the driver but will not be passed up from the WDM capture driver (for compression, display, or
    ///writing to a file) until the external event happens. See Remarks.
    VideoControlFlag_ExternalTriggerEnable = 0x00000004,
    ///In software, simulates an external trigger when the stream has the VideoControlFlag_ExternalTriggerEnable flag
    ///set.
    VideoControlFlag_Trigger               = 0x00000008,
}

enum AMTunerSubChannel : int
{
    AMTUNER_SUBCHAN_NO_TUNE = 0xfffffffe,
    AMTUNER_SUBCHAN_DEFAULT = 0xffffffff,
}

enum AMTunerSignalStrength : int
{
    AMTUNER_HASNOSIGNALSTRENGTH = 0xffffffff,
    AMTUNER_NOSIGNAL            = 0x00000000,
    AMTUNER_SIGNALPRESENT       = 0x00000001,
}

///Specifies the frequency of a TV tuner (cable or antenna).
enum AMTunerModeType : int
{
    ///Indicates default tuner mode.
    AMTUNER_MODE_DEFAULT  = 0x00000000,
    ///Indicates TV tuner mode.
    AMTUNER_MODE_TV       = 0x00000001,
    ///Indicates FM radio tuner mode.
    AMTUNER_MODE_FM_RADIO = 0x00000002,
    ///Indicates AM radio tuner mode.
    AMTUNER_MODE_AM_RADIO = 0x00000004,
    ///Indicates Digital Satellite Service (DSS) tuner mode.
    AMTUNER_MODE_DSS      = 0x00000008,
}

enum AMTunerEventType : int
{
    AMTUNER_EVENT_CHANGED = 0x00000001,
}

///Specifies the mode of a TV audio control.
enum TVAudioMode : int
{
    ///Mono.
    AMTVAUDIO_MODE_MONO     = 0x00000001,
    ///Stereo.
    AMTVAUDIO_MODE_STEREO   = 0x00000002,
    ///Language A: Main audio channel.
    AMTVAUDIO_MODE_LANG_A   = 0x00000010,
    ///Languag B: Secondary audio program (SAP).
    AMTVAUDIO_MODE_LANG_B   = 0x00000020,
    ///Language C: Either a third language, or the main audio program plus the SAP (for example, English from one
    ///speaker and Japanese from the other speaker).
    AMTVAUDIO_MODE_LANG_C   = 0x00000040,
    ///Stereo preset.
    AMTVAUDIO_PRESET_STEREO = 0x00000200,
    ///Languag A preset.
    AMTVAUDIO_PRESET_LANG_A = 0x00001000,
    ///Language B preset.
    AMTVAUDIO_PRESET_LANG_B = 0x00002000,
    ///Language C preset.
    AMTVAUDIO_PRESET_LANG_C = 0x00004000,
}

enum AMTVAudioEventType : int
{
    AMTVAUDIO_EVENT_CHANGED = 0x00000001,
}

alias AMPROPERTY_PIN = int;
enum : int
{
    AMPROPERTY_PIN_CATEGORY = 0x00000000,
    AMPROPERTY_PIN_MEDIUM   = 0x00000001,
}

alias _AMSTREAMSELECTINFOFLAGS = int;
enum : int
{
    AMSTREAMSELECTINFO_ENABLED   = 0x00000001,
    AMSTREAMSELECTINFO_EXCLUSIVE = 0x00000002,
}

alias _AMSTREAMSELECTENABLEFLAGS = int;
enum : int
{
    AMSTREAMSELECTENABLE_ENABLE    = 0x00000001,
    AMSTREAMSELECTENABLE_ENABLEALL = 0x00000002,
}

alias _AMRESCTL_RESERVEFLAGS = int;
enum : int
{
    AMRESCTL_RESERVEFLAGS_RESERVE   = 0x00000000,
    AMRESCTL_RESERVEFLAGS_UNRESERVE = 0x00000001,
}

alias _AM_FILTER_MISC_FLAGS = int;
enum : int
{
    AM_FILTER_MISC_FLAGS_IS_RENDERER = 0x00000001,
    AM_FILTER_MISC_FLAGS_IS_SOURCE   = 0x00000002,
}

///Describes the strategy that the Overlay Mixer Filter filter uses to scale the video image down to a smaller size.
alias DECIMATION_USAGE = int;
enum : int
{
    ///Decimate the video by taking the following steps, in the order listed, until one of them succeeds. <ol> <li>Try
    ///to use the overlay scaler on the VGA chip.</li> <li>If the Overlay Mixer is connected through a video port, try
    ///to use the scaler on the video port.</li> <li>Crop the video image.</li> </ol>
    DECIMATION_LEGACY             = 0x00000000,
    ///Decimate using the scaler on the video decoder. If that fails, crop the video image.
    DECIMATION_USE_DECODER_ONLY   = 0x00000001,
    ///Decimate using the scaler on the video port. If that fails, crop the video image.
    DECIMATION_USE_VIDEOPORT_ONLY = 0x00000002,
    ///Decimate using the overlay scaler on the VGA chip. If that fails, crop the video image.
    DECIMATION_USE_OVERLAY_ONLY   = 0x00000003,
    ///Decimate the video by taking the following steps, in the order listed, until one of them succeeds. <ol> <li>Try
    ///to use the scaler on the video decoder.</li> <li>Try to use the overlay scaler on the VGA chip.</li> <li>If the
    ///Overlay Mixer is connected through a video port, try to use the scaler on the video port.</li> <li>Crop the video
    ///image.</li> </ol> This mode is the default decimation strategy.
    DECIMATION_DEFAULT            = 0x00000004,
}

alias _AM_PUSHSOURCE_FLAGS = int;
enum : int
{
    AM_PUSHSOURCECAPS_INTERNAL_RM      = 0x00000001,
    AM_PUSHSOURCECAPS_NOT_LIVE         = 0x00000002,
    AM_PUSHSOURCECAPS_PRIVATE_CLOCK    = 0x00000004,
    AM_PUSHSOURCEREQS_USE_STREAM_CLOCK = 0x00010000,
    AM_PUSHSOURCEREQS_USE_CLOCK_CHAIN  = 0x00020000,
}

alias _DVENCODERRESOLUTION = int;
enum : int
{
    DVENCODERRESOLUTION_720x480 = 0x000007dc,
    DVENCODERRESOLUTION_360x240 = 0x000007dd,
    DVENCODERRESOLUTION_180x120 = 0x000007de,
    DVENCODERRESOLUTION_88x60   = 0x000007df,
}

alias _DVENCODERVIDEOFORMAT = int;
enum : int
{
    DVENCODERVIDEOFORMAT_NTSC = 0x000007d0,
    DVENCODERVIDEOFORMAT_PAL  = 0x000007d1,
}

alias _DVENCODERFORMAT = int;
enum : int
{
    DVENCODERFORMAT_DVSD = 0x000007d7,
    DVENCODERFORMAT_DVHD = 0x000007d8,
    DVENCODERFORMAT_DVSL = 0x000007d9,
}

alias _DVDECODERRESOLUTION = int;
enum : int
{
    DVDECODERRESOLUTION_720x480 = 0x000003e8,
    DVDECODERRESOLUTION_360x240 = 0x000003e9,
    DVDECODERRESOLUTION_180x120 = 0x000003ea,
    DVDECODERRESOLUTION_88x60   = 0x000003eb,
}

alias _DVRESOLUTION = int;
enum : int
{
    DVRESOLUTION_FULL    = 0x000003e8,
    DVRESOLUTION_HALF    = 0x000003e9,
    DVRESOLUTION_QUARTER = 0x000003ea,
    DVRESOLUTION_DC      = 0x000003eb,
}

alias _AM_AUDIO_RENDERER_STAT_PARAM = int;
enum : int
{
    AM_AUDREND_STAT_PARAM_BREAK_COUNT            = 0x00000001,
    AM_AUDREND_STAT_PARAM_SLAVE_MODE             = 0x00000002,
    AM_AUDREND_STAT_PARAM_SILENCE_DUR            = 0x00000003,
    AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR        = 0x00000004,
    AM_AUDREND_STAT_PARAM_DISCONTINUITIES        = 0x00000005,
    AM_AUDREND_STAT_PARAM_SLAVE_RATE             = 0x00000006,
    AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR    = 0x00000007,
    AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR     = 0x00000008,
    AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR = 0x00000009,
    AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR       = 0x0000000a,
    AM_AUDREND_STAT_PARAM_BUFFERFULLNESS         = 0x0000000b,
    AM_AUDREND_STAT_PARAM_JITTER                 = 0x0000000c,
}

alias _AM_INTF_SEARCH_FLAGS = int;
enum : int
{
    AM_INTF_SEARCH_INPUT_PIN  = 0x00000001,
    AM_INTF_SEARCH_OUTPUT_PIN = 0x00000002,
    AM_INTF_SEARCH_FILTER     = 0x00000004,
}

///Specifies effects on a DirectDraw hardware overlay surface.
alias AMOVERLAYFX = int;
enum : int
{
    ///Normal video (no effects).
    AMOVERFX_NOFX            = 0x00000000,
    ///Mirror the overlay across the vertical axis.
    AMOVERFX_MIRRORLEFTRIGHT = 0x00000002,
    ///Mirror the overlay across the horizontal axis.
    AMOVERFX_MIRRORUPDOWN    = 0x00000004,
    ///When used in IAMOverlayFX::QueryOverlayFXCaps, this flag specifies whether the hardware can support the
    ///DirectDraw 7 DDOVERFX_DEINTERLACE hint. When used with the IAMOverlayFX::GetOverlayFX or
    ///IAMOverlayFX::SetOverlayFX methods, this flag indicates that the overlay should be deinterlaced if possible.
    AMOVERFX_DEINTERLACE     = 0x00000008,
}

alias _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS = int;
enum : int
{
    AM_PIN_FLOW_CONTROL_BLOCK = 0x00000001,
}

///Specifies how to reconnect filters when dynamically rebuilding the filter graph.
alias AM_GRAPH_CONFIG_RECONNECT_FLAGS = int;
enum : int
{
    ///Do not insert additional filters into the graph while reconnecting, aside from any filter explicitly requested.
    AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT           = 0x00000001,
    ///Place filters removed from the graph into the filter cache.
    AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS   = 0x00000002,
    ///When inserting additional filters into the graph, use only filters currently in the filter cache.
    AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS = 0x00000004,
}

alias _REM_FILTER_FLAGS = int;
enum : int
{
    REMFILTERF_LEAVECONNECTED = 0x00000001,
}

alias AM_FILTER_FLAGS = int;
enum : int
{
    AM_FILTER_FLAGS_REMOVABLE = 0x00000001,
}

///The [VMRPRESENTATIONINFO](/windows/desktop/api/strmif/ns-strmif-vmrpresentationinfo) structure .
enum VMRPresentationFlags : int
{
    ///Indicates that the sample is a sync point.
    VMRSample_SyncPoint        = 0x00000001,
    ///Indicates that the sample is part of the preroll.
    VMRSample_Preroll          = 0x00000002,
    ///Indicates that the sample is a discontinuity.
    VMRSample_Discontinuity    = 0x00000004,
    ///Indicates that the time stamp on the sample is valid.
    VMRSample_TimeValid        = 0x00000008,
    VMRSample_SrcDstRectsValid = 0x00000010,
}

///The <b>VMRSurfaceAllocationFlags</b> enumeration is used with the IVMRSurfaceAllocator::AllocateSurface method to
///specify surface creation parameters.
enum VMRSurfaceAllocationFlags : int
{
    ///Indicates that the <b>lpPxFmt</b> field contains valid data that should be used to create the DirectDraw surface.
    AMAP_PIXELFORMAT_VALID = 0x00000001,
    ///Indicates that the DirectDraw surface created should also be a Direct3D render target that is created with the
    ///<b>DDSCAPS_3DDEVICE</b> flag set.
    AMAP_3D_TARGET         = 0x00000002,
    ///Indicates that if you can't allocate the DirectDraw surface in video memory you will try to allocate a system
    ///memory DirectDraw surface. (Note you should never allocate an AGP memory surface.)
    AMAP_ALLOW_SYSMEM      = 0x00000004,
    ///Force the surface to be created in system memory. Specify this if you will use GDI to process the image before it
    ///is renderered. The surface must match the current monitor display format (pixel depth).
    AMAP_FORCE_SYSMEM      = 0x00000008,
    ///Means that when Flip is called you should Flip to the specified DirectDraw Surface passed as a parameter to the
    ///PresentImage method in the IVMRImagePresenter interface. Correct support for this flag is crucial in order to
    ///keep DXVA buffers seen by a video decoder in sync with the DXVA buffers seen by the graphics driver.
    AMAP_DIRECTED_FLIP     = 0x00000010,
    ///Indicates that this surface will be used as a DXVA target.
    AMAP_DXVA_TARGET       = 0x00000020,
}

///The <b>VMR_ASPECT_RATIO_MODE</b> enumeration type describes whether the Video Mixing Renderer Filter 7 preserves the
///aspect ratio of the source video.
alias VMR_ASPECT_RATIO_MODE = int;
enum : int
{
    ///Indicates that the VMR will not try to maintain the aspect ratio of the source video.
    VMR_ARMODE_NONE       = 0x00000000,
    ///Indicates that the VMR will maintain the aspect ratio of the source video by letterboxing within the output
    ///rectangle.
    VMR_ARMODE_LETTER_BOX = 0x00000001,
}

///The <b>VMRMixerPrefs</b> enumeration contains flags that specify decimation, filtering, and color space information
///that will be used when the video image is created on the DirectDraw surface.
enum VMRMixerPrefs : int
{
    ///No decimation. The video will be rendered onto the surface in its native size.
    MixerPref_NoDecimation         = 0x00000001,
    ///Decimate output by 2 in the x and y directions.
    MixerPref_DecimateOutput       = 0x00000002,
    ///Adjust the horizontal or vertical size of the video streams to match the target aspect ratio. If this flag is not
    ///present, the VMR adjusts the horizontal size only. For more information, see Aspect Ratio Correction.
    MixerPref_ARAdjustXorY         = 0x00000004,
    ///Reserved.
    MixerPref_DecimationReserved   = 0x00000008,
    ///Bitmask to isolate the flags that control decimation. (This value is not a valid flag.)
    MixerPref_DecimateMask         = 0x0000000f,
    ///Use bi-linear filtering. This is the default type of filtering, but not all cards can support it.
    MixerPref_BiLinearFiltering    = 0x00000010,
    ///Use point filtering.
    MixerPref_PointFiltering       = 0x00000020,
    ///Bitmask to isolate the flags the control filtering. (This value is not a valid flag.)
    MixerPref_FilteringMask        = 0x000000f0,
    ///The render target is an RGB surface.
    MixerPref_RenderTargetRGB      = 0x00000100,
    ///The render target is a YUV surface. Requires Windows XP Service Pack 2. For more information, see YUV Mixing
    ///Mode.
    MixerPref_RenderTargetYUV      = 0x00001000,
    ///The render target is a YUV 4:2:0 surface. <div class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    MixerPref_RenderTargetYUV420   = 0x00000200,
    ///The render target is a YUV 4:2:2 surface. <div class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    MixerPref_RenderTargetYUV422   = 0x00000400,
    ///The render target is a YUV 4:4:4 surface. <div class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    MixerPref_RenderTargetYUV444   = 0x00000800,
    ///Reserved.
    MixerPref_RenderTargetReserved = 0x0000e000,
    ///Bitmask to isolate flags that control the render target. (This value is not a valid flag.)
    MixerPref_RenderTargetMask     = 0x0000ff00,
    ///In YUV mixing mode only, this flag switches the VMR to bob deinterlacing. You can add or remove this flag while
    ///the filter graph is running; the change will be applied when the VMR mixer composes the next video frame.
    MixerPref_DynamicSwitchToBOB   = 0x00010000,
    ///In YUV mixing mode only, this flag causes the VMR to decimate the image by a factor of 2 horizontally and
    ///vertically. You can add or remove this flag while the filter graph is running; the change is applied when the VMR
    ///mixer composes the next video frame.
    MixerPref_DynamicDecimateBy2   = 0x00020000,
    ///Reserved.
    MixerPref_DynamicReserved      = 0x000c0000,
    ///Bitmask to isolate the MixerPref_DynamicSwitchToBOB and MixerPref_DynamicDecimateBy2 flags. (This value is not a
    ///valid flag.)
    MixerPref_DynamicMask          = 0x000f0000,
}

///The <b>VMRRenderPrefs</b> enumeration type is used with the IVMRFilterConfig::GetRenderingPrefs and
///IVMRFilterConfig::SetRenderingPrefs methods to get and set basic rendering preferences.
enum VMRRenderPrefs : int
{
    ///Not implemented; do not use.
    RenderPrefs_RestrictToInitialMonitor     = 0x00000000,
    ///Indicates that the Video Mixing Renderer Filter 7 (VMR-7) should use only offscreen surfaces for rendering.
    RenderPrefs_ForceOffscreen               = 0x00000001,
    ///Indicates that the VMR-7 should fail if no overlay surfaces are available.
    RenderPrefs_ForceOverlays                = 0x00000002,
    ///Indicates that the VMR-7 should use overlays if they are available. Should not be used by new applications.
    RenderPrefs_AllowOverlays                = 0x00000000,
    ///Indicates that the VMR-7 should use offscreen surfaces if no overlays are available. Should not be used by new
    ///applications.
    RenderPrefs_AllowOffscreen               = 0x00000000,
    ///Indicates that the application is responsible for painting the color keys.
    RenderPrefs_DoNotRenderColorKeyAndBorder = 0x00000008,
    ///Reserved; do not use.
    RenderPrefs_Reserved                     = 0x00000010,
    ///Indicates that the VMR-7 should attempt to use AGP memory when allocating texture surfaces.
    RenderPrefs_PreferAGPMemWhenMixing       = 0x00000020,
    ///Bitwise <b>OR</b> of all of the above flags.
    RenderPrefs_Mask                         = 0x0000003f,
}

///The <b>VMRMode</b> enumeration type is used in calls to the IVMRFilterConfig::GetRenderingMode and
///IVMRFilterConfig::SetRenderingMode methods to retrieve or specify the Video Mixing Renderer Filter 7 (VMR-7)
///rendering mode.
alias VMRMode = int;
enum : int
{
    ///Windowed mode.
    VMRMode_Windowed   = 0x00000001,
    ///Windowless mode.
    VMRMode_Windowless = 0x00000002,
    ///Renderless mode.
    VMRMode_Renderless = 0x00000004,
    ///Bitwise <b>OR</b> of all above flags; this is not a valid value to pass to SetRenderingMode.
    VMRMode_Mask       = 0x00000007,
}

alias __MIDL___MIDL_itf_strmif_0000_0122_0001 = int;
enum : int
{
    MAX_NUMBER_OF_STREAMS = 0x00000010,
}

///The <b>VMRDeinterlacePrefs</b> enumeration type describes the deinterlacing method that the Video Mixing Renderer
///Filter 7 (VMR-7) uses if the method set by the application cannot be used.
enum VMRDeinterlacePrefs : int
{
    ///Use the next best mode offered by the driver.
    DeinterlacePref_NextBest = 0x00000001,
    ///Use the bob method.
    DeinterlacePref_BOB      = 0x00000002,
    ///Use the weave method (that is, no deinterlacing).
    DeinterlacePref_Weave    = 0x00000004,
    ///Bitwise <b>OR</b> of the previous flags. This value is not a valid flag.
    DeinterlacePref_Mask     = 0x00000007,
}

///The <b>VMRDeinterlaceTech</b> enumeration type describes the algorithm used for deinterlacing a video stream. The
///flags are not mutually exclusive; drivers can set a combination of flags.
enum VMRDeinterlaceTech : int
{
    ///The algorithm is unknown or proprietary.
    DeinterlaceTech_Unknown             = 0x00000000,
    ///The algorithm creates each missing line by repeating the line above it or below it. This method creates jagged
    ///artifacts and is not recommended.
    DeinterlaceTech_BOBLineReplicate    = 0x00000001,
    ///The algorithm creates the missing lines by vertically stretching each video field by a factor of two. For
    ///example, it might average two lines or use a (-1, 9, 9, -1)/16 filter across four lines. Slight vertical
    ///adjustments are made to ensure that the resulting image does not "bob" up and down.
    DeinterlaceTech_BOBVerticalStretch  = 0x00000002,
    ///The algorithm uses median filtering to recreate the pixels in the missing lines.
    DeinterlaceTech_MedianFiltering     = 0x00000004,
    ///The algorithm uses an edge filter to create the missing lines. In this process, spatial directional filters are
    ///applied to determine the orientation of edges in the picture content. Missing pixels are created by filtering
    ///along (rather than across) the detected edges.
    DeinterlaceTech_EdgeFiltering       = 0x00000010,
    ///The algorithm uses spatial or temporal interpolation, switching between the two on a field-by-field basis,
    ///depending on the amount of motion.
    DeinterlaceTech_FieldAdaptive       = 0x00000020,
    ///The algorithm uses spatial or temporal interpolation, switching between the two on a pixel-by-pixel basis,
    ///depending on the amount of motion.
    DeinterlaceTech_PixelAdaptive       = 0x00000040,
    ///The algorithm identifies objects within a sequence of video fields. Before it recreates the missing pixels, it
    ///aligns the movement axes of the individual objects in the scene to make them parallel with the time axis.
    DeinterlaceTech_MotionVectorSteered = 0x00000080,
}

///Defines the DVD domains.
alias DVD_DOMAIN = int;
enum : int
{
    ///Performing default initialization of a DVD disc.
    DVD_DOMAIN_FirstPlay         = 0x00000001,
    ///Displaying menus for whole disc.
    DVD_DOMAIN_VideoManagerMenu  = 0x00000002,
    ///Displaying menus for current title set.
    DVD_DOMAIN_VideoTitleSetMenu = 0x00000003,
    ///Displaying the current title.
    DVD_DOMAIN_Title             = 0x00000004,
    ///The DVD Navigator is in the DVD Stop domain.
    DVD_DOMAIN_Stop              = 0x00000005,
}

///Specifies the DVD menu in a call to IDvdControl2::ShowMenu.
alias DVD_MENU_ID = int;
enum : int
{
    ///Specifies the top menu in a DVD-Video volume. This menu is also known as the Title Menu or Video Manager Menu and
    ///it provides access to all VTS (Video Title Set) menus on the disc.
    DVD_MENU_Title      = 0x00000002,
    ///Specifies the root menu for a VTS.
    DVD_MENU_Root       = 0x00000003,
    ///Specifies the subpicture submenu in a VTS menu.
    DVD_MENU_Subpicture = 0x00000004,
    ///Specifies the audio submenu in a VTS menu.
    DVD_MENU_Audio      = 0x00000005,
    ///Specifies the angle submenu in a VTS menu.
    DVD_MENU_Angle      = 0x00000006,
    ///Choose a chapter submenu in a VTS menu.
    DVD_MENU_Chapter    = 0x00000007,
}

///Indicates the sides of a DVD disc.
alias DVD_DISC_SIDE = int;
enum : int
{
    ///Side A.
    DVD_SIDE_A = 0x00000001,
    ///Side B.
    DVD_SIDE_B = 0x00000002,
}

///<div class="alert"><b>Note</b> Deprecated.</div><div> </div> Indicates the user's preferred window aspect ratio and
///conversion method.
alias DVD_PREFERRED_DISPLAY_MODE = int;
enum : int
{
    ///Use the default window size and content type.
    DISPLAY_CONTENT_DEFAULT         = 0x00000000,
    ///Use a 16 x 9 window.
    DISPLAY_16x9                    = 0x00000001,
    ///Use a 4 x 3 window and convert to pan-scan, if possible.
    DISPLAY_4x3_PANSCAN_PREFERRED   = 0x00000002,
    ///Use a 4 x 3 window and convert to letterbox, if possible.
    DISPLAY_4x3_LETTERBOX_PREFERRED = 0x00000003,
}

///Indicates whether the DVD is authored to play at 25 or 30 frames per second.
alias DVD_FRAMERATE = int;
enum : int
{
    ///Twenty-five frames per second.
    DVD_FPS_25        = 0x00000001,
    ///Exactly 30 frames per second.
    DVD_FPS_30NonDrop = 0x00000003,
}

///Defines DVD navigation command types.
alias DVD_NavCmdType = int;
enum : int
{
    ///Pre-command.
    DVD_NavCmdType_Pre    = 0x00000001,
    ///Post-command.
    DVD_NavCmdType_Post   = 0x00000002,
    ///Cell command.
    DVD_NavCmdType_Cell   = 0x00000003,
    ///Button command.
    DVD_NavCmdType_Button = 0x00000004,
}

///Indicates the frame rate at which a DVD has been authored to play.
alias DVD_TIMECODE_FLAGS = int;
enum : int
{
    ///Disc is authored to play at 25 frames per second.
    DVD_TC_FLAG_25fps        = 0x00000001,
    ///Disc is authored to play at 30 frames per second.
    DVD_TC_FLAG_30fps        = 0x00000002,
    ///Disc is authored to play at 29.97 frames per second.
    DVD_TC_FLAG_DropFrame    = 0x00000004,
    ///Value representing the DVD Navigator Filter filter's best estimate of the disc's frame rate.
    DVD_TC_FLAG_Interpolated = 0x00000008,
}

///Indicates which user operation (UOP) commands are currently allowed by the DVD.
alias VALID_UOP_FLAG = int;
enum : int
{
    ///Annex J commands: Time_Play, TimeSearch.
    UOP_FLAG_Play_Title_Or_AtTime                   = 0x00000001,
    ///Annex J commands: PTT_Play, PTT_Search.
    UOP_FLAG_Play_Chapter                           = 0x00000002,
    ///Annex J command: Title_Play.
    UOP_FLAG_Play_Title                             = 0x00000004,
    ///Annex J command: Stop.
    UOP_FLAG_Stop                                   = 0x00000008,
    ///Annex J command: GoUp.
    UOP_FLAG_ReturnFromSubMenu                      = 0x00000010,
    ///Annex J commands: Time_Search, PTT_Search.
    UOP_FLAG_Play_Chapter_Or_AtTime                 = 0x00000020,
    ///Annex J commands: PrevPG_Search, TopPG_Search.
    UOP_FLAG_PlayPrev_Or_Replay_Chapter             = 0x00000040,
    ///Annex J command: NextPG_Search.
    UOP_FLAG_PlayNext_Chapter                       = 0x00000080,
    ///Annex J command: Forward_Scan.
    UOP_FLAG_Play_Forwards                          = 0x00000100,
    ///Annex J command: Backward_Scan.
    UOP_FLAG_Play_Backwards                         = 0x00000200,
    ///Annex J command: Menu_Call(<i>Title</i>).
    UOP_FLAG_ShowMenu_Title                         = 0x00000400,
    ///Annex J command: Menu_Call(<i>Root</i>).
    UOP_FLAG_ShowMenu_Root                          = 0x00000800,
    ///Annex J command: Menu_Call(<i>Sub-picture</i>).
    UOP_FLAG_ShowMenu_SubPic                        = 0x00001000,
    ///Annex J command: Menu_Call(<i>Audio</i>).
    UOP_FLAG_ShowMenu_Audio                         = 0x00002000,
    ///Annex J command: Menu_Call(<i>Angle</i>).
    UOP_FLAG_ShowMenu_Angle                         = 0x00004000,
    ///Annex J command: Menu_Call(<i>PTT</i>).
    UOP_FLAG_ShowMenu_Chapter                       = 0x00008000,
    ///Annex J command: Resume.
    UOP_FLAG_Resume                                 = 0x00010000,
    ///Annex J commands: Upper_Button_Select, Lower_Button_Select, Left_Button_Select, Right_Button_Select,
    ///Button_Activate, Button_Select_And_Activate.
    UOP_FLAG_Select_Or_Activate_Button              = 0x00020000,
    ///Annex J command: Still_Off.
    UOP_FLAG_Still_Off                              = 0x00040000,
    ///Annex J command: Pause_On.
    UOP_FLAG_Pause_On                               = 0x00080000,
    ///Annex J command: Audio_Stream_Change.
    UOP_FLAG_Select_Audio_Stream                    = 0x00100000,
    ///Annex J command: Sub-picture_Stream_Change.
    UOP_FLAG_Select_SubPic_Stream                   = 0x00200000,
    ///Annex J command : Angle_Change.
    UOP_FLAG_Select_Angle                           = 0x00400000,
    ///Annex J command: Karaoke_Audio_Presentation_Mode_Change.
    UOP_FLAG_Select_Karaoke_Audio_Presentation_Mode = 0x00800000,
    ///Annex J command: Video_Presentation_Mode_Change.
    UOP_FLAG_Select_Video_Mode_Preference           = 0x01000000,
}

///Defines flags that control how the DVD Navigator Filter filter handles command synchronization.
alias DVD_CMD_FLAGS = int;
enum : int
{
    ///The DVD Navigator will not flush its buffers when it issues the command, will not send any events, and will not
    ///to block the thread of execution on any method call.
    DVD_CMD_FLAG_None              = 0x00000000,
    ///The DVD Navigator will flush all of its buffered video data before issuing the command. This can cause the DVD
    ///Navigator to discard approximately two seconds of video, which will decrease the response time but cause a gap in
    ///the playback data.
    DVD_CMD_FLAG_Flush             = 0x00000001,
    ///The DVD Navigator will send an EC_DVD_CMD_START event when the command begins, and an EC_DVD_CMD_END event when
    ///the command ends. The event parameters contain the status code of the operation.
    DVD_CMD_FLAG_SendEvents        = 0x00000002,
    ///The DVD Navigator blocks until the command completes or is canceled.
    DVD_CMD_FLAG_Block             = 0x00000004,
    ///Currently not used.
    DVD_CMD_FLAG_StartWhenRendered = 0x00000008,
    ///The DVD Navigator will block until the specified action is actually rendered. This flag can be used with the
    ///following methods: <ul> <li> IDvdControl2::PlayChaptersAutoStop </li> <li>
    ///IDvdControl2::PlayPeriodInTitleAutoStop </li> <li> IDvdControl2::SelectSubpictureStream </li> <li>
    ///IDvdControl2::SetSubpictureState </li> </ul> For example, when used with PlayChaptersAutoStop, this flag causes
    ///the DVD Navigator to block until the specified chapters have all played. When used with SelectSubpictureStream,
    ///the flag causes the DVD Navigator to block until the new subpicture is rendered.
    DVD_CMD_FLAG_EndAfterRendered  = 0x00000010,
}

///The <b>DVD_OPTION_FLAG</b> enumeration defines flags that control the behavior of the DVD Navigator Filter. To set
///any of these flags, call IDvdControl2::SetOption.
alias DVD_OPTION_FLAG = int;
enum : int
{
    ///Specifies whether the DVD Navigator returns to the start of the disc when the graph stops. <table> <tr>
    ///<th>Value</th> <th>Description</th> </tr> <tr> <td><b>TRUE</b></td> <td>The DVD Navigator enters the DVD Stop
    ///domain when the filter graph stops. When playback resumes, it starts at the beginning of the disc. </td> </tr>
    ///<tr> <td><b>FALSE</b></td> <td>The DVD Navigator does not enter the DVD Stop domain when the filter graph stops.
    ///When the filter graph starts again, playback resumes from the point where it stopped.</td> </tr> </table> The
    ///default value is <b>TRUE</b>. The default behavior is not always desirable, because the filter graph might be
    ///stopped unexpectedly. This can happen, for example, if the screen resolution changes, a screen saver starts, or
    ///the computer goes into suspended mode. In these situations, the user probably wants playback to restart from the
    ///same point. Typically, the application should set this flag to <b>FALSE</b> immediately before calling
    ///IMediaControl::Run. It should set the flag to <b>TRUE</b> before calling IMediaControl::Stop in response to an
    ///explicit user to command to stop playback.
    DVD_ResetOnStop                     = 0x00000001,
    ///Specifies whether the DVD Navigator notifies the application when the parental level changes on the disc. <table>
    ///<tr> <th>Value</th> <th>Description</th> </tr> <tr> <td><b>TRUE</b></td> <td>If the DVD Navigator reaches a
    ///temporary parental management level command, it sends the application an EC_DVD_PARENTAL_LEVEL_CHANGE event. It
    ///blocks playback until it the application responds by calling IDvdControl2::AcceptParentalLevelChange.</td> </tr>
    ///<tr> <td><b>FALSE</b></td> <td>When the DVD Navigator encounters a temporary parental management level command
    ///and the current parental level is too low, the Navigator automatically rejects the command and branches to
    ///whatever path the disc specifies. The Navigator sends an EC_DVD_PARENTAL_LEVEL_CHANGE event indicating the
    ///required level. The application can stop playback, put up a password dialog box, and restart playback so that it
    ///can succeed on the next attempt.</td> </tr> </table> The default value <b>FALSE</b>.
    DVD_NotifyParentalLevelChange       = 0x00000002,
    ///Specifies the format for timecode information. <table> <tr> <th>Value</th> <th>Description</th> </tr> <tr>
    ///<td><b>TRUE</b></td> [DVD_HMSF_TIMECODE](/windows/desktop/api/strmif/ns-strmif-dvd_hmsf_timecode) structure.</td>
    ///</tr> <tr> <td><b>FALSE</b></td> [DVD_TIMECODE](/windows/desktop/api/strmif/ns-strmif-dvd_timecode) structure.
    ///</td> </tr> </table> For backward compatibility, the default value is
    ///[DVD_HMSF_TIMECODE](/windows/desktop/api/strmif/ns-strmif-dvd_hmsf_timecode) format is easier to use.
    DVD_HMSF_TimeCodeEvents             = 0x00000003,
    ///Specifies the format for timecode information. <table> <tr> <th>Value</th> <th>Description</th> </tr> <tr>
    ///<td><b>TRUE</b></td> <td>The DVD Navigator enables audio during fast forward and rewind, as long as the audio
    ///rate does not exceed the maximum rate of the audio decoder. </td> </tr> <tr> <td><b>FALSE</b></td> <td>The
    ///Navigator disables audio during fast forward and rewind. </td> </tr> </table> The default value is <b>FALS</b>E.
    ///You can also enable audio during fast forward and rewind by creating the following key in the Windows registry:
    ///<code>DWORD HKLM\Software\Microsoft\DVDNavigator\AudioDuringFFwdRev = 1</code> This has the same effect as
    ///setting the DVD_AudioDuringFFwdRew flag to <b>TRUE</b>.
    DVD_AudioDuringFFwdRew              = 0x00000004,
    ///<div class="alert"><b>Note</b> Requires Windows XP Service Pack 2 or later. </div> <div> </div> If this flag is
    ///<b>FALSE</b>, certain DVD Navigator functions block until the DVD Navigator can complete the operation. This is
    ///the default behavior. If this flag is <b>TRUE</b>, those functions no longer block. Instead, if the DVD Navigator
    ///cannot complete the operation immediately, the function returns <b>VFW_E_DVD_NONBLOCKING</b>. If the application
    ///sets this flag to <b>TRUE</b>, it must handle the <b>VFW_E_DVD_NONBLOCKING</b> error code. Usually the correct
    ///behavior is to poll the function until the function succeeds or returns some other error code. This flag affects
    ///at least the following methods: IDvdControl2::ActivateAtPosition, IDvdControl2::SelectAtPosition,
    ///IDvdInfo2::GetCurrentLocation, IDvdInfo2::GetState. This list may be expanded in the future.
    DVD_EnableNonblockingAPIs           = 0x00000005,
    ///<div class="alert"><b>Note</b> Requires Windows Vista or later.</div> <div> </div> Specifies how much data the
    ///DVD Navigator reads in advance, in MB. For this flag, the <i>bEnable</i> parameter of SetOption is interpreted as
    ///a <b>DWORD</b> value, rather than a Boolean. If the application sets this flag to a large value (&gt; 50 MB), the
    ///DVD drive may spin down after the initial pre-fetch, depending on the hardware. You can also set the cache size
    ///by creating the following registry key: <code>HKLM\Software\Microsoft\DVDNavigator\CacheSizeInMB</code>. This
    ///registry key is intended for diagnostic purposes only. Applications should use the <b>DVD_CacheSizeInMB</b> flag,
    ///not the registry key.
    DVD_CacheSizeInMB                   = 0x00000006,
    ///<div class="alert"><b>Note</b> Requires Windows Vista or later. </div> <div> </div> <table> <tr> <th>Value</th>
    ///<th>Description</th> </tr> <tr> <td><b>TRUE</b></td> <td>DVD bookmarks can be used on another computer. See
    ///Saving and Restoring DvdState Objects.</td> </tr> <tr> <td><b>FALSE</b></td> <td>DVD bookmarks are usable only on
    ///the computer where they were created.</td> </tr> </table> The default value is <b>FALSE</b>.
    DVD_EnablePortableBookmarks         = 0x00000007,
    ///<div class="alert"><b>Note</b> Requires Windows Vista or later. </div> <div> </div> If this flag <b>TRUE</b>, the
    ///DVD Navigator supports an extended set of errors related to copy protection failures. These errors are conveyed
    ///through the EC_DVD_ERROR event, and include the following: <ul>
    ///<li>DVD_PB_STOPPED_CopyProtectOutputNotSupported</li> <li>DVD_PB_STOPPED_CopyProtectOutputFailure</li> </ul> (See
    ///DVD_PB_STOPPED.) If this flag is <b>FALSE</b>, all copy protection errors are reported using the general
    ///<b>DVD_PB_STOPPED_CopyProtectFailure</b> error code. For backward compatibility, the default value is
    ///<b>FALSE</b>.
    DVD_EnableExtendedCopyProtectErrors = 0x00000008,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later. </div> <div> </div> If this flag is <b>TRUE</b>, the
    ///following events are enabled: <ul> <li> EC_DVD_PROGRAM_CELL_CHANGE </li> <li> EC_DVD_PROGRAM_CHAIN_CHANGE </li>
    ///<li> EC_DVD_TITLE_SET_CHANGE </li> </ul> The default value for this flag is <b>FALSE</b>.
    DVD_NotifyPositionChange            = 0x00000009,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later. </div> <div> </div> Bitwise <b>OR</b> of the
    ///following flags: <table> <tr> <th>Flag</th> <th>Description</th> </tr> <tr> <td>0x01</td> <td>Enforce
    ///High-Bandwidth Digital Content Protection (HDCP) without fallback.</td> </tr> <tr> <td>0x02</td> <td>Enforce HDCP
    ///even for DVD discs that do not have Content Scramble System (CSS) protection.</td> </tr> </table> The default
    ///value is zero. These flags are intended for purposes. The recommended value is zero.
    DVD_IncreaseOutputControl           = 0x0000000a,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later. </div> <div> </div> Enables or disables <i>streaming
    ///mode</i>. In streaming mode, bad blocks on the disc are skipped. The DVD Navigator receives partially corrected
    ///data. This mode generally produces better results when playing scratched or damaged disks, because it results in
    ///brief video corruption, rather than long waits that block playback. The DVD drive must support streaming I/O. The
    ///default value is <b>TRUE</b>.
    DVD_EnableStreaming                 = 0x0000000b,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later. </div> <div> </div> Enables the DVD Navigator to
    ///output elementary streams. For more information, see the media types listed in the topic DVD Navigator Filter.
    ///The default value is <b>FALSE</b>.
    DVD_EnableESOutput                  = 0x0000000c,
    ///<i></i> <div class="alert"><b>Note</b> Requires Windows 7 or later. </div> <div> </div> <table> <tr>
    ///<th>Value</th> <th>Description</th> </tr> <tr> <td><b>TRUE</b></td>
    ///[DVD_TitleAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_titleattributes) structure.</td> </tr> <tr>
    ///<td><b>FALSE</b></td> <td>The GetTitleAttributes method returns the title mode (karaoke mode or other mode) and
    ///not the title length.</td> </tr> </table> The default value is <b>FALSE</b>.
    DVD_EnableTitleLength               = 0x0000000d,
    ///If this flag is <b>TRUE</b>, it disables a call to <code>Sleep(1)</code> that the Navigator otherwise makes when
    ///displaying stills. For backward compatibility, the default value for this flag is <b>FALSE</b>, but the
    ///recommended value is <b>TRUE</b>. <div class="alert"><b>Note</b> Requires Windows 7 or later. </div> <div> </div>
    DVD_DisableStillThrottle            = 0x0000000e,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later. </div> <div> </div> If this flag is <b>TRUE</b>, the
    ///following events are enabled: <ul> <li> EC_DVD_BeginNavigationCommands </li> <li> EC_DVD_GPRM_Change </li> <li>
    ///EC_DVD_NavigationCommand </li> <li> EC_DVD_SPRM_Change </li> <li> EC_DVD_VOBU_Offset </li> <li>
    ///EC_DVD_VOBU_Timestamp </li> </ul> The default value for this flag is <b>FALSE</b>.
    DVD_EnableLoggingEvents             = 0x0000000f,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later. </div> <div> </div> The maximum amount of data that
    ///the DVD Navigator will read ahead in a single burst, in kilobytes. For this flag, the <i>bEnable</i> parameter of
    ///SetOption is interpreted as a <b>DWORD</b> value. The default value is 128 KB.
    DVD_MaxReadBurstInKB                = 0x00000010,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later. </div> <div> </div> How often to perform burst reads
    ///into the cache, in milliseconds. For this flag, the <i>bEnable</i> parameter of SetOption is interpreted as a
    ///<b>DWORD</b> value. The default value is 250 milliseconds.
    DVD_ReadBurstPeriodInMS             = 0x00000011,
    DVD_RestartDisc                     = 0x00000012,
    DVD_EnableCC                        = 0x00000013,
}

///Identifies the four directional buttons used for DVD menu navigation and other operations.
alias DVD_RELATIVE_BUTTON = int;
enum : int
{
    ///Upper button.
    DVD_Relative_Upper = 0x00000001,
    ///Lower button.
    DVD_Relative_Lower = 0x00000002,
    ///Left button.
    DVD_Relative_Left  = 0x00000003,
    ///Right button.
    DVD_Relative_Right = 0x00000004,
}

///Identifies flags for the generic parental levels defined in the DVD specification.
alias DVD_PARENTAL_LEVEL = int;
enum : int
{
    ///Parental level 8.
    DVD_PARENTAL_LEVEL_8 = 0x00008000,
    ///Parental level 7.
    DVD_PARENTAL_LEVEL_7 = 0x00004000,
    ///Parental level 6.
    DVD_PARENTAL_LEVEL_6 = 0x00002000,
    ///Parental level 5.
    DVD_PARENTAL_LEVEL_5 = 0x00001000,
    ///Parental level 4.
    DVD_PARENTAL_LEVEL_4 = 0x00000800,
    ///Parental level 3.
    DVD_PARENTAL_LEVEL_3 = 0x00000400,
    ///Parental level 2.
    DVD_PARENTAL_LEVEL_2 = 0x00000200,
    ///Parental level 1.
    DVD_PARENTAL_LEVEL_1 = 0x00000100,
}

///Defines flags that indicate whether an audio stream contains audio language extensions.
alias DVD_AUDIO_LANG_EXT = int;
enum : int
{
    ///The DVD doesn't specify an audio language extension for this audio stream.
    DVD_AUD_EXT_NotSpecified      = 0x00000000,
    ///The audio stream contains captions.
    DVD_AUD_EXT_Captions          = 0x00000001,
    ///The audio stream contains content for people with low vision.
    DVD_AUD_EXT_VisuallyImpaired  = 0x00000002,
    ///The audio stream contains "director comments 1."
    DVD_AUD_EXT_DirectorComments1 = 0x00000003,
    ///The audio stream contains "director comments 2."
    DVD_AUD_EXT_DirectorComments2 = 0x00000004,
}

///Defines the possible language extensions in a specified subpicture stream.
alias DVD_SUBPICTURE_LANG_EXT = int;
enum : int
{
    ///Indicates that no language extensions are present.
    DVD_SP_EXT_NotSpecified              = 0x00000000,
    ///Indicates that the specified stream contains normal captions.
    DVD_SP_EXT_Caption_Normal            = 0x00000001,
    ///Indicates that the specified stream contains big captions.
    DVD_SP_EXT_Caption_Big               = 0x00000002,
    ///Indicates that the specified stream contains captions for children.
    DVD_SP_EXT_Caption_Children          = 0x00000003,
    ///Indicates that the specified stream contains normal closed captions.
    DVD_SP_EXT_CC_Normal                 = 0x00000005,
    ///Indicates that the specified stream contains big closed captions.
    DVD_SP_EXT_CC_Big                    = 0x00000006,
    ///Indicates that the specified stream contains closed captions for children.
    DVD_SP_EXT_CC_Children               = 0x00000007,
    ///Indicates that the subpicture stream is forcedly activated, meaning that the application will not be able to turn
    ///it off.
    DVD_SP_EXT_Forced                    = 0x00000009,
    ///Indicates that the specified stream contains normal-sized director's comments.
    DVD_SP_EXT_DirectorComments_Normal   = 0x0000000d,
    ///Indicates that the specified stream contains large-sized director's comments.
    DVD_SP_EXT_DirectorComments_Big      = 0x0000000e,
    ///Indicates that the specified stream contains director's comments for children.
    DVD_SP_EXT_DirectorComments_Children = 0x0000000f,
}

///Indicates the current audio mode as retrieved in a call to IDvdInfo2::GetAudioAttributes.
alias DVD_AUDIO_APPMODE = int;
enum : int
{
    ///No special audio mode. The DVD Navigator Filter will send the audio to the decoder with no special processing.
    DVD_AudioMode_None     = 0x00000000,
    ///The current audio mode is karaoke content.
    DVD_AudioMode_Karaoke  = 0x00000001,
    ///The current audio mode is surround sound.
    DVD_AudioMode_Surround = 0x00000002,
    ///Unrecognized audio mode.
    DVD_AudioMode_Other    = 0x00000003,
}

///Indicates the audio format of a DVD.
alias DVD_AUDIO_FORMAT = int;
enum : int
{
    ///Audio format is Dolby AC-3.
    DVD_AudioFormat_AC3       = 0x00000000,
    ///Audio format is MPEG-1.
    DVD_AudioFormat_MPEG1     = 0x00000001,
    ///Audio format is MPEG-1 with dynamic range control.
    DVD_AudioFormat_MPEG1_DRC = 0x00000002,
    ///Audio format is MPEG-2.
    DVD_AudioFormat_MPEG2     = 0x00000003,
    ///Audio format is MPEG-2 with dynamic range control.
    DVD_AudioFormat_MPEG2_DRC = 0x00000004,
    ///Audio format is Linear Pulse Code Modulated (LPCM).
    DVD_AudioFormat_LPCM      = 0x00000005,
    ///Audio format is Digital Theater Systems (DTS).
    DVD_AudioFormat_DTS       = 0x00000006,
    ///Audio format is Sony Dynamic Digital Sound (SDDS).
    DVD_AudioFormat_SDDS      = 0x00000007,
    ///Audio format is unrecognized.
    DVD_AudioFormat_Other     = 0x00000008,
}

///Defines flags used by the IDvdControl2::SelectKaraokeAudioPresentationMode method to control which speakers, if any,
///each auxiliary channel is downmixed to.
alias DVD_KARAOKE_DOWNMIX = int;
enum : int
{
    ///Reserved.
    DVD_Mix_0to0 = 0x00000001,
    ///Reserved.
    DVD_Mix_1to0 = 0x00000002,
    ///Downmix channel 2 to the left speaker.
    DVD_Mix_2to0 = 0x00000004,
    ///Downmix channel 3 to the left speaker.
    DVD_Mix_3to0 = 0x00000008,
    ///Downmix channel 4 to the left speaker.
    DVD_Mix_4to0 = 0x00000010,
    ///Reserved.
    DVD_Mix_Lto0 = 0x00000020,
    ///Reserved.
    DVD_Mix_Rto0 = 0x00000040,
    ///Reserved.
    DVD_Mix_0to1 = 0x00000100,
    ///Reserved.
    DVD_Mix_1to1 = 0x00000200,
    ///Downmix channel 2 to the right speaker.
    DVD_Mix_2to1 = 0x00000400,
    ///Downmix channel 3 to the right speaker.
    DVD_Mix_3to1 = 0x00000800,
    ///Downmix channel 4 to the right speaker.
    DVD_Mix_4to1 = 0x00001000,
    ///Reserved.
    DVD_Mix_Lto1 = 0x00002000,
    ///Reserved.
    DVD_Mix_Rto1 = 0x00004000,
}

///Specifies flags that, when used in a bitwise <b>OR</b> operation, describe the contents of each channel of an audio
///stream in a karaoke title.
alias DVD_KARAOKE_CONTENTS = int;
enum : int
{
    ///The channel contains guide vocal 1.
    DVD_Karaoke_GuideVocal1  = 0x00000001,
    ///The channel contains guide vocal 2.
    DVD_Karaoke_GuideVocal2  = 0x00000002,
    ///The channel contains guide melody 1.
    DVD_Karaoke_GuideMelody1 = 0x00000004,
    ///The channel contains guide melody 2.
    DVD_Karaoke_GuideMelody2 = 0x00000008,
    ///The channel contains guide melody A.
    DVD_Karaoke_GuideMelodyA = 0x00000010,
    ///The channel contains guide melody B.
    DVD_Karaoke_GuideMelodyB = 0x00000020,
    ///The channel contains sound effect A.
    DVD_Karaoke_SoundEffectA = 0x00000040,
    ///The channel contains sound effect B.
    DVD_Karaoke_SoundEffectB = 0x00000080,
}

///Defines the speaker configuration for an audio stream.
alias DVD_KARAOKE_ASSIGNMENT = int;
enum : int
{
    ///Reserved.
    DVD_Assignment_reserved0 = 0x00000000,
    ///Reserved.
    DVD_Assignment_reserved1 = 0x00000001,
    ///The stream is assigned to the left and right speakers.
    DVD_Assignment_LR        = 0x00000002,
    ///The stream is assigned to the left, right, and middle speakers.
    DVD_Assignment_LRM       = 0x00000003,
    ///The stream is assigned to the left, right, and audio1 speakers.
    DVD_Assignment_LR1       = 0x00000004,
    ///The stream is assigned to the left, right, middle, and audio1 speakers.
    DVD_Assignment_LRM1      = 0x00000005,
    ///The stream is assigned to the left, right, and audio2 speakers.
    DVD_Assignment_LR12      = 0x00000006,
    ///The stream is assigned to the left, right, middle, and audio2 speakers.
    DVD_Assignment_LRM12     = 0x00000007,
}

///Defines the possible DVD video compression types.
alias DVD_VIDEO_COMPRESSION = int;
enum : int
{
    ///Unrecognized compression type.
    DVD_VideoCompression_Other = 0x00000000,
    ///MPEG-1 compression type.
    DVD_VideoCompression_MPEG1 = 0x00000001,
    ///MPEG-2 compression type.
    DVD_VideoCompression_MPEG2 = 0x00000002,
}

///Defines flags used to determine what kind of content the subpicture stream contains.
alias DVD_SUBPICTURE_TYPE = int;
enum : int
{
    ///The DVD does not specify the subpicture type.
    DVD_SPType_NotSpecified = 0x00000000,
    ///The subpicture contains language-related content such as movie subtitles or other text.
    DVD_SPType_Language     = 0x00000001,
    ///The subpicture contains nonlanguage-related content such as a bouncing ball in karaoke titles.
    DVD_SPType_Other        = 0x00000002,
}

///Indicates what kind of content the subpicture stream contains.
alias DVD_SUBPICTURE_CODING = int;
enum : int
{
    ///Indicates that the subpicture uses run length encoding.
    DVD_SPCoding_RunLength = 0x00000000,
    ///Indicates that subpicture uses extended encoding.
    DVD_SPCoding_Extended  = 0x00000001,
    ///Indicates that the subpicture uses some other encoding scheme.
    DVD_SPCoding_Other     = 0x00000002,
}

///Indicates whether a DVD title is a karaoke title. This enumeration is a member of the
///[DVD_TitleAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_titleattributes) structure, which is filled when an
///application calls the IDvdInfo2::GetTitleAttributes method.
alias DVD_TITLE_APPMODE = int;
enum : int
{
    ///The disc does not provide any application mode information about this title.
    DVD_AppMode_Not_Specified = 0x00000000,
    ///Title contains karaoke content.
    DVD_AppMode_Karaoke       = 0x00000001,
    ///Title contains a type of content that the DVD Navigator Filter does not recognize, so the application should
    ///treat the title as a regular DVD-Video title.
    DVD_AppMode_Other         = 0x00000003,
}

///Defines a subset of the DVD text-string types.
alias DVD_TextStringType = int;
enum : int
{
    ///Indicates the top-level of the logical hierarchy. Refers to the entire contents of a one-sided disc or one side
    ///of a two-sided disc.
    DVD_Struct_Volume      = 0x00000001,
    ///Indicates that all content strings, until the next <b>DVD_Struct_Title</b>, belong to one title.
    DVD_Struct_Title       = 0x00000002,
    ///Indicates the parental ID of the following strings.
    DVD_Struct_ParentalID  = 0x00000003,
    ///Indicates that all content strings, until the next <b>DVD_Struct_PartOfTitle</b>, belong to one chapter.
    DVD_Struct_PartOfTitle = 0x00000004,
    ///Indicates that all content strings, until the next <b>DVD_Struct_Cell</b>, belong to one cell, which can be a
    ///scene from a chapter.
    DVD_Struct_Cell        = 0x00000005,
    ///Indicates that the following content strings refer to the audio stream.
    DVD_Stream_Audio       = 0x00000010,
    ///Indicates that the following content strings refer to the subpicture stream.
    DVD_Stream_Subpicture  = 0x00000011,
    ///Indicates that the following content strings refer to the angle.
    DVD_Stream_Angle       = 0x00000012,
    ///Indicates that the following content strings refer to the audio channel.
    DVD_Channel_Audio      = 0x00000020,
    ///Indicates the most important content string. Strings of this type contain the name of the volume, title, chapter,
    ///and so on, and can follow any structure identifiers.
    DVD_General_Name       = 0x00000030,
    ///Identifies a content string with additional information about the title, chapter, and so on, described by the
    ///<b>DVD_General_Name</b> string. The exact nature or structure of these comments is not defined.
    DVD_General_Comments   = 0x00000031,
    ///Identifies a content string containing the name of a series to which the title belongs.
    DVD_Title_Series       = 0x00000038,
    ///Identifies a content string with the main movie title.
    DVD_Title_Movie        = 0x00000039,
    ///Identifies a content string containing the name of the video title.
    DVD_Title_Video        = 0x0000003a,
    ///Identifies a content string containing the name of the album title.
    DVD_Title_Album        = 0x0000003b,
    ///Identifies a content string containing the name of the song title.
    DVD_Title_Song         = 0x0000003c,
    ///Identifies a content string containing the name of the title of some other genre.
    DVD_Title_Other        = 0x0000003f,
    ///Identifies a content string with the name of the series localized to a particular country/region.
    DVD_Title_Sub_Series   = 0x00000040,
    ///Identifies a content string with the movie title localized to a particular country/region.
    DVD_Title_Sub_Movie    = 0x00000041,
    ///Identifies a content string with the video title localized to a particular country/region.
    DVD_Title_Sub_Video    = 0x00000042,
    ///Identifies a content string with the album title localized to a particular country/region.
    DVD_Title_Sub_Album    = 0x00000043,
    ///Identifies a content string with the song title localized to a particular country/region.
    DVD_Title_Sub_Song     = 0x00000044,
    ///Identifies a content string with the title of some other genre localized to a particular country/region.
    DVD_Title_Sub_Other    = 0x00000047,
    ///Identifies a content string with the original name of the series.
    DVD_Title_Orig_Series  = 0x00000048,
    ///Identifies a content string with the original name of the movie.
    DVD_Title_Orig_Movie   = 0x00000049,
    ///Identifies a content string with the original name of the video.
    DVD_Title_Orig_Video   = 0x0000004a,
    ///Identifies a content string with the original name of the album.
    DVD_Title_Orig_Album   = 0x0000004b,
    ///Identifies a content string with the original name of the song.
    DVD_Title_Orig_Song    = 0x0000004c,
    ///Identifies a content string with the original name of the content.
    DVD_Title_Orig_Other   = 0x0000004f,
    ///Identifies a content string pertaining to a particular scene in a movie or video.
    DVD_Other_Scene        = 0x00000050,
    ///Identifies a content string pertaining to a particular cut in a movie or video.
    DVD_Other_Cut          = 0x00000051,
    ///Identifies a content string pertaining to a particular take in a movie or video.
    DVD_Other_Take         = 0x00000052,
}

///Defines which character set a specified string is encoded with.
alias DVD_TextCharSet = int;
enum : int
{
    ///Unicode character set.
    DVD_CharSet_Unicode                       = 0x00000000,
    ///ISO 646 character set.
    DVD_CharSet_ISO646                        = 0x00000001,
    ///Japanese Industrial Standards (JIS) Roman Kanji character set.
    DVD_CharSet_JIS_Roman_Kanji               = 0x00000002,
    ///ISO 8859-1 character set.
    DVD_CharSet_ISO8859_1                     = 0x00000003,
    ///JIS Kanji-Roman-Katakana character set.
    DVD_CharSet_ShiftJIS_Kanji_Roman_Katakana = 0x00000004,
}

///The <b>AM_DVD_GRAPH_FLAGS</b> enumeration specifies how the DVD Navigator builds a DVD playback graph. These flags
///are used with the IDvdGraphBuilder::RenderDvdVideoVolume method.
alias AM_DVD_GRAPH_FLAGS = int;
enum : int
{
    ///Use a hardware decoder if possible. If none is available, use a software decoder. This is the default setting.
    ///Hardware DVD decoders are registered under the CLSID_DVDHWDecodersCategory filter category. See Filter
    ///Categories.
    AM_DVD_HWDEC_PREFER = 0x00000001,
    ///Use a hardware decoder; do not use a software decoder. Do not combine this flag with the AM_DVD_VMR9_ONLY or
    ///AM_DVD_EVR_ONLY flag.
    AM_DVD_HWDEC_ONLY   = 0x00000002,
    ///Use a software decoder if possible. If none is available, use a hardware decoder.
    AM_DVD_SWDEC_PREFER = 0x00000004,
    ///Use a software decoder; do not use a hardware decoder.
    AM_DVD_SWDEC_ONLY   = 0x00000008,
    ///Do not show video on the computer monitor. Use of this flag should be limited only to the combination of a
    ///hardware DVD-Video decoder and a display device with a port that can connect to a TV. A set-top box type of
    ///device that can play back DVD-Video could play DVD titles to be viewed on a TV set rather than a computer
    ///monitor.
    AM_DVD_NOVPE        = 0x00000100,
    ///Do not clear the filter graph before building the DVD playback graph. By default, the RenderDvdVideoVolume method
    ///removes any existing filters from the graph before it builds the DVD playback graph. <div
    ///class="alert"><b>Note</b> Applies to Windows Vista and later.</div> <div> </div>
    AM_DVD_DO_NOT_CLEAR = 0x00000200,
    ///Use the Video Mixing Renderer Filter 9 (VMR-9) for rendering; fail if the VMR-9 is not available. Do not combine
    ///this flag with the AM_DVD_EVR_ONLY flag.
    AM_DVD_VMR9_ONLY    = 0x00000800,
    ///Use the Enhanced Video Renderer (EVR) for rendering; fail if the EVR is not available. <div
    ///class="alert"><b>Note</b> Applies to Windows Vista and later.</div> <div> </div>
    AM_DVD_EVR_ONLY     = 0x00001000,
    AM_DVD_EVR_QOS      = 0x00002000,
    AM_DVD_ADAPT_GRAPH  = 0x00004000,
    AM_DVD_MASK         = 0x0000ffff,
}

///Describes a DVD stream type (video, audio, or subpicture).
alias AM_DVD_STREAM_FLAGS = int;
enum : int
{
    ///DVD video stream.
    AM_DVD_STREAM_VIDEO  = 0x00000001,
    ///DVD audio stream.
    AM_DVD_STREAM_AUDIO  = 0x00000002,
    ///DVD subpicture stream.
    AM_DVD_STREAM_SUBPIC = 0x00000004,
}

alias _AM_OVERLAY_NOTIFY_FLAGS = int;
enum : int
{
    AM_OVERLAY_NOTIFY_VISIBLE_CHANGE = 0x00000001,
    AM_OVERLAY_NOTIFY_SOURCE_CHANGE  = 0x00000002,
    AM_OVERLAY_NOTIFY_DEST_CHANGE    = 0x00000004,
}

alias BDA_EVENT_ID = int;
enum : int
{
    BDA_EVENT_SIGNAL_LOSS               = 0x00000000,
    BDA_EVENT_SIGNAL_LOCK               = 0x00000001,
    BDA_EVENT_DATA_START                = 0x00000002,
    BDA_EVENT_DATA_STOP                 = 0x00000003,
    BDA_EVENT_CHANNEL_ACQUIRED          = 0x00000004,
    BDA_EVENT_CHANNEL_LOST              = 0x00000005,
    BDA_EVENT_CHANNEL_SOURCE_CHANGED    = 0x00000006,
    BDA_EVENT_CHANNEL_ACTIVATED         = 0x00000007,
    BDA_EVENT_CHANNEL_DEACTIVATED       = 0x00000008,
    BDA_EVENT_SUBCHANNEL_ACQUIRED       = 0x00000009,
    BDA_EVENT_SUBCHANNEL_LOST           = 0x0000000a,
    BDA_EVENT_SUBCHANNEL_SOURCE_CHANGED = 0x0000000b,
    BDA_EVENT_SUBCHANNEL_ACTIVATED      = 0x0000000c,
    BDA_EVENT_SUBCHANNEL_DEACTIVATED    = 0x0000000d,
    BDA_EVENT_ACCESS_GRANTED            = 0x0000000e,
    BDA_EVENT_ACCESS_DENIED             = 0x0000000f,
    BDA_EVENT_OFFER_EXTENDED            = 0x00000010,
    BDA_EVENT_PURCHASE_COMPLETED        = 0x00000011,
    BDA_EVENT_SMART_CARD_INSERTED       = 0x00000012,
    BDA_EVENT_SMART_CARD_REMOVED        = 0x00000013,
}

alias BDA_MULTICAST_MODE = int;
enum : int
{
    BDA_PROMISCUOUS_MULTICAST = 0x00000000,
    BDA_FILTERED_MULTICAST    = 0x00000001,
    BDA_NO_MULTICAST          = 0x00000002,
}

alias BDA_SIGNAL_STATE = int;
enum : int
{
    BDA_SIGNAL_UNAVAILABLE = 0x00000000,
    BDA_SIGNAL_INACTIVE    = 0x00000001,
    BDA_SIGNAL_ACTIVE      = 0x00000002,
}

alias BDA_CHANGE_STATE = int;
enum : int
{
    BDA_CHANGES_COMPLETE = 0x00000000,
    BDA_CHANGES_PENDING  = 0x00000001,
}

alias MEDIA_SAMPLE_CONTENT = int;
enum : int
{
    MEDIA_TRANSPORT_PACKET  = 0x00000000,
    MEDIA_ELEMENTARY_STREAM = 0x00000001,
    MEDIA_MPEG2_PSI         = 0x00000002,
    MEDIA_TRANSPORT_PAYLOAD = 0x00000003,
}

alias ISDBCAS_REQUEST_ID = int;
enum : int
{
    ISDBCAS_REQUEST_ID_EMG = 0x00000038,
    ISDBCAS_REQUEST_ID_EMD = 0x0000003a,
}

alias MUX_PID_TYPE = int;
enum : int
{
    PID_OTHER                = 0xffffffff,
    PID_ELEMENTARY_STREAM    = 0x00000000,
    PID_MPEG2_SECTION_PSI_SI = 0x00000001,
}

enum DVBSystemType : int
{
    DVB_Cable        = 0x00000000,
    DVB_Terrestrial  = 0x00000001,
    DVB_Satellite    = 0x00000002,
    ISDB_Terrestrial = 0x00000003,
    ISDB_Satellite   = 0x00000004,
}

alias BDA_Channel = int;
enum : int
{
    BDA_UNDEFINED_CHANNEL = 0xffffffff,
}

enum ComponentCategory : int
{
    CategoryNotSet      = 0xffffffff,
    CategoryOther       = 0x00000000,
    CategoryVideo       = 0x00000001,
    CategoryAudio       = 0x00000002,
    CategoryText        = 0x00000003,
    CategorySubtitles   = 0x00000004,
    CategoryCaptions    = 0x00000005,
    CategorySuperimpose = 0x00000006,
    CategoryData        = 0x00000007,
    CATEGORY_COUNT      = 0x00000008,
}

enum ComponentStatus : int
{
    StatusActive      = 0x00000000,
    StatusInactive    = 0x00000001,
    StatusUnavailable = 0x00000002,
}

enum MPEG2StreamType : int
{
    BDA_UNITIALIZED_MPEG2STREAMTYPE = 0xffffffff,
    Reserved1                       = 0x00000000,
    ISO_IEC_11172_2_VIDEO           = 0x00000001,
    ISO_IEC_13818_2_VIDEO           = 0x00000002,
    ISO_IEC_11172_3_AUDIO           = 0x00000003,
    ISO_IEC_13818_3_AUDIO           = 0x00000004,
    ISO_IEC_13818_1_PRIVATE_SECTION = 0x00000005,
    ISO_IEC_13818_1_PES             = 0x00000006,
    ISO_IEC_13522_MHEG              = 0x00000007,
    ANNEX_A_DSM_CC                  = 0x00000008,
    ITU_T_REC_H_222_1               = 0x00000009,
    ISO_IEC_13818_6_TYPE_A          = 0x0000000a,
    ISO_IEC_13818_6_TYPE_B          = 0x0000000b,
    ISO_IEC_13818_6_TYPE_C          = 0x0000000c,
    ISO_IEC_13818_6_TYPE_D          = 0x0000000d,
    ISO_IEC_13818_1_AUXILIARY       = 0x0000000e,
    ISO_IEC_13818_7_AUDIO           = 0x0000000f,
    ISO_IEC_14496_2_VISUAL          = 0x00000010,
    ISO_IEC_14496_3_AUDIO           = 0x00000011,
    ISO_IEC_14496_1_IN_PES          = 0x00000012,
    ISO_IEC_14496_1_IN_SECTION      = 0x00000013,
    ISO_IEC_13818_6_DOWNLOAD        = 0x00000014,
    METADATA_IN_PES                 = 0x00000015,
    METADATA_IN_SECTION             = 0x00000016,
    METADATA_IN_DATA_CAROUSEL       = 0x00000017,
    METADATA_IN_OBJECT_CAROUSEL     = 0x00000018,
    METADATA_IN_DOWNLOAD_PROTOCOL   = 0x00000019,
    IRPM_STREAMM                    = 0x0000001a,
    ITU_T_H264                      = 0x0000001b,
    ISO_IEC_13818_1_RESERVED        = 0x0000001c,
    USER_PRIVATE                    = 0x00000010,
    HEVC_VIDEO_OR_TEMPORAL_VIDEO    = 0x00000024,
    HEVC_TEMPORAL_VIDEO_SUBSET      = 0x00000025,
    ISO_IEC_USER_PRIVATE            = 0x00000080,
    DOLBY_AC3_AUDIO                 = 0x00000081,
    DOLBY_DIGITAL_PLUS_AUDIO_ATSC   = 0x00000087,
}

enum ATSCComponentTypeFlags : int
{
    ATSCCT_AC3 = 0x00000001,
}

enum BinaryConvolutionCodeRate : int
{
    BDA_BCC_RATE_NOT_SET     = 0xffffffff,
    BDA_BCC_RATE_NOT_DEFINED = 0x00000000,
    BDA_BCC_RATE_1_2         = 0x00000001,
    BDA_BCC_RATE_2_3         = 0x00000002,
    BDA_BCC_RATE_3_4         = 0x00000003,
    BDA_BCC_RATE_3_5         = 0x00000004,
    BDA_BCC_RATE_4_5         = 0x00000005,
    BDA_BCC_RATE_5_6         = 0x00000006,
    BDA_BCC_RATE_5_11        = 0x00000007,
    BDA_BCC_RATE_7_8         = 0x00000008,
    BDA_BCC_RATE_1_4         = 0x00000009,
    BDA_BCC_RATE_1_3         = 0x0000000a,
    BDA_BCC_RATE_2_5         = 0x0000000b,
    BDA_BCC_RATE_6_7         = 0x0000000c,
    BDA_BCC_RATE_8_9         = 0x0000000d,
    BDA_BCC_RATE_9_10        = 0x0000000e,
    BDA_BCC_RATE_MAX         = 0x0000000f,
}

enum FECMethod : int
{
    BDA_FEC_METHOD_NOT_SET     = 0xffffffff,
    BDA_FEC_METHOD_NOT_DEFINED = 0x00000000,
    BDA_FEC_VITERBI            = 0x00000001,
    BDA_FEC_RS_204_188         = 0x00000002,
    BDA_FEC_LDPC               = 0x00000003,
    BDA_FEC_BCH                = 0x00000004,
    BDA_FEC_RS_147_130         = 0x00000005,
    BDA_FEC_MAX                = 0x00000006,
}

enum ModulationType : int
{
    BDA_MOD_NOT_SET          = 0xffffffff,
    BDA_MOD_NOT_DEFINED      = 0x00000000,
    BDA_MOD_16QAM            = 0x00000001,
    BDA_MOD_32QAM            = 0x00000002,
    BDA_MOD_64QAM            = 0x00000003,
    BDA_MOD_80QAM            = 0x00000004,
    BDA_MOD_96QAM            = 0x00000005,
    BDA_MOD_112QAM           = 0x00000006,
    BDA_MOD_128QAM           = 0x00000007,
    BDA_MOD_160QAM           = 0x00000008,
    BDA_MOD_192QAM           = 0x00000009,
    BDA_MOD_224QAM           = 0x0000000a,
    BDA_MOD_256QAM           = 0x0000000b,
    BDA_MOD_320QAM           = 0x0000000c,
    BDA_MOD_384QAM           = 0x0000000d,
    BDA_MOD_448QAM           = 0x0000000e,
    BDA_MOD_512QAM           = 0x0000000f,
    BDA_MOD_640QAM           = 0x00000010,
    BDA_MOD_768QAM           = 0x00000011,
    BDA_MOD_896QAM           = 0x00000012,
    BDA_MOD_1024QAM          = 0x00000013,
    BDA_MOD_QPSK             = 0x00000014,
    BDA_MOD_BPSK             = 0x00000015,
    BDA_MOD_OQPSK            = 0x00000016,
    BDA_MOD_8VSB             = 0x00000017,
    BDA_MOD_16VSB            = 0x00000018,
    BDA_MOD_ANALOG_AMPLITUDE = 0x00000019,
    BDA_MOD_ANALOG_FREQUENCY = 0x0000001a,
    BDA_MOD_8PSK             = 0x0000001b,
    BDA_MOD_RF               = 0x0000001c,
    BDA_MOD_16APSK           = 0x0000001d,
    BDA_MOD_32APSK           = 0x0000001e,
    BDA_MOD_NBC_QPSK         = 0x0000001f,
    BDA_MOD_NBC_8PSK         = 0x00000020,
    BDA_MOD_DIRECTV          = 0x00000021,
    BDA_MOD_ISDB_T_TMCC      = 0x00000022,
    BDA_MOD_ISDB_S_TMCC      = 0x00000023,
    BDA_MOD_MAX              = 0x00000024,
}

enum ScanModulationTypes : int
{
    BDA_SCAN_MOD_16QAM                          = 0x00000001,
    BDA_SCAN_MOD_32QAM                          = 0x00000002,
    BDA_SCAN_MOD_64QAM                          = 0x00000004,
    BDA_SCAN_MOD_80QAM                          = 0x00000008,
    BDA_SCAN_MOD_96QAM                          = 0x00000010,
    BDA_SCAN_MOD_112QAM                         = 0x00000020,
    BDA_SCAN_MOD_128QAM                         = 0x00000040,
    BDA_SCAN_MOD_160QAM                         = 0x00000080,
    BDA_SCAN_MOD_192QAM                         = 0x00000100,
    BDA_SCAN_MOD_224QAM                         = 0x00000200,
    BDA_SCAN_MOD_256QAM                         = 0x00000400,
    BDA_SCAN_MOD_320QAM                         = 0x00000800,
    BDA_SCAN_MOD_384QAM                         = 0x00001000,
    BDA_SCAN_MOD_448QAM                         = 0x00002000,
    BDA_SCAN_MOD_512QAM                         = 0x00004000,
    BDA_SCAN_MOD_640QAM                         = 0x00008000,
    BDA_SCAN_MOD_768QAM                         = 0x00010000,
    BDA_SCAN_MOD_896QAM                         = 0x00020000,
    BDA_SCAN_MOD_1024QAM                        = 0x00040000,
    BDA_SCAN_MOD_QPSK                           = 0x00080000,
    BDA_SCAN_MOD_BPSK                           = 0x00100000,
    BDA_SCAN_MOD_OQPSK                          = 0x00200000,
    BDA_SCAN_MOD_8VSB                           = 0x00400000,
    BDA_SCAN_MOD_16VSB                          = 0x00800000,
    BDA_SCAN_MOD_AM_RADIO                       = 0x01000000,
    BDA_SCAN_MOD_FM_RADIO                       = 0x02000000,
    BDA_SCAN_MOD_8PSK                           = 0x04000000,
    BDA_SCAN_MOD_RF                             = 0x08000000,
    ScanModulationTypesMask_MCE_DigitalCable    = 0x0000000b,
    ScanModulationTypesMask_MCE_TerrestrialATSC = 0x00000017,
    ScanModulationTypesMask_MCE_AnalogTv        = 0x0000001c,
    ScanModulationTypesMask_MCE_All_TV          = 0xffffffff,
    ScanModulationTypesMask_DVBC                = 0x0000004b,
    BDA_SCAN_MOD_16APSK                         = 0x10000000,
    BDA_SCAN_MOD_32APSK                         = 0x20000000,
}

enum SpectralInversion : int
{
    BDA_SPECTRAL_INVERSION_NOT_SET     = 0xffffffff,
    BDA_SPECTRAL_INVERSION_NOT_DEFINED = 0x00000000,
    BDA_SPECTRAL_INVERSION_AUTOMATIC   = 0x00000001,
    BDA_SPECTRAL_INVERSION_NORMAL      = 0x00000002,
    BDA_SPECTRAL_INVERSION_INVERTED    = 0x00000003,
    BDA_SPECTRAL_INVERSION_MAX         = 0x00000004,
}

enum Polarisation : int
{
    BDA_POLARISATION_NOT_SET     = 0xffffffff,
    BDA_POLARISATION_NOT_DEFINED = 0x00000000,
    BDA_POLARISATION_LINEAR_H    = 0x00000001,
    BDA_POLARISATION_LINEAR_V    = 0x00000002,
    BDA_POLARISATION_CIRCULAR_L  = 0x00000003,
    BDA_POLARISATION_CIRCULAR_R  = 0x00000004,
    BDA_POLARISATION_MAX         = 0x00000005,
}

alias LNB_Source = int;
enum : int
{
    BDA_LNB_SOURCE_NOT_SET     = 0xffffffff,
    BDA_LNB_SOURCE_NOT_DEFINED = 0x00000000,
    BDA_LNB_SOURCE_A           = 0x00000001,
    BDA_LNB_SOURCE_B           = 0x00000002,
    BDA_LNB_SOURCE_C           = 0x00000003,
    BDA_LNB_SOURCE_D           = 0x00000004,
    BDA_LNB_SOURCE_MAX         = 0x00000005,
}

enum GuardInterval : int
{
    BDA_GUARD_NOT_SET     = 0xffffffff,
    BDA_GUARD_NOT_DEFINED = 0x00000000,
    BDA_GUARD_1_32        = 0x00000001,
    BDA_GUARD_1_16        = 0x00000002,
    BDA_GUARD_1_8         = 0x00000003,
    BDA_GUARD_1_4         = 0x00000004,
    BDA_GUARD_1_128       = 0x00000005,
    BDA_GUARD_19_128      = 0x00000006,
    BDA_GUARD_19_256      = 0x00000007,
    BDA_GUARD_MAX         = 0x00000008,
}

enum HierarchyAlpha : int
{
    BDA_HALPHA_NOT_SET     = 0xffffffff,
    BDA_HALPHA_NOT_DEFINED = 0x00000000,
    BDA_HALPHA_1           = 0x00000001,
    BDA_HALPHA_2           = 0x00000002,
    BDA_HALPHA_4           = 0x00000003,
    BDA_HALPHA_MAX         = 0x00000004,
}

enum TransmissionMode : int
{
    BDA_XMIT_MODE_NOT_SET        = 0xffffffff,
    BDA_XMIT_MODE_NOT_DEFINED    = 0x00000000,
    BDA_XMIT_MODE_2K             = 0x00000001,
    BDA_XMIT_MODE_8K             = 0x00000002,
    BDA_XMIT_MODE_4K             = 0x00000003,
    BDA_XMIT_MODE_2K_INTERLEAVED = 0x00000004,
    BDA_XMIT_MODE_4K_INTERLEAVED = 0x00000005,
    BDA_XMIT_MODE_1K             = 0x00000006,
    BDA_XMIT_MODE_16K            = 0x00000007,
    BDA_XMIT_MODE_32K            = 0x00000008,
    BDA_XMIT_MODE_MAX            = 0x00000009,
}

enum RollOff : int
{
    BDA_ROLL_OFF_NOT_SET     = 0xffffffff,
    BDA_ROLL_OFF_NOT_DEFINED = 0x00000000,
    BDA_ROLL_OFF_20          = 0x00000001,
    BDA_ROLL_OFF_25          = 0x00000002,
    BDA_ROLL_OFF_35          = 0x00000003,
    BDA_ROLL_OFF_MAX         = 0x00000004,
}

enum Pilot : int
{
    BDA_PILOT_NOT_SET     = 0xffffffff,
    BDA_PILOT_NOT_DEFINED = 0x00000000,
    BDA_PILOT_OFF         = 0x00000001,
    BDA_PILOT_ON          = 0x00000002,
    BDA_PILOT_MAX         = 0x00000003,
}

alias BDA_Frequency = int;
enum : int
{
    BDA_FREQUENCY_NOT_SET     = 0xffffffff,
    BDA_FREQUENCY_NOT_DEFINED = 0x00000000,
}

alias BDA_Range = int;
enum : int
{
    BDA_RANGE_NOT_SET     = 0xffffffff,
    BDA_RANGE_NOT_DEFINED = 0x00000000,
}

alias BDA_Channel_Bandwidth = int;
enum : int
{
    BDA_CHAN_BANDWITH_NOT_SET     = 0xffffffff,
    BDA_CHAN_BANDWITH_NOT_DEFINED = 0x00000000,
}

alias BDA_Frequency_Multiplier = int;
enum : int
{
    BDA_FREQUENCY_MULTIPLIER_NOT_SET     = 0xffffffff,
    BDA_FREQUENCY_MULTIPLIER_NOT_DEFINED = 0x00000000,
}

alias BDA_Comp_Flags = int;
enum : int
{
    BDACOMP_NOT_DEFINED              = 0x00000000,
    BDACOMP_EXCLUDE_TS_FROM_TR       = 0x00000001,
    BDACOMP_INCLUDE_LOCATOR_IN_TR    = 0x00000002,
    BDACOMP_INCLUDE_COMPONENTS_IN_TR = 0x00000004,
}

enum ApplicationTypeType : int
{
    SCTE28_ConditionalAccess            = 0x00000000,
    SCTE28_POD_Host_Binding_Information = 0x00000001,
    SCTE28_IPService                    = 0x00000002,
    SCTE28_NetworkInterface_SCTE55_2    = 0x00000003,
    SCTE28_NetworkInterface_SCTE55_1    = 0x00000004,
    SCTE28_CopyProtection               = 0x00000005,
    SCTE28_Diagnostic                   = 0x00000006,
    SCTE28_Undesignated                 = 0x00000007,
    SCTE28_Reserved                     = 0x00000008,
}

alias BDA_CONDITIONALACCESS_REQUESTTYPE = int;
enum : int
{
    CONDITIONALACCESS_ACCESS_UNSPECIFIED                      = 0x00000000,
    CONDITIONALACCESS_ACCESS_NOT_POSSIBLE                     = 0x00000001,
    CONDITIONALACCESS_ACCESS_POSSIBLE                         = 0x00000002,
    CONDITIONALACCESS_ACCESS_POSSIBLE_NO_STREAMING_DISRUPTION = 0x00000003,
}

alias BDA_CONDITIONALACCESS_MMICLOSEREASON = int;
enum : int
{
    CONDITIONALACCESS_UNSPECIFIED               = 0x00000000,
    CONDITIONALACCESS_CLOSED_ITSELF             = 0x00000001,
    CONDITIONALACCESS_TUNER_REQUESTED_CLOSE     = 0x00000002,
    CONDITIONALACCESS_DIALOG_TIMEOUT            = 0x00000003,
    CONDITIONALACCESS_DIALOG_FOCUS_CHANGE       = 0x00000004,
    CONDITIONALACCESS_DIALOG_USER_DISMISSED     = 0x00000005,
    CONDITIONALACCESS_DIALOG_USER_NOT_AVAILABLE = 0x00000006,
}

alias BDA_CONDITIONALACCESS_SESSION_RESULT = int;
enum : int
{
    CONDITIONALACCESS_SUCCESSFULL    = 0x00000000,
    CONDITIONALACCESS_ENDED_NOCHANGE = 0x00000001,
    CONDITIONALACCESS_ABORTED        = 0x00000002,
}

alias BDA_DISCOVERY_STATE = int;
enum : int
{
    BDA_DISCOVERY_UNSPECIFIED = 0x00000000,
    BDA_DISCOVERY_REQUIRED    = 0x00000001,
    BDA_DISCOVERY_COMPLETE    = 0x00000002,
}

///The <b>SmartCardStatusType</b> enumeration type specifies the status of a smart card.
enum SmartCardStatusType : int
{
    ///The card was inserted.
    CardInserted        = 0x00000000,
    ///The card was removed.
    CardRemoved         = 0x00000001,
    ///An error occurred.
    CardError           = 0x00000002,
    ///The card data has changed.
    CardDataChanged     = 0x00000003,
    ///Firmware upgrade.
    CardFirmwareUpgrade = 0x00000004,
}

///The <b>SmartCardAssociationType</b> enumeration type specifies a smart card association.
enum SmartCardAssociationType : int
{
    ///Not associated.
    NotAssociated      = 0x00000000,
    ///Associated.
    Associated         = 0x00000001,
    ///Association status is unknown.
    AssociationUnknown = 0x00000002,
}

enum LocationCodeSchemeType : int
{
    SCTE_18 = 0x00000000,
}

enum EntitlementType : int
{
    Entitled         = 0x00000000,
    NotEntitled      = 0x00000001,
    TechnicalFailure = 0x00000002,
}

///The <b>UICloseReasonType</b> enumeration type specifies the reason that a user-interface dialog for a smart card was
///closed.
enum UICloseReasonType : int
{
    ///Not ready.
    NotReady     = 0x00000000,
    ///User.
    UserClosed   = 0x00000001,
    ///System.
    SystemClosed = 0x00000002,
    ///Device.
    DeviceClosed = 0x00000003,
    ///Error.
    ErrorClosed  = 0x00000004,
}

///Specifies the status of a DRM handshake between a tuner and the user's computer.
alias BDA_DrmPairingError = int;
enum : int
{
    ///The handshake was successful.
    BDA_DrmPairing_Succeeded          = 0x00000000,
    ///A hardware failure occurred.
    BDA_DrmPairing_HardwareFailure    = 0x00000001,
    ///The tuner could not obtain the certificate revocation list.
    BDA_DrmPairing_NeedRevocationData = 0x00000002,
    ///The tuner could not perform individualization.
    BDA_DrmPairing_NeedIndiv          = 0x00000003,
    ///Network interface (SCTE 55-1).
    BDA_DrmPairing_Other              = 0x00000004,
    ///The handshake failed during the initialization step.
    BDA_DrmPairing_DrmInitFailed      = 0x00000005,
    ///The client has not requested a handshake or the handshake is still in progress.
    BDA_DrmPairing_DrmNotPaired       = 0x00000006,
    ///The handshake was successful but will soon time out. The client should refresh the handshake soon.
    BDA_DrmPairing_DrmRePairSoon      = 0x00000007,
    BDA_DrmPairing_Aborted            = 0x00000008,
    BDA_DrmPairing_NeedSDKUpdate      = 0x00000009,
}

alias __MIDL___MIDL_itf_bdaiface_0000_0019_0001 = int;
enum : int
{
    KSPROPERTY_IPSINK_MULTICASTLIST       = 0x00000000,
    KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION = 0x00000001,
    KSPROPERTY_IPSINK_ADAPTER_ADDRESS     = 0x00000002,
}

///The <b>AMExtendedSeekingCapabilities</b> enumeration contains flags that describe the extended seeking capabilities
///of a filter.
enum AMExtendedSeekingCapabilities : int
{
    ///Indicates that the stream is seekable.
    AM_EXSEEK_CANSEEK               = 0x00000001,
    ///Indicates that the filter supports rates other than 1.0.
    AM_EXSEEK_CANSCAN               = 0x00000002,
    ///Indicates that the stream contains markers.
    AM_EXSEEK_MARKERSEEK            = 0x00000004,
    ///Indicates that the filter can play back at rates other than 1.0.
    AM_EXSEEK_SCANWITHOUTCLOCK      = 0x00000008,
    ///Indicates that the filter can seek to a new frame without displaying the new frame when it finds it.
    AM_EXSEEK_NOSTANDARDREPAINT     = 0x00000010,
    ///Indicates that the filter can seek while the stream is buffering.
    AM_EXSEEK_BUFFERING             = 0x00000020,
    ///Indicates that the filter's video pin has been created.
    AM_EXSEEK_SENDS_VIDEOFRAMEREADY = 0x00000040,
}

///Indicates the closed caption decoder level.
alias AM_LINE21_CCLEVEL = int;
enum : int
{
    ///TeleCaption II.
    AM_L21_CCLEVEL_TC2 = 0x00000000,
}

///Indicates the closed captioning service.
alias AM_LINE21_CCSERVICE = int;
enum : int
{
    ///No current service.
    AM_L21_CCSERVICE_None       = 0x00000000,
    ///CC1 (caption channel).
    AM_L21_CCSERVICE_Caption1   = 0x00000001,
    ///CC2 (caption channel).
    AM_L21_CCSERVICE_Caption2   = 0x00000002,
    ///T1 (text channel).
    AM_L21_CCSERVICE_Text1      = 0x00000003,
    ///T2 (text channel)
    AM_L21_CCSERVICE_Text2      = 0x00000004,
    ///Extended Data Services (XDS or EDS).
    AM_L21_CCSERVICE_XDS        = 0x00000005,
    AM_L21_CCSERVICE_DefChannel = 0x0000000a,
    AM_L21_CCSERVICE_Invalid    = 0x0000000b,
}

///Indicates the closed captioning state (on or off).
alias AM_LINE21_CCSTATE = int;
enum : int
{
    ///Closed captioning off.
    AM_L21_CCSTATE_Off = 0x00000000,
    ///Closed captioning on.
    AM_L21_CCSTATE_On  = 0x00000001,
}

alias AM_LINE21_CCSTYLE = int;
enum : int
{
    AM_L21_CCSTYLE_None    = 0x00000000,
    AM_L21_CCSTYLE_PopOn   = 0x00000001,
    AM_L21_CCSTYLE_PaintOn = 0x00000002,
    AM_L21_CCSTYLE_RollUp  = 0x00000003,
}

///Indicates the closed captioning text background mode.
alias AM_LINE21_DRAWBGMODE = int;
enum : int
{
    ///Opaque background.
    AM_L21_DRAWBGMODE_Opaque      = 0x00000000,
    ///Transparent background.
    AM_L21_DRAWBGMODE_Transparent = 0x00000001,
}

///The <b>AM_WST_LEVEL</b> enumeration is not supported.
alias AM_WST_LEVEL = int;
enum : int
{
    ///Not implemented.
    AM_WST_LEVEL_1_5 = 0x00000000,
}

///The <b>AM_WST_SERVICE</b> enumeration is not supported.
alias AM_WST_SERVICE = int;
enum : int
{
    ///Reserved.
    AM_WST_SERVICE_None    = 0x00000000,
    ///Reserved.
    AM_WST_SERVICE_Text    = 0x00000001,
    ///Reserved.
    AM_WST_SERVICE_IDS     = 0x00000002,
    ///Reserved.
    AM_WST_SERVICE_Invalid = 0x00000003,
}

///The <b>AM_WST_STATE</b> enumeration specifies whether WST closed captioning is enabled or disabled.
alias AM_WST_STATE = int;
enum : int
{
    ///Specifies that WST closed captioning is enabled.
    AM_WST_STATE_Off = 0x00000000,
    ///Specifies that WST closed captioning is disabled.
    AM_WST_STATE_On  = 0x00000001,
}

///The <b>AM_WST_STYLE</b> enumeration is not supported.
alias AM_WST_STYLE = int;
enum : int
{
    ///Reserved.
    AM_WST_STYLE_None   = 0x00000000,
    ///Reserved.
    AM_WST_STYLE_Invers = 0x00000001,
}

///The <b>AM_WST_DRAWBGMODE</b> enumeration specifies whether the background of the WST frame is opaque or transparent.
alias AM_WST_DRAWBGMODE = int;
enum : int
{
    ///The background is opaque.
    AM_WST_DRAWBGMODE_Opaque      = 0x00000000,
    ///The background is transparent.
    AM_WST_DRAWBGMODE_Transparent = 0x00000001,
}

///<div class="alert"><b>Note</b> This API is deprecated. New applications should not use it.</div> <div> </div> Defines
///the direction of data flow for the stream.
alias STREAM_TYPE = int;
enum : int
{
    ///Application can read the stream.
    STREAMTYPE_READ      = 0x00000000,
    ///Application can write to the stream.
    STREAMTYPE_WRITE     = 0x00000001,
    ///Application reads and writes to the stream.
    STREAMTYPE_TRANSFORM = 0x00000002,
}

///<div class="alert"><b>Note</b> This API is deprecated. New applications should not use it.</div> <div> </div>
///Describes the state of the stream.
alias STREAM_STATE = int;
enum : int
{
    ///Stop state.
    STREAMSTATE_STOP = 0x00000000,
    ///Run state.
    STREAMSTATE_RUN  = 0x00000001,
}

alias __MIDL___MIDL_itf_mmstream_0000_0000_0003 = int;
enum : int
{
    COMPSTAT_NOUPDATEOK = 0x00000001,
    COMPSTAT_WAIT       = 0x00000002,
    COMPSTAT_ABORT      = 0x00000004,
}

alias __MIDL___MIDL_itf_mmstream_0000_0000_0004 = int;
enum : int
{
    MMSSF_HASCLOCK     = 0x00000001,
    MMSSF_SUPPORTSEEK  = 0x00000002,
    MMSSF_ASYNCHRONOUS = 0x00000004,
}

alias __MIDL___MIDL_itf_mmstream_0000_0000_0005 = int;
enum : int
{
    SSUPDATE_ASYNC      = 0x00000001,
    SSUPDATE_CONTINUOUS = 0x00000002,
}

alias __MIDL___MIDL_itf_ddstream_0000_0000_0001 = int;
enum : int
{
    DDSFF_PROGRESSIVERENDER = 0x00000001,
}

alias __MIDL___MIDL_itf_amstream_0000_0000_0001 = int;
enum : int
{
    AMMSF_NOGRAPHTHREAD = 0x00000001,
}

alias __MIDL___MIDL_itf_amstream_0000_0000_0002 = int;
enum : int
{
    AMMSF_ADDDEFAULTRENDERER = 0x00000001,
    AMMSF_CREATEPEER         = 0x00000002,
    AMMSF_STOPIFNOSAMPLES    = 0x00000004,
    AMMSF_NOSTALL            = 0x00000008,
}

alias __MIDL___MIDL_itf_amstream_0000_0000_0003 = int;
enum : int
{
    AMMSF_RENDERTYPEMASK   = 0x00000003,
    AMMSF_RENDERTOEXISTING = 0x00000000,
    AMMSF_RENDERALLSTREAMS = 0x00000001,
    AMMSF_NORENDER         = 0x00000002,
    AMMSF_NOCLOCK          = 0x00000004,
    AMMSF_RUN              = 0x00000008,
}

alias __MIDL___MIDL_itf_amstream_0000_0000_0004 = int;
enum : int
{
    Disabled   = 0x00000000,
    ReadData   = 0x00000001,
    RenderData = 0x00000002,
}

alias AM_PROPERTY_FRAMESTEP = int;
enum : int
{
    AM_PROPERTY_FRAMESTEP_STEP            = 0x00000001,
    AM_PROPERTY_FRAMESTEP_CANCEL          = 0x00000002,
    AM_PROPERTY_FRAMESTEP_CANSTEP         = 0x00000003,
    AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE = 0x00000004,
}

alias KSALLOCATORMODE = int;
enum : int
{
    KsAllocatorMode_User   = 0x00000000,
    KsAllocatorMode_Kernel = 0x00000001,
}

alias FRAMING_PROP = int;
enum : int
{
    FramingProp_Uninitialized = 0x00000000,
    FramingProp_None          = 0x00000001,
    FramingProp_Old           = 0x00000002,
    FramingProp_Ex            = 0x00000003,
}

alias FRAMING_CACHE_OPS = int;
enum : int
{
    Framing_Cache_Update   = 0x00000000,
    Framing_Cache_ReadLast = 0x00000001,
    Framing_Cache_ReadOrig = 0x00000002,
    Framing_Cache_Write    = 0x00000003,
}

alias PIPE_STATE = int;
enum : int
{
    PipeState_DontCare           = 0x00000000,
    PipeState_RangeNotFixed      = 0x00000001,
    PipeState_RangeFixed         = 0x00000002,
    PipeState_CompressionUnknown = 0x00000003,
    PipeState_Finalized          = 0x00000004,
}

alias PIPE_ALLOCATOR_PLACE = int;
enum : int
{
    Pipe_Allocator_None      = 0x00000000,
    Pipe_Allocator_FirstPin  = 0x00000001,
    Pipe_Allocator_LastPin   = 0x00000002,
    Pipe_Allocator_MiddlePin = 0x00000003,
}

alias KS_LogicalMemoryType = int;
enum : int
{
    KS_MemoryTypeDontCare         = 0x00000000,
    KS_MemoryTypeKernelPaged      = 0x00000001,
    KS_MemoryTypeKernelNonPaged   = 0x00000002,
    KS_MemoryTypeDeviceHostMapped = 0x00000003,
    KS_MemoryTypeDeviceSpecific   = 0x00000004,
    KS_MemoryTypeUser             = 0x00000005,
    KS_MemoryTypeAnyHost          = 0x00000006,
}

///Specifies the aspect ratio of a video image in a display window.
alias AM_ASPECT_RATIO_MODE = int;
enum : int
{
    ///No aspect ratio correction.
    AM_ARMODE_STRETCHED            = 0x00000000,
    ///Put the video in letterbox format. Paint background color in the excess region so the video is not distorted.
    AM_ARMODE_LETTER_BOX           = 0x00000001,
    ///Crop the video to the correct aspect ratio.
    AM_ARMODE_CROP                 = 0x00000002,
    ///Use whatever mode is currently set for the primary stream. This value is valid only for secondary streams.
    AM_ARMODE_STRETCHED_AS_PRIMARY = 0x00000003,
}

///The <code>VMR9PresentationFlags</code> enumeration type contains flags that describe the status of a video sample.
///These flags are used in the VMR9PresentationInfo structure.
enum VMR9PresentationFlags : int
{
    ///Indicates that the sample is a sync point.
    VMR9Sample_SyncPoint        = 0x00000001,
    ///Indicates that the sample is part of the preroll.
    VMR9Sample_Preroll          = 0x00000002,
    ///Indicates that the sample is a discontinuity.
    VMR9Sample_Discontinuity    = 0x00000004,
    ///Indicates that the time stamp on the sample is valid.
    VMR9Sample_TimeValid        = 0x00000008,
    VMR9Sample_SrcDstRectsValid = 0x00000010,
}

///The <b>VMR9SurfaceAllocationFlags</b> enumeration type is used with the IVMRSurfaceAllocator9::InitializeDevice
///method to specify surface creation parameters (VMR-9 only).
enum VMR9SurfaceAllocationFlags : int
{
    ///Indicates that the surface is a Direct3D render target.
    VMR9AllocFlag_3DRenderTarget   = 0x00000001,
    ///Indicates that the render target supports DXVA.
    VMR9AllocFlag_DXVATarget       = 0x00000002,
    ///Indicates that the target is a Direct3D texture surface.
    VMR9AllocFlag_TextureSurface   = 0x00000004,
    ///Indicates an offscreen surface.
    VMR9AllocFlag_OffscreenSurface = 0x00000008,
    ///In YUV mixing mode, indicates that the mixer can accept RGB formats in addition to the specified YUV format. The
    ///allocator-presenter can switch between the formats dynamically. This flag is only valid in YUV mixing mode.
    VMR9AllocFlag_RGBDynamicSwitch = 0x00000010,
    ///Reserved for future use.
    VMR9AllocFlag_UsageReserved    = 0x000000e0,
    ///Bitwise <b>OR</b> of all flags; not used by applications
    VMR9AllocFlag_UsageMask        = 0x000000ff,
}

///The <code>VMR9AspectRatioMode</code> enumeration type is used with the IVMRWindowlessControl9::GetAspectRatioMode and
///IVMRWindowlessControl9::SetAspectRatioMode methods to set and retrieve the aspect ratio mode (VMR-9 only).
enum VMR9AspectRatioMode : int
{
    ///Indicates that the VMR is not attempting to maintain the aspect ratio of the source video.
    VMR9ARMode_None      = 0x00000000,
    ///Indicates that the VMR will maintain the aspect ratio of the source video by letterboxing within the output
    ///rectangle.
    VMR9ARMode_LetterBox = 0x00000001,
}

///The <code>VMR9MixerPrefs</code> enumeration type contains flags that specify how the Video Mixing Render 9 filter
///(VMR-9) mixes the video streams. Settings include decimation, filtering, and render target preferences.
enum VMR9MixerPrefs : int
{
    ///No decimation. The video will be rendered onto the surface in its native size.
    MixerPref9_NoDecimation           = 0x00000001,
    ///Decimate output by 2 in the x and y directions.
    MixerPref9_DecimateOutput         = 0x00000002,
    ///Adjust the horizontal or vertical size of the video streams to match the target aspect ratio. If this flag is not
    ///present, the VMR adjusts the horizontal size only. Requires Windows XP Service Pack 2. For more information, see
    ///Aspect Ratio Correction.
    MixerPref9_ARAdjustXorY           = 0x00000004,
    ///Do not perform aspect ratio correction on the composited stream if the input video streams have the same aspect
    ///ratio. Requires Windows XP Service Pack 2. For more information, see Non-Square Mixing.
    MixerPref9_NonSquareMixing        = 0x00000008,
    ///Bitmask to isolate the flags that control decimation. (This value is not a valid flag.)
    MixerPref9_DecimateMask           = 0x0000000f,
    ///Bilinear interpolation filtering. A weighted average of a 2 x 2 area of neighboring pixels is used.
    MixerPref9_BiLinearFiltering      = 0x00000010,
    ///Point filtering. The value of the nearest is pixel is used.
    MixerPref9_PointFiltering         = 0x00000020,
    ///Anisotropic filtering.
    MixerPref9_AnisotropicFiltering   = 0x00000040,
    ///Four-sample tent filtering.
    MixerPref9_PyramidalQuadFiltering = 0x00000080,
    ///Four-sample Gaussian filtering.
    MixerPref9_GaussianQuadFiltering  = 0x00000100,
    ///Reserved for future use.
    MixerPref9_FilteringReserved      = 0x00000e00,
    ///Bitmask to isolate flags that control filtering. (This value is not a valid flag.)
    MixerPref9_FilteringMask          = 0x00000ff0,
    ///Use an RGB render target.
    MixerPref9_RenderTargetRGB        = 0x00001000,
    ///Indicates that the target is a YUV surface. Requires Windows XP Service Pack 2. For more information, see YUV
    ///Mixing Mode.
    MixerPref9_RenderTargetYUV        = 0x00002000,
    ///Reserved for future use.
    MixerPref9_RenderTargetReserved   = 0x000fc000,
    ///Bitmaks to isolate flags that control the render target. (This value is not a valid flag.)
    MixerPref9_RenderTargetMask       = 0x000ff000,
    ///In YUV mixing mode only, this flag switches the VMR to bob deinterlacing. You can add or remove this flag while
    ///the filter graph is running; the change is applied when the VMR mixer composes the next video frame.
    MixerPref9_DynamicSwitchToBOB     = 0x00100000,
    ///In YUV mixing mode only, this flag causes the VMR to decimate the image by a factor of 2 horizontally and
    ///vertically. You can add or remove this flag while the filter graph is running; the change will be applied when
    ///the VMR mixer composes the next video frame.
    MixerPref9_DynamicDecimateBy2     = 0x00200000,
    ///Reserved.
    MixerPref9_DynamicReserved        = 0x00c00000,
    ///Bitmask to isolate the MixerPref9_DynamicSwitchToBOB and MixerPref9_DynamicDecimateBy2 flags. (This value is not
    ///a valid flag.)
    MixerPref9_DynamicMask            = 0x00f00000,
}

///The <code>VMR9ProcAmpControlFlags</code> enumeration type specifies image adjustment properties, for use with the
///Video Mixing Render Filter 9 (VMR-9).
enum VMR9ProcAmpControlFlags : int
{
    ///Brightness adjustment.
    ProcAmpControl9_Brightness = 0x00000001,
    ///Contrast adjustment.
    ProcAmpControl9_Contrast   = 0x00000002,
    ///Hue adjustment.
    ProcAmpControl9_Hue        = 0x00000004,
    ///Saturation adjustment.
    ProcAmpControl9_Saturation = 0x00000008,
    ///Bitwise <b>OR</b> of all the previous flags. This value is used internally by the VMR-9, and is not a valid flag.
    ProcAmpControl9_Mask       = 0x0000000f,
}

///The <b>VMR9AlphaBitmapFlags</b> enumeration type defines the possible values for the <b>dwFlags</b> member of the
///VMR9AlphaBitmap structure.
enum VMR9AlphaBitmapFlags : int
{
    ///Disable the alpha bitmap. This flag cannot be combined with any other flags.
    VMR9AlphaBitmap_Disable     = 0x00000001,
    ///The bitmap is specified as a GDI device context (HDC) in the <b>hdc</b> member of the VMR9AlphaBitmap structure.
    ///If this flag is not present, the bitmap is specified as a Direct3D <b>IDirect3DSurface9</b> pointer in the
    ///<b>pDDS</b> member of the structure.
    VMR9AlphaBitmap_hDC         = 0x00000002,
    ///Use the entire Direct3D surface. The <b>rSrc</b> member of the VMR9AlphaBitmap structure is ignored. This flag
    ///cannot be combined with the VMR9AlphaBitmap_hDC flag.
    VMR9AlphaBitmap_EntireDDS   = 0x00000004,
    ///Indicates that the <b>srcClrKey</b> member is valid and should be used when blending. This flag cannot be used
    ///with a Direct3D surface that contains per-pixel alpha (D3DFMT_A8R8G8B8 format).
    VMR9AlphaBitmap_SrcColorKey = 0x00000008,
    ///Indicates that the <b>rSrc</b> member is valid and specifies a sub-rectangle of the original image to be blended.
    ///This flag is only valid for the IVMRMixerBitmap9::UpdateAlphaBitmapParameters method.
    VMR9AlphaBitmap_SrcRect     = 0x00000010,
    ///Indicates that the <b>dwFilterMode</b> member is valid and should be used to overide the VMR filter's default
    ///filtering method.
    VMR9AlphaBitmap_FilterMode  = 0x00000020,
}

///The <code>VMR9RenderPrefs</code> enumeration type specifies basic rendering preferences for the VMR-9. It is used
///with the IVMRFilterConfig9::GetRenderingPrefs and IVMRFilterConfig9::SetRenderingPrefs methods.
enum VMR9RenderPrefs : int
{
    ///Indicates that the application paints the color keyed areas.
    RenderPrefs9_DoNotRenderBorder = 0x00000001,
    ///Bitwise <b>OR</b> of all flags; not used by applications.
    RenderPrefs9_Mask              = 0x00000001,
}

///The <b>VMR9Mode</b> enumeration type specifies the rendering mode of the Video Mixing Renderer 9 (VMR-9) filter.
alias VMR9Mode = int;
enum : int
{
    ///Windowed mode.
    VMR9Mode_Windowed   = 0x00000001,
    ///Windowless mode.
    VMR9Mode_Windowless = 0x00000002,
    ///Renderless mode.
    VMR9Mode_Renderless = 0x00000004,
    ///Bitwise <b>OR</b> of all above flags; not used by applications.
    VMR9Mode_Mask       = 0x00000007,
}

///The <code>VMR9DeinterlacePrefs</code> enumeration type describes the deinterlacing method that the Video Mixing
///Renderer Filter 9 (VMR-9) uses if the method set by the application cannot be used.
enum VMR9DeinterlacePrefs : int
{
    ///Use the next best mode offered by the driver.
    DeinterlacePref9_NextBest = 0x00000001,
    ///Use the bob method.
    DeinterlacePref9_BOB      = 0x00000002,
    ///Use the weave method (that is, no deinterlacing).
    DeinterlacePref9_Weave    = 0x00000004,
    ///Bitwise OR of the previous flags. This value is used internally by the VMR, and is not a valid flag.
    DeinterlacePref9_Mask     = 0x00000007,
}

///The <code>VMR9DeinterlaceTech</code> enumeration type describes the algorithm used for deinterlacing a video stream.
///The flags are not mutually exclusive; drivers can set a combination of flags.
enum VMR9DeinterlaceTech : int
{
    ///The algorithm is unknown or proprietary.
    DeinterlaceTech9_Unknown             = 0x00000000,
    ///The algorithm creates each missing line by repeating the line above it or below it. This method creates jagged
    ///artifacts and is not recommended.
    DeinterlaceTech9_BOBLineReplicate    = 0x00000001,
    ///The algorithm creates the missing lines by vertically stretching each video field by a factor of two. For
    ///example, it might average two lines or use a (-1, 9, 9, -1)/16 filter across four lines. Slight vertical
    ///adjustments are made to ensure that the resulting image does not "bob" up and down
    DeinterlaceTech9_BOBVerticalStretch  = 0x00000002,
    ///The algorithm uses median filtering to recreate the pixels in the missing lines.
    DeinterlaceTech9_MedianFiltering     = 0x00000004,
    ///The algorithm uses an edge filter to create the missing lines. In this process, spatial directional filters are
    ///applied to determine the orientation of edges in the picture content. Missing pixels are created by filtering
    ///along (rather than across) the detected edges.
    DeinterlaceTech9_EdgeFiltering       = 0x00000010,
    ///The algorithm uses spatial or temporal interpolation, switching between the two on a field-by-field basis,
    ///depending on the amount of motion.
    DeinterlaceTech9_FieldAdaptive       = 0x00000020,
    ///The algorithm uses spatial or temporal interpolation, switching between the two on a pixel-by-pixel basis,
    ///depending on the amount of motion.
    DeinterlaceTech9_PixelAdaptive       = 0x00000040,
    ///The algorithm identifies objects within a sequence of video fields. Before it recreates the missing pixels, it
    ///aligns the movement axes of the individual objects in the scene to make them parallel with the time axis.
    DeinterlaceTech9_MotionVectorSteered = 0x00000080,
}

///The <b>VMR9_SampleFormat</b> enumeration type describes the interlacing of a video stream.
alias VMR9_SampleFormat = int;
enum : int
{
    ///Reserved; do not use.
    VMR9_SampleReserved                  = 0x00000001,
    ///Progressive frame; no interleaving
    VMR9_SampleProgressiveFrame          = 0x00000002,
    ///Each sample contains two interleaved fields, with the even field first.
    VMR9_SampleFieldInterleavedEvenFirst = 0x00000003,
    ///Each sample contains two interleaved fields, with the odd field first.
    VMR9_SampleFieldInterleavedOddFirst  = 0x00000004,
    ///The sample contains a single field, and each line in the sample corresponds to the even lines in a deinterlaced
    ///frame. That is, lines 0, 1, 2,... in the sample correspond to lines 0, 2, 4,... in the deinterlaced frame. The
    ///missing lines must be constructed when the frame is deinterlaced.
    VMR9_SampleFieldSingleEven           = 0x00000005,
    ///The sample contains a single field, and each line in the sample corresponds to the odd lines in a de-interlaced
    ///frame.
    VMR9_SampleFieldSingleOdd            = 0x00000006,
}

alias AM_PROPERTY_AC3 = int;
enum : int
{
    AM_PROPERTY_AC3_ERROR_CONCEALMENT = 0x00000001,
    AM_PROPERTY_AC3_ALTERNATE_AUDIO   = 0x00000002,
    AM_PROPERTY_AC3_DOWNMIX           = 0x00000003,
    AM_PROPERTY_AC3_BIT_STREAM_MODE   = 0x00000004,
    AM_PROPERTY_AC3_DIALOGUE_LEVEL    = 0x00000005,
    AM_PROPERTY_AC3_LANGUAGE_CODE     = 0x00000006,
    AM_PROPERTY_AC3_ROOM_TYPE         = 0x00000007,
}

alias AM_PROPERTY_DVDSUBPIC = int;
enum : int
{
    AM_PROPERTY_DVDSUBPIC_PALETTE     = 0x00000000,
    AM_PROPERTY_DVDSUBPIC_HLI         = 0x00000001,
    AM_PROPERTY_DVDSUBPIC_COMPOSIT_ON = 0x00000002,
}

alias AM_PROPERTY_DVDCOPYPROT = int;
enum : int
{
    AM_PROPERTY_DVDCOPY_CHLG_KEY              = 0x00000001,
    AM_PROPERTY_DVDCOPY_DVD_KEY1              = 0x00000002,
    AM_PROPERTY_DVDCOPY_DEC_KEY2              = 0x00000003,
    AM_PROPERTY_DVDCOPY_TITLE_KEY             = 0x00000004,
    AM_PROPERTY_COPY_MACROVISION              = 0x00000005,
    AM_PROPERTY_DVDCOPY_REGION                = 0x00000006,
    AM_PROPERTY_DVDCOPY_SET_COPY_STATE        = 0x00000007,
    AM_PROPERTY_COPY_ANALOG_COMPONENT         = 0x00000008,
    AM_PROPERTY_COPY_DIGITAL_CP               = 0x00000009,
    AM_PROPERTY_COPY_DVD_SRM                  = 0x0000000a,
    AM_PROPERTY_DVDCOPY_SUPPORTS_NEW_KEYCOUNT = 0x0000000b,
    AM_PROPERTY_DVDCOPY_DISC_KEY              = 0x00000080,
}

alias AM_DIGITAL_CP = int;
enum : int
{
    AM_DIGITAL_CP_OFF           = 0x00000000,
    AM_DIGITAL_CP_ON            = 0x00000001,
    AM_DIGITAL_CP_DVD_COMPLIANT = 0x00000002,
}

///Specifies the copy protection state.
alias AM_DVDCOPYSTATE = int;
enum : int
{
    ///Starting a full key-exchange algorithm.
    AM_DVDCOPYSTATE_INITIALIZE                  = 0x00000000,
    ///Starting a title key-exchange algorithm.
    AM_DVDCOPYSTATE_INITIALIZE_TITLE            = 0x00000001,
    ///Authentication is not required.
    AM_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED = 0x00000002,
    ///Authentication required.
    AM_DVDCOPYSTATE_AUTHENTICATION_REQUIRED     = 0x00000003,
    ///Key exchange negotiation is complete.
    AM_DVDCOPYSTATE_DONE                        = 0x00000004,
}

///Identifies the analog copy protection level.
alias AM_COPY_MACROVISION_LEVEL = int;
enum : int
{
    ///Disabled.
    AM_MACROVISION_DISABLED = 0x00000000,
    ///Level 1.
    AM_MACROVISION_LEVEL1   = 0x00000001,
    ///Level 2.
    AM_MACROVISION_LEVEL2   = 0x00000002,
    ///Level 3.
    AM_MACROVISION_LEVEL3   = 0x00000003,
}

///Indicates an MPEG-2 video level as specified in the MPEG-2 video standard (ISO13818-2).
alias AM_MPEG2Level = int;
enum : int
{
    ///Low level.
    AM_MPEG2Level_Low      = 0x00000001,
    ///Main level.
    AM_MPEG2Level_Main     = 0x00000002,
    ///High 1440 level.
    AM_MPEG2Level_High1440 = 0x00000003,
    ///High level.
    AM_MPEG2Level_High     = 0x00000004,
}

///Indicates an MPEG-2 video profile as specified in the MPEG-2 video standard (ISO13818-2).
alias AM_MPEG2Profile = int;
enum : int
{
    ///Simple profile.
    AM_MPEG2Profile_Simple            = 0x00000001,
    ///Main profile.
    AM_MPEG2Profile_Main              = 0x00000002,
    ///Signal to Noise Ratio (SNR) scalable profile
    AM_MPEG2Profile_SNRScalable       = 0x00000003,
    ///Spatially scalable profile.
    AM_MPEG2Profile_SpatiallyScalable = 0x00000004,
    ///High profile.
    AM_MPEG2Profile_High              = 0x00000005,
}

alias AM_PROPERTY_DVDKARAOKE = int;
enum : int
{
    AM_PROPERTY_DVDKARAOKE_ENABLE = 0x00000000,
    AM_PROPERTY_DVDKARAOKE_DATA   = 0x00000001,
}

alias AM_PROPERTY_TS_RATE_CHANGE = int;
enum : int
{
    AM_RATE_SimpleRateChange       = 0x00000001,
    AM_RATE_ExactRateChange        = 0x00000002,
    AM_RATE_MaxFullDataRate        = 0x00000003,
    AM_RATE_Step                   = 0x00000004,
    AM_RATE_UseRateVersion         = 0x00000005,
    AM_RATE_QueryFullFrameRate     = 0x00000006,
    AM_RATE_QueryLastRateSegPTS    = 0x00000007,
    AM_RATE_CorrectTS              = 0x00000008,
    AM_RATE_ReverseMaxFullDataRate = 0x00000009,
    AM_RATE_ResetOnTimeDisc        = 0x0000000a,
    AM_RATE_QueryMapping           = 0x0000000b,
}

///The <b>AM_PROPERTY_DVD_RATE_CHANGE</b> enumeration is not used.
alias AM_PROPERTY_DVD_RATE_CHANGE = int;
enum : int
{
    ///Reserved.
    AM_RATE_ChangeRate      = 0x00000001,
    ///Reserved.
    AM_RATE_FullDataRateMax = 0x00000002,
    ///Reserved.
    AM_RATE_ReverseDecode   = 0x00000003,
    ///Reserved.
    AM_RATE_DecoderPosition = 0x00000004,
    ///Reserved.
    AM_RATE_DecoderVersion  = 0x00000005,
}

alias DVD_PLAY_DIRECTION = int;
enum : int
{
    DVD_DIR_FORWARD  = 0x00000000,
    DVD_DIR_BACKWARD = 0x00000001,
}

///The <b>DVD_ERROR</b> enumeration value defines DVD error conditions. The EC_DVD_ERROR event contains a flag from this
///enumeration in the <i>lParam1</i> event parameter. The value of the flag determines the meaning of the <i>lParam2</i>
///parameter, as described here for each flag. If not listed, <i>lParam2</i> is zero.
alias DVD_ERROR = int;
enum : int
{
    ///Something unexpected happened; perhaps content is authored incorrectly. Playback is stopped.
    DVD_ERROR_Unexpected                          = 0x00000001,
    ///Key exchange for DVD copy protection failed. Playback is stopped.
    DVD_ERROR_CopyProtectFail                     = 0x00000002,
    ///DVD-Video disc is authored incorrectly for specification version 1.<i>x</i>. Playback is stopped.
    DVD_ERROR_InvalidDVD1_0Disc                   = 0x00000003,
    ///The disc cannot be played because it is not authored to play in the system region. You can try fixing the region
    ///mismatch by changing the system region with Dvdrgn.exe. <i>lParam2</i>: The low <b>WORD</b> contains the disc
    ///region and the high <b>WORD</b> contains the system region.
    DVD_ERROR_InvalidDiscRegion                   = 0x00000004,
    ///Player parental level is lower than the lowest parental level available in the DVD content. Playback is stopped.
    ///<i>lParam2</i>: The lowest parental level in the DVD content, or -1 if no parental level is specified in the
    ///content.
    DVD_ERROR_LowParentalLevel                    = 0x00000005,
    ///Analog copy protection distribution failed. Playback stopped.
    DVD_ERROR_MacrovisionFail                     = 0x00000006,
    ///No discs can be played because the system region does not match the decoder region. <i>lParam2</i>: The low
    ///<b>WORD</b> contains the system region and the high <b>WORD</b> contains the decoder region.
    DVD_ERROR_IncompatibleSystemAndDecoderRegions = 0x00000007,
    ///The disc cannot be played because the disc is not authored to be played in the decoder's region. <i>lParam2</i>:
    ///The low <b>WORD</b> contains the disc region and the high <b>WORD</b> contains the decoder region.
    DVD_ERROR_IncompatibleDiscAndDecoderRegions   = 0x00000008,
    ///The disc cannot be played because the video display does not meet the copy protection requirements.
    DVD_ERROR_CopyProtectOutputFail               = 0x00000009,
    ///The disc cannot be played because the driver does not support checking the video display.
    DVD_ERROR_CopyProtectOutputNotSupported       = 0x0000000a,
}

///Specifies DVD warning conditions.
alias DVD_WARNING = int;
enum : int
{
    ///DVD-Video disc is authored incorrectly. Playback can continue, but unexpected behavior might occur.
    DVD_WARNING_InvalidDVD1_0Disc  = 0x00000001,
    ///A decoder would not support the current format. Playback of a stream (audio, video or subpicture) might not
    ///function. <i>lParam2</i> of the EC_DVD_WARNING event notification code contains the stream type (see
    ///AM_DVD_STREAM_FLAGS).
    DVD_WARNING_FormatNotSupported = 0x00000002,
    ///The internal DVD navigation command processor attempted to process an illegal command.
    DVD_WARNING_IllegalNavCommand  = 0x00000003,
    ///File Open failed.
    DVD_WARNING_Open               = 0x00000004,
    ///File Seek failed.
    DVD_WARNING_Seek               = 0x00000005,
    ///File Read failed.
    DVD_WARNING_Read               = 0x00000006,
}

///The DVD_PB_STOPPED enumeration value has flags that indicate why DVD playback stopped. This flag is sent in the
///<i>lParam1</i> parameter of the EC_DVD_PLAYBACK_STOPPED event.
alias DVD_PB_STOPPED = int;
enum : int
{
    ///Unspecified reason.
    DVD_PB_STOPPED_Other                         = 0x00000000,
    ///The current program chain (PGC) completed and the DVD Navigator found no other video or other branching
    ///instructions.
    DVD_PB_STOPPED_NoBranch                      = 0x00000001,
    ///The disc does not contain an initial startup program.
    DVD_PB_STOPPED_NoFirstPlayDomain             = 0x00000002,
    ///The application stopped playback or a DVD Navigator reached a stop command on the disc.
    DVD_PB_STOPPED_StopCommand                   = 0x00000003,
    ///The DVD Navigator was reset to the start of the disc.
    DVD_PB_STOPPED_Reset                         = 0x00000004,
    ///The disc was ejected.
    DVD_PB_STOPPED_DiscEjected                   = 0x00000005,
    ///An invalid navigation command prevented playback from continuing.
    DVD_PB_STOPPED_IllegalNavCommand             = 0x00000006,
    ///Playback reached the end time that was specified by the application.
    DVD_PB_STOPPED_PlayPeriodAutoStop            = 0x00000007,
    ///Playback reached the end of the chapter.
    DVD_PB_STOPPED_PlayChapterAutoStop           = 0x00000008,
    ///Playback was stopped because of the parental level.
    DVD_PB_STOPPED_ParentalFailure               = 0x00000009,
    ///Playback was stopped because the region did not match.
    DVD_PB_STOPPED_RegionFailure                 = 0x0000000a,
    ///Playback was stopped because of analog copy protection.
    DVD_PB_STOPPED_MacrovisionFailure            = 0x0000000b,
    ///An error occurred while reading the disc.
    DVD_PB_STOPPED_DiscReadError                 = 0x0000000c,
    ///Playback was stopped because of copy protection.
    DVD_PB_STOPPED_CopyProtectFailure            = 0x0000000d,
    ///The disc cannot be played because the video display does not meet the copy protection requirements.
    DVD_PB_STOPPED_CopyProtectOutputFailure      = 0x0000000e,
    ///The disc cannot be played because the driver does not support checking the video display.
    DVD_PB_STOPPED_CopyProtectOutputNotSupported = 0x0000000f,
}

///Specifies how the audio device was being accessed when the failure occurred.
alias SNDDEV_ERR = int;
enum : int
{
    ///The audio device attempted to open.
    SNDDEV_ERROR_Open            = 0x00000001,
    ///The audio device attempted to close.
    SNDDEV_ERROR_Close           = 0x00000002,
    ///The capabilities of the underlying hardware were being retrieved.
    SNDDEV_ERROR_GetCaps         = 0x00000003,
    ///The header for the audio device was being prepared.
    SNDDEV_ERROR_PrepareHeader   = 0x00000004,
    ///The header for the audio device was being unprepared.
    SNDDEV_ERROR_UnprepareHeader = 0x00000005,
    ///The audio device attempted to reset.
    SNDDEV_ERROR_Reset           = 0x00000006,
    ///The audio device attempted to restart.
    SNDDEV_ERROR_Restart         = 0x00000007,
    ///The current and stop position settings were being retrieved.
    SNDDEV_ERROR_GetPosition     = 0x00000008,
    ///The audio device was being written to.
    SNDDEV_ERROR_Write           = 0x00000009,
    ///The audio device attempted to pause.
    SNDDEV_ERROR_Pause           = 0x0000000a,
    ///The audio device attempted to stop.
    SNDDEV_ERROR_Stop            = 0x0000000b,
    ///The audio device attempted to start.
    SNDDEV_ERROR_Start           = 0x0000000c,
    ///A buffer was being added to the audio device.
    SNDDEV_ERROR_AddBuffer       = 0x0000000d,
    ///The audio device was being queried.
    SNDDEV_ERROR_Query           = 0x0000000e,
}

///The <code>MP_TYPE</code> enumeration specifies the data type for a parameter.
alias MP_TYPE = int;
enum : int
{
    ///Value is a signed 32-bit integer.
    MPT_INT   = 0x00000000,
    ///Value is a 32-bit IEEE floating-point value.
    MPT_FLOAT = 0x00000001,
    ///Value is Boolean. Use the following constants for Boolean parameters:
    MPT_BOOL  = 0x00000002,
    ///Value is taken from a set of consecutive integers.
    MPT_ENUM  = 0x00000003,
    ///Reserved.
    MPT_MAX   = 0x00000004,
}

///The <code>MP_CURVE_TYPE</code> enumeration defines the curve that a media parameter follows within an envelope
///segment.
alias MP_CURVE_TYPE = int;
enum : int
{
    ///No interpolation. Jump to the next point.
    MP_CURVE_JUMP      = 0x00000001,
    ///Linear interpolation.
    MP_CURVE_LINEAR    = 0x00000002,
    ///Parabolic curve.
    MP_CURVE_SQUARE    = 0x00000004,
    ///Inverse square curve.
    MP_CURVE_INVSQUARE = 0x00000008,
    ///Sine curve.
    MP_CURVE_SINE      = 0x00000010,
}

///The <code>DMO_REGISTER_FLAGS</code> enumeration defines flags that specify registry information for a Microsoft
///DirectX Media Object (DMO).
alias DMO_REGISTER_FLAGS = int;
enum : int
{
    ///Use of the DMO is restricted by a software key.
    DMO_REGISTERF_IS_KEYED = 0x00000001,
}

///The <code>DMO_ENUM_FLAGS</code> enumeration defines flags that specify search criteria when enumerating Microsoft
///DirectX Media Objects (DMOs).
alias DMO_ENUM_FLAGS = int;
enum : int
{
    ///The enumeration should include DMOs whose use is restricted by a software key. If this flag is absent, keyed DMOs
    ///are omitted from the enumeration.
    DMO_ENUMF_INCLUDE_KEYED = 0x00000001,
}

///The <b>VIDEOENCODER_BITRATE_MODE</b> enumeration type defines the three types of bitrates supported by the
///IEncoderAPI interface.
alias VIDEOENCODER_BITRATE_MODE = int;
enum : int
{
    ///The bit rate used for encoding is constant.
    ConstantBitRate        = 0x00000000,
    ///The bit rate used for encoding is variable with the specified bitrate used as a guaranteed average over a
    ///specified window. The default window size is considered to be five minutes.
    VariableBitRateAverage = 0x00000001,
    ///The <b>ENCAPIPARAM_BITRATE</b> value is the expected (not guaranteed) average bit rate over a given time period
    ///and that the <b>ENCAPIPARAM_PEAK_BITRATE</b> value is the peak which the bit rate must not exceed. The default
    ///window size is considered to be 500ms (which is traditionally equal to one GOP).
    VariableBitRatePeak    = 0x00000002,
}

alias __MIDL___MIDL_itf_tuner_0000_0000_0001 = int;
enum : int
{
    DISPID_TUNER_TS_UNIQUENAME                        = 0x00000001,
    DISPID_TUNER_TS_FRIENDLYNAME                      = 0x00000002,
    DISPID_TUNER_TS_CLSID                             = 0x00000003,
    DISPID_TUNER_TS_NETWORKTYPE                       = 0x00000004,
    DISPID_TUNER_TS__NETWORKTYPE                      = 0x00000005,
    DISPID_TUNER_TS_CREATETUNEREQUEST                 = 0x00000006,
    DISPID_TUNER_TS_ENUMCATEGORYGUIDS                 = 0x00000007,
    DISPID_TUNER_TS_ENUMDEVICEMONIKERS                = 0x00000008,
    DISPID_TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES    = 0x00000009,
    DISPID_TUNER_TS_FREQMAP                           = 0x0000000a,
    DISPID_TUNER_TS_DEFLOCATOR                        = 0x0000000b,
    DISPID_TUNER_TS_CLONE                             = 0x0000000c,
    DISPID_TUNER_TR_TUNINGSPACE                       = 0x00000001,
    DISPID_TUNER_TR_COMPONENTS                        = 0x00000002,
    DISPID_TUNER_TR_CLONE                             = 0x00000003,
    DISPID_TUNER_TR_LOCATOR                           = 0x00000004,
    DISPID_TUNER_CT_CATEGORY                          = 0x00000001,
    DISPID_TUNER_CT_MEDIAMAJORTYPE                    = 0x00000002,
    DISPID_TUNER_CT__MEDIAMAJORTYPE                   = 0x00000003,
    DISPID_TUNER_CT_MEDIASUBTYPE                      = 0x00000004,
    DISPID_TUNER_CT__MEDIASUBTYPE                     = 0x00000005,
    DISPID_TUNER_CT_MEDIAFORMATTYPE                   = 0x00000006,
    DISPID_TUNER_CT__MEDIAFORMATTYPE                  = 0x00000007,
    DISPID_TUNER_CT_MEDIATYPE                         = 0x00000008,
    DISPID_TUNER_CT_CLONE                             = 0x00000009,
    DISPID_TUNER_LCT_LANGID                           = 0x00000064,
    DISPID_TUNER_MP2CT_TYPE                           = 0x000000c8,
    DISPID_TUNER_ATSCCT_FLAGS                         = 0x0000012c,
    DISPID_TUNER_L_CARRFREQ                           = 0x00000001,
    DISPID_TUNER_L_INNERFECMETHOD                     = 0x00000002,
    DISPID_TUNER_L_INNERFECRATE                       = 0x00000003,
    DISPID_TUNER_L_OUTERFECMETHOD                     = 0x00000004,
    DISPID_TUNER_L_OUTERFECRATE                       = 0x00000005,
    DISPID_TUNER_L_MOD                                = 0x00000006,
    DISPID_TUNER_L_SYMRATE                            = 0x00000007,
    DISPID_TUNER_L_CLONE                              = 0x00000008,
    DISPID_TUNER_L_ATSC_PHYS_CHANNEL                  = 0x000000c9,
    DISPID_TUNER_L_ATSC_TSID                          = 0x000000ca,
    DISPID_TUNER_L_ATSC_MP2_PROGNO                    = 0x000000cb,
    DISPID_TUNER_L_DVBT_BANDWIDTH                     = 0x0000012d,
    DISPID_TUNER_L_DVBT_LPINNERFECMETHOD              = 0x0000012e,
    DISPID_TUNER_L_DVBT_LPINNERFECRATE                = 0x0000012f,
    DISPID_TUNER_L_DVBT_GUARDINTERVAL                 = 0x00000130,
    DISPID_TUNER_L_DVBT_HALPHA                        = 0x00000131,
    DISPID_TUNER_L_DVBT_TRANSMISSIONMODE              = 0x00000132,
    DISPID_TUNER_L_DVBT_INUSE                         = 0x00000133,
    DISPID_TUNER_L_DVBT2_PHYSICALLAYERPIPEID          = 0x0000015f,
    DISPID_TUNER_L_DVBS_POLARISATION                  = 0x00000191,
    DISPID_TUNER_L_DVBS_WEST                          = 0x00000192,
    DISPID_TUNER_L_DVBS_ORBITAL                       = 0x00000193,
    DISPID_TUNER_L_DVBS_AZIMUTH                       = 0x00000194,
    DISPID_TUNER_L_DVBS_ELEVATION                     = 0x00000195,
    DISPID_TUNER_L_DVBS2_DISEQ_LNB_SOURCE             = 0x00000196,
    DISPID_TUNER_TS_DVBS2_LOW_OSC_FREQ_OVERRIDE       = 0x00000197,
    DISPID_TUNER_TS_DVBS2_HI_OSC_FREQ_OVERRIDE        = 0x00000198,
    DISPID_TUNER_TS_DVBS2_LNB_SWITCH_FREQ_OVERRIDE    = 0x00000199,
    DISPID_TUNER_TS_DVBS2_SPECTRAL_INVERSION_OVERRIDE = 0x0000019a,
    DISPID_TUNER_L_DVBS2_ROLLOFF                      = 0x0000019b,
    DISPID_TUNER_L_DVBS2_PILOT                        = 0x0000019c,
    DISPID_TUNER_L_ANALOG_STANDARD                    = 0x00000259,
    DISPID_TUNER_L_DTV_O_MAJOR_CHANNEL                = 0x000002bd,
    DISPID_TUNER_C_TYPE                               = 0x00000001,
    DISPID_TUNER_C_STATUS                             = 0x00000002,
    DISPID_TUNER_C_LANGID                             = 0x00000003,
    DISPID_TUNER_C_DESCRIPTION                        = 0x00000004,
    DISPID_TUNER_C_CLONE                              = 0x00000005,
    DISPID_TUNER_C_MP2_PID                            = 0x00000065,
    DISPID_TUNER_C_MP2_PCRPID                         = 0x00000066,
    DISPID_TUNER_C_MP2_PROGNO                         = 0x00000067,
    DISPID_TUNER_C_ANALOG_AUDIO                       = 0x000000c9,
    DISPID_TUNER_TS_DVB_SYSTEMTYPE                    = 0x00000065,
    DISPID_TUNER_TS_DVB2_NETWORK_ID                   = 0x00000066,
    DISPID_TUNER_TS_DVBS_LOW_OSC_FREQ                 = 0x000003e9,
    DISPID_TUNER_TS_DVBS_HI_OSC_FREQ                  = 0x000003ea,
    DISPID_TUNER_TS_DVBS_LNB_SWITCH_FREQ              = 0x000003eb,
    DISPID_TUNER_TS_DVBS_INPUT_RANGE                  = 0x000003ec,
    DISPID_TUNER_TS_DVBS_SPECTRAL_INVERSION           = 0x000003ed,
    DISPID_TUNER_TS_AR_MINFREQUENCY                   = 0x00000065,
    DISPID_TUNER_TS_AR_MAXFREQUENCY                   = 0x00000066,
    DISPID_TUNER_TS_AR_STEP                           = 0x00000067,
    DISPID_TUNER_TS_AR_COUNTRYCODE                    = 0x00000068,
    DISPID_TUNER_TS_AUX_COUNTRYCODE                   = 0x00000065,
    DISPID_TUNER_TS_ATV_MINCHANNEL                    = 0x00000065,
    DISPID_TUNER_TS_ATV_MAXCHANNEL                    = 0x00000066,
    DISPID_TUNER_TS_ATV_INPUTTYPE                     = 0x00000067,
    DISPID_TUNER_TS_ATV_COUNTRYCODE                   = 0x00000068,
    DISPID_TUNER_TS_ATSC_MINMINORCHANNEL              = 0x000000c9,
    DISPID_TUNER_TS_ATSC_MAXMINORCHANNEL              = 0x000000ca,
    DISPID_TUNER_TS_ATSC_MINPHYSCHANNEL               = 0x000000cb,
    DISPID_TUNER_TS_ATSC_MAXPHYSCHANNEL               = 0x000000cc,
    DISPID_TUNER_TS_DC_MINMAJORCHANNEL                = 0x0000012d,
    DISPID_TUNER_TS_DC_MAXMAJORCHANNEL                = 0x0000012e,
    DISPID_TUNER_TS_DC_MINSOURCEID                    = 0x0000012f,
    DISPID_TUNER_TS_DC_MAXSOURCEID                    = 0x00000130,
    DISPID_CHTUNER_ATVAC_CHANNEL                      = 0x00000065,
    DISPID_CHTUNER_ATVDC_SYSTEM                       = 0x00000065,
    DISPID_CHTUNER_ATVDC_CONTENT                      = 0x00000066,
    DISPID_CHTUNER_CIDTR_CHANNELID                    = 0x00000065,
    DISPID_CHTUNER_CTR_CHANNEL                        = 0x00000065,
    DISPID_CHTUNER_ACTR_MINOR_CHANNEL                 = 0x000000c9,
    DISPID_CHTUNER_DCTR_MAJOR_CHANNEL                 = 0x0000012d,
    DISPID_CHTUNER_DCTR_SRCID                         = 0x0000012e,
    DISPID_DVBTUNER_DVBC_ATTRIBUTESVALID              = 0x00000065,
    DISPID_DVBTUNER_DVBC_PID                          = 0x00000066,
    DISPID_DVBTUNER_DVBC_TAG                          = 0x00000067,
    DISPID_DVBTUNER_DVBC_COMPONENTTYPE                = 0x00000068,
    DISPID_DVBTUNER_ONID                              = 0x00000065,
    DISPID_DVBTUNER_TSID                              = 0x00000066,
    DISPID_DVBTUNER_SID                               = 0x00000067,
    DISPID_MP2TUNER_TSID                              = 0x00000065,
    DISPID_MP2TUNER_PROGNO                            = 0x00000066,
    DISPID_MP2TUNERFACTORY_CREATETUNEREQUEST          = 0x00000001,
}

alias EnTvRat_System = int;
enum : int
{
    MPAA                 = 0x00000000,
    US_TV                = 0x00000001,
    Canadian_English     = 0x00000002,
    Canadian_French      = 0x00000003,
    Reserved4            = 0x00000004,
    System5              = 0x00000005,
    System6              = 0x00000006,
    Reserved7            = 0x00000007,
    PBDA                 = 0x00000008,
    AgeBased             = 0x00000009,
    TvRat_kSystems       = 0x0000000a,
    TvRat_SystemDontKnow = 0x000000ff,
}

alias EnTvRat_GenericLevel = int;
enum : int
{
    TvRat_0             = 0x00000000,
    TvRat_1             = 0x00000001,
    TvRat_2             = 0x00000002,
    TvRat_3             = 0x00000003,
    TvRat_4             = 0x00000004,
    TvRat_5             = 0x00000005,
    TvRat_6             = 0x00000006,
    TvRat_7             = 0x00000007,
    TvRat_8             = 0x00000008,
    TvRat_9             = 0x00000009,
    TvRat_10            = 0x0000000a,
    TvRat_11            = 0x0000000b,
    TvRat_12            = 0x0000000c,
    TvRat_13            = 0x0000000d,
    TvRat_14            = 0x0000000e,
    TvRat_15            = 0x0000000f,
    TvRat_16            = 0x00000010,
    TvRat_17            = 0x00000011,
    TvRat_18            = 0x00000012,
    TvRat_19            = 0x00000013,
    TvRat_20            = 0x00000014,
    TvRat_21            = 0x00000015,
    TvRat_kLevels       = 0x00000016,
    TvRat_Unblock       = 0xffffffff,
    TvRat_LevelDontKnow = 0x000000ff,
}

alias EnTvRat_MPAA = int;
enum : int
{
    MPAA_NotApplicable = 0x00000000,
    MPAA_G             = 0x00000001,
    MPAA_PG            = 0x00000002,
    MPAA_PG13          = 0x00000003,
    MPAA_R             = 0x00000004,
    MPAA_NC17          = 0x00000005,
    MPAA_X             = 0x00000006,
    MPAA_NotRated      = 0x00000007,
}

alias EnTvRat_US_TV = int;
enum : int
{
    US_TV_None  = 0x00000000,
    US_TV_Y     = 0x00000001,
    US_TV_Y7    = 0x00000002,
    US_TV_G     = 0x00000003,
    US_TV_PG    = 0x00000004,
    US_TV_14    = 0x00000005,
    US_TV_MA    = 0x00000006,
    US_TV_None7 = 0x00000007,
}

alias EnTvRat_CAE_TV = int;
enum : int
{
    CAE_TV_Exempt   = 0x00000000,
    CAE_TV_C        = 0x00000001,
    CAE_TV_C8       = 0x00000002,
    CAE_TV_G        = 0x00000003,
    CAE_TV_PG       = 0x00000004,
    CAE_TV_14       = 0x00000005,
    CAE_TV_18       = 0x00000006,
    CAE_TV_Reserved = 0x00000007,
}

alias EnTvRat_CAF_TV = int;
enum : int
{
    CAF_TV_Exempt    = 0x00000000,
    CAF_TV_G         = 0x00000001,
    CAF_TV_8         = 0x00000002,
    CAF_TV_13        = 0x00000003,
    CAF_TV_16        = 0x00000004,
    CAF_TV_18        = 0x00000005,
    CAF_TV_Reserved6 = 0x00000006,
    CAF_TV_Reserved  = 0x00000007,
}

alias BfEnTvRat_GenericAttributes = int;
enum : int
{
    BfAttrNone         = 0x00000000,
    BfIsBlocked        = 0x00000001,
    BfIsAttr_1         = 0x00000002,
    BfIsAttr_2         = 0x00000004,
    BfIsAttr_3         = 0x00000008,
    BfIsAttr_4         = 0x00000010,
    BfIsAttr_5         = 0x00000020,
    BfIsAttr_6         = 0x00000040,
    BfIsAttr_7         = 0x00000080,
    BfValidAttrSubmask = 0x000000ff,
}

alias BfEnTvRat_Attributes_US_TV = int;
enum : int
{
    US_TV_IsBlocked                  = 0x00000001,
    US_TV_IsViolent                  = 0x00000002,
    US_TV_IsSexualSituation          = 0x00000004,
    US_TV_IsAdultLanguage            = 0x00000008,
    US_TV_IsSexuallySuggestiveDialog = 0x00000010,
    US_TV_ValidAttrSubmask           = 0x0000001f,
}

alias BfEnTvRat_Attributes_MPAA = int;
enum : int
{
    MPAA_IsBlocked        = 0x00000001,
    MPAA_ValidAttrSubmask = 0x00000001,
}

alias BfEnTvRat_Attributes_CAE_TV = int;
enum : int
{
    CAE_IsBlocked        = 0x00000001,
    CAE_ValidAttrSubmask = 0x00000001,
}

alias BfEnTvRat_Attributes_CAF_TV = int;
enum : int
{
    CAF_IsBlocked        = 0x00000001,
    CAF_ValidAttrSubmask = 0x00000001,
}

enum FormatNotSupportedEvents : int
{
    FORMATNOTSUPPORTED_CLEAR        = 0x00000000,
    FORMATNOTSUPPORTED_NOTSUPPORTED = 0x00000001,
}

///This topic applies to Windows XP Service Pack 1 or later. The <b>ProtType</b> enumeration type specifies various
///types of content protection.
enum ProtType : int
{
    ///Copy Free.
    PROT_COPY_FREE              = 0x00000001,
    ///Copy Once.
    PROT_COPY_ONCE              = 0x00000002,
    ///Copy Never.
    PROT_COPY_NEVER             = 0x00000003,
    ///Reserved.
    PROT_COPY_NEVER_REALLY      = 0x00000004,
    ///Copy No More.
    PROT_COPY_NO_MORE           = 0x00000005,
    ///The Copy Control Information (CCI) flag indicates Copy Free, but the Constrained Image Trigger (CIT) bit is set.
    ///The content is encrypted.
    PROT_COPY_FREE_CIT          = 0x00000006,
    ///Reserved.
    PROT_COPY_BF                = 0x00000007,
    ///Reserved.
    PROT_COPY_CN_RECORDING_STOP = 0x00000008,
    ///The Copy Control Information (CCI) flag indicates Copy Free, but the Redistribution Control Trigger (RCT) bit is
    ///set. The content is encrypted.
    PROT_COPY_FREE_SECURE       = 0x00000009,
    ///Error or invalid protection scheme. Treat as Copy Never.
    PROT_COPY_INVALID           = 0x00000032,
}

enum EncDecEvents : int
{
    ENCDEC_CPEVENT          = 0x00000000,
    ENCDEC_RECORDING_STATUS = 0x00000001,
}

enum CPRecordingStatus : int
{
    RECORDING_STOPPED = 0x00000000,
    RECORDING_STARTED = 0x00000001,
}

enum CPEventBitShift : int
{
    CPEVENT_BITSHIFT_RATINGS             = 0x00000000,
    CPEVENT_BITSHIFT_COPP                = 0x00000001,
    CPEVENT_BITSHIFT_LICENSE             = 0x00000002,
    CPEVENT_BITSHIFT_ROLLBACK            = 0x00000003,
    CPEVENT_BITSHIFT_SAC                 = 0x00000004,
    CPEVENT_BITSHIFT_DOWNRES             = 0x00000005,
    CPEVENT_BITSHIFT_STUBLIB             = 0x00000006,
    CPEVENT_BITSHIFT_UNTRUSTEDGRAPH      = 0x00000007,
    CPEVENT_BITSHIFT_PENDING_CERTIFICATE = 0x00000008,
    CPEVENT_BITSHIFT_NO_PLAYREADY        = 0x00000009,
}

///This topic applies to Windows XP Service Pack 1 or later. The <b>CPEvents</b> enumeration defines copy protection
///events for the Decrypter/Detagger filter. This enumeration is used with the EVENTID_EncDecFilterEvent event. For more
///information, see TV Ratings Broadcast Events.
enum CPEvents : int
{
    ///No content protection issues.
    CPEVENT_NONE            = 0x00000000,
    ///Content is blocked because of parental ratings.
    CPEVENT_RATINGS         = 0x00000001,
    ///Content is blocked because of copy protection rules.
    CPEVENT_COPP            = 0x00000002,
    ///Content is blocked because the DRM license is not valid.
    CPEVENT_LICENSE         = 0x00000003,
    ///Content is blocked because the system detected that the clock was rolled back.
    CPEVENT_ROLLBACK        = 0x00000004,
    ///Content is blocked because the filter graph contains untrusted components.
    CPEVENT_SAC             = 0x00000005,
    ///Content is being rendered at a lower resolution due to copy protection.
    CPEVENT_DOWNRES         = 0x00000006,
    ///Content is blocked because the filter graph contains untrusted components.
    CPEVENT_STUBLIB         = 0x00000007,
    ///Content is blocked because the filter graph contains untrusted components.
    CPEVENT_UNTRUSTEDGRAPH  = 0x00000008,
    CPEVENT_PROTECTWINDOWED = 0x00000009,
}

enum RevokedComponent : int
{
    REVOKED_COPP            = 0x00000000,
    REVOKED_SAC             = 0x00000001,
    REVOKED_APP_STUB        = 0x00000002,
    REVOKED_SECURE_PIPELINE = 0x00000003,
    REVOKED_MAX_TYPES       = 0x00000004,
}

alias EnTag_Mode = int;
enum : int
{
    EnTag_Remove = 0x00000000,
    EnTag_Once   = 0x00000001,
    EnTag_Repeat = 0x00000002,
}

enum COPPEventBlockReason : int
{
    COPP_Unknown                 = 0xffffffff,
    COPP_BadDriver               = 0x00000000,
    COPP_NoCardHDCPSupport       = 0x00000001,
    COPP_NoMonitorHDCPSupport    = 0x00000002,
    COPP_BadCertificate          = 0x00000003,
    COPP_InvalidBusProtection    = 0x00000004,
    COPP_AeroGlassOff            = 0x00000005,
    COPP_RogueApp                = 0x00000006,
    COPP_ForbiddenVideo          = 0x00000007,
    COPP_Activate                = 0x00000008,
    COPP_DigitalAudioUnprotected = 0x00000009,
}

enum LicenseEventBlockReason : int
{
    LIC_BadLicense      = 0x00000000,
    LIC_NeedIndiv       = 0x00000001,
    LIC_Expired         = 0x00000002,
    LIC_NeedActivation  = 0x00000003,
    LIC_ExtenderBlocked = 0x00000004,
}

enum DownResEventParam : int
{
    DOWNRES_Always       = 0x00000000,
    DOWNRES_InWindowOnly = 0x00000001,
    DOWNRES_Undefined    = 0x00000002,
}

enum SegDispidList : int
{
    dispidName                             = 0x00000000,
    dispidStatus                           = 0x00000001,
    dispidDevImageSourceWidth              = 0x00000002,
    dispidDevImageSourceHeight             = 0x00000003,
    dispidDevCountryCode                   = 0x00000004,
    dispidDevOverScan                      = 0x00000005,
    dispidSegment                          = 0x00000006,
    dispidDevVolume                        = 0x00000007,
    dispidDevBalance                       = 0x00000008,
    dispidDevPower                         = 0x00000009,
    dispidTuneChan                         = 0x0000000a,
    dispidDevVideoSubchannel               = 0x0000000b,
    dispidDevAudioSubchannel               = 0x0000000c,
    dispidChannelAvailable                 = 0x0000000d,
    dispidDevVideoFrequency                = 0x0000000e,
    dispidDevAudioFrequency                = 0x0000000f,
    dispidCount                            = 0x00000010,
    dispidDevFileName                      = 0x00000011,
    dispidVisible                          = 0x00000012,
    dispidOwner                            = 0x00000013,
    dispidMessageDrain                     = 0x00000014,
    dispidViewable                         = 0x00000015,
    dispidDevView                          = 0x00000016,
    dispidKSCat                            = 0x00000017,
    dispidCLSID                            = 0x00000018,
    dispid_KSCat                           = 0x00000019,
    dispid_CLSID                           = 0x0000001a,
    dispidTune                             = 0x0000001b,
    dispidTS                               = 0x0000001c,
    dispidDevSAP                           = 0x0000001d,
    dispidClip                             = 0x0000001e,
    dispidRequestedClipRect                = 0x0000001f,
    dispidClippedSourceRect                = 0x00000020,
    dispidAvailableSourceRect              = 0x00000021,
    dispidMediaPosition                    = 0x00000022,
    dispidDevRun                           = 0x00000023,
    dispidDevPause                         = 0x00000024,
    dispidDevStop                          = 0x00000025,
    dispidCCEnable                         = 0x00000026,
    dispidDevStep                          = 0x00000027,
    dispidDevCanStep                       = 0x00000028,
    dispidSourceSize                       = 0x00000029,
    dispid_playtitle                       = 0x0000002a,
    dispid_playchapterintitle              = 0x0000002b,
    dispid_playchapter                     = 0x0000002c,
    dispid_playchaptersautostop            = 0x0000002d,
    dispid_playattime                      = 0x0000002e,
    dispid_playattimeintitle               = 0x0000002f,
    dispid_playperiodintitleautostop       = 0x00000030,
    dispid_replaychapter                   = 0x00000031,
    dispid_playprevchapter                 = 0x00000032,
    dispid_playnextchapter                 = 0x00000033,
    dispid_playforwards                    = 0x00000034,
    dispid_playbackwards                   = 0x00000035,
    dispid_stilloff                        = 0x00000036,
    dispid_audiolanguage                   = 0x00000037,
    dispid_showmenu                        = 0x00000038,
    dispid_resume                          = 0x00000039,
    dispid_returnfromsubmenu               = 0x0000003a,
    dispid_buttonsavailable                = 0x0000003b,
    dispid_currentbutton                   = 0x0000003c,
    dispid_SelectAndActivateButton         = 0x0000003d,
    dispid_ActivateButton                  = 0x0000003e,
    dispid_SelectRightButton               = 0x0000003f,
    dispid_SelectLeftButton                = 0x00000040,
    dispid_SelectLowerButton               = 0x00000041,
    dispid_SelectUpperButton               = 0x00000042,
    dispid_ActivateAtPosition              = 0x00000043,
    dispid_SelectAtPosition                = 0x00000044,
    dispid_ButtonAtPosition                = 0x00000045,
    dispid_NumberOfChapters                = 0x00000046,
    dispid_TotalTitleTime                  = 0x00000047,
    dispid_TitlesAvailable                 = 0x00000048,
    dispid_VolumesAvailable                = 0x00000049,
    dispid_CurrentVolume                   = 0x0000004a,
    dispid_CurrentDiscSide                 = 0x0000004b,
    dispid_CurrentDomain                   = 0x0000004c,
    dispid_CurrentChapter                  = 0x0000004d,
    dispid_CurrentTitle                    = 0x0000004e,
    dispid_CurrentTime                     = 0x0000004f,
    dispid_FramesPerSecond                 = 0x00000050,
    dispid_DVDTimeCode2bstr                = 0x00000051,
    dispid_DVDDirectory                    = 0x00000052,
    dispid_IsSubpictureStreamEnabled       = 0x00000053,
    dispid_IsAudioStreamEnabled            = 0x00000054,
    dispid_CurrentSubpictureStream         = 0x00000055,
    dispid_SubpictureLanguage              = 0x00000056,
    dispid_CurrentAudioStream              = 0x00000057,
    dispid_AudioStreamsAvailable           = 0x00000058,
    dispid_AnglesAvailable                 = 0x00000059,
    dispid_CurrentAngle                    = 0x0000005a,
    dispid_CCActive                        = 0x0000005b,
    dispid_CurrentCCService                = 0x0000005c,
    dispid_SubpictureStreamsAvailable      = 0x0000005d,
    dispid_SubpictureOn                    = 0x0000005e,
    dispid_DVDUniqueID                     = 0x0000005f,
    dispid_EnableResetOnStop               = 0x00000060,
    dispid_AcceptParentalLevelChange       = 0x00000061,
    dispid_NotifyParentalLevelChange       = 0x00000062,
    dispid_SelectParentalCountry           = 0x00000063,
    dispid_SelectParentalLevel             = 0x00000064,
    dispid_TitleParentalLevels             = 0x00000065,
    dispid_PlayerParentalCountry           = 0x00000066,
    dispid_PlayerParentalLevel             = 0x00000067,
    dispid_Eject                           = 0x00000068,
    dispid_UOPValid                        = 0x00000069,
    dispid_SPRM                            = 0x0000006a,
    dispid_GPRM                            = 0x0000006b,
    dispid_DVDTextStringType               = 0x0000006c,
    dispid_DVDTextString                   = 0x0000006d,
    dispid_DVDTextNumberOfStrings          = 0x0000006e,
    dispid_DVDTextNumberOfLanguages        = 0x0000006f,
    dispid_DVDTextLanguageLCID             = 0x00000070,
    dispid_RegionChange                    = 0x00000071,
    dispid_DVDAdm                          = 0x00000072,
    dispid_DeleteBookmark                  = 0x00000073,
    dispid_RestoreBookmark                 = 0x00000074,
    dispid_SaveBookmark                    = 0x00000075,
    dispid_SelectDefaultAudioLanguage      = 0x00000076,
    dispid_SelectDefaultSubpictureLanguage = 0x00000077,
    dispid_PreferredSubpictureStream       = 0x00000078,
    dispid_DefaultMenuLanguage             = 0x00000079,
    dispid_DefaultSubpictureLanguage       = 0x0000007a,
    dispid_DefaultAudioLanguage            = 0x0000007b,
    dispid_DefaultSubpictureLanguageExt    = 0x0000007c,
    dispid_DefaultAudioLanguageExt         = 0x0000007d,
    dispid_LanguageFromLCID                = 0x0000007e,
    dispid_KaraokeAudioPresentationMode    = 0x0000007f,
    dispid_KaraokeChannelContent           = 0x00000080,
    dispid_KaraokeChannelAssignment        = 0x00000081,
    dispid_RestorePreferredSettings        = 0x00000082,
    dispid_ButtonRect                      = 0x00000083,
    dispid_DVDScreenInMouseCoordinates     = 0x00000084,
    dispid_CustomCompositorClass           = 0x00000085,
    dispidCustomCompositorClass            = 0x00000086,
    dispid_CustomCompositor                = 0x00000087,
    dispidMixerBitmap                      = 0x00000088,
    dispid_MixerBitmap                     = 0x00000089,
    dispidMixerBitmapOpacity               = 0x0000008a,
    dispidMixerBitmapRect                  = 0x0000008b,
    dispidSetupMixerBitmap                 = 0x0000008c,
    dispidUsingOverlay                     = 0x0000008d,
    dispidDisplayChange                    = 0x0000008e,
    dispidRePaint                          = 0x0000008f,
    dispid_IsEqualDevice                   = 0x00000090,
    dispidrate                             = 0x00000091,
    dispidposition                         = 0x00000092,
    dispidpositionmode                     = 0x00000093,
    dispidlength                           = 0x00000094,
    dispidChangePassword                   = 0x00000095,
    dispidSaveParentalLevel                = 0x00000096,
    dispidSaveParentalCountry              = 0x00000097,
    dispidConfirmPassword                  = 0x00000098,
    dispidGetParentalLevel                 = 0x00000099,
    dispidGetParentalCountry               = 0x0000009a,
    dispidDefaultAudioLCID                 = 0x0000009b,
    dispidDefaultSubpictureLCID            = 0x0000009c,
    dispidDefaultMenuLCID                  = 0x0000009d,
    dispidBookmarkOnStop                   = 0x0000009e,
    dispidMaxVidRect                       = 0x0000009f,
    dispidMinVidRect                       = 0x000000a0,
    dispidCapture                          = 0x000000a1,
    dispid_DecimateInput                   = 0x000000a2,
    dispidAlloctor                         = 0x000000a3,
    dispid_Allocator                       = 0x000000a4,
    dispidAllocPresentID                   = 0x000000a5,
    dispidSetAllocator                     = 0x000000a6,
    dispid_SetAllocator                    = 0x000000a7,
    dispidStreamBufferSinkName             = 0x000000a8,
    dispidStreamBufferSourceName           = 0x000000a9,
    dispidStreamBufferContentRecording     = 0x000000aa,
    dispidStreamBufferReferenceRecording   = 0x000000ab,
    dispidstarttime                        = 0x000000ac,
    dispidstoptime                         = 0x000000ad,
    dispidrecordingstopped                 = 0x000000ae,
    dispidrecordingstarted                 = 0x000000af,
    dispidNameSetLock                      = 0x000000b0,
    dispidrecordingtype                    = 0x000000b1,
    dispidstart                            = 0x000000b2,
    dispidRecordingAttribute               = 0x000000b3,
    dispid_RecordingAttribute              = 0x000000b4,
    dispidSBEConfigure                     = 0x000000b5,
    dispid_CurrentRatings                  = 0x000000b6,
    dispid_MaxRatingsLevel                 = 0x000000b7,
    dispid_audioencoderint                 = 0x000000b8,
    dispid_videoencoderint                 = 0x000000b9,
    dispidService                          = 0x000000ba,
    dispid_BlockUnrated                    = 0x000000bb,
    dispid_UnratedDelay                    = 0x000000bc,
    dispid_SuppressEffects                 = 0x000000bd,
    dispidsbesource                        = 0x000000be,
    dispidSetSinkFilter                    = 0x000000bf,
    dispid_SinkStreams                     = 0x000000c0,
    dispidTVFormats                        = 0x000000c1,
    dispidModes                            = 0x000000c2,
    dispidAuxInputs                        = 0x000000c3,
    dispidTeleTextFilter                   = 0x000000c4,
    dispid_channelchangeint                = 0x000000c5,
    dispidUnlockProfile                    = 0x000000c6,
    dispid_AddFilter                       = 0x000000c7,
    dispidSetMinSeek                       = 0x000000c8,
    dispidRateEx                           = 0x000000c9,
    dispidaudiocounter                     = 0x000000ca,
    dispidvideocounter                     = 0x000000cb,
    dispidcccounter                        = 0x000000cc,
    dispidwstcounter                       = 0x000000cd,
    dispid_audiocounter                    = 0x000000ce,
    dispid_videocounter                    = 0x000000cf,
    dispid_cccounter                       = 0x000000d0,
    dispid_wstcounter                      = 0x000000d1,
    dispidaudioanalysis                    = 0x000000d2,
    dispidvideoanalysis                    = 0x000000d3,
    dispiddataanalysis                     = 0x000000d4,
    dispidaudio_analysis                   = 0x000000d5,
    dispidvideo_analysis                   = 0x000000d6,
    dispiddata_analysis                    = 0x000000d7,
    dispid_resetFilterList                 = 0x000000d8,
    dispidDevicePath                       = 0x000000d9,
    dispid_SourceFilter                    = 0x000000da,
    dispid__SourceFilter                   = 0x000000db,
    dispidUserEvent                        = 0x000000dc,
    dispid_Bookmark                        = 0x000000dd,
    LastReservedDeviceDispid               = 0x00003fff,
}

enum SegEventidList : int
{
    eventidStateChange                   = 0x00000000,
    eventidOnTuneChanged                 = 0x00000001,
    eventidEndOfMedia                    = 0x00000002,
    eventidDVDNotify                     = 0x00000003,
    eventidPlayForwards                  = 0x00000004,
    eventidPlayBackwards                 = 0x00000005,
    eventidShowMenu                      = 0x00000006,
    eventidResume                        = 0x00000007,
    eventidSelectOrActivateButton        = 0x00000008,
    eventidStillOff                      = 0x00000009,
    eventidPauseOn                       = 0x0000000a,
    eventidChangeCurrentAudioStream      = 0x0000000b,
    eventidChangeCurrentSubpictureStream = 0x0000000c,
    eventidChangeCurrentAngle            = 0x0000000d,
    eventidPlayAtTimeInTitle             = 0x0000000e,
    eventidPlayAtTime                    = 0x0000000f,
    eventidPlayChapterInTitle            = 0x00000010,
    eventidPlayChapter                   = 0x00000011,
    eventidReplayChapter                 = 0x00000012,
    eventidPlayNextChapter               = 0x00000013,
    eventidStop                          = 0x00000014,
    eventidReturnFromSubmenu             = 0x00000015,
    eventidPlayTitle                     = 0x00000016,
    eventidPlayPrevChapter               = 0x00000017,
    eventidChangeKaraokePresMode         = 0x00000018,
    eventidChangeVideoPresMode           = 0x00000019,
    eventidOverlayUnavailable            = 0x0000001a,
    eventidSinkCertificateFailure        = 0x0000001b,
    eventidSinkCertificateSuccess        = 0x0000001c,
    eventidSourceCertificateFailure      = 0x0000001d,
    eventidSourceCertificateSuccess      = 0x0000001e,
    eventidRatingsBlocked                = 0x0000001f,
    eventidRatingsUnlocked               = 0x00000020,
    eventidRatingsChanged                = 0x00000021,
    eventidWriteFailure                  = 0x00000022,
    eventidTimeHole                      = 0x00000023,
    eventidStaleDataRead                 = 0x00000024,
    eventidContentBecomingStale          = 0x00000025,
    eventidStaleFileDeleted              = 0x00000026,
    eventidEncryptionOn                  = 0x00000027,
    eventidEncryptionOff                 = 0x00000028,
    eventidRateChange                    = 0x00000029,
    eventidLicenseChange                 = 0x0000002a,
    eventidCOPPBlocked                   = 0x0000002b,
    eventidCOPPUnblocked                 = 0x0000002c,
    dispidlicenseerrorcode               = 0x0000002d,
    eventidBroadcastEvent                = 0x0000002e,
    eventidBroadcastEventEx              = 0x0000002f,
    eventidContentPrimarilyAudio         = 0x00000030,
    dispidAVDecAudioDualMonoEvent        = 0x00000031,
    dispidAVAudioSampleRateEvent         = 0x00000032,
    dispidAVAudioChannelConfigEvent      = 0x00000033,
    dispidAVAudioChannelCountEvent       = 0x00000034,
    dispidAVDecCommonMeanBitRateEvent    = 0x00000035,
    dispidAVDDSurroundModeEvent          = 0x00000036,
    dispidAVDecCommonInputFormatEvent    = 0x00000037,
    dispidAVDecCommonOutputFormatEvent   = 0x00000038,
    eventidWriteFailureClear             = 0x00000039,
    LastReservedDeviceEvent              = 0x00003fff,
}

enum PositionModeList : int
{
    FrameMode         = 0x00000000,
    TenthsSecondsMode = 0x00000001,
}

enum RecordingType : int
{
    CONTENT   = 0x00000000,
    REFERENCE = 0x00000001,
}

///This topic applies to Windows XP Service Pack 1 or later. The <b>MSVidCCService</b> enumeration indicates closed
///captioning services.
enum MSVidCCService : int
{
    ///No current service
    None     = 0x00000000,
    ///CC1 (caption channel)
    Caption1 = 0x00000001,
    ///CC2 (caption channel)
    Caption2 = 0x00000002,
    ///T1 (text channel)
    Text1    = 0x00000003,
    ///T2 (text channel)
    Text2    = 0x00000004,
    ///Extended data services (XDS or EDS)
    XDS      = 0x00000005,
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>MSVidSinkStreams</b>
///enumeration defines the stream types for a generic sink.
enum MSVidSinkStreams : int
{
    MSVidSink_Video = 0x00000001,
    MSVidSink_Audio = 0x00000002,
    MSVidSink_Other = 0x00000004,
}

enum MSVidSegmentType : int
{
    MSVidSEG_SOURCE = 0x00000000,
    MSVidSEG_XFORM  = 0x00000001,
    MSVidSEG_DEST   = 0x00000002,
}

enum MSVidCtlButtonstate : int
{
    MSVIDCTL_LEFT_BUTTON   = 0x00000001,
    MSVIDCTL_RIGHT_BUTTON  = 0x00000002,
    MSVIDCTL_MIDDLE_BUTTON = 0x00000004,
    MSVIDCTL_X_BUTTON1     = 0x00000008,
    MSVIDCTL_X_BUTTON2     = 0x00000010,
    MSVIDCTL_SHIFT         = 0x00000001,
    MSVIDCTL_CTRL          = 0x00000002,
    MSVIDCTL_ALT           = 0x00000004,
}

///The <b>DVDMenuID</b> constants define menu type ID numbers used to display specific menus.
enum DVDMenuIDConstants : int
{
    ///Title menu, also called the Video Manager Menu.
    dvdMenu_Title      = 0x00000002,
    ///Root menu, the menu for one video title set, which can contain one title or a group of titles.
    dvdMenu_Root       = 0x00000003,
    ///Subpicture menu.
    dvdMenu_Subpicture = 0x00000004,
    ///Audio menu.
    dvdMenu_Audio      = 0x00000005,
    ///Angle menu.
    dvdMenu_Angle      = 0x00000006,
    ///Chapter menu.
    dvdMenu_Chapter    = 0x00000007,
}

enum DVDFilterState : int
{
    dvdState_Undefined   = 0xfffffffe,
    dvdState_Unitialized = 0xffffffff,
    dvdState_Stopped     = 0x00000000,
    dvdState_Paused      = 0x00000001,
    dvdState_Running     = 0x00000002,
}

///The <b>DVDTextStringType</b> enumeration type indicates the type of information contained in a DVD text string.
enum DVDTextStringType : int
{
    ///Indicates the top level of the logical hierarchy. Refers to the entire contents of a one-sided disc or one side
    ///of a two-sided disc.
    dvdStruct_Volume      = 0x00000001,
    ///Indicates that all content strings, until the next dvd_Struct_Title, belong to one title.
    dvdStruct_Title       = 0x00000002,
    ///Indicates the parental ID of the following strings.
    dvdStruct_ParentalID  = 0x00000003,
    ///Indicates that all content strings, until the next dvd_Struct_PartOfTitle, belong to one chapter.
    dvdStruct_PartOfTitle = 0x00000004,
    ///Indicates that all content strings, until the next dvd_Struct_Cell, belong to one cell, which can be a scene from
    ///a chapter.
    dvdStruct_Cell        = 0x00000005,
    ///Indicates that the following content strings refer to the audio stream.
    dvdStream_Audio       = 0x00000010,
    ///Indicates that the following content strings refer to the subpicture stream.
    dvdStream_Subpicture  = 0x00000011,
    ///Indicates that the following content strings refer to the angle.
    dvdStream_Angle       = 0x00000012,
    ///Indicates that the following content strings refer to the audio channel.
    dvdChannel_Audio      = 0x00000020,
    ///Indicates the most important content string. Strings of this type contain the name of the volume, title, chapter,
    ///and so on, and can follow any structure identifiers.
    dvdGeneral_Name       = 0x00000030,
    ///Identifies a content string with additional information about the title, chapter, and so on, described by the
    ///dvd_General_Name string. The exact nature or structure of these comments is not defined.
    dvdGeneral_Comments   = 0x00000031,
    ///Identifies a content string containing the name of a series to which the title belongs.
    dvdTitle_Series       = 0x00000038,
    ///Identifies a content string with the main movie title.
    dvdTitle_Movie        = 0x00000039,
    ///Identifies a content string containing the name of the video title.
    dvdTitle_Video        = 0x0000003a,
    ///Identifies a content string containing the name of the album title.
    dvdTitle_Album        = 0x0000003b,
    ///Identifies a content string containing the name of the song title.
    dvdTitle_Song         = 0x0000003c,
    ///Identifies a content string containing the name of the title of some other genre.
    dvdTitle_Other        = 0x0000003f,
    ///Identifies a content string with the name of the series localized to a particular country/region.
    dvdTitle_Sub_Series   = 0x00000040,
    ///Identifies a content string with the movie title localized to a particular country/region.
    dvdTitle_Sub_Movie    = 0x00000041,
    ///Identifies a content string with the video title localized to a particular country/region.
    dvdTitle_Sub_Video    = 0x00000042,
    ///Identifies a content string with the album title localized to a particular country/region.
    dvdTitle_Sub_Album    = 0x00000043,
    ///Identifies a content string with the song title localized to a particular country/region.
    dvdTitle_Sub_Song     = 0x00000044,
    ///Identifies a content string with the title of some other genre localized to a particular country/region.
    dvdTitle_Sub_Other    = 0x00000047,
    ///Identifies a content string with the original name of the series.
    dvdTitle_Orig_Series  = 0x00000048,
    ///Identifies a content string with the original name of the movie.
    dvdTitle_Orig_Movie   = 0x00000049,
    ///Identifies a content string with the original name of the video.
    dvdTitle_Orig_Video   = 0x0000004a,
    ///Identifies a content string with the original name of the album.
    dvdTitle_Orig_Album   = 0x0000004b,
    ///Identifies a content string with the original name of the song.
    dvdTitle_Orig_Song    = 0x0000004c,
    ///Identifies a content string with the original name of the content.
    dvdTitle_Orig_Other   = 0x0000004f,
    ///Identifies a content string pertaining to a particular scene in a movie or video.
    dvdOther_Scene        = 0x00000050,
    ///Identifies a content string pertaining to a particular cut in a movie or video.
    dvdOther_Cut          = 0x00000051,
    ///Identifies a content string pertaining to a particular take in a movie or video.
    dvdOther_Take         = 0x00000052,
}

///The <b>DVDSPExt</b> enumeration type holds a value indicating the default DVD subpicture language extension.
alias DVDSPExt = int;
enum : int
{
    ///Extension not specified.
    dvdSPExt_NotSpecified              = 0x00000000,
    ///Normal caption size.
    dvdSPExt_Caption_Normal            = 0x00000001,
    ///Big captions.
    dvdSPExt_Caption_Big               = 0x00000002,
    ///Children's captions.
    dvdSPExt_Caption_Children          = 0x00000003,
    ///Normal-sized closed captions.
    dvdSPExt_CC_Normal                 = 0x00000005,
    ///Big closed captions.
    dvdSPExt_CC_Big                    = 0x00000006,
    ///Children's closed captions.
    dvdSPExt_CC_Children               = 0x00000007,
    ///Forced.
    dvdSPExt_Forced                    = 0x00000009,
    ///Normal-sized director's comments.
    dvdSPExt_DirectorComments_Normal   = 0x0000000d,
    ///Big director's comments.
    dvdSPExt_DirectorComments_Big      = 0x0000000e,
    ///Director's comments for children.
    dvdSPExt_DirectorComments_Children = 0x0000000f,
}

///This topic applies to Windows XP or later. The <b>SourceSizeList</b> enumeration is used to indicate how the VMR will
///clip the source video rectangle.
enum SourceSizeList : int
{
    ///Do not clip the source video rectangle.
    sslFullSize       = 0x00000000,
    ///Clip the source video rectangle by the value specified in the last call to IMSVidVideoRenderer::put_OverScan.
    sslClipByOverScan = 0x00000001,
    ///Clip the source video rectangle by the value specified in the last call to
    ///IMSVidVideoRenderer::put_ClippedSourceRect
    sslClipByClipRect = 0x00000002,
}

enum MSViddispidList : int
{
    dispidInputs              = 0x00000000,
    dispidOutputs             = 0x00000001,
    dispid_Inputs             = 0x00000002,
    dispid_Outputs            = 0x00000003,
    dispidVideoRenderers      = 0x00000004,
    dispidAudioRenderers      = 0x00000005,
    dispidFeatures            = 0x00000006,
    dispidInput               = 0x00000007,
    dispidOutput              = 0x00000008,
    dispidVideoRenderer       = 0x00000009,
    dispidAudioRenderer       = 0x0000000a,
    dispidSelectedFeatures    = 0x0000000b,
    dispidView                = 0x0000000c,
    dispidBuild               = 0x0000000d,
    dispidPause               = 0x0000000e,
    dispidRun                 = 0x0000000f,
    dispidStop                = 0x00000010,
    dispidDecompose           = 0x00000011,
    dispidDisplaySize         = 0x00000012,
    dispidMaintainAspectRatio = 0x00000013,
    dispidColorKey            = 0x00000014,
    dispidStateChange         = 0x00000015,
    dispidgetState            = 0x00000016,
    dispidunbind              = 0x00000017,
    dispidbind                = 0x00000018,
    dispidDisableVideo        = 0x00000019,
    dispidDisableAudio        = 0x0000001a,
    dispidViewNext            = 0x0000001b,
    dispidServiceP            = 0x0000001c,
}

///This topic applies to Windows XP or later. The <b>DisplaySizeList</b> enumeration defines the possible sizes at which
///the video rectangle may be rendered.
enum DisplaySizeList : int
{
    ///Display the video rectangle at the native size.
    dslDefaultSize      = 0x00000000,
    ///Same as <b>dslDefaultSize</b>.
    dslSourceSize       = 0x00000000,
    ///Display the video rectangle by shrinking the width and height by half.
    dslHalfSourceSize   = 0x00000001,
    ///Display the video rectangle by stretching the width and height to twice their native size.
    dslDoubleSourceSize = 0x00000002,
    ///Display the video rectangle by stretching the width and height to fill the entire screen as much as possible
    ///while maintaining the original aspect ratio.
    dslFullScreen       = 0x00000003,
    ///Display the video rectangle by stretching the width and height as much as possible to fill half (50%) of the
    ///screen while maintaining the original aspect ratio.
    dslHalfScreen       = 0x00000004,
    ///Display the video rectangle by stretching the width and height as much as possible to fill one quarter (25%) of
    ///the screen while maintaining the original aspect ratio.
    dslQuarterScreen    = 0x00000005,
    ///Display the video rectangle by stretching the width and height as much as possible to fill one sixteenth (6.25%)
    ///of the screen while maintaining the original aspect ratio.
    dslSixteenthScreen  = 0x00000006,
}

///This topic applies to Windows XP or later. The <b>MSVidCtlStateList</b> enumeration defines the possible state values
///of the Video Control or the underlying filter graph.
enum MSVidCtlStateList : int
{
    ///Indicates that there is no filter graph.
    STATE_UNBUILT = 0xffffffff,
    ///Indicates that the Video Control is stopped.
    STATE_STOP    = 0x00000000,
    ///Indicates that the Video Control is paused.
    STATE_PAUSE   = 0x00000001,
    ///Indicates that the Video Control is playing.
    STATE_PLAY    = 0x00000002,
}

alias __MIDL___MIDL_itf_sbe_0000_0001_0001 = int;
enum : int
{
    RECORDING_TYPE_CONTENT   = 0x00000000,
    RECORDING_TYPE_REFERENCE = 0x00000001,
}

///This topic applies only to Windows XP Service Pack 1 or later. The <b>STREAMBUFFER_ATTR_DATATYPE</b> enumeration
///defines the data type for an attribute.
alias STREAMBUFFER_ATTR_DATATYPE = int;
enum : int
{
    ///The attribute is a 32-bit <b>DWORD</b> value.
    STREAMBUFFER_TYPE_DWORD  = 0x00000000,
    ///The attribute is a null-terminated wide-character string.
    STREAMBUFFER_TYPE_STRING = 0x00000001,
    ///The attribute is an array of bytes.
    STREAMBUFFER_TYPE_BINARY = 0x00000002,
    ///The attribute is a 32-bit Boolean value.
    STREAMBUFFER_TYPE_BOOL   = 0x00000003,
    ///The attribute is a 64-bit <b>QWORD</b> value.
    STREAMBUFFER_TYPE_QWORD  = 0x00000004,
    ///The attribute is a 16-bit <b>WORD</b> value.
    STREAMBUFFER_TYPE_WORD   = 0x00000005,
    ///The attribute is a 128-bit <b>GUID</b> value.
    STREAMBUFFER_TYPE_GUID   = 0x00000006,
}

alias CROSSBAR_DEFAULT_FLAGS = int;
enum : int
{
    DEF_MODE_PROFILE = 0x00000001,
    DEF_MODE_STREAMS = 0x00000002,
}

///The <b>MPEG_CURRENT_NEXT_BIT</b> enumeration type specifies the value of the current_next_indicator bit.
alias MPEG_CURRENT_NEXT_BIT = int;
enum : int
{
    ///Indicates that the table is current applicable.
    MPEG_SECTION_IS_NEXT    = 0x00000000,
    ///Indicates that the table is not yet applicable, and will be the next valid table.
    MPEG_SECTION_IS_CURRENT = 0x00000001,
}

///The <b>MPEG_CONTEXT_TYPE</b> enumeration type identifies the source of an MPEG-2 data stream.
alias MPEG_CONTEXT_TYPE = int;
enum : int
{
    ///Indicates that the source is a DirectShow filter graph using the MPEG-2 Demultiplexer filter.
    MPEG_CONTEXT_BCS_DEMUX = 0x00000000,
    ///Reserved. Do not use.
    MPEG_CONTEXT_WINSOCK   = 0x00000001,
}

///The <b>MPEG_REQUEST_TYPE</b> enumeration type specifies a request for MPEG-2 data.
alias MPEG_REQUEST_TYPE = int;
enum : int
{
    ///Unknown request type. Do not use this value.
    MPEG_RQST_UNKNOWN             = 0x00000000,
    ///Get one table section. (Synchronous call.)
    MPEG_RQST_GET_SECTION         = 0x00000001,
    ///Get one table section. (Asynchronous call.)
    MPEG_RQST_GET_SECTION_ASYNC   = 0x00000002,
    ///Get a complete table. (Synchronous call.)
    MPEG_RQST_GET_TABLE           = 0x00000003,
    ///Get a complete table. (Asynchronous call.)
    MPEG_RQST_GET_TABLE_ASYNC     = 0x00000004,
    ///Get a stream of sections.
    MPEG_RQST_GET_SECTIONS_STREAM = 0x00000005,
    ///Get a stream of packetized elementary stream (PES) packets.
    MPEG_RQST_GET_PES_STREAM      = 0x00000006,
    ///Get a stream of transport stream (TS) packets.
    MPEG_RQST_GET_TS_STREAM       = 0x00000007,
    ///Get a stream of multi-protocol encapsulation (MPE) packets.
    MPEG_RQST_START_MPE_STREAM    = 0x00000008,
}

alias VA_VIDEO_FORMAT = int;
enum : int
{
    VA_VIDEO_COMPONENT   = 0x00000000,
    VA_VIDEO_PAL         = 0x00000001,
    VA_VIDEO_NTSC        = 0x00000002,
    VA_VIDEO_SECAM       = 0x00000003,
    VA_VIDEO_MAC         = 0x00000004,
    VA_VIDEO_UNSPECIFIED = 0x00000005,
}

alias VA_COLOR_PRIMARIES = int;
enum : int
{
    VA_PRIMARIES_ITU_R_BT_709            = 0x00000001,
    VA_PRIMARIES_UNSPECIFIED             = 0x00000002,
    VA_PRIMARIES_ITU_R_BT_470_SYSTEM_M   = 0x00000004,
    VA_PRIMARIES_ITU_R_BT_470_SYSTEM_B_G = 0x00000005,
    VA_PRIMARIES_SMPTE_170M              = 0x00000006,
    VA_PRIMARIES_SMPTE_240M              = 0x00000007,
    VA_PRIMARIES_H264_GENERIC_FILM       = 0x00000008,
}

alias VA_TRANSFER_CHARACTERISTICS = int;
enum : int
{
    VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_709            = 0x00000001,
    VA_TRANSFER_CHARACTERISTICS_UNSPECIFIED             = 0x00000002,
    VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_470_SYSTEM_M   = 0x00000004,
    VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_470_SYSTEM_B_G = 0x00000005,
    VA_TRANSFER_CHARACTERISTICS_SMPTE_170M              = 0x00000006,
    VA_TRANSFER_CHARACTERISTICS_SMPTE_240M              = 0x00000007,
    VA_TRANSFER_CHARACTERISTICS_LINEAR                  = 0x00000008,
    VA_TRANSFER_CHARACTERISTICS_H264_LOG_100_TO_1       = 0x00000009,
    VA_TRANSFER_CHARACTERISTICS_H264_LOG_316_TO_1       = 0x0000000a,
}

alias VA_MATRIX_COEFFICIENTS = int;
enum : int
{
    VA_MATRIX_COEFF_H264_RGB                = 0x00000000,
    VA_MATRIX_COEFF_ITU_R_BT_709            = 0x00000001,
    VA_MATRIX_COEFF_UNSPECIFIED             = 0x00000002,
    VA_MATRIX_COEFF_FCC                     = 0x00000004,
    VA_MATRIX_COEFF_ITU_R_BT_470_SYSTEM_B_G = 0x00000005,
    VA_MATRIX_COEFF_SMPTE_170M              = 0x00000006,
    VA_MATRIX_COEFF_SMPTE_240M              = 0x00000007,
    VA_MATRIX_COEFF_H264_YCgCo              = 0x00000008,
}

alias __MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 = int;
enum : int
{
    STRCONV_MODE_DVB                  = 0x00000000,
    STRCONV_MODE_DVB_EMPHASIS         = 0x00000001,
    STRCONV_MODE_DVB_WITHOUT_EMPHASIS = 0x00000002,
    STRCONV_MODE_ISDB                 = 0x00000003,
}

alias __MIDL___MIDL_itf_dvbsiparser_0000_0022_0001 = int;
enum : int
{
    CRID_LOCATION_IN_DESCRIPTOR = 0x00000000,
    CRID_LOCATION_IN_CIT        = 0x00000001,
    CRID_LOCATION_DVB_RESERVED1 = 0x00000002,
    CRID_LOCATION_DVB_RESERVED2 = 0x00000003,
}

alias __MIDL___MIDL_itf_dvbsiparser_0000_0036_0001 = int;
enum : int
{
    DESC_LINKAGE_RESERVED0               = 0x00000000,
    DESC_LINKAGE_INFORMATION             = 0x00000001,
    DESC_LINKAGE_EPG                     = 0x00000002,
    DESC_LINKAGE_CA_REPLACEMENT          = 0x00000003,
    DESC_LINKAGE_COMPLETE_NET_BOUQUET_SI = 0x00000004,
    DESC_LINKAGE_REPLACEMENT             = 0x00000005,
    DESC_LINKAGE_DATA                    = 0x00000006,
    DESC_LINKAGE_RESERVED1               = 0x00000007,
    DESC_LINKAGE_USER                    = 0x00000008,
    DESC_LINKAGE_RESERVED2               = 0x000000ff,
}

alias ChannelChangeSpanningEvent_State = int;
enum : int
{
    ChannelChangeSpanningEvent_Start = 0x00000000,
    ChannelChangeSpanningEvent_End   = 0x00000002,
}

enum ChannelType : int
{
    ChannelTypeNone        = 0x00000000,
    ChannelTypeOther       = 0x00000001,
    ChannelTypeVideo       = 0x00000002,
    ChannelTypeAudio       = 0x00000004,
    ChannelTypeText        = 0x00000008,
    ChannelTypeSubtitles   = 0x00000010,
    ChannelTypeCaptions    = 0x00000020,
    ChannelTypeSuperimpose = 0x00000040,
    ChannelTypeData        = 0x00000080,
}

alias SignalAndServiceStatusSpanningEvent_State = int;
enum : int
{
    SignalAndServiceStatusSpanningEvent_None           = 0xffffffff,
    SignalAndServiceStatusSpanningEvent_Clear          = 0x00000000,
    SignalAndServiceStatusSpanningEvent_NoTVSignal     = 0x00000001,
    SignalAndServiceStatusSpanningEvent_ServiceOffAir  = 0x00000002,
    SignalAndServiceStatusSpanningEvent_WeakTVSignal   = 0x00000003,
    SignalAndServiceStatusSpanningEvent_NoSubscription = 0x00000004,
    SignalAndServiceStatusSpanningEvent_AllAVScrambled = 0x00000005,
}

alias KSPROPERTY_BDA_ETHERNET_FILTER = int;
enum : int
{
    KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST_SIZE = 0x00000000,
    KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST      = 0x00000001,
    KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_MODE      = 0x00000002,
}

alias KSPROPERTY_BDA_IPv4_FILTER = int;
enum : int
{
    KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST_SIZE = 0x00000000,
    KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST      = 0x00000001,
    KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_MODE      = 0x00000002,
}

alias KSPROPERTY_BDA_IPv6_FILTER = int;
enum : int
{
    KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST_SIZE = 0x00000000,
    KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST      = 0x00000001,
    KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_MODE      = 0x00000002,
}

alias KSPROPERTY_BDA_SIGNAL_STATS = int;
enum : int
{
    KSPROPERTY_BDA_SIGNAL_STRENGTH  = 0x00000000,
    KSPROPERTY_BDA_SIGNAL_QUALITY   = 0x00000001,
    KSPROPERTY_BDA_SIGNAL_PRESENT   = 0x00000002,
    KSPROPERTY_BDA_SIGNAL_LOCKED    = 0x00000003,
    KSPROPERTY_BDA_SAMPLE_TIME      = 0x00000004,
    KSPROPERTY_BDA_SIGNAL_LOCK_CAPS = 0x00000005,
    KSPROPERTY_BDA_SIGNAL_LOCK_TYPE = 0x00000006,
}

alias _BdaLockType = int;
enum : int
{
    Bda_LockType_None         = 0x00000000,
    Bda_LockType_PLL          = 0x00000001,
    Bda_LockType_DecoderDemod = 0x00000002,
    Bda_LockType_Complete     = 0x00000080,
}

alias KSMETHOD_BDA_CHANGE_SYNC = int;
enum : int
{
    KSMETHOD_BDA_START_CHANGES    = 0x00000000,
    KSMETHOD_BDA_CHECK_CHANGES    = 0x00000001,
    KSMETHOD_BDA_COMMIT_CHANGES   = 0x00000002,
    KSMETHOD_BDA_GET_CHANGE_STATE = 0x00000003,
}

alias KSMETHOD_BDA_DEVICE_CONFIGURATION = int;
enum : int
{
    KSMETHOD_BDA_CREATE_PIN_FACTORY = 0x00000000,
    KSMETHOD_BDA_DELETE_PIN_FACTORY = 0x00000001,
    KSMETHOD_BDA_CREATE_TOPOLOGY    = 0x00000002,
}

alias KSPROPERTY_BDA_TOPOLOGY = int;
enum : int
{
    KSPROPERTY_BDA_NODE_TYPES           = 0x00000000,
    KSPROPERTY_BDA_PIN_TYPES            = 0x00000001,
    KSPROPERTY_BDA_TEMPLATE_CONNECTIONS = 0x00000002,
    KSPROPERTY_BDA_NODE_METHODS         = 0x00000003,
    KSPROPERTY_BDA_NODE_PROPERTIES      = 0x00000004,
    KSPROPERTY_BDA_NODE_EVENTS          = 0x00000005,
    KSPROPERTY_BDA_CONTROLLING_PIN_ID   = 0x00000006,
    KSPROPERTY_BDA_NODE_DESCRIPTORS     = 0x00000007,
}

alias KSPROPERTY_BDA_PIN_CONTROL = int;
enum : int
{
    KSPROPERTY_BDA_PIN_ID   = 0x00000000,
    KSPROPERTY_BDA_PIN_TYPE = 0x00000001,
}

alias KSPROPERTY_BDA_PIN_EVENT = int;
enum : int
{
    KSEVENT_BDA_PIN_CONNECTED    = 0x00000000,
    KSEVENT_BDA_PIN_DISCONNECTED = 0x00000001,
}

alias KSPROPERTY_BDA_VOID_TRANSFORM = int;
enum : int
{
    KSPROPERTY_BDA_VOID_TRANSFORM_START = 0x00000000,
    KSPROPERTY_BDA_VOID_TRANSFORM_STOP  = 0x00000001,
}

alias KSPROPERTY_BDA_NULL_TRANSFORM = int;
enum : int
{
    KSPROPERTY_BDA_NULL_TRANSFORM_START = 0x00000000,
    KSPROPERTY_BDA_NULL_TRANSFORM_STOP  = 0x00000001,
}

alias KSPROPERTY_BDA_FREQUENCY_FILTER = int;
enum : int
{
    KSPROPERTY_BDA_RF_TUNER_FREQUENCY            = 0x00000000,
    KSPROPERTY_BDA_RF_TUNER_POLARITY             = 0x00000001,
    KSPROPERTY_BDA_RF_TUNER_RANGE                = 0x00000002,
    KSPROPERTY_BDA_RF_TUNER_TRANSPONDER          = 0x00000003,
    KSPROPERTY_BDA_RF_TUNER_BANDWIDTH            = 0x00000004,
    KSPROPERTY_BDA_RF_TUNER_FREQUENCY_MULTIPLIER = 0x00000005,
    KSPROPERTY_BDA_RF_TUNER_CAPS                 = 0x00000006,
    KSPROPERTY_BDA_RF_TUNER_SCAN_STATUS          = 0x00000007,
    KSPROPERTY_BDA_RF_TUNER_STANDARD             = 0x00000008,
    KSPROPERTY_BDA_RF_TUNER_STANDARD_MODE        = 0x00000009,
}

alias _BdaSignalType = int;
enum : int
{
    Bda_SignalType_Unknown = 0x00000000,
    Bda_SignalType_Analog  = 0x00000001,
    Bda_SignalType_Digital = 0x00000002,
}

alias BDA_DigitalSignalStandard = int;
enum : int
{
    Bda_DigitalStandard_None   = 0x00000000,
    Bda_DigitalStandard_DVB_T  = 0x00000001,
    Bda_DigitalStandard_DVB_S  = 0x00000002,
    Bda_DigitalStandard_DVB_C  = 0x00000004,
    Bda_DigitalStandard_ATSC   = 0x00000008,
    Bda_DigitalStandard_ISDB_T = 0x00000010,
    Bda_DigitalStandard_ISDB_S = 0x00000020,
    Bda_DigitalStandard_ISDB_C = 0x00000040,
}

alias KSEVENT_BDA_TUNER = int;
enum : int
{
    KSEVENT_BDA_TUNER_SCAN = 0x00000000,
}

alias KSPROPERTY_BDA_LNB_INFO = int;
enum : int
{
    KSPROPERTY_BDA_LNB_LOF_LOW_BAND     = 0x00000000,
    KSPROPERTY_BDA_LNB_LOF_HIGH_BAND    = 0x00000001,
    KSPROPERTY_BDA_LNB_SWITCH_FREQUENCY = 0x00000002,
}

alias KSPROPERTY_BDA_DISEQC_COMMAND = int;
enum : int
{
    KSPROPERTY_BDA_DISEQC_ENABLE       = 0x00000000,
    KSPROPERTY_BDA_DISEQC_LNB_SOURCE   = 0x00000001,
    KSPROPERTY_BDA_DISEQC_USETONEBURST = 0x00000002,
    KSPROPERTY_BDA_DISEQC_REPEATS      = 0x00000003,
    KSPROPERTY_BDA_DISEQC_SEND         = 0x00000004,
    KSPROPERTY_BDA_DISEQC_RESPONSE     = 0x00000005,
}

alias KSPROPERTY_BDA_DISEQC_EVENT = int;
enum : int
{
    KSEVENT_BDA_DISEQC_DATA_RECEIVED = 0x00000000,
}

alias KSPROPERTY_BDA_DIGITAL_DEMODULATOR = int;
enum : int
{
    KSPROPERTY_BDA_MODULATION_TYPE    = 0x00000000,
    KSPROPERTY_BDA_INNER_FEC_TYPE     = 0x00000001,
    KSPROPERTY_BDA_INNER_FEC_RATE     = 0x00000002,
    KSPROPERTY_BDA_OUTER_FEC_TYPE     = 0x00000003,
    KSPROPERTY_BDA_OUTER_FEC_RATE     = 0x00000004,
    KSPROPERTY_BDA_SYMBOL_RATE        = 0x00000005,
    KSPROPERTY_BDA_SPECTRAL_INVERSION = 0x00000006,
    KSPROPERTY_BDA_GUARD_INTERVAL     = 0x00000007,
    KSPROPERTY_BDA_TRANSMISSION_MODE  = 0x00000008,
    KSPROPERTY_BDA_ROLL_OFF           = 0x00000009,
    KSPROPERTY_BDA_PILOT              = 0x0000000a,
    KSPROPERTY_BDA_SIGNALTIMEOUTS     = 0x0000000b,
    KSPROPERTY_BDA_PLP_NUMBER         = 0x0000000c,
}

alias KSPROPERTY_BDA_AUTODEMODULATE = int;
enum : int
{
    KSPROPERTY_BDA_AUTODEMODULATE_START = 0x00000000,
    KSPROPERTY_BDA_AUTODEMODULATE_STOP  = 0x00000001,
}

alias KSPROPERTY_IDS_BDA_TABLE = int;
enum : int
{
    KSPROPERTY_BDA_TABLE_SECTION = 0x00000000,
}

alias KSPROPERTY_BDA_PIDFILTER = int;
enum : int
{
    KSPROPERTY_BDA_PIDFILTER_MAP_PIDS   = 0x00000000,
    KSPROPERTY_BDA_PIDFILTER_UNMAP_PIDS = 0x00000001,
    KSPROPERTY_BDA_PIDFILTER_LIST_PIDS  = 0x00000002,
}

alias KSPROPERTY_BDA_CA = int;
enum : int
{
    KSPROPERTY_BDA_ECM_MAP_STATUS       = 0x00000000,
    KSPROPERTY_BDA_CA_MODULE_STATUS     = 0x00000001,
    KSPROPERTY_BDA_CA_SMART_CARD_STATUS = 0x00000002,
    KSPROPERTY_BDA_CA_MODULE_UI         = 0x00000003,
    KSPROPERTY_BDA_CA_SET_PROGRAM_PIDS  = 0x00000004,
    KSPROPERTY_BDA_CA_REMOVE_PROGRAM    = 0x00000005,
}

alias KSPROPERTY_BDA_CA_EVENT = int;
enum : int
{
    KSEVENT_BDA_PROGRAM_FLOW_STATUS_CHANGED  = 0x00000000,
    KSEVENT_BDA_CA_MODULE_STATUS_CHANGED     = 0x00000001,
    KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED = 0x00000002,
    KSEVENT_BDA_CA_MODULE_UI_REQUESTED       = 0x00000003,
}

alias KSMETHOD_BDA_DRM = int;
enum : int
{
    KSMETHOD_BDA_DRM_CURRENT   = 0x00000000,
    KSMETHOD_BDA_DRM_DRMSTATUS = 0x00000001,
}

alias KSMETHOD_BDA_WMDRM = int;
enum : int
{
    KSMETHOD_BDA_WMDRM_STATUS         = 0x00000000,
    KSMETHOD_BDA_WMDRM_REVINFO        = 0x00000001,
    KSMETHOD_BDA_WMDRM_CRL            = 0x00000002,
    KSMETHOD_BDA_WMDRM_MESSAGE        = 0x00000003,
    KSMETHOD_BDA_WMDRM_REISSUELICENSE = 0x00000004,
    KSMETHOD_BDA_WMDRM_RENEWLICENSE   = 0x00000005,
    KSMETHOD_BDA_WMDRM_LICENSE        = 0x00000006,
    KSMETHOD_BDA_WMDRM_KEYINFO        = 0x00000007,
}

alias KSMETHOD_BDA_WMDRM_TUNER = int;
enum : int
{
    KSMETHOD_BDA_WMDRMTUNER_CANCELCAPTURETOKEN   = 0x00000000,
    KSMETHOD_BDA_WMDRMTUNER_SETPIDPROTECTION     = 0x00000001,
    KSMETHOD_BDA_WMDRMTUNER_GETPIDPROTECTION     = 0x00000002,
    KSMETHOD_BDA_WMDRMTUNER_SETSYNCVALUE         = 0x00000003,
    KSMETHOD_BDA_WMDRMTUNER_STARTCODEPROFILE     = 0x00000004,
    KSMETHOD_BDA_WMDRMTUNER_PURCHASE_ENTITLEMENT = 0x00000005,
}

alias KSMETHOD_BDA_EVENTING_SERVICE = int;
enum : int
{
    KSMETHOD_BDA_EVENT_DATA     = 0x00000000,
    KSMETHOD_BDA_EVENT_COMPLETE = 0x00000001,
}

alias KSEVENT_BDA_EVENT_TYPE = int;
enum : int
{
    KSEVENT_BDA_EVENT_PENDINGEVENT = 0x00000000,
}

alias KSMETHOD_BDA_DEBUG_SERVICE = int;
enum : int
{
    KSMETHOD_BDA_DEBUG_LEVEL = 0x00000000,
    KSMETHOD_BDA_DEBUG_DATA  = 0x00000001,
}

alias KSMETHOD_BDA_TUNER_SERVICE = int;
enum : int
{
    KSMETHOD_BDA_TUNER_SETTUNER         = 0x00000000,
    KSMETHOD_BDA_TUNER_GETTUNERSTATE    = 0x00000001,
    KSMETHOD_BDA_TUNER_SIGNALNOISERATIO = 0x00000002,
}

alias KSMETHOD_BDA_GPNV_SERVICE = int;
enum : int
{
    KSMETHOD_BDA_GPNV_GETVALUE           = 0x00000000,
    KSMETHOD_BDA_GPNV_SETVALUE           = 0x00000001,
    KSMETHOD_BDA_GPNV_NAMEFROMINDEX      = 0x00000002,
    KSMETHOD_BDA_GPNV_GETVALUEUPDATENAME = 0x00000003,
}

alias KSMETHOD_BDA_MUX_SERVICE = int;
enum : int
{
    KSMETHOD_BDA_MUX_GETPIDLIST = 0x00000000,
    KSMETHOD_BDA_MUX_SETPIDLIST = 0x00000001,
}

alias KSMETHOD_BDA_SCAN_SERVICE = int;
enum : int
{
    KSMETHOD_BDA_SCAN_CAPABILTIES = 0x00000000,
    KSMETHOD_BDA_SCANNING_STATE   = 0x00000001,
    KSMETHOD_BDA_SCAN_FILTER      = 0x00000002,
    KSMETHOD_BDA_SCAN_START       = 0x00000003,
    KSMETHOD_BDA_SCAN_RESUME      = 0x00000004,
    KSMETHOD_BDA_SCAN_STOP        = 0x00000005,
}

alias KSMETHOD_BDA_GDDS_SERVICE = int;
enum : int
{
    KSMETHOD_BDA_GDDS_DATATYPE           = 0x00000000,
    KSMETHOD_BDA_GDDS_DATA               = 0x00000001,
    KSMETHOD_BDA_GDDS_TUNEXMLFROMIDX     = 0x00000002,
    KSMETHOD_BDA_GDDS_GETSERVICES        = 0x00000003,
    KSMETHOD_BDA_GDDS_SERVICEFROMTUNEXML = 0x00000004,
    KSMETHOD_BDA_GDDS_DATAUPDATE         = 0x00000005,
}

alias KSMETHOD_BDA_CAS_SERVICE = int;
enum : int
{
    KSMETHOD_BDA_CAS_CHECKENTITLEMENTTOKEN = 0x00000000,
    KSMETHOD_BDA_CAS_SETCAPTURETOKEN       = 0x00000001,
    KSMETHOD_BDA_CAS_OPENBROADCASTMMI      = 0x00000002,
    KSMETHOD_BDA_CAS_CLOSEMMIDIALOG        = 0x00000003,
}

alias KSMETHOD_BDA_ISDB_CAS = int;
enum : int
{
    KSMETHOD_BDA_ISDBCAS_SETREQUEST   = 0x00000000,
    KSMETHOD_BDA_ISDBCAS_RESPONSEDATA = 0x00000001,
}

alias KSMETHOD_BDA_TS_SELECTOR = int;
enum : int
{
    KSMETHOD_BDA_TS_SELECTOR_SETTSID          = 0x00000000,
    KSMETHOD_BDA_TS_SELECTOR_GETTSINFORMATION = 0x00000001,
}

alias KSMETHOD_BDA_USERACTIVITY_SERVICE = int;
enum : int
{
    KSMETHOD_BDA_USERACTIVITY_USEREASON = 0x00000000,
    KSMETHOD_BDA_USERACTIVITY_INTERVAL  = 0x00000001,
    KSMETHOD_BDA_USERACTIVITY_DETECTED  = 0x00000002,
}

///Specifies the HDCP protection level.
alias COPP_HDCP_Protection_Level = int;
enum : int
{
    ///HDCP protection is not enabled. See Remarks.
    COPP_HDCP_Level0     = 0x00000000,
    ///Minimum HDCP level. Equivalent to <b>COPP_HDCP_Level0</b>.
    COPP_HDCP_LevelMin   = 0x00000000,
    ///HDCP is enabled.
    COPP_HDCP_Level1     = 0x00000001,
    ///Maximum HDCP level. Equivalent to <b>COPP_HDCP_Level1</b>.
    COPP_HDCP_LevelMax   = 0x00000001,
    ///Reserved.
    COPP_HDCP_ForceDWORD = 0x7fffffff,
}

///Specifies the CGMS-A protection level.
alias COPP_CGMSA_Protection_Level = int;
enum : int
{
    ///CGMS-A is disabled.
    COPP_CGMSA_Disabled                      = 0x00000000,
    ///Minimum CGMS-A level. Equivalent to <b>COPP_CGMSA_Disabled</b>.
    COPP_CGMSA_LevelMin                      = 0x00000000,
    ///The protection level is Copy Freely.
    COPP_CGMSA_CopyFreely                    = 0x00000001,
    ///The protection level is Copy No More.
    COPP_CGMSA_CopyNoMore                    = 0x00000002,
    ///The protection level is Copy One Generation.
    COPP_CGMSA_CopyOneGeneration             = 0x00000003,
    ///The protection level is Copy Never.
    COPP_CGMSA_CopyNever                     = 0x00000004,
    ///Redistribution control (or <i>broadcast flag</i>) is required. This flag can be combined with the other flags.
    COPP_CGMSA_RedistributionControlRequired = 0x00000008,
    ///Maximum CGMS-A level.
    COPP_CGMSA_LevelMax                      = 0x0000000c,
    ///Reserved.
    COPP_CGMSA_ForceDWORD                    = 0x7fffffff,
}

///Specifies the ACP protection level.
alias COPP_ACP_Protection_Level = int;
enum : int
{
    ///Level 0.
    COPP_ACP_Level0     = 0x00000000,
    ///Minimum ACP level. Equivalent to <b>COPP_ACP_Level0</b>.
    COPP_ACP_LevelMin   = 0x00000000,
    ///Level 1.
    COPP_ACP_Level1     = 0x00000001,
    ///Level 2.
    COPP_ACP_Level2     = 0x00000002,
    ///Level 3.
    COPP_ACP_Level3     = 0x00000003,
    ///Maximum ACP level. Equivalent to <b>COPP_ACP_Level3</b>.
    COPP_ACP_LevelMax   = 0x00000003,
    ///Reserved.
    COPP_ACP_ForceDWORD = 0x7fffffff,
}

///Defines a list of TV protection standards for Certified Output Protection Protocol (COPP).
alias COPP_TVProtectionStandard = int;
enum : int
{
    ///None.
    COPP_ProtectionStandard_Unknown             = 0x80000000,
    ///Unknown.
    COPP_ProtectionStandard_None                = 0x00000000,
    ///IEC 61880, 525i.
    COPP_ProtectionStandard_IEC61880_525i       = 0x00000001,
    ///IEC 61880-2, 525i.
    COPP_ProtectionStandard_IEC61880_2_525i     = 0x00000002,
    ///IEC 62375, 625p.
    COPP_ProtectionStandard_IEC62375_625p       = 0x00000004,
    ///EIA/CEA-608-B, 525i.
    COPP_ProtectionStandard_EIA608B_525         = 0x00000008,
    ///ETSI EN 300 294, 625i.
    COPP_ProtectionStandard_EN300294_625i       = 0x00000010,
    ///CEA-805-A Type A, 525p.
    COPP_ProtectionStandard_CEA805A_TypeA_525p  = 0x00000020,
    ///CEA-805-A Type A, 750p.
    COPP_ProtectionStandard_CEA805A_TypeA_750p  = 0x00000040,
    ///CEA-805-A Type A, 1125i.
    COPP_ProtectionStandard_CEA805A_TypeA_1125i = 0x00000080,
    ///CEA-805-A Type B, 525p.
    COPP_ProtectionStandard_CEA805A_TypeB_525p  = 0x00000100,
    ///CEA-805-A Type B, 750p.
    COPP_ProtectionStandard_CEA805A_TypeB_750p  = 0x00000200,
    ///CEA-805-A Type B, 1125i.
    COPP_ProtectionStandard_CEA805A_TypeB_1125i = 0x00000400,
    ///ARIB TR-B15, 525i.
    COPP_ProtectionStandard_ARIBTRB15_525i      = 0x00000800,
    ///ARIB TR-B15, 525p.
    COPP_ProtectionStandard_ARIBTRB15_525p      = 0x00001000,
    ///ARIB TR-B15, 750p.
    COPP_ProtectionStandard_ARIBTRB15_750p      = 0x00002000,
    ///ARIB TR-B15, 1125i.
    COPP_ProtectionStandard_ARIBTRB15_1125i     = 0x00004000,
    ///Reserved.
    COPP_ProtectionStandard_Mask                = 0x80007fff,
    ///Reserved.
    COPP_ProtectionStandard_Reserved            = 0x7fff8000,
}

///Specifies the aspect ratio for EN 300 294.
alias COPP_ImageAspectRatio_EN300294 = int;
enum : int
{
    ///Full format 4:3.
    COPP_AspectRatio_EN300294_FullFormat4by3                = 0x00000000,
    ///Box 14:9 center.
    COPP_AspectRatio_EN300294_Box14by9Center                = 0x00000001,
    ///Box 14:9 top.
    COPP_AspectRatio_EN300294_Box14by9Top                   = 0x00000002,
    ///Box 16:9 center.
    COPP_AspectRatio_EN300294_Box16by9Center                = 0x00000003,
    ///Box 16:9 top.
    COPP_AspectRatio_EN300294_Box16by9Top                   = 0x00000004,
    ///Box &gt; 16:9 center.
    COPP_AspectRatio_EN300294_BoxGT16by9Center              = 0x00000005,
    ///Full format 4:3 (shoot and protect 14:9 center).
    COPP_AspectRatio_EN300294_FullFormat4by3ProtectedCenter = 0x00000006,
    ///Full format 16:9 (anamorphic)
    COPP_AspectRatio_EN300294_FullFormat16by9Anamorphic     = 0x00000007,
    COPP_AspectRatio_ForceDWORD                             = 0x7fffffff,
}

///Specifies the status of a Certified Output Protection Protocol (COPP) session.
alias COPP_StatusFlags = int;
enum : int
{
    ///Normal status.
    COPP_StatusNormal          = 0x00000000,
    ///The integrity of the connection has been compromised. Examples of events that cause the driver to set this flag
    ///include: <ul> <li>The driver can no longer enforce the current protection level.</li> <li>The driver detected an
    ///internal integrity error.</li> <li>The connector between the computer and the display device was unplugged.</li>
    ///</ul>
    COPP_LinkLost              = 0x00000001,
    ///The connection configuration has changed. For example, the user has changed the desktop display mode.
    COPP_RenegotiationRequired = 0x00000002,
    ///Reserved. Must be zero.
    COPP_StatusFlagsReserved   = 0xfffffffc,
}

///Contains HDCP status flags. This enumeration is used in the DXVA_COPPStatusHDCPKeyData structure.
alias COPP_StatusHDCPFlags = int;
enum : int
{
    ///The device is an HDCP repeater.
    COPP_HDCPRepeater      = 0x00000001,
    ///Reserved. Must be zero.
    COPP_HDCPFlagsReserved = 0xfffffffe,
}

///Specifies the type of physical connector.
alias COPP_ConnectorType = int;
enum : int
{
    ///Unknown connector type.
    COPP_ConnectorType_Unknown        = 0xffffffff,
    ///VGA (Video Graphics Array) connector.
    COPP_ConnectorType_VGA            = 0x00000000,
    ///S-Video connector.
    COPP_ConnectorType_SVideo         = 0x00000001,
    ///Composite video connector.
    COPP_ConnectorType_CompositeVideo = 0x00000002,
    ///Component video connector.
    COPP_ConnectorType_ComponentVideo = 0x00000003,
    ///DVI (digital video interface) connector.
    COPP_ConnectorType_DVI            = 0x00000004,
    ///HDMI (high-definition multimedia interface) connector.
    COPP_ConnectorType_HDMI           = 0x00000005,
    ///LVDS (Low voltage differential signaling) connector.
    COPP_ConnectorType_LVDS           = 0x00000006,
    ///Reserved.
    COPP_ConnectorType_TMDS           = 0x00000007,
    ///Japanese D connector. (Connector conforming to the EIAJ RC-5237 standard.)
    COPP_ConnectorType_D_JPN          = 0x00000008,
    ///Internal connector. This flag can be combined with the other flags. This flag indicates that the connection
    ///between the graphics adapter and the display device is permanent and not accessible to the user.
    COPP_ConnectorType_Internal       = 0x80000000,
    ///Reserved. Do not use.
    COPP_ConnectorType_ForceDWORD     = 0x7fffffff,
}

///Specifies the type of I/O bus used by the graphics adapter.
alias COPP_BusType = int;
enum : int
{
    ///Unknown bus type.
    COPP_BusType_Unknown    = 0x00000000,
    ///PCI bus.
    COPP_BusType_PCI        = 0x00000001,
    ///PCI-X bus.
    COPP_BusType_PCIX       = 0x00000002,
    ///PCI Express bus.
    COPP_BusType_PCIExpress = 0x00000003,
    ///AGP bus.
    COPP_BusType_AGP        = 0x00000004,
    ///Integrated bus. This flag can be combined with the other flags. This flag indicates that the command and status
    ///signals between the graphics adapter and other subsystems on the computer are not available on an expansion bus
    ///that has a public specification and standard connector type, unless it is a memory bus.
    COPP_BusType_Integrated = 0x80000000,
    ///Reserved.
    COPP_BusType_ForceDWORD = 0x7fffffff,
}

// Constants


enum const(wchar)* g_wszExcludeScriptStreamDeliverySynchronization = "ExcludeScriptStreamDeliverySynchronization";

enum : const(wchar)*
{
    g_wszStreamBufferRecordingBitrate                = "Bitrate",
    g_wszStreamBufferRecordingSeekable               = "Seekable",
    g_wszStreamBufferRecordingStridable              = "Stridable",
    g_wszStreamBufferRecordingBroadcast              = "Broadcast",
    g_wszStreamBufferRecordingProtected              = "Is_Protected",
    g_wszStreamBufferRecordingTrusted                = "Is_Trusted",
    g_wszStreamBufferRecordingSignature_Name         = "Signature_Name",
    g_wszStreamBufferRecordingHasAudio               = "HasAudio",
    g_wszStreamBufferRecordingHasImage               = "HasImage",
    g_wszStreamBufferRecordingHasScript              = "HasScript",
    g_wszStreamBufferRecordingHasVideo               = "HasVideo",
    g_wszStreamBufferRecordingCurrentBitrate         = "CurrentBitrate",
    g_wszStreamBufferRecordingOptimalBitrate         = "OptimalBitrate",
    g_wszStreamBufferRecordingHasAttachedImages      = "HasAttachedImages",
    g_wszStreamBufferRecordingSkipBackward           = "Can_Skip_Backward",
    g_wszStreamBufferRecordingSkipForward            = "Can_Skip_Forward",
    g_wszStreamBufferRecordingNumberOfFrames         = "NumberOfFrames",
    g_wszStreamBufferRecordingFileSize               = "FileSize",
    g_wszStreamBufferRecordingHasArbitraryDataStream = "HasArbitraryDataStream",
    g_wszStreamBufferRecordingHasFileTransferStream  = "HasFileTransferStream",
    g_wszStreamBufferRecordingTitle                  = "Title",
    g_wszStreamBufferRecordingAuthor                 = "Author",
    g_wszStreamBufferRecordingDescription            = "Description",
    g_wszStreamBufferRecordingRating                 = "Rating",
    g_wszStreamBufferRecordingCopyright              = "Copyright",
    g_wszStreamBufferRecordingUse_DRM                = "Use_DRM",
    g_wszStreamBufferRecordingDRM_Flags              = "DRM_Flags",
    g_wszStreamBufferRecordingDRM_Level              = "DRM_Level",
    g_wszStreamBufferRecordingAlbumTitle             = "WM/AlbumTitle",
    g_wszStreamBufferRecordingTrack                  = "WM/Track",
    g_wszStreamBufferRecordingPromotionURL           = "WM/PromotionURL",
    g_wszStreamBufferRecordingAlbumCoverURL          = "WM/AlbumCoverURL",
    g_wszStreamBufferRecordingGenre                  = "WM/Genre",
    g_wszStreamBufferRecordingYear                   = "WM/Year",
    g_wszStreamBufferRecordingGenreID                = "WM/GenreID",
    g_wszStreamBufferRecordingMCDI                   = "WM/MCDI",
    g_wszStreamBufferRecordingComposer               = "WM/Composer",
    g_wszStreamBufferRecordingLyrics                 = "WM/Lyrics",
    g_wszStreamBufferRecordingTrackNumber            = "WM/TrackNumber",
    g_wszStreamBufferRecordingToolName               = "WM/ToolName",
    g_wszStreamBufferRecordingToolVersion            = "WM/ToolVersion",
    g_wszStreamBufferRecordingIsVBR                  = "IsVBR",
    g_wszStreamBufferRecordingAlbumArtist            = "WM/AlbumArtist",
    g_wszStreamBufferRecordingBannerImageType        = "BannerImageType",
    g_wszStreamBufferRecordingBannerImageData        = "BannerImageData",
    g_wszStreamBufferRecordingBannerImageURL         = "BannerImageURL",
    g_wszStreamBufferRecordingCopyrightURL           = "CopyrightURL",
    g_wszStreamBufferRecordingAspectRatioX           = "AspectRatioX",
    g_wszStreamBufferRecordingAspectRatioY           = "AspectRatioY",
    g_wszStreamBufferRecordingNSCName                = "NSC_Name",
    g_wszStreamBufferRecordingNSCAddress             = "NSC_Address",
    g_wszStreamBufferRecordingNSCPhone               = "NSC_Phone",
    g_wszStreamBufferRecordingNSCEmail               = "NSC_Email",
    g_wszStreamBufferRecordingNSCDescription         = "NSC_Description",
}

enum : int
{
    STREAMBUFFER_EC_STALE_DATA_READ                = 0x00000327,
    STREAMBUFFER_EC_STALE_FILE_DELETED             = 0x00000328,
    STREAMBUFFER_EC_CONTENT_BECOMING_STALE         = 0x00000329,
    STREAMBUFFER_EC_WRITE_FAILURE                  = 0x0000032a,
    STREAMBUFFER_EC_WRITE_FAILURE_CLEAR            = 0x0000032b,
    STREAMBUFFER_EC_READ_FAILURE                   = 0x0000032c,
    STREAMBUFFER_EC_RATE_CHANGED                   = 0x0000032d,
    STREAMBUFFER_EC_PRIMARY_AUDIO                  = 0x0000032e,
    STREAMBUFFER_EC_RATE_CHANGING_FOR_SETPOSITIONS = 0x0000032f,
}

// Callbacks

alias AMGETERRORTEXTPROCA = BOOL function(HRESULT param0, byte* param1, uint param2);
alias AMGETERRORTEXTPROCW = BOOL function(HRESULT param0, ushort* param1, uint param2);
alias AMGETERRORTEXTPROC = BOOL function();

// Structs


///The <b>BITMAPINFOHEADER</b> structure contains information about the dimensions and color format of a
///device-independent bitmap (DIB). <div class="alert"><b>Note</b> This structure is also described in the GDI
///documentation. However, the semantics for video data are slightly different than the semantics used for GDI. If you
///are using this structure to describe video data, use the information given here.</div><div> </div>
struct BITMAPINFOHEADER
{
    ///Specifies the number of bytes required by the structure. This value does not include the size of the color table
    ///or the size of the color masks, if they are appended to the end of structure. See Remarks.
    uint   biSize;
    ///Specifies the width of the bitmap, in pixels. For information about calculating the stride of the bitmap, see
    ///Remarks.
    int    biWidth;
    ///Specifies the height of the bitmap, in pixels. <ul> <li>For uncompressed RGB bitmaps, if <b>biHeight</b> is
    ///positive, the bitmap is a bottom-up DIB with the origin at the lower left corner. If <b>biHeight</b> is negative,
    ///the bitmap is a top-down DIB with the origin at the upper left corner.</li> <li>For YUV bitmaps, the bitmap is
    ///always top-down, regardless of the sign of <b>biHeight</b>. Decoders should offer YUV formats with postive
    ///<b>biHeight</b>, but for backward compatibility they should accept YUV formats with either positive or negative
    ///<b>biHeight</b>.</li> <li>For compressed formats, <b>biHeight</b> must be positive, regardless of image
    ///orientation.</li> </ul>
    int    biHeight;
    ///Specifies the number of planes for the target device. This value must be set to 1.
    ushort biPlanes;
    ///Specifies the number of bits per pixel (bpp). For uncompressed formats, this value is the average number of bits
    ///per pixel. For compressed formats, this value is the implied bit depth of the uncompressed image, after the image
    ///has been decoded.
    ushort biBitCount;
    ///For compressed video and YUV formats, this member is a FOURCC code, specified as a <b>DWORD</b> in little-endian
    ///order. For example, YUYV video has the FOURCC 'VYUY' or 0x56595559. For more information, see FOURCC Codes. For
    ///uncompressed RGB formats, the following values are possible: <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="BI_RGB"></a><a id="bi_rgb"></a><dl> <dt><b>BI_RGB</b></dt> </dl> </td> <td
    ///width="60%"> Uncompressed RGB. </td> </tr> <tr> <td width="40%"><a id="BI_BITFIELDS"></a><a
    ///id="bi_bitfields"></a><dl> <dt><b>BI_BITFIELDS</b></dt> </dl> </td> <td width="60%"> Uncompressed RGB with color
    ///masks. Valid for 16-bpp and 32-bpp bitmaps. </td> </tr> </table> See Remarks for more information. Note that
    ///<b>BI_JPG</b> and <b>BI_PNG</b> are not valid video formats. For 16-bpp bitmaps, if <b>biCompression</b> equals
    ///<b>BI_RGB</b>, the format is always RGB 555. If <b>biCompression</b> equals <b>BI_BITFIELDS</b>, the format is
    ///either RGB 555 or RGB 565. Use the subtype GUID in the AM_MEDIA_TYPE structure to determine the specific RGB
    ///type.
    uint   biCompression;
    ///Specifies the size, in bytes, of the image. This can be set to 0 for uncompressed RGB bitmaps.
    uint   biSizeImage;
    ///Specifies the horizontal resolution, in pixels per meter, of the target device for the bitmap.
    int    biXPelsPerMeter;
    ///Specifies the vertical resolution, in pixels per meter, of the target device for the bitmap.
    int    biYPelsPerMeter;
    ///Specifies the number of color indices in the color table that are actually used by the bitmap. See Remarks for
    ///more information.
    uint   biClrUsed;
    ///Specifies the number of color indices that are considered important for displaying the bitmap. If this value is
    ///zero, all colors are important.
    uint   biClrImportant;
}

///The <b>AMVPSIZE</b> structure specifies the width and height for a VP image.
struct AMVPSIZE
{
    ///Width, in pixels.
    uint dwWidth;
    ///Height.
    uint dwHeight;
}

///The <b>AMVPDIMINFO</b> structure specifies the dimensional characteristics of a video port (VP) input stream.
struct AMVPDIMINFO
{
    ///Field width of the data.
    uint dwFieldWidth;
    ///Field height of the data.
    uint dwFieldHeight;
    ///Width of the VBI data.
    uint dwVBIWidth;
    ///Height of the VBI data.
    uint dwVBIHeight;
    ///Valid rectangle, used for cropping.
    RECT rcValidRegion;
}

///The <b>AMVPDATAINFO</b> structure specifies the data-specific characteristics of the VP input stream.
struct AMVPDATAINFO
{
    ///Size of the structure, in bytes.
    uint        dwSize;
    ///Time taken by each field.
    uint        dwMicrosecondsPerField;
    ///Dimensional information.
    AMVPDIMINFO amvpDimInfo;
    ///The X dimension of picture aspect ratio.
    uint        dwPictAspectRatioX;
    ///The Y dimension of picture aspect ratio.
    uint        dwPictAspectRatioY;
    ///Video port should enable double clocking.
    BOOL        bEnableDoubleClock;
    ///Video port should use an external VACT signal.
    BOOL        bEnableVACT;
    ///Indicates that the signal is interlaced.
    BOOL        bDataIsInterlaced;
    ///Number of half lines in the odd field.
    int         lHalfLinesOdd;
    ///Video port should invert the field polarity.
    BOOL        bFieldPolarityInverted;
    ///Number of lines of data in VREF.
    uint        dwNumLinesInVREF;
    ///Number of half lines in the even field.
    int         lHalfLinesEven;
    ///Reserved for future use.
    uint        dwReserved1;
}

///The <b>AM_MEDIA_TYPE</b> structure describes the format of a media sample.
struct AM_MEDIA_TYPE
{
    ///Globally unique identifier (GUID) that specifies the major type of the media sample. For a list of possible major
    ///types, see Media Types.
    GUID     majortype;
    ///GUID that specifies the subtype of the media sample. For a list of possible subtypes, see Media Types. For some
    ///formats, the value might be MEDIASUBTYPE_None, which means the format does not require a subtype.
    GUID     subtype;
    ///If <b>TRUE</b>, samples are of a fixed size. This field is informational only. For audio, it is generally set to
    ///<b>TRUE</b>. For video, it is usually <b>TRUE</b> for uncompressed video and <b>FALSE</b> for compressed video.
    BOOL     bFixedSizeSamples;
    ///If <b>TRUE</b>, samples are compressed using temporal (interframe) compression. A value of <b>TRUE</b> indicates
    ///that not all frames are key frames. This field is informational only.
    BOOL     bTemporalCompression;
    ///Size of the sample in bytes. For compressed data, the value can be zero.
    uint     lSampleSize;
    ///GUID that specifies the structure used for the format block. The <b>pbFormat</b> member points to the
    ///corresponding format structure. Format types include the following: <table> <tr> <th>Format type</th> <th>Format
    ///structure</th> </tr> <tr> <td width="40%"><a id="FORMAT_DvInfo"></a><a id="format_dvinfo"></a><a
    ///id="FORMAT_DVINFO"></a><dl> <dt><b>FORMAT_DvInfo</b></dt> </dl> </td> <td width="60%"> DVINFO </td> </tr> <tr>
    ///<td width="40%"><a id="FORMAT_MPEG2Video"></a><a id="format_mpeg2video"></a><a id="FORMAT_MPEG2VIDEO"></a><dl>
    ///<dt><b>FORMAT_MPEG2Video</b></dt> </dl> </td> <td width="60%"> MPEG2VIDEOINFO </td> </tr> <tr> <td width="40%"><a
    ///id="FORMAT_MPEGStreams"></a><a id="format_mpegstreams"></a><a id="FORMAT_MPEGSTREAMS"></a><dl>
    ///<dt><b>FORMAT_MPEGStreams</b></dt> </dl> </td> <td width="60%"> AM_MPEGSYSTEMTYPE </td> </tr> <tr> <td
    ///width="40%"><a id="FORMAT_MPEGVideo"></a><a id="format_mpegvideo"></a><a id="FORMAT_MPEGVIDEO"></a><dl>
    ///<dt><b>FORMAT_MPEGVideo</b></dt> </dl> </td> <td width="60%"> MPEG1VIDEOINFO </td> </tr> <tr> <td width="40%"><a
    ///id="FORMAT_None"></a><a id="format_none"></a><a id="FORMAT_NONE"></a><dl> <dt><b>FORMAT_None</b></dt> </dl> </td>
    ///<td width="60%"> None. </td> </tr> <tr> <td width="40%"><a id="FORMAT_VideoInfo"></a><a
    ///id="format_videoinfo"></a><a id="FORMAT_VIDEOINFO"></a><dl> <dt><b>FORMAT_VideoInfo</b></dt> </dl> </td> <td
    ///width="60%"> VIDEOINFOHEADER </td> </tr> <tr> <td width="40%"><a id="FORMAT_VideoInfo2"></a><a
    ///id="format_videoinfo2"></a><a id="FORMAT_VIDEOINFO2"></a><dl> <dt><b>FORMAT_VideoInfo2</b></dt> </dl> </td> <td
    ///width="60%"> VIDEOINFOHEADER2 </td> </tr> <tr> <td width="40%"><a id="FORMAT_WaveFormatEx"></a><a
    ///id="format_waveformatex"></a><a id="FORMAT_WAVEFORMATEX"></a><dl> <dt><b>FORMAT_WaveFormatEx</b></dt> </dl> </td>
    ///<td width="60%"> WAVEFORMATEX </td> </tr> <tr> <td width="40%"><a id="GUID_NULL"></a><a id="guid_null"></a><dl>
    ///<dt><b>GUID_NULL</b></dt> </dl> </td> <td width="60%"> None </td> </tr> </table>
    GUID     formattype;
    ///Not used. Set to <b>NULL</b>.
    IUnknown pUnk;
    ///Size of the format block, in bytes.
    uint     cbFormat;
    ///Pointer to the format block. The structure type is specified by the <b>formattype</b> member. The format
    ///structure must be present, unless <b>formattype</b> is GUID_NULL or FORMAT_None. The <b>pbFormat</b> buffer must
    ///be allocated by calling CoTaskMemAlloc. To release the format block, call FreeMediaType.
    ubyte*   pbFormat;
}

///The ALLOCATOR_PROPERTIES structure describes an allocator's count, size, alignment, and prefix properties.
struct ALLOCATOR_PROPERTIES
{
    ///Number of buffers created by the allocator.
    int cBuffers;
    ///Size of each buffer in bytes, excluding any prefix.
    int cbBuffer;
    ///Alignment of the buffer; buffer start will be aligned on a multiple of this value.
    int cbAlign;
    ///Each buffer is preceded by a prefix of this many bytes.
    int cbPrefix;
}

///The <code>PIN_INFO</code> structure contains information about a pin.
struct PIN_INFO
{
    ///Pointer to the IBaseFilter interface of the owning filter.
    IBaseFilter   pFilter;
    ///Direction of the pin (input or output).
    PIN_DIRECTION dir;
    ///Name of the pin.
    ushort[128]   achName;
}

///The <code>FILTER_INFO</code> structure contains information about a filter.
struct FILTER_INFO
{
    ///Null-terminated string containing the name of the filter.
    ushort[128]  achName;
    ///If the filter is member of a filter graph, contains a pointer to the filter graph's IFilterGraph interface. If
    ///the filter is not a member of a filter graph, this value of this member is <b>NULL</b>.
    IFilterGraph pGraph;
}

///The <b>AM_SAMPLE2_PROPERTIES</b> structure describes the properties of a media sample. The IMediaSample2 interface
///uses this structure.
struct AM_SAMPLE2_PROPERTIES
{
    ///Length of property data, in bytes. This structure member is for extensibility.
    uint           cbData;
    ///Type-specific flags. Flags are defined separately for each media type. The default value is
    ///AM_VIDEO_FLAG_INTERLEAVED_FRAME (zero). The following flags are used for video streams. They are defined in the
    ///header file dvdmedia.h. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="AM_VIDEO_FLAG_FIELD_MASK"></a><a id="am_video_flag_field_mask"></a><dl>
    ///<dt><b>AM_VIDEO_FLAG_FIELD_MASK</b></dt> <dt>0x0003</dt> </dl> </td> <td width="60%"> Use this mask to check
    ///whether the sample is a field or a frame. </td> </tr> <tr> <td width="40%"><a
    ///id="AM_VIDEO_FLAG_INTERLEAVED_FRAME"></a><a id="am_video_flag_interleaved_frame"></a><dl>
    ///<dt><b>AM_VIDEO_FLAG_INTERLEAVED_FRAME</b></dt> <dt>0x0000</dt> </dl> </td> <td width="60%"> The sample is a
    ///frame. (Use the AM_VIDEO_FLAG_FIELD_MASK bitmask to test for this value.) </td> </tr> <tr> <td width="40%"><a
    ///id="AM_VIDEO_FLAG_FIELD1"></a><a id="am_video_flag_field1"></a><dl> <dt><b>AM_VIDEO_FLAG_FIELD1</b></dt>
    ///<dt>0x0001</dt> </dl> </td> <td width="60%"> The sample is field 1. (Use the AM_VIDEO_FLAG_FIELD_MASK bitmask to
    ///test for this value.) </td> </tr> <tr> <td width="40%"><a id="AM_VIDEO_FLAG_FIELD2"></a><a
    ///id="am_video_flag_field2"></a><dl> <dt><b>AM_VIDEO_FLAG_FIELD2</b></dt> <dt>0x0002</dt> </dl> </td> <td
    ///width="60%"> The sample is the field 2. (Use the AM_VIDEO_FLAG_FIELD_MASK bitmask to test for this value.) </td>
    ///</tr> <tr> <td width="40%"><a id="AM_VIDEO_FLAG_FIELD1FIRST"></a><a id="am_video_flag_field1first"></a><dl>
    ///<dt><b>AM_VIDEO_FLAG_FIELD1FIRST</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> If this flag is set,
    ///display field 1 first. Otherwise, display field 2 first. (Applies only when there are two fields per sample.)
    ///</td> </tr> <tr> <td width="40%"><a id="AM_VIDEO_FLAG_WEAVE"></a><a id="am_video_flag_weave"></a><dl>
    ///<dt><b>AM_VIDEO_FLAG_WEAVE</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%"> If this flag is set, use weave
    ///mode (that is, do not deinterlace the sample). Otherwise, use bob mode. This flag applies only when there are two
    ///fields per sample. </td> </tr> <tr> <td width="40%"><a id="AM_VIDEO_FLAG_REPEAT_FIELD"></a><a
    ///id="am_video_flag_repeat_field"></a><dl> <dt><b>AM_VIDEO_FLAG_REPEAT_FIELD</b></dt> <dt>0x0040</dt> </dl> </td>
    ///<td width="60%"> If this flag is set, display the first field again after displaying the second field. (Applies
    ///only when there are two fields per sample.) </td> </tr> <tr> <td width="40%"><a id="AM_ReverseBlockStart"></a><a
    ///id="am_reverseblockstart"></a><a id="AM_REVERSEBLOCKSTART"></a><dl> <dt><b>AM_ReverseBlockStart</b></dt>
    ///<dt>0x2</dt> </dl> </td> <td width="60%"> Signals the start of a VOBU during reverse playback of DVD video. For
    ///more information, see DVD Playback Enhancements in Windows Vista. </td> </tr> <tr> <td width="40%"><a
    ///id="AM_ReverseBlockEnd"></a><a id="am_reverseblockend"></a><a id="AM_REVERSEBLOCKEND"></a><dl>
    ///<dt><b>AM_ReverseBlockEnd</b></dt> <dt>0x4</dt> </dl> </td> <td width="60%"> Signals the end of a VOBU during
    ///reverse playback of DVD video. The DVD Navigator sets this flag on an empty sample to signal the end of a VOBU.
    ///For more information, see DVD Playback Enhancements in Windows Vista. </td> </tr> <tr> <td width="40%"><a
    ///id="AM_UseNewCSSKey"></a><a id="am_usenewcsskey"></a><a id="AM_USENEWCSSKEY"></a><dl>
    ///<dt><b>AM_UseNewCSSKey</b></dt> <dt>0x1</dt> </dl> </td> <td width="60%"> For DVD playback, indicates the point
    ///in the stream when the decoder should apply a new Content Scramble System (CSS) key. The DVD Navigator sets this
    ///flag on an empty media sample just before it renegotiate a CSS title key. Previously, the DVD Navigator
    ///incorrectly sent this key before negotiating the disc key. Starting in Windows 7, if the decoder's
    ///<b>AM_PROPERTY_DVDCOPY_SUPPORTS_NEW_KEYCOUNT</b> property returns <b>TRUE</b>, the DVD Navigator does not send
    ///this flag before negotiating the disc key. See DVD Copy Protection Property Set. </td> </tr> </table> Other flags
    ///are defined but not currently used. See dvdmedia.h.
    uint           dwTypeSpecificFlags;
    ///Bitwise combination of flags the AM_SAMPLE_PROPERTY_FLAGS enumerated data type. Undefined bits are reserved and
    ///must be zero.
    uint           dwSampleFlags;
    ///Length of the valid data in the buffer.
    int            lActual;
    ///Start time, if valid. The <b>dwSampleFlags</b> member specifies whether this member is valid.
    long           tStart;
    ///Stop time, if valid. The <b>dwSampleFlags</b> member specifies whether this member is valid.
    long           tStop;
    ///Stream identifier. If the value is AM_STREAM_MEDIA, the stream contains media data. If the value is
    ///AM_STREAM_CONTROL, the stream contains control information. Applications can define values of 0x80000000 or
    ///greater for their own use. (See AM_SAMPLE_PROPERTY_FLAGS.)
    uint           dwStreamId;
    ///Pointer to an AM_MEDIA_TYPE structure that specifies the media type if the format has changed. If this format has
    ///not changed, this member is <b>NULL</b>.
    AM_MEDIA_TYPE* pMediaType;
    ///Pointer to the sample buffer.
    ubyte*         pbBuffer;
    ///Size of the sample buffer, in bytes.
    int            cbBuffer;
}

struct REGFILTER
{
    GUID          Clsid;
    const(wchar)* Name;
}

///The <code>REGPINTYPES</code> structure contains media type information for registering a filter.
struct REGPINTYPES
{
    ///Major type GUID of the media type.
    const(GUID)* clsMajorType;
    ///Sub type GUID of the media type. Can be MEDIASUBTYPE_NULL.
    const(GUID)* clsMinorType;
}

///The <code>REGFILTERPINS</code> structure contains pin information for registering a filter.
struct REGFILTERPINS
{
    ///Name of the pin. (Obsolete.)
    const(wchar)*       strName;
    ///If <b>TRUE</b>, the filter renders the input from this pin. (Applies only to input pins. For output pins, the
    ///value is always <b>FALSE</b>.)
    BOOL                bRendered;
    ///If <b>TRUE</b>, this pin is an output pin. Otherwise, the pin is an input pin.
    BOOL                bOutput;
    ///If <b>TRUE</b>, the filter can have zero instances of this pin.
    BOOL                bZero;
    ///If <b>TRUE</b>, the filter can create more than one instance of this type of pin.
    BOOL                bMany;
    ///Class identifier (CLSID) of the filter to which this pin connects. (Obsolete.)
    const(GUID)*        clsConnectsToFilter;
    ///Name of the pin to which this pin connects. (Obsolete.)
    const(wchar)*       strConnectsToPin;
    ///Number of media types supported by this pin.
    uint                nMediaTypes;
    ///Pointer to an array of REGPINTYPES structures, of size <b>nMediaTypes</b>.
    const(REGPINTYPES)* lpMediaType;
}

///The <code>REGPINMEDIUM</code> structure describes a pin medium for registration through the IFilterMapper2 interface.
struct REGPINMEDIUM
{
    ///GUID that specifies the medium.
    GUID clsMedium;
    ///Variable of type <b>DWORD</b> that specifies the instance of this medium. This is necessary when two identical
    ///devices are present on the host system.
    uint dw1;
    ///Not used.
    uint dw2;
}

///The <code>REGFILTERPINS2</code> structure contains information for registering a filter through the IFilterMapper2
///interface.
struct REGFILTERPINS2
{
    ///Bitwise combination of zero or more REG_PINFLAG flags.
    uint                 dwFlags;
    ///Number of instances of this pin.
    uint                 cInstances;
    ///Number of media types supported by this pin.
    uint                 nMediaTypes;
    ///Pointer to an array of REGPINTYPES structures, of size nMediaTypes.
    const(REGPINTYPES)*  lpMediaType;
    ///Number of mediums. Can be zero.
    uint                 nMediums;
    ///Pointer to an array of REGPINMEDIUM structures, of size nMediums.
    const(REGPINMEDIUM)* lpMedium;
    ///Optional pin category, from the Pin Property Set.
    const(GUID)*         clsPinCategory;
}

///The <code>REGFILTER2</code> structure contains information for registering a filter.
struct REGFILTER2
{
    ///Filter registration format. If the value is 1, the union contains the first unnamed structure. If the value is 2,
    ///the union contains the second unnamed structure.
    uint dwVersion;
    ///Filter merit. Filters with higher merit are enumerated first. See Merit.
    uint dwMerit;
    union
    {
        struct
        {
            uint cPins;
            const(REGFILTERPINS)* rgPins;
        }
        struct
        {
            uint cPins2;
            const(REGFILTERPINS2)* rgPins2;
        }
    }
}

///The <code>Quality</code> structure describes a quality message by indicating Flood or Famine in the renderer and
///specifying the percentage of frames to drop or add to optimize the renderer's performance.
struct Quality
{
    ///Value from the [QualityMessageType](/windows/desktop/api/strmif/ne-strmif-qualitymessagetype) enumeration,
    ///indicating whether the downstream filter needs more or less data.
    QualityMessageType Type;
    ///Value that specifies the rate at which DirectShow should continue to send media samples. The base value is 1000,
    ///which indicates there should be no change. A percentage increase or decrease from 1000 indicates the percentage
    ///of frames to add or drop. If this value is 800, for example, DirectShow will drop 20 percent of the incoming
    ///frames to match the renderer's speed.
    int                Proportion;
    ///If a famine exists downstream, this is the amount of time by which the stream is lagging.
    long               Late;
    ///Value that specifies the time when DirectShow created this structure, which is usually the start time on a video
    ///sample.
    long               TimeStamp;
}

///The <code>COLORKEY</code> structure communicates color key information between the renderer and another filter.
struct COLORKEY
{
    ///Key type. Can be <b>CK_NOCOLORKEY</b>, <b>CK_INDEX</b>, or <b>CK_RGB</b>. The <b>CK_INDEX</b> and <b>CK_RGB</b>
    ///can be combined with a bitwise <b>OR</b>.
    uint KeyType;
    ///Palette index.
    uint PaletteIndex;
    ///Lowest RGB color value.
    uint LowColorValue;
    ///Highest RGB color value.
    uint HighColorValue;
}

///The AM_STREAM_INFO structure contains stream-control information.
struct AM_STREAM_INFO
{
    ///Time when the pin will start streaming data.
    long tStart;
    ///Time when the pin will stop streaming data.
    long tStop;
    ///Value that will be sent with the event notification when the pin starts.
    uint dwStartCookie;
    ///Value that will be sent with the event notification when the pin stops.
    uint dwStopCookie;
    ///Bitwise combination of zero or more flags from the AM_STREAM_INFO_FLAGS enumeration.
    uint dwFlags;
}

///The <b>VIDEO_STREAM_CONFIG_CAPS</b> structure describes a range of video formats. Video compression and video capture
///filters use this structure to describe what formats they can produce. <div class="alert"><b>Note</b> Most of this
///structure is deprecated, with the exception of the following structure members:<ul> <li><b>guid</b></li>
///<li><b>VideoStandard</b></li> <li><b>MinFrameInterval</b></li> <li><b>MaxFrameInterval</b></li> </ul> Applications
///can use <b>MinFrameInterval</b> and <b>MaxFrameInterval</b> to get the range of supported frame rates from a video
///capture device. Applications should avoid using any of the other members of this structure. Instead, use the
///AM_MEDIA_TYPE structure returned by the IAMStreamConfig::GetFormat method.</div><div> </div>
struct VIDEO_STREAM_CONFIG_CAPS
{
    ///<b>GUID</b> that identifies the format type. For example, <b>FORMAT_VideoInfo</b> or <b>FORMAT_VideoInfo2</b>.
    ///For more information, see the <b>formattype</b> member of the AM_MEDIA_TYPE structure.
    GUID guid;
    ///The analog video standard supported. The value is a bitwise combination of flags from the
    ///[AnalogVideoStandard](/windows/desktop/api/strmif/ne-strmif-analogvideostandard) enumeration type, or zero.
    uint VideoStandard;
    ///Native size of the incoming video signal. For a compressor, the size is taken from the input pin. For a capture
    ///filter, the size is the largest signal the filter can digitize with every pixel remaining unique. <div
    ///class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    SIZE InputSize;
    ///Smallest source rectangle allowed. The source rectangle is defined in the <b>rcSource</b> member of the
    ///VIDEOINFOHEADER or VIDEOINFOHEADER2 structure. <div class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    SIZE MinCroppingSize;
    ///Largest source rectangle allowed. <div class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    SIZE MaxCroppingSize;
    ///Horizontal granularity of the source rectangle. This value specifies the increments that are valid between
    ///<b>MinCroppingSize</b> and <b>MaxCroppingSize</b>. <div class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    int  CropGranularityX;
    ///Vertical granularity of the source rectangle. This value specifies the increments that are valid between
    ///<b>MinCroppingSize</b> and <b>MaxCroppingSize</b>. <div class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    int  CropGranularityY;
    ///Required horizontal alignment of the source rectangle. <div class="alert"><b>Note</b> Deprecated.</div> <div>
    ///</div>
    int  CropAlignX;
    ///Required vertical alignment of the source rectangle. <div class="alert"><b>Note</b> Deprecated.</div> <div>
    ///</div>
    int  CropAlignY;
    ///Minimum output size. <div class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    SIZE MinOutputSize;
    ///Maximum output size. <div class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    SIZE MaxOutputSize;
    ///Granularity of the output width. This value specifies the increments that are valid between <b>MinOutputSize</b>
    ///and <b>MaxOutputSize</b>. <div class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    int  OutputGranularityX;
    ///Granularity of output height. This value specifies the increments that are valid between <b>MinOutputSize</b> and
    ///<b>MaxOutputSize</b>. <div class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    int  OutputGranularityY;
    ///Indicates how well the filter can stretch the image horizontally. <div class="alert"><b>Note</b>
    ///Deprecated.</div> <div> </div>
    int  StretchTapsX;
    ///Indicates how well the filter can stretch the image vertically. <div class="alert"><b>Note</b> Deprecated.</div>
    ///<div> </div>
    int  StretchTapsY;
    ///Indicates how well the filter can shrink the image horizontally. <div class="alert"><b>Note</b> Deprecated.</div>
    ///<div> </div>
    int  ShrinkTapsX;
    ///Indicates how well the filter can shrink the image vertically. <div class="alert"><b>Note</b> Deprecated.</div>
    ///<div> </div> The previous four structure members use the following values: <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%">
    ///Does not support stretching/shrinking. </td> </tr> <tr> <td width="40%"><a id="1"></a><dl> <dt><b>1</b></dt>
    ///</dl> </td> <td width="60%"> Uses pixel doubling (stretching) or eliminates pixels (shrinking) </td> </tr> <tr>
    ///<td width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> Uses interpolation (2 taps)
    ///</td> </tr> <tr> <td width="40%"><a id="3_and_higher"></a><a id="3_AND_HIGHER"></a><dl> <dt><b>3 and
    ///higher</b></dt> </dl> </td> <td width="60%"> Uses interpolation (&gt;2 taps) </td> </tr> </table>
    int  ShrinkTapsY;
    ///The minimum frame duration, in 100-nanosecond units. This value applies only to capture filters.
    long MinFrameInterval;
    ///The maximum frame duration, in 100-nanosecond units. This value applies only to capture filters.
    long MaxFrameInterval;
    ///Minimum data rate this pin can produce. <div class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    int  MinBitsPerSecond;
    ///Maximum data rate this pin can produce. <div class="alert"><b>Note</b> Deprecated.</div> <div> </div>
    int  MaxBitsPerSecond;
}

///The <b>AUDIO_STREAM_CONFIG_CAPS</b> structure describes a range of audio formats. Audio compression and capture
///filters use this structure to describe the formats they can produce.
struct AUDIO_STREAM_CONFIG_CAPS
{
    ///Will be set to MEDIATYPE_Audio to indicate an audio sample.
    GUID guid;
    ///Minimum number of channels.
    uint MinimumChannels;
    ///Maximum number of channels.
    uint MaximumChannels;
    ///Granularity of the channels. For example, the filter might specify channels 2 through 4, in steps of 2.
    uint ChannelsGranularity;
    ///Minimum bits per sample.
    uint MinimumBitsPerSample;
    ///Maximum bits per sample.
    uint MaximumBitsPerSample;
    ///Granularity of the bits per sample. For example, the filter might specify 8 bits per sample through 32 bits per
    ///sample, in steps of 8.
    uint BitsPerSampleGranularity;
    ///Minimum sample frequency.
    uint MinimumSampleFrequency;
    ///Maximum sample frequency.
    uint MaximumSampleFrequency;
    ///Granularity of the frequency. For example, the filter might specify 11025 Hz to 44100 Hz, in steps of 11025 Hz.
    uint SampleFrequencyGranularity;
}

///The <b>DVINFO</b> structure describes the format of a digital video (DV) stream.
struct DVINFO
{
    ///Specifies the audio auxiliary (AAUX) source pack for the first audio block.
    uint    dwDVAAuxSrc;
    ///Specifies the AAUX source control Pack for the first audio block.
    uint    dwDVAAuxCtl;
    ///Specifies the AAUX source pack for the second audio block.
    uint    dwDVAAuxSrc1;
    ///Specifies the AAUX source control pack for the second audio block.
    uint    dwDVAAuxCtl1;
    ///Specifies the video auxiliary (VAUX) source pack.
    uint    dwDVVAuxSrc;
    ///Specifies the VAUX source control pack.
    uint    dwDVVAuxCtl;
    ///Reserved. Set this array to zero.
    uint[2] dwDVReserved;
}

///The <code>STREAM_ID_MAP</code> structure describes an elementary stream within an MPEG-2 program stream. Used with
///the IEnumStreamIdMap interface methods.
struct STREAM_ID_MAP
{
    ///Specifies the ID of the PES stream.
    uint stream_id;
    ///Specifies the media contents of the stream. May be one of the following values defined in axextend.idl:
    uint dwMediaSampleContent;
    ///Specifies the substream within the elementary stream. If no substream filtering is required, use
    ///SUBSTREAM_FILTER_VAL_NONE (0x10000000).
    uint ulSubstreamFilterValue;
    ///Specifies the offset in bytes for the substream. If no filtering is required, specify 0.
    int  iDataOffset;
}

///The <b>AMCOPPSignature</b> structure contains the signature needed for the
///IAMCertifiedOutputProtection::SessionSequenceStart method.
struct AMCOPPSignature
{
    ///Buffer that contains the signature. For more information, see the Remarks section for the
    ///<b>SessionSequenceStart</b> method.
    ubyte[256] Signature;
}

///The AMCOPPCommand structure contains a Certified Output Protection Protocol (COPP) command.
struct AMCOPPCommand
{
    ///Message Authentication Code (MAC) of the command data. Use AES-based one-key CBC MAC (OMAC) to calculate this
    ///value.
    GUID        macKDI;
    ///GUID that specifies the command.
    GUID        guidCommandID;
    ///Sequence number. The application must keep a running count of the COPP commands issued. For each command,
    ///increment the sequence number by one.
    uint        dwSequence;
    ///Number of bytes of valid data in the <b>CommandData</b> member.
    uint        cbSizeData;
    ///Data for the command. The meaning of the data depends on the command.
    ubyte[4056] CommandData;
}

///The AMCOPPStatusInput structure contains a Certified Output Protection Protocol (COPP) status request.
struct AMCOPPStatusInput
{
    ///128-bit random number.
    GUID        rApp;
    ///GUID that defines the status request.
    GUID        guidStatusRequestID;
    ///Sequence number. The application must keep a running count of the COPP status requests issued. For each request,
    ///increment the sequence number by one.
    uint        dwSequence;
    ///Number of bytes of valid data in the <b>StatusData</b> member.
    uint        cbSizeData;
    ///Data for the status request. The meaning of the data depends on the request.
    ubyte[4056] StatusData;
}

///The <b>AMCOPPStatusOutput</b> structure contains the result of a Certified Output Protection Protocol (COPP) status
///request.
struct AMCOPPStatusOutput
{
    ///Message Authentication Code (MAC) of the status data. The driver will use AES-based one-key CBC MAC (OMAC) to
    ///calculate this value.
    GUID        macKDI;
    ///Size of the valid data in the <b>COPPStatus</b> member.
    uint        cbSizeData;
    ///Buffer that contains the result of the status request.
    ubyte[4076] COPPStatus;
}

///The <code>VMRPRESENTATIONINFO</code> structure is used in the IVMRImagePresenter::PresentImage method (VMR-7 only).
struct VMRPRESENTATIONINFO
{
    ///A bitwise combination of flags from the VMRPresentationFlags enumeration, which describe the status of the video
    ///sample with respect to its presentation time.
    uint                dwFlags;
    ///Pointer to the DirectDraw surface that contains the video frame to be presented.
    IDirectDrawSurface7 lpSurf;
    ///The start time for the current frame, in 100-nanosecond units.
    long                rtStart;
    ///The end time for the current frame, in 100-nanosecond units.
    long                rtEnd;
    ///The aspect ratio of the rectangle.
    SIZE                szAspectRatio;
    ///The source rectangle.
    RECT                rcSrc;
    ///The destination rectangle.
    RECT                rcDst;
    ///Bitwise combination of flags, as defined for the
    ///[AM_SAMPLE2_PROPERTIES](/windows/desktop/api/strmif/ns-strmif-am_sample2_properties) structure.
    uint                dwTypeSpecificFlags;
    ///Bitwise combination of flags, as defined for the <b>dwInterlaceFlags</b> member of the VIDEOINFOHEADER2
    ///structure.
    uint                dwInterlaceFlags;
}

///The <code>VMRALLOCATIONINFO</code> structure is used in the VMR-7 filter's IVMRSurfaceAllocator::AllocateSurface
///method.
struct VMRALLOCATIONINFO
{
    ///A bitwise <b>OR</b> of flags from the VMRSurfaceAllocationFlags enumeration.
    uint              dwFlags;
    ///Pointer to the <b>BITMAPINFOHEADER</b> structure associated with the surface.
    BITMAPINFOHEADER* lpHdr;
    ///Pointer to the <b>DDPIXELFORMAT</b> structure associated with the surface.
    DDPIXELFORMAT*    lpPixFmt;
    ///A SIZE structure that specifies the aspect ratio of the new surface.
    SIZE              szAspectRatio;
    ///The minimum number of buffers to create for this surface.
    uint              dwMinBuffers;
    ///The maximum number of buffers to create for this surface.
    uint              dwMaxBuffers;
    ///A bitwise <b>OR</b> of flags that indicate the interlacing. For a list of flags, see the <b>dwInterlaceFlags</b>
    ///member of the VIDEOINFOHEADER2 structure.
    uint              dwInterlaceFlags;
    ///The size of the native video rectangle.
    SIZE              szNativeSize;
}

///The <code>NORMALIZEDRECT</code> structure is used with the VMR filter in mixing operations to specify the location of
///a video rectangle in composition space.
struct NORMALIZEDRECT
{
    ///The left corner of the normalized rectangle.
    float left;
    ///The top corner of the normalized rectangle.
    float top;
    ///The right corner of the normalized rectangle.
    float right;
    ///The bottom corner of the normalized rectangle.
    float bottom;
}

///The [VMRMONITORINFO](/windows/desktop/api/strmif/ns-strmif-vmrmonitorinfo) structure and is used to identify a
///monitor on the system (VMR-7 only).
struct VMRGUID
{
    ///Pointer to the GUID member of the structure. <b>pGUID</b> is <b>NULL</b> if the monitor is the default DirectDraw
    ///device.
    GUID* pGUID;
    ///Specifies the GUID for the monitor.
    GUID  Guid;
}

///The <code>VMRMONITORINFO</code> structure is used in the IVMRMonitorConfig::GetAvailableMonitors method to set and
///retrieve information about monitors on the system (VMR-7 only).
struct VMRMONITORINFO
{
    ///A [VMRGUID](/windows/desktop/api/strmif/ns-strmif-vmrguid) structure that specifies the monitor.
    VMRGUID       guid;
    ///The monitor rectangle.
    RECT          rcMonitor;
    ///A handle to the monitor.
    ptrdiff_t     hMon;
    ///Flags as defined for the MONITORINFOEX structure. Currently the only valid flag is <b>MONITORINFOF_PRIMARY</b>,
    ///which indicates the primary display monitor.
    uint          dwFlags;
    ///Null-terminated string containing the device name.
    ushort[32]    szDevice;
    ///Null-terminated string containing the device description.
    ushort[256]   szDescription;
    LARGE_INTEGER liDriverVersion;
    uint          dwVendorId;
    uint          dwDeviceId;
    uint          dwSubSysId;
    uint          dwRevision;
}

///The <code>VMRFrequency</code> structure describes the frequency of a video stream. Frequencies are described as
///ratios. For example, the NTSC frame rate of 29.97 fps is expressed as 30,000:1001.
struct VMRFrequency
{
    ///Numerator of the frequency ratio.
    uint dwNumerator;
    ///Denominator of the frequency ratio.
    uint dwDenominator;
}

///This topic applies to Windows XP Service Pack 1 or later. The <code>VMRVideoDesc</code> structure describes a video
///stream to be deinterlaced.
struct VMRVideoDesc
{
    ///Size of the structure, in bytes.
    uint         dwSize;
    ///Width of the video to be deinterlaced, in pixels.
    uint         dwSampleWidth;
    ///Height of the video to be deinterlaced, in pixels.
    uint         dwSampleHeight;
    ///Specifies one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TRUE"></a><a id="true"></a><dl> <dt><b><b>TRUE</b></b></dt> </dl> </td> <td width="60%"> Each field is
    ///delivered as a separate sample. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a id="false"></a><dl>
    ///<dt><b><b>FALSE</b></b></dt> </dl> </td> <td width="60%"> Pairs of fields are combined into single samples. </td>
    ///</tr> </table>
    BOOL         SingleFieldPerSample;
    ///Specifies a FOURCC code. Valid values include NV12, YV12, YUY2, UYVY, IMC1, IMC2, IMC3 and IMC4
    uint         dwFourCC;
    ///A [VMRFrequency](/windows/desktop/api/strmif/ns-strmif-vmrfrequency) structure that specifies the input
    ///frequency. For NTSC TV, the frequency would be expressed as 30,000:1001.
    VMRFrequency InputSampleFreq;
    ///A [VMRFrequency](/windows/desktop/api/strmif/ns-strmif-vmrfrequency) structure that specifies the output
    ///frequency. For NTSC TV, the frequency would be expressed as 60,000:1001.
    VMRFrequency OutputFrameFreq;
}

///The <code>VMRDeinterlaceCaps</code> structure describes the capabilities of a deinterlacing mode.
struct VMRDeinterlaceCaps
{
    ///Size of the structure, in bytes.
    uint               dwSize;
    ///Number of previously de-interlaced frames that must be fed back to the hardware to deinterlace the next field.
    ///(Used by recursive deinterlacing algorithms.)
    uint               dwNumPreviousOutputFrames;
    ///Number of future samples needed to deinterlace the current field.
    uint               dwNumForwardRefSamples;
    ///Number of past samples needed to deinterlace the current field.
    uint               dwNumBackwardRefSamples;
    ///Bitwise combination of flags from the VMRDeinterlaceTech enumeration type. These flags are used to describe the
    ///deinterlacing algorithm.
    VMRDeinterlaceTech DeinterlaceTechnology;
}

///The <b>VMRALPHABITMAP</b> structure is used in the VMR-7 filter's IVMRMixerBitmap methods when the application is
///providing a static alpha-blended bitmap to be displayed on the composited video frame.
struct VMRALPHABITMAP
{
    ///Flags that instruct the mixer where to find the bitmap. The following values are defined. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VMRBITMAP_DISABLE"></a><a
    ///id="vmrbitmap_disable"></a><dl> <dt><b>VMRBITMAP_DISABLE</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> Disable the bitmap. This flag cannot be combined with other flags. </td> </tr> <tr> <td
    ///width="40%"><a id="VMRBITMAP_HDC"></a><a id="vmrbitmap_hdc"></a><dl> <dt><b>VMRBITMAP_HDC</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> Obtain the bitmap from the HDC. If this flag is set, the
    ///<b>hdc</b> member must specify a valid handle to a device context, and the <b>pDDS</b> member must be
    ///<b>NULL</b>. If this flag is absent, the <b>pDDS</b> member must point to a valid DirectDraw surface, and the
    ///<b>hdc</b> member must be <b>NULL</b>. </td> </tr> <tr> <td width="40%"><a id="VMRBITMAP_ENTIREDDS"></a><a
    ///id="vmrbitmap_entiredds"></a><dl> <dt><b>VMRBITMAP_ENTIREDDS</b></dt> <dt>0x00000004</dt> </dl> </td> <td
    ///width="60%"> Take the entire DirectDraw surface. When this flag is specified, <b>rSrc</b> is ignored. This flag
    ///cannot be combined with the <b>VMRBITMAP_HDC</b> flag. </td> </tr> <tr> <td width="40%"><a
    ///id="VMRBITMAP_SRCCOLORKEY"></a><a id="vmrbitmap_srccolorkey"></a><dl> <dt><b>VMRBITMAP_SRCCOLORKEY</b></dt>
    ///<dt>0x00000008</dt> </dl> </td> <td width="60%"> The <b>clrSrcKey</b> value is valid and should be used when
    ///blending. </td> </tr> <tr> <td width="40%"><a id="VMRBITMAP_SRCRECT"></a><a id="vmrbitmap_srcrect"></a><dl>
    ///<dt><b>VMRBITMAP_SRCRECT</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> Indicates that the <b>rSrc</b>
    ///rectangle is valid and specifies a sub-rectangle of the original app image to be blended. This flag is only valid
    ///for the IVMRMixerBitmap::UpdateAlphaBitmapParameters method. For the IVMRMixerBitmap::SetAlphaBitmap method, the
    ///<b>rSrc</b> member must refer to the entire bitmap. </td> </tr> </table>
    uint                dwFlags;
    ///The handle to the device context for the bitmap. Specify <b>NULL</b> if the bitmap is located in a DirectDraw
    ///surface.
    HDC                 hdc;
    ///Pointer to a DirectDraw surface that contains the bitmap. Specify <b>NULL</b> if the bitmap is to be obtained
    ///from a GDI device context. If a DirectDraw surface is specified, the pixel format must be ARGB-32 or RGB-32. If
    ///the surface contains per-pixel alpha, do not set the VMRBITMAP_SRCCOLORKEY flag in <b>dwFlags</b>.
    IDirectDrawSurface7 pDDS;
    ///Specifies the source rectangle in either the GDI device context or the DirectDraw surface.
    RECT                rSrc;
    ///Specifies the destination rectangle in composition space.
    NORMALIZEDRECT      rDest;
    ///Specifies the alpha blending value; must be a value from 0.0 to 1.0 (inclusive).
    float               fAlpha;
    ///Specifies the source color key.
    uint                clrSrcKey;
}

///This topic applies to Windows XP or later. The <code>VMRVIDEOSTREAMINFO</code> structure is used in the VMR-7
///filter's call to IVMRImageCompositor::CompositeImage on the image compositor.
struct VMRVIDEOSTREAMINFO
{
    ///Specifies the DirectDraw surface that contains the video to be composited.
    IDirectDrawSurface7 pddsVideoSurface;
    ///Specifies the width of the video rectangle.
    uint                dwWidth;
    ///Specifies the height of the video rectangle.
    uint                dwHeight;
    ///Specifies the input stream. This value corresponds to the input pin.
    uint                dwStrmID;
    ///Specifies the alpha value for this stream. (Not per-pixel alpha.)
    float               fAlpha;
    ///Specifies the source color key value or -1 if color keying is not to be used for this stream.
    DDCOLORKEY          ddClrKey;
    ///Specifies the position of the image in composition space.
    NORMALIZEDRECT      rNormal;
}

struct DVD_ATR
{
    uint       ulCAT;
    ubyte[768] pbATRI;
}

///The <code>DVD_TIMECODE</code> structure contains DVD timecode in hours, minutes, seconds, and frames.
struct DVD_TIMECODE
{
    uint _bitfield14;
}

///The <code>DVD_HMSF_TIMECODE</code> structure gives the hours, minutes, seconds, and frames in a DVD timecode.
struct DVD_HMSF_TIMECODE
{
    ///Hours.
    ubyte bHours;
    ///Minutes.
    ubyte bMinutes;
    ///Seconds.
    ubyte bSeconds;
    ///Frames.
    ubyte bFrames;
}

///The <code>DVD_PLAYBACK_LOCATION2</code> structure indicates DVD playback location.
struct DVD_PLAYBACK_LOCATION2
{
    ///Title number for the whole disc (not the track number of the Video Title Set).
    uint              TitleNum;
    ///Part-of-title number with title. 0xffffffff if not a simple linear movie.
    uint              ChapterNum;
    ///Timecode. Use [DVD_HMSF_TIMECODE](/windows/desktop/api/strmif/ns-strmif-dvd_hmsf_timecode) for current playback
    ///time. 0xffffffff if not a simple linear movie.
    DVD_HMSF_TIMECODE TimeCode;
    ///A bitwise [DVD_TIMECODE_FLAGS](/windows/desktop/api/strmif/ne-strmif-dvd_timecode_flags) enumeration.
    uint              TimeCodeFlags;
}

///The <code>DVD_PLAYBACK_LOCATION</code> structure indicates DVD playback location.
struct DVD_PLAYBACK_LOCATION
{
    ///Title number for the whole disc; Title Track Number (TTN) not Video Title Set_Title Track Number (VTS_TTN).
    uint TitleNum;
    ///Part-of-title number with title. 0xffffffff if not a simple linear movie.
    uint ChapterNum;
    ///Timecode. Use [DVD_TIMECODE](/windows/desktop/api/strmif/ns-strmif-dvd_timecode) for current playback time.
    ///0xFFFFFFFF if not a simple linear movie.
    uint TimeCode;
}

///The <code>DVD_AudioAttributes</code> structure is used in IDvdInfo2::GetAudioAttributes to receive the various audio
///attributes of the disc.
struct DVD_AudioAttributes
{
    ///Indicates the current audio mode. If the mode returned is DVD_AudioMode_Karaoke, call
    ///IDvdInfo2::GetKaraokeAttributes to get more info.
    DVD_AUDIO_APPMODE  AppMode;
    ubyte              AppModeData;
    ///Describes the format (encoding mode) of the audio stream.
    DVD_AUDIO_FORMAT   AudioFormat;
    ///An <b>LCID</b> value indicating the language of the audio stream. Is zero if no language is present.
    uint               Language;
    ///A [DVD_AUDIO_LANG_EXT](/windows/desktop/api/strmif/ne-strmif-dvd_audio_lang_ext) enumeration that will be filled
    ///in if any information is available on the disc.
    DVD_AUDIO_LANG_EXT LanguageExtension;
    ///Indicates whether multichannel attributes are present. If <b>TRUE</b>, it means there is additional mixing
    ///information available, such as for SurroundSound. Call IDvdInfo2::GetTitleAttributes to retrieve the multichannel
    ///information.
    BOOL               fHasMultichannelInfo;
    ///The frequency in hertz (48k, 96k) of the audio stream.
    uint               dwFrequency;
    ///The resolution of the audio stream (16, 20, 24 bits, or other) Zero indicates the resolution is unknown.
    ubyte              bQuantization;
    ///The number of channels. For example, 5.1 Dolby AC-3 has six channels.
    ubyte              bNumberOfChannels;
    ///Reserved.
    uint[2]            dwReserved;
}

///The <code>DVD_MUA_MixingInfo</code> structure describes the surround sound mixing information for the channels in one
///audio stream in a specified title.
struct DVD_MUA_MixingInfo
{
    ///Variable of type BOOL; <b>TRUE</b> means the channel is mixed to channel 0.
    BOOL fMixTo0;
    ///Variable of type BOOL; <b>TRUE</b> means the channel is mixed to channel 1.
    BOOL fMixTo1;
    ///Variable of type BOOL; <b>TRUE</b> means the channel is mixed in phase to channel 0.
    BOOL fMix0InPhase;
    ///Variable of type BOOL; <b>TRUE</b> means the channel is mixed in phase to channel 1.
    BOOL fMix1InPhase;
    ///The speaker for which this channel is intended. See Remarks.
    uint dwSpeakerPosition;
}

///The [DVD_MultichannelAudioAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_multichannelaudioattributes)
///structure contains an array of eight <code>DVD_MUA_Coeff</code> structures, one for each channel in the stream.
struct DVD_MUA_Coeff
{
    ///The mixing coefficient for this channel to channel 0.
    double log2_alpha;
    ///The mixing coefficient for this channel to channel 1.
    double log2_beta;
}

///The <code>DVD_MultichannelAudioAttributes</code> structure describes the multichannel attributes of one audio stream
///within a specified title.
struct DVD_MultichannelAudioAttributes
{
    ///Array of eight [DVD_MUA_MixingInfo](/windows/desktop/api/strmif/ns-strmif-dvd_mua_mixinginfo) structures, which
    ///contain the mixing information for each channel in the audio stream.
    DVD_MUA_MixingInfo[8] Info;
    ///Array of eight [DVD_MUA_Coeff](/windows/desktop/api/strmif/ns-strmif-dvd_mua_coeff) structures, which contain the
    ///mixing coefficients for each channel in the audio stream.
    DVD_MUA_Coeff[8] Coeff;
}

///The <code>DVD_KaraokeAttributes</code> structure contains information about a karaoke audio stream. The
///IDvdInfo2::GetKaraokeAttributes method fills in a <code>DVD_KaraokeAttributes</code> structure for a specified
///stream.
struct DVD_KaraokeAttributes
{
    ///Version number. The current karaoke version is 1.0.
    ubyte     bVersion;
    ///If <b>TRUE</b>, the "Guide Vocal 1" channel contains the "Master of Ceremonies" content.
    BOOL      fMasterOfCeremoniesInGuideVocal1;
    ///A Boolean value indicating whether the song is intended to be sung as a duet.
    BOOL      fDuet;
    ///A [DVD_KARAOKE_ASSIGNMENT](/windows/desktop/api/strmif/ne-strmif-dvd_karaoke_assignment) value indicating the
    ///speaker configuration into which all the channels will be mixed.
    DVD_KARAOKE_ASSIGNMENT ChannelAssignment;
    ///An array of valid [DVD_KARAOKE_CONTENTS](/windows/desktop/api/strmif/ne-strmif-dvd_karaoke_contents) values that
    ///identifies the content on each channel.
    ushort[8] wChannelContents;
}

///The <code>DVD_VideoAttributes</code> structure describes the attributes of the video stream for the current title or
///menu.
struct DVD_VideoAttributes
{
    ///<b>TRUE</b> means the picture can be shown as pan-scan if the display aspect ratio is 4 x 3.
    BOOL fPanscanPermitted;
    ///<b>TRUE</b> means the picture can be shown as letterbox if the display aspect ratio is 4 x 3.
    BOOL fLetterboxPermitted;
    ///The video stream's X aspect (4 or 16).
    uint ulAspectX;
    ///The video stream's Y aspect (3 or 9).
    uint ulAspectY;
    ///The frame rate in hertz (Hz), either 50 or 60.
    uint ulFrameRate;
    ///The frame height in lines (525 for a frame rate of 60 Hz or 625 for 50 Hz).
    uint ulFrameHeight;
    ///Variable of type [DVD_VIDEO_COMPRESSION](/windows/desktop/api/strmif/ne-strmif-dvd_video_compression) indicating
    ///the MPEG compression type used on the disc.
    DVD_VIDEO_COMPRESSION Compression;
    ///<b>TRUE</b> means there is user data in line 21, field 1.
    BOOL fLine21Field1InGOP;
    ///<b>TRUE</b> means there is user data in line 21, field 2.
    BOOL fLine21Field2InGOP;
    ///The x-axis source resolution (352, 704, or 720).
    uint ulSourceResolutionX;
    ///The y-axis source resolution (240, 480, 288, or 576).
    uint ulSourceResolutionY;
    ///<b>TRUE</b> means the source video is in letterbox format. Subpictures and menu buttons can only be displayed in
    ///the active video area.
    BOOL fIsSourceLetterboxed;
    ///For 625/50 Hz systems, <b>TRUE</b> means "film mode" and <b>FALSE</b> means "camera mode."
    BOOL fIsFilmMode;
}

///The <code>DVD_SubpictureAttributes</code> structure contains information about the DVD subpicture. The
///IDvdInfo2::GetSubpictureAttributes method fills in a <code>DVD_SubpictureAttributes</code> structure for a specified
///stream.
struct DVD_SubpictureAttributes
{
    ///Variable of type [DVD_SUBPICTURE_TYPE](/windows/desktop/api/strmif/ne-strmif-dvd_subpicture_type) that indicates
    ///whether the subpicture contains language-related content.
    DVD_SUBPICTURE_TYPE Type;
    ///Variable of type [DVD_SUBPICTURE_CODING](/windows/desktop/api/strmif/ne-strmif-dvd_subpicture_coding) that
    ///indicates how the subpicture graphics stream is encoded.
    DVD_SUBPICTURE_CODING CodingMode;
    ///Variable of type LCID that identifies the subpicture language if Type equals DVD_SPType_Language.
    uint                Language;
    ///Variable of type [DVD_SUBPICTURE_LANG_EXT](/windows/desktop/api/strmif/ne-strmif-dvd_subpicture_lang_ext) that
    ///identifies the subpicture language extension if Type equals DVD_SPType_Language.
    DVD_SUBPICTURE_LANG_EXT LanguageExtension;
}

///The <b>DVD_TitleAttributes</b> structure contains information about a DVD title.
struct DVD_TitleAttributes
{
    union
    {
        DVD_TITLE_APPMODE AppMode;
        DVD_HMSF_TIMECODE TitleLength;
    }
    ///A [DVD_VideoAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_videoattributes) structure containing
    ///information about the "main" video of the current menu or title.
    DVD_VideoAttributes VideoAttributes;
    ///The number of audio streams available in the title.
    uint                ulNumberOfAudioStreams;
    ///An array of [DVD_AudioAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_audioattributes) structures
    ///containing information about each available audio stream in the current title.
    DVD_AudioAttributes[8] AudioAttributes;
    ///An array of [DVD_AudioAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_audioattributes) structure.
    DVD_MultichannelAudioAttributes[8] MultichannelAudioAttributes;
    ///The number of subpicture streams available in the title.
    uint                ulNumberOfSubpictureStreams;
    ///An array of [DVD_SubpictureAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_subpictureattributes) structures
    ///that contain information about each available subpicture stream in the title.
    DVD_SubpictureAttributes[32] SubpictureAttributes;
}

///The <b>DVD_MenuAttributes</b> structure contains information about a DVD menu. The IDvdInfo2::GetTitleAttributes
///method fills in a DVD_MenuAttributes structure for a specified stream.
struct DVD_MenuAttributes
{
    ///An array of <b>TRUE</b>/<b>FALSE</b> values indicating with which DVD regions the disc's authored region is
    ///compatible. The eight array indexes (numbered 0-7) correspond to the eight DVD regions (numbered 1-8). This array
    ///is only filled in when the menu being queried is the Video Manager Menu (the main menu for the entire disc). <div
    ///class="alert"><b>Important</b> A value of 0 (<b>FALSE</b>) indicates that the region is compatible (permitted). A
    ///value of 1 (<b>TRUE</b>) indicates that the region is not compatible. This member should have been named
    ///<i>fIncompatibleRegion</i>.</div> <div> </div>
    BOOL[8]***          fCompatibleRegion;
    ///A [DVD_VideoAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_videoattributes) structure containing the video
    ///attributes of the menu. This applies to both a VMGM and VTSM.
    DVD_VideoAttributes VideoAttributes;
    ///A variable of type BOOL indicating whether the menu has an audio stream.
    BOOL                fAudioPresent;
    ///A [DVD_AudioAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_audioattributes) structure containing
    ///information about the menu's audio stream. This structure will only be filled in if <i>fAudioPresent</i> is
    ///<b>TRUE</b>.
    DVD_AudioAttributes AudioAttributes;
    ///A variable of type BOOL indicating whether the menu has a subpicture stream.
    BOOL                fSubpicturePresent;
    ///A [DVD_SubpictureAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_subpictureattributes) structure containing
    ///information about the menu's subpicture stream. This structure will only be filled in if
    ///<i>fSubpicturePresent</i> is <b>TRUE</b>.
    DVD_SubpictureAttributes SubpictureAttributes;
}

///The <code>DVD_DECODER_CAPS</code> structure indicates the capabilities of a DVD decoder.
struct DVD_DECODER_CAPS
{
    ///Size of this structure.
    uint   dwSize;
    ///Bitwise <b>OR</b> of flags indicating which audio formats are supported. The following flags are defined. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DVD_AUDIO_CAPS_AC3"></a><a
    ///id="dvd_audio_caps_ac3"></a><dl> <dt><b>DVD_AUDIO_CAPS_AC3</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> Dolby Digital (AC3). </td> </tr> <tr> <td width="40%"><a id="DVD_AUDIO_CAPS_MPEG2"></a><a
    ///id="dvd_audio_caps_mpeg2"></a><dl> <dt><b>DVD_AUDIO_CAPS_MPEG2</b></dt> <dt>0x00000002</dt> </dl> </td> <td
    ///width="60%"> MPEG-2 audio. </td> </tr> <tr> <td width="40%"><a id="DVD_AUDIO_CAPS_LPCM"></a><a
    ///id="dvd_audio_caps_lpcm"></a><dl> <dt><b>DVD_AUDIO_CAPS_LPCM</b></dt> <dt>0x00000004</dt> </dl> </td> <td
    ///width="60%"> Linear pulse code modulation (LPCM). </td> </tr> <tr> <td width="40%"><a
    ///id="DVD_AUDIO_CAPS_DTS"></a><a id="dvd_audio_caps_dts"></a><dl> <dt><b>DVD_AUDIO_CAPS_DTS</b></dt>
    ///<dt>0x00000008</dt> </dl> </td> <td width="60%"> DTS audio. </td> </tr> <tr> <td width="40%"><a
    ///id="DVD_AUDIO_CAPS_SDDS"></a><a id="dvd_audio_caps_sdds"></a><dl> <dt><b>DVD_AUDIO_CAPS_SDDS</b></dt>
    ///<dt>0x00000010</dt> </dl> </td> <td width="60%"> Sony Dynamic Digital Sound (SDDS) audio. </td> </tr> </table>
    uint   dwAudioCaps;
    ///Maximum video data rate in forward direction.
    double dFwdMaxRateVideo;
    ///Maximum audio data rate in forward direction.
    double dFwdMaxRateAudio;
    ///Maximum subpicture data rate in forward direction.
    double dFwdMaxRateSP;
    ///Maximum video data rate in reverse direction. (0 if decoder does not support the smooth reverse mechanism.)
    double dBwdMaxRateVideo;
    ///Maximum audio data rate in reverse direction. (0 if decoder does not support the smooth reverse mechanism.)
    double dBwdMaxRateAudio;
    ///Maximum subpicture data rate in reverse direction. (0 if decoder does not support the smooth reverse mechanism.)
    double dBwdMaxRateSP;
    ///Reserved for future use.
    uint   dwRes1;
    ///Reserved for future use.
    uint   dwRes2;
    ///Reserved for future use.
    uint   dwRes3;
    ///Reserved for future use.
    uint   dwRes4;
}

///The AM_DVD_RENDERSTATUS structure contains codes indicating the status of DVD-Video playback. These codes are used in
///the IDvdGraphBuilder::RenderDvdVideoVolume method.
struct AM_DVD_RENDERSTATUS
{
    ///Overlay/VPE error code. Zero indicates success; any other value is failure.
    HRESULT hrVPEStatus;
    ///<b>TRUE</b> if the specified DVD volume to be played does not exist; <b>FALSE</b> otherwise.
    BOOL    bDvdVolInvalid;
    ///<b>TRUE</b> if no DVD volume is specified or if it isn't found; <b>FALSE</b> otherwise.
    BOOL    bDvdVolUnknown;
    ///<b>TRUE</b> if the video decoder doesn't produce line 21 (closed captioning) data; <b>FALSE</b> otherwise.
    BOOL    bNoLine21In;
    ///<b>TRUE</b> if the video decoder can't be shown as closed captioning on video due to a problem with graph
    ///building; <b>FALSE</b> otherwise.
    BOOL    bNoLine21Out;
    ///Number of DVD streams to render.
    int     iNumStreams;
    ///Number of streams that failed to render.
    int     iNumStreamsFailed;
    ///Combination of [AM_DVD_STREAM_FLAGS](/windows/desktop/api/strmif/ne-strmif-am_dvd_stream_flags) flags indicating
    ///which streams failed.
    uint    dwFailedStreamsFlag;
}

struct BDA_TEMPLATE_CONNECTION
{
    uint FromNodeType;
    uint FromNodePinType;
    uint ToNodeType;
    uint ToNodePinType;
}

struct BDA_TEMPLATE_PIN_JOINT
{
    uint uliTemplateConnection;
    uint ulcInstancesMax;
}

struct KS_BDA_FRAME_INFO
{
    uint ExtendedHeaderSize;
    uint dwFrameFlags;
    uint ulEvent;
    uint ulChannelNumber;
    uint ulSubchannelNumber;
    uint ulReason;
}

struct BDA_ETHERNET_ADDRESS
{
    ubyte[6] rgbAddress;
}

struct BDA_ETHERNET_ADDRESS_LIST
{
    uint ulcAddresses;
    BDA_ETHERNET_ADDRESS[1] rgAddressl;
}

struct BDA_IPv4_ADDRESS
{
    ubyte[4] rgbAddress;
}

struct BDA_IPv4_ADDRESS_LIST
{
    uint                ulcAddresses;
    BDA_IPv4_ADDRESS[1] rgAddressl;
}

struct BDA_IPv6_ADDRESS
{
    ubyte[6] rgbAddress;
}

struct BDA_IPv6_ADDRESS_LIST
{
    uint                ulcAddresses;
    BDA_IPv6_ADDRESS[1] rgAddressl;
}

struct BDANODE_DESCRIPTOR
{
    uint ulBdaNodeType;
    GUID guidFunction;
    GUID guidName;
}

struct BDA_TABLE_SECTION
{
    uint    ulPrimarySectionId;
    uint    ulSecondarySectionId;
    uint    ulcbSectionLength;
    uint[1] argbSectionData;
}

struct BDA_DISEQC_SEND
{
    uint     ulRequestId;
    uint     ulPacketLength;
    ubyte[8] argbPacketData;
}

struct BDA_DISEQC_RESPONSE
{
    uint     ulRequestId;
    uint     ulPacketLength;
    ubyte[8] argbPacketData;
}

struct PID_MAP
{
    uint                 ulPID;
    MEDIA_SAMPLE_CONTENT MediaSampleContent;
}

struct BDA_PID_MAP
{
    MEDIA_SAMPLE_CONTENT MediaSampleContent;
    uint                 ulcPIDs;
    uint[1]              aulPIDs;
}

struct BDA_PID_UNMAP
{
    uint    ulcPIDs;
    uint[1] aulPIDs;
}

struct BDA_CA_MODULE_UI
{
    uint    ulFormat;
    uint    ulbcDesc;
    uint[1] ulDesc;
}

struct BDA_PROGRAM_PID_LIST
{
    uint    ulProgramNumber;
    uint    ulcPIDs;
    uint[1] ulPID;
}

struct BDA_DRM_DRMSTATUS
{
    int     lResult;
    GUID    DRMuuid;
    uint    ulDrmUuidListStringSize;
    GUID[1] argbDrmUuidListString;
}

struct BDA_WMDRM_STATUS
{
    int   lResult;
    uint  ulMaxCaptureTokenSize;
    uint  uMaxStreamingPid;
    uint  ulMaxLicense;
    uint  ulMinSecurityLevel;
    uint  ulRevInfoSequenceNumber;
    ulong ulRevInfoIssuedTime;
    uint  ulRevListVersion;
    uint  ulRevInfoTTL;
    uint  ulState;
}

struct BDA_WMDRM_KEYINFOLIST
{
    int     lResult;
    uint    ulKeyuuidBufferLen;
    GUID[1] argKeyuuidBuffer;
}

struct BDA_BUFFER
{
    int      lResult;
    uint     ulBufferSize;
    ubyte[1] argbBuffer;
}

struct BDA_WMDRM_RENEWLICENSE
{
    int      lResult;
    uint     ulDescrambleStatus;
    uint     ulXmrLicenseOutputLength;
    ubyte[1] argbXmrLicenceOutputBuffer;
}

struct BDA_WMDRMTUNER_PIDPROTECTION
{
    int  lResult;
    GUID uuidKeyID;
}

struct BDA_WMDRMTUNER_PURCHASEENTITLEMENT
{
    int      lResult;
    uint     ulDescrambleStatus;
    uint     ulCaptureTokenLength;
    ubyte[1] argbCaptureTokenBuffer;
}

struct BDA_TUNER_TUNERSTATE
{
    int      lResult;
    uint     ulTuneLength;
    ubyte[1] argbTuneData;
}

struct BDA_TUNER_DIAGNOSTICS
{
    int  lResult;
    uint ulSignalLevel;
    uint ulSignalLevelQuality;
    uint ulSignalNoiseRatio;
}

struct BDA_STRING
{
    int      lResult;
    uint     ulStringSize;
    ubyte[1] argbString;
}

struct BDA_SCAN_CAPABILTIES
{
    int   lResult;
    ulong ul64AnalogStandardsSupported;
}

struct BDA_SCAN_STATE
{
    int  lResult;
    uint ulSignalLock;
    uint ulSecondsLeft;
    uint ulCurrentFrequency;
}

struct BDA_SCAN_START
{
    int  lResult;
    uint LowerFrequency;
    uint HigerFrequency;
}

struct BDA_GDDS_DATATYPE
{
    int  lResult;
    GUID uuidDataType;
}

struct BDA_GDDS_DATA
{
    int      lResult;
    uint     ulDataLength;
    uint     ulPercentageProgress;
    ubyte[1] argbData;
}

struct BDA_USERACTIVITY_INTERVAL
{
    int  lResult;
    uint ulActivityInterval;
}

struct BDA_CAS_CHECK_ENTITLEMENTTOKEN
{
    int  lResult;
    uint ulDescrambleStatus;
}

struct BDA_CAS_CLOSE_MMIDIALOG
{
    int  lResult;
    uint SessionResult;
}

struct BDA_CAS_REQUESTTUNERDATA
{
    ubyte ucRequestPriority;
    ubyte ucRequestReason;
    ubyte ucRequestConsequences;
    uint  ulEstimatedTime;
}

struct BDA_CAS_OPENMMIDATA
{
    uint     ulDialogNumber;
    uint     ulDialogRequest;
    GUID     uuidDialogType;
    ushort   usDialogDataLength;
    ubyte[1] argbDialogData;
}

struct BDA_CAS_CLOSEMMIDATA
{
    uint ulDialogNumber;
}

struct BDA_ISDBCAS_REQUESTHEADER
{
align (1):
    ubyte    bInstruction;
    ubyte[3] bReserved;
    uint     ulDataLength;
    ubyte[1] argbIsdbCommand;
}

struct BDA_ISDBCAS_RESPONSEDATA
{
align (1):
    int      lResult;
    uint     ulRequestID;
    uint     ulIsdbStatus;
    uint     ulIsdbDataSize;
    ubyte[1] argbIsdbCommandData;
}

struct BDA_ISDBCAS_EMG_REQ
{
    ubyte    bCLA;
    ubyte    bINS;
    ubyte    bP1;
    ubyte    bP2;
    ubyte    bLC;
    ubyte[6] bCardId;
    ubyte    bProtocol;
    ubyte    bCABroadcasterGroupId;
    ubyte    bMessageControl;
    ubyte[1] bMessageCode;
}

struct BDA_MUX_PIDLISTITEM
{
align (2):
    ushort       usPIDNumber;
    ushort       usProgramNumber;
    MUX_PID_TYPE ePIDType;
}

struct BDA_TS_SELECTORINFO
{
align (1):
    ubyte     bTSInfolength;
    ubyte[2]  bReserved;
    GUID      guidNetworkType;
    ubyte     bTSIDCount;
    ushort[1] usTSID;
}

struct BDA_TS_SELECTORINFO_ISDBS_EXT
{
    ubyte[48] bTMCC;
}

struct BDA_DVBT2_L1_SIGNALLING_DATA
{
    ubyte    L1Pre_TYPE;
    ubyte    L1Pre_BWT_S1_S2;
    ubyte    L1Pre_REPETITION_GUARD_PAPR;
    ubyte    L1Pre_MOD_COD_FEC;
    ubyte[5] L1Pre_POSTSIZE_INFO_PILOT;
    ubyte    L1Pre_TX_ID_AVAIL;
    ubyte[2] L1Pre_CELL_ID;
    ubyte[2] L1Pre_NETWORK_ID;
    ubyte[2] L1Pre_T2SYSTEM_ID;
    ubyte    L1Pre_NUM_T2_FRAMES;
    ubyte[2] L1Pre_NUM_DATA_REGENFLAG_L1POSTEXT;
    ubyte[2] L1Pre_NUMRF_CURRENTRF_RESERVED;
    ubyte[4] L1Pre_CRC32;
    ubyte[1] L1PostData;
}

struct BDA_RATING_PINRESET
{
    ubyte    bPinLength;
    ubyte[1] argbNewPin;
}

struct MPEG2_TRANSPORT_STRIDE
{
    uint dwOffset;
    uint dwPacketLength;
    uint dwStride;
}

struct BDA_SIGNAL_TIMEOUTS
{
    uint ulCarrierTimeoutMs;
    uint ulScanningTimeoutMs;
    uint ulTuningTimeoutMs;
}

///The EALocationCodeType structure defines an Emergency Alert (EA) location code, as defined in ANSI/SCTE 28.
struct EALocationCodeType
{
    ///Identifies the standard that shall be used to interpret the other members of this structure. Currently this value
    ///must be SCTE_18, meaning SCTE 18, "Emergency Alert Message for Cable."
    LocationCodeSchemeType LocationCodeScheme;
    ///Contains the state_code field.
    ubyte  state_code;
    ///Contains the county_subdivision field.
    ubyte  county_subdivision;
    ///Contains the county_code field.
    ushort county_code;
}

///The <b>SmartCardApplication</b> structure identifies a smart card application.
struct SmartCardApplication
{
    ///Member of the ApplicationTypeType enumeration.
    ApplicationTypeType ApplicationType;
    ///Application version.
    ushort              ApplicationVersion;
    ///Application name.
    BSTR                pbstrApplicationName;
    ///Application URL.
    BSTR                pbstrApplicationURL;
}

///The <b>AMVAUncompBufferInfo</b> structure describes the uncompressed surfaces to be allocated by the video renderer.
struct AMVAUncompBufferInfo
{
    ///Minimum number of surfaces to allocate.
    uint          dwMinNumSurfaces;
    ///Maximum number of surfaces to allocate.
    uint          dwMaxNumSurfaces;
    ///<b>DDPIXELFORMAT</b> structure, describing the pixel format of the allocated surfaces.
    DDPIXELFORMAT ddUncompPixelFormat;
}

///The <b>AMVAUncompDataInfo</b> structure specifies the dimensions and pixel format of the uncompressed surfaces for
///DirectX Video Acceleration (DXVA) video decoding.
struct AMVAUncompDataInfo
{
    ///Width of the decoded, uncompressed data, in pixels.
    uint          dwUncompWidth;
    ///Height of the decoded, uncompressed data, in pixels.
    uint          dwUncompHeight;
    ///A <b>DDPIXELFORMAT</b> structure that specifies the pixel format of the uncompressed data.
    DDPIXELFORMAT ddUncompPixelFormat;
}

///The <b>AMVAInternalMemInfo</b> structure specifies the amount of scratch memory the hardware abstraction layer (HAL)
///will allocate for its private use.
struct AMVAInternalMemInfo
{
    ///Amount of scratch memory the HAL will allocate for its private use.
    uint dwScratchMemAlloc;
}

///The <b>AMVACompBufferInfo</b> structure describes the allocated surfaces and compressed buffer information.
struct AMVACompBufferInfo
{
    ///Number of buffers requested for compressed data.
    uint          dwNumCompBuffers;
    ///Width of surface to create.
    uint          dwWidthToCreate;
    ///Height of surface to create.
    uint          dwHeightToCreate;
    ///Total number of bytes used by each surface.
    uint          dwBytesToAllocate;
    ///<b>DDSCAPS2</b> structure defining the capabilities of the DirectDraw surface created to store compressed data.
    DDSCAPS2      ddCompCaps;
    ///<b>DDPIXELFORMAT</b> structure, describing the pixel format used to create surfaces to store compressed data.
    DDPIXELFORMAT ddPixelFormat;
}

///The <b>AMVABeginFrameInfo</b> structure contains information for the IAMVideoAccelerator::BeginFrame method.
struct AMVABeginFrameInfo
{
    ///The zero-based index of the uncompressed destination surface. The number of uncompressed surfaces is specified in
    ///the IAMVideoAcceleratorNotify::SetUncompSurfacesInfo method.
    uint  dwDestSurfaceIndex;
    ///Pointer to a buffer that contains data for the video accelerator. This buffer must contain a <b>WORD</b> value
    ///that is equal to the value of <b>dwDestSurfaceIndex</b>.
    void* pInputData;
    ///Size, in bytes, of the buffer that <b>pInputData</b> points to. The value must be 2.
    uint  dwSizeInputData;
    ///Pointer to a buffer that the video accelerator can write to. This member must be <b>NULL</b>.
    void* pOutputData;
    ///Size, in bytes, of the buffer that <b>pOutputData</b> points to. The value must be zero.
    uint  dwSizeOutputData;
}

///The <b>AMVAEndFrameInfo</b> structure contains information for the IAMVideoAccelerator::EndFrame method.
struct AMVAEndFrameInfo
{
    ///Size, in bytes, of the buffer that <b>pMiscData</b> points to. The value must be 2.
    uint  dwSizeMiscData;
    ///Pointer to a buffer that contains data for the video accelerator. This buffer must contain a <b>WORD</b> value
    ///equal equal to the same surface index that passed to the corresponding IAMVideoAccelerator::BeginFrame method.
    void* pMiscData;
}

///The <b>AMVABUFFERINFO</b> structure specifies a buffer for the IAMVideoAccelerator::Execute method.
struct AMVABUFFERINFO
{
    ///Type of buffer. The following buffer types are defined. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="DXVA_ALPHA_BLEND_COMBINATION_BUFFER"></a><a
    ///id="dxva_alpha_blend_combination_buffer"></a><dl> <dt><b>DXVA_ALPHA_BLEND_COMBINATION_BUFFER</b></dt> </dl> </td>
    ///<td width="60%"> Alpha blend combination buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA_AYUV_BUFFER"></a><a
    ///id="dxva_ayuv_buffer"></a><dl> <dt><b>DXVA_AYUV_BUFFER</b></dt> </dl> </td> <td width="60%"> AYUV alpha blending
    ///sample buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA_BITSTREAM_DATA_BUFFER"></a><a
    ///id="dxva_bitstream_data_buffer"></a><dl> <dt><b>DXVA_BITSTREAM_DATA_BUFFER</b></dt> </dl> </td> <td width="60%">
    ///Raw bitstream data buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA_DCCMD_SURFACE_BUFFER"></a><a
    ///id="dxva_dccmd_surface_buffer"></a><dl> <dt><b>DXVA_DCCMD_SURFACE_BUFFER</b></dt> </dl> </td> <td width="60%">
    ///Display control command (DCCMD) data buffer. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA_DEBLOCKING_CONTROL_BUFFER"></a><a id="dxva_deblocking_control_buffer"></a><dl>
    ///<dt><b>DXVA_DEBLOCKING_CONTROL_BUFFER</b></dt> </dl> </td> <td width="60%"> Deblocking Filter control command
    ///buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA_DPXD_SURFACE_BUFFER"></a><a
    ///id="dxva_dpxd_surface_buffer"></a><dl> <dt><b>DXVA_DPXD_SURFACE_BUFFER</b></dt> </dl> </td> <td width="60%">
    ///Decoded PXD (DPXD) alpha blending surface buffer. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA_HIGHLIGHT_BUFFER"></a><a id="dxva_highlight_buffer"></a><dl> <dt><b>DXVA_HIGHLIGHT_BUFFER</b></dt> </dl>
    ///</td> <td width="60%"> Highlight data buffers. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA_IA44_SURFACE_BUFFER"></a><a id="dxva_ia44_surface_buffer"></a><dl>
    ///<dt><b>DXVA_IA44_SURFACE_BUFFER</b></dt> </dl> </td> <td width="60%"> IA44 alpha blending sample buffer. </td>
    ///</tr> <tr> <td width="40%"><a id="DXVA_INVERSE_QUANTIZATION_MATRIX_BUFFER"></a><a
    ///id="dxva_inverse_quantization_matrix_buffer"></a><dl> <dt><b>DXVA_INVERSE_QUANTIZATION_MATRIX_BUFFER</b></dt>
    ///</dl> </td> <td width="60%"> Inverse quantization matrix buffer. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA_MACROBLOCK_CONTROL_BUFFER"></a><a id="dxva_macroblock_control_buffer"></a><dl>
    ///<dt><b>DXVA_MACROBLOCK_CONTROL_BUFFER</b></dt> </dl> </td> <td width="60%"> Macroblock control command buffer.
    ///</td> </tr> <tr> <td width="40%"><a id="DXVA_PICTURE_DECODE_BUFFER"></a><a
    ///id="dxva_picture_decode_buffer"></a><dl> <dt><b>DXVA_PICTURE_DECODE_BUFFER</b></dt> </dl> </td> <td width="60%">
    ///Picture parameters buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA_PICTURE_RESAMPLE_BUFFER"></a><a
    ///id="dxva_picture_resample_buffer"></a><dl> <dt><b>DXVA_PICTURE_RESAMPLE_BUFFER</b></dt> </dl> </td> <td
    ///width="60%"> Alpha blend combination buffer. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA_READ_BACK_BUFFER"></a><a id="dxva_read_back_buffer"></a><dl> <dt><b>DXVA_READ_BACK_BUFFER</b></dt> </dl>
    ///</td> <td width="60%"> Read-back command buffers containing commands to read macroblocks of the resulting picture
    ///back to the host. </td> </tr> <tr> <td width="40%"><a id="DXVA_RESIDUAL_DIFFERENCE_BUFFER"></a><a
    ///id="dxva_residual_difference_buffer"></a><dl> <dt><b>DXVA_RESIDUAL_DIFFERENCE_BUFFER</b></dt> </dl> </td> <td
    ///width="60%"> Residual difference block data buffer. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA_SLICE_CONTROL_BUFFER"></a><a id="dxva_slice_control_buffer"></a><dl>
    ///<dt><b>DXVA_SLICE_CONTROL_BUFFER</b></dt> </dl> </td> <td width="60%"> Slice control buffer. </td> </tr> </table>
    ///For complete descriptions of these buffer types, refer to the DirectX Video Acceleration 1.0 specification.
    uint dwTypeIndex;
    ///Buffer index.
    uint dwBufferIndex;
    ///The offset of the relevant data from the beginning of the buffer.
    uint dwDataOffset;
    ///Size of the relevant data in the buffer, in bytes.
    uint dwDataSize;
}

///The AM_WST_PAGE structure identifies a World Standard Teletext (WST) page.
struct AM_WST_PAGE
{
    ///The page number.
    uint   dwPageNr;
    ///The sub-page number.
    uint   dwSubPageNr;
    ///A pointer to the page data.
    ubyte* pucPageData;
}

///The <b>TRUECOLORINFO</b> structure contains color palette and bitmask information for a video image.
struct TRUECOLORINFO
{
    ///Array of color masks (one per color element).
    uint[3]      dwBitMasks;
    ///Array of palette colors.
    RGBQUAD[256] bmiColors;
}

///The <b>VIDEOINFOHEADER</b> structure describes the bitmap and color information for a video image.
struct VIDEOINFOHEADER
{
    ///A RECT structure that specifies the source video window. This structure can be a clipping rectangle, to select a
    ///portion of the source video stream.
    RECT             rcSource;
    ///A RECT structure that specifies the destination video window.
    RECT             rcTarget;
    ///Approximate data rate of the video stream, in bits per second.
    uint             dwBitRate;
    ///Data error rate, in bit errors per second.
    uint             dwBitErrorRate;
    ///The desired average display time of the video frames, in 100-nanosecond units. The actual time per frame may be
    ///longer. See Remarks.
    long             AvgTimePerFrame;
    ///BITMAPINFOHEADER structure that contains color and dimension information for the video image bitmap. If the
    ///format block contains a color table or color masks, they immediately follow the <b>bmiHeader</b> member. You can
    ///get the first color entry by casting the address of member to a <b>BITMAPINFO</b> pointer. When used inside a
    ///<b>VIDEOINFOHEADER</b> structure, the semantics of the BITMAPINFOHEADER structure differ slightly from how the
    ///structure is used in GDI. For more information, refer to the topic BITMAPINFOHEADER Structure.
    BITMAPINFOHEADER bmiHeader;
}

///The <b>VIDEOINFO</b> structure is equivalent to a VIDEOINFOHEADER structure, but it contains enough memory to hold
///three color masks plus a color table with 256 colors. If you are writing a video filter, you can use this structure
///to guarantee that the format block always has enough memory to contain the largest possible VIDEOINFOHEADER
///structure.
struct VIDEOINFO
{
    ///Portion of the input video to use.
    RECT             rcSource;
    ///Where the video should be displayed.
    RECT             rcTarget;
    ///Approximate data rate in bits per second.
    uint             dwBitRate;
    ///Bit error rate for this stream.
    uint             dwBitErrorRate;
    ///The desired average time per frame, in 100-nanosecond units. For more information, see the Remarks section for
    ///the VIDEOINFOHEADER structure.
    long             AvgTimePerFrame;
    ///BITMAPINFOHEADER structure that contains color and dimension information for a device-independent bitmap.
    BITMAPINFOHEADER bmiHeader;
    union
    {
        RGBQUAD[256]  bmiColors;
        uint[3]       dwBitMasks;
        TRUECOLORINFO TrueColorInfo;
    }
}

///The <b>MPEG1VIDEOINFO</b> structure describes an MPEG-1 video stream.
struct MPEG1VIDEOINFO
{
    ///VIDEOINFOHEADER structure.
    VIDEOINFOHEADER hdr;
    ///25-bit group-of-pictures (GOP) time code at start of data.
    uint            dwStartTimeCode;
    ///Length of the <b>bSequenceHeader</b> member, in bytes.
    uint            cbSequenceHeader;
    ///Start of an array that contains the sequence header, including quantization matrices, if any. The size of the
    ///array is given in the <b>cbSequenceHeader</b> member.
    ubyte[1]        bSequenceHeader;
}

///The <b>ANALOGVIDEOINFO</b> structure maintains information about the format of the analog video signal.
struct ANALOGVIDEOINFO
{
    ///Source video rectangle.
    RECT rcSource;
    ///Destination target rectangle.
    RECT rcTarget;
    ///Source video width.
    uint dwActiveWidth;
    ///Source video height (483 for NTSC, 575 for PAL/SECAM).
    uint dwActiveHeight;
    ///Average time per frame in 100-nanosecond units.
    long AvgTimePerFrame;
}

///Specifies the number of frames to step.
struct AM_FRAMESTEP_STEP
{
    ///<b>DWORD</b> value specifying to the decoder the number of frames to step. Must be at least 1. If greater than 1,
    ///this instruction means to skip <i>n</i> - 1 frames and show the <i>n</i>th.
    uint dwFramesToStep;
}

struct OPTIMAL_WEIGHT_TOTALS
{
    long MinTotalNominator;
    long MaxTotalNominator;
    long TotalDenominator;
}

struct IKsPin
{
}

struct IKsAllocator
{
}

struct IKsAllocatorEx
{
}

struct PIPE_DIMENSIONS
{
    KS_COMPRESSION AllocatorPin;
    KS_COMPRESSION MaxExpansionPin;
    KS_COMPRESSION EndPin;
}

struct PIPE_TERMINATION
{
    uint             Flags;
    uint             OutsideFactors;
    uint             Weigth;
    KS_FRAMING_RANGE PhysicalRange;
    KS_FRAMING_RANGE_WEIGHTED OptimalRange;
    KS_COMPRESSION   Compression;
}

struct ALLOCATOR_PROPERTIES_EX
{
    int                  cBuffers;
    int                  cbBuffer;
    int                  cbAlign;
    int                  cbPrefix;
    GUID                 MemoryType;
    GUID                 BusType;
    PIPE_STATE           State;
    PIPE_TERMINATION     Input;
    PIPE_TERMINATION     Output;
    uint                 Strategy;
    uint                 Flags;
    uint                 Weight;
    KS_LogicalMemoryType LogicalMemoryType;
    PIPE_ALLOCATOR_PLACE AllocatorPlace;
    PIPE_DIMENSIONS      Dimensions;
    KS_FRAMING_RANGE     PhysicalRange;
    IKsAllocatorEx*      PrevSegment;
    uint                 CountNextSegments;
    IKsAllocatorEx**     NextSegments;
    uint                 InsideFactors;
    uint                 NumberPins;
}

///The <b>AM_MPEGSTREAMTYPE</b> structure defines the media type for an MPEG-1 program stream.
struct AM_MPEGSTREAMTYPE
{
    ///Stream identifier of the stream to process.
    uint          dwStreamId;
    ///Reserved.
    uint          dwReserved;
    ///AM_MEDIA_TYPE structure describing the type for the substeam. The <b>pbFormat</b> member of this structure must
    ///<b>NULL</b>. The format data normally conveyed in <b>pbFormat</b> is stored in the <b>bFormat</b> member.
    AM_MEDIA_TYPE mt;
    ///Format data. The size of this array, in bytes, is given in the <b>mt.cbFormat</b> member.
    ubyte[1]      bFormat;
}

///The <b>AM_MPEGSYSTEMTYPE</b> structure defines the format block for an MPEG-1 system stream. This structure is used
///when the <b>formattype</b> member of the AM_MEDIA_TYPE structure is FORMAT_MPEG1System.
struct AM_MPEGSYSTEMTYPE
{
    ///Bits per second.
    uint                 dwBitRate;
    ///Number of streams.
    uint                 cStreams;
    ///List AM_MPEGSTREAMTYPE structures that describe the elementary streams. The number of elements in the list is
    ///given by the <b>cStream</b> member. The size of each <b>AM_MPEGSTREAMTYPE</b> structure is variable. Use the
    ///<b>AM_MPEGSTREAMTYPE_ELEMENTLENGTH</b> macro to calculate the size of each structure.
    AM_MPEGSTREAMTYPE[1] Streams;
}

///The <code>VMR9PresentationInfo</code> structure is used with the VMR-9 in the IVMRImagePresenter9::PresentImage
///method.
struct VMR9PresentationInfo
{
    ///Contains a bitwise combintation of flags from the VMR9PresentationFlags enumeration type. These flags describe
    ///the status of the video sample with respect to its presentation time.
    uint              dwFlags;
    ///Pointer to the DirectDraw surface that contains the video frame.
    IDirect3DSurface9 lpSurf;
    ///Specifies the start time for the video frame.
    long              rtStart;
    ///Specifies the end time for the video frame
    long              rtEnd;
    ///Specifies the aspect ratio of the video, as a <b>SIZE</b> structure.
    SIZE              szAspectRatio;
    ///Specifies the source rectangle.
    RECT              rcSrc;
    ///Specifies the destination rectangle.
    RECT              rcDst;
    ///Reserved.
    uint              dwReserved1;
    ///Reserved.
    uint              dwReserved2;
}

///The <b>VMR9AllocationInfo</b> structure describes the Direct3D surfaces that a VMR-9 Allocator-Presenter object
///should allocate.
struct VMR9AllocationInfo
{
    ///Specifies a bitwise combination of flags from the VMR9SurfaceAllocationFlags enumeration type.
    uint      dwFlags;
    ///Specifies the width of the surfaces.
    uint      dwWidth;
    ///Specifies the height of the surfaces.
    uint      dwHeight;
    ///Specifies the surface format, as a <b>D3DFORMAT</b> type. The value D3DFMT_UNKNOWN (zero) indicates that the
    ///surface format should be compatible with the display.
    D3DFORMAT Format;
    ///Specifies the Direct3D memory pool to use for the surfaces, as a <b>D3DPOOL</b> type.
    D3DPOOL   Pool;
    ///Specifies the minimum number of buffers to create.
    uint      MinBuffers;
    ///Specifies the video aspect ratio as a <b>SIZE</b> structure.
    SIZE      szAspectRatio;
    ///Specifies the native video size as a <b>SIZE</b> structure.
    SIZE      szNativeSize;
}

///The <code>VMR9NormalizedRect</code> structure is used with the VMR-9 filter in mixing operations to specify or
///retrieve the location of a video rectangle in composition space.
struct VMR9NormalizedRect
{
    ///Specifies left.
    float left;
    ///Specifies top.
    float top;
    ///Specifies right.
    float right;
    ///Specifies bottom.
    float bottom;
}

///The <code>VMR9ProcAmpControl</code> structure specifies the image adjustments to be performed on a video stream. This
///structure is used with the Video Mixing Renderer Filter 9 (VMR-9).
struct VMR9ProcAmpControl
{
    ///Size of the structure, in bytes. The value must be <code>sizeof(VMR9ProcAmpControl)</code>.
    uint  dwSize;
    ///Bitwise combination of flags from the VMR9ProcAmpControlFlags enumeration, indicating which properties the driver
    ///supports.
    uint  dwFlags;
    ///Specifies the image brightness. Brightness, also called black-level setup, specifies the viewing black level.
    ///Functionally, it adds or subtracts the same number of quantizing steps (bits) from all the luminance words in a
    ///picture.
    float Brightness;
    ///Specifies the image contrast. Contrast alters the relative light-to-dark values in a picture. Functionally it
    ///maps the range of input values to a smaller or larger range of output values.
    float Contrast;
    ///Specifies the image hue. Perceptually, hue corresponds approximately to "color." Functionally, hue is a phase
    ///relationship of the chrominance components. It is specified in degrees, with a nominal valid range from –180 to
    ///180 degrees and a default value of 0.
    float Hue;
    ///Specifies the image saturation. Saturation alters the color intensity of the image. Functionally it is similar to
    ///contrast, but operates on the chroma components of the image.
    float Saturation;
}

///The <code>VMR9ProcAmpControlRange</code> structure specifies the valid range for an image adjustment property. The
///range depends on the graphics device driver. This structure is used with the Video Mixing Renderer 9 Filter (VMR-9).
struct VMR9ProcAmpControlRange
{
    ///Size of the structure, in bytes. The value must be <code>sizeof(VMR9ProcAmpControlRange)</code>.
    uint  dwSize;
    ///Specifies the image adjustment property to query, as a member of the VMR9ProcAmpControlFlags enumeration. The
    ///caller should set this field.
    VMR9ProcAmpControlFlags dwProperty;
    ///Specifies the minimum value for the property. The driver sets this field.
    float MinValue;
    ///Specifies the maximum value for the property. The driver sets this field.
    float MaxValue;
    ///Specifies the default value for the property. The default value is the value that does not alter the image. The
    ///driver sets this field.
    float DefaultValue;
    ///Specifies the valid increments from <b>MinValue</b> to <b>MaxValue</b>. The driver sets this field.
    float StepSize;
}

///The <b>VMR9AlphaBitmap</b> structure is used with the IVMRMixerBitmap9 interface when an application provides a
///static bitmap for alpha blending with the video frame.
struct VMR9AlphaBitmap
{
    ///Bitwise <b>OR</b> of flags from the VMR9AlphaBitmapFlags enumeration type.
    uint               dwFlags;
    ///Handle to the GDI device context (HDC) for the bitmap. If this member contains a non-<b>NULL</b> value, set
    ///<b>pDDS</b> to <b>NULL</b> and set the <b>VMR9AlphaBitmap_hDC</b> flag in the <b>dwFlags</b> member. The device
    ///context is not compatible with GDI+.
    HDC                hdc;
    ///Pointer to the <b>IDirect3DSurface9</b> interface of a Direct3D surface that contains the bitmap. If this member
    ///contains a valid pointer, set the <b>hdc</b> member to <b>NULL</b>. The surface format must be
    ///<b>D3DFMT_X8R8G8B8</b> (32-bit RGB) or <b>D3DFMT_A8R8G8B8</b> (32-bit RGB with per-pixel alpha). The surface must
    ///be allocated from the <b>D3DPOOL_SYSTEMMEM</b> pool.
    IDirect3DSurface9  pDDS;
    ///Specifies the rectangle to copy from the source image. This rectangle is specified relative to the GDI device
    ///context or the DirectDraw surface. When calling IVMRMixerBitmap9::SetAlphaBitmap, the source rectangle must be
    ///valid if a GDI bitmap is specified in the <b>hdc</b> member. On the other hand, if a Direct3D surface is
    ///specified in the <b>pDDS</b> member, then you can either set <b>rSrc</b> to a valid rectangle, or use the entire
    ///surface by setting the VMR9AlphaBitmap_EntireDDS flag in <b>dwFlags</b>. When calling
    ///IVMRMixerBitmap9::UpdateAlphaBitmapParameters, <b>rSrc</b> is always optional, and is used if <b>dwFlags</b>
    ///contains the VMR9AlphaBitmap_SrcRect flag.
    RECT               rSrc;
    ///Specifies the destination rectangle in composition space.
    VMR9NormalizedRect rDest;
    ///Specifies the alpha blending value; must be a value from 0.0 to 1.0 (inclusive).
    float              fAlpha;
    ///Specifies the source color key. This value is used if the <b>dwFlags</b> member contains the
    ///<b>VMR9AlphaBitmap_SrcColorKey</b>. A color key cannot be used with a Direct3D surface that contains per-pixel
    ///alpha.
    uint               clrSrcKey;
    ///One of the following flags from the VMR9MixerPrefs enumeration, or zero to specify no filtering. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MixerPref9_BiLinearFiltering"></a><a
    ///id="mixerpref9_bilinearfiltering"></a><a id="MIXERPREF9_BILINEARFILTERING"></a><dl>
    ///<dt><b>MixerPref9_BiLinearFiltering</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> Bilinear
    ///interpolation filtering. </td> </tr> <tr> <td width="40%"><a id="MixerPref9_PointFiltering"></a><a
    ///id="mixerpref9_pointfiltering"></a><a id="MIXERPREF9_POINTFILTERING"></a><dl>
    ///<dt><b>MixerPref9_PointFiltering</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> Point filtering. </td>
    ///</tr> <tr> <td width="40%"><a id="MixerPref9_AnisotropicFiltering"></a><a
    ///id="mixerpref9_anisotropicfiltering"></a><a id="MIXERPREF9_ANISOTROPICFILTERING"></a><dl>
    ///<dt><b>MixerPref9_AnisotropicFiltering</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> Anisotropic
    ///filtering. </td> </tr> <tr> <td width="40%"><a id="_MixerPref9_PyramidalQuadFiltering"></a><a
    ///id="_mixerpref9_pyramidalquadfiltering"></a><a id="_MIXERPREF9_PYRAMIDALQUADFILTERING"></a><dl> <dt><b>
    ///MixerPref9_PyramidalQuadFiltering</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> Four-sample tent
    ///filtering. </td> </tr> <tr> <td width="40%"><a id="MixerPref9_GaussianQuadFiltering"></a><a
    ///id="mixerpref9_gaussianquadfiltering"></a><a id="MIXERPREF9_GAUSSIANQUADFILTERING"></a><dl>
    ///<dt><b>MixerPref9_GaussianQuadFiltering</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> Four-sample
    ///Gaussian filtering. </td> </tr> </table> This structure member is used only if the <b>dwFlags</b> member contains
    ///the <b>VMR9AlphaBitmap_FilterMode</b> flag. Point filtering is particularly useful for images that contain text
    ///and do not need to be stretched prior to mixing.
    uint               dwFilterMode;
}

///The <code>VMR9MonitorInfo</code> structure is used with the VMR-9 in the IVMRMonitorConfig9::GetAvailableMonitors
///method to set and retrieve information about monitors on the system.
struct VMR9MonitorInfo
{
    ///Integer index that specifies the monitor device.
    uint          uDevID;
    ///Specifies the monitor's rectangle.
    RECT          rcMonitor;
    ///Handle to the monitor.
    ptrdiff_t     hMon;
    ///Flags as defined for the MONITORINFOEX structure. Currently the only valid flag is <b>MONITORINFOF_PRIMARY</b>,
    ///which indicates the primary display monitor.
    uint          dwFlags;
    ///Null-terminated string containing the device name.
    ushort[32]    szDevice;
    ///Null-terminated string containing a description of the device.
    ushort[512]   szDescription;
    ///Specifies the driver version.
    LARGE_INTEGER liDriverVersion;
    ///Specifies the vendor.
    uint          dwVendorId;
    ///Specifies the device ID.
    uint          dwDeviceId;
    ///Specifies the device subsystem.
    uint          dwSubSysId;
    ///Specifies the revision number.
    uint          dwRevision;
}

///The <code>VMR9Frequency</code> structure describes the frequency of a video stream. Frequencies are described as
///ratios. For example, the NTSC frame rate of 29.97 fps is expressed as 30,000:1001.
struct VMR9Frequency
{
    ///Numerator of the frequency ratio.
    uint dwNumerator;
    ///Denominator of the frequency ratio.
    uint dwDenominator;
}

///The <code>VMR9VideoDesc</code> structure describes a video stream to be deinterlaced.
struct VMR9VideoDesc
{
    ///Size of the structure, in bytes.
    uint              dwSize;
    ///Width of the video to be deinterlaced, in pixels.
    uint              dwSampleWidth;
    ///Height of the video to be deinterlaced, in pixels.
    uint              dwSampleHeight;
    ///Specifies the interlacing format of the sample, as a member of the VMR9_SampleFormat enumeration.
    VMR9_SampleFormat SampleFormat;
    ///Specifies the FOURCC code. Valid values include NV12, YV12, YUY2, UYVY, IMC1, IMC2, IMC3 and IMC4
    uint              dwFourCC;
    ///A VMR9Frequency structure that specifies the input frequency. For NTSC TV, the frequency would be expressed as
    ///30,000:1001.
    VMR9Frequency     InputSampleFreq;
    ///A VMRFrequency structure that specifies the output frequency. For NTSC TV, the frequency would be expressed as
    ///60,000:1001.
    VMR9Frequency     OutputFrameFreq;
}

///The <code>VMR9DeinterlaceCaps</code> structure describes the capabilities of a deinterlacing mode.
struct VMR9DeinterlaceCaps
{
    ///Size of the structure, in bytes.
    uint                dwSize;
    ///Number of previously de-interlaced frames that must be fed back to the hardware to deinterlace the next field.
    ///(Used by recursive deinterlacing algorithms.)
    uint                dwNumPreviousOutputFrames;
    ///Number of future samples needed to deinterlace the current field.
    uint                dwNumForwardRefSamples;
    ///Number of past samples needed to deinterlace the current field.
    uint                dwNumBackwardRefSamples;
    ///Bitwise combination of flags from the VMR9DeinterlaceTech enumeration type. These flags are used to describe the
    ///deinterlacing algorithm.
    VMR9DeinterlaceTech DeinterlaceTechnology;
}

///The <code>VMR9VideoStreamInfo</code> structure describes the rendering parameters for a video compositing operation
///in the VRM-9 filter. This structure is used in the IVMRImageCompositor9::CompositeImage method.
struct VMR9VideoStreamInfo
{
    ///A pointer to the IDirect3DSurface9 interface of the Direct3D surface that contains the video to be composited.
    IDirect3DSurface9  pddsVideoSurface;
    ///The width of the video rectangle.
    uint               dwWidth;
    ///The height of the video rectangle.
    uint               dwHeight;
    ///Specifies the input stream. This value corresponds to the input pin.
    uint               dwStrmID;
    ///The alpha value for this stream. (Not per-pixel alpha.)
    float              fAlpha;
    ///The position of the image in composition space, as a VMR9NormalizedRect structure.
    VMR9NormalizedRect rNormal;
    ///The start time of the video frame, in 100-nanosecond units.
    long               rtStart;
    ///The end time of the video frame, in 100-nanosecond units.
    long               rtEnd;
    ///The video interlacing format, specified as a member of the VMR9_SampleFormat enumeration type.
    VMR9_SampleFormat  SampleFormat;
}

struct _riffchunk
{
align (2):
    uint fcc;
    uint cb;
}

struct _rifflist
{
align (2):
    uint fcc;
    uint cb;
    uint fccListType;
}

///The <b>AVIMAINHEADER</b> structure defines global information in an AVI file.
struct AVIMAINHEADER
{
align (2):
    ///Specifies a FOURCC code. The value must be 'avih'.
    uint    fcc;
    ///Specifies the size of the structure, not including the initial 8 bytes.
    uint    cb;
    ///Specifies the number of microseconds between frames. This value indicates the overall timing for the file.
    uint    dwMicroSecPerFrame;
    ///Specifies the approximate maximum data rate of the file. This value indicates the number of bytes per second the
    ///system must handle to present an AVI sequence as specified by the other parameters contained in the main header
    ///and stream header chunks.
    uint    dwMaxBytesPerSec;
    ///Specifies the alignment for data, in bytes. Pad the data to multiples of this value.
    uint    dwPaddingGranularity;
    ///Contains a bitwise combination of zero or more of the following flags: <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="AVIF_COPYRIGHTED"></a><a id="avif_copyrighted"></a><dl>
    ///<dt><b>AVIF_COPYRIGHTED</b></dt> </dl> </td> <td width="60%"> Indicates the AVI file contains copyrighted data
    ///and software. When this flag is used, software should not permit the data to be duplicated. </td> </tr> <tr> <td
    ///width="40%"><a id="AVIF_HASINDEX"></a><a id="avif_hasindex"></a><dl> <dt><b>AVIF_HASINDEX</b></dt> </dl> </td>
    ///<td width="60%"> Indicates the AVI file has an index. </td> </tr> <tr> <td width="40%"><a
    ///id="AVIF_ISINTERLEAVED"></a><a id="avif_isinterleaved"></a><dl> <dt><b>AVIF_ISINTERLEAVED</b></dt> </dl> </td>
    ///<td width="60%"> Indicates the AVI file is interleaved. </td> </tr> <tr> <td width="40%"><a
    ///id="AVIF_MUSTUSEINDEX"></a><a id="avif_mustuseindex"></a><dl> <dt><b>AVIF_MUSTUSEINDEX</b></dt> </dl> </td> <td
    ///width="60%"> Indicates that application should use the index, rather than the physical ordering of the chunks in
    ///the file, to determine the order of presentation of the data. For example, this flag could be used to create a
    ///list of frames for editing. </td> </tr> <tr> <td width="40%"><a id="AVIF_WASCAPTUREFILE"></a><a
    ///id="avif_wascapturefile"></a><dl> <dt><b>AVIF_WASCAPTUREFILE</b></dt> </dl> </td> <td width="60%"> Indicates the
    ///AVI file is a specially allocated file used for capturing real-time video. Applications should warn the user
    ///before writing over a file with this flag set because the user probably defragmented this file. </td> </tr>
    ///</table>
    uint    dwFlags;
    ///Specifies the total number of frames of data in the file.
    uint    dwTotalFrames;
    ///Specifies the initial frame for interleaved files. Noninterleaved files should specify zero. If you are creating
    ///interleaved files, specify the number of frames in the file prior to the initial frame of the AVI sequence in
    ///this member. To give the audio driver enough audio to work with, the audio data in an interleaved file must be
    ///skewed from the video data. Typically, the audio data should be moved forward enough frames to allow
    ///approximately 0.75 seconds of audio data to be preloaded. The <b>dwInitialRecords</b> member should be set to the
    ///number of frames the audio is skewed. Also set the same value for the <b>dwInitialFrames</b> member of the
    ///AVISTREAMHEADER structure in the audio stream header.
    uint    dwInitialFrames;
    ///Specifies the number of streams in the file. For example, a file with audio and video has two streams.
    uint    dwStreams;
    ///Specifies the suggested buffer size for reading the file. Generally, this size should be large enough to contain
    ///the largest chunk in the file. If set to zero, or if it is too small, the playback software will have to
    ///reallocate memory during playback, which will reduce performance. For an interleaved file, the buffer size should
    ///be large enough to read an entire record, and not just a chunk.
    uint    dwSuggestedBufferSize;
    ///Specifies the width of the AVI file in pixels.
    uint    dwWidth;
    ///Specifies the height of the AVI file in pixels.
    uint    dwHeight;
    ///Reserved. Set this array to zero.
    uint[4] dwReserved;
}

struct _aviextheader
{
align (2):
    uint     fcc;
    uint     cb;
    uint     dwGrandFrames;
    uint[61] dwFuture;
}

///The <b>AVISTREAMHEADER</b> structure contains information about one stream in an AVI file.
struct AVISTREAMHEADER
{
align (2):
    ///Specifies a FOURCC code. The value must be 'strh'.
    uint   fcc;
    ///Specifies the size of the structure, not including the initial 8 bytes.
    uint   cb;
    ///Contains a FOURCC that specifies the type of the data contained in the stream. The following standard AVI values
    ///for video and audio are defined. <table> <tr> <th>FOURCC</th> <th>Description</th> </tr> <tr> <td width="40%"><a
    ///id="_auds_"></a><a id="_AUDS_"></a><dl> <dt><b>'auds'</b></dt> </dl> </td> <td width="60%"> Audio stream </td>
    ///</tr> <tr> <td width="40%"><a id="_mids_"></a><a id="_MIDS_"></a><dl> <dt><b>'mids'</b></dt> </dl> </td> <td
    ///width="60%"> MIDI stream </td> </tr> <tr> <td width="40%"><a id="_txts_"></a><a id="_TXTS_"></a><dl>
    ///<dt><b>'txts'</b></dt> </dl> </td> <td width="60%"> Text stream </td> </tr> <tr> <td width="40%"><a
    ///id="_vids_"></a><a id="_VIDS_"></a><dl> <dt><b>'vids'</b></dt> </dl> </td> <td width="60%"> Video stream </td>
    ///</tr> </table>
    uint   fccType;
    ///Optionally, contains a FOURCC that identifies a specific data handler. The data handler is the preferred handler
    ///for the stream. For audio and video streams, this specifies the codec for decoding the stream.
    uint   fccHandler;
    ///Contains any flags for the data stream. The bits in the high-order word of these flags are specific to the type
    ///of data contained in the stream. The following standard flags are defined. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="AVISF_DISABLED"></a><a id="avisf_disabled"></a><dl>
    ///<dt><b>AVISF_DISABLED</b></dt> </dl> </td> <td width="60%"> Indicates this stream should not be enabled by
    ///default. </td> </tr> <tr> <td width="40%"><a id="AVISF_VIDEO_PALCHANGES"></a><a
    ///id="avisf_video_palchanges"></a><dl> <dt><b>AVISF_VIDEO_PALCHANGES</b></dt> </dl> </td> <td width="60%">
    ///Indicates this video stream contains palette changes. This flag warns the playback software that it will need to
    ///animate the palette. </td> </tr> </table>
    uint   dwFlags;
    ///Specifies priority of a stream type. For example, in a file with multiple audio streams, the one with the highest
    ///priority might be the default stream.
    ushort wPriority;
    ///Language tag.
    ushort wLanguage;
    ///Specifies how far audio data is skewed ahead of the video frames in interleaved files. Typically, this is about
    ///0.75 seconds. If you are creating interleaved files, specify the number of frames in the file prior to the
    ///initial frame of the AVI sequence in this member. For more information, see the remarks for the
    ///<b>dwInitialFrames</b> member of the AVIMAINHEADER structure.
    uint   dwInitialFrames;
    ///Used with <b>dwRate</b> to specify the time scale that this stream will use. Dividing <b>dwRate</b> by
    ///<b>dwScale</b> gives the number of samples per second. For video streams, this is the frame rate. For audio
    ///streams, this rate corresponds to the time needed to play <b>nBlockAlign</b> bytes of audio, which for PCM audio
    ///is the just the sample rate.
    uint   dwScale;
    ///See <b>dwScale</b>.
    uint   dwRate;
    ///Specifies the starting time for this stream. The units are defined by the <b>dwRate</b> and <b>dwScale</b>
    ///members in the main file header. Usually, this is zero, but it can specify a delay time for a stream that does
    ///not start concurrently with the file.
    uint   dwStart;
    ///Specifies the length of this stream. The units are defined by the <b>dwRate</b> and <b>dwScale</b> members of the
    ///stream's header.
    uint   dwLength;
    ///Specifies how large a buffer should be used to read this stream. Typically, this contains a value corresponding
    ///to the largest chunk present in the stream. Using the correct buffer size makes playback more efficient. Use zero
    ///if you do not know the correct buffer size.
    uint   dwSuggestedBufferSize;
    ///Specifies an indicator of the quality of the data in the stream. Quality is represented as a number between 0 and
    ///10,000. For compressed data, this typically represents the value of the quality parameter passed to the
    ///compression software. If set to –1, drivers use the default quality value.
    uint   dwQuality;
    ///Specifies the size of a single sample of data. This is set to zero if the samples can vary in size. If this
    ///number is nonzero, then multiple samples of data can be grouped into a single chunk within the file. If it is
    ///zero, each sample of data (such as a video frame) must be in a separate chunk. For video streams, this number is
    ///typically zero, although it can be nonzero if all video frames are the same size. For audio streams, this number
    ///should be the same as the <b>nBlockAlign</b> member of the WAVEFORMATEX structure describing the audio.
    uint   dwSampleSize;
    struct rcFrame
    {
        short left;
        short top;
        short right;
        short bottom;
    }
}

///The <b>AVIOLDINDEX</b> structure describes an AVI 1.0 index ('idx1' format). New AVI files should use an AVI 2.0
///index ('indx' format).
struct AVIOLDINDEX
{
align (2):
    ///Specifies a FOURCC code. The value must be 'idx1'.
    uint fcc;
    ///Specifies the size of the structure, not including the initial 8 bytes.
    uint cb;
    struct aIndex
    {
    align (2):
        uint dwChunkId;
        uint dwFlags;
        uint dwOffset;
        uint dwSize;
    }
}

struct _timecodedata
{
align (2):
    TIMECODE time;
    uint     dwSMPTEflags;
    uint     dwUser;
}

///The base structure for an AVI 2.0 index ('indx' format).
struct AVIMETAINDEX
{
align (2):
    ///A <b>FOURCC</b> code. The value is either 'indx' or '<i>nn</i>ix', where <i>nn</i> is the stream number.
    uint    fcc;
    ///The size of the structure, not including the initial 8 bytes.
    uint    cb;
    ///The size of each index entry, in 4-byte units.
    ushort  wLongsPerEntry;
    ///The index subtype. The meaning depends on the value of <b>bIndexType</b>.
    ubyte   bIndexSubType;
    ///The index type. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="AVI_INDEX_OF_INDEXES"></a><a id="avi_index_of_indexes"></a><dl> <dt><b>AVI_INDEX_OF_INDEXES</b></dt>
    ///<dt>0x00</dt> </dl> </td> <td width="60%"> Each index entry points to another index. Treat the
    ///<b>AVIMETAINDEX</b> structure as an AVISUPERINDEX structure. The value of <b>bIndexSubType</b> must be zero.
    ///</td> </tr> <tr> <td width="40%"><a id="AVI_INDEX_OF_CHUNKS"></a><a id="avi_index_of_chunks"></a><dl>
    ///<dt><b>AVI_INDEX_OF_CHUNKS</b></dt> <dt>0x01</dt> </dl> </td> <td width="60%"> Each index entry points to a data
    ///chunk in the file. <ul> <li>If <b>bIndexSubType</b> is 0, treat the <b>AVIMETAINDEX</b> structure as an
    ///AVISTDINDEX structure. Each index entry is an AVISTDINDEX_ENTRY structure.</li> <li>If <b>bIndexSubType</b> is
    ///<b>AVI_INDEX_SUB_2FIELD</b>, the index is a field index chunk.<div class="alert"><b>Note</b> DirectShow does not
    ///support field indexes.</div> <div> </div> </li> </ul> </td> </tr> <tr> <td width="40%"><a
    ///id="AVI_INDEX_IS_DATA"></a><a id="avi_index_is_data"></a><dl> <dt><b>AVI_INDEX_IS_DATA</b></dt> <dt>0x80</dt>
    ///</dl> </td> <td width="60%"> The <b>adwIndex</b> array contains a table of data, not a list of index entries.
    ///</td> </tr> </table>
    ubyte   bIndexType;
    ///The number of valid entries in the <b>adwIndex</b> array.
    uint    nEntriesInUse;
    ///A <b>FOURCC</b> that identifies the object that is indexed. If the indexed object is a stream, this member has
    ///the same meaning as the <b>dwChunkId</b> member of the AVIOLDINDEX structure.
    uint    dwChunkId;
    ///The meaning of this member depends on the index type.
    uint[3] dwReserved;
    ///An array of index entries. The format of this data depends on the index type.
    uint    adwIndex;
}

///Contains an AVI 2.0 super index (index of indexes).
struct AVISUPERINDEX
{
align (2):
    ///A <b>FOURCC</b> code. The value must be 'indx'.
    uint    fcc;
    ///The size of the structure, not including the initial 8 bytes.
    uint    cb;
    ///The size of each index entry, in 4-byte units. The value must be 4.
    ushort  wLongsPerEntry;
    ///The index subtype. The value must be zero or <b>AVI_INDEX_SUB_2FIELD</b>.
    ubyte   bIndexSubType;
    ///The index type. The value must be <b>AVI_INDEX_OF_INDEXES</b>.
    ubyte   bIndexType;
    ///The number of valid entries in the <b>adwIndex</b> array.
    uint    nEntriesInUse;
    ///A <b>FOURCC</b> that identifies the object that is indexed.
    uint    dwChunkId;
    ///Reserved. Set the array elements to zero.
    uint[3] dwReserved;
    struct aIndex
    {
    align (2):
        ulong qwOffset;
        uint  dwSize;
        uint  dwDuration;
    }
}

///Contains one index entry for an AVI 2.0 standard index. This structure is contained in the AVISTDINDEX structure.
struct AVISTDINDEX_ENTRY
{
align (2):
    ///The offset, in bytes, to the start of the data. The offset is relative to the value of the <b>qwBaseOffset</b>
    ///member of the AVISTDINDEX. The value is the offset of the actual audio/video data in the chunk, not the offset of
    ///the start of the chunk.
    uint dwOffset;
    ///The lower 31 bits contain the size of the data. The high bit is set to 1 if the frame is delta frame, or zero
    ///otherwise.
    uint dwSize;
}

///Contains an AVI 2.0 standard index.
struct AVISTDINDEX
{
align (2):
    ///A <b>FOURCC</b> code. The value is either 'indx' or '<i>nn</i>ix', where <i>nn</i> is the stream number.
    uint   fcc;
    ///The size of the structure, not including the initial 8 bytes.
    uint   cb;
    ///The size of each index entry, in 4-byte units. The value must be 2.
    ushort wLongsPerEntry;
    ///The index subtype. The value must be zero.
    ubyte  bIndexSubType;
    ///The index type. The value must be <b>AVI_INDEX_OF_CHUNKS</b>.
    ubyte  bIndexType;
    ///The number of valid entries in the <b>adwIndex</b> array.
    uint   nEntriesInUse;
    ///A <b>FOURCC</b> that identifies the object that is indexed. This member has the same meaning as the
    ///<b>dwChunkId</b> member of the AVIOLDINDEX structure.
    uint   dwChunkId;
    ///The base offset for the index entries. For each index entry, <b>qwBaseOffset</b> +
    ///<b>AVISTDINDEX_ENTRY.dwOffset</b> gives the offset from the start of the file to the data.
    ulong  qwBaseOffset;
    ///Reserved. Set to zero.
    uint   dwReserved_3;
    ///An array of AVISTDINDEX_ENTRY structures. The number of elements in the array is calculated from the value of
    ///<b>cb</b>.
    AVISTDINDEX_ENTRY[2044] aIndex;
}

struct _avitimedindex_entry
{
align (2):
    uint dwOffset;
    uint dwSize;
    uint dwDuration;
}

struct _avitimedindex
{
align (2):
    uint       fcc;
    uint       cb;
    ushort     wLongsPerEntry;
    ubyte      bIndexSubType;
    ubyte      bIndexType;
    uint       nEntriesInUse;
    uint       dwChunkId;
    ulong      qwBaseOffset;
    uint       dwReserved_3;
    _avitimedindex_entry[1362] aIndex;
    uint[2734] adwTrailingFill;
}

struct _avitimecodeindex
{
align (2):
    uint                fcc;
    uint                cb;
    ushort              wLongsPerEntry;
    ubyte               bIndexSubType;
    ubyte               bIndexType;
    uint                nEntriesInUse;
    uint                dwChunkId;
    uint[3]             dwReserved;
    _timecodedata[1022] aIndex;
}

struct _avitcdlindex_entry
{
align (2):
    uint     dwTick;
    TIMECODE time;
    uint     dwSMPTEflags;
    uint     dwUser;
    byte[12] szReelId;
}

struct _avitcdlindex
{
align (2):
    uint       fcc;
    uint       cb;
    ushort     wLongsPerEntry;
    ubyte      bIndexSubType;
    ubyte      bIndexType;
    uint       nEntriesInUse;
    uint       dwChunkId;
    uint[3]    dwReserved;
    _avitcdlindex_entry[584] aIndex;
    uint[3512] adwTrailingFill;
}

struct _avifieldindex_chunk
{
align (2):
    uint   fcc;
    uint   cb;
    ushort wLongsPerEntry;
    ubyte  bIndexSubType;
    ubyte  bIndexType;
    uint   nEntriesInUse;
    uint   dwChunkId;
    ulong  qwBaseOffset;
    uint   dwReserved3;
    struct aIndex
    {
    align (2):
        uint dwOffset;
        uint dwSize;
        uint dwOffsetField2;
    }
}

struct MainAVIHeader
{
    uint    dwMicroSecPerFrame;
    uint    dwMaxBytesPerSec;
    uint    dwPaddingGranularity;
    uint    dwFlags;
    uint    dwTotalFrames;
    uint    dwInitialFrames;
    uint    dwStreams;
    uint    dwSuggestedBufferSize;
    uint    dwWidth;
    uint    dwHeight;
    uint[4] dwReserved;
}

///The <b>AVISTREAMHEADER</b> structure contains information about one stream in an AVI file.
struct AVIStreamHeader
{
    ///Contains a FOURCC that specifies the type of the data contained in the stream. The following standard AVI values
    ///for video and audio are defined. <table> <tr> <th>FOURCC</th> <th>Description</th> </tr> <tr> <td width="40%"><a
    ///id="_auds_"></a><a id="_AUDS_"></a><dl> <dt><b>'auds'</b></dt> </dl> </td> <td width="60%"> Audio stream </td>
    ///</tr> <tr> <td width="40%"><a id="_mids_"></a><a id="_MIDS_"></a><dl> <dt><b>'mids'</b></dt> </dl> </td> <td
    ///width="60%"> MIDI stream </td> </tr> <tr> <td width="40%"><a id="_txts_"></a><a id="_TXTS_"></a><dl>
    ///<dt><b>'txts'</b></dt> </dl> </td> <td width="60%"> Text stream </td> </tr> <tr> <td width="40%"><a
    ///id="_vids_"></a><a id="_VIDS_"></a><dl> <dt><b>'vids'</b></dt> </dl> </td> <td width="60%"> Video stream </td>
    ///</tr> </table>
    uint   fccType;
    ///Optionally, contains a FOURCC that identifies a specific data handler. The data handler is the preferred handler
    ///for the stream. For audio and video streams, this specifies the codec for decoding the stream.
    uint   fccHandler;
    ///Contains any flags for the data stream. The bits in the high-order word of these flags are specific to the type
    ///of data contained in the stream. The following standard flags are defined. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="AVISF_DISABLED"></a><a id="avisf_disabled"></a><dl>
    ///<dt><b>AVISF_DISABLED</b></dt> </dl> </td> <td width="60%"> Indicates this stream should not be enabled by
    ///default. </td> </tr> <tr> <td width="40%"><a id="AVISF_VIDEO_PALCHANGES"></a><a
    ///id="avisf_video_palchanges"></a><dl> <dt><b>AVISF_VIDEO_PALCHANGES</b></dt> </dl> </td> <td width="60%">
    ///Indicates this video stream contains palette changes. This flag warns the playback software that it will need to
    ///animate the palette. </td> </tr> </table>
    uint   dwFlags;
    ///Specifies priority of a stream type. For example, in a file with multiple audio streams, the one with the highest
    ///priority might be the default stream.
    ushort wPriority;
    ///Language tag.
    ushort wLanguage;
    ///Specifies how far audio data is skewed ahead of the video frames in interleaved files. Typically, this is about
    ///0.75 seconds. If you are creating interleaved files, specify the number of frames in the file prior to the
    ///initial frame of the AVI sequence in this member. For more information, see the remarks for the
    ///<b>dwInitialFrames</b> member of the AVIMAINHEADER structure.
    uint   dwInitialFrames;
    ///Used with <b>dwRate</b> to specify the time scale that this stream will use. Dividing <b>dwRate</b> by
    ///<b>dwScale</b> gives the number of samples per second. For video streams, this is the frame rate. For audio
    ///streams, this rate corresponds to the time needed to play <b>nBlockAlign</b> bytes of audio, which for PCM audio
    ///is the just the sample rate.
    uint   dwScale;
    ///See <b>dwScale</b>.
    uint   dwRate;
    ///Specifies the starting time for this stream. The units are defined by the <b>dwRate</b> and <b>dwScale</b>
    ///members in the main file header. Usually, this is zero, but it can specify a delay time for a stream that does
    ///not start concurrently with the file.
    uint   dwStart;
    ///Specifies the length of this stream. The units are defined by the <b>dwRate</b> and <b>dwScale</b> members of the
    ///stream's header.
    uint   dwLength;
    ///Specifies how large a buffer should be used to read this stream. Typically, this contains a value corresponding
    ///to the largest chunk present in the stream. Using the correct buffer size makes playback more efficient. Use zero
    ///if you do not know the correct buffer size.
    uint   dwSuggestedBufferSize;
    ///Specifies an indicator of the quality of the data in the stream. Quality is represented as a number between 0 and
    ///10,000. For compressed data, this typically represents the value of the quality parameter passed to the
    ///compression software. If set to –1, drivers use the default quality value.
    uint   dwQuality;
    ///Specifies the size of a single sample of data. This is set to zero if the samples can vary in size. If this
    ///number is nonzero, then multiple samples of data can be grouped into a single chunk within the file. If it is
    ///zero, each sample of data (such as a video frame) must be in a separate chunk. For video streams, this number is
    ///typically zero, although it can be nonzero if all video frames are the same size. For audio streams, this number
    ///should be the same as the <b>nBlockAlign</b> member of the WAVEFORMATEX structure describing the audio.
    uint   dwSampleSize;
    ///Specifies the destination rectangle for a text or video stream within the movie rectangle specified by the
    ///<b>dwWidth</b> and <b>dwHeight</b> members of the AVI main header structure. The <b>rcFrame</b> member is
    ///typically used in support of multiple video streams. Set this rectangle to the coordinates corresponding to the
    ///movie rectangle to update the whole movie rectangle. Units for this member are pixels. The upper-left corner of
    ///the destination rectangle is relative to the upper-left corner of the movie rectangle.
    RECT   rcFrame;
}

struct AVIINDEXENTRY
{
    uint ckid;
    uint dwFlags;
    uint dwChunkOffset;
    uint dwChunkLength;
}

///The <b>AVIPALCHANGE</b> structure defines a palette change in an AVI file.
struct AVIPALCHANGE
{
    ///Specifies the index of the first palette entry to change.
    ubyte        bFirstEntry;
    ///Specifies the number of palette entries to change, or zero to change all 256 palette entries.
    ubyte        bNumEntries;
    ///Reserved.
    ushort       wFlags;
    ///Specifies an array of PALETTEENTRY structures, of size <b>bNumEntries</b>.
    PALETTEENTRY peNew;
}

struct AM_AC3_ERROR_CONCEALMENT
{
    BOOL fRepeatPreviousBlock;
    BOOL fErrorInCurrentBlock;
}

struct AM_AC3_ALTERNATE_AUDIO
{
    BOOL fStereo;
    uint DualMode;
}

struct AM_AC3_DOWNMIX
{
    BOOL fDownMix;
    BOOL fDolbySurround;
}

struct AM_AC3_BIT_STREAM_MODE
{
    int BitStreamMode;
}

struct AM_AC3_DIALOGUE_LEVEL
{
    uint DialogueLevel;
}

struct AM_AC3_ROOM_TYPE
{
    BOOL fLargeRoom;
}

///Contains DVD YUV subpicture data.
struct AM_DVD_YUV
{
    ///Reserved.
    ubyte Reserved;
    ///Y color data.
    ubyte Y;
    ///U color data.
    ubyte U;
    ///V color data.
    ubyte V;
}

///Specifies the DVD subpicture palette.
struct AM_PROPERTY_SPPAL
{
    ///Array of 16 YUV elements that correspond to the 4-bit color numbers requested within the subpicture command
    ///stream. The YUV elements are of type AM_DVD_YUV.
    AM_DVD_YUV[16] sppal;
}

///Indicates the color contrast description from the DVD highlight (HLI) structure.
struct AM_COLCON
{
    ubyte _bitfield1;
    ubyte _bitfield2;
    ubyte _bitfield3;
    ubyte _bitfield4;
}

///Describes the currently selected button from the DVD highlight information.
struct AM_PROPERTY_SPHLI
{
    ///Highlight status of current selection.
    ushort    HLISS;
    ///Reserved for internal use. Do not use or set.
    ushort    Reserved;
    ///Start presentation time divided by 90,000.
    uint      StartPTM;
    ///End presentation time divided by 90,000.
    uint      EndPTM;
    ///Start x-coordinate pixel of the current highlight button.
    ushort    StartX;
    ///Start y-coordinate pixel of the current highlight button.
    ushort    StartY;
    ///Ending x-coordinate pixel of the current highlight button.
    ushort    StopX;
    ///Ending y-coordinate pixel of the current highlight button.
    ushort    StopY;
    ///Color contrast description of type AM_COLCON.
    AM_COLCON ColCon;
}

///Identifies the DVD challenge key.
struct AM_DVDCOPY_CHLGKEY
{
    ///Challenge key.
    ubyte[10] ChlgKey;
    ///Reserved.
    ubyte[2]  Reserved;
}

///Identifies the DVD bus key.
struct AM_DVDCOPY_BUSKEY
{
    ///DVD drive bus key.
    ubyte[5] BusKey;
    ///Reserved.
    ubyte[1] Reserved;
}

///Specifies the DVD disc key.
struct AM_DVDCOPY_DISCKEY
{
    ///DVD disc key.
    ubyte[2048] DiscKey;
}

///Specifies the DVD title key from the current content.
struct AM_DVDCOPY_TITLEKEY
{
    ///Key flags.
    uint     KeyFlags;
    uint[2]  Reserved1;
    ///Title key.
    ubyte[6] TitleKey;
    ubyte[2] Reserved2;
}

///The <b>AM_COPY_MACROVISION</b> structure specifies the analog copy protection level for an NTSC encoder.
struct AM_COPY_MACROVISION
{
    ///Analog copy protection level for the NTSC encoder. Member of the AM_COPY_MACROVISION_LEVEL enumerated data type.
    uint MACROVISIONLevel;
}

///Specifies the copy protection state of the filter.
struct AM_DVDCOPY_SET_COPY_STATE
{
    ///Copy protection state of the filter. Member of the AM_DVDCOPYSTATE enumerated data type.
    uint DVDCopyState;
}

///Identifies the DVD region as reported by the local system components.
struct DVD_REGION
{
    ///Specifies whether the disk is copy protected.
    ubyte CopySystem;
    ///Contains information about the region from the decoder.
    ubyte RegionData;
    ///Contains information about region from DVD drive.
    ubyte SystemRegion;
    ///Reserved.
    ubyte ResetCount;
}

///The <b>VIDEOINFOHEADER2</b> structure describes the bitmap and color information for a video image, including
///interlace, copy protection, and pixel aspect ratio information.
struct VIDEOINFOHEADER2
{
    ///A RECT structure that specifies what part of the source stream should be used to fill the destination buffer.
    ///Renderers can use this field to ask the decoders to stretch or clip. For more information, see Source and Target
    ///Rectangles in Video Renderers.
    RECT             rcSource;
    ///A RECT structure that specifies that specifies what part of the destination buffer should be used
    RECT             rcTarget;
    ///The approximate data rate of the video stream, in bits per second.
    uint             dwBitRate;
    ///The data error rate of the video stream, in bits per second.
    uint             dwBitErrorRate;
    ///The video frame's average display time, in 100-nanosecond units. For more information, see the Remarks section
    ///for the VIDEOINFOHEADER structure.
    long             AvgTimePerFrame;
    ///Flags that specify how the video is interlaced. This member is a bit-wise combination of zero or more of the
    ///following flags. The flags in Group 2 are mutually exclusive, and so are the flags in Group 3. (The flags in
    ///Group 2 are not recommended.) The flags in Group 1 may be combined with each other, and with one flag each from
    ///Group 2 and Group 3. See the table at the bottom of this page for more information about flag combinations.
    ///<table> <tr> <th>Group 1</th> <th>Description</th> </tr> <tr> <td width="40%"><a
    ///id="AMINTERLACE_IsInterlaced"></a><a id="aminterlace_isinterlaced"></a><a id="AMINTERLACE_ISINTERLACED"></a><dl>
    ///<dt><b>AMINTERLACE_IsInterlaced</b></dt> </dl> </td> <td width="60%"> The stream is interlaced. If this flag is
    ///absent, the video is progressive and the other bits are irrelevant. </td> </tr> <tr> <td width="40%"><a
    ///id="AMINTERLACE_1FieldPerSample"></a><a id="aminterlace_1fieldpersample"></a><a
    ///id="AMINTERLACE_1FIELDPERSAMPLE"></a><dl> <dt><b>AMINTERLACE_1FieldPerSample</b></dt> </dl> </td> <td
    ///width="60%"> Each media sample contains one field. If this flag is absent, each media sample contains two fields.
    ///</td> </tr> <tr> <td width="40%"><a id="AMINTERLACE_Field1First"></a><a id="aminterlace_field1first"></a><a
    ///id="AMINTERLACE_FIELD1FIRST"></a><dl> <dt><b>AMINTERLACE_Field1First</b></dt> </dl> </td> <td width="60%"> Field
    ///1 is first. If this flag is absent, field 2 is first. (The top field in PAL is field 1, and the top field in NTSC
    ///is field 2.) </td> </tr> </table> <table> <tr> <th>Group 2</th> <th>Description</th> </tr> <tr> <td
    ///width="40%"><a id="AMINTERLACE_FieldPatField1Only"></a><a id="aminterlace_fieldpatfield1only"></a><a
    ///id="AMINTERLACE_FIELDPATFIELD1ONLY"></a><dl> <dt><b>AMINTERLACE_FieldPatField1Only</b></dt> </dl> </td> <td
    ///width="60%"> The stream never contains a field 2. </td> </tr> <tr> <td width="40%"><a
    ///id="AMINTERLACE_FieldPatField2Only"></a><a id="aminterlace_fieldpatfield2only"></a><a
    ///id="AMINTERLACE_FIELDPATFIELD2ONLY"></a><dl> <dt><b>AMINTERLACE_FieldPatField2Only</b></dt> </dl> </td> <td
    ///width="60%"> The stream never contains a field 1. </td> </tr> <tr> <td width="40%"><a
    ///id="AMINTERLACE_FieldPatBothRegular"></a><a id="aminterlace_fieldpatbothregular"></a><a
    ///id="AMINTERLACE_FIELDPATBOTHREGULAR"></a><dl> <dt><b>AMINTERLACE_FieldPatBothRegular</b></dt> </dl> </td> <td
    ///width="60%"> There is one field 2 for every field 1. </td> </tr> <tr> <td width="40%"><a
    ///id="AMINTERLACE_FieldPatBothIrregular"></a><a id="aminterlace_fieldpatbothirregular"></a><a
    ///id="AMINTERLACE_FIELDPATBOTHIRREGULAR"></a><dl> <dt><b>AMINTERLACE_FieldPatBothIrregular</b></dt> </dl> </td> <td
    ///width="60%"> The stream contains an irregular pattern of field 1 and field 2. </td> </tr> </table> <table> <tr>
    ///<th>Group 3</th> <th>Description</th> </tr> <tr> <td width="40%"><a id="AMINTERLACE_DisplayModeBobOnly"></a><a
    ///id="aminterlace_displaymodebobonly"></a><a id="AMINTERLACE_DISPLAYMODEBOBONLY"></a><dl>
    ///<dt><b>AMINTERLACE_DisplayModeBobOnly</b></dt> </dl> </td> <td width="60%"> Bob display mode only. </td> </tr>
    ///<tr> <td width="40%"><a id="AMINTERLACE_DisplayModeWeaveOnly"></a><a id="aminterlace_displaymodeweaveonly"></a><a
    ///id="AMINTERLACE_DISPLAYMODEWEAVEONLY"></a><dl> <dt><b>AMINTERLACE_DisplayModeWeaveOnly</b></dt> </dl> </td> <td
    ///width="60%"> Weave display mode only. </td> </tr> <tr> <td width="40%"><a
    ///id="AMINTERLACE_DisplayModeBobOrWeave"></a><a id="aminterlace_displaymodeboborweave"></a><a
    ///id="AMINTERLACE_DISPLAYMODEBOBORWEAVE"></a><dl> <dt><b>AMINTERLACE_DisplayModeBobOrWeave</b></dt> </dl> </td> <td
    ///width="60%"> Either bob or weave mode. </td> </tr> </table> Set undefined flags to zero, or the connection will
    ///be rejected.
    uint             dwInterlaceFlags;
    ///Flag set with the AMCOPYPROTECT_RestrictDuplication value (0x00000001) to indicate that the duplication of the
    ///stream should be restricted. If undefined, specify zero or else the connection will be rejected.
    uint             dwCopyProtectFlags;
    ///The X dimension of picture aspect ratio. For example, 16 for a 16-inch x 9-inch display.
    uint             dwPictAspectRatioX;
    ///The Y dimension of picture aspect ratio. For example, 9 for a 16-inch x 9-inch display.
    uint             dwPictAspectRatioY;
    union
    {
        uint dwControlFlags;
        uint dwReserved1;
    }
    ///Reserved for future use. Must be zero.
    uint             dwReserved2;
    ///BITMAPINFOHEADER structure that contains color and dimension information for the video image bitmap. When used
    ///inside a <b>VIDEOINFOHEADER2</b> structure, the semantics of the BITMAPINFOHEADER structure differ slightly from
    ///how the structure is used in GDI. For more information, refer to the topic BITMAPINFOHEADER.
    BITMAPINFOHEADER bmiHeader;
}

///The <b>MPEG2VIDEOINFO</b> structure describes an MPEG-2 video stream.
struct MPEG2VIDEOINFO
{
    ///VIDEOINFOHEADER2 structure.
    VIDEOINFOHEADER2 hdr;
    ///25-bit group-of-pictures (GOP) time code at start of data. This field is not used for DVD.
    uint             dwStartTimeCode;
    ///Length of the sequence header, in bytes. For DVD, set this field to zero. The sequence header is given in the
    ///<b>dwSequenceHeader</b> field.
    uint             cbSequenceHeader;
    ///Specifies the MPEG-2 profile as an AM_MPEG2Profile enumeration type.
    uint             dwProfile;
    ///Specifies the MPEG-2 level as an AM_MPEG2Level enumeration type.
    uint             dwLevel;
    ///Flag indicating preferences. Set one or a combination of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="AMMPEG2_DoPanScan"></a><a id="ammpeg2_dopanscan"></a><a
    ///id="AMMPEG2_DOPANSCAN"></a><dl> <dt><b>AMMPEG2_DoPanScan</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> If this flag is set, the MPEG-2 video decoder should crop the output image based on pan-scan vectors
    ///in picture_display_extension and change the picture aspect ratio to 4x3. The VMR should not receive a 16x9 sample
    ///with this flag. A simple implementation might alter the source rectangle to indicate a 540 wide source region
    ///with a left edge equal to the display offset in the picture_display_extension. </td> </tr> <tr> <td
    ///width="40%"><a id="AMMPEG2_DVDLine21Field1"></a><a id="ammpeg2_dvdline21field1"></a><a
    ///id="AMMPEG2_DVDLINE21FIELD1"></a><dl> <dt><b>AMMPEG2_DVDLine21Field1</b></dt> <dt>0x00000002</dt> </dl> </td> <td
    ///width="60%"> If set, the MPEG-2 decoder must be able to produce an output pin for DVD style closed-captioned data
    ///found in the Group Of Pictures (GOP) layer of field 1. </td> </tr> <tr> <td width="40%"><a
    ///id="AMMPEG2_DVDLine21Field2"></a><a id="ammpeg2_dvdline21field2"></a><a id="AMMPEG2_DVDLINE21FIELD2"></a><dl>
    ///<dt><b>AMMPEG2_DVDLine21Field2</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> If set, the MPEG-2
    ///decoder must be able to produce an output pin for DVD style closed-captioned data found in the GOP layer of field
    ///2. </td> </tr> <tr> <td width="40%"><a id="AMMPEG2_SourceIsLetterboxed"></a><a
    ///id="ammpeg2_sourceisletterboxed"></a><a id="AMMPEG2_SOURCEISLETTERBOXED"></a><dl>
    ///<dt><b>AMMPEG2_SourceIsLetterboxed</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> If set, indicates
    ///that black bars have been encoded in the top and bottom of the video. </td> </tr> <tr> <td width="40%"><a
    ///id="AMMPEG2_FilmCameraMode"></a><a id="ammpeg2_filmcameramode"></a><a id="AMMPEG2_FILMCAMERAMODE"></a><dl>
    ///<dt><b>AMMPEG2_FilmCameraMode</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> If set, indicates "film
    ///mode" used for the 625/50 (line/field) content. If cleared, indicates that "camera mode" was used. </td> </tr>
    ///<tr> <td width="40%"><a id="AMMPEG2_LetterboxAnalogOut"></a><a id="ammpeg2_letterboxanalogout"></a><a
    ///id="AMMPEG2_LETTERBOXANALOGOUT"></a><dl> <dt><b>AMMPEG2_LetterboxAnalogOut</b></dt> <dt>0x00000020</dt> </dl>
    ///</td> <td width="60%"> If set and this stream is sent to an analog output, it should be letterboxed. Streams sent
    ///to VGA should be letterboxed only by renderers. </td> </tr> <tr> <td width="40%"><a
    ///id="AMMPEG2_DSS_UserData"></a><a id="ammpeg2_dss_userdata"></a><a id="AMMPEG2_DSS_USERDATA"></a><dl>
    ///<dt><b>AMMPEG2_DSS_UserData</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> If set, the MPEG-2 decoder
    ///must process DSS style user data. </td> </tr> <tr> <td width="40%"><a id="AMMPEG2_DVB_UserData"></a><a
    ///id="ammpeg2_dvb_userdata"></a><a id="AMMPEG2_DVB_USERDATA"></a><dl> <dt><b>AMMPEG2_DVB_UserData</b></dt>
    ///<dt>0x00000080</dt> </dl> </td> <td width="60%"> If set, the MPEG-2 decoder must process DVB style user data.
    ///</td> </tr> <tr> <td width="40%"><a id="AMMPEG2_27MhzTimebase"></a><a id="ammpeg2_27mhztimebase"></a><a
    ///id="AMMPEG2_27MHZTIMEBASE"></a><dl> <dt><b>AMMPEG2_27MhzTimebase</b></dt> <dt>0x00000100</dt> </dl> </td> <td
    ///width="60%"> If set, the PTS, DTS timestamps advance at 27MHz rather than 90KHz. </td> </tr> <tr> <td
    ///width="40%"><a id="AMMPEG2_WidescreenAnalogOut"></a><a id="ammpeg2_widescreenanalogout"></a><a
    ///id="AMMPEG2_WIDESCREENANALOGOUT"></a><dl> <dt><b>AMMPEG2_WidescreenAnalogOut</b></dt> <dt>0x00000200</dt> </dl>
    ///</td> <td width="60%"> If set and this stream is sent to an analog output, it should be in widescreen format (4x3
    ///content should be centered on a 16x9 output). Streams sent to VGA should be widescreened only by renderers. </td>
    ///</tr> </table> Set undefined flags to zero or connection will be rejected. For more information on how to use
    ///these flags, see MPEG Decoder Preprocessing Transformations.
    uint             dwFlags;
    ///Start of an array that contains the sequence header, including quantization matrices and the sequence extension,
    ///if required. This field is typed as <b>DWORD</b> array to enforce 32-bit alignment. The size of the array, in
    ///bytes, is given in the <b>cbSequenceHeader</b> member.
    uint[1]          dwSequenceHeader;
}

///Specifies how to mix the karaoke audio channels.
struct AM_DvdKaraokeData
{
    ///A bitwise OR of DVD_KARAOKE_DOWNMIX flags telling the decoder which channels are downmixed to channels 0 or 1.
    uint dwDownmix;
    ///A valid DVD_KARAOKE_ASSIGNMENT value that indicates which speakers the output is going to.
    uint dwSpeakerAssignment;
}

///The <b>AM_SimpleRateChange</b> structure is used to change the playback rate for an MPEG-2 stream.
struct AM_SimpleRateChange
{
    ///Specifies the time stamp on the input sample when the new rate takes effect. The new rate applies to all samples
    ///with a time stamp &gt;= <b>StartTime</b> and less than the start time on the next queued rate segment.
    long StartTime;
    ///Specifies the new rate x 10000. Rate is the inverse of speed. For example, if the playback speed is 2x, the rate
    ///is 1/2, so the <b>Rate</b> member is set to 5000.
    int  Rate;
}

///The <b>AM_QueryRate</b> structure is used to query the decoder's maximum full-frame rate for forward and reverse
///playback.
struct AM_QueryRate
{
    ///Specifies the maximum forward full-frame rate, as rate x 10000.
    int lMaxForwardFullFrame;
    ///Specifies the maximum reverse full-frame rate, as rate x 10000.
    int lMaxReverseFullFrame;
}

///The AM_ExactRateChange structure is not supported. Use AM_SimpleRateChange.
struct AM_ExactRateChange
{
    ///Reserved.
    long OutputZeroTime;
    ///Reserved.
    int  Rate;
}

struct AM_DVD_ChangeRate
{
    long StartInTime;
    long StartOutTime;
    int  Rate;
}

///The <code>MP_PARAMINFO</code> structure contains information about a parameter.
struct MP_PARAMINFO
{
    ///Member of the MP_TYPE enumeration that specifies the valid data type for this parameter.
    MP_TYPE    mpType;
    ///Bitwise combination of one or more Parameter Capabilities Flags that specify which envelope curves are supported.
    ///For Boolean and enumeration parameters, only MP_CAPS_CURVE_JUMP is valid.
    uint       mopCaps;
    ///Minimum value of the parameter. Used only for parameters with numeric values.
    float      mpdMinValue;
    ///Maximum value of the parameter. Used only for parameters with numeric values.
    float      mpdMaxValue;
    ///Default or "neutral" value of the parameter.
    float      mpdNeutralValue;
    ///NULL-terminated wide-character string that contains the name of the units for the parameter.
    ushort[32] szUnitText;
    ///NULL-terminated wide-character string that contains the name of the parameter.
    ushort[32] szLabel;
}

///The <code>MP_ENVELOPE_SEGMENT</code> structure defines an envelope segment used by an envelope-following parameter.
struct MP_ENVELOPE_SEGMENT
{
    ///Start time of the segment, relative to the time stamp on the first buffer, in 100-nanosecond units.
    long          rtStart;
    ///Stop time of the segment, relative to the time stamp on the first buffer, in 100-nanosecond units.
    long          rtEnd;
    ///Initial value of the parameter, at the start of the segment.
    float         valStart;
    ///Final value of the parameter, at the end of the segment.
    float         valEnd;
    ///Member of the <b>MP_CURVE_TYPE</b> enumerated type that specifies the curve followed by the parameter.
    MP_CURVE_TYPE iCurve;
    ///Specifies one of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="MPF_ENVLP_STANDARD"></a><a id="mpf_envlp_standard"></a><dl> <dt><b>MPF_ENVLP_STANDARD</b></dt>
    ///<dt>0x0000</dt> </dl> </td> <td width="60%"> Use all the information provided with the envelope segment. </td>
    ///</tr> <tr> <td width="40%"><a id="MPF_ENVLP_BEGIN_CURRENTVAL"></a><a id="mpf_envlp_begin_currentval"></a><dl>
    ///<dt><b>MPF_ENVLP_BEGIN_CURRENTVAL</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> Ignore the specified
    ///start value. Start from the current value. </td> </tr> <tr> <td width="40%"><a
    ///id="MPF_ENVLP_BEGIN_NEUTRALVAL"></a><a id="mpf_envlp_begin_neutralval"></a><dl>
    ///<dt><b>MPF_ENVLP_BEGIN_NEUTRALVAL</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> Ignore the specified
    ///start value. Start from the neutral value. (See MP_PARAMINFO.) </td> </tr> </table>
    uint          flags;
}

///The <code>DMO_PARTIAL_MEDIATYPE</code> structure partially describes a media type used by a Microsoft DirectX Media
///Object (DMO). The DMO registration functions use this structure to specify supported media types.
struct DMO_PARTIAL_MEDIATYPE
{
    ///Major type GUID. Use GUID_NULL to match any major type.
    GUID type;
    ///Subtype GUID. Use GUID_NULL to match any subtype.
    GUID subtype;
}

///This topic applies to Windows XP Service Pack 2 or later. The <b>KSTOPOLOGY_CONNECTION</b> structure describes a node
///connection within a kernel-streaming (KS) filter. A node can be connected to another node within the filter, or to a
///pin on the filter.
struct KSTOPOLOGY_CONNECTION
{
    ///Index of the upstream node in the connection. If the upstream connection is a pin, rather than a node, the value
    ///is KSFILTER_NODE.
    uint FromNode;
    ///If the value of the <b>FromNode</b> field is KSFILTER_NODE, this field specifies the index of the upstream pin.
    ///Otherwise, this field is ignored.
    uint FromNodePin;
    ///Index of the downstream node in the connection. If the downstream connection is a pin, rather than a node, the
    ///value is KSFILTER_NODE.
    uint ToNode;
    ///If the value of the <b>ToNode</b> field is KSFILTER_NODE, this field specifies the index of the downstream pin.
    ///Otherwise, this field is ignored.
    uint ToNodePin;
}

///The <b>TIMECODE</b> structure contains basic timecode frame count information.
union TIMECODE
{
    struct
    {
        ushort wFrameRate;
        ushort wFrameFract;
        uint   dwFrames;
    }
    ulong qw;
}

///The <code>TIMECODE_SAMPLE</code> structure contains complete timecode information.
struct TIMECODE_SAMPLE
{
    ///Reference time, in 100-nanosecond units.
    long     qwTick;
    ///TIMECODE structure.
    TIMECODE timecode;
    ///Packed SMPTE userbits.
    uint     dwUser;
    ///Timecode flag masks. Specify one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="AM_TIMECODE_FLAG_FCM"></a><a id="am_timecode_flag_fcm"></a><dl>
    ///<dt><b>AM_TIMECODE_FLAG_FCM</b></dt> </dl> </td> <td width="60%"> Frame code mode; 0 = nondrop; 1 = drop. </td>
    ///</tr> <tr> <td width="40%"><a id="AM_TIMECODE_FLAG_CF"></a><a id="am_timecode_flag_cf"></a><dl>
    ///<dt><b>AM_TIMECODE_FLAG_CF</b></dt> </dl> </td> <td width="60%"> Color frame flag. </td> </tr> <tr> <td
    ///width="40%"><a id="AM_TIMECODE_FLAG_FIELD"></a><a id="am_timecode_flag_field"></a><dl>
    ///<dt><b>AM_TIMECODE_FLAG_FIELD</b></dt> </dl> </td> <td width="60%"> Field flag. </td> </tr> <tr> <td
    ///width="40%"><a id="AM_TIMECODE_FLAG_DF"></a><a id="am_timecode_flag_df"></a><dl>
    ///<dt><b>AM_TIMECODE_FLAG_DF</b></dt> </dl> </td> <td width="60%"> Drop frame flag (from flags in actual timecode
    ///on external media). </td> </tr> <tr> <td width="40%"><a id="AM_TIMECODE_COLORFRAME"></a><a
    ///id="am_timecode_colorframe"></a><dl> <dt><b>AM_TIMECODE_COLORFRAME</b></dt> </dl> </td> <td width="60%">
    ///Specifies frame in color sequence. </td> </tr> <tr> <td width="40%"><a id="AM_TIMECODE_COLORSEQUENCE"></a><a
    ///id="am_timecode_colorsequence"></a><dl> <dt><b>AM_TIMECODE_COLORSEQUENCE</b></dt> </dl> </td> <td width="60%">
    ///Duration in frames of complete sequence. </td> </tr> <tr> <td width="40%"><a
    ///id="AM_TIMECODE_FILMSEQUENCE_TYPE"></a><a id="am_timecode_filmsequence_type"></a><dl>
    ///<dt><b>AM_TIMECODE_FILMSEQUENCE_TYPE</b></dt> </dl> </td> <td width="60%"> One of the FILM_SEQUENCE_XXX defines.
    ///</td> </tr> <tr> <td width="40%"><a id="ED_DEVCAP_TIMECODE_READ"></a><a id="ed_devcap_timecode_read"></a><dl>
    ///<dt><b>ED_DEVCAP_TIMECODE_READ</b></dt> </dl> </td> <td width="60%"> Read SMPTE timecode; applies to DV
    ///camcorders. </td> </tr> <tr> <td width="40%"><a id="ED_DEVCAP_ATN_READ"></a><a id="ed_devcap_atn_read"></a><dl>
    ///<dt><b>ED_DEVCAP_ATN_READ</b></dt> </dl> </td> <td width="60%"> Read the absolute track number (ATN); applies to
    ///DV camcorders. This constant is defined in the header file Xprtdefs.h. </td> </tr> <tr> <td width="40%"><a
    ///id="ED_DEVCAP_RTC_READ"></a><a id="ed_devcap_rtc_read"></a><dl> <dt><b>ED_DEVCAP_RTC_READ</b></dt> </dl> </td>
    ///<td width="60%"> Read the relative time counter (RTC); applies to MPEG camcorders. This constant is defined in
    ///the header file Xprtdefs.h. </td> </tr> </table>
    uint     dwFlags;
}

struct __MIDL___MIDL_itf_encdec_0000_0000_0001
{
align (1):
    ushort[25] wszKID;
    ulong      qwCounter;
    ulong      qwIndex;
    ubyte      bOffset;
}

struct __MIDL___MIDL_itf_encdec_0000_0000_0002
{
align (1):
    HRESULT hrReason;
}

///This topic applies only to Windows XP Service Pack 1 or later. The <b>STREAMBUFFER_ATTRIBUTE</b> structure describes
///an attribute on a stream buffer file.
struct STREAMBUFFER_ATTRIBUTE
{
    ///Pointer to a null-terminated wide-character string that contains the name of the attribute.
    const(wchar)* pszName;
    ///Member of the STREAMBUFFER_ATTR_DATATYPE enumeration. The value indicates the data type that you should use to
    ///interpret the attribute data, which is contained in the <b>pbAttribute</b> member.
    STREAMBUFFER_ATTR_DATATYPE StreamBufferAttributeType;
    ///Pointer to a buffer that contains the attribute data.
    ubyte*        pbAttribute;
    ///The size of the buffer given in <b>pbAttribute</b>, in bytes.
    ushort        cbLength;
}

///This topic applies to Windows XP Service Pack 2 only. The <b>STREAMBUFFER_ATTRIBUTE</b> structure contains
///performance data for the stream buffer filters.
struct SBE_PIN_DATA
{
    ///Total sample payload, in bytes.
    ulong cDataBytes;
    ///Number of samples processed.
    ulong cSamplesProcessed;
    ///Number of discontinuities. See IMediaSample::SetDiscontinuity.
    ulong cDiscontinuities;
    ///Number of synchronization points. See IMediaSample::SetSyncPoint.
    ulong cSyncPoints;
    ///Number of time stamps.
    ulong cTimestamps;
}

///Describes a stream produced by the stream buffer engine.
struct SBE2_STREAM_DESC
{
    ///The version number of the stream. Currently the following value is defined. <a id="SBE2_STREAM_DESC_VERSION"></a>
    ///<a id="sbe2_stream_desc_version"></a>
    uint Version;
    ///The identifier of the stream.
    uint StreamId;
    ///Specifies whether the steam is the default for the current media type. If the value is nonzero, the stream is the
    ///default. If the value is zero, the stream is not the default.
    uint Default;
    ///Reserved.
    uint Reserved;
}

///Describes a stream captured by a tuner.
struct DVR_STREAM_DESC
{
    uint          Version;
    ///Specifies a unique identifier for the stream.
    uint          StreamId;
    ///Indicates whether or not the stream is the default stream.
    BOOL          Default;
    ///Indicates whether or not the stream has been created.
    BOOL          Creation;
    ///Reserved.
    uint          Reserved;
    ///Specifies the GUID corresponding to the media subtype.
    GUID          guidSubMediaType;
    ///Specifies the GUID corresponding to the major media type of the stream.
    GUID          guidFormatType;
    ///Defines the major media type of the stream.
    AM_MEDIA_TYPE MediaType;
}

struct __MIDL___MIDL_itf_mpeg2structs_0000_0000_0001
{
align (1):
    ushort Bits;
}

struct __MIDL___MIDL_itf_mpeg2structs_0000_0000_0002
{
align (1):
    ushort Bits;
}

struct __MIDL___MIDL_itf_mpeg2structs_0000_0000_0003
{
    ubyte Bits;
}

struct __MIDL___MIDL_itf_mpeg2structs_0000_0000_0005
{
align (1):
    ushort wTidExt;
    ushort wCount;
}

///The <b>SECTION</b> structure represents a short header from an MPEG-2 table section.
struct SECTION
{
    ///Specifies the table identifier (TID) of the section.
    ubyte    TableId;
    union Header
    {
    align (1):
        __MIDL___MIDL_itf_mpeg2structs_0000_0000_0002 S;
        ushort W;
    }
    ///Contains the section data, as a byte array. The length of the array is given by the <b>Header.W.SectionLength</b>
    ///field.
    ubyte[1] SectionData;
}

///The <b>LONG_SECTION</b> structure represents a long MPEG-2 section header. If a section contains a long header, you
///can cast a SECTION pointer to a <b>LONG_SECTION</b> pointer. For more information, see the Remarks section in the
///<b>SECTION</b> reference.
struct LONG_SECTION
{
align (1):
    ///Specifies the table identifier (TID) of the section.
    ubyte    TableId;
    union Header
    {
    align (1):
        __MIDL___MIDL_itf_mpeg2structs_0000_0000_0002 S;
        ushort W;
    }
    ///Specifies the table_id_extension field.
    ushort   TableIdExtension;
    union Version
    {
        __MIDL___MIDL_itf_mpeg2structs_0000_0000_0003 S;
        ubyte B;
    }
    ///Specifies the section_number field, which gives the section number for this section.
    ubyte    SectionNumber;
    ///Specifies the last_section_number field, which gives the last (highest) section number for the table.
    ubyte    LastSectionNumber;
    ///Contains the remaining section data, as a byte array. The length of the array is <code>Header.W.SectionLength -
    ///5</code> bytes.
    ubyte[1] RemainingData;
}

///The <b>DSMCC_SECTION</b> structure represents a DSM-CC section header. If a section contains a DSM-CC header, you can
///cast a SECTION pointer to a <b>DSMCC_SECTION</b> pointer. For more information, see the Remarks section in the
///<b>SECTION</b> reference.
struct DSMCC_SECTION
{
align (1):
    ///Specifies the table identifier (TID) of the section.
    ubyte    TableId;
    union Header
    {
    align (1):
        __MIDL___MIDL_itf_mpeg2structs_0000_0000_0002 S;
        ushort W;
    }
    ///Specifies the table_id_extension field.
    ushort   TableIdExtension;
    union Version
    {
        __MIDL___MIDL_itf_mpeg2structs_0000_0000_0003 S;
        ubyte B;
    }
    ///Specifies the section_number field, which gives the section number for this section.
    ubyte    SectionNumber;
    ///Specifies the last_section_number field, which gives the last (highest) section number for the table.
    ubyte    LastSectionNumber;
    ///Indicates that the message is an MPEG-2 DSM-CC message. The value of this field is always 0x11.
    ubyte    ProtocolDiscriminator;
    ///Specifies the DSM-CC message type.
    ubyte    DsmccType;
    ///Specifies the DSM-CC message identifier.
    ushort   MessageId;
    ///Specifies the transaction identifier.
    uint     TransactionId;
    ///Reserved bytes.
    ubyte    Reserved;
    ///Specifies the adaptation field length.
    ubyte    AdaptationLength;
    ///Specifies the message length.
    ushort   MessageLength;
    ///Contains the remaining section data, as a byte array. The length of the array is <code>Header.W.SectionLength -
    ///17</code> bytes.
    ubyte[1] RemainingData;
}

///The <b>MPEG_RQST_PACKET</b> structure defines a buffer to receive MPEG-2 section data.
struct MPEG_RQST_PACKET
{
align (1):
    ///Specifies the length of the buffer that <b>pSection</b> points to. The minimum size for section data is 4096
    ///bytes.
    uint     dwLength;
    ///Pointer to a buffer that receives the section data. The pointer is typed as a SECTION structure. The first bytes
    ///in the section contain header fields that are defined in the <b>SECTION</b> structure. The <b>SectionData</b>
    ///member of the <b>SECTION</b> structure is an array of bytes, containing the body of the section after the header
    ///bytes.
    SECTION* pSection;
}

///The <b>MPEG_PACKET_LIST</b> structure contains a list of MPEG-2 sections.
struct MPEG_PACKET_LIST
{
align (1):
    ///Specifies the size of the <b>PacketList</b> array.
    ushort               wPacketCount;
    ///Specifies a pointer to an array of MPEG_RQST_PACKET structures, which themselves contain pointers to buffers that
    ///hold the sectioned data.
    MPEG_RQST_PACKET[1]* PacketList;
}

///The <b>DSMCC_FILTER_OPTIONS</b> structure specifies additional filtering criteria for the DSM-CC portions of the
///section header.
struct DSMCC_FILTER_OPTIONS
{
align (1):
    ///If this flag is <b>TRUE</b>, the protocolDiscriminator field in the header must match the value of the
    ///<b>Protocol</b> structure member. Otherwise, the protocolDiscriminator field is ignored.
    BOOL   fSpecifyProtocol;
    ///Specifies a value for the protocolDiscriminator field. For MPEG-2 DSM-CC messages, this field must equal 0x11.
    ubyte  Protocol;
    ///If this field is <b>TRUE</b>, the dsmccType field in the header must match the value of the <b>Type</b> structure
    ///member. Otherwise, the dsmccType field is ignored.
    BOOL   fSpecifyType;
    ///Specifies a value for the dsmccType field, which defines the DSM-CC message type.
    ubyte  Type;
    ///If this flag is <b>TRUE</b>, the messageId field in the header must match the value of the <b>MessageId</b>
    ///structure member. Otherwise, the messageId field is ignored.
    BOOL   fSpecifyMessageId;
    ///Specifies a value for the messageId field, which defines the DSM-CC message within the scope of the message type.
    ushort MessageId;
    ///If this flag is <b>TRUE</b>, the transactionId (or downloadId) field in the header must match the value of the
    ///<b>TransactionId</b> structure member. Otherwise, the transactionId/downloadId field is ignored.
    BOOL   fSpecifyTransactionId;
    ///If this flag is <b>TRUE</b>, the transactionId bits are masked so that the following subfields are ignored: <ul>
    ///<li>Updated flag</li> <li>Version </li> </ul> The following subfields are matched against the
    ///<b>TransactionId</b> structure member: <ul> <li>Identification</li> <li>Originator</li> </ul> For more
    ///information about the subfields within the transactionId, see section 4.6.5 of TR 101 202, <i>Digital Video
    ///Broadcasting (DVB); Implementation Guidelines for Data Broadcasting</i>. (This resource may not be available in
    ///some languages and countries.) This flag is ignored if <b>fSpecifyTransactionId</b> is <b>FALSE</b>.
    BOOL   fUseTrxIdMessageIdMask;
    ///Specifies a value for the transactionId field.
    uint   TransactionId;
    ///If this flag is <b>TRUE</b>, the moduleVersion field in the header must match the value of the
    ///<b>ModuleVersion</b> structure member. Otherwise, the moduleVersion field is ignored.
    BOOL   fSpecifyModuleVersion;
    ///Specifies a value for the moduleVersion field.
    ubyte  ModuleVersion;
    ///If this flag is <b>TRUE</b>, the blockNumber field in the header must match the value of the BlockNumber
    ///structure member. Otherwise, the moduleVersion field is ignored.
    BOOL   fSpecifyBlockNumber;
    ///Specifies a value for the blockNumber field.
    ushort BlockNumber;
    ///If this flag is <b>TRUE</b>, the <b>NumberOfBlocksInModule</b> structure member specifies the number of blocks in
    ///the module. Applies only to download data block (DDB) messages.
    BOOL   fGetModuleCall;
    ///Specifies the number of blocks in the module. Applies only to DDB messages.
    ushort NumberOfBlocksInModule;
}

///The <b>ATSC_FILTER_OPTIONS</b> structure specifies additional criteria for matching ATSC section headers.
struct ATSC_FILTER_OPTIONS
{
align (1):
    ///If this flag is <b>TRUE</b>, the ETM_id field in the header must match the value of the <b>EtmId</b> structure
    ///member. Otherwise, the ETM_id field is ignored.
    BOOL fSpecifyEtmId;
    ///Specifies a value for the ETM_id field.
    uint EtmId;
}

///Specifies a section within a Digital Video Broadcast (DVB) Event Information Table (EIT) section header. Because the
///EIT can be quite large, these options allow applications to reduce load time by filtering specific segments from the
///EIT section header.
struct DVB_EIT_FILTER_OPTIONS
{
align (1):
    ///If this flag is <b>TRUE</b>, the number of the segment that is queried from the header must match the value of
    ///the <b>bSegment</b> structure member. Otherwise, the segment field is ignored.
    BOOL  fSpecifySegment;
    ubyte bSegment;
}

///The <b>MPEG2_FILTER</b> structure specifies criteria for matching MPEG-2 section headers.
struct MPEG2_FILTER
{
align (1):
    ///Specifies the version number of the structure. This value must be 1 or higher.
    ubyte                bVersionNumber;
    ///Specifies the size of the structure data, excluding any padding bytes. Set this field equal to the constant
    ///<b>MPEG2_FILTER_VERSION_1_SIZE</b>.
    ushort               wFilterSize;
    ///If <b>TRUE</b>, the <b>Filter</b> and <b>Mask</b> members specify the filtering criteria as a pair of bit masks,
    ///and the remaining members of this structure are ignored. If this field is <b>FALSE</b>, the <b>Filter</b> and
    ///<b>Mask</b> members are ignored, and the other structure members contain the filtering criteria.
    BOOL                 fUseRawFilteringBits;
    ///Specifies a 16-byte bit mask, which contains the bit values to match in the section header.
    ubyte[16]            Filter;
    ///Specifies a 16-byte bit mask. Set any "don't care" bits equal to 1, and all other bits to 0. In other words, for
    ///each bit, if the value in <b>Mask</b> is 0, the corresponding bit in <b>Filter</b> will be matched against that
    ///bit in the section header. If the value in <b>Mask</b> is 1, that bit in the section header is ignored.
    ubyte[16]            Mask;
    ///If <b>TRUE</b>, the <b>table_ID_extension</b> field in the header must match the value of the
    ///<b>TableIdExtension</b> structure member. Otherwise, the <b>table_ID_extension</b> field is ignored.
    BOOL                 fSpecifyTableIdExtension;
    ///Specifies a value for the <b>table_ID_extension</b> field.
    ushort               TableIdExtension;
    ///If <b>TRUE</b>, the <b>version_number</b> field in the header must match the value of the <b>Version</b>
    ///structure member. Otherwise, the <b>version_number</b> field is ignored.
    BOOL                 fSpecifyVersion;
    ///Specifies a value for the <b>version_number</b> field.
    ubyte                Version;
    ///If <b>TRUE</b>, the <b>section_number</b> field in the header must match the value of the <b>SectionNumber</b>
    ///member. Otherwise, the <b>section_number</b> field is ignored.
    BOOL                 fSpecifySectionNumber;
    ///Specifies a value for the <b>section_number</b> field.
    ubyte                SectionNumber;
    ///If <b>TRUE</b>, the <b>current_next_indicator</b> bit in the header must match the value of the <b>fNext</b>
    ///structue member. Otherwise, the <b>current_next_indicator</b> field is ignored.
    BOOL                 fSpecifyCurrentNext;
    ///Specifies a value for the <b>current_next_indicator</b> bit. You can use the MPEG_CURRENT_NEXT_BIT enumeration
    ///type to specify this value.
    BOOL                 fNext;
    ///If <b>TRUE</b>, the <b>Dsmcc</b> member contains additional filtering criteria for the DSM-CC portions of the
    ///section header. Otherwise, the <b>Dsmcc</b> member is ignored.
    BOOL                 fSpecifyDsmccOptions;
    ///Specifies a DSMCC_FILTER_OPTIONS structure that contains additional filtering criteria for the DSM-CC portions of
    ///the section header.
    DSMCC_FILTER_OPTIONS Dsmcc;
    ///If <b>TRUE</b>, the <b>Atsc</b> member contains additional filtering criteria. Otherwise, the <b>Atsc</b> member
    ///is ignored.
    BOOL                 fSpecifyAtscOptions;
    ///Specifies an ATSC_FILTER_OPTIONS structure that contains additional filtering criteria.
    ATSC_FILTER_OPTIONS  Atsc;
}

///The <b>MPEG2_FILTER2</b> structure specifies criteria for matching MPEG-2 section headers.
struct MPEG2_FILTER2
{
align (1):
    union
    {
        struct
        {
        align (1):
            ubyte                bVersionNumber;
            ushort               wFilterSize;
            BOOL                 fUseRawFilteringBits;
            ubyte[16]            Filter;
            ubyte[16]            Mask;
            BOOL                 fSpecifyTableIdExtension;
            ushort               TableIdExtension;
            BOOL                 fSpecifyVersion;
            ubyte                Version;
            BOOL                 fSpecifySectionNumber;
            ubyte                SectionNumber;
            BOOL                 fSpecifyCurrentNext;
            BOOL                 fNext;
            BOOL                 fSpecifyDsmccOptions;
            DSMCC_FILTER_OPTIONS Dsmcc;
            BOOL                 fSpecifyAtscOptions;
            ATSC_FILTER_OPTIONS  Atsc;
        }
        ubyte[124] bVersion1Bytes;
    }
    ///If <b>TRUE</b>, the <b>Dvb_Eit</b> member contains additional filtering criteria. Otherwise, the <b>Dvb_Eit</b>
    ///member is ignored. <div class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div>
    BOOL fSpecifyDvbEitOptions;
    ///An DVB_EIT_FILTER_OPTIONS structure that contains additional filtering criteria. <div class="alert"><b>Note</b>
    ///Requires Windows 7 or later.</div> <div> </div>
    DVB_EIT_FILTER_OPTIONS DvbEit;
}

///The <b>MPEG_STREAM_BUFFER</b> structure defines a buffer that receives MPEG-2 data.
struct MPEG_STREAM_BUFFER
{
align (1):
    ///Specifies a status code. Use this value to check the status of the read request.
    HRESULT hr;
    ///Specifies the size of the buffer, in bytes.
    uint    dwDataBufferSize;
    ///Specifies the amount of valid data in the buffer, in bytes
    uint    dwSizeOfDataRead;
    ///Pointer to a buffer that holds the MPEG-2 data.
    ubyte*  pDataBuffer;
}

///The <b>MPEG_TIME</b> structure represents a time of day, or a duration.
struct MPEG_TIME
{
    ///Specifies the hours. The value can range from 0 to 23, inclusive.
    ubyte Hours;
    ///Specifies the minutes. The value can range from 0 to 59, inclusive.
    ubyte Minutes;
    ///Specifies the seconds. The value can range from 0 to 59, inclusive.
    ubyte Seconds;
}

///The <b>MPEG_DATE</b> structure specifies a date.
struct MPEG_DATE
{
align (1):
    ///Specifies the day of the month. The value can range from 1 to 31, inclusive.
    ubyte  Date;
    ///Specifies the month. The value can range from 1 to 12, inclusive.
    ubyte  Month;
    ///Specifies the year.
    ushort Year;
}

///The <b>MPEG_DATE_AND_TIME</b> structure specifies a date and time.
struct MPEG_DATE_AND_TIME
{
    ///Specifies the date, as an MPEG_DATE structure.
    MPEG_DATE D;
    ///Specifies the time, as an MPEG_TIME structure.
    MPEG_TIME T;
}

///The <b>MPEG_BCS_DEMUX</b> structure identifies the filter graph that is providing the MPEG-2 data stream.
struct MPEG_BCS_DEMUX
{
align (1):
    ///Specifies the filter graph instance.
    uint AVMGraphId;
}

///The <b>MPEG_WINSOCK</b> structure is not supported.
struct MPEG_WINSOCK
{
align (1):
    ///Reserved.
    uint AVMGraphId;
}

///The <b>MPEG_CONTEXT</b> structure identifies the source of an MPEG-2 data stream.
struct MPEG_CONTEXT
{
align (1):
    ///Specifies the source type, as an MPEG_CONTEXT_TYPE value. Currently, the value must be MPEG_CONTEXT_BCS_DEMUX.
    MPEG_CONTEXT_TYPE Type;
    union U
    {
        MPEG_BCS_DEMUX Demux;
        MPEG_WINSOCK   Winsock;
    }
}

struct __MIDL___MIDL_itf_mpeg2structs_0000_0000_0033
{
align (1):
    MPEG_REQUEST_TYPE Type;
    MPEG_CONTEXT      Context;
    ushort            Pid;
    ubyte             TableId;
    MPEG2_FILTER      Filter;
    uint              Flags;
}

struct __MIDL___MIDL_itf_mpeg2structs_0000_0000_0034
{
align (1):
    uint   IPAddress;
    ushort Port;
}

///The <b>DSMCC_ELEMENT</b> structure contains information from a DSM-CC element.
struct DSMCC_ELEMENT
{
align (1):
    ///Packet identifier (PID).
    ushort         pid;
    ///Component tag.
    ubyte          bComponentTag;
    ///Carousel identifier.
    uint           dwCarouselId;
    ///Transaction identifier.
    uint           dwTransactionId;
    ///Pointer to the next <b>DSMCC_ELEMENT</b> structure in the list, or <b>NULL</b> if this element is the end of the
    ///list.
    DSMCC_ELEMENT* pNext;
}

///The <b>MPE_ELEMENT</b> structure contains information from a multi-protocol encapsulation (MPE) element.
struct MPE_ELEMENT
{
align (1):
    ///Packet identifier (PID).
    ushort       pid;
    ///Component tag.
    ubyte        bComponentTag;
    ///Pointer to the next <b>MPE_ELEMENT</b> structure in the list, or <b>NULL</b> if this element is the end of the
    ///list.
    MPE_ELEMENT* pNext;
}

struct MPEG_STREAM_FILTER
{
align (1):
    ushort    wPidValue;
    uint      dwFilterSize;
    BOOL      fCrcEnabled;
    ubyte[16] rgchFilter;
    ubyte[16] rgchMask;
}

struct Mpeg2TableSampleHdr
{
align (1):
    ubyte    SectionCount;
    ubyte[3] Reserved;
    int[1]   SectionOffsets;
}

struct __MIDL_IPAT_0001
{
    ushort wProgramNumber;
    ushort wProgramMapPID;
}

struct UDCR_TAG
{
    ubyte     bVersion;
    ubyte[25] KID;
    ulong     ullBaseCounter;
    ulong     ullBaseCounterRange;
    BOOL      fScrambled;
    ubyte     bStreamMark;
    uint      dwReserved1;
    uint      dwReserved2;
}

struct PIC_SEQ_SAMPLE
{
    uint _bitfield15;
}

struct SAMPLE_SEQ_OFFSET
{
    uint _bitfield16;
}

struct VA_OPTIONAL_VIDEO_PROPERTIES
{
    ushort             dwPictureHeight;
    ushort             dwPictureWidth;
    ushort             dwAspectRatioX;
    ushort             dwAspectRatioY;
    VA_VIDEO_FORMAT    VAVideoFormat;
    VA_COLOR_PRIMARIES VAColorPrimaries;
    VA_TRANSFER_CHARACTERISTICS VATransferCharacteristics;
    VA_MATRIX_COEFFICIENTS VAMatrixCoefficients;
}

struct TRANSPORT_PROPERTIES
{
    uint PID;
    long PCR;
    union Fields
    {
        struct Others
        {
            long _bitfield17;
        }
        long Value;
    }
}

struct PBDA_TAG_ATTRIBUTE
{
    GUID     TableUUId;
    ubyte    TableId;
    ushort   VersionNo;
    uint     TableDataSize;
    ubyte[1] TableData;
}

struct CAPTURE_STREAMTIME
{
    long StreamTime;
}

struct DSHOW_STREAM_DESC
{
    uint VersionNo;
    uint StreamId;
    BOOL Default;
    BOOL Creation;
    uint Reserved;
}

struct SAMPLE_LIVE_STREAM_TIME
{
    ulong qwStreamTime;
    ulong qwLiveTime;
}

struct KSP_BDA_NODE_PIN
{
    KSIDENTIFIER Property;
    uint         ulNodeType;
    uint         ulInputPinId;
    uint         ulOutputPinId;
}

struct KSM_BDA_PIN
{
    KSIDENTIFIER Method;
    union
    {
        uint PinId;
        uint PinType;
    }
    uint         Reserved;
}

struct KSM_BDA_PIN_PAIR
{
    KSIDENTIFIER Method;
    union
    {
        uint InputPinId;
        uint InputPinType;
    }
    union
    {
        uint OutputPinId;
        uint OutputPinType;
    }
}

struct KSP_NODE_ESPID
{
    KSP_NODE Property;
    uint     EsPid;
}

struct KSM_BDA_DEBUG_LEVEL
{
    KSIDENTIFIER Method;
    ubyte        ucDebugLevel;
    uint         ulDebugStringSize;
    ubyte[1]     argbDebugString;
}

struct BDA_DEBUG_DATA
{
    int      lResult;
    GUID     uuidDebugDataType;
    uint     ulDataSize;
    ubyte[1] argbDebugData;
}

struct BDA_EVENT_DATA
{
    int      lResult;
    uint     ulEventID;
    GUID     uuidEventType;
    uint     ulEventDataLength;
    ubyte[1] argbEventData;
}

struct KSM_BDA_EVENT_COMPLETE
{
    KSIDENTIFIER Method;
    uint         ulEventID;
    uint         ulEventResult;
}

struct KSM_BDA_DRM_SETDRM
{
    KSM_NODE NodeMethod;
    GUID     NewDRMuuid;
}

struct KSM_BDA_BUFFER
{
    KSM_NODE NodeMethod;
    uint     ulBufferSize;
    ubyte[1] argbBuffer;
}

struct KSM_BDA_WMDRM_LICENSE
{
    KSM_NODE NodeMethod;
    GUID     uuidKeyID;
}

struct KSM_BDA_WMDRM_RENEWLICENSE
{
    KSM_NODE NodeMethod;
    uint     ulXMRLicenseLength;
    uint     ulEntitlementTokenLength;
    ubyte[1] argbDataBuffer;
}

struct KSM_BDA_WMDRMTUNER_PURCHASEENTITLEMENT
{
    KSM_NODE NodeMethod;
    uint     ulDialogRequest;
    byte[12] cLanguage;
    uint     ulPurchaseTokenLength;
    ubyte[1] argbDataBuffer;
}

struct KSM_BDA_WMDRMTUNER_SETPIDPROTECTION
{
    KSM_NODE NodeMethod;
    uint     ulPID;
    GUID     uuidKeyID;
}

struct KSM_BDA_WMDRMTUNER_GETPIDPROTECTION
{
    KSM_NODE NodeMethod;
    uint     ulPID;
}

struct KSM_BDA_WMDRMTUNER_SYNCVALUE
{
    KSM_NODE NodeMethod;
    uint     ulSyncValue;
}

struct KSM_BDA_TUNER_TUNEREQUEST
{
    KSIDENTIFIER Method;
    uint         ulTuneLength;
    ubyte[1]     argbTuneData;
}

struct KSM_BDA_GPNV_GETVALUE
{
    KSIDENTIFIER Method;
    uint         ulNameLength;
    byte[12]     cLanguage;
    ubyte[1]     argbData;
}

struct KSM_BDA_GPNV_SETVALUE
{
    KSIDENTIFIER Method;
    uint         ulDialogRequest;
    byte[12]     cLanguage;
    uint         ulNameLength;
    uint         ulValueLength;
    ubyte[1]     argbName;
}

struct KSM_BDA_GPNV_NAMEINDEX
{
    KSIDENTIFIER Method;
    uint         ulValueNameIndex;
}

struct KSM_BDA_SCAN_CAPABILTIES
{
    KSIDENTIFIER Method;
    GUID         uuidBroadcastStandard;
}

struct KSM_BDA_SCAN_FILTER
{
    KSIDENTIFIER Method;
    uint         ulScanModulationTypeSize;
    ulong        AnalogVideoStandards;
    ubyte[1]     argbScanModulationTypes;
}

struct KSM_BDA_SCAN_START
{
    KSIDENTIFIER Method;
    uint         LowerFrequency;
    uint         HigherFrequency;
}

struct KSM_BDA_GDDS_TUNEXMLFROMIDX
{
    KSIDENTIFIER Method;
    ulong        ulIdx;
}

struct KSM_BDA_GDDS_SERVICEFROMTUNEXML
{
    KSIDENTIFIER Method;
    uint         ulTuneXmlLength;
    ubyte[1]     argbTuneXml;
}

struct KSM_BDA_USERACTIVITY_USEREASON
{
    KSIDENTIFIER Method;
    uint         ulUseReason;
}

struct KSM_BDA_CAS_ENTITLEMENTTOKEN
{
    KSM_NODE NodeMethod;
    uint     ulDialogRequest;
    byte[12] cLanguage;
    uint     ulRequestType;
    uint     ulEntitlementTokenLen;
    ubyte[1] argbEntitlementToken;
}

struct KSM_BDA_CAS_CAPTURETOKEN
{
    KSM_NODE NodeMethod;
    uint     ulTokenLength;
    ubyte[1] argbToken;
}

struct KSM_BDA_CAS_OPENBROADCASTMMI
{
    KSM_NODE NodeMethod;
    uint     ulDialogRequest;
    byte[12] cLanguage;
    uint     ulEventId;
}

struct KSM_BDA_CAS_CLOSEMMIDIALOG
{
    KSM_NODE NodeMethod;
    uint     ulDialogRequest;
    byte[12] cLanguage;
    uint     ulDialogNumber;
    uint     ulReason;
}

struct KSM_BDA_ISDBCAS_REQUEST
{
    KSM_NODE NodeMethod;
    uint     ulRequestID;
    uint     ulIsdbCommandSize;
    ubyte[1] argbIsdbCommandData;
}

struct KSM_BDA_TS_SELECTOR_SETTSID
{
    KSM_NODE NodeMethod;
    ushort   usTSID;
}

struct KS_DATARANGE_BDA_ANTENNA
{
    KSDATAFORMAT DataRange;
}

struct BDA_TRANSPORT_INFO
{
    uint ulcbPhyiscalPacket;
    uint ulcbPhyiscalFrame;
    uint ulcbPhyiscalFrameAlignment;
    long AvgTimePerFrame;
}

struct KS_DATARANGE_BDA_TRANSPORT
{
    KSDATAFORMAT       DataRange;
    BDA_TRANSPORT_INFO BdaTransportInfo;
}

struct ChannelChangeInfo
{
    ChannelChangeSpanningEvent_State state;
    ulong TimeStamp;
}

struct ChannelTypeInfo
{
    ChannelType channelType;
    ulong       timeStamp;
}

struct ChannelInfo
{
    int lFrequency;
    union
    {
        struct DVB
        {
            int lONID;
            int lTSID;
            int lSID;
        }
        struct DC
        {
            int lProgNumber;
        }
        struct ATSC
        {
            int lProgNumber;
        }
    }
}

struct SpanningEventDescriptor
{
    ushort   wDataLen;
    ushort   wProgNumber;
    ushort   wSID;
    ubyte[1] bDescriptor;
}

struct DVBScramblingControlSpanningEvent
{
    uint ulPID;
    BOOL fScrambled;
}

struct SpanningEventEmmMessage
{
    ubyte     bCAbroadcasterGroupId;
    ubyte     bMessageControl;
    ushort    wServiceId;
    ushort    wTableIdExtension;
    ubyte     bDeletionStatus;
    ubyte     bDisplayingDuration1;
    ubyte     bDisplayingDuration2;
    ubyte     bDisplayingDuration3;
    ubyte     bDisplayingCycle;
    ubyte     bFormatVersion;
    ubyte     bDisplayPosition;
    ushort    wMessageLength;
    ushort[1] szMessageArea;
}

struct LanguageInfo
{
    ushort LangID;
    int    lISOLangCode;
}

struct DualMonoInfo
{
    ushort LangID1;
    ushort LangID2;
    int    lISOLangCode1;
    int    lISOLangCode2;
}

struct PIDListSpanningEvent
{
    ushort  wPIDCount;
    uint[1] pulPIDs;
}

struct RATING_ATTRIBUTE
{
align (1):
    uint rating_attribute_id;
    uint rating_attribute_value;
}

struct RATING_SYSTEM
{
align (1):
    GUID              rating_system_id;
    ubyte             _bitfield18;
    ubyte[3]          country_code;
    uint              rating_attribute_count;
    RATING_ATTRIBUTE* lpratingattrib;
}

struct RATING_INFO
{
align (1):
    uint           rating_system_count;
    RATING_SYSTEM* lpratingsystem;
}

struct PBDAParentalControl
{
align (1):
    uint           rating_system_count;
    RATING_SYSTEM* rating_systems;
}

struct DvbParentalRatingParam
{
    byte[4] szCountryCode;
    ubyte   bRating;
}

struct DvbParentalRatingDescriptor
{
    uint ulNumParams;
    DvbParentalRatingParam[1] pParams;
}

struct KSPROPERTY_BDA_RF_TUNER_CAPS_S
{
    KSP_NODE Property;
    uint     Mode;
    uint     AnalogStandardsSupported;
    uint     DigitalStandardsSupported;
    uint     MinFrequency;
    uint     MaxFrequency;
    uint     SettlingTime;
    uint     AnalogSensingRange;
    uint     DigitalSensingRange;
    uint     MilliSecondsPerMHz;
}

struct KSPROPERTY_BDA_RF_TUNER_SCAN_STATUS_S
{
    KSP_NODE Property;
    uint     CurrentFrequency;
    uint     FrequencyRangeMin;
    uint     FrequencyRangeMax;
    uint     MilliSecondsLeft;
}

struct KSPROPERTY_BDA_RF_TUNER_STANDARD_S
{
    KSP_NODE       Property;
    _BdaSignalType SignalType;
    uint           SignalStandard;
}

struct KSPROPERTY_BDA_RF_TUNER_STANDARD_MODE_S
{
    KSP_NODE Property;
    BOOL     AutoDetect;
}

struct KSEVENTDATA_BDA_RF_TUNER_SCAN_S
{
    KSEVENTDATA  EventData;
    uint         StartFrequency;
    uint         EndFrequency;
    _BdaLockType LockRequested;
}

struct PID_BITS
{
align (1):
    ushort _bitfield19;
}

///The <b>MPEG_HEADER_BITS</b> structure contains the first 16 bits that follow the table_id in a generic MPEG-2 section
///header.
struct MPEG_HEADER_BITS
{
align (1):
    ushort _bitfield20;
}

///The <b>MPEG_HEADER_VERSION_BITS</b> structure contains the first 8 bits following the TSID in an MPEG-2 PSI section.
///These bits contain the version number and the current/next indicator.
struct MPEG_HEADER_VERSION_BITS
{
    ubyte _bitfield21;
}

///The <code>MPEG1WAVEFORMAT</code> structure describes the format of MPEG-1 audio data.
struct MPEG1WAVEFORMAT
{
align (1):
    ///WAVEFORMATEX structure that contains information about the audio format. See Remarks.
    WAVEFORMATEX wfx;
    ///Specifies the MPEG audio layer, as defined by the following constants: <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="ACM_MPEG_LAYER1"></a><a id="acm_mpeg_layer1"></a><dl>
    ///<dt><b>ACM_MPEG_LAYER1</b></dt> </dl> </td> <td width="60%"> Layer 1 </td> </tr> <tr> <td width="40%"><a
    ///id="ACM_MPEG_LAYER2"></a><a id="acm_mpeg_layer2"></a><dl> <dt><b>ACM_MPEG_LAYER2</b></dt> </dl> </td> <td
    ///width="60%"> Layer 2 </td> </tr> <tr> <td width="40%"><a id="ACM_MPEG_LAYER3"></a><a
    ///id="acm_mpeg_layer3"></a><dl> <dt><b>ACM_MPEG_LAYER3</b></dt> </dl> </td> <td width="60%"> Layer 3 </td> </tr>
    ///</table> Some MPEG streams may contain frames from more than one layer. If so, combine the flags with a bitwise
    ///<b>OR</b>.
    ushort       fwHeadLayer;
    ///Specifies the bitrate, in bits per second. This value gives the actual bitrate, not the MPEG frame header code.
    ///If the bitrate is variable, or is a non-standard bitrate, set this field to zero.
    uint         dwHeadBitrate;
    ///Specifies the stream mode, as defined by the following constants: <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="ACM_MPEG_STEREO"></a><a id="acm_mpeg_stereo"></a><dl>
    ///<dt><b>ACM_MPEG_STEREO</b></dt> </dl> </td> <td width="60%"> Stereo </td> </tr> <tr> <td width="40%"><a
    ///id="ACM_MPEG_JOINTSTEREO"></a><a id="acm_mpeg_jointstereo"></a><dl> <dt><b>ACM_MPEG_JOINTSTEREO</b></dt> </dl>
    ///</td> <td width="60%"> Joint stereo </td> </tr> <tr> <td width="40%"><a id="ACM_MPEG_DUALCHANNEL"></a><a
    ///id="acm_mpeg_dualchannel"></a><dl> <dt><b>ACM_MPEG_DUALCHANNEL</b></dt> </dl> </td> <td width="60%"> Dual channel
    ///</td> </tr> <tr> <td width="40%"><a id="ACM_MPEG_SINGLECHANNEL"></a><a id="acm_mpeg_singlechannel"></a><dl>
    ///<dt><b>ACM_MPEG_SINGLECHANNEL</b></dt> </dl> </td> <td width="60%"> Single channel </td> </tr> </table> Some MPEG
    ///streams may contain frames with different modes. If so, combine the flags with a bitwise OR.
    ushort       fwHeadMode;
    ///Specifies the mode extension for joint-stereo encoding: <table> <tr> <th>Value</th> <th>MPEG Frame Header
    ///Code</th> <th>Layers 1 and 2</th> <th>Layer 3</th> </tr> <tr> <td>0x01</td> <td>'00'</td> <td>Intensity stereo in
    ///bands 4 to 31</td> <td>Intensity stereo off; Middle/Side (MS) stereo off </td> </tr> <tr> <td>0x02</td>
    ///<td>'01'</td> <td>Intensity stereo in bands 8 to 31</td> <td>Intensity stereo on; MS stereo off </td> </tr> <tr>
    ///<td>0x04</td> <td>'10'</td> <td>Intensity stereo in bands 12 to 31</td> <td>Intensity stereo off; MS stereo on
    ///</td> </tr> <tr> <td>0x08</td> <td>'11'</td> <td>Intensity stereo in bands 16 to 31</td> <td>Intensity stereo
    ///off; MS stereo on </td> </tr> </table> These values may be combined with a bitwise <b>OR</b>. In general,
    ///encoders will dynamically switch between extension modes according to the characteristics of the signal.
    ///Therefore, for normal joint-stereo encoding, set this field to 0x0F (the bitwise OR of all the flags). However,
    ///you can use this field to limit the encoder to a set of allowable encoding types. This field applies only when
    ///<b>fwHeadMode</b> includes ACM_MPEG_JOINTSTEREO. For other modes, set this field to zero.
    ushort       fwHeadModeExt;
    ///Sepecifies the de-emphasis required by the decoder: <table> <tr> <th>Value</th> <th>MPEG Frame Header</th>
    ///<th>Code De-emphasis Required </th> </tr> <tr> <td>1</td> <td>'00'</td> <td>None </td> </tr> <tr> <td>2</td>
    ///<td>'01'</td> <td>50/15 ms emphasis </td> </tr> <tr> <td>3</td> <td>'10'</td> <td>Reserved </td> </tr> <tr>
    ///<td>4</td> <td>'11'</td> <td>CCITT J.17 </td> </tr> </table>
    ushort       wHeadEmphasis;
    ///Specifies a bitwise combination of zero or more of the following flags: <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="ACM_MPEG_PRIVATEBIT"></a><a id="acm_mpeg_privatebit"></a><dl>
    ///<dt><b>ACM_MPEG_PRIVATEBIT</b></dt> </dl> </td> <td width="60%"> Set the private bit. </td> </tr> <tr> <td
    ///width="40%"><a id="ACM_MPEG_COPYRIGHT"></a><a id="acm_mpeg_copyright"></a><dl> <dt><b>ACM_MPEG_COPYRIGHT</b></dt>
    ///</dl> </td> <td width="60%"> Set the copyright bit. </td> </tr> <tr> <td width="40%"><a
    ///id="ACM_MPEG_ORIGINALHOME"></a><a id="acm_mpeg_originalhome"></a><dl> <dt><b>ACM_MPEG_ORIGINALHOME</b></dt> </dl>
    ///</td> <td width="60%"> Set the original/home bit. </td> </tr> <tr> <td width="40%"><a
    ///id="ACM_MPEG_PROTECTIONBIT"></a><a id="acm_mpeg_protectionbit"></a><dl> <dt><b>ACM_MPEG_PROTECTIONBIT</b></dt>
    ///</dl> </td> <td width="60%"> Set the protection bit, and insert a 16-bit error protection code into each frame.
    ///</td> </tr> <tr> <td width="40%"><a id="ACM_MPEG_ID_MPEG1"></a><a id="acm_mpeg_id_mpeg1"></a><dl>
    ///<dt><b>ACM_MPEG_ID_MPEG1</b></dt> </dl> </td> <td width="60%"> Set the ID bit to 1, defining the stream as an
    ///MPEG-1 audio stream. </td> </tr> </table> An encoder will use these flags to set the corresponding bits in the
    ///MPEG audio frame headers.
    ushort       fwHeadFlags;
    ///Specifies the least signifcant 32 bits of the presentation time stamp (PTS) of the first frame of the audio
    ///stream.
    uint         dwPTSLow;
    ///Specifies the most significant bit of the PTS. The <b>dwPTSLow</b> and <b>dwPTSHigh</b> fields can be treated as
    ///a single 64-bit value.
    uint         dwPTSHigh;
}

///The <b>MPEGLAYER3WAVEFORMAT</b> structure describes an MPEG Audio Layer-3 (MP3) audio format.
struct MPEGLAYER3WAVEFORMAT
{
align (1):
    ///WAVEFORMATEX structure that specifies the basic audio format. The <b>wFormatTag</b> member must be
    ///<b>WAVE_FORMAT_MPEGLAYER3</b>. The <b>cbSize</b> member must be at least 12. (For <b>cbSize</b>, you can use the
    ///constant <b>MPEGLAYER3_WFX_EXTRA_BYTES</b>, defined in the Mmreg.h.)
    WAVEFORMATEX wfx;
    ///Set this structure member to <b>MPEGLAYER3_ID_MPEG</b>.
    ushort       wID;
    ///Indicates whether padding is used to adjust the average bitrate to the sampling rate. Use one of the following
    ///values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="MPEGLAYER3_FLAG_PADDING_ISO"></a><a id="mpeglayer3_flag_padding_iso"></a><dl>
    ///<dt><b>MPEGLAYER3_FLAG_PADDING_ISO</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> Insert padding as
    ///needed to achieve the stated average bitrate. </td> </tr> <tr> <td width="40%"><a
    ///id="MPEGLAYER3_FLAG_PADDING_ON"></a><a id="mpeglayer3_flag_padding_on"></a><dl>
    ///<dt><b>MPEGLAYER3_FLAG_PADDING_ON</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Always insert
    ///padding. The average bit rate may be higher than stated. </td> </tr> <tr> <td width="40%"><a
    ///id="MPEGLAYER3_FLAG_PADDING_OFF"></a><a id="mpeglayer3_flag_padding_off"></a><dl>
    ///<dt><b>MPEGLAYER3_FLAG_PADDING_OFF</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Never insert
    ///padding. The average bit rate may be lower than stated. </td> </tr> </table>
    uint         fdwFlags;
    ///Block size in bytes. This value equals the frame length in bytes x <b>nFramesPerBlock</b>. For MP3 audio, the
    ///frame length is calculated as follows: 144 x (bitrate / sample rate) + padding.
    ushort       nBlockSize;
    ///Number of audio frames per block.
    ushort       nFramesPerBlock;
    ///Encoder delay in samples. If you do not know this value, set this structure member to zero.
    ushort       nCodecDelay;
}

///Contains format data for an Advanced Audio Coding (AAC) or High-Efficiency Advanced Audio Coding (HE-AAC) stream.
struct HEAACWAVEINFO
{
align (1):
    ///A <b>WAVEFORMATEX</b> structure that describes the core AAC stream, without SBR or PS extensions. See Remarks.
    WAVEFORMATEX wfx;
    ///The payload type. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl>
    ///</td> <td width="60%"> The stream contains raw_data_block elements only. </td> </tr> <tr> <td width="40%"> <dl>
    ///<dt>1</dt> </dl> </td> <td width="60%"> Audio Data Transport Stream (ADTS). The stream contains an adts_sequence,
    ///as defined by MPEG-2. </td> </tr> <tr> <td width="40%"> <dl> <dt>2</dt> </dl> </td> <td width="60%"> Audio Data
    ///Interchange Format (ADIF). The stream contains an adif_sequence, as defined by MPEG-2. </td> </tr> <tr> <td
    ///width="40%"> <dl> <dt>3</dt> </dl> </td> <td width="60%"> The stream contains an MPEG-4 audio transport stream
    ///with a synchronization layer (LOAS) and a multiplex layer (LATM). </td> </tr> </table>
    ushort       wPayloadType;
    ///Contains the value of the <b>audioProfileLevelIndication</b> field, as defined by ISO/IEC 14496-3 (MPEG-4 Audio).
    ///If the value is unknown, set this member to zero or 0xFE ("no audio profile specified").
    ushort       wAudioProfileLevelIndication;
    ///Defines the data that follows this structure. Currently the following value is defined. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The data
    ///that follows the <b>HEAACWAVEINFO</b> structure contains the value of AudioSpecificConfig(), as defined by
    ///ISO/IEC 14496-3. The size of the data is <code>wfx.cbSize - sizeof(HEAACWAVEINFO) + sizeof(WAVEFORMATEX)</code>.
    ///If the size is greater than zero, you can access the data by casting the <b>HEAACWAVEINFO</b> structure to a
    ///HEAACWAVEFORMAT structure. </td> </tr> </table> All other values for this member are reserved.
    ushort       wStructType;
    ///Reserved. Set to zero.
    ushort       wReserved1;
    ///Reserved. Set to zero.
    uint         dwReserved2;
}

///Contains format data for an AAC or HE-AAC stream that includes AudioSpecificConfig() data.
struct HEAACWAVEFORMAT
{
    ///A HEAACWAVEINFO structure.
    HEAACWAVEINFO wfInfo;
    ///A byte array that contains the value of AudioSpecificConfig(), as defined by ISO/IEC 14496-3. The array might be
    ///larger than the size given in the structure declaration. Use the value of <b>wfInfo.wfx.cbSize</b> to determine
    ///the size.
    ubyte[1]      pbAudioSpecificConfig;
}

///The <b>DMO_MEDIA_TYPE</b> structure describes the format of the data used by a stream in a Microsoft DirectX Media
///Object (DMO).
struct DMO_MEDIA_TYPE
{
    ///Major type GUID of the stream.
    GUID     majortype;
    ///Subtype GUID of the stream.
    GUID     subtype;
    ///If <b>TRUE</b>, samples are of a fixed size. This field is informational only. For audio, it is generally set to
    ///<b>TRUE</b>. For video, it is usually <b>TRUE</b> for uncompressed video and <b>FALSE</b> for compressed video.
    BOOL     bFixedSizeSamples;
    ///If <b>TRUE</b>, samples are compressed using temporal (interframe) compression. (A value of <b>TRUE</b> indicates
    ///that not all frames are key frames.) This field is informational only.
    BOOL     bTemporalCompression;
    ///Size of the sample in bytes. For compressed data, the value can be zero.
    uint     lSampleSize;
    ///GUID specifying the format type. The <b>pbFormat</b> member points to the corresponding format structure. Format
    ///types include the following. <table> <tr> <th>Format type</th> <th>Format structure</th> </tr> <tr> <td
    ///width="40%"><a id="FORMAT_DvInfo"></a><a id="format_dvinfo"></a><a id="FORMAT_DVINFO"></a><dl>
    ///<dt><b>FORMAT_DvInfo</b></dt> </dl> </td> <td width="60%"> DVINFO </td> </tr> <tr> <td width="40%"><a
    ///id="FORMAT_MPEG2Video"></a><a id="format_mpeg2video"></a><a id="FORMAT_MPEG2VIDEO"></a><dl>
    ///<dt><b>FORMAT_MPEG2Video</b></dt> </dl> </td> <td width="60%"> MPEG2VIDEOINFO </td> </tr> <tr> <td width="40%"><a
    ///id="FORMAT_MPEGVideo"></a><a id="format_mpegvideo"></a><a id="FORMAT_MPEGVIDEO"></a><dl>
    ///<dt><b>FORMAT_MPEGVideo</b></dt> </dl> </td> <td width="60%"> MPEG1VIDEOINFO </td> </tr> <tr> <td width="40%"><a
    ///id="FORMAT_None"></a><a id="format_none"></a><a id="FORMAT_NONE"></a><dl> <dt><b>FORMAT_None</b></dt> </dl> </td>
    ///<td width="60%"> None. </td> </tr> <tr> <td width="40%"><a id="FORMAT_VideoInfo"></a><a
    ///id="format_videoinfo"></a><a id="FORMAT_VIDEOINFO"></a><dl> <dt><b>FORMAT_VideoInfo</b></dt> </dl> </td> <td
    ///width="60%"> VIDEOINFOHEADER </td> </tr> <tr> <td width="40%"><a id="FORMAT_VideoInfo2"></a><a
    ///id="format_videoinfo2"></a><a id="FORMAT_VIDEOINFO2"></a><dl> <dt><b>FORMAT_VideoInfo2</b></dt> </dl> </td> <td
    ///width="60%"> VIDEOINFOHEADER2 </td> </tr> <tr> <td width="40%"><a id="FORMAT_WaveFormatEx"></a><a
    ///id="format_waveformatex"></a><a id="FORMAT_WAVEFORMATEX"></a><dl> <dt><b>FORMAT_WaveFormatEx</b></dt> </dl> </td>
    ///<td width="60%"> WAVEFORMATEX </td> </tr> </table>
    GUID     formattype;
    ///Not used. Set to <b>NULL</b>.
    IUnknown pUnk;
    ///Size of the format block of the media type.
    uint     cbFormat;
    ///Pointer to the format structure. The structure type is specified by the <b>formattype</b> member. The format
    ///structure must be present, unless <b>formattype</b> is GUID_NULL or FORMAT_None.
    ubyte*   pbFormat;
}

///The <code>DMO_OUTPUT_DATA_BUFFER</code> structure describes an output buffer used by a Microsoft DirectX Media Object
///(DMO).
struct DMO_OUTPUT_DATA_BUFFER
{
    ///Pointer to the IMediaBuffer interface of a buffer allocated by the application.
    IMediaBuffer pBuffer;
    ///Status flags. After processing output, the DMO sets this member to a bitwise combination of zero or more
    ///DMO_OUTPUT_DATA_BUFFER_FLAGS flags.
    uint         dwStatus;
    ///Time stamp that specifies the start time of the data in the buffer. If the buffer has a valid time stamp, the DMO
    ///sets this member and also sets the DMO_OUTPUT_DATA_BUFFERF_TIME flag in the <b>dwStatus</b> member. Otherwise,
    ///ignore this member.
    long         rtTimestamp;
    ///Reference time specifying the length of the data in the buffer. If the DMO sets this member to a valid value, it
    ///also sets the DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH flag in the <b>dwStatus</b> member. Otherwise, ignore this
    ///member.
    long         rtTimelength;
}

///Contains data for the Set Protection Level command in Certified Output Protection Protocol (COPP).
struct DXVA_COPPSetProtectionLevelCmdData
{
    ///Identifies the protection mechanism. See COPP Protection Type Flags.
    uint ProtType;
    ///Specifies the protection level. The meaning of this value depends on the protection mechanism that is queried.
    ///For each protection mechanism, the value of the <code>ProtLevel</code> member is a flag from a different
    ///enumeration, as shown in the following table. <table> <tr> <th>Protection mechanism</th> <th>Enumeration</th>
    ///</tr> <tr> <td>ACP</td> <td> COPP_ACP_Protection_Level </td> </tr> <tr> <td>CGMS-A</td> <td>
    ///COPP_CGMSA_Protection_Level </td> </tr> <tr> <td>HDCP</td> <td> COPP_HDCP_Protection_Level </td> </tr> </table>
    uint ProtLevel;
    ///Reserved. Must be zero.
    uint ExtendedInfoChangeMask;
    ///Reserved. Must be zero.
    uint ExtendedInfoData;
}

///Contains information for the Set Signal command in Certified Output Protection Protocol (COPP). This command causes
///the driver to insert Wide Screen Signalling (WSS) codes or other data packets in the television signal, as required
///by some Analog Copy Protection (ACP) and Copy Generation Management System — Analog (CGMS-A) specifications. For
///example: <ul> <li>ETSI EN 300 294 (625i PAL): Data packets are inserted into line 23 of the signal.</li>
///<li>CEA-608-B (NTSC): Data packets are inserted into line 21 of the vertical blanking interval (VBI).</li> </ul>
struct DXVA_COPPSetSignalingCmdData
{
    ///Specifies the protection standard and format that is current active. The value is a member of the
    ///COPP_TVProtectionStandard enumeration.
    uint    ActiveTVProtectionStandard;
    ///Bit mask indicating which bits from <b>AspectRatioData1</b> to set in the signal.
    uint    AspectRatioChangeMask1;
    ///Specifies the aspect ratio value to be set for the current protection standard. For EN 300 294, use the
    ///COPP_ImageAspectRatio_EN300294 enumeration.
    uint    AspectRatioData1;
    ///Bit mask indicating which bits from <b>AspectRatioData2</b> to set in the signal.
    uint    AspectRatioChangeMask2;
    ///An additional data element related to aspect ratio. The presence and meaning of this data depends on the
    ///protection standard. This field can be used to convey End and Q0 bits for EIA-608-B, or the active format
    ///description for CEA-805-A.
    uint    AspectRatioData2;
    ///Bit mask indicating which bits from <b>AspectRatioData3</b> to set in the signal.
    uint    AspectRatioChangeMask3;
    ///An additional data element related to aspect ratio for the current protection standard. The presence and meaning
    ///of this data depends on the protection standard.
    uint    AspectRatioData3;
    ///Array of bit masks indicating which bits in <b>ExtendedInfoData</b> to change. This array is currently not used.
    ///Set each member to zero.
    uint[4] ExtendedInfoChangeMask;
    ///Additional signaling elements to be set. This array is currently not used. Set each member to zero.
    uint[4] ExtendedInfoData;
    ///Reserved. Set to zero.
    uint    Reserved;
}

///Contains the result from a Certified Output Protection Protocol (COPP) status request.
struct DXVA_COPPStatusData
{
    ///A 128-bit random number that was passed by the application in the AMCOPPStatusInput structure.
    GUID rApp;
    ///Status flag. See COPP_StatusFlags.
    uint dwFlags;
    ///Response to the status query. The meaning of this value depends on the status request. For more information, see
    ///COPP Query Reference.
    uint dwData;
    ///Reserved. Must be zero.
    uint ExtendedInfoValidMask;
    ///Reserved. Must be zero.
    uint ExtendedInfoData;
}

///Contains the result of a Display Data query in Certified Output Protection Protocol (COPP).
struct DXVA_COPPStatusDisplayData
{
    ///A 128-bit random number that was passed by the application in the AMCOPPStatusInput structure.
    GUID rApp;
    ///Status flag. See COPP_StatusFlags.
    uint dwFlags;
    ///Width of the display mode, in pixels.
    uint DisplayWidth;
    ///Height of the display mode, in pixels.
    uint DisplayHeight;
    ///Contains a <b>DXVA_ExtendedFormat</b> structure packed into a <b>ULONG</b>, describing the video format.
    uint Format;
    ///Contains a <b>D3DFORMAT</b> value that describes the video format. For more information, see the Direct3D SDK
    ///documentation.
    uint d3dFormat;
    ///The numerator of the refresh rate of the current display mode.
    uint FreqNumerator;
    ///The denominator of the refresh rate of the current display mode.
    uint FreqDenominator;
}

///Contains the result from an HDCP Key Data query in Certified Output Protection Protocol (COPP). This query returns
///the device's HDCP key selection vector (KSV).
struct DXVA_COPPStatusHDCPKeyData
{
    ///A 128-bit random number that was passed by the application in the AMCOPPStatusInput structure.
    GUID rApp;
    ///Status flag. See COPP_StatusFlags.
    uint dwFlags;
    ///Receives zero or more flags from the COPP_StatusHDCPFlags enumeration. If the COPP_HDCPRepeater flag is present,
    ///the application should not play the content using this graphics adapter.
    uint dwHDCPFlags;
    ///Receives the HDCP key selection vector, B<sub>KSV</sub>, from the HDSCP device attached to the graphics adapter.
    GUID BKey;
    ///Reserved. Must be zero.
    GUID Reserved1;
    ///Reserved. Must be zero.
    GUID Reserved2;
}

///Contains the result from a Signaling query in Certified Output Protection Protocol (COPP).
struct DXVA_COPPStatusSignalingCmdData
{
    ///A 128-bit random number that was passed by the application in the <b>AMCOPPStatusInput</b> structure.
    GUID    rApp;
    ///Status flag. See COPP_StatusFlags.
    uint    dwFlags;
    ///Bitwise <b>OR</b> of flags from the COPP_TVProtectionStandard enumeration. The driver should return flags for all
    ///of the protection standards and resolutions that it supports.
    uint    AvailableTVProtectionStandards;
    ///Member of the COPP_TVProtectionStandard enumeration, indicating the protection standard that is currently active.
    uint    ActiveTVProtectionStandard;
    ///Reserved.
    uint    TVType;
    ///Bit mask indicating which bits of <b>AspectRatioData1</b> are valid.
    uint    AspectRatioValidMask1;
    ///Specifies the current aspect ratio value. For EN 300 294, the value is a member of the
    ///COPP_ImageAspectRatio_EN300294 enumeration.
    uint    AspectRatioData1;
    ///Bit mask indicating which bits of <b>AspectRatioData2</b> are valid.
    uint    AspectRatioValidMask2;
    ///Additional data element related to aspect ratio for the current protection standard. The presence and meaning of
    ///this data depends on the protection standard. This field may be used to convey End and Q0 bits for EIA-608-B, or
    ///the active format description for CEA-805-A.
    uint    AspectRatioData2;
    ///Bit mask indicating which bits of <b>AspectRatioData3</b> are valid.
    uint    AspectRatioValidMask3;
    ///Additional data element related to aspect ratio for the current protection standard. The presence and meaning of
    ///this data depends on the protection standard.
    uint    AspectRatioData3;
    ///Array of bit masks indicating which bits in <b>ExtendedInfoData</b> are valid.
    uint[4] ExtendedInfoValidMask;
    ///Additional signaling elements. This array is currently not used.
    uint[4] ExtendedInfoData;
}

///Describes a color key as a range of values.
struct DDCOLORKEY
{
    uint dwColorSpaceLowValue;
    uint dwColorSpaceHighValue;
}

// Functions

///The <b>AMGetErrorText</b> function retrieves the error message for a given return code, using the current language
///setting. This function converts <b>HRESULT</b> return codes to error messages. The constant MAX_ERROR_TEXT_LEN
///specifies the maximum number of characters in an error message.
///Params:
///    hr = <b>HRESULT</b> value.
///    pbuffer = Pointer to a character buffer that receives the error message.
///    MaxLen = Number of characters in <i>pBuffer</i>.
///Returns:
///    Returns the number of characters returned in the buffer, or zero if an error occurred.
///    
@DllImport("QUARTZ")
uint AMGetErrorTextA(HRESULT hr, const(char)* pbuffer, uint MaxLen);

///The <b>AMGetErrorText</b> function retrieves the error message for a given return code, using the current language
///setting. This function converts <b>HRESULT</b> return codes to error messages. The constant MAX_ERROR_TEXT_LEN
///specifies the maximum number of characters in an error message.
///Params:
///    hr = <b>HRESULT</b> value.
///    pbuffer = Pointer to a character buffer that receives the error message.
///    MaxLen = Number of characters in <i>pBuffer</i>.
///Returns:
///    Returns the number of characters returned in the buffer, or zero if an error occurred.
///    
@DllImport("QUARTZ")
uint AMGetErrorTextW(HRESULT hr, const(wchar)* pbuffer, uint MaxLen);

///The <b>DMORegister</b> function registers a DMO.
///Params:
///    szName = NULL-terminated string that contains a descriptive name for the DMO. Names longer than 79 characters might be
///             truncated.
///    clsidDMO = Class identifier (CLSID) of the DMO.
///    guidCategory = GUID that specifies the category of the DMO. See DMO GUIDs for a list of category GUIDs.
///    dwFlags = Bitwise combination of zero or more flags from the DMO_REGISTER_FLAGS enumeration.
///    cInTypes = Number of input media types to register. Can be zero.
///    pInTypes = Pointer to an array of DMO_PARTIAL_MEDIATYPE structures that specify the input media types. The size of the array
///               is specified in the cInTypes parameter
///    cOutTypes = Number of output media types to register.
///    pOutTypes = Pointer to an array of DMO_PARTIAL_MEDIATYPE structures that specify the output media types. The size of the
///                array is specified in the cOutTypes parameter. Can be zero.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr>
///    </table>
///    
@DllImport("msdmo")
HRESULT DMORegister(const(wchar)* szName, const(GUID)* clsidDMO, const(GUID)* guidCategory, uint dwFlags, 
                    uint cInTypes, const(DMO_PARTIAL_MEDIATYPE)* pInTypes, uint cOutTypes, 
                    const(DMO_PARTIAL_MEDIATYPE)* pOutTypes);

///The DMOUnregister function unregisters a DMO.
///Params:
///    clsidDMO = Class identifier (CLSID) of the DMO.
///    guidCategory = GUID that specifies the category from which to remove the DMO. Use GUID_NULL to unregister the DMO from every
///                   category. See DMO GUIDs for a list of category GUIDs.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Result Code</th>
///    <th>Description</th> </tr> <tr> <td>E_INVALIDARG</td> <td>Invalid argument</td> </tr> <tr> <td>S_FALSE</td>
///    <td>This CLSID was not registered in the specified category.</td> </tr> <tr> <td>S_OK</td> <td>Success</td> </tr>
///    </table>
///    
@DllImport("msdmo")
HRESULT DMOUnregister(const(GUID)* clsidDMO, const(GUID)* guidCategory);

///The <b>DMOEnum</b> function enumerates DMOs listed in the registry. The caller can search by category, media type, or
///both.
///Params:
///    guidCategory = GUID that specifies which category of DMO to search. Use GUID_NULL to search every category. See DMO GUIDs for a
///                   list of category GUIDs.
///    dwFlags = Bitwise combination of zero or more flags from the DMO_ENUM_FLAGS enumeration.
///    cInTypes = Number of input media types to use in the search criteria. Use zero to match any input type.
///    pInTypes = Pointer to an array of DMO_PARTIAL_MEDIATYPE structures that contain the input media types. Specify the size of
///               the array in the cInTypes parameter.
///    cOutTypes = Number of output media types to use in the search criteria. Use zero to match any output type.
///    pOutTypes = Pointer to an array of DMO_PARTIAL_MEDIATYPE structures that contain the output media types. Specify the size of
///                the array in the cOutTypes parameter.
///    ppEnum = Address of a variable to receive the IEnumDMO interface of the enumerator.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient
///    memory </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td>
///    </tr> </table>
///    
@DllImport("msdmo")
HRESULT DMOEnum(const(GUID)* guidCategory, uint dwFlags, uint cInTypes, const(DMO_PARTIAL_MEDIATYPE)* pInTypes, 
                uint cOutTypes, const(DMO_PARTIAL_MEDIATYPE)* pOutTypes, IEnumDMO* ppEnum);

///The <b>DMOGetTypes</b> function retrieves the name of a DMO from the registry.
///Params:
///    clsidDMO = Class identifier (CLSID) of the DMO.
///    ulInputTypesRequested = Size of the array passed in the <i>pInputTypes</i> parameter.
///    pulInputTypesSupplied = Pointer to a variable that receives the number of DMO_PARTIAL_MEDIATYPE structures in <i>pInputTypes</i> that the
///                            function fills in.
///    pInputTypes = Pointer to a caller-allocated array of DMO_PARTIAL_MEDIATYPE structures. The size of the array is given in the
///                  ulInputTypesRequested parameter. The function fills the array with the input types registered for the DMO.
///    ulOutputTypesRequested = Size of the array passed in the <i>pOutputTypes</i> parameter.
///    pulOutputTypesSupplied = Pointer to a variable that receives the number of DMO_PARTIAL_MEDIATYPE structures in <i>pOutputTypes</i> that
///                             the function fills in.
///    pOutputTypes = Pointer to a caller-allocated array of DMO_PARTIAL_MEDIATYPE structures. The size of the array is given in the
///                   <i>ulOutputTypesRequested</i> parameter. The function fills the array with the DMO output types registered for
///                   the DMO.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Array too small.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr>
///    </table>
///    
@DllImport("msdmo")
HRESULT DMOGetTypes(const(GUID)* clsidDMO, uint ulInputTypesRequested, uint* pulInputTypesSupplied, 
                    DMO_PARTIAL_MEDIATYPE* pInputTypes, uint ulOutputTypesRequested, uint* pulOutputTypesSupplied, 
                    DMO_PARTIAL_MEDIATYPE* pOutputTypes);

///The <b>DMOGetName</b> function retrieves the name of a DMO from the registry.
///Params:
///    clsidDMO = Class identifier (CLSID) of the DMO.
///    szName = Array of 80 Unicode characters that receives the name of the DMO. The caller must allocate the array. The name is
///             a NULL-terminated string.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No name was
///    registered for this DMO, or the name has zero length. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
///    </dl> </td> <td width="60%"> Success </td> </tr> </table>
///    
@DllImport("msdmo")
HRESULT DMOGetName(const(GUID)* clsidDMO, char* szName);

///The <b>MoInitMediaType</b> function initializes a media type structure.
///Params:
///    pmt = Pointer to an uninitialized DMO_MEDIA_TYPE structure allocated by the caller.
///    cbFormat = Number of bytes to allocate for the format block. Can be zero.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
///    Insufficient memory </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
///    <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> Success </td> </tr> </table>
///    
@DllImport("msdmo")
HRESULT MoInitMediaType(AM_MEDIA_TYPE* pmt, uint cbFormat);

///The <b>MoFreeMediaType</b> function frees the allocated members of a media type structure.
///Params:
///    pmt = Pointer to an initialized DMO_MEDIA_TYPE structure.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
///    <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> Success </td> </tr> </table>
///    
@DllImport("msdmo")
HRESULT MoFreeMediaType(AM_MEDIA_TYPE* pmt);

///The <b>MoCopyMediaType</b> function copies the members of one media type structure into another media type structure.
///Params:
///    pmtDest = Pointer to the target DMO_MEDIA_TYPE structure. The caller must allocate, but not initialize, this structure.
///    pmtSrc = Pointer to the source DMO_MEDIA_TYPE structure.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
///    Insufficient memory </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
///    <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> Success </td> </tr> </table>
///    
@DllImport("msdmo")
HRESULT MoCopyMediaType(AM_MEDIA_TYPE* pmtDest, const(AM_MEDIA_TYPE)* pmtSrc);

///The <b>MoCreateMediaType</b> function allocates a new media type structure.
///Params:
///    ppmt = Receives a pointer to an allocated DMO_MEDIA_TYPE structure.
///    cbFormat = Number of bytes to allocate for the format block. Can be zero.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
///    Insufficient memory </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
///    <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> Success </td> </tr> </table>
///    
@DllImport("msdmo")
HRESULT MoCreateMediaType(AM_MEDIA_TYPE** ppmt, uint cbFormat);

///The <b>MoDeleteMediaType</b> function deletes a media type structure that was previously allocated.
///Params:
///    pmt = Pointer to an initialized DMO_MEDIA_TYPE structure.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
///    <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> Success </td> </tr> </table>
///    
@DllImport("msdmo")
HRESULT MoDeleteMediaType(AM_MEDIA_TYPE* pmt);

///The <b>MoDuplicateMediaType</b> function duplicates a media type structure.
///Params:
///    ppmtDest = Address of a pointer to a DMO_MEDIA_TYPE structure that receives the duplicated structure.
///    pmtSrc = Pointer to the media type structure to duplicate.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
///    Insufficient memory </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
///    <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> Success </td> </tr> </table>
///    
@DllImport("msdmo")
HRESULT MoDuplicateMediaType(AM_MEDIA_TYPE** ppmtDest, const(AM_MEDIA_TYPE)* pmtSrc);


// Interfaces

@GUID("E436EBB3-524F-11CE-9F53-0020AF0BA770")
struct FilgraphManager;

@GUID("17CCA71B-ECD7-11D0-B908-00A0C9223196")
struct CLSID_Proxy;

@GUID("D02AAC50-027E-11D3-9D8E-00C04F72D980")
struct SystemTuningSpaces;

@GUID("5FFDC5E6-B83A-4B55-B6E8-C69E765FE9DB")
struct TuningSpace;

@GUID("CC829A2F-3365-463F-AF13-81DBB6F3A555")
struct ChannelIDTuningSpace;

@GUID("A2E30750-6C3D-11D3-B653-00C04F79498E")
struct ATSCTuningSpace;

@GUID("D9BB4CEE-B87A-47F1-AC92-B08D9C7813FC")
struct DigitalCableTuningSpace;

@GUID("8A674B4C-1F63-11D3-B64C-00C04F79498E")
struct AnalogRadioTuningSpace;

@GUID("F9769A06-7ACA-4E39-9CFB-97BB35F0E77E")
struct AuxInTuningSpace;

@GUID("8A674B4D-1F63-11D3-B64C-00C04F79498E")
struct AnalogTVTuningSpace;

@GUID("C6B14B32-76AA-4A86-A7AC-5C79AAF58DA7")
struct DVBTuningSpace;

@GUID("B64016F3-C9A2-4066-96F0-BD9563314726")
struct DVBSTuningSpace;

@GUID("A1A2B1C4-0E3A-11D3-9D8E-00C04F72D980")
struct ComponentTypes;

@GUID("823535A0-0318-11D3-9D8E-00C04F72D980")
struct ComponentType;

@GUID("1BE49F30-0E1B-11D3-9D8E-00C04F72D980")
struct LanguageComponentType;

@GUID("418008F3-CF67-4668-9628-10DC52BE1D08")
struct MPEG2ComponentType;

@GUID("A8DCF3D5-0780-4EF4-8A83-2CFFAACB8ACE")
struct ATSCComponentType;

@GUID("809B6661-94C4-49E6-B6EC-3F0F862215AA")
struct Components;

@GUID("59DC47A8-116C-11D3-9D8E-00C04F72D980")
struct Component;

@GUID("055CB2D7-2969-45CD-914B-76890722F112")
struct MPEG2Component;

@GUID("28AB0005-E845-4FFA-AA9B-F4665236141C")
struct AnalogAudioComponentType;

@GUID("B46E0D38-AB35-4A06-A137-70576B01B39F")
struct TuneRequest;

@GUID("3A9428A7-31A4-45E9-9EFB-E055BF7BB3DB")
struct ChannelIDTuneRequest;

@GUID("0369B4E5-45B6-11D3-B650-00C04F79498E")
struct ChannelTuneRequest;

@GUID("0369B4E6-45B6-11D3-B650-00C04F79498E")
struct ATSCChannelTuneRequest;

@GUID("26EC0B63-AA90-458A-8DF4-5659F2C8A18A")
struct DigitalCableTuneRequest;

@GUID("0955AC62-BF2E-4CBA-A2B9-A63F772D46CF")
struct MPEG2TuneRequest;

@GUID("2C63E4EB-4CEA-41B8-919C-E947EA19A77C")
struct MPEG2TuneRequestFactory;

@GUID("0888C883-AC4F-4943-B516-2C38D9B34562")
struct Locator;

@GUID("6E50CC0D-C19B-4BF6-810B-5BD60761F5CC")
struct DigitalLocator;

@GUID("49638B91-48AB-48B7-A47A-7D0E75A08EDE")
struct AnalogLocator;

@GUID("8872FF1B-98FA-4D7A-8D93-C9F1055F85BB")
struct ATSCLocator;

@GUID("03C06416-D127-407A-AB4C-FDD279ABBE5D")
struct DigitalCableLocator;

@GUID("9CD64701-BDF3-4D14-8E03-F12983D86664")
struct DVBTLocator;

@GUID("EFE3FA02-45D7-4920-BE96-53FA7F35B0E6")
struct DVBTLocator2;

@GUID("1DF7D126-4050-47F0-A7CF-4C4CA9241333")
struct DVBSLocator;

@GUID("C531D9FD-9685-4028-8B68-6E1232079F1E")
struct DVBCLocator;

@GUID("6504AFED-A629-455C-A7F1-04964DEA5CC4")
struct ISDBSLocator;

@GUID("15D6504A-5494-499C-886C-973C9E53B9F1")
struct DVBTuneRequest;

@GUID("8A674B49-1F63-11D3-B64C-00C04F79498E")
struct CreatePropBagOnRegKey;

@GUID("0B3FFB92-0919-4934-9D5B-619C719D0202")
struct BroadcastEventService;

@GUID("6438570B-0C08-4A25-9504-8012BB4D50CF")
struct TunerMarshaler;

@GUID("E77026B0-B97F-4CBB-B7FB-F4F03AD69F11")
struct PersistTuneXmlUtility;

@GUID("C20447FC-EC60-475E-813F-D2B0A6DECEFE")
struct ESEventService;

@GUID("8E8A07DA-71F8-40C1-A929-5E3A868AC2C6")
struct ESEventFactory;

@GUID("C5C5C5F0-3ABC-11D6-B25B-00C04FA0C026")
struct XDSToRat;

@GUID("C5C5C5F1-3ABC-11D6-B25B-00C04FA0C026")
struct EvalRat;

@GUID("C4C4C4F1-0049-4E2B-98FB-9537F6CE516D")
struct ETFilter;

@GUID("C4C4C4F2-0049-4E2B-98FB-9537F6CE516D")
struct DTFilter;

@GUID("C4C4C4F3-0049-4E2B-98FB-9537F6CE516D")
struct XDSCodec;

@GUID("C4C4C4F4-0049-4E2B-98FB-9537F6CE516D")
struct CXDSData;

@GUID("1C15D484-911D-11D2-B632-00C04F79498E")
struct MSVidAnalogTunerDevice;

@GUID("A2E3074E-6C3D-11D3-B653-00C04F79498E")
struct MSVidBDATunerDevice;

@GUID("37B0353C-A4C8-11D2-B634-00C04F79498E")
struct MSVidFilePlaybackDevice;

@GUID("011B3619-FE63-4814-8A84-15A194CE9CE3")
struct MSVidWebDVD;

@GUID("FA7C375B-66A7-4280-879D-FD459C84BB02")
struct MSVidWebDVDAdm;

@GUID("37B03543-A4C8-11D2-B634-00C04F79498E")
struct MSVidVideoRenderer;

@GUID("24DC3975-09BF-4231-8655-3EE71F43837D")
struct MSVidVMR9;

@GUID("C45268A2-FA81-4E19-B1E3-72EDBD60AEDA")
struct MSVidEVR;

@GUID("37B03544-A4C8-11D2-B634-00C04F79498E")
struct MSVidAudioRenderer;

@GUID("4A5869CF-929D-4040-AE03-FCAFC5B9CD42")
struct MSVidGenericSink;

@GUID("9E77AAC4-35E5-42A1-BDC2-8F3FF399847C")
struct MSVidStreamBufferSink;

@GUID("AD8E510D-217F-409B-8076-29C5E73B98E8")
struct MSVidStreamBufferSource;

@GUID("FD351EA1-4173-4AF4-821D-80D4AE979048")
struct MSVidStreamBufferV2Source;

@GUID("BB530C63-D9DF-4B49-9439-63453962E598")
struct MSVidEncoder;

@GUID("5740A302-EF0B-45CE-BF3B-4470A14A8980")
struct MSVidITVCapture;

@GUID("9E797ED0-5253-4243-A9B7-BD06C58F8EF3")
struct MSVidITVPlayback;

@GUID("86151827-E47B-45EE-8421-D10E6E690979")
struct MSVidCCA;

@GUID("7F9CB14D-48E4-43B6-9346-1AEBC39C64D3")
struct MSVidClosedCaptioning;

@GUID("92ED88BF-879E-448F-B6B6-A385BCEB846D")
struct MSVidClosedCaptioningSI;

@GUID("334125C0-77E5-11D3-B653-00C04F79498E")
struct MSVidDataServices;

@GUID("0149EEDF-D08F-4142-8D73-D23903D21E90")
struct MSVidXDS;

@GUID("C5702CD6-9B79-11D3-B654-00C04F79498E")
struct MSVidAnalogCaptureToDataServices;

@GUID("38F03426-E83B-4E68-B65B-DCAE73304838")
struct MSVidDataServicesToStreamBufferSink;

@GUID("0429EC6E-1144-4BED-B88B-2FB9899A4A3D")
struct MSVidDataServicesToXDS;

@GUID("3540D440-5B1D-49CB-821A-E84B8CF065A7")
struct MSVidAnalogCaptureToXDS;

@GUID("B0EDF163-910A-11D2-B632-00C04F79498E")
struct MSVidCtl;

@GUID("C5702CCC-9B79-11D3-B654-00C04F79498E")
struct MSVidInputDevices;

@GUID("C5702CCD-9B79-11D3-B654-00C04F79498E")
struct MSVidOutputDevices;

@GUID("C5702CCE-9B79-11D3-B654-00C04F79498E")
struct MSVidVideoRendererDevices;

@GUID("C5702CCF-9B79-11D3-B654-00C04F79498E")
struct MSVidAudioRendererDevices;

@GUID("C5702CD0-9B79-11D3-B654-00C04F79498E")
struct MSVidFeatures;

@GUID("2764BCE5-CC39-11D2-B639-00C04F79498E")
struct MSVidGenericComposite;

@GUID("E18AF75A-08AF-11D3-B64A-00C04F79498E")
struct MSVidAnalogCaptureToOverlayMixer;

@GUID("267DB0B3-55E3-4902-949B-DF8F5CEC0191")
struct MSVidWebDVDToVideoRenderer;

@GUID("8D04238E-9FD1-41C6-8DE3-9E1EE309E935")
struct MSVidWebDVDToAudioRenderer;

@GUID("6AD28EE1-5002-4E71-AAF7-BD077907B1A4")
struct MSVidMPEG2DecoderToClosedCaptioning;

@GUID("9F50E8B1-9530-4DDC-825E-1AF81D47AED6")
struct MSVidAnalogCaptureToStreamBufferSink;

@GUID("ABE40035-27C3-4A2F-8153-6624471608AF")
struct MSVidDigitalCaptureToStreamBufferSink;

@GUID("92B94828-1AF7-4E6E-9EBF-770657F77AF5")
struct MSVidITVToStreamBufferSink;

@GUID("3EF76D68-8661-4843-8B8F-C37163D8C9CE")
struct MSVidCCAToStreamBufferSink;

@GUID("A0B9B497-AFBC-45AD-A8A6-9B077C40D4F2")
struct MSVidEncoderToStreamBufferSink;

@GUID("B401C5EB-8457-427F-84EA-A4D2363364B0")
struct MSVidFilePlaybackToVideoRenderer;

@GUID("CC23F537-18D4-4ECE-93BD-207A84726979")
struct MSVidFilePlaybackToAudioRenderer;

@GUID("28953661-0231-41DB-8986-21FF4388EE9B")
struct MSVidAnalogTVToEncoder;

@GUID("3C4708DC-B181-46A8-8DA8-4AB0371758CD")
struct MSVidStreamBufferSourceToVideoRenderer;

@GUID("942B7909-A28E-49A1-A207-34EBCBCB4B3B")
struct MSVidAnalogCaptureToCCA;

@GUID("73D14237-B9DB-4EFA-A6DD-84350421FB2F")
struct MSVidDigitalCaptureToCCA;

@GUID("5D8E73F7-4989-4AC8-8A98-39BA0D325302")
struct MSVidDigitalCaptureToITV;

@GUID("2291478C-5EE3-4BEF-AB5D-B5FF2CF58352")
struct MSVidSBESourceToITV;

@GUID("9193A8F9-0CBA-400E-AA97-EB4709164576")
struct MSVidSBESourceToCC;

@GUID("991DA7E5-953F-435B-BE5E-B92A05EDFC42")
struct MSVidSBESourceToGenericSink;

@GUID("C4BF2784-AE00-41BA-9828-9C953BD3C54A")
struct MSVidCCToVMR;

@GUID("D76334CA-D89E-4BAF-86AB-DDB59372AFC2")
struct MSVidCCToAR;

@GUID("577FAA18-4518-445E-8F70-1473F8CF4BA4")
struct MSEventBinder;

@GUID("CAAFDD83-CEFC-4E3D-BA03-175F17A24F91")
struct MSVidStreamBufferRecordingControl;

@GUID("CB4276E6-7D5F-4CF1-9727-629C5E6DB6AE")
struct MSVidRect;

@GUID("6E40476F-9C49-4C3E-8BB9-8587958EFF74")
struct MSVidDevice;

@GUID("30997F7D-B3B5-4A1C-983A-1FE8098CB77D")
struct MSVidDevice2;

@GUID("AC1972F2-138A-4CA3-90DA-AE51112EDA28")
struct MSVidInputDevice;

@GUID("95F4820B-BB3A-4E2D-BC64-5B817BC2C30E")
struct MSVidVideoInputDevice;

@GUID("1990D634-1A5E-4071-A34A-53AAFFCE9F36")
struct MSVidVideoPlaybackDevice;

@GUID("7748530B-C08A-47EA-B24C-BE8695FF405F")
struct MSVidFeature;

@GUID("87EB890D-03AD-4E9D-9866-376E5EC572ED")
struct MSVidOutput;

@GUID("73DA5D04-4347-45D3-A9DC-FAE9DDBE558D")
struct SectionList;

@GUID("F91D96C7-8509-4D0B-AB26-A0DD10904BB7")
struct Mpeg2Stream;

@GUID("C666E115-BB62-4027-A113-82D643FE2D99")
struct Mpeg2Data;

@GUID("DBAF6C1B-B6A4-4898-AE65-204F0D9509A1")
struct Mpeg2DataLib;

@GUID("14EB8748-1753-4393-95AE-4F7E7A87AAD6")
struct TIFLoad;

@GUID("83183C03-C09E-45C4-A719-807A94952BF9")
struct EVENTID_TuningChanging;

@GUID("9D7E6235-4B7D-425D-A6D1-D717C33B9C4C")
struct EVENTID_TuningChanged;

@GUID("9F02D3D0-9F06-4369-9F1E-3AD6CA19807E")
struct EVENTID_CandidatePostTuneData;

@GUID("2A65C528-2249-4070-AC16-00390CDFB2DD")
struct EVENTID_CADenialCountChanged;

@GUID("6D9CFAF2-702D-4B01-8DFF-6892AD20D191")
struct EVENTID_SignalStatusChanged;

@GUID("C87EC52D-CD18-404A-A076-C02A273D3DE7")
struct EVENTID_NewSignalAcquired;

@GUID("D10DF9D5-C261-4B85-9E8A-517B3299CAB2")
struct EVENTID_EASMessageReceived;

@GUID("1B9C3703-D447-4E16-97BB-01799FC031ED")
struct EVENTID_PSITable;

@GUID("0A1D591C-E0D2-4F8E-8960-2335BEF45CCB")
struct EVENTID_ServiceTerminated;

@GUID("A265FAEA-F874-4B38-9FF7-C53D02969996")
struct EVENTID_CardStatusChanged;

@GUID("000906F5-F0D1-41D6-A7DF-4028697669F6")
struct EVENTID_DRMParingStatusChanged;

@GUID("5B2EBF78-B752-4420-B41E-A472DC95828E")
struct EVENTID_DRMParingStepComplete;

@GUID("052C29AF-09A4-4B93-890F-BD6A348968A4")
struct EVENTID_MMIMessage;

@GUID("9071AD5D-2359-4C95-8694-AFA81D70BFD5")
struct EVENTID_EntitlementChanged;

@GUID("17C4D730-D0F0-413A-8C99-500469DE35AD")
struct EVENTID_STBChannelNumber;

@GUID("5CA51711-5DDC-41A6-9430-E41B8B3BBC5B")
struct EVENTID_BDAEventingServicePendingEvent;

@GUID("EFC3A459-AE8B-4B4A-8FE9-79A0D097F3EA")
struct EVENTID_BDAConditionalAccessTAG;

@GUID("B2127D42-7BE5-4F4B-9130-6679899F4F4B")
struct EVENTTYPE_CASDescrambleFailureEvent;

@GUID("EAD831AE-5529-4D1F-AFCE-0D8CD1257D30")
struct EVENTID_CASFailureSpanningEvent;

@GUID("9067C5E5-4C5C-4205-86C8-7AFE20FE1EFA")
struct EVENTID_ChannelChangeSpanningEvent;

@GUID("72AB1D51-87D2-489B-BA11-0E08DC210243")
struct EVENTID_ChannelTypeSpanningEvent;

@GUID("41F36D80-4132-4CC2-B121-01A43219D81B")
struct EVENTID_ChannelInfoSpanningEvent;

@GUID("F6CFC8F4-DA93-4F2F-BFF8-BA1EE6FCA3A2")
struct EVENTID_RRTSpanningEvent;

@GUID("EFE779D9-97F0-4786-800D-95CF505DDC66")
struct EVENTID_CSDescriptorSpanningEvent;

@GUID("3AB4A2E6-4247-4B34-896C-30AFA5D21C24")
struct EVENTID_CtxADescriptorSpanningEvent;

@GUID("4BD4E1C4-90A1-4109-8236-27F00E7DCC5B")
struct EVENTID_DVBScramblingControlSpanningEvent;

@GUID("8068C5CB-3C04-492B-B47D-0308820DCE51")
struct EVENTID_SignalAndServiceStatusSpanningEvent;

@GUID("6BF00268-4F7E-4294-AA87-E9E953E43F14")
struct EVENTID_EmmMessageSpanningEvent;

@GUID("501CBFBE-B849-42CE-9BE9-3DB869FB82B3")
struct EVENTID_AudioTypeSpanningEvent;

@GUID("82AF2EBC-30A6-4264-A80B-AD2E1372AC60")
struct EVENTID_StreamTypeSpanningEvent;

@GUID("3A954083-93D0-463E-90B2-0742C496EDF0")
struct EVENTID_ARIBcontentSpanningEvent;

@GUID("E292666D-9C02-448D-AA8D-781A93FDC395")
struct EVENTID_LanguageSpanningEvent;

@GUID("A9A29B56-A84B-488C-89D5-0D4E7657C8CE")
struct EVENTID_DualMonoSpanningEvent;

@GUID("47FC8F65-E2BB-4634-9CEF-FDBFE6261D5C")
struct EVENTID_PIDListSpanningEvent;

@GUID("107BD41C-A6DA-4691-8369-11B2CDAA288E")
struct EVENTID_AudioDescriptorSpanningEvent;

@GUID("5DCEC048-D0B9-4163-872C-4F32223BE88A")
struct EVENTID_SubtitleSpanningEvent;

@GUID("9599D950-5F33-4617-AF7C-1E54B510DAA3")
struct EVENTID_TeletextSpanningEvent;

@GUID("CAF1AB68-E153-4D41-A6B3-A7C998DB75EE")
struct EVENTID_StreamIDSpanningEvent;

@GUID("F947AA85-FB52-48E8-B9C5-E1E1F411A51A")
struct EVENTID_PBDAParentalControlEvent;

@GUID("D97287B2-2DFD-436A-9485-99D7D4AB5A69")
struct EVENTID_TuneFailureEvent;

@GUID("6F8AA455-5EE1-48AB-A27C-4C8D70B9AEBA")
struct EVENTID_TuneFailureSpanningEvent;

@GUID("2A67A58D-ECA5-4EAC-ABCB-E734D3776D0A")
struct EVENTID_DvbParentalRatingDescriptor;

@GUID("F5689FFE-55F9-4BB3-96BE-AE971C63BAE0")
struct EVENTID_DFNWithNoActualAVData;

@GUID("71985F41-1CA1-11D3-9CC8-00C04F7971E0")
struct KSDATAFORMAT_TYPE_BDA_ANTENNA;

@GUID("F4AEB342-0329-4FDD-A8FD-4AFF4926C978")
struct KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT;

@GUID("8DEDA6FD-AC5F-4334-8ECF-A4BA8FA7D0F0")
struct KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT;

@GUID("61BE0B47-A5EB-499B-9A85-5B16C07F1258")
struct KSDATAFORMAT_TYPE_BDA_IF_SIGNAL;

@GUID("455F176C-4B06-47CE-9AEF-8CAEF73DF7B5")
struct KSDATAFORMAT_TYPE_MPEG2_SECTIONS;

@GUID("B3C7397C-D303-414D-B33C-4ED2C9D29733")
struct KSDATAFORMAT_SUBTYPE_ATSC_SI;

@GUID("E9DD31A3-221D-4ADB-8532-9AF309C1A408")
struct KSDATAFORMAT_SUBTYPE_DVB_SI;

@GUID("762E3F66-336F-48D1-BF83-2B00352C11F0")
struct KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP;

@GUID("951727DB-D2CE-4528-96F6-3301FABB2DE0")
struct KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP;

@GUID("4A2EEB99-6458-4538-B187-04017C41413F")
struct KSDATAFORMAT_SUBTYPE_ISDB_SI;

@GUID("0D7AED42-CB9A-11DB-9705-005056C00008")
struct KSDATAFORMAT_SUBTYPE_PBDA_TRANSPORT_RAW;

@GUID("78216A81-CFA8-493E-9711-36A61C08BD9D")
struct PINNAME_BDA_TRANSPORT;

@GUID("5C0C8281-5667-486C-8482-63E31F01A6E9")
struct PINNAME_BDA_ANALOG_VIDEO;

@GUID("D28A580A-9B1F-4B0C-9C33-9BF0A8EA636B")
struct PINNAME_BDA_ANALOG_AUDIO;

@GUID("D2855FED-B2D3-4EEB-9BD0-193436A2F890")
struct PINNAME_BDA_FM_RADIO;

@GUID("1A9D4A42-F3CD-48A1-9AEA-71DE133CBE14")
struct PINNAME_BDA_IF_PIN;

@GUID("297BB104-E5C9-4ACE-B123-95C3CBB24D4F")
struct PINNAME_BDA_OPENCABLE_PSIP_PIN;

@GUID("71985F43-1CA1-11D3-9CC8-00C04F7971E0")
struct KSPROPSETID_BdaEthernetFilter;

@GUID("71985F44-1CA1-11D3-9CC8-00C04F7971E0")
struct KSPROPSETID_BdaIPv4Filter;

@GUID("E1785A74-2A23-4FB3-9245-A8F88017EF33")
struct KSPROPSETID_BdaIPv6Filter;

@GUID("1347D106-CF3A-428A-A5CB-AC0D9A2A4338")
struct KSPROPSETID_BdaSignalStats;

@GUID("FD0A5AF3-B41D-11D2-9C95-00C04F7971E0")
struct KSMETHODSETID_BdaChangeSync;

@GUID("71985F45-1CA1-11D3-9CC8-00C04F7971E0")
struct KSMETHODSETID_BdaDeviceConfiguration;

@GUID("A14EE835-0A23-11D3-9CC7-00C04F7971E0")
struct KSPROPSETID_BdaTopology;

@GUID("0DED49D5-A8B7-4D5D-97A1-12B0C195874D")
struct KSPROPSETID_BdaPinControl;

@GUID("104781CD-50BD-40D5-95FB-087E0E86A591")
struct KSEVENTSETID_BdaPinEvent;

@GUID("71985F46-1CA1-11D3-9CC8-00C04F7971E0")
struct KSPROPSETID_BdaVoidTransform;

@GUID("DDF15B0D-BD25-11D2-9CA0-00C04F7971E0")
struct KSPROPSETID_BdaNullTransform;

@GUID("71985F47-1CA1-11D3-9CC8-00C04F7971E0")
struct KSPROPSETID_BdaFrequencyFilter;

@GUID("AAB59E17-01C9-4EBF-93F2-FC3B79B46F91")
struct KSEVENTSETID_BdaTunerEvent;

@GUID("992CF102-49F9-4719-A664-C4F23E2408F4")
struct KSPROPSETID_BdaLNBInfo;

@GUID("F84E2AB0-3C6B-45E3-A0FC-8669D4B81F11")
struct KSPROPSETID_BdaDiseqCommand;

@GUID("8B19BBF0-4184-43AC-AD3C-0C889BE4C212")
struct KSEVENTSETID_BdaDiseqCEvent;

@GUID("EF30F379-985B-4D10-B640-A79D5E04E1E0")
struct KSPROPSETID_BdaDigitalDemodulator;

@GUID("DDF15B12-BD25-11D2-9CA0-00C04F7971E0")
struct KSPROPSETID_BdaAutodemodulate;

@GUID("516B99C5-971C-4AAF-B3F3-D9FDA8A15E16")
struct KSPROPSETID_BdaTableSection;

@GUID("D0A67D65-08DF-4FEC-8533-E5B550410B85")
struct KSPROPSETID_BdaPIDFilter;

@GUID("B0693766-5278-4EC6-B9E1-3CE40560EF5A")
struct KSPROPSETID_BdaCA;

@GUID("488C4CCC-B768-4129-8EB1-B00A071F9068")
struct KSEVENTSETID_BdaCAEvent;

@GUID("BFF6B5BB-B0AE-484C-9DCA-73528FB0B46E")
struct KSMETHODSETID_BdaDrmService;

@GUID("4BE6FA3D-07CD-4139-8B80-8C18BA3AEC88")
struct KSMETHODSETID_BdaWmdrmSession;

@GUID("86D979CF-A8A7-4F94-B5FB-14C0ACA68FE6")
struct KSMETHODSETID_BdaWmdrmTuner;

@GUID("F99492DA-6193-4EB0-8690-6686CBFF713E")
struct KSMETHODSETID_BdaEventing;

@GUID("AE7E55B2-96D7-4E29-908F-62F95B2A1679")
struct KSEVENTSETID_BdaEvent;

@GUID("0D4A90EC-C69D-4EE2-8C5A-FB1F63A50DA1")
struct KSMETHODSETID_BdaDebug;

@GUID("B774102F-AC07-478A-8228-2742D961FA7E")
struct KSMETHODSETID_BdaTuner;

@GUID("0C24096D-5FF5-47DE-A856-062E587E3727")
struct KSMETHODSETID_BdaNameValueA;

@GUID("36E07304-9F0D-4E88-9118-AC0BA317B7F2")
struct KSMETHODSETID_BdaNameValue;

@GUID("942AAFEC-4C05-4C74-B8EB-8706C2A4943F")
struct KSMETHODSETID_BdaMux;

@GUID("12EB49DF-6249-47F3-B190-E21E6E2F8A9C")
struct KSMETHODSETID_BdaScanning;

@GUID("8D9D5562-1589-417D-99CE-AC531DDA19F9")
struct KSMETHODSETID_BdaGuideDataDeliveryService;

@GUID("10CED3B4-320B-41BF-9824-1B2E68E71EB9")
struct KSMETHODSETID_BdaConditionalAccessService;

@GUID("5E68C627-16C2-4E6C-B1E2-D00170CDAA0F")
struct KSMETHODSETID_BdaIsdbConditionalAccess;

@GUID("1DCFAFE9-B45E-41B3-BB2A-561EB129AE98")
struct KSMETHODSETID_BdaTSSelector;

@GUID("EDA5C834-4531-483C-BE0A-94E6C96FF396")
struct KSMETHODSETID_BdaUserActivity;

@GUID("FD0A5AF4-B41D-11D2-9C95-00C04F7971E0")
struct KSCATEGORY_BDA_RECEIVER_COMPONENT;

@GUID("71985F48-1CA1-11D3-9CC8-00C04F7971E0")
struct KSCATEGORY_BDA_NETWORK_TUNER;

@GUID("71985F49-1CA1-11D3-9CC8-00C04F7971E0")
struct KSCATEGORY_BDA_NETWORK_EPG;

@GUID("71985F4A-1CA1-11D3-9CC8-00C04F7971E0")
struct KSCATEGORY_BDA_IP_SINK;

@GUID("71985F4B-1CA1-11D3-9CC8-00C04F7971E0")
struct KSCATEGORY_BDA_NETWORK_PROVIDER;

@GUID("A2E3074F-6C3D-11D3-B653-00C04F79498E")
struct KSCATEGORY_BDA_TRANSPORT_INFORMATION;

@GUID("71985F4C-1CA1-11D3-9CC8-00C04F7971E0")
struct KSNODE_BDA_RF_TUNER;

@GUID("634DB199-27DD-46B8-ACFB-ECC98E61A2AD")
struct KSNODE_BDA_ANALOG_DEMODULATOR;

@GUID("71985F4D-1CA1-11D3-9CC8-00C04F7971E0")
struct KSNODE_BDA_QAM_DEMODULATOR;

@GUID("6390C905-27C1-4D67-BDB7-77C50D079300")
struct KSNODE_BDA_QPSK_DEMODULATOR;

@GUID("71985F4F-1CA1-11D3-9CC8-00C04F7971E0")
struct KSNODE_BDA_8VSB_DEMODULATOR;

@GUID("2DAC6E05-EDBE-4B9C-B387-1B6FAD7D6495")
struct KSNODE_BDA_COFDM_DEMODULATOR;

@GUID("E957A0E7-DD98-4A3C-810B-3525157AB62E")
struct KSNODE_BDA_8PSK_DEMODULATOR;

@GUID("FCEA3AE3-2CB2-464D-8F5D-305C0BB778A2")
struct KSNODE_BDA_ISDB_T_DEMODULATOR;

@GUID("EDDE230A-9086-432D-B8A5-6670263807E9")
struct KSNODE_BDA_ISDB_S_DEMODULATOR;

@GUID("345812A0-FB7C-4790-AA7E-B1DB88AC19C9")
struct KSNODE_BDA_OPENCABLE_POD;

@GUID("D83EF8FC-F3B8-45AB-8B71-ECF7C339DEB4")
struct KSNODE_BDA_COMMON_CA_POD;

@GUID("F5412789-B0A0-44E1-AE4F-EE999B1B7FBE")
struct KSNODE_BDA_PID_FILTER;

@GUID("71985F4E-1CA1-11D3-9CC8-00C04F7971E0")
struct KSNODE_BDA_IP_SINK;

@GUID("D98429E3-65C9-4AC4-93AA-766782833B7A")
struct KSNODE_BDA_VIDEO_ENCODER;

@GUID("C026869F-7129-4E71-8696-EC8F75299B77")
struct KSNODE_BDA_PBDA_CAS;

@GUID("F2CF2AB3-5B9D-40AE-AB7C-4E7AD0BD1C52")
struct KSNODE_BDA_PBDA_ISDBCAS;

@GUID("AA5E8286-593C-4979-9494-46A2A9DFE076")
struct KSNODE_BDA_PBDA_TUNER;

@GUID("F88C7787-6678-4F4B-A13E-DA09861D682B")
struct KSNODE_BDA_PBDA_MUX;

@GUID("9EEEBD03-EEA1-450F-96AE-633E6DE63CCE")
struct KSNODE_BDA_PBDA_DRM;

@GUID("4F95AD74-CEFB-42D2-94A9-68C5B2C1AABE")
struct KSNODE_BDA_DRI_DRM;

@GUID("5EDDF185-FED1-4F45-9685-BBB73C323CFC")
struct KSNODE_BDA_TS_SELECTOR;

@GUID("3FDFFA70-AC9A-11D2-8F17-00C04F7971E2")
struct PINNAME_IPSINK_INPUT;

@GUID("E25F7B8E-CCCC-11D2-8F25-00C04F7971E2")
struct KSDATAFORMAT_TYPE_BDA_IP;

@GUID("5A9A213C-DB08-11D2-8F32-00C04F7971E2")
struct KSDATAFORMAT_SUBTYPE_BDA_IP;

@GUID("6B891420-DB09-11D2-8F32-00C04F7971E2")
struct KSDATAFORMAT_SPECIFIER_BDA_IP;

@GUID("DADD5799-7D5B-4B63-80FB-D1442F26B621")
struct KSDATAFORMAT_TYPE_BDA_IP_CONTROL;

@GUID("499856E8-E85B-48ED-9BEA-410D0DD4EF81")
struct KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL;

@GUID("C1B06D73-1DBB-11D3-8F46-00C04F7971E2")
struct PINNAME_MPE;

@GUID("455F176C-4B06-47CE-9AEF-8CAEF73DF7B5")
struct KSDATAFORMAT_TYPE_MPE;

@GUID("143827AB-F77B-498D-81CA-5A007AEC28BF")
struct DIGITAL_CABLE_NETWORK_TYPE;

@GUID("B820D87E-E0E3-478F-8A38-4E13F7B3DF42")
struct ANALOG_TV_NETWORK_TYPE;

@GUID("742EF867-09E1-40A3-82D3-9669BA35325F")
struct ANALOG_AUXIN_NETWORK_TYPE;

@GUID("7728087B-2BB9-4E30-8078-449476E59DBB")
struct ANALOG_FM_NETWORK_TYPE;

@GUID("95037F6F-3AC7-4452-B6C4-45A9CE9292A2")
struct ISDB_TERRESTRIAL_TV_NETWORK_TYPE;

@GUID("FC3855A6-C901-4F2E-ABA8-90815AFC6C83")
struct ISDB_T_NETWORK_TYPE;

@GUID("B0A4E6A0-6A1A-4B83-BB5B-903E1D90E6B6")
struct ISDB_SATELLITE_TV_NETWORK_TYPE;

@GUID("A1E78202-1459-41B1-9CA9-2A92587A42CC")
struct ISDB_S_NETWORK_TYPE;

@GUID("C974DDB5-41FE-4B25-9741-92F049F1D5D1")
struct ISDB_CABLE_TV_NETWORK_TYPE;

@GUID("93B66FB5-93D4-4323-921C-C1F52DF61D3F")
struct DIRECT_TV_SATELLITE_TV_NETWORK_TYPE;

@GUID("C4F6B31B-C6BF-4759-886F-A7386DCA27A0")
struct ECHOSTAR_SATELLITE_TV_NETWORK_TYPE;

@GUID("0DAD2FDD-5FD7-11D3-8F50-00C04F7971E2")
struct ATSC_TERRESTRIAL_TV_NETWORK_TYPE;

@GUID("216C62DF-6D7F-4E9A-8571-05F14EDB766A")
struct DVB_TERRESTRIAL_TV_NETWORK_TYPE;

@GUID("9E9E46C6-3ABA-4F08-AD0E-CC5AC8148C2B")
struct BSKYB_TERRESTRIAL_TV_NETWORK_TYPE;

@GUID("FA4B375A-45B4-4D45-8440-263957B11623")
struct DVB_SATELLITE_TV_NETWORK_TYPE;

@GUID("DC0C0FE7-0485-4266-B93F-68FBF80ED834")
struct DVB_CABLE_TV_NETWORK_TYPE;

@GUID("69C24F54-9983-497E-B415-282BE4C555FB")
struct BDA_DEBUG_DATA_AVAILABLE;

@GUID("A806E767-DE5C-430C-80BF-A21EBE06C748")
struct BDA_DEBUG_DATA_TYPE_STRING;

@GUID("D4CB1966-41BC-4CED-9A20-FDCEAC78F70D")
struct EVENTID_BDA_IsdbCASResponse;

@GUID("CF39A9D8-F5D3-4685-BE57-ED81DBA46B27")
struct EVENTID_BDA_CASRequestTuner;

@GUID("20C1A16B-441F-49A5-BB5C-E9A04495C6C1")
struct EVENTID_BDA_CASReleaseTuner;

@GUID("85DAC915-E593-410D-8471-D6812105F28E")
struct EVENTID_BDA_CASOpenMMI;

@GUID("5D0F550F-DE2E-479D-8345-EC0E9557E8A2")
struct EVENTID_BDA_CASCloseMMI;

@GUID("676876F0-1132-404C-A7CA-E72069A9D54F")
struct EVENTID_BDA_CASBroadcastMMI;

@GUID("1872E740-F573-429B-A00E-D9C1E408AF09")
struct EVENTID_BDA_TunerSignalLock;

@GUID("E29B382B-1EDD-4930-BC46-682FD72D2DFB")
struct EVENTID_BDA_TunerNoSignal;

@GUID("FF75C68C-F416-4E7E-BF17-6D55C5DF1575")
struct EVENTID_BDA_GPNVValueUpdate;

@GUID("65A6F681-1462-473B-88CE-CB731427BDB5")
struct EVENTID_BDA_UpdateDrmStatus;

@GUID("55702B50-7B49-42B8-A82F-4AFB691B0628")
struct EVENTID_BDA_UpdateScanState;

@GUID("98DB717A-478A-4CD4-92D0-95F66B89E5B1")
struct EVENTID_BDA_GuideDataAvailable;

@GUID("A1C3EA2B-175F-4458-B735-507D22DB23A6")
struct EVENTID_BDA_GuideServiceInformationUpdated;

@GUID("AC33C448-6F73-4FD7-B341-594C360D8D74")
struct EVENTID_BDA_GuideDataError;

@GUID("EFA628F8-1F2C-4B67-9EA5-ACF6FA9A1F36")
struct EVENTID_BDA_DiseqCResponseAvailable;

@GUID("356207B2-6F31-4EB0-A271-B3FA6BB7680F")
struct EVENTID_BDA_LbigsOpenConnection;

@GUID("1123277B-F1C6-4154-8B0D-48E6157059AA")
struct EVENTID_BDA_LbigsSendData;

@GUID("C2F08B99-65EF-4314-9671-E99D4CCE0BAE")
struct EVENTID_BDA_LbigsCloseConnectionHandle;

@GUID("5EC90EB9-39FA-4CFC-B93F-00BB11077F5E")
struct EVENTID_BDA_EncoderSignalLock;

@GUID("05F25366-D0EB-43D2-BC3C-682B863DF142")
struct EVENTID_BDA_FdcStatus;

@GUID("6A0CD757-4CE3-4E5B-9444-7187B87152C5")
struct EVENTID_BDA_FdcTableSection;

@GUID("C40F9F85-09D0-489C-9E9C-0ABBB56951B0")
struct EVENTID_BDA_TransprtStreamSelectorInfo;

@GUID("C6E048C0-C574-4C26-BCDA-2F4D35EB5E85")
struct EVENTID_BDA_RatingPinReset;

@GUID("1E1D7141-583F-4AC2-B019-1F430EDA0F4C")
struct PBDA_ALWAYS_TUNE_IN_MUX;

///The <b>ICreateDevEnum</b> interface creates an enumerator for a category of filters, such as video capture devices or
///audio capture devices. The System Device Enumerator exposes this interface. Applications can use this interface to
///enumerate filters within a category. The CreateClassEnumerator method returns an enumerator object for a specific
///filter category. The enumerator object supports the IEnumMoniker interface and returns a list of monikers, where each
///moniker represents a filter. In some cases, the same DirectShow filter manages an entire category of hardware
///devices. In that case, the moniker represents the device, and the moniker is used to initialize the filter. The
///application can treat each device as a separate filter, regardless of the underlying implementation. For more
///information on using this interface, see Using the System Device Enumerator.
@GUID("29840822-5B84-11D0-BD3B-00A0C911CE86")
interface ICreateDevEnum : IUnknown
{
    ///The <b>CreateClassEnumerator</b> method creates an enumerator for a specified device category.
    ///Params:
    ///    clsidDeviceClass = Specifies the class identifier (CLSID) of the device category. See Filter Categories.
    ///    ppEnumMoniker = Receives a pointer to the IEnumMoniker interface. The caller must release the interface.
    ///    dwFlags = Bitwise combination of zero or more flags. If zero, the method enumerates every filter in the category. If
    ///              any flags are set, the enumeration includes only filters that match the specified flags. The following flags
    ///              are defined: <table> <tr> <th>Flag </th> <th>Description </th> </tr> <tr> <td>CDEF_DEVMON_CMGR_DEVICE</td>
    ///              <td>Enumerate audio or video codecs, using the audio compression manager (ACM) or video compression manager
    ///              (VCM).</td> </tr> <tr> <td>CDEF_DEVMON_DMO</td> <td>Enumerate DirectX Media Objects (DMOs).</td> </tr> <tr>
    ///              <td>CDEF_DEVMON_FILTER</td> <td>Enumerate native DirectShow filters.</td> </tr> <tr>
    ///              <td>CDEF_DEVMON_PNP_DEVICE</td> <td>Enumerate Plug and Play hardware devices.</td> </tr> </table>
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Out of memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The category specified by
    ///    <i>clsidDeviceClass</i> does not exist or is empty. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT CreateClassEnumerator(const(GUID)* clsidDeviceClass, IEnumMoniker* ppEnumMoniker, uint dwFlags);
}

///This interface is exposed by all input and output pins. The filter graph manager uses this interface to connect pins
///and perform flushing operations. Applications can use this interface to query the pin for information. Applications
///should never call <code>IPin</code> methods that change a pin's state, such as Connect, Disconnect, BeginFlush, or
///EndFlush. To connect pins, an application must use the methods in IGraphBuilder. <b>Filter developers: </b>The
///CBasePin, CBaseInputPin, and CBaseOutputPin classes implement this interface. Other base classes derive from these
///three classes.
@GUID("56A86891-0AD4-11CE-B03A-0020AF0BA770")
interface IPin : IUnknown
{
    ///The <code>Connect</code> method connects the pin to another pin. Applications should not call this method. Use
    ///IGraphBuilder methods instead. This method is called by the Filter Graph Manager to connect pins.
    ///Params:
    ///    pReceivePin = Pointer to the receiving pin's IPin interface.
    ///    pmt = Pointer to an AM_MEDIA_TYPE structure that specifies the media type for the connection. Can be <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_ALREADY_CONNECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The pin is already connected. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NO_ACCEPTABLE_TYPES</b></dt> </dl> </td> <td width="60%"> Cannot find an acceptable media type.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NO_TRANSPORT</b></dt> </dl> </td> <td width="60%"> Pins
    ///    cannot agree on a transport, or there is no allocator for the connection. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VFW_E_NOT_STOPPED</b></dt> </dl> </td> <td width="60%"> The filter is active and the pin does not
    ///    support dynamic reconnection. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_TYPE_NOT_ACCEPTED</b></dt>
    ///    </dl> </td> <td width="60%"> The specified media type is not acceptable. </td> </tr> </table>
    ///    
    HRESULT Connect(IPin pReceivePin, const(AM_MEDIA_TYPE)* pmt);
    ///The <code>ReceiveConnection</code> method accepts a connection from another pin. Applications should not call
    ///this method. This method is called by other filters during the pin connection process.
    ///Params:
    ///    pConnector = Pointer to the connecting pin's IPin interface.
    ///    pmt = Pointer to an AM_MEDIA_TYPE structure that specifies the media type for the connection.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_ALREADY_CONNECTED</b></dt>
    ///    </dl> </td> <td width="60%"> The pin is already connected. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_STOPPED</b></dt> </dl> </td> <td width="60%"> Cannot connect while filter is active. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_TYPE_NOT_ACCEPTED</b></dt> </dl> </td> <td width="60%"> The
    ///    specified media type is not acceptable. </td> </tr> </table>
    ///    
    HRESULT ReceiveConnection(IPin pConnector, const(AM_MEDIA_TYPE)* pmt);
    ///The <code>Disconnect</code> method breaks the current pin connection. The Filter Graph Manager calls this method
    ///when it disconnects two filters. Applications and filters should not call this method. Instead, call the
    ///IFilterGraph::Disconnect method on the Filter Graph Manager.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    The pin was not connected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_STOPPED</b></dt> </dl> </td>
    ///    <td width="60%"> The filter is active. </td> </tr> </table>
    ///    
    HRESULT Disconnect();
    ///The <b>ConnectedTo</b> method retrieves a pointer to the connected pin, if any.
    ///Params:
    ///    pPin = Receives a pointer to the IPin interface of the other pin. The caller must release the interface. This
    ///           parameter cannot be <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt>
    ///    </dl> </td> <td width="60%"> Pin is not connected. </td> </tr> </table>
    ///    
    HRESULT ConnectedTo(IPin* pPin);
    ///The <code>ConnectionMediaType</code> method retrieves the media type for the current pin connection, if any.
    ///Params:
    ///    pmt = Pointer to an AM_MEDIA_TYPE structure that receives the media type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt>
    ///    </dl> </td> <td width="60%"> Pin is not connected. </td> </tr> </table>
    ///    
    HRESULT ConnectionMediaType(AM_MEDIA_TYPE* pmt);
    ///The <code>QueryPinInfo</code> method retrieves information about the pin.
    ///Params:
    ///    pInfo = Pointer to a [PIN_INFO](/windows/desktop/api/strmif/ns-strmif-pin_info) structure that receives the pin
    ///            information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT QueryPinInfo(PIN_INFO* pInfo);
    ///The <b>QueryDirection</b> method gets the direction of the pin (input or output).
    ///Params:
    ///    pPinDir = Receives a member of the [PIN_DIRECTION](/windows/desktop/api/strmif/ne-strmif-pin_direction) enumerated
    ///              type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT QueryDirection(PIN_DIRECTION* pPinDir);
    ///The <code>QueryId</code> method retrieves an identifier for the pin.
    ///Params:
    ///    Id = Receives a string containing the pin identifier.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT QueryId(ushort** Id);
    ///The <code>QueryAccept</code> method determines whether the pin accepts a specified media type.
    ///Params:
    ///    pmt = Pointer to an AM_MEDIA_TYPE structure that specifies the media type.
    ///Returns:
    ///    Returns one of the following values: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The pin rejects the media type. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The pin accepts the media
    ///    type. </td> </tr> </table>
    ///    
    HRESULT QueryAccept(const(AM_MEDIA_TYPE)* pmt);
    ///The <b>EnumMediaTypes</b> method enumerates the pin's preferred media types.
    ///Params:
    ///    ppEnum = Receives a pointer to the IEnumMediaTypes interface. The caller must release the interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pin is not connected. Some pins do not
    ///    enumerate media types unless the pin is connected to another filter. </td> </tr> </table>
    ///    
    HRESULT EnumMediaTypes(IEnumMediaTypes* ppEnum);
    ///The <b>QueryInternalConnections</b> method retrieves the pins that are connected internally to this pin (within
    ///the filter).
    ///Params:
    ///    apPin = Address of an array of IPin pointers. The caller allocates the array. The method fills the array with
    ///            <b>IPin</b> pointers. If <i>nPin</i> is zero, this parameter can be <b>NULL</b>.
    ///    nPin = On input, specifies the size of the array. On output, specifies the number of internally connected pins.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient array size. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> </table>
    ///    
    HRESULT QueryInternalConnections(char* apPin, uint* nPin);
    ///The <code>EndOfStream</code> method notifies the pin that no additional data is expected, until a new run command
    ///is issued to the filter. Applications should not call this method. This method is called by other filters to
    ///signal the end of the stream.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The
    ///    pin is an output pin. </td> </tr> </table>
    ///    
    HRESULT EndOfStream();
    ///The <code>BeginFlush</code> method begins a flush operation. Applications should not call this method. This
    ///method is called by other filters, to flush data from the graph.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The
    ///    pin is an output pin. </td> </tr> </table>
    ///    
    HRESULT BeginFlush();
    ///The <code>EndFlush</code> method ends a flush operation. Applications should not call this method. This method is
    ///called by other filters, to flush data from the graph.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The
    ///    pin is an output pin. </td> </tr> </table>
    ///    
    HRESULT EndFlush();
    ///The <code>NewSegment</code> method notifies the pin that media samples received after this call are grouped as a
    ///segment, with a common start time, stop time, and rate. Applications should not call this method. This method is
    ///called by other filters.
    ///Params:
    ///    tStart = Start time of the segment, relative to the original source, in 100-nanosecond units.
    ///    tStop = End time of the segment, relative to the original source, in 100-nanosecond units.
    ///    dRate = Rate at which this segment should be processed, as a percentage of the original rate.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT NewSegment(long tStart, long tStop, double dRate);
}

///Enumerates pins on a filter. The IBaseFilter::EnumPins method returns this interface. It is based on the standard
///Component Object Model (COM) enumerators. The filter graph manager uses this interface when it connects filters.
///Applications can use it to retrieve pins on a filter. For more information, see Enumerating Objects in a Filter
///Graph. If the number of pins on the filter changes, some methods on this interface return VFW_E_ENUM_OUT_OF_SYNC.
///Call the IEnumPins::Reset method to resynchronize the enumerator.
@GUID("56A86892-0AD4-11CE-B03A-0020AF0BA770")
interface IEnumPins : IUnknown
{
    ///The <code>Next</code> method retrieves a specified number of pins in the enumeration sequence.
    ///Params:
    ///    cPins = Number of pins to retrieve.
    ///    ppPins = Array of size <i>cPins</i> that is filled with IPin pointers. The caller must release the interfaces.
    ///    pcFetched = Pointer to a variable that receives the number of pins retrieved. Can be <b>NULL</b> if <i>cPins</i> is 1.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Did not retrieve as
    ///    many pins as requested. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_ENUM_OUT_OF_SYNC</b></dt> </dl> </td> <td width="60%"> The filter's state has changed and is now
    ///    inconsistent with the enumerator. </td> </tr> </table>
    ///    
    HRESULT Next(uint cPins, char* ppPins, uint* pcFetched);
    ///The <code>Skip</code> method skips over a specified number of pins.
    ///Params:
    ///    cPins = Number of pins to skip.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Skipped past the end of the
    ///    sequence. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_ENUM_OUT_OF_SYNC</b></dt> </dl> </td> <td width="60%">
    ///    The filter's state has changed and is now inconsistent with the enumerator. </td> </tr> </table>
    ///    
    HRESULT Skip(uint cPins);
    ///The <code>Reset</code> method resets the enumeration sequence to the beginning.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT Reset();
    ///The <code>Clone</code> method makes a copy of the enumerator with the same enumeration state.
    ///Params:
    ///    ppEnum = Receives a pointer to the IEnumPins interface of the new enumerator. The caller must release the interface.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_ENUM_OUT_OF_SYNC</b></dt> </dl> </td> <td
    ///    width="60%"> The filter's state has changed and is now inconsistent with the enumerator. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumPins* ppEnum);
}

///The <b>IEnumMediaTypes</b> interface enumerates a pin's preferred media types. To obtain this interface, call the
///IPin::EnumMediaTypes method on the pin. Filters use this interface when they connect to other filters. Applications
///can also use it to examine a pin's preferred media types. For more information, see Enumerating Objects in a Filter
///Graph. This interface implements a standard Component Object Model (COM) collection object. If a pin's set of
///preferred media types changes, some methods on this interface return <b>VFW_E_ENUM_OUT_OF_SYNC</b>. Call the
///IEnumMediaTypes::Reset method to resynchronize the enumerator.
@GUID("89C31040-846B-11CE-97D3-00AA0055595A")
interface IEnumMediaTypes : IUnknown
{
    ///The <b>Next</b> method retrieves a specified number of media types.
    ///Params:
    ///    cMediaTypes = The number of media types to retrieve.
    ///    ppMediaTypes = The address of an array of AM_MEDIA_TYPE pointers. The number of elements in the array is given in the
    ///                   <i>cMediaTypes</i> parameter.
    ///    pcFetched = Receives the number of media types returned in <i>ppMediaTypes</i>. This parameter can be <b>NULL</b> if
    ///                <i>cMediaTypes</i> is 1.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Did not retrieve as
    ///    many media types as requested. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_ENUM_OUT_OF_SYNC</b></dt> </dl> </td> <td width="60%"> The pin's state has changed and is now
    ///    inconsistent with the enumerator. </td> </tr> </table>
    ///    
    HRESULT Next(uint cMediaTypes, char* ppMediaTypes, uint* pcFetched);
    ///The <code>Skip</code> method skips over a specified number of media types.
    ///Params:
    ///    cMediaTypes = Number of media types to skip.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Skipped past the end of
    ///    the sequence. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_ENUM_OUT_OF_SYNC</b></dt> </dl> </td> <td
    ///    width="60%"> The pin's state has changed and is now inconsistent with the enumerator. </td> </tr> </table>
    ///    
    HRESULT Skip(uint cMediaTypes);
    ///The <code>Reset</code> method resets the enumeration sequence to the beginning.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT Reset();
    ///The <code>Clone</code> method makes a copy of the enumerator. The returned object starts with the same
    ///enumeration state as the original.
    ///Params:
    ///    ppEnum = Receives a pointer to the IEnumMediaTypes interface of the new enumerator. The caller must release the
    ///             interface.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_ENUM_OUT_OF_SYNC</b></dt> </dl> </td> <td
    ///    width="60%"> The pin's state has changed and is now inconsistent with the enumerator. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumMediaTypes* ppEnum);
}

///The <code>IFilterGraph</code> interface provides methods for building a filter graph. An application can use it to
///add filters to the graph, connect or disconnect filters, remove filters, and perform other basic operations. However,
///the IGraphBuilder interface inherits from this interface and provides additional methods that are more sophisticated.
///Therefore, applications should use <b>IGraphBuilder</b> rather than using <code>IFilterGraph</code> directly. The
///filter graph manager implements this interface.
@GUID("56A8689F-0AD4-11CE-B03A-0020AF0BA770")
interface IFilterGraph : IUnknown
{
    ///The <code>AddFilter</code> method adds a filter to the graph.
    ///Params:
    ///    pFilter = Pointer to the IBaseFilter interface of the filter to add.
    ///    pName = Pointer to a wide-character string containing a name for filter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_S_DUPLICATE_NAME</b></dt> </dl> </td> <td
    ///    width="60%"> Successfully added a filter with a duplicate name. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_CERTIFICATION_FAILURE</b></dt> </dl> </td> <td width="60%"> Use
    ///    of this filter is restricted by a software key. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DUPLICATE_NAME</b></dt> </dl> </td> <td width="60%"> Failed to add a filter with a duplicate
    ///    name. </td> </tr> </table>
    ///    
    HRESULT AddFilter(IBaseFilter pFilter, const(wchar)* pName);
    ///The <code>RemoveFilter</code> method removes a filter from the graph.
    ///Params:
    ///    pFilter = Pointer to the filter to be removed from the graph.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td>
    ///    </tr> </table>
    ///    
    HRESULT RemoveFilter(IBaseFilter pFilter);
    ///The <code>EnumFilters</code> method provides an enumerator for all filters in the graph.
    ///Params:
    ///    ppEnum = Receives a pointer to the IEnumFilters interface. Use this interface to enumerate the filters. The caller
    ///             must release the interface.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory to create
    ///    the enumerator. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT EnumFilters(IEnumFilters* ppEnum);
    ///The <code>FindFilterByName</code> method finds a filter that was added to the filter graph with a specific name.
    ///Params:
    ///    pName = [in, string] Pointer to the name to search for.
    ///    ppFilter = Receives a pointer to the filter's IBaseFilter interface. The caller must release the interface.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> No filter was
    ///    found with the specified name. </td> </tr> </table>
    ///    
    HRESULT FindFilterByName(const(wchar)* pName, IBaseFilter* ppFilter);
    ///The <code>ConnectDirect</code> method connects the two pins directly (without intervening filters).
    ///Params:
    ///    ppinOut = Pointer to the output pin.
    ///    ppinIn = Pointer to the input pin.
    ///    pmt = Pointer to the media type to use for the connection (optional; can be <b>NULL</b>).
    ///Returns:
    ///    Returns one of the following values, or an error value returned by IPin::Connect. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_IN_GRAPH</b></dt> </dl> </td> <td width="60%"> One of the specified pins is not in the
    ///    graph. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_CIRCULAR_GRAPH</b></dt> </dl> </td> <td
    ///    width="60%"> The input pin is upstream of the output pin, which would result in a circular graph. </td> </tr>
    ///    </table>
    ///    
    HRESULT ConnectDirect(IPin ppinOut, IPin ppinIn, const(AM_MEDIA_TYPE)* pmt);
    ///The <code>Reconnect</code> method disconnects a pin and then reconnects it to the same pin. Applications should
    ///not call this method. It is called by filters during the graph building process.
    ///Params:
    ///    ppin = Pointer to IPin interface of the pin to reconnect.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> Pin is not
    ///    connected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td
    ///    width="60%"> Filter is not stopped. </td> </tr> </table>
    ///    
    HRESULT Reconnect(IPin ppin);
    ///The <code>Disconnect</code> method disconnects this pin.
    ///Params:
    ///    ppin = Pointer to the pin to disconnect.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Pin was not connected. No error. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_STOPPED</b></dt> </dl> </td> <td
    ///    width="60%"> The filter is not stopped, but does not support reconnection while in a running state. </td>
    ///    </tr> </table>
    ///    
    HRESULT Disconnect(IPin ppin);
    ///The <code>SetDefaultSyncSource</code> method sets the reference clock to the default clock.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_STOPPED</b></dt> </dl> </td> <td
    ///    width="60%"> The filter graph is not stopped. </td> </tr> </table>
    ///    
    HRESULT SetDefaultSyncSource();
}

///The <code>IEnumFilters</code> interface enumerates the filters in a filter graph. To obtain this interface, call the
///IFilterGraph::EnumFilters method on the Filter Graph Manager. For more information, see Enumerating Objects in a
///Filter Graph. This interface implements a standard Component Object Model (COM) collection object. If the set of
///filters in the graph changes, some methods on this interface return VFW_E_ENUM_OUT_OF_SYNC. Call the
///IEnumFilters::Reset method to resynchronize the enumerator.
@GUID("56A86893-0AD4-11CE-B03A-0020AF0BA770")
interface IEnumFilters : IUnknown
{
    ///The <code>Next</code> method retrieves the specified number of filters in the enumeration sequence.
    ///Params:
    ///    cFilters = Number of filters to retrieve.
    ///    ppFilter = Array of size <i>cFilters</i> that is filled with IBaseFilter interface pointers. The caller must release the
    ///               interfaces.
    ///    pcFetched = Receives the number of filters retrieved. Can be <b>NULL</b> if <i>cFilters</i> is 1.
    ///Returns:
    ///    <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>S_FALSE</td> <td>Did not retrieve as many
    ///    filters as requested.</td> </tr> <tr> <td>S_OK</td> <td>Success.</td> </tr> <tr> <td>E_INVALIDARG</td>
    ///    <td>Invalid argument.</td> </tr> <tr> <td>E_POINTER</td> <td><b>NULL</b> pointer argument.</td> </tr> <tr>
    ///    <td>VFW_E_ENUM_OUT_OF_SYNC</td> <td>The graph has changed and is now inconsistent with the enumerator.</td>
    ///    </tr> </table>
    ///    
    HRESULT Next(uint cFilters, char* ppFilter, uint* pcFetched);
    ///The <code>Skip</code> method skips over a specified number of filters.
    ///Params:
    ///    cFilters = Number of filters to skip.
    ///Returns:
    ///    <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>S_FALSE</td> <td>Skipped past the end of
    ///    the sequence.</td> </tr> <tr> <td>S_OK</td> <td>Success.</td> </tr> <tr> <td>VFW_E_ENUM_OUT_OF_SYNC</td>
    ///    <td>The graph has changed and is now inconsistent with the enumerator.</td> </tr> </table>
    ///    
    HRESULT Skip(uint cFilters);
    ///The <code>Reset</code> method resets the enumeration sequence to the beginning.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT Reset();
    ///The <code>Clone</code> method makes a copy of the enumerator object. The returned object starts with the same
    ///enumeration state as the original.
    ///Params:
    ///    ppEnum = Receives a pointer to the <b>IEnumFilters</b> interface of the new enumerator. The caller must release the
    ///             interface.
    ///Returns:
    ///    Returns one of the following <b>HRESULTs</b>. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer
    ///    argument. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumFilters* ppEnum);
}

///The <code>IMediaFilter</code> interface controls the streaming state of a filter. All DirectShow filters implement
///this interface. It provides methods for switching the filter between states (stopped, paused, and running); for
///retrieving the filter's current state; and for setting a reference clock. Applications should not call
///<code>IMediaFilter</code> methods on filters. The Filter Graph Manager also exposes this interface. Applications can
///use the <b>SetSyncSource</b> method to set the graph reference clock, and <b>GetSyncSource</b> to retrieve the clock.
///Applications should not call the other methods on this interface. Instead, use the corresponding methods on the
///IMediaControl interface. The IBaseFilter interface inherits from <code>IMediaFilter</code>.
@GUID("56A86899-0AD4-11CE-B03A-0020AF0BA770")
interface IMediaFilter : IPersist
{
    ///The <code>Stop</code> method stops the filter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> Transition is not complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. Transition is complete. </td> </tr> </table>
    ///    
    HRESULT Stop();
    ///The <b>Pause</b> method pauses the filter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> Transition is not complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. Transition is complete. </td> </tr> </table>
    ///    
    HRESULT Pause();
    ///The <code>Run</code> method runs the filter.
    ///Params:
    ///    tStart = Reference time corresponding to stream time 0.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> Transition is not complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. Transition is complete. </td> </tr> </table>
    ///    
    HRESULT Run(long tStart);
    ///The <b>GetState</b> method retrieves the filters's state (running, stopped, or paused).
    ///Params:
    ///    dwMilliSecsTimeout = Time-out interval, in milliseconds. To block indefinitely, use the value <b>INFINITE</b>.
    ///    State = Receives a member of the [FILTER_STATE](/windows/desktop/api/strmif/ne-strmif-filter_state) enumerated type,
    ///            indicating the filter's state.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_S_STATE_INTERMEDIATE</b></dt> </dl> </td> <td width="60%"> Intermediate state. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_S_CANT_CUE</b></dt> </dl> </td> <td width="60%"> The filter is active, but
    ///    cannot deliver data. </td> </tr> </table>
    ///    
    HRESULT GetState(uint dwMilliSecsTimeout, FILTER_STATE* State);
    ///The <code>SetSyncSource</code> method sets the reference clock.
    ///Params:
    ///    pClock = Pointer to the clock's IReferenceClock interface, or <b>NULL</b>. If this parameter is <b>NULL</b>, the
    ///             filter graph does not use a reference clock, and all filters run as quickly as possible.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT SetSyncSource(IReferenceClock pClock);
    ///The <code>GetSyncSource</code> method retrieves the current reference clock.
    ///Params:
    ///    pClock = Receives a pointer to the clock's IReferenceClock interface. The caller must release the interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument </td> </tr> </table>
    ///    
    HRESULT GetSyncSource(IReferenceClock* pClock);
}

///The <code>IBaseFilter</code> interface is the primary interface for DirectShow filters. All DirectShow filters must
///expose this interface. The Filter Graph Manager uses this interface to control filters. Applications can use this
///interface to enumerate pins and query for filter information, but should not use it to change the state of a filter.
///Instead, use the IMediaControl interface on the Filter Graph Manager. <b>Filter developers</b>: Implement this
///interface on every DirectShow filter. The CBaseFilter base class implements this interface.
@GUID("56A86895-0AD4-11CE-B03A-0020AF0BA770")
interface IBaseFilter : IMediaFilter
{
    ///The <code>EnumPins</code> method enumerates the pins on this filter.
    ///Params:
    ///    ppEnum = Address of a variable that receives a pointer to the IEnumPins interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument </td> </tr> </table>
    ///    
    HRESULT EnumPins(IEnumPins* ppEnum);
    ///The <code>FindPin</code> method retrieves the pin with the specified identifier.
    ///Params:
    ///    Id = Pointer to a constant wide-character string that identifies the pin. Call the IPin::QueryId method to
    ///         retrieve a pin's identifier.
    ///    ppPin = Address of a variable that receives a pointer to the pin's IPin interface. If the method fails, <i>*ppPin</i>
    ///            is set to <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_FOUND</b></dt> </dl>
    ///    </td> <td width="60%"> Could not find a pin with this identifier. </td> </tr> </table>
    ///    
    HRESULT FindPin(const(wchar)* Id, IPin* ppPin);
    ///The <code>QueryFilterInfo</code> method retrieves information about the filter.
    ///Params:
    ///    pInfo = Pointer to a [FILTER_INFO](/windows/desktop/api/strmif/ns-strmif-filter_info) structure.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument </td> </tr> </table>
    ///    
    HRESULT QueryFilterInfo(FILTER_INFO* pInfo);
    ///The <code>JoinFilterGraph</code> method notifies the filter that it has joined or left the filter graph.
    ///Params:
    ///    pGraph = Pointer to the Filter Graph Manager's IFilterGraph interface, or <b>NULL</b> if the filter is leaving the
    ///             graph.
    ///    pName = Pointer to a wide-character string that specifies a name for the filter.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT JoinFilterGraph(IFilterGraph pGraph, const(wchar)* pName);
    ///The <code>QueryVendorInfo</code> method retrieves a string containing vendor information.
    ///Params:
    ///    pVendorInfo = Address of a variable that receives a pointer to a wide-character string containing the vendor information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method
    ///    is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT QueryVendorInfo(ushort** pVendorInfo);
}

///The <code>IReferenceClock</code> interface provides the reference time for the filter graph. Filters that can act as
///a reference clock can expose this interface. It is also exposed by the System Reference Clock. The filter graph
///manager uses this interface to synchronize the filter graph. Applications can use this interface to retrieve the
///current reference time, or to request notification of an elapsed time. For more information, see Time and Clocks in
///DirectShow. <b>Filter developers: </b>Implement this interface if you are writing a filter that generates reliable
///clock times. For example, audio renderers implement this interface, because audio sound boards usually contain a
///reference clock. Use the CBaseReferenceClock class to implement this interface. To increase the chances that a
///non-rendering filter will be selected by the Filter Graph Manager as the reference close, follow these steps: <ol>
///<li>Implement <code>IReferenceClock</code> in the filter.</li> <li>Implement IAMFilterMiscFlags in the filter.</li>
///<li>Return AM_FILTER_MISC_FLAGS_IS_SOURCE from IAMFilterMiscFlags::GetMiscFlags.</li> <li>Implement IAMPushSource on
///all output pins.</li> <li>Return (* pFlags) = 0 from IAMPushSource::GetPushSourceFlags.</li> <li>You may return
///E_NOTIMPL from all other <b>IAMPushSource</b> methods.</li> </ol>
@GUID("56A86897-0AD4-11CE-B03A-0020AF0BA770")
interface IReferenceClock : IUnknown
{
    ///The <code>GetTime</code> method retrieves the current reference time.
    ///Params:
    ///    pTime = Pointer to a variable that receives the current time, in 100-nanosecond units.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> Returned time is the same as the previous value. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetTime(long* pTime);
    ///The <code>AdviseTime</code> method creates a one-shot advise request.
    ///Params:
    ///    baseTime = Base reference time, in 100-nanosecond units. See Remarks.
    ///    streamTime = Stream offset time, in 100-nanosecond units. See Remarks.
    ///    hEvent = Handle to an event, created by the caller.
    ///    pdwAdviseCookie = Pointer to a variable that receives an identifier for the advise request.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid time values. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT AdviseTime(long baseTime, long streamTime, size_t hEvent, size_t* pdwAdviseCookie);
    ///The <code>AdvisePeriodic</code> method creates a periodic advise request.
    ///Params:
    ///    startTime = Time of the first notification, in 100-nanosecond units. Must be greater than zero and less than MAX_TIME.
    ///    periodTime = Time between notifications, in 100-nanosecond units. Must be greater than zero.
    ///    hSemaphore = Handle to a semaphore, created by the caller.
    ///    pdwAdviseCookie = Pointer to a variable that receives an identifier for the advise request.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid time values. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT AdvisePeriodic(long startTime, long periodTime, size_t hSemaphore, size_t* pdwAdviseCookie);
    ///The <code>Unadvise</code> method removes a pending advise request.
    ///Params:
    ///    dwAdviseCookie = Identifier of the request to remove. Use the value returned by IReferenceClock::AdviseTime or
    ///                     IReferenceClock::AdvisePeriodic in the <i>pdwAdviseToken</i> parameter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> </table>
    ///    
    HRESULT Unadvise(size_t dwAdviseCookie);
}

///The <code>IReferenceClockTimerControl</code> interface changes the timer period used by a reference clock. This
///interface is exposed by the DirectShow System Reference Clock.
@GUID("EBEC459C-2ECA-4D42-A8AF-30DF557614B8")
interface IReferenceClockTimerControl : IUnknown
{
    ///The <code>SetDefaultTimerResolution</code> method sets the minimum timer resolution.
    ///Params:
    ///    timerResolution = Minimum timer resolution, in 100-nanosecond units. If the value is zero, the reference clock cancels its
    ///                      previous request.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT SetDefaultTimerResolution(long timerResolution);
    ///The <code>GetDefaultTimerResolution</code> method returns the timer resolution that was requested by the
    ///reference clock.
    ///Params:
    ///    pTimerResolution = Receives the requested timer resolution, in 100-nanosecond units.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetDefaultTimerResolution(long* pTimerResolution);
}

@GUID("36B73885-C2C8-11CF-8B46-00805F6CEF60")
interface IReferenceClock2 : IReferenceClock
{
}

///The <code>IMediaSample</code> interface sets and retrieves properties on media samples. A media sample is a COM
///object that contains a block of media data. Media samples support the use of shared memory buffers among filters.
///Typically, applications do not call methods on this interface. Filters use this interface to set properties on
///samples, and deliver the samples to a downstream filter. The downstream filter uses the interface to retrieve the
///properties and read the data. The filter can modify the data in place, or it can copy the sample, modify the copy,
///and pass the copy downstream. The IMediaSample2 interface inherits this interface.
@GUID("56A8689A-0AD4-11CE-B03A-0020AF0BA770")
interface IMediaSample : IUnknown
{
    ///The <code>GetPointer</code> method retrieves a read/write pointer to the media sample's buffer.
    ///Params:
    ///    ppBuffer = Receives a pointer to the buffer.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT GetPointer(char* ppBuffer);
    ///The <code>GetSize</code> method retrieves the size of the buffer.
    ///Returns:
    ///    Returns the size of the buffer, in bytes. The size does not include the prefix bytes, if any.
    ///    
    int     GetSize();
    ///The <code>GetTime</code> method retrieves the stream times at which this sample should begin and finish.
    ///Params:
    ///    pTimeStart = Pointer to a variable that receives the start time.
    ///    pTimeEnd = Pointer to a variable that receives the stop time. If the sample has no stop time, the value is set to the
    ///               start time plus one.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. The sample has valid start and stop times. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_S_NO_STOP_TIME</b></dt> </dl> </td> <td width="60%"> The sample has a valid start time, but no
    ///    stop time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_SAMPLE_TIME_NOT_SET</b></dt> </dl> </td> <td
    ///    width="60%"> The sample is not time-stamped. </td> </tr> </table>
    ///    
    HRESULT GetTime(long* pTimeStart, long* pTimeEnd);
    ///The <code>SetTime</code> method sets the stream times when this sample should begin and finish.
    ///Params:
    ///    pTimeStart = Pointer to a variable that contains the start time of the sample.
    ///    pTimeEnd = Pointer to a variable that contains the stop time of the sample.
    ///Returns:
    ///    Returns S_OK, or <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT SetTime(long* pTimeStart, long* pTimeEnd);
    ///The <code>IsSyncPoint</code> method determines if the beginning of this sample is a synchronization point.
    ///Returns:
    ///    Returns S_OK if the sample is a synchronization point. Otherwise, returns S_FALSE.
    ///    
    HRESULT IsSyncPoint();
    ///The <code>SetSyncPoint</code> method specifies whether the beginning of this sample is a synchronization point.
    ///Params:
    ///    bIsSyncPoint = Boolean value that specifies whether this is a synchronization point. If <b>TRUE</b>, this is a
    ///                   synchronization point.
    ///Returns:
    ///    Returns S_OK or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT SetSyncPoint(BOOL bIsSyncPoint);
    ///The <code>IsPreroll</code> method determines if this sample is a preroll sample. A preroll sample should not be
    ///displayed.
    ///Returns:
    ///    Returns S_OK if the sample is a preroll sample. Otherwise, returns S_FALSE.
    ///    
    HRESULT IsPreroll();
    ///The <code>SetPreroll</code> method specifies whether this sample is a preroll sample.
    ///Params:
    ///    bIsPreroll = Boolean value that specifies whether this is a preroll sample. If <b>TRUE</b>, this is a preroll sample.
    ///Returns:
    ///    Returns S_OK, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT SetPreroll(BOOL bIsPreroll);
    ///The <code>GetActualDataLength</code> method retrieves the length of the valid data in the buffer.
    ///Returns:
    ///    Returns the length of the valid data, in bytes.
    ///    
    int     GetActualDataLength();
    ///The <code>SetActualDataLength</code> method sets the length of the valid data in the buffer.
    ///Params:
    ///    __MIDL__IMediaSample0000 = Length of the data in the media sample, in bytes.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_BUFFER_OVERFLOW.</b></dt> </dl>
    ///    </td> <td width="60%"> Length specified in <i>lLen</i> is larger than the buffer size. </td> </tr> </table>
    ///    
    HRESULT SetActualDataLength(int __MIDL__IMediaSample0000);
    ///The <code>GetMediaType</code> method retrieves the media type, if the media type differs from the previous
    ///sample.
    ///Params:
    ///    ppMediaType = Address of a variable that receives a pointer to an AM_MEDIA_TYPE structure. If the media type has not
    ///                  changed from the previous sample, <i>*ppMediaType</i> is set to <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The media type has not changed from the previous sample. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetMediaType(AM_MEDIA_TYPE** ppMediaType);
    ///The <code>SetMediaType</code> method sets the media type for the sample.
    ///Params:
    ///    pMediaType = Pointer to an AM_MEDIA_TYPE structure that specifies the media type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory </td> </tr> </table>
    ///    
    HRESULT SetMediaType(AM_MEDIA_TYPE* pMediaType);
    ///The <code>IsDiscontinuity</code> method determines if this sample represents a break in the data stream.
    ///Returns:
    ///    Returns S_OK if the sample is a break in the data stream. Otherwise, returns S_FALSE.
    ///    
    HRESULT IsDiscontinuity();
    ///The <code>SetDiscontinuity</code> method specifies whether this sample represents a break in the data stream.
    ///Params:
    ///    bDiscontinuity = Boolean value that specifies whether this sample is a discontinuity. If <b>TRUE</b>, the media sample is
    ///                     discontinuous with the previous sample.
    ///Returns:
    ///    Returns S_OK, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT SetDiscontinuity(BOOL bDiscontinuity);
    ///The <code>GetMediaTime</code> method retrieves the media times for this sample.
    ///Params:
    ///    pTimeStart = Pointer to a variable that receives the media start time.
    ///    pTimeEnd = Pointer to a variable that receives the media stop time.
    ///Returns:
    ///    Returns an HRESULT value. Possible values include those shown in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_MEDIA_TIME_NOT_SET</b></dt> </dl>
    ///    </td> <td width="60%"> Media times are not set on this sample. </td> </tr> </table>
    ///    
    HRESULT GetMediaTime(long* pTimeStart, long* pTimeEnd);
    ///The <code>SetMediaTime</code> method sets the media times for this sample.
    ///Params:
    ///    pTimeStart = Pointer to the beginning media time.
    ///    pTimeEnd = Pointer to the ending media time.
    ///Returns:
    ///    Returns S_OK, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT SetMediaTime(long* pTimeStart, long* pTimeEnd);
}

///The <code>IMediaSample2</code> interface sets and retrieves properties on media samples. This interface inherits the
///IMediaSample interface. Whereas the <b>IMediaSample</b> interface requires separate method calls for each sample
///property, the <code>IMediaSample2</code> interface has methods for setting and retrieving multiple properties at
///once. Media samples are not guaranteed to support <code>IMediaSample2</code>. However, if an allocator creates
///samples that support <code>IMediaSample2</code>, all of the samples that it creates must support the interface. For
///any given media sample, the <b>IMediaSample2::GetProperties</b> method returns the same values as the individual
///<b>IMediaSample</b> methods. Therefore, you can use whichever version you prefer.
@GUID("36B73884-C2C8-11CF-8B46-00805F6CEF60")
interface IMediaSample2 : IMediaSample
{
    ///The <code>GetProperties</code> method retrieves the properties of a media sample.
    ///Params:
    ///    cbProperties = Length of property data to retrieve, in bytes.
    ///    pbProperties = Pointer to a buffer of size <i>cbProperties</i>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetProperties(uint cbProperties, char* pbProperties);
    ///The <b>SetProperties</b> method sets the properties of a media sample.
    ///Params:
    ///    cbProperties = Length of property data to set, in bytes.
    ///    pbProperties = Pointer to a buffer of size <i>cbProperties</i>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT SetProperties(uint cbProperties, char* pbProperties);
}

///The <b>IMediaSample2Config</b> interface returns a pointer to a Direct3D surface representing a VRAM capture buffer.
@GUID("68961E68-832B-41EA-BC91-63593F3E70E3")
interface IMediaSample2Config : IUnknown
{
    ///The <code>GetSurface</code> method returns a pointer to the Direct3D surface managed by this media sample.
    ///Params:
    ///    ppDirect3DSurface9 = Receives a pointer to the <b>IUnknown</b> interface of the Direct3D surface. The caller must release the
    ///                         interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT GetSurface(IUnknown* ppDirect3DSurface9);
}

///The <code>IMemAllocator</code> interface allocates media samples, for moving data between pins. This interface is
///used by pins that share allocators, when the input pin exposes the IMemInputPin interface. The pins negotiate which
///pin will provide the allocator. The allocator is used to allocate memory buffers, retrieve empty buffers, and release
///buffers. Not every filter creates its own allocator, so one allocator might be used by several filters. For more
///information, see How Filters Connect. Applications typically do not use this interface. To use an allocator, perform
///the following steps: <ol> <li>Call the IMemAllocator::SetProperties method to specify the buffer requirements,
///including the number of buffers and the size of each buffer.</li> <li>Call the IMemAllocator::Commit method to
///allocate the buffers.</li> <li>Call the IMemAllocator::GetBuffer method to retrieve media samples. This method blocks
///until the next sample becomes available.</li> <li>When you are done with each sample, call the
///<b>IUnknown::Release</b> method on the sample. The sample is not deleted when its reference count reaches zero.
///Instead, the sample returns to the allocator's free list.</li> <li>When you are done using the allocator, call the
///IMemAllocator::Decommit method to release the memory for the buffers.</li> </ol>
@GUID("56A8689C-0AD4-11CE-B03A-0020AF0BA770")
interface IMemAllocator : IUnknown
{
    ///The <code>SetProperties</code> method specifies the number of buffers to allocate and the size of each buffer.
    ///Params:
    ///    pRequest = Pointer to an [ALLOCATOR_PROPERTIES](/windows/desktop/api/strmif/ns-strmif-allocator_properties) structure
    ///               that contains the buffer requirements.
    ///    pActual = Pointer to an <b>ALLOCATOR_PROPERTIES</b> structure that receives the actual buffer properties.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_ALREADY_COMMITTED</b></dt> </dl> </td> <td width="60%"> Cannot change allocated memory while the
    ///    filter is active. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_BADALIGN</b></dt> </dl> </td> <td
    ///    width="60%"> An invalid alignment was specified. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_BUFFERS_OUTSTANDING</b></dt> </dl> </td> <td width="60%"> One or more buffers are still active.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);
    ///The <code>GetProperties</code> method retrieves the number of buffers that the allocator will create, and the
    ///buffer properties.
    ///Params:
    ///    pProps = Pointer to an [ALLOCATOR_PROPERTIES](/windows/desktop/api/strmif/ns-strmif-allocator_properties) structure
    ///             that receives the allocator properties.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT GetProperties(ALLOCATOR_PROPERTIES* pProps);
    ///The <code>Commit</code> method allocates the buffer memory.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td>
    ///    <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_SIZENOTSET</b></dt>
    ///    </dl> </td> <td width="60%"> Buffer requirements were not set. </td> </tr> </table>
    ///    
    HRESULT Commit();
    ///The <code>Decommit</code> method releases the buffer memory.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT Decommit();
    ///The <b>GetBuffer</b> method retrieves a media sample that contains an empty buffer.
    ///Params:
    ///    ppBuffer = Receives a pointer to the buffer's IMediaSample interface. The caller must release the interface.
    ///    pStartTime = Pointer to the start time of the sample, or <b>NULL</b>.
    ///    pEndTime = Pointer to the ending time of the sample, or <b>NULL</b>.
    ///    dwFlags = Bitwise combination of zero or more of the following flags: <table> <tr> <th>Flag </th> <th>Description </th>
    ///              </tr> <tr> <td>AM_GBF_NOTASYNCPOINT</td> <td>This sample is not a synchronization point. Dynamic format
    ///              changes are not allowed on this sample. When called on the Overlay Mixer or VMR, this flag implies that the
    ///              buffer returned will contain an image that is identical to the last image delivered.</td> </tr> <tr>
    ///              <td>AM_GBF_PREVFRAMESKIPPED</td> <td>This sample is the first after a discontinuity. (Only the video renderer
    ///              uses this flag.)</td> </tr> <tr> <td>AM_GBF_NOWAIT</td> <td>Do not wait for a buffer to become
    ///              available.</td> </tr> <tr> <td>AM_GBF_NODDSURFACELOCK</td> <td>Used with the Video Mixing Renderer Filter 7
    ///              to request an unlocked DirectDraw surface. For more information, see Working with Direct3D Render
    ///              Targets.</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_COMMITTED</b></dt> </dl>
    ///    </td> <td width="60%"> Allocator is decommitted. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> Timed out. </td> </tr> </table>
    ///    
    HRESULT GetBuffer(IMediaSample* ppBuffer, long* pStartTime, long* pEndTime, uint dwFlags);
    ///The <code>ReleaseBuffer</code> method releases a media sample.
    ///Params:
    ///    pBuffer = Pointer to the media sample's IMediaSample interface.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT ReleaseBuffer(IMediaSample pBuffer);
}

///The <code>IMemAllocatorCallbackTemp</code> interface enables a filter to receive a callback notification from an
///allocator whenever a sample is returned to the allocator's free list. The use of this interface is deprecated.
@GUID("379A0CF0-C1DE-11D2-ABF5-00A0C905F375")
interface IMemAllocatorCallbackTemp : IMemAllocator
{
    ///The <code>SetNotify</code> method sets or removes a callback on the allocator. The allocator calls the callback
    ///method whenever the allocator's IMemAllocator::ReleaseBuffer method is called.
    ///Params:
    ///    pNotify = Pointer to the IMemAllocatorNotifyCallbackTemp interface that will be used for the callback. The caller must
    ///              implement the interface. Use the value <b>NULL</b> to remove the callback.
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT SetNotify(IMemAllocatorNotifyCallbackTemp pNotify);
    ///The <code>GetFreeCount</code> method returns the number of free media samples. This number equals the total
    ///number of media samples minus the number of samples that are currently held by filters.
    ///Params:
    ///    plBuffersFree = Pointer to a variable that receives the number of free media samples.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetFreeCount(int* plBuffersFree);
}

///<p class="CCE_Message">[<b>IMemAllocatorNotifyCallbackTemp</b> is available for use in the operating systems
///specified in the Requirements section. It may be altered or unavailable in subsequent versions.] The
///<b>IMemAllocatorNotifyCallbackTemp</b> interface enables a filter to receive a callback notification from an
///allocator whenever a sample is returned to the allocator's free list. To receive callbacks, the filter must implement
///this interface. For more information, see IMemAllocatorCallbackTemp Interface.
@GUID("92980B30-C1DE-11D2-ABF5-00A0C905F375")
interface IMemAllocatorNotifyCallbackTemp : IUnknown
{
    ///The <code>NotifyRelease</code> method is called whenever the allocator's IMemAllocator::ReleaseBuffer method is
    ///called. The <b>ReleaseBuffer</b> method returns a media sample to the allocator's free list. Samples call this
    ///method when their reference counts reach zero.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT NotifyRelease();
}

///The <code>IMemInputPin</code> interface delivers media data to an input pin. Input pins expose this interface if they
///use the IMemAllocator interface to allocate buffers. When an output pin connects to an input pin, the output pin uses
///this interface to negotiate allocator requirements and deliver samples to the input pin. Applications typically do
///not use this interface. <b>Filter developers: </b>The CBaseInputPin class implements this interface.
@GUID("56A8689D-0AD4-11CE-B03A-0020AF0BA770")
interface IMemInputPin : IUnknown
{
    ///The <code>GetAllocator</code> method retrieves the memory allocator proposed by this pin. After the allocator has
    ///been selected, this method returns a pointer to the selected allocator.
    ///Params:
    ///    ppAllocator = Receives a pointer to the allocator's IMemAllocator interface. The caller must release the interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NO_ALLOCATOR</b></dt> </dl>
    ///    </td> <td width="60%"> No allocator is available. </td> </tr> </table>
    ///    
    HRESULT GetAllocator(IMemAllocator* ppAllocator);
    ///The <code>NotifyAllocator</code> method specifies an allocator for the connection.
    ///Params:
    ///    pAllocator = Pointer to the allocator's IMemAllocator interface.
    ///    bReadOnly = Flag that specifies whether samples from this allocator are read-only. If <b>TRUE</b>, samples are read-only.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT NotifyAllocator(IMemAllocator pAllocator, BOOL bReadOnly);
    ///The <code>GetAllocatorRequirements</code> method retrieves the allocator properties requested by the input pin.
    ///Params:
    ///    pProps = Pointer to an [ALLOCATOR_PROPERTIES](/windows/desktop/api/strmif/ns-strmif-allocator_properties), structure
    ///             which is filled in with the requirements.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument </td> </tr> </table>
    ///    
    HRESULT GetAllocatorRequirements(ALLOCATOR_PROPERTIES* pProps);
    ///The <code>Receive</code> method receives the next media sample in the stream.
    ///Params:
    ///    pSample = Pointer to the sample's IMediaSample interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> The sample was rejected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> Invalid media type. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_RUNTIME_ERROR</b></dt> </dl> </td> <td width="60%"> A run-time error occurred.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The pin
    ///    is stopped. </td> </tr> </table>
    ///    
    HRESULT Receive(IMediaSample pSample);
    ///The <code>ReceiveMultiple</code> method receives multiple samples in the stream.
    ///Params:
    ///    pSamples = Address of an array of IMediaSample interface pointers, of size <i>nSamples</i>.
    ///    nSamples = Number of samples to process.
    ///    nSamplesProcessed = Pointer to a variable that receives the number of samples that were processed.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> Pin is currently flushing; sample was rejected. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> Invalid media type.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_RUNTIME_ERROR</b></dt> </dl> </td> <td width="60%"> A
    ///    run-time error occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The pin is stopped. </td> </tr> </table>
    ///    
    HRESULT ReceiveMultiple(char* pSamples, int nSamples, int* nSamplesProcessed);
    ///The <code>ReceiveCanBlock</code> method determines whether calls to the IMemInputPin::Receive method might block.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The pin will not block on a call to <b>Receive</b> </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The pin might block on a call to <b>Receive</b>. </td>
    ///    </tr> </table>
    ///    
    HRESULT ReceiveCanBlock();
}

///<div class="alert"><b>Note</b> This interface has been deprecated. It is used by two obsolete functions,
///AMovieDllRegisterServer and AMovieDllUnregisterServer. These functions are now replaced by AMovieDllRegisterServer2,
///which does not require <b>IAMovieSetup</b>. However, <b>IAMovieSetup</b> will continue to be supported for backward
///compatibility with existing applications.</div> <div> </div>
@GUID("A3D8CEC0-7E5A-11CF-BBC5-00805F6CEF20")
interface IAMovieSetup : IUnknown
{
    ///<div class="alert"><b>Note</b> The <b>IAMovieSetup</b> interface is deprecated. Use the AMovieDllRegisterServer2
    ///function instead.</div> <div> </div> Adds the filter to the registry.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT Register();
    ///<div class="alert"><b>Note</b> The <b>IAMovieSetup</b> interface is deprecated. Use the AMovieDllRegisterServer2
    ///function instead.</div> <div> </div> Removes the filter from the registry.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT Unregister();
}

///The <code>IMediaSeeking</code> interface contains methods for seeking to a position within a stream, and for setting
///the playback rate. The Filter Graph Manager exposes this interface, and so do individual filters or pins.
///Applications should query the Filter Graph Manager for the interface. The Filter Graph Manager distributes any
///<code>IMediaSeeking</code> call to each of the renderer filters in the graph. The renderer filters send the call
///upstream to the source filters. This sequence of events ensures that all streams remain synchronized. If any of the
///distributed calls returns an error, the Filter Graph Manager returns the first error value it received, even if some
///of the distributed calls succeed. An exception is E_NOTIMPL: the Filter Graph Manager does not return E_NOTIMPL
///unless it was returned by all of the distributed calls. An application can seek the graph while the graph is in any
///state (running, paused or stopped). If the graph is running, the Filter Graph Manager pauses the graph before it
///issues the seek command. Then it runs the graph again. All seeking operations are independent of the current playback
///rate. Seeking operations cause any pending media data to be flushed from the graph. For all
///<code>IMediaSeeking</code> parameters that specify time, the unit of time depends on the current time format. To set
///the time format, call the IMediaSeeking::SetTimeFormat method. Time formats are globally unique identifiers (GUIDs)
///defined in uuids.h. For more information, see Time Format GUIDs.
@GUID("36B73880-C2C8-11CF-8B46-00805F6CEF60")
interface IMediaSeeking : IUnknown
{
    ///The <code>GetCapabilities</code> method retrieves all the seeking capabilities of the stream.
    ///Params:
    ///    pCapabilities = Pointer to a variable that receives a bitwise combination of AM_SEEKING_SEEKING_CAPABILITIES flags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetCapabilities(uint* pCapabilities);
    ///The <b>CheckCapabilities</b> method queries whether a stream has specified seeking capabilities.
    ///Params:
    ///    pCapabilities = On input, a pointer to a variable that contains a bitwise <b>OR</b> of one or more
    ///                    AM_SEEKING_SEEKING_CAPABILITIES attributes. When the method returns, the value indicates which of those
    ///                    attributes are available.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Some but not all of the capabilities in <i>pCapabilities</i> are present. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> All capabilities in <i>pCapabilities</i> are present.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> No capabilities in
    ///    <i>pCapabilities</i> are present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT CheckCapabilities(uint* pCapabilities);
    ///The <code>IsFormatSupported</code> method determines whether a specified time format is supported for seek
    ///operations.
    ///Params:
    ///    pFormat = Pointer to a GUID that specifies the time format. See Time Format GUIDs.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    The format is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The format is supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT IsFormatSupported(const(GUID)* pFormat);
    ///The <code>QueryPreferredFormat</code> method retrieves the preferred time format for seeking.
    ///Params:
    ///    pFormat = Pointer to a variable that receives a GUID specifying the time format. See Time Format GUIDs.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT QueryPreferredFormat(GUID* pFormat);
    HRESULT GetTimeFormatA(GUID* pFormat);
    ///The <code>IsUsingTimeFormat</code> method determines whether seek operations are currently using a specified time
    ///format.
    ///Params:
    ///    pFormat = Pointer to a GUID that specifies the time format. See Time Format GUIDs.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    The specified format is not the current format. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The specified format is the current format. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td>
    ///    </tr> </table>
    ///    
    HRESULT IsUsingTimeFormat(const(GUID)* pFormat);
    ///The <code>SetTimeFormat</code> method sets the time format for subsequent seek operations.
    ///Params:
    ///    pFormat = Pointer to a GUID that specifies the time format. See Time Format GUIDs.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Method is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> Filter graph is not stopped. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetTimeFormat(const(GUID)* pFormat);
    ///The <b>GetDuration</b> method gets the duration of the stream.
    ///Params:
    ///    pDuration = Receives the duration, in units of the current time format.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDuration(long* pDuration);
    ///The <code>GetStopPosition</code> method retrieves the time at which the playback will stop, relative to the
    ///duration of the stream.
    ///Params:
    ///    pStop = Pointer to a variable that receives the stop time, in units of the current time format.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method
    ///    is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetStopPosition(long* pStop);
    ///The <code>GetCurrentPosition</code> method retrieves the current position, relative to the total duration of the
    ///stream.
    ///Params:
    ///    pCurrent = Pointer to a variable that receives the current position, in units of the current time format.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method
    ///    is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetCurrentPosition(long* pCurrent);
    ///The <code>ConvertTimeFormat</code> method converts from one time format to another.
    ///Params:
    ///    pTarget = Pointer to a variable that receives the converted time.
    ///    pTargetFormat = Pointer to a GUID that specifies the target format. If <b>NULL</b>, the current format is used. See Time
    ///                    Format GUIDs.
    ///    Source = Time value to be converted.
    ///    pSourceFormat = Pointer to a GUID that specifies the format to convert. If <b>NULL</b>, the current format is used. See Time
    ///                    Format GUIDs.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Conversion between these types is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method is not supported. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td>
    ///    </tr> </table>
    ///    
    HRESULT ConvertTimeFormat(long* pTarget, const(GUID)* pTargetFormat, long Source, const(GUID)* pSourceFormat);
    ///The <code>SetPositions</code> method sets the current position and the stop position.
    ///Params:
    ///    pCurrent = [in,out] Pointer to a variable that specifies the current position, in units of the current time format.
    ///    dwCurrentFlags = Bitwise combination of flags. See Remarks.
    ///    pStop = [in,out] Pointer to a variable that specifies the stop time, in units of the current time format.
    ///    dwStopFlags = Bitwise combination of flags. See Remarks.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No
    ///    position change. (Both flags specify no seeking.) </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method is not supported. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetPositions(long* pCurrent, uint dwCurrentFlags, long* pStop, uint dwStopFlags);
    ///The <code>GetPositions</code> method retrieves the current position and the stop position, relative to the total
    ///duration of the stream.
    ///Params:
    ///    pCurrent = Pointer to a variable that receives the current position, in units of the current time format.
    ///    pStop = Pointer to a variable that receives the stop position, in units of the current time format.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method
    ///    is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetPositions(long* pCurrent, long* pStop);
    ///The <code>GetAvailable</code> method retrieves the range of times in which seeking is efficient.
    ///Params:
    ///    pEarliest = Pointer to a variable that receives the earliest time for efficient seeking.
    ///    pLatest = Pointer to a variable that receives the latest time for efficient seeking.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method
    ///    is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetAvailable(long* pEarliest, long* pLatest);
    ///The <code>SetRate</code> method sets the playback rate.
    ///Params:
    ///    dRate = Playback rate. Must not be zero.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The
    ///    specified rate was zero or a negative value. (See Remarks.) </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_UNSUPPORTED_AUDIO</b></dt> </dl> </td> <td width="60%"> Audio device or
    ///    filter does not support this rate. </td> </tr> </table>
    ///    
    HRESULT SetRate(double dRate);
    ///The <code>GetRate</code> method retrieves the playback rate.
    ///Params:
    ///    pdRate = Pointer to a variable that receives the playback rate.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method
    ///    is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetRate(double* pdRate);
    ///The <code>GetPreroll</code> method retrieves the amount of data that will be queued before the start position.
    ///Params:
    ///    pllPreroll = Pointer to a variable that receives the preroll time, in units of the current time format.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method
    ///    is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetPreroll(long* pllPreroll);
}

///<div class="alert"><b>Note</b> This interface has been deprecated. New applications should call
///IFilterMapper2::EnumMatchingFilters, which enumerates monikers and returns a pointer to the <b>IEnumMoniker</b>
///interface.</div> <div> </div> This interface provides methods for enumerating registered filters. The
///IFilterMapper::EnumMatchingFilters method returns a pointer to this interface. However, IFilterMapper has been
///deprecated in favor of IFilterMapper2.
@GUID("56A868A4-0AD4-11CE-B03A-0020AF0BA770")
interface IEnumRegFilters : IUnknown
{
    ///<div class="alert"><b>Note</b> The <b>IEnumRegFilters</b> interface is deprecated.</div> <div> </div> Fills the
    ///array with descriptions of the next set of filters (specified by the <i>cFilters</i> parameter) that meet the
    ///requirements specified upon creation of the enumerator.
    ///Params:
    ///    cFilters = Number of filters.
    ///    apRegFilter = Address of a pointer to an array of <b>REGFILTER</b> pointers.
    ///    pcFetched = Pointer to the actual number of filters passed.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Fewer filters were retrieved than requested. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_ENUM_OUT_OF_SYNC</b></dt> </dl> </td> <td width="60%"> The enumerator has
    ///    become invalid. For more information, see Remarks. </td> </tr> </table>
    ///    
    HRESULT Next(uint cFilters, char* apRegFilter, uint* pcFetched);
    ///<div class="alert"><b>Note</b> The <code>IEnumRegFilters</code> interface is deprecated.</div> <div> </div> This
    ///method is not currently implemented and returns E_NOTIMPL.
    ///Params:
    ///    cFilters = Number of items to skip.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT Skip(uint cFilters);
    ///<div class="alert"><b>Note</b> The <b>IEnumRegFilters</b> interface is deprecated.</div> <div> </div> Resets the
    ///enumerator so that the next call to the IEnumRegFilters::Next method begins again at the first filter, if any.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT Reset();
    ///<div class="alert"><b>Note</b> The <b>IEnumRegFilters</b> interface is deprecated.</div> <div> </div> This method
    ///is not currently implemented and returns E_NOTIMPL.
    ///Params:
    ///    ppEnum = Address of a pointer to the duplicate enumerator interface.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT Clone(IEnumRegFilters* ppEnum);
}

///<div class="alert"><b>Note</b> This interface has been deprecated. It will continue to be supported for backward
///compatibility with existing applications, but new applications should use the IFilterMapper2 interface.</div> <div>
///</div> This interface provides methods for registering and unregistering filters, and for looking up filters based on
///their characteristics.
@GUID("56A868A3-0AD4-11CE-B03A-0020AF0BA770")
interface IFilterMapper : IUnknown
{
    ///<div class="alert"><b>Note</b> The <b>IFilterMapper</b> interface is deprecated. Use IFilterMapper2
    ///instead.</div> <div> </div> Adds a filter to the registry; the filter can then be enumerated.
    ///Params:
    ///    clsid = Globally unique identifier (<b>GUID</b>) of the filter.
    ///    Name = Descriptive name for the filter.
    ///    dwMerit = Position in the order of enumeration. Filters with higher merit are enumerated first.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT RegisterFilter(GUID clsid, const(wchar)* Name, uint dwMerit);
    ///<div class="alert"><b>Note</b> The <b>IFilterMapper</b> interface is deprecated. Use IFilterMapper2
    ///instead.</div> <div> </div> Registers an identifiable instance of a filter.
    ///Params:
    ///    clsid = GUID of the filter.
    ///    Name = Descriptive name of the instance.
    ///    MRId = Pointer to the returned media resource ID. This parameter is a locally unique identifier for this instance of
    ///           this filter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT RegisterFilterInstance(GUID clsid, const(wchar)* Name, GUID* MRId);
    ///<div class="alert"><b>Note</b> The <b>IFilterMapper</b> interface is deprecated. Use IFilterMapper2
    ///instead.</div> <div> </div> Records the details of the pin in the registry.
    ///Params:
    ///    Filter = GUID of the filter.
    ///    Name = Name of the pin. This should be unique within the filter. It has no significance other than to indicate type
    ///           information. You should not use pin names longer than 99 characters, because this causes filter enumeration
    ///           problems.
    ///    bRendered = Value specifying whether the filter renders this input. Set to <b>TRUE</b> if it does; otherwise, set to
    ///                <b>FALSE</b>.
    ///    bOutput = Value specifying whether this is an output pin. Set to <b>TRUE</b> if it is; otherwise, set to <b>FALSE</b>.
    ///    bZero = Value specifying whether the filter can have zero instances of this pin. If it can, set to <b>TRUE</b>;
    ///            otherwise, set to <b>FALSE</b>. For example, a decompression filter doesn't need to create a sound output pin
    ///            for a movie without a sound track.
    ///    bMany = Value specifying whether the filter can have many instances of this pin. If it can, set to <b>TRUE</b>;
    ///            otherwise, set to <b>FALSE</b>. For example, a mixer might have multiple instances of its input pin.
    ///    ConnectsToFilter = Reserved. Must be <b>NULL</b>. (This is intended for filters such as system-wide mixers that have connections
    ///                       outside the filter graph. It is not yet implemented.)
    ///    ConnectsToPin = Reserved. Must be <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT RegisterPin(GUID Filter, const(wchar)* Name, BOOL bRendered, BOOL bOutput, BOOL bZero, BOOL bMany, 
                        GUID ConnectsToFilter, const(wchar)* ConnectsToPin);
    ///<div class="alert"><b>Note</b> The <b>IFilterMapper</b> interface is deprecated. Use IFilterMapper2
    ///instead.</div> <div> </div> Registers this pin type.
    ///Params:
    ///    clsFilter = Class identifier (CLSID) of the filter to which the pin belongs.
    ///    strName = Name by which it is known.
    ///    clsMajorType = Major type of the media sample supported by this pin class.
    ///    clsSubType = Subtype of the media sample supported by this pin class.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT RegisterPinType(GUID clsFilter, const(wchar)* strName, GUID clsMajorType, GUID clsSubType);
    ///<div class="alert"><b>Note</b> The <b>IFilterMapper</b> interface is deprecated. Use IFilterMapper2
    ///instead.</div> <div> </div> Removes the registration of this filter from the registry.
    ///Params:
    ///    Filter = GUID of the filter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT UnregisterFilter(GUID Filter);
    ///<div class="alert"><b>Note</b> The <b>IFilterMapper</b> interface is deprecated. Use IFilterMapper2
    ///instead.</div> <div> </div> Removes the registration of this filter instance from the registry.
    ///Params:
    ///    MRId = Media resource identifier of this instance.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT UnregisterFilterInstance(GUID MRId);
    ///<div class="alert"><b>Note</b> The <b>IFilterMapper</b> interface is deprecated. Use IFilterMapper2
    ///instead.</div> <div> </div> Removes the registration of this pin from the registry.
    ///Params:
    ///    Filter = GUID of the filter that this pin is part of.
    ///    Name = Name of the pin.
    HRESULT UnregisterPin(GUID Filter, const(wchar)* Name);
    ///<div class="alert"><b>Note</b> The <b>IFilterMapper</b> interface is deprecated. Use IFilterMapper2
    ///instead.</div> <div> </div> Provides an enumerator that enumerates registered filters that meet specified
    ///requirements.
    ///Params:
    ///    ppEnum = Address of a pointer to the enumerator returned.
    ///    dwMerit = Minimum merit value of filters to enumerate.
    ///    bInputNeeded = Value indicating whether there must be at least one input pin; <b>TRUE</b> indicates at least one input pin
    ///                   is required.
    ///    clsInMaj = Input major type required. Set to GUID_NULL if you do not care.
    ///    clsInSub = Input subtype required. Set to GUID_NULL if you do not care.
    ///    bRender = Flag that specifies whether the filter must render the input; <b>TRUE</b> means that it must.
    ///    bOututNeeded = Value indicating whether there must be at least one output pin; <b>TRUE</b> indicates at least one output pin
    ///                   is required.
    ///    clsOutMaj = Output major type required. Set to GUID_NULL if you do not care.
    ///    clsOutSub = Output subtype required. Set to GUID_NULL if you do not care.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT EnumMatchingFilters(IEnumRegFilters* ppEnum, uint dwMerit, BOOL bInputNeeded, GUID clsInMaj, 
                                GUID clsInSub, BOOL bRender, BOOL bOututNeeded, GUID clsOutMaj, GUID clsOutSub);
}

///Registers and unregisters filters, and locates filters in the registry. The Filter Mapper helper object implements
///this interface. Filters use this interface to register and unregister themselves. When the filter graph manager
///builds a filter graph, it uses this interface to look up filters and determine their characteristics. Applications
///can also use this interface to look up filters. For more information, see Using the Filter Mapper and How to Register
///DirectShow Filters.
@GUID("B79BB0B0-33C1-11D1-ABE1-00A0C905F375")
interface IFilterMapper2 : IUnknown
{
    ///The <code>CreateCategory</code> method adds a new filter category to the registry.
    ///Params:
    ///    clsidCategory = Class identifier (CLSID) of the new filter category.
    ///    dwCategoryMerit = Merit of the category. Categories with higher merit are enumerated first.
    ///    Description = Descriptive name for the category.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT CreateCategory(const(GUID)* clsidCategory, uint dwCategoryMerit, const(wchar)* Description);
    ///The <code>UnregisterFilter</code> method removes filter information from the registry.
    ///Params:
    ///    pclsidCategory = Address of a GUID that specifies the filter category from which to remove the filter. For a list of
    ///                     categories, see Filter Categories.
    ///    szInstance = Instance data used to construct the device moniker's display name. Use the value that was originally passed
    ///                 to the <b>RegisterFilter</b> method.
    ///    Filter = Class identifier (CLSID) of the filter.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT UnregisterFilter(const(GUID)* pclsidCategory, ushort* szInstance, const(GUID)* Filter);
    ///The <code>RegisterFilter</code> method adds filter information to the registry.
    ///Params:
    ///    clsidFilter = Class identifier (CLSID) of the filter.
    ///    Name = Descriptive name for the filter.
    ///    ppMoniker = Address of a pointer to a device moniker that determines where this filter's data will be written. Can be
    ///                <b>NULL</b>.
    ///    pclsidCategory = Pointer to the filter category of the filter. If <b>NULL</b>, the default category is
    ///                     CLSID_ActiveMovieFilters. (See Filter Categories.)
    ///    szInstance = Instance data for constructing the device moniker's display name. Can be the friendly name, or the string
    ///                 representation of the filter CLSID. If <b>NULL</b>, defaults to the filter CLSID.
    ///    prf2 = Pointer to a REGFILTER2 structure containing filter information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_BAD_KEY</b></dt> </dl> </td>
    ///    <td width="60%"> Could not get registry key. </td> </tr> </table>
    ///    
    HRESULT RegisterFilter(const(GUID)* clsidFilter, const(wchar)* Name, IMoniker* ppMoniker, 
                           const(GUID)* pclsidCategory, ushort* szInstance, const(REGFILTER2)* prf2);
    ///The <code>EnumMatchingFilters</code> method enumerates registered filters that meet specified requirements.
    ///Params:
    ///    ppEnum = Receives a pointer to the IEnumMoniker interface. Use this interface pointer to retrieve filter monikers from
    ///             the enumeration. The caller must release the interface.
    ///    dwFlags = Reserved, must be zero.
    ///    bExactMatch = Boolean value indicating whether an exact match is required. See Remarks for more information.
    ///    dwMerit = Minimum merit value. The enumeration exludes filters with a lesser merit value. For a list of merit values,
    ///              see Merit. If <i>dwMerit</i> is higher than MERIT_DO_NOT_USE, the enumeration also excludes filters whose
    ///              category has a merit less than or equal to MERIT_DO_NOT_USE. (See Filter Categories.)
    ///    bInputNeeded = Boolean value indicating whether the filter must have an input pin. If the value is <b>TRUE</b>, the filter
    ///                   must have at least one input pin.
    ///    cInputTypes = Number of input media types specified in <i>pInputTypes</i>.
    ///    pInputTypes = Pointer to an array of GUID pairs that specify major types and subtypes, for the input pins to match. The
    ///                  size of the array is 2 * <i>cInputTypes</i>. The array can be <b>NULL</b>. Individual array members can be
    ///                  GUID_NULL, which matches any type. (See Media Types.)
    ///    pMedIn = Pointer to a REGPINMEDIUM structure specifying the medium for the input pins. Set to <b>NULL</b> if not
    ///             needed.
    ///    pPinCategoryIn = Pointer to a GUID that specifies the input pin category. (See Pin Property Set.) Set to <b>NULL</b> if not
    ///                     needed.
    ///    bRender = Boolean value that specifies whether the filter must render its input. If <b>TRUE</b>, the specified filter
    ///              must render its input. (This value corresponds to the <b>bRendered</b> field in the REGFILTERPINS structure,
    ///              which is used to register information about the filter's pins.)
    ///    bOutputNeeded = Boolean value specifying whether the filter must have an output pin. If <b>TRUE</b>, the filter must have at
    ///                    least one output pin.
    ///    cOutputTypes = Number of input media types specified in <i>pOutputTypes</i>.
    ///    pOutputTypes = Pointer to an array of GUID pairs that specify major types and subtypes, for the output pins to match. The
    ///                   size of the array is 2 * <i>cOutputTypes</i>. The array can be <b>NULL</b>. Individual array members can be
    ///                   GUID_NULL, which matches any type.
    ///    pMedOut = Pointer to a REGPINMEDIUM structure specifying the medium for the output pins. Set to <b>NULL</b> if not
    ///              needed.
    ///    pPinCategoryOut = Pointer to a GUID that specifies the output pin category. (See Pin Property Set.) Set to <b>NULL</b> if not
    ///                      needed.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> <b>NULL</b> pointer argument </td> </tr> </table>
    ///    
    HRESULT EnumMatchingFilters(IEnumMoniker* ppEnum, uint dwFlags, BOOL bExactMatch, uint dwMerit, 
                                BOOL bInputNeeded, uint cInputTypes, char* pInputTypes, const(REGPINMEDIUM)* pMedIn, 
                                const(GUID)* pPinCategoryIn, BOOL bRender, BOOL bOutputNeeded, uint cOutputTypes, 
                                char* pOutputTypes, const(REGPINMEDIUM)* pMedOut, const(GUID)* pPinCategoryOut);
}

///The <code>IFilterMapper3</code> interface extends the IFilterMapper2 interface. The Filter Mapper object implements
///this interface. <div class="alert"><b>Note</b> This interface is deprecated.</div> <div> </div>
@GUID("B79BB0B1-33C1-11D1-ABE1-00A0C905F375")
interface IFilterMapper3 : IFilterMapper2
{
    ///The <code>GetICreateDevEnum</code> method returns a pointer to the <b>ICreateDevEnum</b> interface. You can use
    ///the ICreateDevEnum interface to create an enumerator for a category of filters, such as video capture devices or
    ///audio capture devices. <div class="alert"><b>Note</b> This method is deprecated. Instead, applications should
    ///call <b>CoCreateInstance</b> with CLSID_SystemDeviceEnum to create the System Device Enumerator.</div><div>
    ///</div>
    ///Params:
    ///    ppEnum = Receives a pointer to the <b>ICreateDevEnum</b> interface. The caller must release the interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetICreateDevEnum(ICreateDevEnum* ppEnum);
}

///The <code>IQualityControl</code> interface provides support for quality control. An object exposes this interface if
///it can generate or receive quality-control messages. This includes renderer filters (which typically generate quality
///control messages), pins (which receive them), and external quality managers (which also receive them). A renderer
///filter generates a quality-control message by calling the IQualityControl::Notify method on the output pin of the
///upstream filter. The upstream filter either handles the message or passes it upstream. An application can implement
///its own quality-control manager. Call IQualityControl::SetSink on the renderer to designate the quality-control
///manager as the recipient for quality-control messages. Calling this method overrides the default handling of
///quality-control messages. However, most applications will not implement their own quality-control managers; and aside
///from this special case, applications typically do not use this interface. For more information, see Quality-Control
///Management
@GUID("56A868A5-0AD4-11CE-B03A-0020AF0BA770")
interface IQualityControl : IUnknown
{
    ///The <code>Notify</code> method notifies the filter that a quality change is requested.
    ///Params:
    ///    pSelf = Pointer to the filter that is sending the quality notification.
    ///    q = [Quality](/windows/desktop/api/strmif/ns-strmif-quality) structure.
    ///Returns:
    ///    Returns S_OK if the method succeeds; otherwise, returns an <b>HRESULT</b> error code.
    ///    
    HRESULT Notify(IBaseFilter pSelf, Quality q);
    ///The <code>SetSink</code> method sets the IQualityControl object that will receive quality messages.
    ///Params:
    ///    piqc = Pointer to the IQualityControl object to which the notifications should be sent.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation. <b>HRESULT</b> can be one of the
    ///    following standard constants, or other values not listed. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method isn't supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK or
    ///    NOERROR</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetSink(IQualityControl piqc);
}

///The <code>IOverlayNotify</code> interface provides an upstream filter, such as a decoder, with notifications of
///changes to the rendering window. This includes notifications of changes to the palette, color key, and window
///position, and visible region (clipping) changes. Most software video decoders let the video renderer draw the
///decompressed images they produce by passing the media samples to the IMemInputPin interface on the renderer's input
///pin. However, some video decoding filters (typically hardware decompression boards) handle the drawing of the images
///themselves, perhaps by using a VGA connector. These filters do not need to use IMemInputPin, but can instead use the
///IOverlay interface provided by the renderer input pin. Through this interface, the decoder can be notified when the
///window position or size changes, or when the current system palette changes in order to install and change color keys
///and palettes. Decoders that do their own drawing should implement the <code>IOverlayNotify</code> and IOverlayNotify2
///interfaces. The renderer uses this interface to notify the decoder whenever the window size or position changes, the
///system palette changes, or a different color key is used. The decoder should call the IOverlay::Advise method on the
///renderer's input pin, to set up the callback. Once the callback is established, the renderer calls the decoder's
///<code>IOverlayNotify</code> methods when the appropriate events occur. To cancel the callback, use the
///IOverlay::Unadvise method. The video renderer is the only filter that calls the methods on this interface. This is
///done automatically by the default video renderer. If you are writing a replacement video renderer, you will need to
///use the methods on this interface if your filter supports <b>IOverlay</b> and this interface is passed to your filter
///in an IOverlay::Advise call.
@GUID("56A868A0-0AD4-11CE-B03A-0020AF0BA770")
interface IOverlayNotify : IUnknown
{
    ///The <code>OnPaletteChange</code> method provides notification that the palette of the window has changed.
    ///Params:
    ///    dwColors = Number of colors present.
    ///    pPalette = Pointer to the array of palette colors.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT OnPaletteChange(uint dwColors, const(PALETTEENTRY)* pPalette);
    ///The <code>OnClipChange</code> method provides notification that the window's visible region has changed. It is
    ///essential that any overlay hardware be updated to reflect the change to the visible region before returning from
    ///this method.
    ///Params:
    ///    pSourceRect = Pointer to the region of the video to use.
    ///    pDestinationRect = Pointer to the video destination.
    ///    pRgnData = Pointer to the clipping information.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT OnClipChange(const(RECT)* pSourceRect, const(RECT)* pDestinationRect, const(RGNDATA)* pRgnData);
    ///The <code>OnColorKeyChange</code> method provides notification that the window's color key has changed.
    ///Params:
    ///    pColorKey = Pointer to the new chroma key.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT OnColorKeyChange(const(COLORKEY)* pColorKey);
    ///The <code>OnPositionChange</code> method provides notification that the position has changed.
    ///Params:
    ///    pSourceRect = Pointer to the source video rectangle.
    ///    pDestinationRect = Pointer to the destination video rectangle. Note that this is not clipped to the visible display area.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT OnPositionChange(const(RECT)* pSourceRect, const(RECT)* pDestinationRect);
}

///The <code>IOverlayNotify2</code> interface derives from the IOverlayNotify interface. <code>IOverlayNotify2</code>
///gives asynchronous notifications of changes to the rendering window, identifying changes to the exposed window area.
///The advise link optionally supports this for the purpose of accepting IOverlayNotify2::OnDisplayChange notification.
///To get notifications that the exposed window area has changed, decoders that do their own drawing should implement an
///<code>IOverlayNotify2</code> interface. The video renderer is the only filter that calls the method on this
///interface. This is done automatically by the default video renderer.
@GUID("680EFA10-D535-11D1-87C8-00A0C9223196")
interface IOverlayNotify2 : IOverlayNotify
{
    ///The <code>OnDisplayChange</code> method provides notification that the exposed window area has changed.
    ///Params:
    ///    hMonitor = Handle to the monitor used for displaying the overlay.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT OnDisplayChange(ptrdiff_t hMonitor);
}

///The <code>IOverlay</code> interface provides information so that a filter can write directly to video memory while
///placing the video in the correct window position. It is implemented on the input pin of the video renderer and
///communicates with an upstream filter (typically a video decompressor) by calling that filter's IOverlayNotify methods
///to notify it of changes to the video window. This interface has no relationship to the DirectDraw® overlay
///capability. The Microsoft video renderer draws data it receives through the IMemInputPin interface, using DirectDraw
///overlays when available. This interface, used in place of <b>IMemInputPin</b>, is intended to provide notification
///support for any upstream filter that bypasses the renderer's drawing capabilities, but needs notifications of other
///display properties. See the IOverlayNotify reference page for more information on how the <code>IOverlay</code> and
///<b>IOverlayNotify</b> interfaces work together. See the IOverlayNotify2 interface for more information on
///asynchronous notifications of changes to the rendering window. This interface is implemented on the Microsoft®
///DirectShow® video renderer filter. It can also be implemented on replacement video renderer filters if desired. If
///doing so, implement this interface so that filters writing directly to the frame buffer or trying to position an
///overlay know where to display their video. To implement this interface, the renderer must be prepared to use methods
///on the IOverlayNotify interface or the IOverlayNotify2 interface of the filter doing the drawing, with notifications
///of video property changes. The window-based renderer in DirectShow supports both IMemInputPin and <b>IOverlay</b>
///interfaces. These two interfaces are mutually exclusive. A filter chooses to use the <b>IOverlay</b> transport by
///providing a media type during connection that has a subtype of MEDIASUBTYPE_Overlay. After connection, it will be
///able to get and use successfully the <code>IOverlay</code> interface. If it connects with any other video formats
///(such as MEDIASUBTYPE_RGB8), trying to call through <code>IOverlay</code> returns VFW_E_NOT_OVERLAY_CONNECTION. Use
///the methods on this function from an upstream filter that must control video overlay properties and intends to handle
///the displaying of the video data itself. This typically is used by hardware video decoders that have an alternate
///connection to the video hardware.
@GUID("56A868A1-0AD4-11CE-B03A-0020AF0BA770")
interface IOverlay : IUnknown
{
    ///The <code>GetPalette</code> method retrieves the current system palette.
    ///Params:
    ///    pdwColors = Pointer to a variable that receives the number of colors present.
    ///    ppPalette = Receives a pointer to a PALETTEENTRY structure describing the palette.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetPalette(uint* pdwColors, char* ppPalette);
    ///The <code>SetPalette</code> method sets the palette.
    ///Params:
    ///    dwColors = Number of colors present.
    ///    pPalette = Pointer to colors to use for the palette.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetPalette(uint dwColors, char* pPalette);
    ///The <code>GetDefaultColorKey</code> method retrieves the default color key used for a chroma key overlay.
    ///Params:
    ///    pColorKey = Pointer to a variable that receives the default color key.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetDefaultColorKey(COLORKEY* pColorKey);
    ///The <code>GetColorKey</code> method retrieves the current color key used for chroma keying.
    ///Params:
    ///    pColorKey = Pointer to a variable that receives the current color key for chroma keying.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetColorKey(COLORKEY* pColorKey);
    ///The <code>SetColorKey</code> method changes the color key.
    ///Params:
    ///    pColorKey = Pointer to the color key value to be set. If successful, the actual color key value selected is copied to
    ///                this parameter.
    ///Returns:
    ///    Returns S_OK if successful, E_POINTER if <i>pColorKey</i> is <b>NULL</b>, or E_INVALIDARG if the value of
    ///    <i>pColorKey</i> is invalid for the current palette or pixel format.
    ///    
    HRESULT SetColorKey(COLORKEY* pColorKey);
    ///The <code>GetWindowHandle</code> method retrieves the current window handle.
    ///Params:
    ///    pHwnd = Receives the window handle.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetWindowHandle(HWND* pHwnd);
    ///The <code>GetClipList</code> method retrieves the clipping list.
    ///Params:
    ///    pSourceRect = Pointer to the bounding client rectangle.
    ///    pDestinationRect = Pointer to the destination rectangle.
    ///    ppRgnData = Address of a pointer to the header and data describing clipping. If successful, free the allocated memory by
    ///                calling CoTaskMemFree.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetClipList(RECT* pSourceRect, RECT* pDestinationRect, RGNDATA** ppRgnData);
    ///The <code>GetVideoPosition</code> method retrieves the current video source and destination rectangles.
    ///Params:
    ///    pSourceRect = Pointer to a <b>RECT</b> structure that receives the source rectangle.
    ///    pDestinationRect = Pointer to to a <b>RECT</b> structure that receives the destination rectangle.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetVideoPosition(RECT* pSourceRect, RECT* pDestinationRect);
    ///The <code>Advise</code> method sets up an advise link for the overlay events specified by the <i>dwInterests</i>
    ///parameter.
    ///Params:
    ///    pOverlayNotify = Pointer to the notification interface.
    ///    dwInterests = Callbacks of interest, which can be any subset of the following events. <table> <tr> <th>Event </th>
    ///                  <th>Description </th> </tr> <tr> <td>ADVISE_NONE</td> <td>No changes.</td> </tr> <tr>
    ///                  <td>ADVISE_CLIPPING</td> <td>Change in clipping region (synchronized with the window).</td> </tr> <tr>
    ///                  <td>ADVISE_PALETTE</td> <td>Change in palette.</td> </tr> <tr> <td>ADVISE_COLORKEY</td> <td>Change of chroma
    ///                  key value.</td> </tr> <tr> <td>ADVISE_POSITION</td> <td>Change in position of video window (not synchronized
    ///                  with the window).</td> </tr> <tr> <td>ADVISE_DISPLAY_CHANGE</td> <td>Called on WM_DISPLAYCHANGE. The
    ///                  <b>WM_DISPLAYCHANGE</b> message is sent to all windows when the display resolution has changed.</td> </tr>
    ///                  <tr> <td>ADVISE_ALL2</td> <td>All of the above.</td> </tr> </table>
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT Advise(IOverlayNotify pOverlayNotify, uint dwInterests);
    ///The <code>Unadvise</code> method terminates the advise link established with the IOverlayNotify interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT Unadvise();
}

///Notifies the Filter Graph Manager of events that occur within the filter graph. Filters use this interface to report
///events. The Filter Graph Manager exposes this interface. Applications do not use <code>IMediaEventSink</code>. To
///retrieve events, applications use the IMediaEventEx interface.
@GUID("56A868A2-0AD4-11CE-B03A-0020AF0BA770")
interface IMediaEventSink : IUnknown
{
    ///The <code>Notify</code> method notifies the Filter Graph Manager of an event.
    ///Params:
    ///    EventCode = Identifier of the event.
    ///    EventParam1 = First event parameter.
    ///    EventParam2 = Second event parameter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT Notify(int EventCode, ptrdiff_t EventParam1, ptrdiff_t EventParam2);
}

///The <code>IFileSourceFilter</code> interface is exposed by source filters to set the file name and media type of the
///media file that they are to render. It is an abbreviated version of the COM IPersistFile interface. If the file has a
///type that can be determined by the algorithm described in Registering a Custom File Type, the recommended file source
///filter CLSID is used when the filter graph manager attempts to render the filter graph. If a filter needs the name of
///a file to open, it should expose this interface to allow an application to set the file name. Note that there is no
///base class implementation of this interface. An application that inserts file source filters directly must query for
///this interface and set the file name. Normally, the filter graph manager uses this interface when an application
///calls IGraphBuilder::RenderFile. The Graphedt.exe tool queries for the <b>IFileSourceFilter</b> interface and prompts
///for a file name if it finds it.
@GUID("56A868A6-0AD4-11CE-B03A-0020AF0BA770")
interface IFileSourceFilter : IUnknown
{
    ///The <code>Load</code> method causes a source filter to load a media file.
    ///Params:
    ///    pszFileName = Pointer to the name of the file to open.
    ///    pmt = Pointer to the media type of the file. This can be <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT Load(ushort* pszFileName, const(AM_MEDIA_TYPE)* pmt);
    ///The <code>GetCurFile</code> method retrieves the name and media type of the current file.
    ///Params:
    ///    ppszFileName = Address of a pointer that receives the name of the file, as an <b>OLESTR</b> type.
    ///    pmt = Pointer to an AM_MEDIA_TYPE structure that receives the media type. This parameter can by <b>NULL</b>, in
    ///          which case the method does not return the media type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> No file
    ///    is opened. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument in <i>ppszFileName</i>. </td> </tr> </table>
    ///    
    HRESULT GetCurFile(ushort** ppszFileName, AM_MEDIA_TYPE* pmt);
}

///The <code>IFileSinkFilter</code> interface is implemented on filters that write media streams to a file. A file sink
///filter in a video capture filter graph, for instance, writes the output of the video compression filter to a file.
///Typically, the application running this filter graph should enable the user to enter the name of the file to be
///written to. This interface enables the communication of this information. If a filter needs the name of an output
///file, it should expose this interface to allow an application to set the file name. Note that there is currently no
///base class implementation of this interface. Any application that must set the name of the file into which the file
///sink filter will write should use this interface to get and set the file name.
@GUID("A2104830-7C70-11CF-8BCE-00AA00A3F1A6")
interface IFileSinkFilter : IUnknown
{
    ///The <code>SetFileName</code> method sets the name of the file into which media samples will be written.
    ///Params:
    ///    pszFileName = Pointer to the name of the file to receive the media samples.
    ///    pmt = Pointer to the type of media samples to be written to the file, and the media type of the sink filter's input
    ///          pin.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetFileName(ushort* pszFileName, const(AM_MEDIA_TYPE)* pmt);
    ///The <code>GetCurFile</code> method retrieves the name and media type of the current file.
    ///Params:
    ///    ppszFileName = Address of a pointer that receives the name of the file, as an <b>OLESTR</b> type.
    ///    pmt = Pointer to an AM_MEDIA_TYPE structure that receives the media type. This parameter can by <b>NULL</b>, in
    ///          which case the method does not return the media type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> No file
    ///    is opened. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument in <i>ppszFileName</i>. </td> </tr> </table>
    ///    
    HRESULT GetCurFile(ushort** ppszFileName, AM_MEDIA_TYPE* pmt);
}

///The <b>IFileSinkFilter2</b> interface extends the IFileSinkFilter interface. Filters that write media streams to a
///file implement this interface. A file sink filter in a video capture filter graph, for instance, saves the output of
///the video compression filter to a file. Typically, the application running this filter graph should allow the user to
///enter the name of the file to which to save the data. This interface enables you to communicate this information.
///<b>IFileSinkFilter2</b> adds the option to determine whether the file it writes should destroy an existing file of
///the same name. In the video capture case, do not destroy a file you've already created, because preallocating file
///space takes valuable time. By default, the new file does not destroy the old one. Otherwise, destroy the original
///file to make sure the file you author doesn't contain garbage.
@GUID("00855B90-CE1B-11D0-BD4F-00A0C911CE86")
interface IFileSinkFilter2 : IFileSinkFilter
{
    ///The <code>SetMode</code> method determines whether the file writer destroys the file when it creates the new one.
    ///Params:
    ///    dwFlags = Currently, the only defined flag is AM_FILE_OVERWRITE, which indicates that the file writer should destroy
    ///              the file. Specify zero for <i>dwFlags</i> to leave the file alone.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT SetMode(uint dwFlags);
    ///The <code>GetMode</code> method retrieves whether the file writer destroys the file when it creates the new one.
    ///Params:
    ///    pdwFlags = Pointer to the retrieved flags. Currently, the only defined flag is AM_FILE_OVERWRITE, which indicates that
    ///               the file should be destroyed; zero indicates that the file will be left alone.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetMode(uint* pdwFlags);
}

///This interface provides methods that enable an application to build a filter graph. The Filter Graph Manager
///implements this interface. The <b>IGraphBuilder</b> interface inherits from the IFilterGraph interface.
///<b>IFilterGraph</b> provides basic operations, such as adding a filter to the graph or connecting two pins.
///<b>IGraphBuilder</b> adds further methods that construct graphs from partial information. For example, the
///IGraphBuilder::RenderFile method builds a graph for file playback, given the name of the file. The
///IGraphBuilder::Render method renders data from an output pin by connecting new filters to the pin. Using these
///methods, an application does not need to specify every filter and pin connection in the graph. Instead, the Filter
///Graph Manager selects filters that are registered on the user's system, adds them to the graph, and connects them.
///For more information, see Intelligent Connect.
@GUID("56A868A9-0AD4-11CE-B03A-0020AF0BA770")
interface IGraphBuilder : IFilterGraph
{
    ///The <code>Connect</code> method connects the two pins, using intermediates if necessary.
    ///Params:
    ///    ppinOut = Pointer to the IPin interface on the output pin.
    ///    ppinIn = Pointer to the <b>IPin</b> interface on the input pin.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_S_PARTIAL_RENDER</b></dt> </dl> </td> <td
    ///    width="60%"> Partial success; some of the streams from this pin use an unsupported format. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%"> Operation aborted. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_CANNOT_CONNECT</b></dt> </dl> </td> <td
    ///    width="60%"> No combination of intermediate filters could be found to make the connection. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_IN_GRAPH</b></dt> </dl> </td> <td width="60%"> At least one of the
    ///    filters is not in the filter graph. </td> </tr> </table>
    ///    
    HRESULT Connect(IPin ppinOut, IPin ppinIn);
    ///The <code>Render</code> method builds a filter graph that renders the data from a specified output pin.
    ///Params:
    ///    ppinOut = Pointer to the IPin interface on an output pin.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_S_AUDIO_NOT_RENDERED</b></dt> </dl> </td> <td
    ///    width="60%"> Partial success; the audio was not rendered. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_S_DUPLICATE_NAME</b></dt> </dl> </td> <td width="60%"> Success; the Filter Graph Manager modified
    ///    a filter name to avoid duplication. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_S_PARTIAL_RENDER</b></dt> </dl> </td> <td width="60%"> Partial success; some of the streams in
    ///    this movie are in an unsupported format. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_S_VIDEO_NOT_RENDERED</b></dt> </dl> </td> <td width="60%"> Partial success; the video was not
    ///    rendered. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%">
    ///    Operation aborted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_CANNOT_CONNECT</b></dt> </dl> </td> <td width="60%"> No combination of intermediate filters
    ///    could be found to make the connection. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_CANNOT_RENDER</b></dt> </dl> </td> <td width="60%"> No combination of filters could be found to
    ///    render the stream. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NO_ACCEPTABLE_TYPES</b></dt> </dl>
    ///    </td> <td width="60%"> There is no common media type between these pins. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VFW_E_NOT_IN_GRAPH</b></dt> </dl> </td> <td width="60%"> The filter to which this pin belongs is
    ///    not in the filter graph. </td> </tr> </table>
    ///    
    HRESULT Render(IPin ppinOut);
    ///The <code>RenderFile</code> method builds a filter graph that renders the specified file.
    ///Params:
    ///    lpcwstrFile = Specifies a wide-character string that contains the name of a media file.
    ///    lpcwstrPlayList = Reserved. Must be <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_S_AUDIO_NOT_RENDERED</b></dt> </dl> </td> <td
    ///    width="60%"> Partial success; the audio was not rendered. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_S_DUPLICATE_NAME</b></dt> </dl> </td> <td width="60%"> Success; the Filter Graph Manager modified
    ///    the filter name to avoid duplication. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_S_PARTIAL_RENDER</b></dt> </dl> </td> <td width="60%"> Some of the streams in this movie are in an
    ///    unsupported format. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_S_VIDEO_NOT_RENDERED</b></dt> </dl>
    ///    </td> <td width="60%"> Partial success; some of the streams in this movie are in an unsupported format. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%"> Operation aborted.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Argument is
    ///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_CANNOT_CONNECT</b></dt> </dl> </td> <td width="60%"> No combination of intermediate filters
    ///    could be found to make the connection. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_CANNOT_LOAD_SOURCE_FILTER</b></dt> </dl> </td> <td width="60%"> The source filter for this file
    ///    could not be loaded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_CANNOT_RENDER</b></dt> </dl> </td>
    ///    <td width="60%"> No combination of filters could be found to render the stream. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_INVALID_FILE_FORMAT</b></dt> </dl> </td> <td width="60%"> The file format is
    ///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%">
    ///    An object or name was not found. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_UNKNOWN_FILE_TYPE</b></dt> </dl> </td> <td width="60%"> The media type of this file is not
    ///    recognized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_UNSUPPORTED_STREAM</b></dt> </dl> </td> <td
    ///    width="60%"> Cannot play back the file: the format is not supported. </td> </tr> </table>
    ///    
    HRESULT RenderFile(const(wchar)* lpcwstrFile, const(wchar)* lpcwstrPlayList);
    ///The <code>AddSourceFilter</code> method adds a source filter for a specified file to the filter graph.
    ///Params:
    ///    lpcwstrFileName = Specifies the name of the file to load.
    ///    lpcwstrFilterName = Specifies a name for the source filter.
    ///    ppFilter = Receives a pointer to the filter's IBaseFilter interface. The caller must release the interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%">
    ///    The source filter does not support the IFileSourceFilter interface. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_CANNOT_LOAD_SOURCE_FILTER</b></dt> </dl> </td> <td width="60%">
    ///    The source filter for this file could not be loaded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> File or object not found. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_UNKNOWN_FILE_TYPE</b></dt> </dl> </td> <td width="60%"> The media type of this
    ///    file was not recognized. </td> </tr> </table>
    ///    
    HRESULT AddSourceFilter(const(wchar)* lpcwstrFileName, const(wchar)* lpcwstrFilterName, IBaseFilter* ppFilter);
    ///The <code>SetLogFile</code> method sets the file for logging actions taken when attempting to perform an
    ///operation.
    ///Params:
    ///    hFile = Handle to the log file.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT SetLogFile(size_t hFile);
    ///The <code>Abort</code> method requests the Filter Graph Manager to halt its current task as quickly as possible.
    ///The current task may or may not fail to complete. Possibly the fastest option for the Filter Graph Manager is to
    ///complete the task.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT Abort();
    ///The <code>ShouldOperationContinue</code> method queries whether the current operation should continue. A filter
    ///that is performing some operation at the request of the graph can call this method to determine whether it should
    ///continue. Applications will not normally call this method.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    current operation should continue. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td>
    ///    <td width="60%"> The current operation should not continue. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. </td> </tr> </table>
    ///    
    HRESULT ShouldOperationContinue();
}

///<div class="alert"><b>Note</b> This interface has been deprecated. It will continue to be supported for backward
///compatibility with existing applications, but new applications should use the ICaptureGraphBuilder2 interface.</div>
///<div> </div> The <code>ICaptureGraphBuilder</code> interface enables you to build capture graphs, preview graphs,
///file recompression graphs, or other custom graphs.
@GUID("BF87B6E0-8C27-11D0-B3F0-00AA003761C5")
interface ICaptureGraphBuilder : IUnknown
{
    ///<div class="alert"><b>Note</b> The <b>ICaptureGraphBuilder</b> interface is deprecated. Use ICaptureGraphBuilder2
    ///instead.</div> <div> </div> Tells the graph builder object which filter graph to use.
    ///Params:
    ///    pfg = Pointer to an IGraphBuilder interface that specifies the filter graph to use for subsequent calls to the
    ///          IFilterGraph::AddFilter method.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetFiltergraph(IGraphBuilder pfg);
    ///<div class="alert"><b>Note</b> The <b>ICaptureGraphBuilder</b> interface is deprecated. Use ICaptureGraphBuilder2
    ///instead.</div> <div> </div> Retrieves the filter graph that the builder is using.
    ///Params:
    ///    ppfg = Address of a pointer to an IGraphBuilder interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetFiltergraph(IGraphBuilder* ppfg);
    ///<div class="alert"><b>Note</b> The <b>ICaptureGraphBuilder</b> interface is deprecated. Use ICaptureGraphBuilder2
    ///instead.</div> <div> </div> Creates the rendering section of the filter graph, which will save bits to disk with
    ///the specified file name.
    ///Params:
    ///    pType = Pointer to a <b>GUID</b> representing the media subtype. Must be <code>&amp;MEDIASUBTYPE_Avi</code>.
    ///    lpstrFile = Pointer to a wide-character string containing the output file name.
    ///    ppf = Address of a pointer to an IBaseFilter interface representing the multiplexer filter. This method increments
    ///          the reference count on the <b>IBaseFilter</b> interface so you must decrement the reference count by using
    ///          the <b>Release</b> method on this parameter when done using the filter.
    ///    ppSink = Address of a pointer to an IFileSinkFilter interface representing the file writer. This method increments the
    ///             reference count on the IFileSinkFilter interface so you must decrement the reference count using
    ///             <b>Release</b> when done using the filter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid argument. Audio-Video Interleaved (AVI) is the only supported output format. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Out of memory. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected
    ///    error occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>NOERROR</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Instance of
    ///    the AVI multiplexer filter was successfully created. </td> </tr> </table>
    ///    
    HRESULT SetOutputFileName(const(GUID)* pType, ushort* lpstrFile, IBaseFilter* ppf, IFileSinkFilter* ppSink);
    ///<div class="alert"><b>Note</b> The <b>ICaptureGraphBuilder</b> interface is deprecated. Use ICaptureGraphBuilder2
    ///instead.</div> <div> </div> Looks for the specified interface on the filter, upstream and downstream from the
    ///filter, and, optionally, only on the output pin of the given category.
    ///Params:
    ///    pCategory = Pointer to a GUID specifying the output pin category. See Pin Property Set for a list of all pin categories.
    ///                <b>NULL</b> indicates search all the output pins regardless of category.
    ///    pf = Pointer to the IBaseFilter interface of the filter.
    ///    riid = Reference ID of the desired interface.
    ///    ppint = Address of a void pointer. If the interface was found, this method initializes <i>ppint</i> so that it
    ///            contains the address of a pointer to the found interface. Call the <b>Release</b> method to decrement the
    ///            reference count when you're done with the interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT FindInterface(const(GUID)* pCategory, IBaseFilter pf, const(GUID)* riid, void** ppint);
    ///<div class="alert"><b>Note</b> The <b>ICaptureGraphBuilder</b> interface is deprecated. Use ICaptureGraphBuilder2
    ///instead.</div> <div> </div> Connects a source filter's pin, of an optionally specified category, to the rendering
    ///filter, and optionally through another filter.
    ///Params:
    ///    pCategory = Pointer to a GUID specifying which output pin of the source filter to connect. See Pin Property Set for a
    ///                list of all pin categories. <b>NULL</b> indicates render the only output pin, regardless of category.
    ///    pSource = Pointer to an IBaseFilter or an IPin interface representing either the source filter or an output pin. Source
    ///              filters are typically a file source filter, such as an AVI file source filter or a capture filter.
    ///    pfCompressor = Pointer to an IBaseFilter interface representing the optional compression filter.
    ///    pfRenderer = Pointer to an IBaseFilter interface representing the renderer. You can use the <i>ppf</i> (multiplexer)
    ///                 parameter from ICaptureGraphBuilder::SetOutputFileName to supply this value.
    ///Returns:
    ///    Returns VFW_S_NOPREVIEWPIN if the capture filter has a capture pin but no preview pin, and you call
    ///    <code>RenderStream</code> with the &amp;PIN_CATEGORY_PREVIEW category on the capture pin. In this case,
    ///    <code>RenderStream</code> will render the preview pin of the Smart Tee filter. For more information, see
    ///    Remarks.
    ///    
    HRESULT RenderStream(const(GUID)* pCategory, IUnknown pSource, IBaseFilter pfCompressor, 
                         IBaseFilter pfRenderer);
    ///<div class="alert"><b>Note</b> The <b>ICaptureGraphBuilder</b> interface is deprecated. Use ICaptureGraphBuilder2
    ///instead.</div> <div> </div> Sends stream control messages to the pin of the specified category on one or more
    ///capture filters in a graph.
    ///Params:
    ///    pCategory = Pointer to a <b>GUID</b> specifying the output pin category. See Pin Property Set for a list of all pin
    ///                categories. This value cannot be <b>NULL</b>.
    ///    pFilter = Pointer to an IBaseFilter interface on the filter to control. Specifying <b>NULL</b> controls all capture
    ///              filters in the graph. You will get one notification for each capture filter.
    ///    pstart = Pointer to the start time for capture. <b>NULL</b> means start now. <b>MAX_TIME</b> means cancel previous
    ///             request, or take no action if there is no previous request.
    ///    pstop = Pointer to the stop time for capture. <b>NULL</b> means stop now. <b>MAX_TIME</b> means cancel previous
    ///            request, or take no action if there is no previous request.
    ///    wStartCookie = Specifies a particular value to be sent when the start occurs.
    ///    wStopCookie = Specifies a particular value to be sent when the stop occurs.
    ///Returns:
    ///    Returns S_FALSE if the stop notification is sent before the last sample sent by the capture filter is
    ///    rendered, otherwise returns S_OK. If this method returns S_FALSE, the application might want to wait before
    ///    stopping the filter graph to allow all samples to pass through the graph and be rendered. Otherwise, samples
    ///    might be lost. If there are no pins matching the description you provide, or if stream control cannot be
    ///    supported on all of the indicated pins, this function will return a failure code.
    ///    
    HRESULT ControlStream(const(GUID)* pCategory, IBaseFilter pFilter, long* pstart, long* pstop, 
                          ushort wStartCookie, ushort wStopCookie);
    ///<div class="alert"><b>Note</b> The <b>ICaptureGraphBuilder</b> interface is deprecated. Use ICaptureGraphBuilder2
    ///instead.</div> <div> </div> Preallocates a capture file to a specified size.
    ///Params:
    ///    lpstr = Pointer to a wide-character string containing the name of the file to create or resize.
    ///    dwlSize = Size, in bytes, of the file to be allocated.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT AllocCapFile(ushort* lpstr, ulong dwlSize);
    ///<div class="alert"><b>Note</b> The <b>ICaptureGraphBuilder</b> interface is deprecated. Use ICaptureGraphBuilder2
    ///instead.</div> <div> </div> Copies the valid media data from the preallocated capture file.
    ///Params:
    ///    lpwstrOld = Pointer to a Unicode™ string containing the source file name.
    ///    lpwstrNew = Pointer to a Unicode string containing the destination file name. Valid data is copied to this file.
    ///    fAllowEscAbort = Value indicating whether pressing the ESC key will cancel the copy operation. <b>TRUE</b> indicates that it
    ///                     will; <b>FALSE</b> indicates that this method will ignore that keystroke.
    ///    pCallback = Optional pointer to an IAMCopyCaptureFileProgress show the progress (percentage complete) of the copy
    ///                operation.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT CopyCaptureFile(ushort* lpwstrOld, ushort* lpwstrNew, int fAllowEscAbort, 
                            IAMCopyCaptureFileProgress pCallback);
}

///The <code>IAMCopyCaptureFileProgress</code> interface is a callback interface used by the
///ICaptureGraphBuilder2::CopyCaptureFile method. Because the <b>CopyCaptureFile</b> method can take a long time to
///complete, an application can implement this interface to receive periodic notifications about the progress of the
///copy operation. If the application does not need to receive this information, there is no need to implement the
///interface.
@GUID("670D1D20-A068-11D0-B3F0-00AA003761C5")
interface IAMCopyCaptureFileProgress : IUnknown
{
    ///The <code>Progress</code> method is called periodically by the ICaptureGraphBuilder2::CopyCaptureFile method
    ///while it copies the file.
    ///Params:
    ///    iProgress = Specifies the percentage of the copy operation that has completed, as a value between 0 and 100.
    ///Returns:
    ///    Returns S_OK or an <b>HRESULT</b> error code.
    ///    
    HRESULT Progress(int iProgress);
}

///The <code>ICaptureGraphBuilder2</code> interface builds capture graphs and other custom filter graphs. The Capture
///Graph Builder object implements this interface. <div class="alert"><b>Note</b> By default, the
///<code>ICaptureGraphBuilder2</code> interface does not use the Video Mixing Renderer (VMR), Enhanced Video Renderer
///(EVR) or Video Port Manager filters.</div> <div> </div>
@GUID("93E5A4E0-2D50-11D2-ABFA-00A0C9C6E38D")
interface ICaptureGraphBuilder2 : IUnknown
{
    ///The <code>SetFiltergraph</code> method specifies a filter graph for the capture graph builder to use.
    ///Params:
    ///    pfg = Pointer to the filter graph's IGraphBuilder interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td>
    ///    <td width="60%"> Unexpected error. </td> </tr> </table>
    ///    
    HRESULT SetFiltergraph(IGraphBuilder pfg);
    ///The <code>GetFiltergraph</code> method retrieves the filter graph that the capture graph builder is using.
    ///Params:
    ///    ppfg = Receives an IGraphBuilder interface pointer.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> No filter
    ///    graph. </td> </tr> </table>
    ///    
    HRESULT GetFiltergraph(IGraphBuilder* ppfg);
    ///The <code>SetOutputFileName</code> method creates the file writing section of the filter graph.
    ///Params:
    ///    pType = Pointer to a <b>GUID</b> that represents either the media subtype of the output or the class identifier
    ///            (CLSID) of a multiplexer filter or file writer filter. If you specify a media subtype, it must be one of the
    ///            following: <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>MEDIASUBTYPE_Avi</td>
    ///            <td>Audio-Video Interleaved (AVI)</td> </tr> <tr> <td>MEDIASUBTYPE_Asf</td> <td>Advanced Systems Format
    ///            (ASF)</td> </tr> </table>
    ///    lpstrFile = Pointer to a wide-character string that contains the output file name.
    ///    ppf = Address of a pointer that receives the multiplexer's IBaseFilter interface.
    ///    ppSink = Address of a pointer that receives the file writer's IFileSinkFilter interface. Can be <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b>
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT SetOutputFileName(const(GUID)* pType, ushort* lpstrFile, IBaseFilter* ppf, IFileSinkFilter* ppSink);
    ///The <code>FindInterface</code> method searches the graph for a specified interface, starting from a specified
    ///filter. You can restrict the search to a section of the graph upstream or downstream of the filter, or restrict
    ///it to a particular pin category or media type.
    ///Params:
    ///    pCategory = A pointer to a GUID that specifies the search criteria. See Remarks for more information. The following
    ///                values are possible: <ul> <li>&amp;LOOK_UPSTREAM_ONLY.</li> <li>&amp;LOOK_DOWNSTREAM_ONLY.</li> <li>One of
    ///                the pin categories listed in Pin Property Set. </li> <li><b>NULL</b></li> </ul> See Remarks for more
    ///                information.
    ///    pType = Pointer to a GUID that specifies the major media type of an output pin, or <b>NULL</b>.
    ///    pf = Pointer to the IBaseFilter interface of the filter. The method begins searching from this filter.
    ///    riid = Interface identifier (IID) of the interface to locate.
    ///    ppint = Address of a variable that receives the interface pointer. Be sure to release the retrieved interface pointer
    ///            when you are done with the interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> No such
    ///    interface supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT FindInterface(const(GUID)* pCategory, const(GUID)* pType, IBaseFilter pf, const(GUID)* riid, 
                          void** ppint);
    ///The <code>RenderStream</code> method connects an output pin on a source filter to a sink filter, optionally
    ///through an intermediate filter.
    ///Params:
    ///    pCategory = A pointer to a GUID that specifies one of the pin categories listed in Pin Property Set. To match any pin,
    ///                regardless of category, set this parameter to <b>NULL</b>. Typical values include the following. <ul>
    ///                <li>PIN_CATEGORY_CAPTURE</li> <li>PIN_CATEGORY_PREVIEW</li> <li>PIN_CATEGORY_CC</li> </ul>
    ///    pType = Pointer to a major-type GUID that specifies the media type of the output pin; or <b>NULL</b> to use any pin,
    ///            regardless of media type. For a list of possible values, see Major Types.
    ///    pSource = Specifies a pointer to the starting filter for the connection, or to an output pin.
    ///    pfCompressor = Pointer to the IBaseFilter interface of an intermediate filter, such as a compression filter. Can be
    ///                   <b>NULL</b>.
    ///    pfRenderer = Pointer to the <b>IBaseFilter</b> interface of a sink filter, such as a renderer or mux filter. If the value
    ///                 is <b>NULL</b>, the method uses a default renderer (see Remarks).
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible return values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_S_NOPREVIEWPIN</b></dt> </dl> </td>
    ///    <td width="60%"> Preview was rendered through the Smart Tee Filter. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_IN_GRAPH</b></dt> </dl> </td> <td width="60%"> A filter is not in the
    ///    filter graph. This error can occur if you did not call <b>AddFilter</b> to add <i>pSource</i>,
    ///    <i>pIntermediate</i>, or <i>pSink</i> to the graph. It can also occur if you did not call
    ///    <b>SetFiltergraph</b> to connect your graph to the Capture Graph Builder; in this case, the Capture Graph
    ///    Builder object automatically creates its own filter graph. See About the Capture Graph Builder. </td> </tr>
    ///    </table>
    ///    
    HRESULT RenderStream(const(GUID)* pCategory, const(GUID)* pType, IUnknown pSource, IBaseFilter pfCompressor, 
                         IBaseFilter pfRenderer);
    ///The <code>ControlStream</code> method sets the start and stop times for one or more streams of captured data.
    ///Params:
    ///    pCategory = A pointer to a GUID that specifies one of the pin categories listed in Pin Property Set. The value of this
    ///                parameter cannot be <b>NULL</b>.
    ///    pType = Pointer to a major type GUID that specifies the media type, or <b>NULL</b>. If this parameter is <b>NULL</b>,
    ///            set the <i>pFilter</i> parameter to <b>NULL</b> as well. Otherwise, you might control the wrong pin and get
    ///            unpredictable results.
    ///    pFilter = Pointer to an IBaseFilter interface that specifies which filter to control. To control all the capture
    ///              filters in the graph, set this parameter to <b>NULL</b>.
    ///    pstart = Pointer to a variable that contains the start time. If the value is <b>MAXLONGLONG</b> (0x7FFFFFFFFFFFFFFF),
    ///             the method cancels the previous start request. If the value is <b>NULL</b>, the pin starts immediately when
    ///             the graph runs.
    ///    pstop = Pointer to a variable that contains the stop time. If the value is <b>MAXLONGLONG</b>, the method cancels any
    ///            previous stop request. If the value is <b>NULL</b>, the pin stops immediately.
    ///    wStartCookie = Value that is sent as the second parameter of the EC_STREAM_CONTROL_STARTED event notification. See Remarks
    ///                   for more information.
    ///    wStopCookie = Value that is sent as the second parameter of the EC_STREAM_CONTROL_STOPPED event notification. See Remarks
    ///                  for more information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> At
    ///    least one downstream renderer will not send a stop notification. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Could not find a matching pin, or the pin did not support
    ///    stream control. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT ControlStream(const(GUID)* pCategory, const(GUID)* pType, IBaseFilter pFilter, long* pstart, 
                          long* pstop, ushort wStartCookie, ushort wStopCookie);
    ///The <code>AllocCapFile</code> method preallocates a capture file to a specified size. For best results, always
    ///capture to a defragmented, preallocated capture file that is larger than the size of the capture data.
    ///Params:
    ///    lpstr = Pointer to a wide-character string that contains the name of the file to create or resize.
    ///    dwlSize = Size of the file to allocate, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AllocCapFile(ushort* lpstr, ulong dwlSize);
    ///The <code>CopyCaptureFile</code> method copies the valid media data from a capture file.
    ///Params:
    ///    lpwstrOld = Pointer to a wide-character string that contains the source file name.
    ///    lpwstrNew = Pointer to a wide-character string that contains the destination file name. Valid data is copied to this
    ///                file.
    ///    fAllowEscAbort = Boolean value that specifies whether pressing the ESC key cancels the copy operation. If the value is
    ///                     <b>TRUE</b> and the user presses the ESC key, the operation halts. If the value is <b>FALSE</b>, the method
    ///                     ignores the ESC key.
    ///    pCallback = Pointer to an IAMCopyCaptureFileProgress interface to display progress information, or <b>NULL</b>. See
    ///                Remarks for more information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    User canceled the operation before it completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Could not open the source file or destination file. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td>
    ///    </tr> </table>
    ///    
    HRESULT CopyCaptureFile(ushort* lpwstrOld, ushort* lpwstrNew, int fAllowEscAbort, 
                            IAMCopyCaptureFileProgress pCallback);
    ///The <code>FindPin</code> method retrieves a particular pin on a filter, or determines whether a given pin matches
    ///the specified criteria.
    ///Params:
    ///    pSource = Pointer to an interface on a filter, or to an interface on a pin.
    ///    pindir = Member of the [PIN_DIRECTION](/windows/desktop/api/strmif/ne-strmif-pin_direction) enumeration that specifies
    ///             the pin direction (input or output).
    ///    pCategory = A pointer to a GUID that specifies one of the pin categories listed in Pin Property Set. To match any pin,
    ///                regardless of category, set this parameter to <b>NULL</b>.
    ///    pType = Pointer to a major type GUID that specifies the media type. Use <b>NULL</b> to match any media type.
    ///    fUnconnected = Boolean value that specifies whether the pin must be unconnected. If <b>TRUE</b>, the pin must be
    ///                   unconnected. If <b>FALSE</b>, the pin can be connected or unconnected.
    ///    num = Zero-based index of the pin to retrieve, from the set of matching pins. If <i>pSource</i> is a pointer to a
    ///          filter, and more than one pin matches the search criteria, this parameter specifies which pin to retrieve. If
    ///          <i>pSource</i> is a pointer to a pin, this parameter is ignored.
    ///    ppPin = Address of a pointer to receive the IPin interface of the matching pin.
    ///Returns:
    ///    Returns S_OK if a matching pin is found, or E_FAIL otherwise.
    ///    
    HRESULT FindPin(IUnknown pSource, PIN_DIRECTION pindir, const(GUID)* pCategory, const(GUID)* pType, 
                    BOOL fUnconnected, int num, IPin* ppPin);
}

///The <code>IFilterGraph2</code> interface extends the IFilterGraph and IGraphBuilder interfaces, which contain methods
///for building filter graphs. The Filter Graph Manager implements this interface. Applications can use it when building
///graphs, to take advantage of the additional methods it provides.
@GUID("36B73882-C2C8-11CF-8B46-00805F6CEF60")
interface IFilterGraph2 : IGraphBuilder
{
    ///The <code>AddSourceFilterForMoniker</code> method creates a source filter from an IMoniker pointer and adds the
    ///filter to the graph. For example, you can obtain a moniker for a system device, such as a video capture device,
    ///and add a video capture filter for that device. (For more information about system device monikers, see the
    ///ICreateDevEnum interface.)
    ///Params:
    ///    pMoniker = Pointer to the IMoniker interface.
    ///    pCtx = Pointer to an IBindCtx bind context interface.
    ///    lpcwstrFilterName = Name for the filter.
    ///    ppFilter = Receives a pointer to the source filter's IBaseFilter pointer. The caller must release the interface.
    ///Returns:
    ///    Returns and <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_S_DUPLICATE_NAME</b></dt> </dl> </td> <td
    ///    width="60%"> Success; but the specified name was a duplicate, so the Filter Graph Manager modified the name.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient
    ///    memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DUPLICATE_NAME</b></dt> </dl> </td> <td
    ///    width="60%"> Failed to add a filter with a duplicate name. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_CANNOT_LOAD_SOURCE_FILTER</b></dt> </dl> </td> <td width="60%"> The source filter for could not
    ///    be loaded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_UNKNOWN_FILE_TYPE</b></dt> </dl> </td> <td
    ///    width="60%"> The media type of this file is not recognized. </td> </tr> </table>
    ///    
    HRESULT AddSourceFilterForMoniker(IMoniker pMoniker, IBindCtx pCtx, const(wchar)* lpcwstrFilterName, 
                                      IBaseFilter* ppFilter);
    ///The <code>ReconnectEx</code> method breaks the existing pin connection and reconnects it to the same pin, using a
    ///specified media type. Applications should not call this method. It is called by filters during the graph building
    ///process.
    ///Params:
    ///    ppin = Pointer to the pin to disconnect and reconnect.
    ///    pmt = Pointer to the media type to reconnect with. Specify <b>NULL</b> to use the existing media type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Pin was
    ///    not connected. No error. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_STOPPED</b></dt> </dl> </td> <td width="60%"> The filter is not stopped, but it does not
    ///    support reconnection while in a running state. </td> </tr> </table>
    ///    
    HRESULT ReconnectEx(IPin ppin, const(AM_MEDIA_TYPE)* pmt);
    ///The <code>RenderEx</code> method renders an output pin, with an option to use existing renderers only.
    ///Params:
    ///    pPinOut = Pointer to the IPin interface of the output pin.
    ///    dwFlags = Flag that specifies how to render the pin. If the value is AM_RENDEREX_RENDERTOEXISTINGRENDERERS, the method
    ///              attempts to use renderers already in the filter graph. It will not add new renderers to the graph. (It will
    ///              add intermediate transform filters, if needed.) For the method to succeed, the graph must contain the
    ///              appropriate renderers, and they must have unconnected input pins. If the value is zero, the method behaves
    ///              identically to the IGraphBuilder::Render method.
    ///    pvContext = Reserved. Must be <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b>.
    ///    
    HRESULT RenderEx(IPin pPinOut, uint dwFlags, uint* pvContext);
}

///The <code>IFilterGraph3</code> interface extends the IFilterGraph2 interface, which contains methods for building
///filter graphs. The Filter Graph Manager implements this interface. Applications can use it when building graphs, to
///take advantage of the additional methods it provides.
@GUID("AAF38154-B80B-422F-91E6-B66467509A07")
interface IFilterGraph3 : IFilterGraph2
{
    ///The <code>SetSyncSourceEx</code> method establishes two reference clocks for the filter graph: a primary clock
    ///that is used by most of the filters, and a secondary clock that is used only by one specified filter.
    ///Params:
    ///    pClockForMostOfFilterGraph = Pointer to the IReferenceClock interface of the main reference clock. Every filter in the graph uses this
    ///                                 clock, except for the filter specified by the <i>pFilter</i> parameter.
    ///    pClockForFilter = Pointer to the <b>IReferenceClock</b> interface of the secondary clock. The filter specified by the
    ///                      <i>pFilter</i> parameter uses this clock.
    ///    pFilter = Pointer to the IBaseFilter interface of a filter in the graph. This filter uses the secondary reference
    ///              clock.
    ///Returns:
    ///    Returns and <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_STOPPED</b></dt> </dl> </td> <td
    ///    width="60%"> The filter graph is not stopped. </td> </tr> </table>
    ///    
    HRESULT SetSyncSourceEx(IReferenceClock pClockForMostOfFilterGraph, IReferenceClock pClockForFilter, 
                            IBaseFilter pFilter);
}

///The <code>IStreamBuilder</code> interface enables an output pin to notify the filter graph manager that the pin
///itself will build the downstream section of the filter graph. Output pins with special connection needs can implement
///this interface to override the default pin connection process used by the filter graph manager.
@GUID("56A868BF-0AD4-11CE-B03A-0020AF0BA770")
interface IStreamBuilder : IUnknown
{
    ///The <code>Render</code> method completes rendering of the stream originating with this pin. This can involve
    ///adding filters to the filter graph and connecting them.
    ///Params:
    ///    ppinOut = Pointer to the IPin interface of this pin.
    ///    pGraph = Pointer to the IGraphBuilder interface of the Filter Graph Manager.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. A return code of S_OK indicates that the stream was successfully rendered.
    ///    
    HRESULT Render(IPin ppinOut, IGraphBuilder pGraph);
    ///The <code>Backout</code> method undoes steps taken in the IStreamBuilder::Render method. This includes
    ///disconnecting and removing any filters that were added inside <b>Render</b>.
    ///Params:
    ///    ppinOut = Pointer to the IPin interface of this pin.
    ///    pGraph = Pointer to the IGraphBuilder interface of the Filter Graph Manager.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. A return code of S_OK indicates to the graph builder that the disconnect was
    ///    successful.
    ///    
    HRESULT Backout(IPin ppinOut, IGraphBuilder pGraph);
}

///The <code>IAsyncReader</code> interface performs an asynchronous data request on a filter. This interface is exposed
///by output pins that perform asynchronous read operations. The interface is used by the input pin on the downstream
///filter. Applications do not use this interface. The Async File Source filter exposes this interface on its output
///pin. <b>Filter developers</b>: Implement this interface if your output pin delivers data in the form of a byte stream
///(MEDIATYPE_Stream) and supports the pull model. During the connection process, check whether the downstream pin
///queries for the <code>IAsyncReader</code> interface. If it does not, your pin should either fail the connection or
///establish some other transport. (If your pin derives from CBasePin, perform this check in the CBasePin::CheckConnect
///method.) For more information about using this interface, see the following topics: <ul> <li> Negotiating Allocators
///</li> <li> Data Flow for Filter Developers </li> <li> CPullPin Class </li> </ul>
@GUID("56A868AA-0AD4-11CE-B03A-0020AF0BA770")
interface IAsyncReader : IUnknown
{
    ///The <code>RequestAllocator</code> method requests an allocator during the pin connection.
    ///Params:
    ///    pPreferred = Pointer to the IMemAllocator interface on the input pin's preferred allocator, or <b>NULL</b>.
    ///    pProps = Specifies the address of an
    ///             [ALLOCATOR_PROPERTIES](/windows/desktop/api/strmif/ns-strmif-allocator_properties) structure, allocated by
    ///             the caller. The caller should fill in any allocator properties that the input pin requires, and set the
    ///             remaining members to zero.
    ///    ppActual = Address of a variable that receives an <b>IMemAllocator</b> interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure to initialize an allocator. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_BADALIGN</b></dt>
    ///    </dl> </td> <td width="60%"> An invalid alignment was specified. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Allocator was returned. </td> </tr> </table>
    ///    
    HRESULT RequestAllocator(IMemAllocator pPreferred, ALLOCATOR_PROPERTIES* pProps, IMemAllocator* ppActual);
    ///The <code>Request</code> method queues an asynchronous request for data.
    ///Params:
    ///    pSample = Pointer to the IMediaSample interface of a media sample provided by the caller.
    ///    dwUser = Specifies an arbitrary value that is returned when the request completes.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_BADALIGN</b></dt> </dl> </td> <td width="60%">
    ///    The buffer is not aligned correctly. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_SAMPLE_TIME_NOT_SET</b></dt> </dl> </td> <td width="60%"> The sample was not time stamped. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The pin is
    ///    flushing. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_HANDLE_EOF)</b></dt> </dl>
    ///    </td> <td width="60%"> The requested start position is past the end of the file. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    </table>
    ///    
    HRESULT Request(IMediaSample pSample, size_t dwUser);
    ///The <code>WaitForNext</code> method waits for the next pending read request to complete.
    ///Params:
    ///    dwTimeout = Specifies a time-out in milliseconds. Use the value INFINITE to wait indefinitely
    ///    ppSample = Address of a variable that receives an IMediaSample interface pointer.
    ///    pdwUser = Pointer to a variable that receives the value of the <i>dwUser</i> parameter specified in the
    ///              IAsyncReader::Request method.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_TIMEOUT</b></dt> </dl> </td> <td
    ///    width="60%"> The time-out expired, or the pin is flushing. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The pin is flushing. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> A read error occurred. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Reached the end of the file; retrieved
    ///    fewer bytes than requested. </td> </tr> </table>
    ///    
    HRESULT WaitForNext(uint dwTimeout, IMediaSample* ppSample, size_t* pdwUser);
    ///The <code>SyncReadAligned</code> method performs a synchronous read. The method blocks until the request is
    ///completed. The file positions and the buffer address must be aligned; check the allocator properties for the
    ///required alignment.
    ///Params:
    ///    pSample = Pointer to the IMediaSample interface of a media sample provided by the caller.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_BADALIGN</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid alignment. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td>
    ///    <td width="60%"> Retrieved fewer bytes than requested. (Probably the end of the file was reached.) </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr>
    ///    </table>
    ///    
    HRESULT SyncReadAligned(IMediaSample pSample);
    ///The <code>SyncRead</code> method performs a synchronous read. The method blocks until the request is completed.
    ///The file positions and the buffer address do not have to be aligned. If the request is not aligned, the method
    ///performs a buffered read operation.
    ///Params:
    ///    llPosition = Specifies the byte offset at which to begin reading. The method fails if this value is beyond the end of the
    ///                 file.
    ///    lLength = Specifies the number of bytes to read.
    ///    pBuffer = Pointer to a buffer that receives the data.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Retrieved fewer bytes than requested. (Probably the end of the file was reached.) </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SyncRead(long llPosition, int lLength, char* pBuffer);
    ///The <code>Length</code> method retrieves the total length of the stream.
    ///Params:
    ///    pTotal = Pointer to a variable that receives the length of the stream, in bytes.
    ///    pAvailable = Pointer to a variable that receives the portion of the stream that is currently available, in bytes.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_S_ESTIMATED</b></dt> </dl> </td> <td width="60%">
    ///    The returned values are estimates; for example, if the file is being read over a network. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The file is not open or no
    ///    longer exists. </td> </tr> </table>
    ///    
    HRESULT Length(long* pTotal, long* pAvailable);
    ///The <code>BeginFlush</code> method begins a flush operation.
    ///Returns:
    ///    Returns S_OK if successful, or S_FALSE otherwise.
    ///    
    HRESULT BeginFlush();
    ///The <code>EndFlush</code> method ends a flush operation.
    ///Returns:
    ///    Returns S_OK if successful, or S_FALSE otherwise.
    ///    
    HRESULT EndFlush();
}

///The <code>IGraphVersion</code> interface is implemented on the Filter Graph Manager to provide a way for plug-in
///distributors and applications to know when the graph has changed. If the graph has changed, and the application or
///plug-in distributor has an interface on a particular filter or pin, it should requery the graph to see if its
///pointers are still valid, or if there are new ones it should use.
@GUID("56A868AB-0AD4-11CE-B03A-0020AF0BA770")
interface IGraphVersion : IUnknown
{
    ///The <code>QueryVersion</code> method retrieves the current graph version number.
    ///Params:
    ///    pVersion = Pointer to the current graph version.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation. <b>HRESULT</b> can be one of the
    ///    following standard constants, or other values not listed. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method isn't supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK or
    ///    NOERROR</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT QueryVersion(int* pVersion);
}

///The <code>IResourceConsumer</code> interface provides a callback mechanism for objects using the IResourceManager
///interface. An object must implement <code>IResourceConsumer</code> if it uses the IResourceManager interface to
///request resources from the filter graph manager. The filter graph manager calls methods on
///<code>IResourceConsumer</code> to notify the object when a resource becomes available, or when the object should
///release a resource that it acquired. Applications typically do not use or implement this interface.
@GUID("56A868AD-0AD4-11CE-B03A-0020AF0BA770")
interface IResourceConsumer : IUnknown
{
    ///The <code>AcquireResource</code> method notifies the resource consumer that a resource might be acquired.
    ///Params:
    ///    idResource = Resource identifier of the resource to be acquired.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Consumer has successfully acquired the resource. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Consumer has not acquired the resource but will use
    ///    IResourceManager::NotifyAcquire when it does. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_S_RESOURCE_NOT_NEEDED</b></dt> </dl> </td> <td width="60%"> Consumer no longer needs the resource.
    ///    </td> </tr> </table> The method may return some other error code, if the consumer fails to acquire the
    ///    resource.
    ///    
    HRESULT AcquireResource(int idResource);
    ///The <code>ReleaseResource</code> method requests the resource consumer to release the specified resource.
    ///Params:
    ///    idResource = Resource identifier to be released.
    ///Returns:
    ///    Returns S_OK if the consumer has released it and requires it again when it becomes available, or S_FALSE if
    ///    the consumer has not released it but will use IResourceManager::NotifyRelease when it does.
    ///    
    HRESULT ReleaseResource(int idResource);
}

///The <code>IResourceManager</code> interface resolves contentions for system resources. The filter graph manager
///exposes this interface. Filters can use this interface to request resources that other objects are likely to use. For
///example, audio renderers use this interface to resolve contentions for the wave-output device, to enable sound to
///follow focus. Applications will typically not use this interface. An object can use this interface to resolve
///possible contentions between existing resources. The object registers the resource with the interface and then
///requests it whenever needed. The object should notify the filter graph manager whenever the user focus changes. The
///filter graph manager can then switch contended resources to the objects that have the focus of the user. An object
///that uses this interface must implement the IResourceConsumer interface. <b>IResourceConsumer</b> provides a callback
///mechanism for the filter graph manager to notify the object when a resource becomes available, or when the object
///should release a resource that it acquired.
@GUID("56A868AC-0AD4-11CE-B03A-0020AF0BA770")
interface IResourceManager : IUnknown
{
    ///The <code>Register</code> method registers a single named resource with the resource manager.
    ///Params:
    ///    pName = Named resource.
    ///    cResource = Number of resources.
    ///    plToken = Pointer to the returned token identifying the resource to be used in additional calls.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation. <b>HRESULT</b> can be one of the
    ///    following standard constants, or other values not listed. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method isn't supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK or
    ///    NOERROR</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT Register(const(wchar)* pName, int cResource, int* plToken);
    ///The <code>RegisterGroup</code> method registers a named resource group with the resource manager.
    ///Params:
    ///    pName = Named resource group.
    ///    cResource = Number of resources in the group.
    ///    palTokens = Pointer to an array of resources in the group.
    ///    plToken = Pointer to the returned group resource identifier.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation. <b>HRESULT</b> can be one of the
    ///    following standard constants, or other values not listed. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method isn't supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK or
    ///    NOERROR</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT RegisterGroup(const(wchar)* pName, int cResource, char* palTokens, int* plToken);
    ///The <code>RequestResource</code> method requests the use of a given registered resource.
    ///Params:
    ///    idResource = Resource token retrieved when the resource was registered.
    ///    pFocusObject = Pointer to the <b>IUnknown</b> interface of a focus object associated with a request (typically the
    ///                   <b>IUnknown</b> interface of the filter).
    ///    pConsumer = Pointer to the IResourceConsumer interface on the object requesting the resource.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Returns S_OK if the requested resource is returned, or S_FALSE if the
    ///    resource is not available, in which case the resource manager will call the requesting object back when the
    ///    resource becomes available. Any other return is an error.
    ///    
    HRESULT RequestResource(int idResource, IUnknown pFocusObject, IResourceConsumer pConsumer);
    ///The <code>NotifyAcquire</code> method notifies the resource manager that an attempt to acquire a resource has
    ///completed.
    ///Params:
    ///    idResource = Token for the registered resource.
    ///    pConsumer = Pointer to the IResourceConsumer interface of the object requesting the resource.
    ///    hr = Value indicating the success of the acquisition; S_OK if the resource was acquired, or an error value if not.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation. <b>HRESULT</b> can be one of the
    ///    following standard constants, or other values not listed. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method isn't supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK or
    ///    NOERROR</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT NotifyAcquire(int idResource, IResourceConsumer pConsumer, HRESULT hr);
    ///The <code>NotifyRelease</code> method notifies the resource manager that IResourceConsumer has released a
    ///resource.
    ///Params:
    ///    idResource = Resource token.
    ///    pConsumer = Pointer to the object releasing the resource.
    ///    bStillWant = Flag that specifies whether the resource is still required. Set to <b>TRUE</b> to indicate that you still
    ///                 want the resource when it is next available, or <b>FALSE</b> if you no longer want the resource.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation. <b>HRESULT</b> can be one of the
    ///    following standard constants, or other values not listed. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method isn't supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK or
    ///    NOERROR</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT NotifyRelease(int idResource, IResourceConsumer pConsumer, BOOL bStillWant);
    ///The <code>CancelRequest</code> method cancels the request for a resource.
    ///Params:
    ///    idResource = Resource identifier of a pending request.
    ///    pConsumer = Pointer to the IResourceConsumer interface that made the request.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation. <b>HRESULT</b> can be one of the
    ///    following standard constants, or other values not listed. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method isn't supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK or
    ///    NOERROR</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT CancelRequest(int idResource, IResourceConsumer pConsumer);
    ///The <code>SetFocus</code> method notifies the resource manager that a specified object has been given the focus
    ///of the user.
    ///Params:
    ///    pFocusObject = Pointer to the object that has been given the user's focus.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation. <b>HRESULT</b> can be one of the
    ///    following standard constants, or other values not listed. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method isn't supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK or
    ///    NOERROR</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetFocus(IUnknown pFocusObject);
    ///The <code>ReleaseFocus</code> method sets the focus object to <b>NULL</b> in the resource manager if the current
    ///focus object is the one specified in this method.
    ///Params:
    ///    pFocusObject = Pointer to the focus object.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation. <b>HRESULT</b> can be one of the
    ///    following standard constants, or other values not listed. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method isn't supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK or
    ///    NOERROR</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT ReleaseFocus(IUnknown pFocusObject);
}

///The <code>IDistributorNotify</code> interface enables a plug-in distributor to be notified when the filter graph
///changes. Applications never use this interface. Implement this interface if you are writing a plug-in distributor
///(PID) and want the PID to receive notifications of control and changes in the composition of filter graphs. The
///Filter Graph Manager queries for this interface on any plug-in distributors that it aggregates. If a PID exposes this
///interface, the Filter Graph Manager notifies the PID of any state changes by calling <b>IDistributorNotify</b>
///methods before calling the equivalent IBaseFilter methods on the filters. The Filter Graph Manager also calls the
///IDistributorNotify::NotifyGraphChange method whenever it adds or removes a filter, or any pin connections change.
///During a call to any <b>IDistributorNotify</b> method, do not hold any critical section that might be held by another
///code path that calls methods on the Filter Graph Manager. Doing so could result in a deadlock.
@GUID("56A868AF-0AD4-11CE-B03A-0020AF0BA770")
interface IDistributorNotify : IUnknown
{
    ///The <code>Stop</code> method is called when the filter graph is entering a stopped state.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Transition is not complete, but no error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT Stop();
    ///The <code>Pause</code> method is called when the filter graph is entering a paused state.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Transition is not complete, but no error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT Pause();
    ///The <code>Run</code> method is called when the filter graph is entering a running state.
    ///Params:
    ///    tStart = Stream-time offset that will be passed to every filter's IMediaFilter::Run method.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT Run(long tStart);
    ///The <code>SetSyncSource</code> method is called when a new clock is registered.
    ///Params:
    ///    pClock = Pointer to the new clock's IReferenceClock interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetSyncSource(IReferenceClock pClock);
    ///The <code>NotifyGraphChange</code> method is called when the set of filters in the filter graph changes or any
    ///pin connections change.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT NotifyGraphChange();
}

///The <code>IAMStreamControl</code> interface controls individual streams on a filter. Pins on some filters expose this
///interface. For example, the AVI Mux Filter supports this interface on its input pins, and the Audio Capture Filter
///and WDM Video Capture Filter support it on their output pins. This interface enables an application to turn streams
///on and off at specified times. For example, an application might turn off an audio stream to mute the audio during
///video preview. Capture applications can use this interface to specify exact start and stop times for capture, and to
///control capture and preview streams independently of each other. To use this interface, call the
///IAMStreamControl::StartAt method to specify when the pin will start delivering data, and the IAMStreamControl::StopAt
///method to specify when it will stop delivering data. Then call IMediaControl::Run on the Filter Graph Manager to run
///the filter graph. All times are relative to when the graph starts running. When you use this interface, be aware of
///the following limitations: <ul> <li>There must be a reference clock in the filter graph.</li> <li>Preview pins on
///capture cards with hardware overlay do not support this interface.</li> <li>If you are capturing audio and video to
///an interleaved AVI file, the AVI Mux filter requires data both streams. If you stop one stream, the filter cannot
///interleave the data. For more information, see IConfigInterleaving Interface.</li> </ul> Depending on the
///application, you might find the ICaptureGraphBuilder2::ControlStream method more convenient, because it supports
///stream control at the graph level, so that you do not have to enumerate individual filters and pins. <b>Filter
///developers</b>: The CBaseStreamControl base class implements this interface.
@GUID("36B73881-C2C8-11CF-8B46-00805F6CEF60")
interface IAMStreamControl : IUnknown
{
    ///The <code>StartAt</code> method informs the pin when to start delivering data.
    ///Params:
    ///    ptStart = Pointer to a REFERENCE_TIME value that specifies when the pin should start delivering data. If the value is
    ///              <b>MAXLONGLONG</b> (0x7FFFFFFFFFFFFFFF), the method cancels the previous start request. If <i>psStart</i> is
    ///              <b>NULL</b>, the pin starts immediately when the graph runs. For preview pins, only the values <b>NULL</b>
    ///              and <b>MAXLONGLONG</b> are valid, because preview pins do not time stamp the samples they deliver.
    ///    dwCookie = Specifies a value to send along with the start notification. See Remarks.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, returns an <b>HRESULT</b> value indicating the
    ///    cause of the failure.
    ///    
    HRESULT StartAt(const(long)* ptStart, uint dwCookie);
    ///The <code>StopAt</code> method informs the pin when to stop delivering data.
    ///Params:
    ///    ptStop = Pointer to a REFERENCE_TIME value that specifies when the pin should stop delivering data. If the value is
    ///             <b>MAXLONGLONG</b> (0x7FFFFFFFFFFFFFFF), the method cancels any previous stop request. If <i>psStop</i> is
    ///             <b>NULL</b>, the pin stops immediately. For preview pins, only the values <b>NULL</b> and <b>MAXLONGLONG</b>
    ///             are valid, because preview pins do not time stamp the samples they deliver.
    ///    bSendExtra = Specifies a Boolean value that indicates whether to send an extra sample after the scheduled stop time. If
    ///                 <b>TRUE</b>, the pin sends one extra sample.
    ///    dwCookie = Specifies a value to send along with the start notification. See Remarks.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, returns an <b>HRESULT</b> value indicating the
    ///    cause of the failure.
    ///    
    HRESULT StopAt(const(long)* ptStop, BOOL bSendExtra, uint dwCookie);
    ///The <code>GetInfo</code> method retrieves information about the current stream-control settings, including the
    ///start and stop times.
    ///Params:
    ///    pInfo = Pointer to an AM_STREAM_INFO structure, allocated by the caller, that receives the current stream-control
    ///            settings.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer value. </td> </tr> </table>
    ///    
    HRESULT GetInfo(AM_STREAM_INFO* pInfo);
}

///The <code>ISeekingPassThru</code> interface creates a helper object that implements seeking for one-input filters.
///Filters can use this interface to implement the IMediaSeeking and IMediaPosition interfaces. For more information,
///see CPosPassThru. Applications do not use this interface.
@GUID("36B73883-C2C8-11CF-8B46-00805F6CEF60")
interface ISeekingPassThru : IUnknown
{
    ///The <code>Init</code> method initializes the seeking helper object.
    ///Params:
    ///    bSupportRendering = Boolean value that specifies whether the filter is a renderer. Use the value <b>TRUE</b> if the filter is a
    ///                        renderer, or <b>FALSE</b> otherwise.
    ///    pPin = Pointer to the IPin interface on the input pin of the filter.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Object was already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Not enough
    ///    memory to create the object. </td> </tr> </table>
    ///    
    HRESULT Init(BOOL bSupportRendering, IPin pPin);
}

///The <b>IAMStreamConfig</b> interface sets the output format on certain capture and compression filters, for both
///audio and video. Applications can use this interface to set format properties, such as the output dimensions and
///frame rate (for video) or the sample rate and number of channels (for audio).
@GUID("C6E13340-30AC-11D0-A18C-00A0C9118956")
interface IAMStreamConfig : IUnknown
{
    ///The <code>SetFormat</code> method sets the output format on the pin.
    ///Params:
    ///    pmt = Pointer to an AM_MEDIA_TYPE structure that specifies the new format.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer value. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> This media type is not valid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The input pin is
    ///    not connected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_STOPPED</b></dt> </dl> </td> <td
    ///    width="60%"> Cannot set the type; the filter is not stopped. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> Cannot set the type; the filter is not
    ///    stopped. </td> </tr> </table>
    ///    
    HRESULT SetFormat(AM_MEDIA_TYPE* pmt);
    ///The <code>GetFormat</code> method retrieves the current or preferred output format.
    ///Params:
    ///    ppmt = Address of a pointer to an AM_MEDIA_TYPE structure.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer value. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The input pin is not connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetFormat(AM_MEDIA_TYPE** ppmt);
    ///The <code>GetNumberOfCapabilities</code> method retrieves the number of format capabilities that this pin
    ///supports.
    ///Params:
    ///    piCount = Pointer to a variable that receives the number of format capabilities.
    ///    piSize = Pointer to a variable that receives the size of the configuration structure in bytes. See Remarks for more
    ///             information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl>
    ///    </td> <td width="60%"> The input pin is not connected. </td> </tr> </table>
    ///    
    HRESULT GetNumberOfCapabilities(int* piCount, int* piSize);
    ///The <b>GetStreamCaps</b> method retrieves a set of format capabilities.
    ///Params:
    ///    iIndex = Specifies the format capability to retrieve, indexed from zero. To determine the number of capabilities that
    ///             the pin supports, call the IAMStreamConfig::GetNumberOfCapabilities method.
    ///    ppmt = Address of a pointer to an AM_MEDIA_TYPE structure. The method allocates the structure and fills it with a
    ///           media type.
    ///    pSCC = Pointer to a byte array allocated by the caller. For video, use the VIDEO_STREAM_CONFIG_CAPS structure (see
    ///           Remarks). For audio, use the AUDIO_STREAM_CONFIG_CAPS structure. To determine the required size of the array,
    ///           call the <b>GetNumberOfCapabilities</b> method. The size is returned in the <i>piSize</i> parameter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Specified index is too high. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid index. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td>
    ///    <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer value. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The input pin is not connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetStreamCaps(int iIndex, AM_MEDIA_TYPE** ppmt, ubyte* pSCC);
}

///The <b>IConfigInterleaving</b> interface controls how the AVI Mux filter interleaves audio and video samples.
///Video-authoring applications that handle capturing should use this interface when they need to control how audio
///samples and video frames will be saved on a disk.
@GUID("BEE3D220-157B-11D0-BD23-00A0C911CE86")
interface IConfigInterleaving : IUnknown
{
    ///The <code>put_Mode</code> method sets how audio samples and video frames are to be written to disk, by specifying
    ///quality of interleaving.
    ///Params:
    ///    mode = Interleaving quality setting specified in the InterleavingMode enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT put_Mode(InterleavingMode mode);
    ///The <code>get_Mode</code> method retrieves the interleaving quality setting.
    ///Params:
    ///    pMode = Receives the interleaving quality, specified as a member of the InterleavingMode enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT get_Mode(InterleavingMode* pMode);
    ///The <b>put_Interleaving</b> method sets the audio preroll time and the frequency of interleaving for an AVI file.
    ///Params:
    ///    prtInterleave = The approximate duration of each interleaved group of audio or video chunks, in 100-nanosecond units. The
    ///                    exact amount of interleaving is also affected by the interleave mode, which is specified by calling
    ///                    IConfigInterleaving::put_Mode.
    ///    prtPreroll = The amount of audio data, in 100-nanosecond units, that is written to the file before the first video frame.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT put_Interleaving(const(long)* prtInterleave, const(long)* prtPreroll);
    ///The <b>get_Interleaving</b> method gets the audio preroll time and the frequency of interleaving for an AVI file.
    ///Params:
    ///    prtInterleave = Receives the approximate duration of each interleaved group of audio or video chunks.
    ///    prtPreroll = Receives the amount of audio data, in 100-nanosecond units, that is written to the file before the first
    ///                 video frame.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT get_Interleaving(long* prtInterleave, long* prtPreroll);
}

///The <code>IConfigAviMux</code> interface configures the AVI Mux filter. Applications can use this interface to set
///the master stream and to create an AVI 1.0 index.
///[IConfigAviMux::GetOutputCompatibilityIndex](/windows/desktop/api/strmif/nf-strmif-iconfigavimux-getoutputcompatibilityindex)
///methods.
@GUID("5ACD6AA0-F482-11CE-8B67-00AA00A3F1A6")
interface IConfigAviMux : IUnknown
{
    ///The <code>SetMasterStream</code> method specifies a stream that will be used to synchronize the other streams in
    ///the file.
    ///Params:
    ///    iStream = Specifies the index of the stream, or –1 to indicate no master stream. The AVI Mux writes one stream for
    ///              each connected input pin. Stream numbers are indexed from zero.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetMasterStream(int iStream);
    ///The <code>GetMasterStream</code> method queries which stream will be used to synchronize the other streams in the
    ///file.
    ///Params:
    ///    pStream = Receives the index of the master stream, or -1 if no master stream was set.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetMasterStream(int* pStream);
    ///The <code>SetOutputCompatibilityIndex</code> method sets the AVI index format.
    ///Params:
    ///    fOldIndex = Specifies one of the following values: <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                <td><b>TRUE</b></td> <td>Create an AVI 1.0 index, as well as an AVI 2.0 index.</td> </tr> <tr>
    ///                <td><b>FALSE</b></td> <td>Create an AVI 2.0 index, but not an AVI 1.0 index.</td> </tr> </table>
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT SetOutputCompatibilityIndex(BOOL fOldIndex);
    ///The <code>GetOutputCompatibilityIndex</code> method retrieves the setting for the AVI index format.
    ///Params:
    ///    pfOldIndex = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                 <td><b>TRUE</b></td> <td>Create an AVI 1.0 index, as well as an AVI 2.0 index.</td> </tr> <tr>
    ///                 <td><b>FALSE</b></td> <td>Create an AVI 2.0 index, but not an AVI 1.0 index.</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetOutputCompatibilityIndex(int* pfOldIndex);
}

///The <b>IAMVideoCompression</b> interface sets and retrieves video compression properties. It is supported by some
///video compression filters, and also by some video capture filters that output compressed video. Filters that support
///this interface expose it through their output pins. An application can use this interface to control how video is
///compressed, including characteristics such as the key-frame rate or the compression quality. A filter that supports
///this interface might not support every method. Use the IAMVideoCompression::GetInfo method to determine which methods
///the filter supports. <div class="alert"><b>Note</b> To use this interface on a capture filter, you might need to
///connect the filter to another filter in the graph.</div> <div> </div>
@GUID("C6E13343-30AC-11D0-A18C-00A0C9118956")
interface IAMVideoCompression : IUnknown
{
    ///The <code>put_KeyFrameRate</code> method sets the key-frame rate.
    ///Params:
    ///    KeyFrameRate = Desired key-frame rate. If the value is negative, the filter will use the default key-frame rate. If the
    ///                   value is zero, only the first frame will be a key frame.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_KeyFrameRate(int KeyFrameRate);
    ///The <code>get_KeyFrameRate</code> method retrieves the current key-frame rate.
    ///Params:
    ///    pKeyFrameRate = Pointer to a variable that receives the current key-frame rate. If the value is negative, the filter will use
    ///                    the default key-frame rate. If the value is zero, only the first frame is a key frame.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_KeyFrameRate(int* pKeyFrameRate);
    ///The <code>put_PFramesPerKeyFrame</code> method sets the rate of predicted (P) frames per key frame.
    ///Params:
    ///    PFramesPerKeyFrame = Specifies the number of P frames per key frame. If the value is negative, the filter will use the default
    ///                         rate.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_PFramesPerKeyFrame(int PFramesPerKeyFrame);
    ///The <code>get_PFramesPerKeyFrame</code> method retrieves the rate of predicted (P) frames per key frame.
    ///Params:
    ///    pPFramesPerKeyFrame = Pointer to a variable that receives the number of P frames per key frame. If the value is negative, the
    ///                          filter will use the default rate.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_PFramesPerKeyFrame(int* pPFramesPerKeyFrame);
    ///The <code>put_Quality</code> method sets the compression quality.
    ///Params:
    ///    Quality = Specifies the quality as a value between 0.0 and 1.0, where 1.0 indicates the best quality and 0.0 indicates
    ///              the worst quality. If the value is negative, the filter will use the default quality.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Quality(double Quality);
    ///The <code>get_Quality</code> method retrieves the current compression quality.
    ///Params:
    ///    pQuality = Pointer to a variable that receives the relative compression quality. The quality is expressed as a value
    ///               between 0.0 and 1.0, where 1.0 indicates the best quality and 0.0 indicates the worst quality. If the value
    ///               is negative, the filter will use the default quality.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Quality(double* pQuality);
    ///The <code>put_WindowSize</code> method sets the number of frames over which the compressor must maintain an
    ///average data rate. For example, assuming a data rate of 100K/sec and a frame rate of 10 frames per second, if the
    ///window size is 1, then every frame will be 10K or less. If the window size is 5, then every five consecutive
    ///frames must average 10K per frame, but individual frames may exceed this size.
    ///Params:
    ///    WindowSize = Specifies the window size, expressed as a number of frames. .
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_WindowSize(ulong WindowSize);
    ///The <code>get_WindowSize</code> method retrieves the number of frames over which the compressor will maintain the
    ///average data rate. For example, assuming a data rate of 100K/sec and a frame rate of 10 frames per second, if the
    ///window size is 1, then every frame will be 10K or less. If the window size is 5, then every five consecutive
    ///frames will average 10K per frame, but individual frames may exceed this size. The default window size is 1.
    ///Params:
    ///    pWindowSize = Pointer to a variable that receives the window size, expressed as a number of frames.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_WindowSize(ulong* pWindowSize);
    ///The <code>GetInfo</code> method retrieves information about the filter's compression properties, including
    ///capabilities and default values.
    ///Params:
    ///    pszVersion = Pointer to a buffer that receives a version string, such as "Version 2.1.0."
    ///    pcbVersion = Receives the size of the version string, in bytes.
    ///    pszDescription = Pointer to a buffer that receives a description string, such as "My Video Compressor."
    ///    pcbDescription = Receives the size of the description string, in bytes.
    ///    pDefaultKeyFrameRate = Receives the default key-frame rate.
    ///    pDefaultPFramesPerKey = Receives the default rate of predicted (P) frames per key frame.
    ///    pDefaultQuality = Receives the default quality.
    ///    pCapabilities = Receives the compression capabilities, as a bitwise combination of zero or more CompressionCaps flags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetInfo(const(wchar)* pszVersion, int* pcbVersion, const(wchar)* pszDescription, int* pcbDescription, 
                    int* pDefaultKeyFrameRate, int* pDefaultPFramesPerKey, double* pDefaultQuality, 
                    int* pCapabilities);
    ///The <code>OverrideKeyFrame</code> method instructs the filter to compress a particular frame as a key frame.
    ///Params:
    ///    FrameNumber = Specifies the frame number. The first frame that the filter delivers is numbered zero.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> </table>
    ///    
    HRESULT OverrideKeyFrame(int FrameNumber);
    ///The <code>OverrideFrameSize</code> method overrides the frame size of a specified frame.
    ///Params:
    ///    FrameNumber = Specifies the frame number. The first frame that the filter delivers is numbered zero.
    ///    Size = Specifies the maximum size of the specified frame, in bytes.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> </table>
    ///    
    HRESULT OverrideFrameSize(int FrameNumber, int Size);
}

///The <code>IAMVfwCaptureDialogs</code> interface displays a dialog box provided by a Video for Windows (VFW) capture
///driver. The VFW Capture filter implements this interface. Applications can use it to display one of the three dialog
///boxes (Source, Format, or Display) provided by VFW capture drivers.
@GUID("D8D715A0-6E5E-11D0-B3F0-00AA003761C5")
interface IAMVfwCaptureDialogs : IUnknown
{
    ///The <code>HasDialog</code> method determines if the specified dialog box exists in the driver.
    ///Params:
    ///    iDialog = Desired dialog box. This is a member of the VfwCaptureDialogs enumeration.
    ///Returns:
    ///    Returns S_OK if the driver contains the dialog box or S_FALSE otherwise.
    ///    
    HRESULT HasDialog(int iDialog);
    ///The <code>ShowDialog</code> method displays the specified VFW dialog box.
    ///Params:
    ///    iDialog = Dialog box to display. This is a member of the VfwCaptureDialogs enumeration.
    ///    hwnd = Handle of the dialog box's parent window.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_CANNOT_CONNECT</b></dt> </dl> </td>
    ///    <td width="60%"> Could not reconnect with the new format. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_STOPPED</b></dt> </dl> </td> <td width="60%"> The filter graph is not stopped. </td> </tr>
    ///    </table>
    ///    
    HRESULT ShowDialog(int iDialog, HWND hwnd);
    ///The <code>SendDriverMessage</code> method sends a driver-specific message.
    ///Params:
    ///    iDialog = Handle of the driver dialog box. This is a member of the VfwCaptureDialogs enumeration.
    ///    uMsg = Message to send to the driver.
    ///    dw1 = Message data.
    ///    dw2 = Message data.
    ///Returns:
    ///    Return value varies depending on the implementation within each driver.
    ///    
    HRESULT SendDriverMessage(int iDialog, int uMsg, int dw1, int dw2);
}

///The <code>IAMVfwCompressDialogs</code> interface displays a dialog box provided by a Video for Windows (VFW) codec.
///The AVI Compressor filter implements this interface. Applications can use it to display one of the dialog boxes
///(Configure or About) provided by VFW codecs, and to set and retrieve compressor status.
@GUID("D8D715A3-6E5E-11D0-B3F0-00AA003761C5")
interface IAMVfwCompressDialogs : IUnknown
{
    ///The <code>ShowDialog</code> method displays the specified dialog box.
    ///Params:
    ///    iDialog = Dialog box to display. This is a member of the VfwCompressDialogs enumeration.
    ///    hwnd = Handle of the dialog box's parent window.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT ShowDialog(int iDialog, HWND hwnd);
    ///The <code>GetState</code> method retrieves the current configuration settings for the VCM codec currently being
    ///used.
    ///Params:
    ///    pState = State of the VCM codec.
    ///    pcbState = Pointer to the size of the state.
    ///Returns:
    ///    Return value varies depending on the implementation within each driver.
    ///    
    HRESULT GetState(char* pState, int* pcbState);
    ///The <code>SetState</code> method sets configuration for the VCM codec.
    ///Params:
    ///    pState = State of the VCM codec.
    ///    cbState = Size of the state.
    ///Returns:
    ///    Return value varies depending on the implementation within each driver.
    ///    
    HRESULT SetState(char* pState, int cbState);
    ///The <code>SendDriverMessage</code> method sends a driver-specific message.
    ///Params:
    ///    uMsg = Message to send to the driver.
    ///    dw1 = Message data.
    ///    dw2 = Message data.
    ///Returns:
    ///    Return value varies depending on the implementation within each driver.
    ///    
    HRESULT SendDriverMessage(int uMsg, int dw1, int dw2);
}

///The <b>IAMDroppedFrames</b> interface retrieves performance information from a video capture filter, including how
///many frames were dropped and how many were delivered. Applications can use this interface to determine capture
///performance at run-time.
@GUID("C6E13344-30AC-11D0-A18C-00A0C9118956")
interface IAMDroppedFrames : IUnknown
{
    ///The <code>GetNumDropped</code> method retrieves the total number of frames that the filter has dropped since it
    ///started streaming.
    ///Params:
    ///    plDropped = Pointer to a variable that receives the number of dropped frames.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetNumDropped(int* plDropped);
    ///The <code>GetNumNotDropped</code> method retrieves the total number of frames that the filter has delivered since
    ///it started streaming.
    ///Params:
    ///    plNotDropped = Pointer to a variable that receives the number of delivered frames.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetNumNotDropped(int* plNotDropped);
    ///The <code>GetDroppedInfo</code> method retrieves an array of frame numbers that were dropped.
    ///Params:
    ///    lSize = Specifies the size of the array.
    ///    plArray = Pointer to an array of size <i>lSize</i>, allocated by the caller. The method fills the array with the frame
    ///              numbers of the first <i>lSize</i> frames that were dropped, up to a maximum number that is device-depedent.
    ///    plNumCopied = Pointer to a variable that receives the number of items returned in <i>plArray</i>. This number might be less
    ///                  than the value of <i>lSize</i>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid argument; the <i>lSize</i> parameter must by greater than zero. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_PROP_ID_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> Not
    ///    supported by this device. </td> </tr> </table>
    ///    
    HRESULT GetDroppedInfo(int lSize, int* plArray, int* plNumCopied);
    ///The <code>GetAverageFrameSize</code> method retrieves the average size of the frames that the filter has
    ///captured.
    ///Params:
    ///    plAverageSize = Pointer to a variable that receives the average frame size, in bytes, since the filter began streaming.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetAverageFrameSize(int* plAverageSize);
}

///The <code>IAMAudioInputMixer</code> interface controls audio capture properties, such as panning and loudness; and
///enables or disables specific audio inputs, such as the line in or the microphone. The Audio Capture filter exposes
///this interface on each input pin, as well as on the filter itself. The input pins on the Audio Capture Filter
///represent physical hardware connections; they are not connected to other DirectShow filters. The pin name indicates
///the input type; for example, "Line In" or "Microphone." Use the <code>IAMAudioInputMixer</code> interface as follows:
///<ul> <li>To control the settings on a particular input, use the interface on the pin.</li> <li>To set the overall
///properties when multiple inputs are enabled, use the interface on the filter.</li> <li>To enable or disable an input,
///call that pin's IAMAudioInputMixer::put_Enable method.</li> </ul> Some methods on this interface might fail, depening
///on the capabilities of the underlying hardware. <b>Filter Developers</b>: Implement this interface on each input pin
///of an audio capture filter. You can also implement this interface on the audio capture filter itself to control the
///overall audio settings after mixing.
@GUID("54C39221-8380-11D0-B3F0-00AA003761C5")
interface IAMAudioInputMixer : IUnknown
{
    ///The <code>put_Enable</code> method enables or disables an input.
    ///Params:
    ///    fEnable = Specifies whether to enable or disable the input. Use one of the following values. <table> <tr> <th>Value
    ///              </th> <th>Description </th> </tr> <tr> <td><b>TRUE</b></td> <td>Enable the input.</td> </tr> <tr>
    ///              <td><b>FALSE</b></td> <td>Disable the input.</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> </table>
    ///    
    HRESULT put_Enable(BOOL fEnable);
    ///The <code>get_Enable</code> method retrieves whether the input is enabled.
    ///Params:
    ///    pfEnable = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///               <td><b>TRUE</b></td> <td>Input is enabled.</td> </tr> <tr> <td><b>FALSE</b></td> <td>Input is disabled.</td>
    ///               </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Enable(int* pfEnable);
    ///The <code>put_Mono</code> method combines all channels into a mono signal.
    ///Params:
    ///    fMono = Specifies mono or multichannel. Use one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///            </th> </tr> <tr> <td><b>TRUE</b></td> <td>Mono</td> </tr> <tr> <td><b>FALSE</b></td> <td>Multichannel</td>
    ///            </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Error setting mono control. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT put_Mono(BOOL fMono);
    ///The <code>get_Mono</code> method queries whether all channels are combined into a mono signal.
    ///Params:
    ///    pfMono = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///             <td><b>TRUE</b></td> <td>Mono</td> </tr> <tr> <td><b>FALSE</b></td> <td>Multichannel</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_Mono(int* pfMono);
    ///The <code>put_MixLevel</code> method sets the recording level for this input.
    ///Params:
    ///    Level = Specifies the recording level. The following values are possible. <table> <tr> <th>Value </th>
    ///            <th>Description </th> </tr> <tr> <td>0.0 to 1.0</td> <td>Zero indicates that the recording level is off; the
    ///            value 1.0 indicates that the recording level is at full volume. Intermediate values are also allowed.</td>
    ///            </tr> <tr> <td>AMF_AUTOMATICGAIN</td> <td>Enable automatic adjustment of the recording level.</td> </tr>
    ///            </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This
    ///    filter does not support the AMF_AUTOMATICGAIN flag. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT put_MixLevel(double Level);
    ///The <code>get_MixLevel</code> method retrieves the recording level.
    ///Params:
    ///    pLevel = Receives the recording level. The following values are possible. <table> <tr> <th>Value </th> <th>Description
    ///             </th> </tr> <tr> <td>0.0 to 1.0</td> <td>Zero indicates that the recording level is off; the value 1.0
    ///             indicates that the recording level is at full volume. Intermediate values are also allowed.</td> </tr> <tr>
    ///             <td>AMF_AUTOMATICGAIN</td> <td>Automatic adjustment of the recording level is enabled.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_MixLevel(double* pLevel);
    ///The <code>put_Pan</code> method sets the pan level.
    ///Params:
    ///    Pan = Specifies the pan level. Possible values range from –1.0 to 1.0, as follows. <table> <tr> <th>Value </th>
    ///          <th>Description </th> </tr> <tr> <td>-1</td> <td>Full left</td> </tr> <tr> <td>0</td> <td>Center</td> </tr>
    ///          <tr> <td>1</td> <td>Full right</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_Pan(double Pan);
    ///The <code>get_Pan</code> method retrieves the pan level.
    ///Params:
    ///    pPan = Receives the pan level. Possible values range from from –1.0 to 1.0, as follows: <table> <tr> <th>Value
    ///           </th> <th>Description </th> </tr> <tr> <td>-1</td> <td>Full left</td> </tr> <tr> <td>0</td> <td>Center</td>
    ///           </tr> <tr> <td>1</td> <td>Full right</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_Pan(double* pPan);
    ///The <code>put_Loudness</code> method enables or disables the loudness control.
    ///Params:
    ///    fLoudness = Specifies whether loudness is on or off. Use one of the following values. <table> <tr> <th>Value </th>
    ///                <th>Description </th> </tr> <tr> <td><b>TRUE</b></td> <td>Sets loudness on.</td> </tr> <tr>
    ///                <td><b>FALSE</b></td> <td>Sets loudness off.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_Loudness(BOOL fLoudness);
    ///The <code>get_Loudness</code> method retrieves the loudness control setting.
    ///Params:
    ///    pfLoudness = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                 <td><b>TRUE</b></td> <td>Loudness is on.</td> </tr> <tr> <td><b>FALSE</b></td> <td>Loudness is off.</td>
    ///                 </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_Loudness(int* pfLoudness);
    ///The <code>put_Treble</code> method sets the treble equalization for this input.
    ///Params:
    ///    Treble = Specifies the gain, in decibels. A negative value specifies attenuation.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. The following are possible values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Argument is invalid. Must be in range given by IAMAudioInputMixer::get_TrebleRange. </td> </tr> </table>
    ///    
    HRESULT put_Treble(double Treble);
    ///The <code>get_Treble</code> method retrieves the treble equalization.
    ///Params:
    ///    pTreble = Receives the treble gain, in decibels. A negative value indicates attenuation.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_Treble(double* pTreble);
    ///The <code>get_TrebleRange</code> method retrieves the treble range for this input.
    ///Params:
    ///    pRange = Receives the largest valid value for the IAMAudioInputMixer::put_Treble. For example, 6.0 means that any
    ///             value between –6.0 and 6.0 is valid.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_TrebleRange(double* pRange);
    ///The <code>put_Bass</code> method sets the bass equalization.
    ///Params:
    ///    Bass = Specifies the gain, in decibels. A negative value specifies attenuation.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid argument. Must be in range given by IAMAudioInputMixer::get_BassRange. </td> </tr> </table>
    ///    
    HRESULT put_Bass(double Bass);
    ///The <code>get_Bass</code> method retrieves the bass equalization.
    ///Params:
    ///    pBass = Receives the bass gain, in decibels. A negative value indicates attenuation.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_Bass(double* pBass);
    ///The <code>get_BassRange</code> method retrieves the bass range.
    ///Params:
    ///    pRange = Receives the largest valid value for the IAMAudioInputMixer::put_Bass method. For example, 6.0 means that any
    ///             value between –6.0 and 6.0 is valid.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_BassRange(double* pRange);
}

///The <code>IAMBufferNegotiation</code> interface requests the number of buffers for a filter to create and size of
///each buffer. This interface can be exposed by any pin that connects using the IMemInputPin pin interface, but is
///typically exposed on the output pins of capture filters. When two pins connect through <b>IMemInputPin</b>, they
///agree on an allocator object that is responsible for creating buffers. Normally this process is transparent to the
///application, but in some situations the application needs more control. If a pin exposes
///<code>IAMBufferNegotiation</code>, the application can suggest how many buffers to create, the size of the buffers,
///and other properties. If your application performs preview of captured audio, you can specify a smaller buffer size
///to reduce latency. Teleconferencing applications should specify a minimal number of buffers. To use this interface,
///call the <b>SuggestAllocatorProperties</b> method before the pins connect. After the pins connect, call the
///<b>GetAllocatorProperties</b> method to determine whether the pin honored the request. <b>Filter developers</b>:
///Capture filters should always support this interface when possible.
@GUID("56ED71A0-AF5F-11D0-B3F0-00AA003761C5")
interface IAMBufferNegotiation : IUnknown
{
    ///The <code>SuggestAllocatorProperties</code> method informs the pin of the application's preferred allocator
    ///properties. Call this method before the pin connects.
    ///Params:
    ///    pprop = Pointer to an [ALLOCATOR_PROPERTIES](/windows/desktop/api/strmif/ns-strmif-allocator_properties) structure
    ///            that contains the requested properties. A negative value for any member indicates that the pin should use its
    ///            default setting for that property.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b>
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_ALREADY_CONNECTED</b></dt> </dl> </td>
    ///    <td width="60%"> Pin is already connected. </td> </tr> </table>
    ///    
    HRESULT SuggestAllocatorProperties(const(ALLOCATOR_PROPERTIES)* pprop);
    ///The <code>GetAllocatorProperties</code> method retrieves the allocator properties that the pin is using.
    ///Params:
    ///    pprop = Pointer to an [ALLOCATOR_PROPERTIES](/windows/desktop/api/strmif/ns-strmif-allocator_properties) structure,
    ///            allocated by the caller, that receives the allocator properties.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt>
    ///    </dl> </td> <td width="60%"> Pin is not connected. </td> </tr> </table>
    ///    
    HRESULT GetAllocatorProperties(ALLOCATOR_PROPERTIES* pprop);
}

///The <b>IAMAnalogVideoDecoder</b> interface sets and retrieves information about the analog-to-digital conversion
///process in a video capture filter. The WDM Video Capture filter exposes this interface if the device is an analog
///video capture device. Applications can use this interface to control aspects of the analog decoding process, such as
///the analog video format and the horizontal sync lock.
@GUID("C6E13350-30AC-11D0-A18C-00A0C9118956")
interface IAMAnalogVideoDecoder : IUnknown
{
    ///The <b>get_AvailableTVFormats</b> method retrieves the analog video formats that the decoder supports.
    ///Params:
    ///    lAnalogVideoStandard = Pointer to a variable that receives a bitwise
    ///                           [AnalogVideoStandard](/windows/desktop/api/strmif/ne-strmif-analogvideostandard) enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_AvailableTVFormats(int* lAnalogVideoStandard);
    ///The <code>put_TVFormat</code> method sets the analog video format.
    ///Params:
    ///    lAnalogVideoStandard = Specifies the video format as a member of the
    ///                           [AnalogVideoStandard](/windows/desktop/api/strmif/ne-strmif-analogvideostandard) enumeration.
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT put_TVFormat(int lAnalogVideoStandard);
    ///The <code>get_TVFormat</code> method retrieves the current analog video format.
    ///Params:
    ///    plAnalogVideoStandard = Pointer to a variable that receives a member of the
    ///                            [AnalogVideoStandard](/windows/desktop/api/strmif/ne-strmif-analogvideostandard) enumeration, indicating the
    ///                            analog video format.
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT get_TVFormat(int* plAnalogVideoStandard);
    ///The <code>get_HorizontalLocked</code> method determines whether the horizontal sync is locked.
    ///Params:
    ///    plLocked = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///               </th> </tr> <tr> <td>0</td> <td>Horizontal sync is not locked.</td> </tr> <tr> <td>1</td> <td>Horizontal sync
    ///               is locked</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PROP_ID_UNSUPPORTED</b></dt> </dl> </td> <td
    ///    width="60%"> The device does not support this method. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_HorizontalLocked(int* plLocked);
    ///The <code>put_VCRHorizontalLocking</code> method specifies whether the video is a tape source or a broadcast
    ///source.
    ///Params:
    ///    lVCRHorizontalLocking = Specifies one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                            <td>0</td> <td>The video is from a broadcast source.</td> </tr> <tr> <td>1</td> <td>The video is from a tape
    ///                            source.</td> </tr> </table>
    ///Returns:
    ///    Returns an HRESULT value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PROP_ID_UNSUPPORTED</b></dt> </dl> </td> <td
    ///    width="60%"> The device does not support this method. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT put_VCRHorizontalLocking(int lVCRHorizontalLocking);
    ///The <code>get_VCRHorizontalLocking</code> method indicates whether the decoder is expecting video from a tape
    ///source or a broadcast source.
    ///Params:
    ///    plVCRHorizontalLocking = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///                             </th> </tr> <tr> <td>0</td> <td>The decoder is expecting video from a broadcast source.</td> </tr> <tr>
    ///                             <td>1</td> <td>The decoder is expecting video from a tape source.</td> </tr> </table>
    ///Returns:
    ///    Returns an HRESULT value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PROP_ID_UNSUPPORTED</b></dt> </dl> </td> <td
    ///    width="60%"> The device does not support this method. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_VCRHorizontalLocking(int* plVCRHorizontalLocking);
    ///The <code>get_NumberOfLInes</code> method retrieves the number of scan lines in the video signal.
    ///Params:
    ///    plNumberOfLines = Pointer to a variable that receives the number of scan lines in the video signal. This is generally by 525
    ///                      lines for NTSC and 625 lines for PAL or SECAM.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PROP_ID_UNSUPPORTED</b></dt> </dl> </td> <td
    ///    width="60%"> The device does not support this method. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_NumberOfLines(int* plNumberOfLines);
    ///The <code>put_OutputEnable</code> method enables or disables the video port bus.
    ///Params:
    ///    lOutputEnable = Specifies whether the bus is enabled. Use one of the following values. <table> <tr> <th>Value </th>
    ///                    <th>Description </th> </tr> <tr> <td>0</td> <td>Disable the video port bus.</td> </tr> <tr> <td>1</td>
    ///                    <td>Enable the video port bus.</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PROP_ID_UNSUPPORTED</b></dt> </dl> </td> <td
    ///    width="60%"> The device does not support this method. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT put_OutputEnable(int lOutputEnable);
    ///The <code>get_OutputEnable</code> method determines whether the video port bus is enabled.
    ///Params:
    ///    plOutputEnable = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///                     </th> </tr> <tr> <td>0</td> <td>Video port bus is disabled.</td> </tr> <tr> <td>1</td> <td>Video port bus is
    ///                     enabled.</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PROP_ID_UNSUPPORTED</b></dt> </dl> </td> <td
    ///    width="60%"> The device does not support this method. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_OutputEnable(int* plOutputEnable);
}

///The <b>IAMVideoProcAmp</b> interface adjusts the qualities of an incoming video signal, such as brightness, contrast,
///hue, saturation, gamma, and sharpness. The WDM Video Capture filter exposes this interface if the hardware supports
///image adjustment.
@GUID("C6E13360-30AC-11D0-A18C-00A0C9118956")
interface IAMVideoProcAmp : IUnknown
{
    ///The <code>GetRange</code> method gets the range and default value of a specified video property.
    ///Params:
    ///    Property = Specifies the property to query, as a value from the
    ///               [VideoProcAmpProperty](/windows/desktop/api/strmif/ne-strmif-videoprocampproperty) enumeration.
    ///    pMin = Receives the minimum value of the property.
    ///    pMax = Receives the maximum value of the property.
    ///    pSteppingDelta = Receives the step size for the property. The step size is the smallest increment by which the property can
    ///                     change.
    ///    pDefault = Receives the default value of the property.
    ///    pCapsFlags = Receives a member of the [VideoProcAmpFlags](/windows/desktop/api/strmif/ne-strmif-videoprocampflags)
    ///                 enumeration, indicating whether the property is controlled automatically or manually.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_PROP_ID_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The device does not support this property.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> No error. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetRange(int Property, int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlags);
    ///The <b>Set</b> method sets video quality for a specified property.
    ///Params:
    ///    Property = The property to set, specified as a
    ///               [VideoProcAmpProperty](/windows/desktop/api/strmif/ne-strmif-videoprocampproperty) enumeration value.
    ///    lValue = The new value of the property.
    ///    Flags = The desired control setting, specified as a
    ///            [VideoProcAmpFlags](/windows/desktop/api/strmif/ne-strmif-videoprocampflags) enumeration value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Set(int Property, int lValue, int Flags);
    ///The <code>Get</code> method gets the current setting of a video property.
    ///Params:
    ///    Property = Specifies the property to retrieve, as a value from the
    ///               [VideoProcAmpProperty](/windows/desktop/api/strmif/ne-strmif-videoprocampproperty) enumeration.
    ///    lValue = Receives the value of the property.
    ///    Flags = Receives a member of the [VideoProcAmpFlags](/windows/desktop/api/strmif/ne-strmif-videoprocampflags)
    ///            enumeration. The returned value indicates whether the setting is controlled manually or automatically.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Get(int Property, int* lValue, int* Flags);
}

///The <b>IAMCameraControl</b> interface controls camera settings such as zoom, pan, aperture adjustment, or shutter
///speed. To obtain this interface, query the filter that controls the camera.
@GUID("C6E13370-30AC-11D0-A18C-00A0C9118956")
interface IAMCameraControl : IUnknown
{
    ///The <b>GetRange</b> method gets the range and default value of a specified camera property.
    ///Params:
    ///    Property = Specifies the property to query, as a value from the
    ///               [CameraControlProperty](/windows/desktop/api/strmif/ne-strmif-cameracontrolproperty) enumeration.
    ///    pMin = Receives the minimum value of the property.
    ///    pMax = Receives the maximum value of the property.
    ///    pSteppingDelta = Receives the step size for the property. The step size is the smallest increment by which the property can
    ///                     change.
    ///    pDefault = Receives the default value of the property.
    ///    pCapsFlags = Receives a member of the [CameraControlFlags](/windows/desktop/api/strmif/ne-strmif-cameracontrolflags)
    ///                 enumeration, indicating whether the property is controlled automatically or manually.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRange(int Property, int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlags);
    ///The <b>Set</b> method sets a specified property on the camera.
    ///Params:
    ///    Property = Specifies the property to set, as a value from the
    ///               [CameraControlProperty](/windows/desktop/api/strmif/ne-strmif-cameracontrolproperty) enumeration.
    ///    lValue = Specifies the new value of the property.
    ///    Flags = Specifies the desired control setting, as a member of the
    ///            [CameraControlFlags](/windows/desktop/api/strmif/ne-strmif-cameracontrolflags) enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Set(int Property, int lValue, int Flags);
    ///The <b>Get</b> method gets the current setting of a camera property.
    ///Params:
    ///    Property = Specifies the property to retrieve, as a value from the
    ///               [CameraControlProperty](/windows/desktop/api/strmif/ne-strmif-cameracontrolproperty) enumeration.
    ///    lValue = Receives the value of the property.
    ///    Flags = Receives a member of the [CameraControlFlags](/windows/desktop/api/strmif/ne-strmif-cameracontrolflags)
    ///            enumeration. The returned value indicates whether the setting is controlled manually or automatically.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Get(int Property, int* lValue, int* Flags);
}

///The <b>IAMVideoControl</b> interface controls certain video capture operations such as enumerating available frame
///rates and image orientation.
@GUID("6A2E0670-28E4-11D0-A18C-00A0C9118956")
interface IAMVideoControl : IUnknown
{
    ///The <code>GetCaps</code> method retrieves the capabilities of the underlying hardware.
    ///Params:
    ///    pPin = Pointer to the pin to query capabilities from.
    ///    pCapsFlags = Pointer to a value representing a combination of the flags from the
    ///                 [VideoControlFlags](/windows/desktop/api/strmif/ne-strmif-videocontrolflags) enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetCaps(IPin pPin, int* pCapsFlags);
    ///The <code>SetMode</code> method sets the video control mode of operation.
    ///Params:
    ///    pPin = Pointer to the pin to set the video control mode on.
    ///    Mode = Value specifying a combination of the flags from the
    ///           [VideoControlFlags](/windows/desktop/api/strmif/ne-strmif-videocontrolflags) enumeration to set the video
    ///           control mode.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT SetMode(IPin pPin, int Mode);
    ///The <code>GetMode</code> method retrieves the video control mode of operation.
    ///Params:
    ///    pPin = Pointer to the pin to retrieve the video control mode from.
    ///    Mode = Pointer to a value representing a combination of the flags from the
    ///           [VideoControlFlags](/windows/desktop/api/strmif/ne-strmif-videocontrolflags) enumeration, which specify the
    ///           video control mode.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetMode(IPin pPin, int* Mode);
    ///The <code>GetCurrentActualFrameRate</code> method retrieves the actual frame rate, expressed as a frame duration
    ///in 100-nanosecond units. USB (Universal Serial Bus) and IEEE 1394 cameras may provide lower frame rates than
    ///requested because of bandwidth availability. This is only available during video streaming.
    ///Params:
    ///    pPin = Pointer to the pin to retrieve the frame rate from.
    ///    ActualFrameRate = Pointer to the frame rate in frame duration in 100-nanosecond units.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetCurrentActualFrameRate(IPin pPin, long* ActualFrameRate);
    ///The <code>GetMaxAvailableFrameRate</code> method retrieves the maximum frame rate currently available, based on
    ///bus bandwidth usage for connections, such as USB and IEEE 1394, where the maximum frame rate may be limited by
    ///bandwidth availability.
    ///Params:
    ///    pPin = Pointer to the pin to retrieve the maximum frame rate from.
    ///    iIndex = Index of the format to query for maximum frame rate. This index corresponds to the order in which formats are
    ///             enumerated by IAMStreamConfig::GetStreamCaps. The value must range between zero and the number of supported
    ///             <b>VIDEO_STREAM_CONFIG_CAPS</b> structures returned by IAMStreamConfig::GetNumberOfCapabilities) minus one.
    ///    Dimensions = Frame image size (width and height) in pixels.
    ///    MaxAvailableFrameRate = Pointer to the maximum available frame rate. The frame rate is expressed as frame duration in 100-nanosecond
    ///                            units.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetMaxAvailableFrameRate(IPin pPin, int iIndex, SIZE Dimensions, long* MaxAvailableFrameRate);
    ///The <code>GetFrameRateList</code> method retrieves a list of available frame rates.
    ///Params:
    ///    pPin = Pointer to the pin to query for the list of frame rates.
    ///    iIndex = Index of the format to query for frame rates. This index corresponds to the order in which formats are
    ///             enumerated by [VIDEO_STREAM_CONFIG_CAPS](/windows/desktop/api/strmif/ns-strmif-video_stream_config_caps)
    ///             structures returned by IAMStreamConfig::GetNumberOfCapabilities) minus one.
    ///    Dimensions = Frame image size (width and height) in pixels.
    ///    ListSize = Pointer to the number of elements in the list of frame rates.
    ///    FrameRates = Address of a pointer to an array of frame rates in 100-nanosecond units. Can be <b>NULL</b> if you only need
    ///                 <i>ListSize</i>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetFrameRateList(IPin pPin, int iIndex, SIZE Dimensions, int* ListSize, long** FrameRates);
}

///The <code>IAMCrossbar</code> interface routes signals from an analog or digital source to a video capture filter.
///This interface is implemented by the Analog Video Crossbar Filter. The Analog Video Crossbar filter is modeled after
///a general switching matrix, with <i>n</i> inputs and <i>m</i> outputs. For example, a video card might have two
///external connectors: a coaxial connector for TV, and an S-video input. These would be represented as input pins on
///the filter. To select one of the inputs, an application would use the <code>IAMCrossbar</code> interface to "route"
///an input pin to the filter's output pin, by calling the IAMCrossbar::Route method.
@GUID("C6E13380-30AC-11D0-A18C-00A0C9118956")
interface IAMCrossbar : IUnknown
{
    ///The <code>get_PinCounts</code> method retrieves the number of input and output pins on the crossbar filter.
    ///Params:
    ///    OutputPinCount = Pointer to variable that receives the number of output pins.
    ///    InputPinCount = Pointer to variable that receives the number of input pins.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_PinCounts(int* OutputPinCount, int* InputPinCount);
    ///The <code>CanRoute</code> method queries whether a specified input pin can be routed to a specified output pin.
    ///Params:
    ///    OutputPinIndex = Specifies the index of the output pin.
    ///    InputPinIndex = Specifies the index of input pin.
    ///Returns:
    ///    Returns an <b>HRESULT</b> values. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> These
    ///    two pins can be routed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> These two pins cannot be routed. </td> </tr> </table>
    ///    
    HRESULT CanRoute(int OutputPinIndex, int InputPinIndex);
    ///The <code>Route</code> method routes an input pin to an output pin.
    ///Params:
    ///    OutputPinIndex = Specifies the index of the output pin.
    ///    InputPinIndex = Specifies the index of the input pin.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Cannot route these two pins. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT Route(int OutputPinIndex, int InputPinIndex);
    ///The <code>get_IsRoutedTo</code> method retrieves the input pin that is currently routed to the specified output
    ///pin.
    ///Params:
    ///    OutputPinIndex = Specifies the index of the output pin.
    ///    InputPinIndex = Pointer to a variable that receives the index of the input pin, or -1 if no input pin is routed to this
    ///                    output pin.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No
    ///    input pin is routed to this output pin. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_IsRoutedTo(int OutputPinIndex, int* InputPinIndex);
    ///The <code>get_CrossbarPinInfo</code> method retrieves information about a specified pin.
    ///Params:
    ///    IsInputPin = Specifies the direction of the pin. Use one of the following values. <table> <tr> <th>Value</th>
    ///                 <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TRUE"></a><a id="true"></a><dl>
    ///                 <dt><b><b>TRUE</b></b></dt> </dl> </td> <td width="60%"> Input pin </td> </tr> <tr> <td width="40%"><a
    ///                 id="FALSE"></a><a id="false"></a><dl> <dt><b><b>FALSE</b></b></dt> </dl> </td> <td width="60%"> Output pin
    ///                 </td> </tr> </table>
    ///    PinIndex = Specifies the index of the pin.
    ///    PinIndexRelated = Pointer to a variable that receives the index of the related pin, or –1 if no pin is related to this pin.
    ///                      The <i>related pin</i> is a pin on the same filter, with the same direction; it typically represents the same
    ///                      physical jack or connector. For example, a video tuner and an audio tuner might be related pins. Typically,
    ///                      if two pins are related, you should route them together.
    ///    PhysicalType = Pointer to a variable that receives a member of the
    ///                   [PhysicalConnectorType](/windows/desktop/api/strmif/ne-strmif-physicalconnectortype) enumeration, indicating
    ///                   the pin's physical type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Unknown physical type. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_CrossbarPinInfo(BOOL IsInputPin, int PinIndex, int* PinIndexRelated, int* PhysicalType);
}

///The <code>IAMTuner</code> interface controls a TV tuner. This interface is the base class for the IAMTVTuner
///interface, which inherits all of the <code>IAMTuner</code> methods. For more information on controlling a TV tuner
///using Microsoft DirectShow, see the <b>IAMTVTuner</b> documentation.
@GUID("211A8761-03AC-11D1-8D13-00AA00BD8339")
interface IAMTuner : IUnknown
{
    ///The <code>put_Channel</code> method sets the TV channel.
    ///Params:
    ///    lChannel = TV channel number.
    ///    lVideoSubChannel = Predefined video subchannel value. Specify AMTUNER_SUBCHAN_NO_TUNE for no tuning or AMTUNER_SUBCHAN_DEFAULT
    ///                       for default subchannel. Meaningful only for satellite broadcasts.
    ///    lAudioSubChannel = Predefined audio subchannel value. Specify AMTUNER_SUBCHAN_NO_TUNE for no tuning or AMTUNER_SUBCHAN_DEFAULT
    ///                       for default subchannel. Meaningful only for satellite broadcasts.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT put_Channel(int lChannel, int lVideoSubChannel, int lAudioSubChannel);
    ///The <code>get_Channel</code> method retrieves the channel to which the tuner is set.
    ///Params:
    ///    plChannel = Pointer to a variable that receives the channel. For frequencies, see International Analog TV Tuning
    ///    plVideoSubChannel = Pointer to a variable that receives either the video subchannel, or one of the following flags: <table> <tr>
    ///                        <th>Value </th> <th>Description </th> </tr> <tr> <td>AMTUNER_SUBCHAN_DEFAULT</td> <td>Default subchannel</td>
    ///                        </tr> <tr> <td>AMTUNER_SUBCHAN_NO_TUNE</td> <td>No subchannel tuning</td> </tr> </table>
    ///    plAudioSubChannel = Pointer to a variable that receives either the audio subchannel, or one of the following flags: <table> <tr>
    ///                        <th>Value </th> <th>Description </th> </tr> <tr> <td>AMTUNER_SUBCHAN_DEFAULT</td> <td>Default subchannel</td>
    ///                        </tr> <tr> <td>AMTUNER_SUBCHAN_NO_TUNE</td> <td>No subchannel tuning</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT get_Channel(int* plChannel, int* plVideoSubChannel, int* plAudioSubChannel);
    ///The <code>ChannelMinMax</code> method retrieves the highest and lowest channels available.
    ///Params:
    ///    lChannelMin = Pointer to a variable that receives the lowest channel.
    ///    lChannelMax = Pointer to a variable that receives the highest channel.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT ChannelMinMax(int* lChannelMin, int* lChannelMax);
    ///The <code>put_CountryCode</code> method sets the country/region code to establish the frequency to use.
    ///Params:
    ///    lCountryCode = Value indicating the country/region code.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT put_CountryCode(int lCountryCode);
    ///The <code>get_CountryCode</code> method retrieves the country/region code that establishes the current
    ///channel-to-frequency mapping.
    ///Params:
    ///    plCountryCode = Pointer to a variable that receives the country/region code currently in use by the TV Tuner filter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT get_CountryCode(int* plCountryCode);
    ///The <code>put_TuningSpace</code> method sets a storage index for regional channel-to-frequency mappings.
    ///Params:
    ///    lTuningSpace = Value indicating the current locale.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT put_TuningSpace(int lTuningSpace);
    ///The <code>get_TuningSpace</code> method retrieves the tuning space.
    ///Params:
    ///    plTuningSpace = Pointer to a variable that receives the current tuning space.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_TuningSpace(int* plTuningSpace);
    ///The <code>Logon</code> method logs a user onto the system.
    ///Params:
    ///    hCurrentUser = Handle to an application-defined data structure that identifies the current user.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT Logon(HANDLE hCurrentUser);
    ///The <code>Logout</code> method logs out the current user.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT Logout();
    ///The <code>SignalPresent</code> method retrieves the strength of the signal on a given channel.
    ///Params:
    ///    plSignalStrength = Pointer to a variable that receives a value indicating whether a signal is present on the current channel.
    ///                       Can be one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                       <td>AMTUNER_HASNOSIGNALSTRENGTH</td> <td>-1</td> </tr> <tr> <td>AMTUNER_NOSIGNAL</td> <td>0</td> </tr> <tr>
    ///                       <td>AMTUNER_SIGNALPRESENT</td> <td>1</td> </tr> </table> A value of AMTUNER_HASNOSIGNALSTRENGTH means the
    ///                       signal strength cannot be determined at this time.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SignalPresent(int* plSignalStrength);
    ///The <code>put_Mode</code> method sets a multifunction tuner to the specified mode.
    ///Params:
    ///    lMode = Flag indicating which mode to switch to. Possible values are defined in the
    ///            [AMTunerModeType](/windows/desktop/api/strmif/ne-strmif-amtunermodetype) enumeration. You can also set the
    ///            mode to digital TV if the card supports it. To do this, define AMTUNER_MODE_DTV with a value of 0x0010.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Mode(AMTunerModeType lMode);
    ///The <code>get_Mode</code> method retrieves the current mode on a multifunction tuner.
    ///Params:
    ///    plMode = Pointer to a variable that receives a flag indicating the current mode setting. The possible values are
    ///             defined in the [AMTunerModeType](/windows/desktop/api/strmif/ne-strmif-amtunermodetype) enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT get_Mode(AMTunerModeType* plMode);
    ///The <code>GetAvailableModes</code> method retrieves the tuner's supported modes.
    ///Params:
    ///    plModes = Pointer to a variable that receives any combination of the values as specified in the
    ///              [AMTunerModeType](/windows/desktop/api/strmif/ne-strmif-amtunermodetype) enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetAvailableModes(int* plModes);
    ///The <code>RegisterNotificationCallBack</code> method enables an object to receive event notifications when the
    ///tuner changes state. This method is not implemented.
    ///Params:
    ///    pNotify = Pointer to the IAMTunerNotification interface that will receive the event notifications.
    ///    lEvents = Flag indicating that an event has occurred.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT RegisterNotificationCallBack(IAMTunerNotification pNotify, int lEvents);
    ///The <code>UnRegisterNotificationCallBack</code> method unregisters an object for event notifications. This method
    ///is not implemented.
    ///Params:
    ///    pNotify = Pointer to the IAMTunerNotification interface that was specified in a previous call to
    ///              <b>RegisterNotificationCallBack</b>.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT UnRegisterNotificationCallBack(IAMTunerNotification pNotify);
}

///<div class="alert"><b>Note</b> This callback interface has been deprecated, because the TV Tuner filter does not
///implement the callback mechanism.</div> <div> </div>
@GUID("211A8760-03AC-11D1-8D13-00AA00BD8339")
interface IAMTunerNotification : IUnknown
{
    ///<div class="alert"><b>Note</b> The <b>IAMTunerNotification</b> interface is deprecated.</div> <div> </div> The
    ///<code>OnEvent</code> method handles events from the TV tuner card.
    ///Params:
    ///    Event = Flag identifying the type of event. Currently, the only value defined is AMTUNER_EVENT_CHANGED.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT OnEvent(AMTunerEventType Event);
}

///The <code>IAMTVTuner</code> interface controls a TV tuner. The TV Tuner filter implements this interface.
///Applications can use this interface to set TV channels and to get or set information about their frequencies, and to
///determine what analog video standards your TV tuner card supports. The interface supports tuners for analog broadcast
///television and AM/FM radio. It supports tuners with multiple input pins, to enable multiple devices and multiple
///transmission types. The TV Tuner filter supports worldwide tuning coverage. It maps TV channels to specific
///frequencies through the IAMTuner::put_Channel and IAMTVTuner::AutoTune methods. These methods handle the details of
///the conversion, so that the hardware driver receives an exact frequency.
@GUID("211A8766-03AC-11D1-8D13-00AA00BD8339")
interface IAMTVTuner : IAMTuner
{
    ///The <code>get_AvailableTVFormats</code> method retrieves all the analog video TV standards that the tuner
    ///supports.
    ///Params:
    ///    lAnalogVideoStandard = Pointer to a variable that receives a bitwise combination of values from the
    ///                           [AnalogVideoStandard](/windows/desktop/api/strmif/ne-strmif-analogvideostandard) enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT get_AvailableTVFormats(int* lAnalogVideoStandard);
    ///The <code>get_TVFormat</code> method retrieves the current analog video TV standard in use.
    ///Params:
    ///    plAnalogVideoStandard = Pointer to a variable that receives a member of the
    ///                            [AnalogVideoStandard](/windows/desktop/api/strmif/ne-strmif-analogvideostandard) enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT get_TVFormat(int* plAnalogVideoStandard);
    ///The <code>AutoTune</code> method scans for a precise signal on the channel's frequency.
    ///Params:
    ///    lChannel = TV channel number.
    ///    plFoundSignal = Pointer to a variable indicating whether the channel's frequency was found; nonzero indicates found, zero
    ///                    indicates not found.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT AutoTune(int lChannel, int* plFoundSignal);
    ///The <code>StoreAutoTune</code> method saves the fine-tuning information for all channels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT StoreAutoTune();
    ///The <code>get_NumInputConnections</code> method retrieves the number of TV sources plugged into the tuner filter.
    ///Params:
    ///    plNumInputConnections = Pointer to a variable that receives the number of TV sources plugged into the tuner filter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT get_NumInputConnections(int* plNumInputConnections);
    ///The <code>put_InputType</code> method sets the tuner input type (cable or antenna).
    ///Params:
    ///    lIndex = Index value that specifies the input pin to be set.
    ///    InputType = Value indicating the connection type, as specified in the
    ///                [TunerInputType](/windows/desktop/api/strmif/ne-strmif-tunerinputtype) enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT put_InputType(int lIndex, TunerInputType InputType);
    ///The <code>get_InputType</code> method retrieves the input type set in IAMTVTuner::put_InputType.
    ///Params:
    ///    lIndex = Index value that specifies the input pin that will be set.
    ///    pInputType = Pointer to a variable the receives a member of the
    ///                 [TunerInputType](/windows/desktop/api/strmif/ne-strmif-tunerinputtype) enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT get_InputType(int lIndex, TunerInputType* pInputType);
    ///The <code>put_ConnectInput</code> method sets the hardware tuner input connection.
    ///Params:
    ///    lIndex = Index value of the input pin to set connection for.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT put_ConnectInput(int lIndex);
    ///The <code>get_ConnectInput</code> method retrieves the hardware tuner input connection.
    ///Params:
    ///    plIndex = Pointer to the input pin to get the connection for.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT get_ConnectInput(int* plIndex);
    ///The <code>get_VideoFrequency</code> method retrieves the current video frequency.
    ///Params:
    ///    lFreq = Pointer to a variable that receives the video frequency, in hertz (Hz).
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT get_VideoFrequency(int* lFreq);
    ///The <code>get_AudioFrequency</code> method retrieves the currently tuned audio frequency.
    ///Params:
    ///    lFreq = Pointer to a variable that receives the audio frequency, in hertz (Hz).
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT get_AudioFrequency(int* lFreq);
}

///<div class="alert"><b>Note</b> This interface is not implemented and has been deprecated.</div> <div> </div> The
///<code>IBPCSatelliteTuner</code> interface supports satellite television tuning.
@GUID("211A8765-03AC-11D1-8D13-00AA00BD8339")
interface IBPCSatelliteTuner : IAMTuner
{
    ///<div class="alert"><b>Note</b> The <b>IBPCSatelliteTuner</b> interface is deprecated.</div> <div> </div> Gets the
    ///default sub-channel types.
    ///Params:
    ///    plDefaultVideoType = Receives a provider-specific service type for video.
    ///    plDefaultAudioType = Receives a provider-specific service type for audio.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_DefaultSubChannelTypes(int* plDefaultVideoType, int* plDefaultAudioType);
    ///<div class="alert"><b>Note</b> The <code>IBPCSatelliteTuner</code> interface is deprecated.</div> <div> </div>
    ///Sets the default sub-channel types.
    ///Params:
    ///    lDefaultVideoType = Provider-specific service type for video.
    ///    lDefaultAudioType = Provider-specific service type for audio.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_DefaultSubChannelTypes(int lDefaultVideoType, int lDefaultAudioType);
    ///<div class="alert"><b>Note</b> The <b>IBPCSatelliteTuner</b> interface is deprecated.</div> <div> </div> Queries
    ///whether taping is permitted.
    ///Returns:
    ///    Returns S_OK if taping is permitted or S_FALSE if taping is not permitted.
    ///    
    HRESULT IsTapingPermitted();
}

///The <code>IAMTVAudio</code> interface controls audio from a television source. The TV Audio filter implements this
///interface. Applications can use it to control television audio settings, including secondary audio program (SAP) and
///stereo or mono selection.
@GUID("83EC1C30-23D1-11D1-99E6-00A0C9560266")
interface IAMTVAudio : IUnknown
{
    ///The <code>GetHardwareSupportedTVAudioModes</code> method retrieves a bitmask of the formats available in the
    ///hardware.
    ///Params:
    ///    plModes = Pointer to a [TVAudioMode](/windows/desktop/api/strmif/ne-strmif-tvaudiomode) enumeration value that
    ///              identifies the audio mode.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation. <b>HRESULT</b> can be one of the
    ///    following standard constants, or other values not listed. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method isn't supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK or
    ///    NOERROR</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetHardwareSupportedTVAudioModes(int* plModes);
    ///The <code>GetAvailableTVAudioModes</code> method retrieves a bitmask of the possible modes.
    ///Params:
    ///    plModes = Pointer to a [TVAudioMode](/windows/desktop/api/strmif/ne-strmif-tvaudiomode) enumeration type, identifying
    ///              the audio mode.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation. <b>HRESULT</b> can be one of the
    ///    following standard constants, or other values not listed. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Null
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td>
    ///    <td width="60%"> Method isn't supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK or
    ///    NOERROR</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetAvailableTVAudioModes(int* plModes);
    ///The <code>get_TVAudioMode</code> method retrieves the current TV audio mode.
    ///Params:
    ///    plMode = Pointer to a [TVAudioMode](/windows/desktop/api/strmif/ne-strmif-tvaudiomode) enumeration type, identifying
    ///             the audio mode.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation. <b>HRESULT</b> can be one of the
    ///    following standard constants, or other values not listed. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method isn't supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK or
    ///    NOERROR</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_TVAudioMode(int* plMode);
    ///The <code>put_TVAudioMode</code> method sets the current TV audio mode.
    ///Params:
    ///    lMode = A [TVAudioMode](/windows/desktop/api/strmif/ne-strmif-tvaudiomode) enumeration value that identifies the
    ///            audio mode.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation. <b>HRESULT</b> can be one of the
    ///    following standard constants, or other values not listed. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method isn't supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK or
    ///    NOERROR</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT put_TVAudioMode(int lMode);
    ///The <code>RegisterNotificationCallBack</code> method enables an object that implements the IAMTunerNotification
    ///interface to receive event notifications when the tuner changes state. This method is not implemented.
    ///Params:
    ///    pNotify = Pointer to the IAMTunerNotification interface that will receive the event notifications.
    ///    lEvents = Flag indicating that an event has occurred.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT RegisterNotificationCallBack(IAMTunerNotification pNotify, int lEvents);
    ///The <code>UnRegisterNotificationCallBack</code> method unregisters an object for event notifications. This method
    ///is not implemented.
    ///Params:
    ///    pNotify = Pointer to the IAMTunerNotification interface that was specified in a previous call to
    ///              <b>RegisterNotificationCallBack</b>.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT UnRegisterNotificationCallBack(IAMTunerNotification pNotify);
}

///<div class="alert"><b>Note</b> This callback interface has been deprecated, because the TV Audio filter does not
///implement the callback mechanism.</div> <div> </div>
@GUID("83EC1C33-23D1-11D1-99E6-00A0C9560266")
interface IAMTVAudioNotification : IUnknown
{
    ///<div class="alert"><b>Note</b> The <b>IAMTVAudioNotification</b> interface is deprecated.</div> <div> </div> The
    ///<code>OnEvent</code> method handles events from a TV tuner card controlled by the IAMTVAudio interface.
    ///Params:
    ///    Event = Flag identifying the type of event. The only value currently defined is AMTVAUDIO_EVENT_CHANGED.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT OnEvent(AMTVAudioEventType Event);
}

///<div class="alert"><b>Note</b> This interface has been deprecated.</div> <div> </div> <div class="alert"><b>Note</b>
///Microsoft does not provide an implementation of this interface. Third parties might implement it.</div> <div> </div>
///The <b>IAMAnalogVideoEncoder</b> interface might be implemented by a hardware video encoder in video capture
///operations when an application is streaming data to disk and sending it back out to videotape.
@GUID("C6E133B0-30AC-11D0-A18C-00A0C9118956")
interface IAMAnalogVideoEncoder : IUnknown
{
    ///<div class="alert"><b>Note</b> The <b>IAMAnalogVideoEncoder</b> interface is deprecated.</div> <div> </div> The
    ///<code>get_AvailableTVFormats</code> method retrieves the analog video standards (NTSC/M, PAL/B, SECAM/K1, and so
    ///on) supported by the encoder.
    ///Params:
    ///    lAnalogVideoStandard = Specifies a pointer to a [AnalogVideoStandard](/windows/desktop/api/strmif/ne-strmif-analogvideostandard)
    ///                           enumeration and the available formats have been combined in this integer with a bitwise OR.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_AvailableTVFormats(int* lAnalogVideoStandard);
    ///<div class="alert"><b>Note</b> The <b>IAMAnalogVideoEncoder</b> interface is deprecated.</div> <div> </div> The
    ///<code>put_TVFormat</code> method sets the encoder to a particular analog video standard (NTSC/M, PAL/B, SECAM/K1,
    ///and so on).
    ///Params:
    ///    lAnalogVideoStandard = Specifies the video standard to set in the encoder as a
    ///                           [AnalogVideoStandard](/windows/desktop/api/strmif/ne-strmif-analogvideostandard) enumeration.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_TVFormat(int lAnalogVideoStandard);
    ///<div class="alert"><b>Note</b> The <b>IAMAnalogVideoEncoder</b> interface is deprecated.</div> <div> </div> The
    ///<code>get_TVFormat</code> method retrieves the analog video standard that the encoder is currently set to
    ///(NTSC/M, PAL/B, SECAM/K1, and so on).
    ///Params:
    ///    plAnalogVideoStandard = Specifies a pointer to a <b>long</b> integer to receive the encoder's current video standard.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_TVFormat(int* plAnalogVideoStandard);
    ///<div class="alert"><b>Note</b> The <b>IAMAnalogVideoEncoder</b> interface is deprecated.</div> <div> </div> The
    ///<code>put_CopyProtection</code> method sets the level of copy protection for the encoder.
    ///Params:
    ///    lVideoCopyProtection = Specifies the level of copy protection as a <b>long</b> integer with a value as defined in the
    ///                           AM_COPY_MACROVISION_LEVEL enumeration.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_CopyProtection(int lVideoCopyProtection);
    ///<div class="alert"><b>Note</b> The <b>IAMAnalogVideoEncoder</b> interface is deprecated.</div> <div> </div> The
    ///<code>get_CopyProtection</code> method determines whether copy protection is currently enabled on the encoder.
    ///Params:
    ///    lVideoCopyProtection = Specifies a pointer to a <b>long</b> integer to receive the current copy protection level, as defined in the
    ///                           AM_COPY_MACROVISION_LEVEL enumeration.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b>
    ///    
    HRESULT get_CopyProtection(int* lVideoCopyProtection);
    ///<div class="alert"><b>Note</b> The <b>IAMAnalogVideoEncoder</b> interface is deprecated.</div> <div> </div> The
    ///<code>put_CCEnable</code> method enables or disables closed captioning.
    ///Params:
    ///    lCCEnable = Specifies whether closed captioning is on or off as a <b>long</b> integer. <table> <tr> <th>Value </th>
    ///                <th>Description </th> </tr> <tr> <td>1</td> <td>Closed captioning is on.</td> </tr> <tr> <td>0</td>
    ///                <td>Closed captioning is off.</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_CCEnable(int lCCEnable);
    ///<div class="alert"><b>Note</b> The <b>IAMAnalogVideoEncoder</b> interface is deprecated.</div> <div> </div> The
    ///<code>get_CCEnable</code> determines whether closed captioning on the encoder is currently enabled.
    ///Params:
    ///    lCCEnable = Specifies a pointer to a long integer to receive the current status of closed captioning on the encoder.
    ///                <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>1</td> <td>Closed captioning enabled.</td>
    ///                </tr> <tr> <td>0</td> <td>Closed captioning disabled.</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_CCEnable(int* lCCEnable);
}

@GUID("31EFAC30-515C-11D0-A9AA-00AA0061BE93")
interface IKsPropertySet : IUnknown
{
    HRESULT Set(const(GUID)* guidPropSet, uint dwPropID, char* pInstanceData, uint cbInstanceData, char* pPropData, 
                uint cbPropData);
    HRESULT Get(const(GUID)* guidPropSet, uint dwPropID, char* pInstanceData, uint cbInstanceData, char* pPropData, 
                uint cbPropData, uint* pcbReturned);
    HRESULT QuerySupported(const(GUID)* guidPropSet, uint dwPropID, uint* pTypeSupport);
}

///The <code>IMediaPropertyBag</code> interface is exposed by the Media Property Bag object. The Media Property Bag is a
///specialized version of the standard COM property bag, designed for setting and retrieving INFO and DISP chunks in
///Audio-Video Interleaved (AVI) files. An INFO chunk contains meta-information about a file, such as author and
///copyright information. A DISP chunk contains data in Clipboard format. For more information, refer to the resource
///interchange file format (RIFF) specification. The media property bag stores the chunks as name/value pairs, as
///follows: <ul> <li>INFO chunks: The name is a string with the form INFO/XXXX, where XXXX is the four-character code
///that defines the type of meta-information—for example, ICOP for copyright information and IART for author name. The
///value is any string.</li> <li>DISP chunks: The name is a string with the form DISP/0000000000, where 0000000000 is
///the 10-character decimal equivalent of a standard Clipboard format—for example, 0000000008 for CF_DIB. The value is
///an array of bytes that contains the display data.</li> </ul> Use this interface with the IPersistMediaPropertyBag
///interface to retrieve INFO and DISP chunks from an AVI file.
@GUID("6025A880-C0D5-11D0-BD4E-00A0C911CE86")
interface IMediaPropertyBag : IPropertyBag
{
    ///The <code>EnumProperty</code> method retrieves a property/value pair.
    ///Params:
    ///    iProperty = Index value of the pair.
    ///    pvarPropertyName = Pointer to a <b>VARIANT</b> that receives the property's name.
    ///    pvarPropertyValue = Pointer to a <b>VARIANT</b> that receives the property's value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)</b></dt> </dl> </td> <td width="60%"> Index out of range.
    ///    </td> </tr> </table>
    ///    
    HRESULT EnumProperty(uint iProperty, VARIANT* pvarPropertyName, VARIANT* pvarPropertyValue);
}

///The <code>IPersistMediaPropertyBag</code> interface sets and retrieves INFO and DISP chunks in Audio-Video
///Interleaved (AVI) streams. It uses the IMediaPropertyBag interface to store the chunks as name/value pairs. The AVI
///Splitter filter and the WAVE Parser filter support this interface for reading INFO and DISP chunks from an AVI or WAV
///file. The AVI Mux filter supports the interface for writing these chunks into a file.
///<code>IPersistMediaPropertyBag</code> is modeled after, but does not inherit from, the <b>IPersistPropertyBag</b>
///interface. For more information on <b>IPersistPropertyBag</b>, see the Platform SDK.
@GUID("5738E040-B67F-11D0-BD4D-00A0C911CE86")
interface IPersistMediaPropertyBag : IPersist
{
    ///The <code>InitNew</code> method initializes the object to receive new properties.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT InitNew();
    ///The <code>Load</code> method loads properties from the media property bag into the filter.
    ///Params:
    ///    pPropBag = Pointer to the IMediaPropertyBag interface of a media property bag created by the caller.
    ///    pErrorLog = Reserved. Set the value to <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_ACCESSDENIED</b></dt> </dl>
    ///    </td> <td width="60%"> Access denied. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> Filter graph is not in a stopped state. </td>
    ///    </tr> </table>
    ///    
    HRESULT Load(IMediaPropertyBag pPropBag, IErrorLog pErrorLog);
    ///The <code>Save</code> method saves properties from the filter into the media property bag.
    ///Params:
    ///    pPropBag = Pointer to the IMediaPropertyBag interface of a media property bag created by the caller.
    ///    fClearDirty = Reserved. Can be any value.
    ///    fSaveAllProperties = Reserved. Can be any value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>HRESULT_FROM_WIN32(ERROR_INVALID_DATA)</b></dt> </dl> </td> <td width="60%"> Invalid data. </td> </tr>
    ///    </table>
    ///    
    HRESULT Save(IMediaPropertyBag pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
}

///<div class="alert"><b>Note</b> This interface has been deprecated. It will continue to be supported for backward
///compatibility with existing applications, but new applications and filters should not use it.</div> <div> </div> This
///interface enables an application or filter to retrieve information about a pin that represents a physical hardware
///connections.
@GUID("F938C991-3029-11CF-8C44-00AA006B6814")
interface IAMPhysicalPinInfo : IUnknown
{
    ///<div class="alert"><b>Note</b> The <code>IAMPhysicalPinInfo</code> interface is deprecated.</div> <div> </div>
    ///Retrieves the type and name of the physical pin.
    ///Params:
    ///    pType = Pointer to a variable that receives a value indicating the pin's type. The
    ///            [PhysicalConnectorType](/windows/desktop/api/strmif/ne-strmif-physicalconnectortype) enumeration defines the
    ///            pin type values.
    ///    ppszType = Address of a pointer to a buffer that receives a human-readable string identifying the pin type.
    ///Returns:
    ///    Returns S_OK if a valid physical pin value is found. Otherwise, returns VFW_E_NO_ACCEPTABLE_TYPES.
    ///    
    HRESULT GetPhysicalType(int* pType, ushort** ppszType);
}

///The <b>IAMExtDevice</b> interface controls an external device, such as a DV camera or video tape recoder (VTR). This
///interface controls basic device functions. Several other interfaces exist for controlling more specific functionality
///in a device: <ul> <li> IAMExtTransport </li> <li> IAMTimecodeReader </li> <li> IAMTimecodeGenerator </li> <li>
///IAMTimecodeDisplay </li> </ul>
@GUID("B5730A90-1A2C-11CF-8C23-00AA006B6814")
interface IAMExtDevice : IUnknown
{
    ///The <code>GetCapability</code> method retrieves the capabilities of the external device.
    ///Params:
    ///    Capability = Specifies the capability to check. See Remarks for more information.
    ///    pValue = Pointer to a variable that receives a <b>long</b> integer. See Remarks for more information.
    ///    pdblValue = Pointer to a variable that receives a <b>double</b>. See Remarks for more information.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetCapability(int Capability, int* pValue, double* pdblValue);
    ///The <code>get_ExternalDeviceID</code> method retrieves the model number of the external device.
    ///Params:
    ///    ppszData = Pointer to an <b>LPOLESTR</b> that receives the manufacturer-specific identification as a string. The caller
    ///               must release the string by calling CoTaskMemFree.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_ExternalDeviceID(ushort** ppszData);
    ///The <code>get_ExternalDeviceVersion</code> retrieves the version number of the external device's operating
    ///software.
    ///Params:
    ///    ppszData = Pointer to an <b>LPOLESTR</b> that receives the manufacturer-specific operating software version number as a
    ///               string. The caller must release the string by calling CoTaskMemFree.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_ExternalDeviceVersion(ushort** ppszData);
    ///The <code>put_DevicePower</code> method assigns the external device's power mode to either on, off, or standby.
    ///Params:
    ///    PowerMode = Specifies the device's power mode. Use one of the following values. <table> <tr> <th>Value </th>
    ///                <th>Description </th> </tr> <tr> <td>ED_POWER_OFF</td> <td>Off</td> </tr> <tr> <td>ED_POWER_ON</td>
    ///                <td>On</td> </tr> <tr> <td>ED_POWER_STANDBY</td> <td>Standby</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_DevicePower(int PowerMode);
    ///The <code>get_DevicePower</code> method retrieves the external device's power mode.
    ///Params:
    ///    pPowerMode = Pointer to a <b>long</b> integer that receives one of the following values, indicating the device's power
    ///                 mode. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_POWER_OFF</td> <td>Power is
    ///                 off.</td> </tr> <tr> <td>ED_POWER_ON</td> <td>Power if on.</td> </tr> <tr> <td>ED_POWER_STANDBY</td>
    ///                 <td>Device is in standby mode.</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_DevicePower(int* pPowerMode);
    ///The <code>Calibrate</code> method calibrates an external device's transport mechanism. This method is not
    ///implemented.
    ///Params:
    ///    hEvent = Handle to an event. The event is signaled when the action is complete.
    ///    Mode = Specifies a value that activates or deactivates the calibration process: <table> <tr> <th>Value </th>
    ///           <th>Description </th> </tr> <tr> <td>ED_ACTIVE</td> <td>Activates the calibration process.</td> </tr> <tr>
    ///           <td>ED_INACTIVE</td> <td>Deactivates the calibration process.</td> </tr> <tr> <td><b>NULL</b></td> <td>No
    ///           action; return the calibration status in <i>pStatus</i>.</td> </tr> </table>
    ///    pStatus = Pointer to a <b>long</b> integer that receives one of the following values: <table> <tr> <th>Value </th>
    ///              <th>Description </th> </tr> <tr> <td>OATRUE</td> <td>Calibration is active.</td> </tr> <tr> <td>OAFALSE</td>
    ///              <td>Calibration is inactive.</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT Calibrate(size_t hEvent, int Mode, int* pStatus);
    ///The <code>put_DevicePort</code> method assigns the communication port to which the external device is connected.
    ///This method is not implemented.
    ///Params:
    ///    DevicePort = Specifies the port to which the device will connect. Use one of the following values. <table> <tr> <th>Value
    ///                 </th> <th>Description </th> </tr> <tr> <td>DEV_PORT_1394</td> <td>IEEE 1394 Bus</td> </tr> <tr>
    ///                 <td>DEV_PORT_ARTI</td> <td>ARTI driver</td> </tr> <tr> <td>DEV_PORT_COM1</td> <td>COM1</td> </tr> <tr>
    ///                 <td>DEV_PORT_COM2</td> <td>COM2</td> </tr> <tr> <td>DEV_PORT_COM3</td> <td>COM3</td> </tr> <tr>
    ///                 <td>DEV_PORT_COM4</td> <td>COM4</td> </tr> <tr> <td>DEV_PORT_DIAQ</td> <td>Diaquest driver</td> </tr> <tr>
    ///                 <td>DEV_PORT_MIN</td> <td>DEV_PORT_SIM</td> </tr> <tr> <td>DEV_PORT_SIM</td> <td>Simulation port (used for
    ///                 "no hardware" simulation)</td> </tr> <tr> <td>DEV_PORT_USB</td> <td>Universal serial bus</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_DevicePort(int DevicePort);
    ///The <code>get_DevicePort</code> method retrieves the communication port to which the external device is
    ///connected.
    ///Params:
    ///    pDevicePort = Pointer to a <b>long</b> integer that receives one of the following values, indicating the port to which the
    ///                  device is connected: <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>DEV_PORT_1394</td>
    ///                  <td>IEEE 1394 Bus</td> </tr> <tr> <td>DEV_PORT_ARTI</td> <td>ARTI driver</td> </tr> <tr>
    ///                  <td>DEV_PORT_COM1</td> <td>COM1</td> </tr> <tr> <td>DEV_PORT_COM2</td> <td>COM2</td> </tr> <tr>
    ///                  <td>DEV_PORT_COM3</td> <td>COM3</td> </tr> <tr> <td>DEV_PORT_COM4</td> <td>COM4</td> </tr> <tr>
    ///                  <td>DEV_PORT_DIAQ</td> <td>Diaquest driver</td> </tr> <tr> <td>DEV_PORT_SIM</td> <td>Simulation port</td>
    ///                  </tr> <tr> <td>DEV_PORT_USB</td> <td>Universal Serial Bus</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_DevicePort(int* pDevicePort);
}

///The <b>IAMExtTransport</b> interface controls the transport on a video tape recporder (VTR) or camcorder.
///Applications can use this interface to play, record, or stop the transport; determine whether the transport contains
///media; and other transport-related functions. The implementation of this interface can vary, depending on the device.
///Some methods might return E_NOTIMPL if the device does not support them. This interface also contains methods for
///non-linear editing through <i>edit events</i> and <i>edit property sets</i>. Currently, DirectShow does not provide
///any filters or drivers that implement this part of the interface.
@GUID("A03CD5F0-3045-11CF-8C44-00AA006B6814")
interface IAMExtTransport : IUnknown
{
    ///The <code>GetCapability</code> method retrieves the general capabilities of the transport.
    ///Params:
    ///    Capability = Specifies the capability to check. See Remarks for more information.
    ///    pValue = Pointer to a variable that receives a <b>long</b> integer. See Remarks for more information.
    ///    pdblValue = Pointer to a variable that receives a <b>double</b>. See Remarks for more information.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetCapability(int Capability, int* pValue, double* pdblValue);
    ///The <code>put_MediaState</code> method sets the current state of the media.
    ///Params:
    ///    State = Specifies the media state as a <b>long</b> integer. Use one of the following: <table> <tr> <th>Value </th>
    ///            <th>Description </th> </tr> <tr> <td>ED_MEDIA_SPIN_DOWN</td> <td>For disk media: Stop spinning. For tape
    ///            media: Unthread the tape.</td> </tr> <tr> <td>ED_MEDIA_SPIN_UP</td> <td>For disk media: Start spinning. For
    ///            tape media: Thread the tape.</td> </tr> <tr> <td>ED_MEDIA_UNLOAD</td> <td>Eject the media from the
    ///            drive.</td> </tr> </table> These constants are for disk and tape media. Other devices might need to define
    ///            new constants.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_MediaState(int State);
    ///The <code>get_MediaState</code> method retrieves the current state of the media. This method is not implemented.
    ///Params:
    ///    pState = Pointer to a <b>long</b> integer that receives one of the following values. <table> <tr> <th>Value </th>
    ///             <th>Description </th> </tr> <tr> <td>ED_MEDIA_SPIN_DOWN</td> <td>For disk media: Stopped spinning. For tape
    ///             media: Tape is unthreaded.</td> </tr> <tr> <td>ED_MEDIA_SPIN_UP</td> <td>For disk media: Started spinning,
    ///             but not at full speed. For tape media: Threading the tape.</td> </tr> <tr> <td>ED_MEDIA_UNLOAD</td> <td>Media
    ///             is ejected from the drive.</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_MediaState(int* pState);
    ///The <code>put_LocalControl</code> method switches the device between local and remote control. This method is not
    ///implemented.
    ///Params:
    ///    State = Specifies the state of the device. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>OATRUE</td> <td>Local control</td> </tr> <tr> <td>OAFALSE</td> <td>Remote control</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_LocalControl(int State);
    ///The <code>get_LocalControl</code> method determines whether the transport is under local control or remote
    ///control. This method is not implemented.
    ///Params:
    ///    pState = Pointer to a <b>long</b> integer that receives one of the following values: <table> <tr> <th>Value </th>
    ///             <th>Description </th> </tr> <tr> <td>OATRUE</td> <td>Local control.</td> </tr> <tr> <td>OAFALSE</td>
    ///             <td>Remote control.</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_LocalControl(int* pState);
    ///The <code>GetStatus</code> method returns information about the transport's status.
    ///Params:
    ///    StatusItem = Specifies the status information to retrieve. See Remarks for more information.
    ///    pValue = Pointer to variable that either specifies or receives a <b>long</b> integer, whose meaning depends on the
    ///             value of <i>StatusItem</i>. See Remarks for more information.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetStatus(int StatusItem, int* pValue);
    ///The <code>GetTransportBasicParameters</code> method retrieves general properties of the external transport.
    ///Params:
    ///    Param = Specifies which property to receive.
    ///    pValue = Pointer to a variable that receives a <b>long</b> integer value. See Remarks for more information.
    ///    ppszData = Pointer to a variable of type <b>LPOLESTR</b> that receives a string. See Remarks for more information.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetTransportBasicParameters(int Param, int* pValue, ushort** ppszData);
    ///The <code>SetTransportBasicParameters</code> method sets general properties of the transport.
    ///Params:
    ///    Param = Specifies which property to set. See Remarks for more information.
    ///    Value = Specifies the value of the property as a <b>long</b> integer. See Remarks for more information.
    ///    pszData = Specifies the value of the property as an <b>LPOLESTR</b>. See Remarks for more information.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code. Possible error
    ///    codes include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Device does not support setting this
    ///    property. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_DEVICE_REMOVED</b></dt> </dl> </td> <td
    ///    width="60%"> Device was removed. </td> </tr> </table>
    ///    
    HRESULT SetTransportBasicParameters(int Param, int Value, ushort* pszData);
    ///The <code>GetTransportVideoParameters</code> retrieves video parameter settings for external transport. This
    ///method is not implemented.
    ///Params:
    ///    Param = Specifies the video parameter to retrieve. Must be one of the following values. <table> <tr> <th>Value </th>
    ///            <th>Description </th> </tr> <tr> <td>ED_TRANSVIDEO_SET_OUTPUT</td> <td>Retrieves the output mode.</td> </tr>
    ///            <tr> <td>ED_TRANSVIDEO_SET_SOURCE</td> <td>Retrieves the input pin.</td> </tr> </table>
    ///    pValue = Specifies a pointer to a <b>long</b> integer to receive the video parameter. See Remarks for more
    ///             information.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetTransportVideoParameters(int Param, int* pValue);
    ///The <code>SetTransportVideoParameters</code> method assigns video parameters for external transport. This method
    ///is not implemented.
    ///Params:
    ///    Param = Specifies the video parameter to set. Must be one of the following values. <table> <tr> <th>Value </th>
    ///            <th>Description </th> </tr> <tr> <td>ED_TRANSVIDEO_SET_OUTPUT</td> <td>Sets the output mode.</td> </tr> <tr>
    ///            <td>ED_TRANSVIDEO_SET_SOURCE</td> <td>Sets the input pin.</td> </tr> </table>
    ///    Value = Specifies the value of the video parameter. See Remarks for more information.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetTransportVideoParameters(int Param, int Value);
    ///The <code>GetTransportAudioParameters</code> method retrieves audio parameter setting for external transport.
    ///This method is not implemented.
    ///Params:
    ///    Param = Specifies the audio parameter, whose value you want receive, as a <b>long</b> integer containing one of the
    ///            following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>ED_TRANSAUDIO_ENABLE_OUTPUT</td> <td>Audio output channel(s)</td> </tr> <tr>
    ///            <td>ED_TRANSAUDIO_ENABLE_RECORD</td> <td>Audio recording channel(s)</td> </tr> <tr>
    ///            <td>ED_TRANSAUDIO_ENABLE_SELSYNC</td> <td>Audio selsync recording channel(s)</td> </tr> <tr>
    ///            <td>ED_TRANSAUDIO_SET_MONITOR</td> <td>Monitor output audio channel(s)</td> </tr> <tr>
    ///            <td>ED_TRANSAUDIO_SET_SOURCE</td> <td>Audio source channel(s)</td> </tr> </table>
    ///    pValue = Specifies a pointer to a <b>long</b> integer to receive the channel or channels set in the
    ///             IAMExtTransport::SetTransportAudioParameters method.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetTransportAudioParameters(int Param, int* pValue);
    ///The <code>SetTransportAudioParameters</code> assigns audio parameter settings for external transport. This method
    ///is not implemented.
    ///Params:
    ///    Param = Specifies the audio parameter you want to set as a <b>long</b> integer. <table> <tr> <th>Value </th>
    ///            <th>Description </th> </tr> <tr> <td>ED_TRANSAUDIO_ENABLE_OUTPUT</td> <td>Enable audio channel(s) for
    ///            output.</td> </tr> <tr> <td>ED_TRANSAUDIO_ENABLE_RECORD</td> <td>Enable audio channel(s) for recording.</td>
    ///            </tr> <tr> <td>ED_TRANSAUDIO_ENABLE_SELSYNC</td> <td>Enable audio channel(s) for selsync recording.</td>
    ///            </tr> <tr> <td>ED_TRANSAUDIO_SET_MONITOR</td> <td>Set the monitor output source.</td> </tr> <tr>
    ///            <td>ED_TRANSAUDIO_SET_SOURCE</td> <td>Set the active audio input.</td> </tr> </table>
    ///    Value = Specifies which audio channel or channels is assigned the parameter as a <b>long</b> integer.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetTransportAudioParameters(int Param, int Value);
    ///The <b>put_Mode</b> method sets the transport mode; for example, play, stop, or record.
    ///Params:
    ///    Mode = Specifies the transport mode. Use one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///           </th> </tr> <tr> <td>ED_MODE_PLAY</td> <td>Play.</td> </tr> <tr> <td>ED_MODE_STOP</td> <td>Stop.</td> </tr>
    ///           <tr> <td>ED_MODE_FREEZE</td> <td>Pause.</td> </tr> <tr> <td>ED_MODE_THAW</td> <td>Resume.</td> </tr> <tr>
    ///           <td>ED_MODE_FF</td> <td>Fast forward.</td> </tr> <tr> <td>ED_MODE_REW</td> <td>Rewind.</td> </tr> <tr>
    ///           <td>ED_MODE_RECORD</td> <td>Record.</td> </tr> <tr> <td>ED_MODE_RECORD_FREEZE</td> <td>Pause recording.</td>
    ///           </tr> <tr> <td>ED_MODE_RECORD_STROBE</td> <td>Record single frame.</td> </tr> <tr> <td>ED_MODE_STEP_FWD</td>
    ///           <td>Single step forward.</td> </tr> <tr> <td>ED_MODE_STEP_REV</td> <td>Single step backward.</td> </tr> <tr>
    ///           <td>ED_MODE_SHUTTLE</td> <td>Shuttle (high-speed movement with visible picture). Use with
    ///           IAMExtTransport::put_Rate to set the transport speed.</td> </tr> <tr> <td>ED_MODE_EDIT_CUE</td> <td>Position
    ///           transport to the cue point for an active edit event.</td> </tr> <tr> <td>ED_MODE_LINK_ON</td> <td>Link this
    ///           method to the graph's IMediaControl::Run, IMediaControl::Stop, and IMediaControl::Pause methods.</td> </tr>
    ///           <tr> <td>ED_MODE_LINK_OFF</td> <td>Disengage this method from the graph's <b>IMediaControl</b> methods.</td>
    ///           </tr> </table>
    ///Returns:
    ///    Returns an HRESULT. Possible errors include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_REQ_NOT_ACCEP)</b></dt>
    ///    </dl> </td> <td width="60%"> The device did not accept the command. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT put_Mode(int Mode);
    ///The <code>get_Mode</code> method retrieves the current transport mode, such as play, stop, or record.
    ///Params:
    ///    pMode = Pointer to a <b>long</b> integer that receives the current transport mode. For possible values, see
    ///            IAMExtTransport::put_Mode.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_Mode(int* pMode);
    ///The <code>put_Rate</code> method sets the playback rate for variable-speed external devices. This method is not
    ///implemented.
    ///Params:
    ///    dblRate = Specifies the rate as a multiple of normal playback rate. For example, 0.5 specifies half speed, and 2.0
    ///              specifies double speed.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_Rate(double dblRate);
    ///The <code>get_Rate</code> method retrieves the playback rate for variable-speed external devices. This method is
    ///not implemented.
    ///Params:
    ///    pdblRate = Pointer to a <b>double</b> to receive the playback rate that was set using IAMExtTransport::put_Rate.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_Rate(double* pdblRate);
    ///The <code>GetChase</code> method retrieves the status of chase mode. This method is not implemented.
    ///Params:
    ///    pEnabled = Pointer to a <b>long</b> integer that receives one of the following values: <table> <tr> <th>Value </th>
    ///               <th>Description </th> </tr> <tr> <td>OATRUE</td> <td>Chase enabled.</td> </tr> <tr> <td>OAFALSE</td>
    ///               <td>Chase disabled.</td> </tr> </table>
    ///    pOffset = Pointer to a <b>long</b> integer that receives an offset from the present time, indicating the offset that
    ///              the transport will maintain while playing. The offset is given in the current time format; see
    ///              IAMExtTransport::SetTransportBasicParameters for more information.
    ///    phEvent = Pointer to a variable that receives an event handle. The event is signaled when the chase offset is
    ///              established.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetChase(int* pEnabled, int* pOffset, size_t* phEvent);
    ///The <code>SetChase</code> method enables or disables chase mode. This method is not implemented.
    ///Params:
    ///    Enable = Specifies whether chase is enabled as a <b>long</b> integer. <table> <tr> <th>Value </th> <th>Description
    ///             </th> </tr> <tr> <td>OATRUE</td> <td>Enable chase.</td> </tr> <tr> <td>OAFALSE</td> <td>Disable chase.</td>
    ///             </tr> </table>
    ///    Offset = Specifies the offset that the transport will maintain from a reference time. The offset is given in the
    ///             current time format; see IAMExtTransport::SetTransportBasicParameters for more information.
    ///    hEvent = Specifies a handle to an event. The device signals the event after it has established the signal offset.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetChase(int Enable, int Offset, size_t hEvent);
    ///The <code>GetBump</code> method retrieves the status of bump mode. This method is not implemented.
    ///Params:
    ///    pSpeed = Pointer to a <b>long</b> integer that receives the temporary bump speed, as a multiple of normal speed.
    ///    pDuration = Pointer to a <b>long</b> integer that receives the duration of a bump. The duration is given in the current
    ///                time format; see IAMExtTransport::SetTransportBasicParameters for more information.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetBump(int* pSpeed, int* pDuration);
    ///The <code>SetBump</code> method temporarily changes the playback, for synchronization of multiple external
    ///devices. This method is not implemented.
    ///Params:
    ///    Speed = Specifies the temporary speed (a multiple of normal speed) as a <b>long</b> integer.
    ///    Duration = Specifies the duration of a bump as a <b>long</b> integer. The duration is given in the current time format;
    ///               see IAMExtTransport::SetTransportBasicParameters for more information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT SetBump(int Speed, int Duration);
    ///The <code>get_AntiClogControl</code> method determines whether the anti-headclog control is enabled or disabled.
    ///This method is not implemented.
    ///Params:
    ///    pEnabled = Pointer to a <b>long</b> integer that receives one of the following values: <table> <tr> <th>Value </th>
    ///               <th>Description </th> </tr> <tr> <td>OATRUE</td> <td>Anti-headclog is enabled.</td> </tr> <tr>
    ///               <td>OAFALSE</td> <td>Anti-headclog is disabled.</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_AntiClogControl(int* pEnabled);
    ///The <code>put_AntiClogControl</code> method enables or disables anti-headclog control on the transport. This
    ///method is not implemented.
    ///Params:
    ///    Enable = Specifies whether to enable anti-headclog control. <table> <tr> <th>Value </th> <th>Description </th> </tr>
    ///             <tr> <td>OATRUE</td> <td>Enable transport anti-headclog control.</td> </tr> <tr> <td>OAFALSE</td> <td>Disable
    ///             transport anti-headclog control.</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_AntiClogControl(int Enable);
    ///The <code>GetEditPropertySet</code> method retrieves the state of an edit event. This method is not implemented.
    ///Params:
    ///    EditID = Specifies the edit property set. Use the identifier returned by the IAMExtTransport::SetEditPropertySet
    ///             method.
    ///    pState = Pointer to a <b>long</b> integer that receives the state of the edit property set: <table> <tr> <th>Value
    ///             </th> <th>Description </th> </tr> <tr> <td>ED_ACTIVE</td> <td>The edit property set is active.</td> </tr>
    ///             <tr> <td>ED_DELETE</td> <td>The edit property set was deleted.</td> </tr> <tr> <td>ED_INACTIVE</td> <td>The
    ///             edit property set is inactive.</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetEditPropertySet(int EditID, int* pState);
    ///The <code>SetEditPropertySet</code> method registers an edit property set that describes a group of edit
    ///properties. This method is not implemented.
    ///Params:
    ///    pEditID = Pointer to a <b>long</b> integer that specifies or receives an identifier for the edit property set.
    ///    State = Specifies the state of the edit property set. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>ED_ACTIVE</td> <td>Activates the edit property set.</td> </tr> <tr> <td>ED_DELETE</td> <td>Deletes the
    ///            edit property set.</td> </tr> <tr> <td>ED_INACTIVE</td> <td>Inactivates edit property set.</td> </tr> <tr>
    ///            <td>ED_REGISTER</td> <td>Registers the edit property set.</td> </tr> </table> If the value is ED_REGISTER,
    ///            the <i>pEditID</i> parameter receives an identifier for the edit property set. For the other flags, use the
    ///            <i>pEditID</i> parameter to specify the identifier.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetEditPropertySet(int* pEditID, int State);
    ///The <code>GetEditProperty</code> method retrieves parameters and values associated with an edit event. This
    ///method is not implemented.
    ///Params:
    ///    EditID = Specifies the edit property set. Use the identifier returned by the IAMExtTransport::SetEditPropertySet
    ///             method.
    ///    Param = Specifies the edit event parameter to retrieve.
    ///    pValue = pointer to a variable that receives the parameter value.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetEditProperty(int EditID, int Param, int* pValue);
    ///The <code>SetEditProperty</code> method defines parameters and values associated with an edit event. This method
    ///is not implemented.
    ///Params:
    ///    EditID = Specifies the edit property set. Use the identifier returned by the IAMExtTransport::SetEditPropertySet
    ///             method.
    ///    Param = Specifies the edit event parameter. See Remarks for more information.
    ///    Value = Specifies the value of the parameter. See Remarks for more information.
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetEditProperty(int EditID, int Param, int Value);
    ///The <code>get_EditStart</code> method determines whether the external transport's edit control is active. This
    ///method is not implemented.
    ///Params:
    ///    pValue = Specifies a pointer to a <b>long</b> integer to receive a value indicating whether the external transport's
    ///             edit control is active. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>OATRUE</td>
    ///             <td>Edit control is active.</td> </tr> <tr> <td>OAFALSE</td> <td>Edit control is inactive.</td> </tr>
    ///             </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_EditStart(int* pValue);
    ///The <code>put_EditStart</code> method activates the edit control on a capable transport. This method is not
    ///implemented.
    ///Params:
    ///    Value = Specifies whether to active the edit control. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>OATRUE</td> <td>Activates the edit control.</td> </tr> <tr> <td>OAFALSE</td> <td>Deactivates the edit
    ///            control.</td> </tr> </table>
    ///Returns:
    ///    When this method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_EditStart(int Value);
}

///The <b>IAMTimecodeReader</b> interface reads SMPTE or MIDI timecode from an external device. The MSDV and MSTape
///drivers support this interface for reading timecode from an external DV or MPEG-2 camcorder.
@GUID("9B496CE1-811B-11CF-8C77-00AA006B6814")
interface IAMTimecodeReader : IUnknown
{
    ///The <code>GetTCRMode</code> method retrieves the timecode reader's properties. This method is not implemented.
    ///Params:
    ///    Param = Timecode reader property to get (either ED_TCR_SOURCE or ED_TCR_NOTIFY_ENABLE).
    ///    pValue = Pointer to the value of the requested timecode reader property. If <i>Param</i> is set to
    ///             ED_TCR_NOTIFY_ENABLE, then this parameter will return OATRUE—meaning that notifications are enabled—or
    ///             OAFALSE. If <i>Param</i> is set to ED_TCR_SOURCE, then this value must be one of the following. <table> <tr>
    ///             <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_TCR_CT</td> <td>Control track</td> </tr> <tr>
    ///             <td>ED_TCR_LTC</td> <td>Linear timecode</td> </tr> <tr> <td>ED_TCR_VITC</td> <td>Vertical interval
    ///             timecode</td> </tr> <tr> <td>ED_TCR_LAST_VALUE</td> <td>Last read value</td> </tr> </table>
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT GetTCRMode(int Param, int* pValue);
    ///The <code>SetTCRMode</code> method sets the timecode reader properties. This method is not implemented.
    ///Params:
    ///    Param = Property you want to set (use ED_TCR_SOURCE or ED_TCR_NOTIFY_ENABLE).
    ///    Value = Value of the specified property; If <i>Param</i> returns ED_TCR_NOTIFY_ENABLE, then this value will return
    ///            OATRUE or OAFALSE. If <i>Param</i> returns ED_TCR_SOURCE, then this value must be one of the following.
    ///            <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_TCR_CT</td> <td>Control Track.</td>
    ///            </tr> <tr> <td>ED_TCR_LTC</td> <td>Linear Timecode.</td> </tr> <tr> <td>ED_TCR_VITC</td> <td>Vertical
    ///            Interval Timecode.</td> </tr> <tr> <td>ED_TCR_LAST_VALUE</td> <td>Return last read value.</td> </tr> </table>
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT SetTCRMode(int Param, int Value);
    ///The <code>put_VITCLine</code> method specifies the vertical interval line that the timecode reader will use to
    ///read timecode. This method is not implemented.
    ///Params:
    ///    Line = Vertical line containing timecode information (valid lines are 11-20; 0 means autoselect).
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT put_VITCLine(int Line);
    ///The <code>get_VITCLine</code> method retrieves the vertical interval line that the timecode reader is using to
    ///read timecode. This method is not implemented.
    ///Params:
    ///    pLine = Pointer to the vertical line containing timecode information (valid lines are from 11 through 20).
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT get_VITCLine(int* pLine);
    ///The <code>GetTimecode</code> method retrieves the most recent timecode, userbit, and flag values available in the
    ///stream.
    ///Params:
    ///    pTimecodeSample = Pointer to a TIMECODE_SAMPLE structure.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetTimecode(TIMECODE_SAMPLE* pTimecodeSample);
}

///The <code>IAMTimecodeGenerator</code> interface controls how an external SMPTE/MIDI timecode generator supplies data
///to the filter graph. DirectShow currently does not provide any filters that implement this interface. Third parties
///should implement this interface on any filter that controls an external timecode generator. Timecode generators can
///be built into a VCR or can be separate external devices. The device must be able to read timecode and send it to the
///computer over its control interface. If not, the user must have a timecode reader card in the computer, or you can
///write a software decoder that converts VITC embedded in captured video frames or LTC captured as an audio signal into
///DirectShow timecode samples. SMPTE timecode is a frame addressing system that identifies video and audio sources,
///makes automatic track synchronization possible, and provides a container for additional data related to the
///production. SMPTE timecode's main purpose is to provide a machine-readable address for video and audio. It is
///displayed in hh:mm:ss:ff format and is thoroughly defined in ANSI/SMPTE 12-1986. Optionally, you can enable
///applications to convert timecode to reference time by supporting the IMediaSeeking::ConvertTimeFormat method on the
///filter. <b>Hardware Requirements</b> For hardware requirements, see the IAMExtTransport interface.
@GUID("9B496CE0-811B-11CF-8C77-00AA006B6814")
interface IAMTimecodeGenerator : IUnknown
{
    ///The <code>GetTCGMode</code> method retrieves the SMPTE timecode generator properties.
    ///Params:
    ///    Param = Timecode generator mode. Specify one of the following modes you want to get settings for. <table> <tr>
    ///            <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_TCG_FRAMERATE</td> <td>Frame rate</td> </tr> <tr>
    ///            <td>ED_TCG_REFERENCE_SOURCE</td> <td>Source of the count value</td> </tr> <tr> <td>ED_TCG_SYNC_SOURCE</td>
    ///            <td>Source of the hardware clock reference</td> </tr> <tr> <td>ED_TCG_TIMECODE_TYPE</td> <td>SMPTE timecode
    ///            format of the generator</td> </tr> </table>
    ///    pValue = Pointer to the current setting of the mode specified in <i>Param</i>. If you specify ED_TCG_FRAMERATE in
    ///             <i>Param</i>, this parameter retrieves one of the following. <table> <tr> <th>Value </th> <th>Description
    ///             </th> </tr> <tr> <td>ED_FORMAT_SMPTE_24</td> <td>24 frames per second.</td> </tr> <tr>
    ///             <td>ED_FORMAT_SMPTE_25</td> <td>25 frames per second.</td> </tr> <tr> <td>ED_FORMAT_SMPTE_30</td> <td>30
    ///             frames per second. Nondrop frame.</td> </tr> <tr> <td>ED_FORMAT_SMPTE_30DROP</td> <td>30 frames per second.
    ///             Drop frame (actually 29.97 fps).</td> </tr> </table> If you specify ED_TCG_REFERENCE_SOURCE in <i>Param</i>,
    ///             this parameter retrieves one of the following. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///             <td>ED_TCG_FREE</td> <td>No count reference source.</td> </tr> <tr> <td>ED_TCG_READER</td> <td>Synchronize to
    ///             reader value (jamsync).</td> </tr> </table> If you specify ED_TCG_SYNC_SOURCE in <i>Param</i>, this parameter
    ///             retrieves one of the following. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///             <td>ED_TCG_FREE</td> <td>Lock to nothing (freerun).</td> </tr> <tr> <td>ED_TCG_READER</td> <td>Lock to
    ///             timecode reader.</td> </tr> <tr> <td>ED_TCG_VIDEO</td> <td>Lock to incoming video.</td> </tr> </table> If you
    ///             specify ED_TCG_TIMECODE_TYPE in <i>Param</i>, this parameter retrieves one of the following. <table> <tr>
    ///             <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_TCG_MIDI_FULL</td> <td>MIDI full frame timecode</td>
    ///             </tr> <tr> <td>ED_TCG_MIDI_QF</td> <td>MIDI quarter frame timecode</td> </tr> <tr> <td>ED_TCG_SMPTE_LTC</td>
    ///             <td>Linear timecode</td> </tr> <tr> <td>ED_TCG_SMPTE_VITC</td> <td>Vertical interval timecode</td> </tr>
    ///             </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetTCGMode(int Param, int* pValue);
    ///The <code>SetTCGMode</code> method sets the SMPTE timecode generator properties.
    ///Params:
    ///    Param = Timecode generator mode. Specify one of the following modes. <table> <tr> <th>Value </th> <th>Description
    ///            </th> </tr> <tr> <td>ED_TCG_FRAMERATE</td> <td>Frame rate</td> </tr> <tr> <td>ED_TCG_REFERENCE_SOURCE</td>
    ///            <td>Source of the count value</td> </tr> <tr> <td>ED_TCG_SYNC_SOURCE</td> <td>Source of the hardware clock
    ///            reference</td> </tr> <tr> <td>ED_TCG_TIMECODE_TYPE</td> <td>SMPTE timecode format of the generator</td> </tr>
    ///            </table>
    ///    Value = Setting of the mode specified in <i>Param</i>. If ED_TCG_FRAMERATE is specified in <i>Param</i>, this
    ///            parameter is set to one of the following. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>ED_FORMAT_SMPTE_24</td> <td>24 frames per second.</td> </tr> <tr> <td>ED_FORMAT_SMPTE_25</td> <td>25
    ///            frames per second.</td> </tr> <tr> <td>ED_FORMAT_SMPTE_30</td> <td>30 frames per second. Nondrop frame.</td>
    ///            </tr> <tr> <td>ED_FORMAT_SMPTE_30DROP</td> <td>30 frames per second. Drop frame (actually 29.97 frames per
    ///            second).</td> </tr> </table> If ED_TCG_REFERENCE_SOURCE is specified in <i>Param</i>, set one of the
    ///            following. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_TCG_FREE</td> <td>No count
    ///            reference source.</td> </tr> <tr> <td>ED_TCG_READER</td> <td>Sync to reader value (jamsync).</td> </tr>
    ///            </table> If ED_TCG_SYNC_SOURCE is specified in <i>Param</i>, set one of the following. <table> <tr> <th>Value
    ///            </th> <th>Description </th> </tr> <tr> <td>ED_TCG_FREE</td> <td>Lock to nothing (freerun).</td> </tr> <tr>
    ///            <td>ED_TCG_READER</td> <td>Lock to timecode reader.</td> </tr> <tr> <td>ED_TCG_VIDEO</td> <td>Lock to
    ///            incoming video.</td> </tr> </table> If ED_TCG_TIMECODE_TYPE is specified in <i>Param</i>, set one of the
    ///            following. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_TCG_MIDI_FULL</td> <td>MIDI
    ///            Full Frame timecode</td> </tr> <tr> <td>ED_TCG_MIDI_QF</td> <td>MIDI quarter frame timecode</td> </tr> <tr>
    ///            <td>ED_TCG_SMPTE_LTC</td> <td>Linear timecode</td> </tr> <tr> <td>ED_TCG_SMPTE_VITC</td> <td>Vertical
    ///            interval timecode</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT SetTCGMode(int Param, int Value);
    ///The <code>put_VITCLine</code> method specifies which line to insert the vertical interval timecode information
    ///into.
    ///Params:
    ///    Line = Vertical line to contain the timecode information (valid lines are 11-20; 0 means autoselect).
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT put_VITCLine(int Line);
    ///The <code>get_VITCLine</code> method retrieves which line(s) the vertical interval timecode information has been
    ///inserted into.
    ///Params:
    ///    pLine = Pointer to the vertical line(s) containing the timecode information (valid lines are 11-20).
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT get_VITCLine(int* pLine);
    ///The <code>SetTimecode</code> method sets the timecode, userbit value, or both.
    ///Params:
    ///    pTimecodeSample = Pointer to a TIMECODE_SAMPLE structure.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT SetTimecode(TIMECODE_SAMPLE* pTimecodeSample);
    ///The <code>GetTimecode</code> method retrieves the most recent timecode and/or userbit value available in the
    ///stream.
    ///Params:
    ///    pTimecodeSample = Pointer to a TIMECODE_SAMPLE structure.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetTimecode(TIMECODE_SAMPLE* pTimecodeSample);
}

///The <code>IAMTimecodeDisplay</code> interface controls an external SMPTE/MIDI timecode display device. DirectShow
///currently does not provide any filters that implement this interface. Third parties should implement this interface
///on any filter that controls the timecode display of an external timecode reader or generator. Timecode readers or
///generators can be built into a VCR or can be separate external devices. This interface is not intended for rendering
///in a DirectShow filter graph; it is purely for use on external device displays. <b>Hardware Requirements</b> See the
///IAMExtTransport interface for hardware requirements.
@GUID("9B496CE2-811B-11CF-8C77-00AA006B6814")
interface IAMTimecodeDisplay : IUnknown
{
    ///The <code>GetTCDisplayEnable</code> method determines whether an external device's timecode character generator
    ///output is enabled or disabled.
    ///Params:
    ///    pState = Pointer to a value indicating whether timecode character generator output is enabled. OATRUE indicates
    ///             enabled; OAFALSE indicates disabled.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetTCDisplayEnable(int* pState);
    ///The <code>SetTCDisplayEnable</code> method enables or disables an external device's timecode character output
    ///generator.
    ///Params:
    ///    State = Value specifying whether to enable or disable the timecode character output generator. Specify OATRUE to
    ///            enable or OAFALSE to disable.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT SetTCDisplayEnable(int State);
    ///The <code>GetTCDisplay</code> method retrieves current settings of the timecode character generator output.
    ///Params:
    ///    Param = Timecode display characteristic. Specify one of the following items you want to get settings for. <table>
    ///            <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_TCD_BORDER</td> <td>White border for black
    ///            characters, black border for white characters.</td> </tr> <tr> <td>ED_TCD_INTENSITY</td> <td>Intensity
    ///            (brightness) of characters.</td> </tr> <tr> <td>ED_TCD_INVERT</td> <td>Black characters on white background
    ///            or white characters on black background.</td> </tr> <tr> <td>ED_TCD_POSITION</td> <td>Position of
    ///            characters.</td> </tr> <tr> <td>ED_TCD_SIZE</td> <td>Size of characters.</td> </tr> <tr>
    ///            <td>ED_TCD_SOURCE</td> <td>Source of display's data.</td> </tr> <tr> <td>ED_TCD_TRANSPARENCY</td>
    ///            <td>Transparency of characters.</td> </tr> </table>
    ///    pValue = Pointer to the current setting of the parameter specified in <i>Param</i>. This parameter retrieves one of
    ///             the following values. If ED_TCD_SOURCE specified in <i>Param</i>, will return one of the following. <table>
    ///             <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_TCG</td> <td>Timecode generator</td> </tr> <tr>
    ///             <td>ED_TCR</td> <td>Timecode reader</td> </tr> </table> If ED_TCD_SIZE specified in <i>Param</i>, will return
    ///             one of the following. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_LARGE</td>
    ///             <td>Large</td> </tr> <tr> <td>ED_MED</td> <td>Medium</td> </tr> <tr> <td>ED_SMALL</td> <td>Small</td> </tr>
    ///             </table> If ED_TCD_POSITION specified in <i>Param</i>, will return one of the following. <table> <tr>
    ///             <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_BOTTOM</td> <td>Bottom</td> </tr> <tr>
    ///             <td>ED_MIDDLE</td> <td>Middle</td> </tr> <tr> <td>ED_TOP</td> <td>Top</td> </tr> </table> in combination with
    ///             one of the following. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_CENTER</td>
    ///             <td>Center</td> </tr> <tr> <td>ED_LEFT</td> <td>Left</td> </tr> <tr> <td>ED_RIGHT</td> <td>Right</td> </tr>
    ///             </table> If ED_TCD_INTENSITY specified in <i>Param</i>, will return one of the following. <table> <tr>
    ///             <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_HIGH</td> <td>High</td> </tr> <tr> <td>ED_LOW</td>
    ///             <td>Low</td> </tr> </table> If ED_TCD_TRANSPARENCY is specified in <i>Param</i>, will return a value from 0
    ///             to 4, 0 being completely opaque. If ED_TCD_INVERT is specified in <i>Param</i>, will return one of the
    ///             following. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>OAFALSE</td> <td>Black
    ///             characters on white background</td> </tr> <tr> <td>OATRUE</td> <td>White characters on black background</td>
    ///             </tr> </table> If ED_TCD_BORDER specified in <i>Param</i>, will return one of the following. <table> <tr>
    ///             <th>Value </th> <th>Description </th> </tr> <tr> <td>OAFALSE</td> <td>Black characters for white border</td>
    ///             </tr> <tr> <td>OATRUE</td> <td>White border for black characters</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetTCDisplay(int Param, int* pValue);
    ///The <code>SetTCDisplay</code> method sets the timecode character generator output characteristics.
    ///Params:
    ///    Param = Timecode display characteristic. Specify one of the following properties you want to set properties for.
    ///            <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_TCD_BORDER</td> <td>White border for
    ///            black characters, black border for white characters</td> </tr> <tr> <td>ED_TCD_INTENSITY</td> <td>Intensity
    ///            (brightness) of characters</td> </tr> <tr> <td>ED_TCD_INVERT</td> <td>Black characters on white background or
    ///            white characters on black background</td> </tr> <tr> <td>ED_TCD_POSITION</td> <td>Position of characters</td>
    ///            </tr> <tr> <td>ED_TCD_SIZE</td> <td>Size of characters</td> </tr> <tr> <td>ED_TCD_SOURCE</td> <td>Source of
    ///            the display's data</td> </tr> <tr> <td>ED_TCD_TRANSPARENCY</td> <td>Transparency of characters</td> </tr>
    ///            </table>
    ///    Value = Setting of the parameter specified in <i>Param</i>. Must be one of the following: If ED_TCD_SOURCE specified
    ///            in <i>Param</i>, set one of the following. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>ED_TCG</td> <td>Timecode generator</td> </tr> <tr> <td>ED_TCR</td> <td>Timecode reader</td> </tr>
    ///            </table> If ED_TCD_SIZE is specified in <i>Param</i>, set one of the following. <table> <tr> <th>Value </th>
    ///            <th>Description </th> </tr> <tr> <td>ED_LARGE</td> <td>Large</td> </tr> <tr> <td>ED_MED</td> <td>Medium</td>
    ///            </tr> <tr> <td>ED_SMALL</td> <td>Small</td> </tr> </table> If ED_TCD_POSITION specified in <i>Param</i>, set
    ///            one of the following. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_BOTTOM</td>
    ///            <td>Bottom</td> </tr> <tr> <td>ED_MIDDLE</td> <td>Middle</td> </tr> <tr> <td>ED_TOP</td> <td>Top</td> </tr>
    ///            </table> in combination with one of the following. <table> <tr> <th>Value </th> <th>Description </th> </tr>
    ///            <tr> <td>ED_CENTER</td> <td>Center</td> </tr> <tr> <td>ED_LEFT</td> <td>Left</td> </tr> <tr>
    ///            <td>ED_RIGHT</td> <td>Right</td> </tr> </table> If ED_TCD_INTENSITY is specified in <i>Param</i>, set one of
    ///            the following. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>ED_HIGH</td> <td>High</td>
    ///            </tr> <tr> <td>ED_LOW</td> <td>Low</td> </tr> </table> If ED_TCD_TRANSPARENCY is specified in <i>Param</i>,
    ///            set a value from 0 to 4, 0 being completely opaque, 4 being as dark as possible. If ED_TCD_INVERT is
    ///            specified in <i>Param</i>, set one of the following. <table> <tr> <th>Value </th> <th>Description </th> </tr>
    ///            <tr> <td>OAFALSE</td> <td>Black on white</td> </tr> <tr> <td>OATRUE</td> <td>White on black</td> </tr>
    ///            </table> If ED_TCD_BORDER is specified in <i>Param</i>, set one of the following. <table> <tr> <th>Value
    ///            </th> <th>Description </th> </tr> <tr> <td>OAFALSE</td> <td>Black characters for white border</td> </tr> <tr>
    ///            <td>OATRUE</td> <td>White border for black characters</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT SetTCDisplay(int Param, int Value);
}

///<div class="alert"><b>Note</b> This interface is no longer supported by the AVI Splitter.</div> <div> </div> <div
///class="alert"><b>Note</b> This interface was defined to support older hardware decoders that required AVI files to be
///read into directly hardware memory. The interface enables the AVI parser to allocate memory from the downstream
///filter but still provide its own allocator.</div> <div> </div> Implement this interface when your pin must support
///the creation of on-board memory allocators. Source filters that are aware of on-board memory and need to create their
///own allocators should query for this interface, request an amount of memory and then create an allocator (aggregating
///the device memory control object). Source filters that don't need to create their own allocator could just use the
///allocator of the downstream pin (which also aggregates the device memory control object). The hardware-based filter
///can confirm the usage of its on-board memory by calling methods on the aggregated allocator. Use this interface when
///applications need to control the memory of codecs with on-board memory.
@GUID("C6545BF0-E76B-11D0-BD52-00A0C911CE86")
interface IAMDevMemoryAllocator : IUnknown
{
    ///<div class="alert"><b>Note</b> The <b>IAMDevMemoryAllocator</b> interface is deprecated.</div> <div> </div>
    ///Retrieves information about the memory capabilities.
    ///Params:
    ///    pdwcbTotalFree = Pointer to the total free memory size.
    ///    pdwcbLargestFree = Pointer to the returned largest free memory size.
    ///    pdwcbTotalMemory = Pointer to the returned total memory size.
    ///    pdwcbMinimumChunk = Pointer to the returned minimum chunk size, giving granularity and alignment rules.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetInfo(uint* pdwcbTotalFree, uint* pdwcbLargestFree, uint* pdwcbTotalMemory, uint* pdwcbMinimumChunk);
    ///<div class="alert"><b>Note</b> The <b>IAMDevMemoryAllocator</b> interface is deprecated.</div> <div> </div> Tests
    ///whether the specific instance (device) of the allocator allocated a memory pointer.
    ///Params:
    ///    pBuffer = Pointer to the allocated memory buffer's address.
    ///Returns:
    ///    Returns S_OK if the on-board allocator allocated the memory, or S_FALSE if not. Memory that is on the
    ///    particular device but not allocated will also return S_FALSE.
    ///    
    HRESULT CheckMemory(const(ubyte)* pBuffer);
    ///<div class="alert"><b>Note</b> The <b>IAMDevMemoryAllocator</b> interface is deprecated.</div> <div> </div>
    ///Allocates a memory buffer.
    ///Params:
    ///    ppBuffer = Pointer that will receive the address of the allocated memory buffer.
    ///    pdwcbBuffer = Pointer to a <b>DWORD</b> whose input value is the number of bytes to allocate and whose output value is the
    ///                  actual number of bytes allocated.
    ///Returns:
    ///    Returns S_OK if the desired quantity of memory was allocated, S_FALSE if memory was unavailable.
    ///    
    HRESULT Alloc(ubyte** ppBuffer, uint* pdwcbBuffer);
    ///<div class="alert"><b>Note</b> The <b>IAMDevMemoryAllocator</b> interface is deprecated.</div> <div> </div> Frees
    ///the previously allocated memory.
    ///Params:
    ///    pBuffer = Pointer to the allocated memory.
    ///Returns:
    ///    Returns E_INVALIDARG if the specified allocator didn't allocate the memory (that is, CheckMemory fails).
    ///    
    HRESULT Free(ubyte* pBuffer);
    ///<div class="alert"><b>Note</b> The <b>IAMDevMemoryAllocator</b> interface is deprecated.</div> <div> </div>
    ///Retrieves an <b>IUnknown</b> interface pointer to a device memory control object that can be aggregated with a
    ///custom allocator.
    ///Params:
    ///    ppUnkInnner = Address of a pointer to the newly created control object's own <b>IUnknown</b>. This inner <b>IUnknown</b>
    ///                  interface should be released when the outer object is destroyed. The custom allocator should call the
    ///                  <b>QueryInterface</b> method on this pointer to obtain the IAMDevMemoryControl interface.
    ///    pUnkOuter = Pointer to the custom allocator's own <b>IUnknown</b> interface. This interface aggregates the device memory
    ///                control object inside the custom allocator.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetDevMemoryObject(IUnknown* ppUnkInnner, IUnknown pUnkOuter);
}

///<div class="alert"><b>Note</b> This interface is no longer supported by the AVI Splitter.</div> <div> </div> <div
///class="alert"><b>Note</b> It was defined to support certain older hardware decoders that required AVI files to be
///read directly into hardware memory. The interface enables the AVI parser to allocate memory from the downstream
///filter but still provide its own allocator. There should be no need for any newer devices to support this
///interface.</div> <div> </div> A device memory control object supports <code>IAMDevMemoryControl</code>. This object
///is aggregated with an IMemAllocator object that is used in the connection. Typically, filters will call the
///IAMDevMemoryAllocator::GetDevMemoryObject method to obtain a pointer to this interface. Implement this interface with
///the IAMDevMemoryAllocator interface when pins need to have greater control of memory allocation. Use this interface
///to synchronize the completion of writing data to a memory allocator, and to get the device ID of the on-board memory
///allocator.
@GUID("C6545BF1-E76B-11D0-BD52-00A0C911CE86")
interface IAMDevMemoryControl : IUnknown
{
    ///<div class="alert"><b>Note</b> The <b>IAMDevMemoryControl</b> interface is deprecated.</div> <div> </div> Checks
    ///if the memory supported by the allocator requires the use of the IAMDevMemoryControl::WriteSync method.
    ///Returns:
    ///    Returns S_OK if the method is required, or S_FALSE otherwise.
    ///    
    HRESULT QueryWriteSync();
    ///<div class="alert"><b>Note</b> The <b>IAMDevMemoryControl</b> interface is deprecated.</div> <div> </div> Used to
    ///synchronize with the completed write. This method returns when any data being written to the particular allocator
    ///region is fully written into the memory.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> A
    ///    time-out has occurred without this method confirming that data was written. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The data was successfully written into memory. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_COMMITTED</b></dt> </dl> </td> <td width="60%"> The
    ///    allocator hasn't called the IMemAllocator::Commit method. </td> </tr> </table>
    ///    
    HRESULT WriteSync();
    ///<div class="alert"><b>Note</b> The <b>IAMDevMemoryControl</b> interface is deprecated.</div> <div> </div>
    ///Retrieves the device ID of the on-board memory allocator.
    ///Params:
    ///    pdwDevId = Pointer to the device ID.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetDevId(uint* pdwDevId);
}

///The <code>IAMStreamSelect</code> interface selects from the available streams on a parser filter. For example, a file
///might contain audio streams encoded in several languages, such as English, German, and French. The application could
///use this interface to select which language is played.
@GUID("C1960960-17F5-11D1-ABE1-00A0C905F375")
interface IAMStreamSelect : IUnknown
{
    ///The <code>Count</code> method retrieves the number of available streams.
    ///Params:
    ///    pcStreams = Receives the number of streams.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The pins are not connected. </td> </tr> </table>
    ///    
    HRESULT Count(uint* pcStreams);
    ///The <code>Info</code> method retrieves information about a given stream.
    ///Params:
    ///    lIndex = Zero-based index of the stream.
    ///    ppmt = Address of a variable that receives a pointer to the stream's media type. This parameter is optional and can
    ///           be <b>NULL</b>. If the value is non-<b>NULL</b>, the method returns a pointer to an AM_MEDIA_TYPE structure.
    ///           The caller must delete the structure, including the format block. (You can use the DeleteMediaType function
    ///           from the DirectShow base-class library.)
    ///    pdwFlags = Pointer to a variable that receives one of the following values: <table> <tr> <th>Value </th> <th>Description
    ///               </th> </tr> <tr> <td>Zero</td> <td>This stream is disabled.</td> </tr> <tr>
    ///               <td>AMSTREAMSELECTINFO_ENABLED</td> <td>The stream is enabled, and others in this group might be enabled
    ///               too.</td> </tr> <tr> <td>AMSTREAMSELECTINFO_EXCLUSIVE</td> <td>This stream is the only enabled stream in the
    ///               group.</td> </tr> </table> This parameter is optional and can be <b>NULL</b>.
    ///    plcid = Pointer to a variable that receives a locale context (LCID) value. If the stream is associated with a
    ///            particular locale, the LCID is returned in this variable. Otherwise, the variable receives the value zero.
    ///            This parameter is optional and can be <b>NULL</b>.
    ///    pdwGroup = Pointer to a variable that receives the logical group with which the stream is associated. This parameter is
    ///               optional and can be <b>NULL</b>.
    ///    ppszName = Address of a variable that receives a pointer to the stream name. The caller must free the returned string by
    ///               calling the <b>CoTaskMemFree</b> function. This parameter is optional and can be <b>NULL</b>.
    ///    ppObject = Address of a variable that receives an <b>IUnknown</b> interface pointer. The method might return a pointer
    ///               to a pin or filter associated with the stream, or it might return the value <b>NULL</b>. If the method
    ///               returns a non-<b>NULL</b> value, the caller must release the <b>IUnknown</b> pointer. Calling the
    ///               IAMStreamSelect::Enable method might invalidate the object returned by this method. This parameter is
    ///               optional and can be <b>NULL</b>. The MPEG-1 Stream Splitter, MPEG-2 Splitter, and SAMI (CC) Parser filters
    ///               return a pointer to the pin associated with the selected stream.
    ///    ppUnk = Address of a variable that receives an <b>IUnknown</b> interface pointer. The method might return a pointer
    ///            to an interface that is specific to the stream, or it might return the value <b>NULL</b>. If the method
    ///            returns a non-<b>NULL</b> value, the caller must release the <b>IUnknown</b> pointer. This parameter is
    ///            optional and can be <b>NULL</b>. The MPEG-1 Stream Splitter, MPEG-2 Splitter, and SAMI (CC) Parser filters
    ///            all return the value <b>NULL</b>. Third party filters might return a pointer to a custom filter interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> The index is out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT Info(int lIndex, AM_MEDIA_TYPE** ppmt, uint* pdwFlags, uint* plcid, uint* pdwGroup, ushort** ppszName, 
                 IUnknown* ppObject, IUnknown* ppUnk);
    ///The <code>Enable</code> method enables or disables a given stream.
    ///Params:
    ///    lIndex = Zero-based index of the stream.
    ///    dwFlags = Flag indicating whether to enable or disable the stream. Use one of the following values. <table> <tr>
    ///              <th>Value </th> <th>Description </th> </tr> <tr> <td>Zero</td> <td>Disable all streams in the group
    ///              containing this stream.</td> </tr> <tr> <td>AMSTREAMSELECTENABLE_ENABLE</td> <td>Enable only this stream
    ///              within the given group and disable all others.</td> </tr> <tr> <td>AMSTREAMSELECTENABLE_ENABLEALL</td>
    ///              <td>Enable all streams in the group containing this stream.</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid stream ID. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> The filter does not support the specified flag. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pins are not connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT Enable(int lIndex, uint dwFlags);
}

///The <code>IAMResourceControl</code> interface opens and holds an audio device resource before the device is actually
///needed, so that playback can be guaranteed or the application can learn in advance that a device is not available.
///The following filters implement this interface: <ul> <li> Audio Capture filter.</li> <li> DirectSound Renderer
///filter.</li> <li> Audio Renderer (WaveOut) filter.</li> </ul>
@GUID("8389D2D0-77D7-11D1-ABE6-00A0C905F375")
interface IAMResourceControl : IUnknown
{
    ///The <code>Reserve</code> method reserves or unreserves a device resource.
    ///Params:
    ///    dwFlags = Flag indicating whether to reserve or unreserve this device. The value must be a member of the
    ///              AMRESCTL_RESERVEFLAGS enumeration.
    ///    pvReserved = Must be <b>NULL</b>.
    ///Returns:
    ///    Returns S_OK if the device was successfully reserved or unreserved, S_FALSE if the device is currently
    ///    reserved and will continue to be held, or an <b>HRESULT</b> error code if the device can't be reserved.
    ///    
    HRESULT Reserve(uint dwFlags, void* pvReserved);
}

///The <code>IAMClockAdjust</code> interface adjusts the reference clock. The System Reference Clock exposes this
///interface.
@GUID("4D5466B0-A49C-11D1-ABE8-00A0C905F375")
interface IAMClockAdjust : IUnknown
{
    ///The <code>SetClockDelta</code> method adjusts the clock time.
    ///Params:
    ///    rtDelta = Specifies the amount by which to adjust the clock, as a REFERENCE_TIME value. A positive value moves the
    ///              clock forward, and a negative value moves the clock backward.
    ///Returns:
    ///    Returns S_OK or an <b>HRESULT</b> error code.
    ///    
    HRESULT SetClockDelta(long rtDelta);
}

///The <code>IAMFilterMiscFlags</code> interface queries whether a filter is a source filter or a renderer. Source and
///renderer filters should implement this interface. Applications do not use this interface. The Filter Graph Manager
///uses this interface to determine how many EC_COMPLETE events it will receive when playback completes.
@GUID("2DD74950-A890-11D1-ABE8-00A0C905F375")
interface IAMFilterMiscFlags : IUnknown
{
    ///The <code>GetMiscFlags</code> method returns the filter's type, either source or renderer.
    ///Returns:
    ///    This method returns a member of the _AM_FILTER_MISC_FLAGS enumeration.
    ///    
    uint GetMiscFlags();
}

///<div class="alert"><b>Note</b> This interface has been deprecated. New applications should not use it.</div> <div>
///</div> The <code>IDrawVideoImage</code> interface enables an application to draw the same video image in multiple
///places simultaneously on the screen. The Video Renderer filter exposes this interface. The Video Mixing Renderer
///(VMR) filter provides a better way to accomplish the same effect, through the use of multiple input streams. To use
///this interface, call <b>DrawVideoImageBegin</b> to put the Video Renderer into GDI mode. Then the application can
///call the <b>DrawVideoImageDraw</b> method as often as necessary. The renderer simply takes the current video frame
///and draws it to the specified rectangle. This process is asynchronous to the delivery of frames to the renderer on
///the filter graph thread. The application is responsible for the frame rate at which it renders images; this rate will
///never be the same as the rate of the frames being delivered to the filter. In other words, calling this method is
///like taking a periodic shapshot of the video and putting it into a device context of your choosing at a rate of your
///choosing.
@GUID("48EFB120-AB49-11D2-AED2-00A0C995E8D5")
interface IDrawVideoImage : IUnknown
{
    ///<div class="alert"><b>Note</b> This interface has been deprecated. New applications should not use it.</div>
    ///<div> </div> The <code>DrawVideoImageBegin</code> method turns off DirectDraw in preparation for a call to the
    ///<b>DrawVideoImageDraw</b> method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT DrawVideoImageBegin();
    ///<div class="alert"><b>Note</b> This interface has been deprecated. New applications should not use it.</div>
    ///<div> </div> The <code>DrawVideoImageEnd</code> method turns DirectDraw back on after drawing has been performed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT DrawVideoImageEnd();
    ///<div class="alert"><b>Note</b> This interface has been deprecated. New applications should not use it.</div>
    ///<div> </div> The <code>DrawVideoImageDraw</code> method draws the specified source rectangle to the specified
    ///destination rectangle in the specified GDI device context.
    ///Params:
    ///    hdc = Specifies the device context.
    ///    lprcSrc = Pointer to a <b>RECT</b> structure that specifies the source rectangle, as a subrectangle of the current
    ///              video frame.
    ///    lprcDst = Pointer to a <b>RECT</b> structure that specifies the destination rectangle in the device context.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT DrawVideoImageDraw(HDC hdc, RECT* lprcSrc, RECT* lprcDst);
}

///The <code>IDecimateVideoImage</code> interface specifies decimation on a decoder filter. The term <i>decimation</i>
///refers to scaling the video output down to a size smaller than the native size of the video. Applications must not
///call methods on this interface. The Overlay Mixer filter uses this interface to decimate video at the video decoder.
///Decoder filters that can decimate their video output should support this interface.
@GUID("2E5EA3E0-E924-11D2-B6DA-00A0C995E8DF")
interface IDecimateVideoImage : IUnknown
{
    ///The <code>SetDecimationImageSize</code> method specifies the dimensions to which the decoder should decimate its
    ///output image.
    ///Params:
    ///    lWidth = Specifies the width of the video image, in pixels.
    ///    lHeight = Specifies the height of the video image, in pixels.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The decoder cannot
    ///    perform any decimation, or needs to halt decimation it is currently performing. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The decoder can decimate the video to the
    ///    requested size. </td> </tr> </table>
    ///    
    HRESULT SetDecimationImageSize(int lWidth, int lHeight);
    ///The <code>ResetDecimationImageSize</code> method specifies that the decoder should no longer decimate its output
    ///image.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value indicating the success or failure of the call.
    ///    
    HRESULT ResetDecimationImageSize();
}

///The <code>IAMVideoDecimationProperties</code> interface controls how the Overlay Mixer performs video decimation If a
///video window is smaller than the native size of the video being displayed, the video renderer must <i>decimate</i>
///the incoming video—that is, scale the video down to the smaller size. Decimation can be performed in one of the
///following places. <ul> <li>The overlay hardware on the VGA chip.</li> <li>The scaler built in to the video port (if
///the connection is through a video port).</li> <li>The decoder supplying video to the renderer.</li> </ul> An
///application can call methods on this interface to select a particular decimation strategy, in order to optimize
///performance. However, most applications will have no occasion to use this interface. Unless your application is
///designed to support particular hardware, there is no reason to modify the Overlay Mixer filter's default behavior for
///decimation.
@GUID("60D32930-13DA-11D3-9EC6-C4FCAEF5C7BE")
interface IAMVideoDecimationProperties : IUnknown
{
    ///The <code>QueryDecimationUsage</code> method retrieves the current decimation strategy.
    ///Params:
    ///    lpUsage = Pointer to a variable of type [DECIMATION_USAGE](/windows/desktop/api/strmif/ne-strmif-decimation_usage) that
    ///              receives the decimation setting.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. The DirectShow
    ///    implementation returns S_OK if successful, or E_FAIL or another error code otherwise.
    ///    
    HRESULT QueryDecimationUsage(DECIMATION_USAGE* lpUsage);
    ///The <code>SetDecimationUsage</code> method sets the decimation strategy.
    ///Params:
    ///    Usage = Member of the [DECIMATION_USAGE](/windows/desktop/api/strmif/ne-strmif-decimation_usage) enumeration that
    ///            specifies the decimation strategy.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. The DirectShow
    ///    implementation returns S_OK if successful, or E_INVALIDARG otherwise.
    ///    
    HRESULT SetDecimationUsage(DECIMATION_USAGE Usage);
}

///The <code>IVideoFrameStep</code> interface steps through a video stream. This interface enables Microsoft®
///DirectShow® applications, including DVD players, to step through a video stream as slowly as one frame at a time.
///Obtain the interface through the filter graph manager, which controls the frame stepping process in conjunction with
///the Overlay Mixer Filter or the Video Renderer Filter. Backward frame stepping is not supported. <div
///class="alert"><b>Note</b> For frame stepping to work with a hardware decoder, the decoder must support the Frame
///Stepping Property Set.</div> <div> </div>
@GUID("E46A9787-2B71-444D-A4B5-1FAB7B708D6A")
interface IVideoFrameStep : IUnknown
{
    ///The <code>Step</code> method causes the filter graph to step forward by the specified number of frames.
    ///Params:
    ///    dwFrames = Specifies the number of frames to skip. If <i>dwFrames</i> is 1, the graph steps forward one frame. If
    ///               <i>dwFrames</i> is a number <i>n</i> greater than 1, the graph skips <i>n</i> - 1 frames and shows the
    ///               <i>n</i>th frame.
    ///    pStepObject = Pointer to an interface on the filter that will control the stepping operation, or <b>NULL</b>. Specify
    ///                  <b>NULL</b> to perform the frame stepping using the renderer filter in the graph. If non-<b>NULL</b>, the
    ///                  object must implement the IKsPropertySet interface and support the AM_KSPROPSETID_FrameStep property. (For
    ///                  more information, see Frame Stepping Property Set.) If the graph includes a custom filter that implements the
    ///                  frame stepping, <i>pStepObject</i> can specify a pointer to that filter.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_FRAME_STEP_UNSUPPORTED</b></dt> </dl> </td> <td
    ///    width="60%"> Frame stepping is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pStepObject</i> parameter is invalid. </td>
    ///    </tr> </table>
    ///    
    HRESULT Step(uint dwFrames, IUnknown pStepObject);
    ///The <code>CanStep</code> method determines the stepping capabilities of the specified filter.
    ///Params:
    ///    bMultiple = If <i>bMultiple</i> is zero and the method returns S_OK, the graph can step one frame at a time. If
    ///                <i>bMultiple</i> if greater than zero and the method returns S_OK, the graph can step <i>bMultiple</i> frames
    ///                at a time.
    ///    pStepObject = Pointer to an interface on the filter that will control the stepping operation. Specify <b>NULL</b> to
    ///                  perform frame stepping using the renderer filter in the graph. If the graph includes a custom filter that
    ///                  implements the frame stepping, then <i>pStepObject</i> should specify that filter's IBaseFilter interface.
    ///Returns:
    ///    Returns S_OK if the object can step or E_INVALIDARG if <i>pStepObject</i> is invalid.
    ///    
    HRESULT CanStep(int bMultiple, IUnknown pStepObject);
    ///The <code>CancelStep</code> method cancels the previous IVideoFrameStep::Step operation.
    ///Returns:
    ///    Returns S_OK if the <b>Step</b> operation was successfully canceled, or E_FAIL otherwise.
    ///    
    HRESULT CancelStep();
}

///The <code>IAMLatency</code> interface reports the amount of latency that a filter introduces into the graph. Latency
///is defined as the time that it takes the filter to process a sample. For a source filter, latency is the filter's
///maximum buffer size, measured in time. For example, a video capture filter that buffers one frame at 30 frames per
///second introduces a latency of about 33 milliseconds. Currently, there is no support for using this interface by
///itself. A source filter that streams live or real-time data should implement the IAMPushSource interface, which
///inherits from this interface.
@GUID("62EA93BA-EC62-11D2-B770-00C04FB6BD3D")
interface IAMLatency : IUnknown
{
    ///The <code>GetLatency</code> method retrieves the expected latency associated with this filter.
    ///Params:
    ///    prtLatency = Pointer to a variable that receives the latency in 100-nanosecond units.
    ///Returns:
    ///    Returns S_OK if successsful, or an error code otherwise.
    ///    
    HRESULT GetLatency(long* prtLatency);
}

///The <code>IAMPushSource</code> interface synchronizes a filter graph that renders a live source. A live source is a
///source that streams data in real time, such as a capture device or a network broadcast. Source filters that stream
///live data should expose this interface on their output pins. Generally, applications should not call the methods on
///this interface; instead, use the IAMGraphStreams interface.
@GUID("F185FE76-E64E-11D2-B76E-00C04FB6BD3D")
interface IAMPushSource : IAMLatency
{
    ///The <code>GetPushSourceFlags</code> method retrieves a combination of flags describing the behavior of the
    ///filter.
    ///Params:
    ///    pFlags = Pointer to a variable that receives a combination of flags from the AM_PUSHSOURCE_FLAGS enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetPushSourceFlags(uint* pFlags);
    ///The <code>SetPushSourceFlags</code> method sets flags that specify the behavior of the filter. Currently,
    ///applications should not call this method, because request flags are not supported and an application should not
    ///override the flags set by the filter.
    ///Params:
    ///    Flags = Combination of flags from the AM_PUSHSOURCE_FLAGS enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT SetPushSourceFlags(uint Flags);
    ///The <code>SetStreamOffset</code> method sets the offset for time stamps generated by this filter.
    ///Params:
    ///    rtOffset = New stream offset for the filter.
    ///Returns:
    ///    Returns S_FALSE if the specified offset is larger than the filter's maximum preferred offset. Otherwise,
    ///    returns S_OK if successful or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT SetStreamOffset(long rtOffset);
    ///The <code>GetStreamOffset</code> method retrieves the offset that the filter uses when generating time stamps.
    ///Params:
    ///    prtOffset = Pointer to a variable that receives a reference time indicating the current stream offset.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT GetStreamOffset(long* prtOffset);
    ///The <code>GetMaxStreamOffset</code> method retrieves the maximum stream offset the filter can support.
    ///Params:
    ///    prtMaxOffset = Pointer to a variable that receives a reference time indicating the maximum offset the filter can support.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. The DirectShow
    ///    implementation returns E_POINTER or S_OK.
    ///    
    HRESULT GetMaxStreamOffset(long* prtMaxOffset);
    ///The <code>SetMaxStreamOffset</code> method specifies the stream offset that will be allowed in the filter graph.
    ///Params:
    ///    rtMaxOffset = Reference time specifying the maximum stream offset.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT SetMaxStreamOffset(long rtMaxOffset);
}

///The <code>IAMDeviceRemoval</code> interface provides a way for the Filter Graph Manager to register for device
///removal events for a capture device. The KsProxy filter exposes this interface. (See WDM Video Capture Filter.)
///Applications typically do not use this interface, and third-party filters do not need to implement this interface. To
///get a pointer to this interface, call <b>QueryInterface</b> on the KsProxy filter.
@GUID("F90A6130-B658-11D2-AE49-0000F8754B99")
interface IAMDeviceRemoval : IUnknown
{
    ///The <code>DeviceInfo</code> method retrieves information about the device.
    ///Params:
    ///    pclsidInterfaceClass = Receives a GUID that specifies the device interface class.
    ///    pwszSymbolicLink = Receives a pointer to a string that contains the Plug and Play (PnP) device path for the device. The caller
    ///                       must release the string by calling CoTaskMemFree. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT DeviceInfo(GUID* pclsidInterfaceClass, ushort** pwszSymbolicLink);
    ///The <code>Reassociate</code> method reassociates the KsProxy filter with the device. The Filter Graph Manager
    ///calls this method if it receives a notification that the device has returned after being removed.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT Reassociate();
    ///The <code>Disassociate</code> method disassociates the KsProxy filter from the device by closing the device
    ///handle. The Filter Graph Manager calls this method if it receives a notification that the device was removed.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT Disassociate();
}

///The <code>IDVEnc</code> interface sets and retrieves properties on the DV Video Encoder filter.
@GUID("D18E17A0-AACB-11D0-AFB0-00AA00B67A42")
interface IDVEnc : IUnknown
{
    ///The <b>get_IFormatResolution</b> method retrieves the encoding resolution.
    ///Params:
    ///    VideoFormat = Pointer to a variable that receives a member of the DVENCODERVIDEOFORMAT enumeration, specifying the video
    ///                  standard in use (NTSC or PAL).
    ///    DVFormat = Pointer to a variable that receives a member of the DVENCODERFORMAT enumeration, specifying the digital video
    ///               (DV) format.
    ///    Resolution = Pointer to a variable that receives a member of the DVENCODERRESOLUTION enumeration, specifying the video
    ///                 resolution.
    ///    fDVInfo = Boolean value specifying whether to retrieve the DVINFO structure that specifies the stream format. If
    ///              <b>TRUE</b>, the stream format is returned in the <i>sDVInfo</i> parameter.
    ///    sDVInfo = Pointer to a variable that receives a <b>DVINFO</b> structure containing the stream format. If <i>fDVInfo</i>
    ///              is <b>FALSE</b>, this parameter is ignored.
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns E_FAIL or another error code.
    ///    
    HRESULT get_IFormatResolution(int* VideoFormat, int* DVFormat, int* Resolution, ubyte fDVInfo, DVINFO* sDVInfo);
    ///The <code>put_IFormatResolution</code> method sets the encoding resolution.
    ///Params:
    ///    VideoFormat = Member of the DVENCODERVIDEOFORMAT enumeration, specifying the video standard to use (NTSC or PAL).
    ///    DVFormat = Member of the DVENCODERFORMAT enumeration, specifying the DV format.
    ///    Resolution = Member of the DVENCODERRESOLUTION enumeration, specifying the video resolution.
    ///    fDVInfo = Boolean value specifying whether the <i>sDVInfo</i> parameter contains a valid DVINFO structure. To set the
    ///              stream format, set this parameter to <b>TRUE</b> and specify the format chunk with the <i>sDVInfo</i>
    ///              parameter.
    ///    sDVInfo = If <i>fDVInfo</i> is <b>TRUE</b>, must point to a <b>DVINFO</b> structure that describes the stream format.
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns E_FAIL or another error code.
    ///    
    HRESULT put_IFormatResolution(int VideoFormat, int DVFormat, int Resolution, ubyte fDVInfo, DVINFO* sDVInfo);
}

///The <code>IIPDVDec</code> interface provides methods for setting and retrieving properties on the DV Video Decoder
///filter.
@GUID("B8E8BD60-0BFE-11D0-AF91-00AA00B67A42")
interface IIPDVDec : IUnknown
{
    ///The <code>get_IPDisplay</code> method gets the decoding resolution.
    ///Params:
    ///    displayPix = Receives a member of the DVDECODERRESOLUTION enumerated type, specifying the decoding resolution.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT get_IPDisplay(int* displayPix);
    ///The <code>put_IPDisplay</code> method sets the decoding resolution.
    ///Params:
    ///    displayPix = Member of the DVDECODERRESOLUTION enumerated type, specifying the decoding resolution. The meaning of this
    ///                 value depends on whether the current format is NTSC or PAL. The filter determines at run time which format
    ///                 applies, based on the media type.
    ///Returns:
    ///    Returns S_OK if successful; otherwise, returns E_FAIL or another error code.
    ///    
    HRESULT put_IPDisplay(int displayPix);
}

///The <code>IDVRGB219</code> interface controls the dynamic range in the DV Video Encoder and DV Video Decoder filters.
@GUID("58473A19-2BC8-4663-8012-25F81BABDDD1")
interface IDVRGB219 : IUnknown
{
    ///The <code>SetRGB219</code> method controls the dynamic range for DV encoding and decoding. The DV video format
    ///has a dynamic range of 16–235. By default, when the DV Video Decoder decodes to 24-bit or 32-bit RGB, it
    ///stretches the color range to 0–255. Similarly, the DV Video Encoder compresses 24-bit RGB into the 16-235
    ///range. In RGB-219 mode, the decoder does not stretch the color range, and the encoder does not compress the color
    ///range. Use the <code>SetRGB219</code> method to toggle between the default mode and RGB-219 mode.
    ///Params:
    ///    bState = Boolean value that specifies the filter's encoding or decoder behavior. <table> <tr> <th>Value </th>
    ///             <th>Description </th> </tr> <tr> <td><b>TRUE</b></td> <td>Enable RGB-219 mode.</td> </tr> <tr>
    ///             <td><b>FALSE</b></td> <td>Disable RGB-219 mode. Use the default mode.</td> </tr> </table>
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns an <b>HRESULT</b> failure code.
    ///    
    HRESULT SetRGB219(BOOL bState);
}

///Downgrades the frame rate on a digital video (DV) stream. The DV Splitter filter exposes this interface. Applications
///can use this interface to reduce the frame rate on a DV stream, before the stream reaches the DV Video Decoder
///filter. This can be helpful for processor-intensive tasks, such as real-time transcoding.
@GUID("92A3A302-DA7C-4A1F-BA7E-1802BB5D2D02")
interface IDVSplitter : IUnknown
{
    ///The <b>DiscardAlternateVideoFrames</b> method discards half of the frames in the video stream. For NTSC, the
    ///frame rate is reduced from 30 frames per second (fps) to 15 fps. For PAL, the frame rate is reduced from 25 fps
    ///to 12.5 fps.
    ///Params:
    ///    nDiscard = Flag that specifies whether to discard frames. If the value is non-zero, the filter discards alternate
    ///               frames. If the value is zero, the filter delivers every frame.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Filter is paused or running. </td> </tr> </table>
    ///    
    HRESULT DiscardAlternateVideoFrames(int nDiscard);
}

///The <code>IAMAudioRendererStats</code> interface retrieves statistical performance information from an audio renderer
///filter. This interface is intended for use during development, to log performance data from the audio renderer. There
///is probably no reason for an application to use it in a retail build. The Audio Renderer (WaveOut) filter and the
///DirectSound Renderer filter both expose this interface. <b>Filter Developers</b>: It is not expected that other
///filters will implement this interface.
@GUID("22320CB2-D41A-11D2-BF7C-D7CB9DF0BF93")
interface IAMAudioRendererStats : IUnknown
{
    ///The <code>GetStatParam</code> method retrieves performance information from the audio renderer.
    ///Params:
    ///    dwParam = Specifies a member of the _AM_AUDIO_RENDERER_STAT_PARAM enumeration, indicating which information to
    ///              retrieve.
    ///    pdwParam1 = Pointer to a variable that receives performance information. The meaning of the returned value depends on the
    ///                value of <i>dwParam</i>.
    ///    pdwParam2 = Pointer to a variable that receives performance information. The meaning of the returned value depends on the
    ///                value of <i>dwParam</i>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> The renderer does not track the specified information. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetStatParam(uint dwParam, uint* pdwParam1, uint* pdwParam2);
}

///The <code>IAMGraphStreams</code> interface controls a filter graph that renders a live source. A live source is one
///that streams data in real time, such as a capture device or a network broadcast. The Filter Graph Manager implements
///this interface. Applications can use this interface to specify how the graph handles latency and synchronization when
///it renders a live source. For more information, see Live Sources.
@GUID("632105FA-072E-11D3-8AF9-00C04FB6BD3D")
interface IAMGraphStreams : IUnknown
{
    ///The <code>FindUpstreamInterface</code> method searches the filter graph for a specified interface, upstream from
    ///a specified pin.
    ///Params:
    ///    pPin = Pointer to the IPin interface of a pin. The pin must belong to a filter in the filter graph.
    ///    riid = Reference to an interface identifier (IID) that specifies the interface to find.
    ///    ppvInterface = Address of a void pointer. If the method succeeds, this variable receives a pointer to the interface
    ///                   specified by <i>riid</i>.
    ///    dwFlags = Combination of flags from the AM_INTF_SEARCH_FLAGS enumeration, specifying what to search (pins or filters).
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> Interface not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> </table>
    ///    
    HRESULT FindUpstreamInterface(IPin pPin, const(GUID)* riid, void** ppvInterface, uint dwFlags);
    ///The <code>SyncUsingStreamOffset</code> method enables or disables synchronization using time-stamp offsets.
    ///Params:
    ///    bUseStreamOffset = Boolean value indicating whether to use a time-stamp offset. If <b>TRUE</b>, live sources will use a
    ///                       time-stamp offset to synchronize streams.
    ///Returns:
    ///    Returns S_OK if successsful, or an error code otherwise.
    ///    
    HRESULT SyncUsingStreamOffset(BOOL bUseStreamOffset);
    ///The <code>SetMaxGraphLatency</code> method sets the maximum latency for the graph. You must call the
    ///IAMGraphStreams::SyncUsingStreamOffset method before calling this method.
    ///Params:
    ///    rtMaxGraphLatency = Specifies the maximum latency in 100-nanosecond units.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success
    ///    </td> </tr> </table>
    ///    
    HRESULT SetMaxGraphLatency(long rtMaxGraphLatency);
}

///The <code>IAMOverlayFX</code> interface controls how the video overlay appears on the user's screen. The Overlay
///Mixer filter implements this interface.
@GUID("62FAE250-7E65-4460-BFC9-6398B322073C")
interface IAMOverlayFX : IUnknown
{
    ///The <code>QueryOverlayFXCaps</code> method retrieves information about which overlay effects are available to the
    ///Overlay Mixer filter.
    ///Params:
    ///    lpdwOverlayFXCaps = Pointer to a variable that receives a value indicating the overlay effects capabilities of the overlay
    ///                        surface. The value is a logical combination of flags from the AMOVERLAYFX enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. The DirectShow
    ///    implementation returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> </table>
    ///    
    HRESULT QueryOverlayFXCaps(uint* lpdwOverlayFXCaps);
    ///The <code>SetOverlayFX</code> method applies the specified effects to the overlay surface.
    ///Params:
    ///    dwOverlayFX = Value specifying which effects to apply. The value must be a logical combination of flags from the
    ///                  AMOVERLAYFX enumeration, or the method returns E_INVALIDARG.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. The DirectShow
    ///    implementation may return one of the following values, or others not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetOverlayFX(uint dwOverlayFX);
    ///The <code>GetOverlayFX</code> method retrieves the effects currently applied to the overlay surface, if any. The
    ///application can call this method while the filter graph is running.
    ///Params:
    ///    lpdwOverlayFX = Pointer a variable that receives a value indicating which effects, if any, are currently applied to the
    ///                    overlay surface. The value is a logical combination of flags from the AMOVERLAYFX enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. The DirectShow
    ///    implementation returns S_OK if successful, or E_POINTER to indicate a <b>NULL</b> pointer argument.
    ///    
    HRESULT GetOverlayFX(uint* lpdwOverlayFX);
}

///The <code>IAMOpenProgress</code> interface reports the progress of a file-open operation and enables the application
///to cancel the operation. Filters that open files over a network can expose this interface. An application can use it
///to query the progress of the download, or to cancel the download. If the network is not responsive, a method such as
///IGraphBuilder::RenderFile might block for an indefinite period. To prevent your application from blocking, create a
///worker thread that uses <code>IAMOpenProgress</code> to monitor the progress. The worker thread can cancel the
///operation if a predefined timeout occurs, or in response to a command from the user. The File Source (URL) filter
///supports this interface.
@GUID("8E1C39A1-DE53-11CF-AA63-0080C744528D")
interface IAMOpenProgress : IUnknown
{
    ///The <code>QueryProgress</code> method retrieves the progress of the file-open operation.
    ///Params:
    ///    pllTotal = Pointer to a variable that receives the length of the entire file, in bytes.
    ///    pllCurrent = Pointer to a variable that receives the length of the downloaded portion of the file, in bytes.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_S_ESTIMATED</b></dt> </dl> </td>
    ///    <td width="60%"> The returned values are estimates. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. </td> </tr> </table>
    ///    
    HRESULT QueryProgress(long* pllTotal, long* pllCurrent);
    ///The <code>AbortOperation</code> method cancels the file-open operation.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT AbortOperation();
}

///This interface is implemented on the MPEG-2 Demultiplexer filter (Demux) and is used in both program stream mode and
///transport stream mode. It is called by applications or other filters to create, configure and delete output pins on
///the Demux. This interface is not exposed when the filter is playing back a file (pull-mode).
@GUID("436EEE9C-264F-4242-90E1-4E330C107512")
interface IMpeg2Demultiplexer : IUnknown
{
    ///The <code>CreateOutputPin</code> method creates a new output pin on the Demux.
    ///Params:
    ///    pMediaType = Pointer to an AM_MEDIA_TYPE structure that specifies the media type information for the new pin.
    ///    pszPinName = Pointer to a wide character string that specifies a name for the new pin. The maximum length is 128
    ///                 characters, including the <b>NULL</b> terminator.
    ///    ppIPin = Address of a variable that receives a pointer to the pin's IPin interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible return values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DUPLICATE_NAME</b></dt> </dl> </td>
    ///    <td width="60%"> Duplicate pin name. </td> </tr> </table>
    ///    
    HRESULT CreateOutputPin(AM_MEDIA_TYPE* pMediaType, const(wchar)* pszPinName, IPin* ppIPin);
    ///The <code>SetOutputPinMediaType</code> method updates the media type of the specified output pin. (DirectX 9.0
    ///and later.)
    ///Params:
    ///    pszPinName = The friendly name of the pin as specified when the pin was created in a call to <b>CreateOutputPin</b>.
    ///    pMediaType = Pointer to an AM_MEDIA_TYPE structure that specifies the new media type information for the pin.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetOutputPinMediaType(const(wchar)* pszPinName, AM_MEDIA_TYPE* pMediaType);
    ///The <code>DeleteOutputPin</code> method deletes the specified output pin.
    ///Params:
    ///    pszPinName = The friendly name of the pin as specified when the pin was created in a call to <b>CreateOutputPin</b>.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT DeleteOutputPin(const(wchar)* pszPinName);
}

///The <code>IEnumStreamIdMap</code> interface is implemented on a standard COM collection of Stream ID maps that have
///been created by the MPEG-2 Demultiplexer's IMPEG2StreamIdMap::MapStreamId method. To obtain a pointer to this
///interface, use the IMPEG2StreamIdMap::EnumStreamIdMap method. Typically, an output pin will never have more than one
///stream ID mapped to it at any given time. This collection represents a snapshot of the Stream IDs mapped at the time
///the collection is created. The collection is not updated automatically.
@GUID("945C1566-6202-46FC-96C7-D87F289C6534")
interface IEnumStreamIdMap : IUnknown
{
    ///The <code>Next</code> method retrieves the next <i>n</i> elements in the collection.
    ///Params:
    ///    cRequest = The number of elements to retrieve.
    ///    pStreamIdMap = Address of a user-allocated array containing <i>cRequest</i> elements that will receive the retrieved
    ///                   STREAM_ID_MAP structures.
    ///    pcReceived = Receives the number of elements actually retrieved.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails,an <b>HRESULT</b> error code is returned.
    ///    
    HRESULT Next(uint cRequest, char* pStreamIdMap, uint* pcReceived);
    ///The <code>Skip</code> method skip the element at the specified index.
    ///Params:
    ///    cRecords = Index of the element to skip.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, an <b>HRESULT</b> error code is returned.
    ///    
    HRESULT Skip(uint cRecords);
    ///The <code>Reset</code> method moves the iterator to the beginning of the collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails,an <b>HRESULT</b> error code is returned.
    ///    
    HRESULT Reset();
    ///The <code>Clone</code> method copies the collection.
    ///Params:
    ///    ppIEnumStreamIdMap = Receives a pointer to the IEnumStreamIdMap interface of the new collection object. The caller must release
    ///                         the interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails,an <b>HRESULT</b> error code is returned.
    ///    
    HRESULT Clone(IEnumStreamIdMap* ppIEnumStreamIdMap);
}

///This interface is implemented on each output pin of the MPEG-2 Demultiplexer filter (Demux) and is used in program
///stream mode only. It is called by applications or other filters to associate the pin with a specified Stream ID and
///to inform the pin whether substream filtering is required on the stream. This interface is not exposed when the
///filter is playing back a file (pull-mode). For transport streams, use the IMPEG2PIDMap interface.
@GUID("D0E04C47-25B8-4369-925A-362A01D95444")
interface IMPEG2StreamIdMap : IUnknown
{
    ///The <code>MapStreamId</code> method maps the Stream ID of an elementary stream within an MPEG-2 program stream to
    ///a media content type and substream filtering information.
    ///Params:
    ///    ulStreamId = The stream ID of the PES stream.
    ///    MediaSampleContent = Specifies the contents of the stream. Currently the only value supported is MPEG2_PROGRAM_ELEMENTARY_STREAM
    ///                         (defined as 0x00000001 in axextend.idl).
    ///    ulSubstreamFilterValue = Specifies which substream within this elementary stream to pass on to the downstream decoder. Only the
    ///                             low-order byte can contain a valid filter value. If <i>iDataOffset</i> = 0, this parameter is ignored.
    ///    iDataOffset = The byte offset into the payload at which the substream begins.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, an error code is returned. If a Stream ID of
    ///    MEDIA_PROGRAM_STREAM_MAP, MEDIA_PROGRAM_DIRECTORY_PES_PACKET or MEDIA_PROGRAM_PACK_HEADER is attempted, this
    ///    method returns E_NOTIMPL.
    ///    
    HRESULT MapStreamId(uint ulStreamId, uint MediaSampleContent, uint ulSubstreamFilterValue, int iDataOffset);
    ///The <code>UnmapStreamId</code> method unmaps the Stream ID mapping created in a previous call to
    ///<b>MapStreamId</b>.
    ///Params:
    ///    culStreamId = The number of elements in the <i>pulStreamID</i> array.
    ///    pulStreamId = Array of Stream IDs mapped for this pin.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT UnmapStreamId(uint culStreamId, char* pulStreamId);
    ///The <code>EnumStreamIdMap</code> method returns a collection of all the mapped Stream IDs on this pin.
    ///Params:
    ///    ppIEnumStreamIdMap = IEnumStreamIdMap interface pointer that will be set to the returned collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT EnumStreamIdMap(IEnumStreamIdMap* ppIEnumStreamIdMap);
}

///The <code>IRegisterServiceProvider</code> interface registers an object as a service with the Filter Graph Manager.
///For more information, see IRegisterServiceProvider::RegisterService.
@GUID("7B3A2F01-0751-48DD-B556-004785171C54")
interface IRegisterServiceProvider : IUnknown
{
    ///The <code>RegisterService</code> method registers an object as a service.
    ///Params:
    ///    guidService = Service identifier (SID) of the service.
    ///    pUnkObject = Pointer to the <b>IUnknown</b> interface of the service object, or <b>NULL</b> to unregister the service.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT RegisterService(const(GUID)* guidService, IUnknown pUnkObject);
}

///The <code>IAMClockSlave</code> interface controls the tolerance of an audio renderer when it is matching rates with
///another clock. If the audio renderer is matching rates with another clock, it allows the audio to drift up to the
///amount of the specified tolerance. If the audio drifts too far ahead, the renderer drops samples; if it drifts too
///far behind, the renderer inserts silent gaps. This interface enables an application to change the tolerance from the
///default. Setting a larger tolerance is likely to result in the audio stream becoming out of sync with the video
///stream. Setting a smaller tolerance can cause audio jitter. Therefore, changing the tolerance setting is not
///recommended, unless you have a specific reason to do so.
@GUID("9FD52741-176D-4B36-8F51-CA8F933223BE")
interface IAMClockSlave : IUnknown
{
    ///The <code>SetErrorTolerance</code> method sets the audio renderer's rate-matching tolerance.
    ///Params:
    ///    dwTolerance = Specifies the maximum tolerance, in milliseconds. The value must be from 1 to 1000, inclusive.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_STOPPED</b></dt> </dl> </td> <td width="60%"> The
    ///    filter graph is not stopped. </td> </tr> </table>
    ///    
    HRESULT SetErrorTolerance(uint dwTolerance);
    ///The <code>GetErrorTolerance</code> method retrieves the audio renderer's rate-matching tolerance.
    ///Params:
    ///    pdwTolerance = Pointer to a variable that receives the maximum tolerance, in milliseconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetErrorTolerance(uint* pdwTolerance);
}

///The <code>IAMGraphBuilderCallback</code> interface provides a callback mechanism during graph building. To use this
///interface, implement the interface in your application or client object. Query the Filter Graph Manager for the
///<b>IObjectWithSite</b> interface and call the <b>IObjectWithSite::SetSite</b> method with a pointer to your
///implementation of the interface. The Filter Graph Manager calls the methods on this interface while it builds the
///graph, which gives the client the opportunity to modify the graph-building process. The primary use for this
///interface is to configure the Video Mixing Renderer filter before it is connected. You can also use it reject a
///specific filter during graph building, such as a decoder filter.
@GUID("4995F511-9DDB-4F12-BD3B-F04611807B79")
interface IAMGraphBuilderCallback : IUnknown
{
    ///The Filter Graph Manager calls this method when it finds a candidate filter for the graph, but before it creates
    ///the filter.
    ///Params:
    ///    pMon = Pointer to a moniker that contains information about the filter.
    ///Returns:
    ///    If the method returns a success code, the Filter Graph Manager creates the filter and tries to connect it. If
    ///    the method returns a failure code, the Filter Graph Manager rejects the filter.
    ///    
    HRESULT SelectedFilter(IMoniker pMon);
    ///The Filter Graph Manager calls this method after it has created a filter, but before it attempts to connect the
    ///filter.
    ///Params:
    ///    pFil = Pointer to the IBaseFilter interface of the filter.
    ///Returns:
    ///    If the method returns a success code, the Filter Graph Manager tries to connect the filter. If the method
    ///    returns a failure code, the Filter Graph Manager rejects the filter.
    ///    
    HRESULT CreatedFilter(IBaseFilter pFil);
}

///The <code>IAMFilterGraphCallback</code> interface provides a callback mechanism during graph building. To use this
///interface, implement the interface in your application or client object. Query the Filter Graph Manager for the
///<b>IObjectWithSite</b> interface and call the <b>IObjectWithSite::SetSite</b> method with a pointer to your
///implementation of the interface. During graph building, if the Filter Graph Manager fails to render a pin, it calls
///the <b>UnabletoRender</b> method. The client can then take appropriate action, such as providing an error message for
///the user or registering a new filter.
interface IAMFilterGraphCallback : IUnknown
{
    ///The <code>UnableToRender</code> method is called by the Filter Graph Manager if it cannot find any combination of
    ///filters to render the specified pin.
    ///Params:
    ///    pPin = Specifies the IPin interface of the pin that could not be rendered.
    ///Returns:
    ///    If the return value is S_OK, this Filter Graph Manager attempts to render the pin again. For any other return
    ///    value, including S_FALSE and other success codes, the Filter Graph Manager continues to build the graph as
    ///    normal. Typically it will reject the current filter and attempt to use a different filter.
    ///    
    HRESULT UnableToRender(IPin pPin);
}

///The <b>IGetCapabilitiesKey</b> interface enables an application to retrieve the capabilities of a software or
///hardware codec from the registry, without creating an instance of the encoder filter. The moniker for the codec
///filter exposes this interface. For more information, see Encoder API.
@GUID("A8809222-07BB-48EA-951C-33158100625B")
interface IGetCapabilitiesKey : IUnknown
{
    ///The <b>GetCapabilitiesKey</b> method gets a registry key that contains capability information for the codec.
    ///Params:
    ///    pHKey = Receives a handle to the registry key. The caller must close the handle by calling <b>RegCloseKey</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)</b></dt> </dl> </td> <td
    ///    width="60%"> There is no capabilities key for this codec. </td> </tr> </table>
    ///    
    HRESULT GetCapabilitiesKey(HKEY* pHKey);
}

///<p class="CCE_Message">[<b>IEncoderAPI</b> is no longer available for use. Instead, use ICodecAPI.] The
///<b>IEncoderAPI</b> interface defines a standard way for applications and drivers to communicate with third-party
///hardware or software encoders that implement the interface. For more information on this interface, see Encoder API.
@GUID("70423839-6ACC-4B23-B079-21DBF08156A5")
interface IEncoderAPI : IUnknown
{
    ///<p class="CCE_Message">[IEncoderAPI is no longer available for use. Instead, use ICodecAPI.] The
    ///<b>IsSupported</b> method queries whether a given parameter is supported.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the parameter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The encoder supports the parameter. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The encoder does not support the
    ///    parameter. </td> </tr> </table>
    ///    
    HRESULT IsSupported(const(GUID)* Api);
    ///<p class="CCE_Message">[IEncoderAPI is no longer available for use. Instead, use ICodecAPI.] The
    ///<b>IsAvailable</b> method queries whether a given parameter can be read and modified.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the parameter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The parameter can be read and modified. (Set and get
    ///    operations are supported for this parameter.) </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The parameter cannot be read or modified. </td> </tr>
    ///    </table>
    ///    
    HRESULT IsAvailable(const(GUID)* Api);
    ///<p class="CCE_Message">[IEncoderAPI is no longer available for use. Instead, use ICodecAPI.] The
    ///<b>GetParameterRange</b> method retrieves the valid range of values that the parameter supports, in cases where
    ///the parameter supports a stepped range as opposed to a list of specific values.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the parameter.
    ///    ValueMin = Pointer to a <b>VARIANT</b> type that receives the minimum value of the parameter.
    ///    ValueMax = Pointer to a <b>VARIANT</b> type that receives the maximum value of the parameter.
    ///    SteppingDelta = Pointer to a <b>VARIANT</b> type that receives the stepping delta, which defines the valid increments from
    ///                    <i>ValueMin</i> to <i>ValueMax</i>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The property supports a
    ///    list of possible values, not a linear range. </td> </tr> </table>
    ///    
    HRESULT GetParameterRange(const(GUID)* Api, VARIANT* ValueMin, VARIANT* ValueMax, VARIANT* SteppingDelta);
    ///<p class="CCE_Message">[IEncoderAPI is no longer available for use. Instead, use ICodecAPI.] The
    ///<b>GetParameterValues</b> method retrieves the list of values supported by the given parameter.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the parameter.
    ///    Values = Address of a pointer to an array that receives the values.
    ///    ValuesCount = Indicates the number of entries placed into the array.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetParameterValues(const(GUID)* Api, char* Values, uint* ValuesCount);
    ///<p class="CCE_Message">[IEncoderAPI is no longer available for use. Instead, use ICodecAPI.] The
    ///<b>GetDefaultValue</b> method retrieves the default value for a parameter, if one exists.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the parameter.
    ///    Value = Receives the value for the parameter specified in <i>Api</i>. If <i>Api</i> was specified as
    ///            ENCAPIPARAM_BITRATE_MODE, then <i>Value</i> will be one of the VIDEOENCODER_BITRATE_MODE constants.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDefaultValue(const(GUID)* Api, VARIANT* Value);
    ///<p class="CCE_Message">[IEncoderAPI is no longer available for use. Instead, use ICodecAPI.] The <b>GetValue</b>
    ///method retrieves the current value of a specified parameter.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the parameter.
    ///    Value = Receives the value for the parameter specified in <i>Api</i>. If <i>Api</i> was specified as
    ///            ENCAPIPARAM_BITRATE_MODE, then <i>Value</i> will be one of the VIDEOENCODER_BITRATE_MODE constants.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetValue(const(GUID)* Api, VARIANT* Value);
    ///<p class="CCE_Message">[IEncoderAPI is no longer available for use. Instead, use ICodecAPI.] The <b>SetValue</b>
    ///method sets the current value of a parameter.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the parameter.
    ///    Value = Pointer that specifies the value of <i>Api</i>. If <i>Api</i> was specified as
    ///            <b>ENCAPIPARAM_BITRATE_MODE</b>, then <i>Value</i> must be one of the VIDEOENCODER_BITRATE_MODE constants.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetValue(const(GUID)* Api, VARIANT* Value);
}

///<p class="CCE_Message">[<b>IVideoEncoder</b> may be altered or unavailable in subsequent versions.] The
///<b>IVideoEncoder</b> interface is optionally exposed by video encoder filters.
@GUID("02997C3B-8E1B-460E-9270-545E0DE9563E")
interface IVideoEncoder : IEncoderAPI
{
}

///The <code>IAMDecoderCaps</code> interface returns capabilities information from an MPEG decoder filter. The
///capabilities reported through this interface include whether the decoder supports the Video Mixing Renderer filter
///and whether it supports DirectX Video Acceleration. Some DirectShow components, such as the DVD Graph Builder, use
///this interface to determine the correct filter graph to build. Applications might use this interface to query the
///decoder's capabilities.
@GUID("C0DFF467-D499-4986-972B-E1D9090FA941")
interface IAMDecoderCaps : IUnknown
{
    ///The <code>GetDecoderCaps</code> method queries the decoder for its capabilities.
    ///Params:
    ///    dwCapIndex = Specifies the capability being queried for. <table> <tr> <th>Constant </th> <th>Value </th> <th>Description
    ///                 </th> </tr> <tr> <td>AM_QUERY_DECODER_VMR_SUPPORT</td> <td>0x00000001</td> <td>Video Mixing Renderer Filter 7
    ///                 (VMR-7) support</td> </tr> <tr> <td>AM_QUERY_DECODER_DXVA_1_SUPPORT</td> <td>0x00000002</td> <td>DirectX
    ///                 Video Acceleration support</td> </tr> <tr> <td>AM_QUERY_DECODER_DVD_SUPPORT</td> <td>0x00000003</td> <td>DVD
    ///                 Video support</td> </tr> <tr> <td>AM_QUERY_DECODER_ATSC_SD_SUPPORT</td> <td>0x00000004</td>
    ///                 <td>Standard-definition (SD) ATSC video support</td> </tr> <tr> <td>AM_QUERY_DECODER_ATSC_HD_SUPPORT</td>
    ///                 <td>0x00000005</td> <td>High-definition (HD) ATSC video support</td> </tr> <tr>
    ///                 <td>AM_GETDECODERCAP_QUERY_VMR9_SUPPORT</td> <td>0x00000006</td> <td>Video Mixing Renderer Filter 9 (VMR-9)
    ///                 support</td> </tr> <tr> <td>AM_GETDECODERCAP_QUERY_EVR_SUPPORT</td> <td>0x00000007</td> <td>Enhanced Video
    ///                 Renderer (EVR) support.</td> </tr> </table>
    ///    lpdwCap = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///              <td>DECODER_CAP_NOTSUPPORTED</td> <td>The decoder does not support this capability.</td> </tr> <tr>
    ///              <td>DECODER_CAP_SUPPORTED</td> <td>The decoder supports this capability.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetDecoderCaps(uint dwCapIndex, uint* lpdwCap);
}

///The <code>IAMCertifiedOutputProtection</code> interface sends Certified Output Protection Protocol (COPP) messages to
///the graphics driver. This interface is exposed by the Video Mixing Renderer 7 (VMR-7) and Video Mixing Renderer 9
///(VMR-9) filters. For information about using COPP, see Using Certified Output Protection Protocol (COPP).
@GUID("6FEDED3E-0FF1-4901-A2F1-43F7012C8515")
interface IAMCertifiedOutputProtection : IUnknown
{
    ///The <b>KeyExchange</b> method returns the graphics driver's certificate.
    ///Params:
    ///    pRandom = Receives a 128-bit random number, generated by the graphics driver. Use this value in the
    ///              IAMCertifiedOutputProtection::SessionSequenceStart method.
    ///    VarLenCertGH = Receives a pointer to a buffer containing the graphics driver's certificate. The method allocates the memory
    ///                   for the buffer. The caller must release the memory by calling CoTaskMemFree.
    ///    pdwLengthCertGH = Receives the length of the buffer returned in <i>VarLenCertGH</i>.
    ///Returns:
    ///    Returns an HRESULT value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Invalid state. Possibly the application passed unexpected data, or called IAMCertifiedOutputProtection
    ///    methods in the wrong order. If this error occurs, the application should release the current instance of the
    ///    VMR. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NO_COPP_HW</b></dt> </dl> </td> <td width="60%"> The
    ///    display device does not support COPP; or the VMR has not connected to a display device yet. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>ERROR_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE</b></dt> </dl> </td> <td
    ///    width="60%"> No monitors correspond to the display device. This error can occur if the display mode changes;
    ///    or the user turns off a monitor or removes a monitor. </td> </tr> </table>
    ///    
    HRESULT KeyExchange(GUID* pRandom, ubyte** VarLenCertGH, uint* pdwLengthCertGH);
    ///The <code>SessionSequenceStart</code> method initiates the COPP session with the graphics driver.
    ///Params:
    ///    pSig = Pointer to an [AMCOPPSignature](/windows/desktop/api/strmif/ns-strmif-amcoppsignature) structure. Fill this
    ///           structure as described in the Remarks session.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Invalid state. Possibly the application passed unexpected data, or called <b>IAMCertifiedOutputProtection</b>
    ///    methods in the wrong order. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NO_COPP_HW</b></dt> </dl>
    ///    </td> <td width="60%"> The display device does not support COPP; or the VMR has not connected to a display
    ///    device yet. </td> </tr> </table>
    ///    
    HRESULT SessionSequenceStart(AMCOPPSignature* pSig);
    ///The <code>ProtectionCommand</code> method sends a COPP command to the graphics driver.
    ///Params:
    ///    cmd = Pointer to an [AMCOPPCommand](/windows/desktop/api/strmif/ns-strmif-amcoppcommand) structure that contains
    ///          the command.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Invalid state. Possibly the application passed unexpected data, or called <b>IAMCertifiedOutputProtection</b>
    ///    methods in the wrong order. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NO_COPP_HW</b></dt> </dl>
    ///    </td> <td width="60%"> The display device does not support COPP; or the VMR has not connected to a display
    ///    device yet. </td> </tr> </table>
    ///    
    HRESULT ProtectionCommand(const(AMCOPPCommand)* cmd);
    ///The <code>ProtectionStatus</code> method sends a COPP status request to the graphics driver.
    ///Params:
    ///    pStatusInput = Pointer to an [AMCOPPStatusInput](/windows/desktop/api/strmif/ns-strmif-amcoppstatusinput) structure that
    ///                   contains the status request.
    ///    pStatusOutput = Pointer to an [AMCOPPStatusOutput](/windows/desktop/api/strmif/ns-strmif-amcoppstatusoutput) structure. The
    ///                    method fills this structure with the driver's response.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Invalid state. Possibly the application passed unexpected data, or called <b>IAMCertifiedOutputProtection</b>
    ///    methods in the wrong order. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NO_COPP_HW</b></dt> </dl>
    ///    </td> <td width="60%"> The display device does not support COPP; or the VMR has not connected to a display
    ///    device yet. </td> </tr> </table>
    ///    
    HRESULT ProtectionStatus(const(AMCOPPStatusInput)* pStatusInput, AMCOPPStatusOutput* pStatusOutput);
}

///Enables a pull-mode source filter to support larger file sizes.
@GUID("CF7B26FC-9A00-485B-8147-3E789D5E8F67")
interface IAMAsyncReaderTimestampScaling : IUnknown
{
    ///Gets the filter's time-stamping mode.
    ///Params:
    ///    pfRaw = Receives a Boolean value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///            id="TRUE"></a><a id="true"></a><dl> <dt><b><b>TRUE</b></b></dt> </dl> </td> <td width="60%"> Time stamps are
    ///            in units of bytes. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a id="false"></a><dl>
    ///            <dt><b><b>FALSE</b></b></dt> </dl> </td> <td width="60%"> Time stamps are in units of bytes × 10000000. To
    ///            get the offset in bytes, divide the sample time by 10000000. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTimestampMode(int* pfRaw);
    ///Sets the filter's time-stamping mode.
    ///Params:
    ///    fRaw = Specifies the units for the source filter's time stamps. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///           <tr> <td width="40%"><a id="TRUE"></a><a id="true"></a><dl> <dt><b><b>TRUE</b></b></dt> </dl> </td> <td
    ///           width="60%"> Time stamps are in units of bytes. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a
    ///           id="false"></a><dl> <dt><b><b>FALSE</b></b></dt> </dl> </td> <td width="60%"> Time stamps are in units of
    ///           bytes × 10000000. To get the offset in bytes, divide the sample time by 10000000. </td> </tr> </table> The
    ///           default value is <b>FALSE</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetTimestampMode(BOOL fRaw);
}

///Controls the preferred and blocked filter lists. To get a pointer to this interface, call <b>CoCreateInstance</b>.
///The class identifier (CLSID) is <b>CLSID_DirectShowPluginControl</b>, which is defined in the header file uuids.h.
@GUID("0E26A181-F40C-4635-8786-976284B52981")
interface IAMPluginControl : IUnknown
{
    ///Searches the preferred list for a class identifier (CLSID) that matches a specified subtype.
    ///Params:
    ///    subType = A media subtype GUID to match.
    ///    clsid = Receives a CLSID from the preferred list.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_NOT_FOUND)</b></dt> </dl> </td> <td width="60%">
    ///    No CLSID matching this subtype was found. </td> </tr> </table>
    ///    
    HRESULT GetPreferredClsid(const(GUID)* subType, GUID* clsid);
    ///Gets a class identifier (CLSID) from the preferred list, specified by index value.
    ///Params:
    ///    index = The zero-based index of the CLSID to retrieve.
    ///    subType = Receives the subtype GUID associated with the CLSID.
    ///    clsid = Receives the CLSID at the specified index.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>index</i> parameter is out of range. </td> </tr> </table>
    ///    
    HRESULT GetPreferredClsidByIndex(uint index, GUID* subType, GUID* clsid);
    ///Adds a class identifier (CLSID) to the preferred list or removes a CLSID from the list.
    ///Params:
    ///    subType = A media subtype GUID to associate with the CLSID.
    ///    clsid = Pointer to the CLSID to add to the list. If this parameter is <b>NULL</b>, the entry associated with
    ///            <i>subType</i> is removed from the list
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPreferredClsid(const(GUID)* subType, const(GUID)* clsid);
    ///Queries whether a class identifier (CLSID) appears in the blocked list.
    ///Params:
    ///    clsid = The CLSID to search for.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The specified CLSID appears in the
    ///    blocked list. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_NOT_FOUND)</b></dt>
    ///    </dl> </td> <td width="60%"> The specified CLSID is not in the blocked list. </td> </tr> </table>
    ///    
    HRESULT IsDisabled(const(GUID)* clsid);
    ///Gets a class identifier (CLSID) from the blocked list.
    ///Params:
    ///    index = The zero-based index of the CLSID to retrieve.
    ///    clsid = Receives the CLSID at the specified index.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>index</i> parameter is out of range. </td> </tr> </table>
    ///    
    HRESULT GetDisabledByIndex(uint index, GUID* clsid);
    ///Adds a class identifier (CLSID) to the blocked list, or removes a CLSID from the list.
    ///Params:
    ///    clsid = The CLSID to add or remove.
    ///    disabled = Specifies whether to add or remove the CSLID. If the value is <b>TRUE</b>, the method adds the CLSID to the
    ///               blocked list. Otherwise, the method removes it from the list.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDisabled(const(GUID)* clsid, BOOL disabled);
    ///Queries whether an Audio Compression Manager (ACM) or Video Compression Manager (VCM) codec appears in the
    ///blocked list.
    ///Params:
    ///    dllName = The name of the DLL that implements the codec.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The specified DLL appears in the
    ///    blocked list. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)</b></dt>
    ///    </dl> </td> <td width="60%"> The specified DLL is not in the blocked list. </td> </tr> </table>
    ///    
    HRESULT IsLegacyDisabled(const(wchar)* dllName);
}

///This interface provides methods for reconnecting an input pin while the filter is still running. The Filter Graph
///Manager calls methods on this interface when it performs dynamic reconnections (see the IGraphConfig interface).
///Applications might also use this interface to perform dynamic pin reconnections. <b>Filter developers: </b>Implement
///this interface on any input pin that allows dynamic reconnection or dynamic changes in format.
@GUID("4A9A62D3-27D4-403D-91E9-89F540E55534")
interface IPinConnection : IUnknown
{
    ///The <code>DynamicQueryAccept</code> method queries whether the pin can accept the specified media type while the
    ///graph is running with the current connection to this pin.
    ///Params:
    ///    pmt = Pointer to an AM_MEDIA_TYPE structure that specifies the media type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Media
    ///    type is acceptable. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_TYPE_NOT_ACCEPTED</b></dt> </dl>
    ///    </td> <td width="60%"> Media type is not acceptable. </td> </tr> </table>
    ///    
    HRESULT DynamicQueryAccept(const(AM_MEDIA_TYPE)* pmt);
    ///The <code>NotifyEndOfStream</code> method requests notification from the pin when the next end-of-stream
    ///condition occurs.
    ///Params:
    ///    hNotifyEvent = Handle to an event object that the pin will signal.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Event handle was <b>NULL</b>, but there was no existing event handle to reset. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Event handle was set. (If event handle
    ///    was <b>NULL</b>, event notification was canceled.) </td> </tr> </table>
    ///    
    HRESULT NotifyEndOfStream(HANDLE hNotifyEvent);
    ///The <code>IsEndPin</code> method indicates whether a reconnection search should end at this pin.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    This pin is not a candidate for reconnection. (The reconnection search should not stop at this pin.) </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> This pin is a candidate
    ///    for reconnection. (The reconnection search should stop at this pin.) </td> </tr> </table>
    ///    
    HRESULT IsEndPin();
    ///The <code>DynamicDisconnect</code> method disconnects the pin when the filter is active (paused or running). Call
    ///this method instead of IPin::Disconnect to disconnect a pin when the graph is running or paused. The caller must
    ///ensure that no data is flowing to the pin when it calls this method. Call the IPinFlowControl::Block method on an
    ///upstream pin to block the data flow, or use some other mechanism to make sure that no samples are delivered until
    ///this pin is reconnected.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    The pin is already disconnected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT DynamicDisconnect();
}

///Blocks data flow from an active output pin. This interface is exposed by output pins that can reconnect dynamically.
///Use this interface to start a dynamic reconnection within the filter graph. For more information, see Dynamic Graph
///Building. <b>Filter developers: </b>Parser and capture filters that support dynamic reconnection should support this
///interface on their output pins. Generally, other types of filters do not need to implement this interface.
@GUID("C56E9858-DBF3-4F6B-8119-384AF2060DEB")
interface IPinFlowControl : IUnknown
{
    ///The <code>Block</code> method blocks or unblocks the flow of data from the pin.
    ///Params:
    ///    dwBlockFlags = Flag that indicates whether to block or unblock the pin. Must be one of the following values: <ul> <li>Zero:
    ///                   Unblock data flow from the pin.</li> <li>AM_PIN_FLOW_CONTROL_BLOCK: Block data flow from the pin.</li> </ul>
    ///    hEvent = Handle to an event object, or <b>NULL</b>. If this parameter is non-<b>NULL</b>, the method is asynchronous
    ///             and returns immediately. The event is signaled when the operation completes. If this parameter is
    ///             <b>NULL</b>, the method is synchronous and does not complete until the pin is blocked. If <i>dwBlockFlags</i>
    ///             is zero, this parameter must be <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Pin is already unblocked. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_PIN_ALREADY_BLOCKED</b></dt> </dl>
    ///    </td> <td width="60%"> Pin is already blocked on another thread. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD</b></dt> </dl> </td> <td width="60%"> Pin is already blocked
    ///    on the calling thread. </td> </tr> </table>
    ///    
    HRESULT Block(uint dwBlockFlags, HANDLE hEvent);
}

///The Filter Graph Manager exposes <code>IGraphConfig</code> to support dynamic graph building. This interface enables
///applications and filters to reconfigure the filter graph while the graph is in a running state, and without losing
///data from the stream. The most straightforward way to rebuild the graph dynamically is to call the
///IGraphConfig::Reconnect method. This method handles most of the details of dynamically rebuilding the graph. If a
///situation ever arises where you want to implement your own technique, <code>IGraphConfig</code> also provides the
///IGraphConfig::Reconfigure method. This method obtains a lock on the filter graph and then calls a callback function
///in your application, which reconfigures the graph. With this method, most of the work is shifted to your application.
///For more information, see Dynamic Graph Building. To optimize the process of adding and removing filters, the filter
///graph maintains a cache of filters. During a call to the <b>Reconnect</b> method, you can specify that any filters
///removed from the graph get added to the cache. You can also add a filter to the cache directly, if you know it is
///likely to be needed, by calling IGraphConfig::AddFilterToCache. The IGraphBuilder::Render, IGraphBuilder::RenderFile,
///and IGraphBuilder::Connect methods automatically try to use filters in the cache before using other filters. Also, in
///the <b>Reconnect</b> method you can specify that only cached filters will be used for the reconnection. Note that
///filters held in the cache are not actually part of the graph. They are disconnected from any pins and are kept in a
///stopped state.
@GUID("03A1EB8E-32BF-4245-8502-114D08A9CB88")
interface IGraphConfig : IUnknown
{
    ///The <code>Reconnect</code> method performs a dynamic reconnection between two pins.
    ///Params:
    ///    pOutputPin = Pointer to the IPin interface of an output pin. Can be <b>NULL</b>, in which case <i>pInputPin</i> must not
    ///                 be <b>NULL</b>.
    ///    pInputPin = Pointer the IPin interface to an input pin. Can be <b>NULL</b>, in which case <i>pOutputPin</i> must not be
    ///                <b>NULL</b>.
    ///    pmtFirstConnection = Pointer to an AM_MEDIA_TYPE structure that specifies the media type for the first pin connection made during
    ///                         the reconnection. If this parameter is <b>NULL</b>, the first connection can have any media type.
    ///    pUsingFilter = Pointer to an optional filter to use in the reconnection. The filter must already be in the graph. Can be
    ///                   <b>NULL</b>.
    ///    hAbortEvent = Handle to an event. If the caller is a filter calling on one of its data processing threads, this parameter
    ///                  should be a handle to an event that will be signaled when the filter is put into a stopped state. Otherwise,
    ///                  this parameter can be <b>NULL</b>. For more information, see Remarks.
    ///    dwFlags = Combination of flags from the
    ///              [AM_GRAPH_CONFIG_RECONNECT_FLAGS](/windows/desktop/api/strmif/ne-strmif-am_graph_config_reconnect_flags)
    ///              enumeration, specifying how to perform the reconnection.
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns an error code that may be one of the following values, or
    ///    others not listed. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. (For example, both
    ///    <i>pInputPin</i> and <i>pOutputPin</i> are <b>NULL</b>.) </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> Input pin does not support IPinConnection. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_CANNOT_CONNECT</b></dt> </dl> </td> <td width="60%"> Unable to
    ///    connect filter. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_STATE_CHANGED</b></dt> </dl> </td> <td
    ///    width="60%"> The state of the filter changed. Unable to complete the operation. </td> </tr> </table>
    ///    
    HRESULT Reconnect(IPin pOutputPin, IPin pInputPin, const(AM_MEDIA_TYPE)* pmtFirstConnection, 
                      IBaseFilter pUsingFilter, HANDLE hAbortEvent, uint dwFlags);
    ///The <code>Reconfigure</code> method locks the filter graph and calls a callback function in the application or
    ///filter to perform a dynamic reconfiguration.
    ///Params:
    ///    pCallback = Pointer to the IGraphConfigCallback callback interface on the application or filter.
    ///    pvContext = Pointer to a variable of type <b>PVOID</b> that is passed to the callback routine.
    ///    dwFlags = Application-defined flags that are passed to the callback routine.
    ///    hAbortEvent = Handle to an event. If the caller is a filter calling on one of its data processing threads, this parameter
    ///                  should be a handle to an event that will be signaled when the filter is put into a stopped state. Otherwise,
    ///                  this parameter can be <b>NULL</b>. For more information, see Remarks.
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise. Possible errors include VFW_E_WRONG_STATE, if the
    ///    method could not obtain a lock on the filter graph; whatever <b>HRESULT</b> was returned by the callback
    ///    routine; or an error code indicating that the graph could not put the filters into a running state.
    ///    
    HRESULT Reconfigure(IGraphConfigCallback pCallback, void* pvContext, uint dwFlags, HANDLE hAbortEvent);
    ///The <code>AddFilterToCache</code> method adds a filter to the filter cache.
    ///Params:
    ///    pFilter = Pointer to the IBaseFilter interface of the filter.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Filter
    ///    is already in the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Filter was added to the cache. </td> </tr> </table>
    ///    
    HRESULT AddFilterToCache(IBaseFilter pFilter);
    ///The <code>EnumCacheFilter</code> method enumerates the filters in the filter cache.
    ///Params:
    ///    pEnum = Receives a pointer to the IEnumFilters interface on the filter enumerator. The caller must release the
    ///            interface.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Failed to
    ///    allocate necessary memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT EnumCacheFilter(IEnumFilters* pEnum);
    ///The <code>RemoveFilterFromCache</code> method removes a filter from the filter cache.
    ///Params:
    ///    pFilter = Pointer to the IBaseFilter interface of the filter to remove from the cache.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Filter
    ///    was not in the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Filter was successfully removed from the cache. </td> </tr> </table>
    ///    
    HRESULT RemoveFilterFromCache(IBaseFilter pFilter);
    ///The <code>GetStartTime</code> method retrieves the reference time that was used when the filter graph was last
    ///put into a running state.
    ///Params:
    ///    prtStart = Receives the start time.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> Filter graph is not in a
    ///    running state. </td> </tr> </table>
    ///    
    HRESULT GetStartTime(long* prtStart);
    ///The <code>PushThroughData</code> method pushes data through the filter graph to the specified pin.
    ///Params:
    ///    pOutputPin = Pointer to the IPin interface of an output pin in the filter graph.
    ///    pConnection = Pointer to the IPinConnection interface of an input pin in the filter graph. This parameter can be
    ///                  <b>NULL</b>.
    ///    hEventAbort = Handle to an event. If the caller is a filter calling on one of its data processing threads, this parameter
    ///                  should be a handle to an event that will be signaled when the filter is put into a stopped state. Otherwise,
    ///                  this parameter can be <b>NULL</b>. For more information, see Remarks.
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns an error code that may be one of the following values, or
    ///    others not listed. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Failed to allocate necessary memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Could not find a
    ///    candidate input pin. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_STATE_CHANGED</b></dt> </dl> </td>
    ///    <td width="60%"> Filter state changed during the operation. </td> </tr> </table>
    ///    
    HRESULT PushThroughData(IPin pOutputPin, IPinConnection pConnection, HANDLE hEventAbort);
    ///The <code>SetFilterFlags</code> method sets a filter's configuration information.
    ///Params:
    ///    pFilter = Pointer to the IBaseFilter interface of a filter in the filter graph.
    ///    dwFlags = Value specifying the new configuration flags. Must be one of the following values. <table> <tr> <th>Value
    ///              </th> <th>Description </th> </tr> <tr> <td>Zero</td> <td>No flags set.</td> </tr> <tr>
    ///              <td>AM_FILTER_FLAGS_REMOVABLE</td> <td>The filter is removable during a dynamic reconnection. For more
    ///              information, see Remarks.</td> </tr> </table>
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_IN_GRAPH</b></dt> </dl> </td> <td
    ///    width="60%"> The filter is not in the graph. </td> </tr> </table>
    ///    
    HRESULT SetFilterFlags(IBaseFilter pFilter, uint dwFlags);
    ///The <code>GetFilterFlags</code> method retrieves a filter's configuration information.
    ///Params:
    ///    pFilter = Pointer to the IBaseFilter interface of a filter in the filter graph.
    ///    pdwFlags = Receives the current configuration flags.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Null pointer
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_IN_GRAPH</b></dt> </dl> </td> <td width="60%"> The
    ///    filter is not in the graph. </td> </tr> </table>
    ///    
    HRESULT GetFilterFlags(IBaseFilter pFilter, uint* pdwFlags);
    ///The <code>RemoveFilterEx</code> method removes a filter from the filter graph.
    ///Params:
    ///    pFilter = Pointer to the IBaseFilter interface of the filter to remove from the graph.
    ///    Flags = Combination of flags from the REM_FILTER_FLAGS enumerated type.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the failure.
    ///    
    HRESULT RemoveFilterEx(IBaseFilter pFilter, uint Flags);
}

///The <code>IGraphConfigCallback</code> interface contains the callback method passed to IGraphConfig::Reconfigure. The
///caller (an application or filter) implements this interface. For more information, see IGraphConfig.
@GUID("ADE0FD60-D19D-11D2-ABF6-00A0C905F375")
interface IGraphConfigCallback : IUnknown
{
    ///The <code>Reconfigure</code> method is a callback method passed to IGraphConfig::Reconfigure.
    ///Params:
    ///    pvContext = Value passed in the <b>IGraphConfig::Reconfigure</b> method's <i>pvContext</i> parameter.
    ///    dwFlags = Value passed in the <b>IGraphConfig::Reconfigure</b> method's <i>dwFlags</i> parameter.
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT Reconfigure(void* pvContext, uint dwFlags);
}

///The <code>IFilterChain</code> interface provides methods for starting, stopping, or removing chains of filters in a
///filter graph. The filter graph manager exposes this interface. A <i>filter chain</i> is a sequence of filters, each
///with at most one connected input pin and one connected output pin, that forms an unbroken line of filters. A filter
///chain is defined by the filter at the start of the chain and the filter at the end of the chain. (These can be the
///same filter, making a chain of one filter.) By definition, there is a single stream path going from the start of the
///chain downstream to the end of the chain. The methods on this interface are useful in situations where an entire
///stream of data can appear or disappear, such as a video conferencing application that receives multiple streams over
///a network. For more information, see Dynamic Graph Building. To control individual streams on a capture filter, use
///the IAMStreamControl interface instead.
@GUID("DCFBDCF6-0DC2-45F5-9AB2-7C330EA09C29")
interface IFilterChain : IUnknown
{
    ///The <code>StartChain</code> method switches all the filters in a filter chain into a running state.
    ///Params:
    ///    pStartFilter = A pointer to the IBaseFilter interface of the filter at the start of the chain.
    ///    pEndFilter = Pointer to the filter at the end of the chain. If this parameter is <b>NULL</b>, the method uses the longest
    ///                 possible filter chain that extends downstream from the start filter.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, the return value may be VFW_E_NOT_RUNNING or another
    ///    <b>HRESULT</b> value.
    ///    
    HRESULT StartChain(IBaseFilter pStartFilter, IBaseFilter pEndFilter);
    ///The <code>PauseChain</code> method switches all the filters in a filter chain into a paused state.
    ///Params:
    ///    pStartFilter = A pointer to the IBaseFilter interface of the filter at the start of the chain.
    ///    pEndFilter = A pointer to the IBaseFilter interface of the filter at the end of the chain. If this parameter is
    ///                 <b>NULL</b>, the method uses the longest possible filter chain that extends downstream from the start filter.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, the return value may be VFW_E_NOT_PAUSED or another
    ///    <b>HRESULT</b> value.
    ///    
    HRESULT PauseChain(IBaseFilter pStartFilter, IBaseFilter pEndFilter);
    ///The <code>StopChain</code> method switches all the filters in a filter chain into a stopped state.
    ///Params:
    ///    pStartFilter = A pointer to the IBaseFilter interface of the filter at the start of the chain.
    ///    pEndFilter = Pointer to the filter at the end of the chain. If this parameter is <b>NULL</b>, the method uses the longest
    ///                 possible filter chain that extends downstream from the start filter.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the failure otherwise.
    ///    
    HRESULT StopChain(IBaseFilter pStartFilter, IBaseFilter pEndFilter);
    ///The <code>RemoveChain</code> method removes every filter in a filter chain from the filter graph.
    ///Params:
    ///    pStartFilter = A pointer to the IBaseFilter interface of the filter at the start of the chain.
    ///    pEndFilter = A pointer to the IBaseFilter interface of the filter at the end of the chain. If this parameter is
    ///                 <b>NULL</b>, the method uses the longest possible filter chain that extends downstream from the start filter.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value indicating the cause of the failure otherwise.
    ///    
    HRESULT RemoveChain(IBaseFilter pStartFilter, IBaseFilter pEndFilter);
}

///The <code>IVMRImagePresenter</code> interface is implemented by the default Allocator-Presenter for the Video Mixing
///Renderer Filter 7 (VMR-7). It must also be implemented by any plug-in Allocator-Presenter that an application
///provides for the VMR-7. The VMR-7 uses the methods on this interface to inform the Allocator-Presenter that it should
///present the video frame contained in the supplied Direct Draw surface. Applications do not use this interface. For
///the VMR-9, use the IVMRImagePresenter9 interface.
@GUID("CE704FE7-E71E-41FB-BAA2-C4403E1182F5")
interface IVMRImagePresenter : IUnknown
{
    ///The <code>StartPresenting</code> method is called just before the video starts playing. The allocator-presenter
    ///should perform any necessary configuration in this method.
    ///Params:
    ///    dwUserID = An application-defined <b>DWORD_PTR</b> cookie that uniquely identifies this instance of the VMR for use in
    ///               scenarios when one instance of the allocator-presenter is used with multiple VMR instances.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT StartPresenting(size_t dwUserID);
    ///The <code>StopPresenting</code> method is called just after the video stops playing. The allocator-presenter
    ///should perform any necessary cleanup in this method.
    ///Params:
    ///    dwUserID = An application-defined <b>DWORD_PTR</b> cookie that uniquely identifies this instance of the VMR for use in
    ///               scenarios when one instance of the allocator-presenter is used with multiple VMR instances.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT StopPresenting(size_t dwUserID);
    ///The <code>PresentImage</code> method is called at precisely the moment this video frame should be presented.
    ///Params:
    ///    dwUserID = An application-defined DWORD_PTR that uniquely identifies this instance of the VMR in scenarios when multiple
    ///               instances of the VMR are being used with a single instance of an Allocator-Presenter. See Remarks
    ///    lpPresInfo = Specifies the [VMRPRESENTATIONINFO](/windows/desktop/api/strmif/ns-strmif-vmrpresentationinfo) structure.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PresentImage(size_t dwUserID, VMRPRESENTATIONINFO* lpPresInfo);
}

///The <code>IVMRSurfaceAllocator</code> interface is implemented by the default allocator-presenter for the Video
///Mixing Renderer Filter 7 (VMR-7). It must also be implemented by any plug-in allocator-presenter that an application
///provides to the VMR-7. The VMR-7 uses the methods on this interface to allocate, prepare and free DirectDraw
///surfaces. Applications do not use this interface. For the VMR-9, use the IVMRSurfaceAllocator9 interface.
@GUID("31CE832E-4484-458B-8CCA-F4D7E3DB0B52")
interface IVMRSurfaceAllocator : IUnknown
{
    ///The <code>AllocateSurface</code> method allocates a DirectDraw surface.
    ///Params:
    ///    dwUserID = An application-defined DWORD_PTR cookie that uniquely identifies this instance of the VMR for use in
    ///               scenarios when one instance of the allocator-presenter is used with multiple VMR instances.
    ///    lpAllocInfo = Specifies the [VMRALLOCATIONINFO](/windows/desktop/api/strmif/ns-strmif-vmrallocationinfo) structure. See
    ///                  Remarks.
    ///    lpdwActualBuffers = [out] On input this parameter is used to request the number of buffers desired. On output it receives the
    ///                        actual number of buffers created.
    ///    lplpSurface = Address of a pointer that receives the Direct3D surface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> One of the pointers is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> In <i>dwFlags</i>, the AMAP_3D_TARGET was combined
    ///    with AMAP_FORCE_SYSMEM or AMAP_ALLOW_SYSMEM. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt>
    ///    </dl> </td> <td width="60%"> One or more members of the BITMAPINFOHEADER structure specified by
    ///    <i>lpAllocInfo</i>-&gt;lpHdr is incorrect. </td> </tr> </table>
    ///    
    HRESULT AllocateSurface(size_t dwUserID, VMRALLOCATIONINFO* lpAllocInfo, uint* lpdwActualBuffers, 
                            IDirectDrawSurface7* lplpSurface);
    ///The <code>FreeSurface</code> method frees the allocated DirectDraw surface.
    ///Params:
    ///    dwID = An application-defined DWORD_PTR cookie that uniquely identifies this instance of the VMR for use in
    ///           scenarios when one instance of the allocator-presenter is used with multiple VMR instances.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT FreeSurface(size_t dwID);
    ///The <code>PrepareSurface</code> method prepares the DirectDraw surface to have the next video frame decoded into
    ///it.
    ///Params:
    ///    dwUserID = An application-defined DWORD_PTR cookie that uniquely identifies this instance of the VMR for use in
    ///               scenarios when one instance of the allocator-presenter is used with multiple VMR instances.
    ///    lpSurface = Specifies the DirectDraw surface
    ///    dwSurfaceFlags = Double word containing the surface flags. See Remarks.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PrepareSurface(size_t dwUserID, IDirectDrawSurface7 lpSurface, uint dwSurfaceFlags);
    ///The <code>AdviseNotify</code> method provides the allocator-presenter with the VMR-7 filter's interface for
    ///notification callbacks. If you are using a custom allocator-presenter, the application must call this method on
    ///the allocator-presenter, with a pointer to the VMR's <b>IVMRSurfaceAllocatorNotify</b> interface. The
    ///allocator-presenter uses this interface to communicate with the VMR. If you are not using a custom
    ///allocator-presenter, the application does not have to call this method.
    ///Params:
    ///    lpIVMRSurfAllocNotify = Specifies the IVMRSurfaceAllocatorNotify interface pointer that the allocator-presenter will use to pass
    ///                            notifications back to the VMR.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT AdviseNotify(IVMRSurfaceAllocatorNotify lpIVMRSurfAllocNotify);
}

///The <code>IVMRSurfaceAllocatorNotify</code> interface is implemented by the Video Mixing Renderer Filter 7 (VMR-7).
///Applications use this interface to set a custom allocator-presenter and the allocator-presenter uses this interface
///to inform the VMR-7 of changes to the system environment that affect the DirectDraw surfaces. In order for an
///application to obtain this interface, the VMR must be in renderless mode. For the VMR-9, use the
///IVMRSurfaceAllocatorNotify9 interface.
@GUID("AADA05A8-5A4E-4729-AF0B-CEA27AED51E2")
interface IVMRSurfaceAllocatorNotify : IUnknown
{
    ///The <code>AdviseSurfaceAllocator</code> method is called by an application to instruct the VMR to use a custom
    ///allocator-presenter.
    ///Params:
    ///    dwUserID = An application-defined DWORD_PTR that uniquely identifies this instance of the VMR in scenarios when multiple
    ///               instances of the VMR are being used with a single instance of an allocator-presenter.
    ///    lpIVRMSurfaceAllocator = Specifies the IVMRSurfaceAllocator interface on the new allocator-presenter. If this value is <b>NULL</b>,
    ///                             then the VMR will release the client allocator-presenter and restore its default allocator-presenter.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT AdviseSurfaceAllocator(size_t dwUserID, IVMRSurfaceAllocator lpIVRMSurfaceAllocator);
    ///The <code>SetDDrawDevice</code> method sets the initial DirectDraw device and monitor to be used for video
    ///playback.
    ///Params:
    ///    lpDDrawDevice = Specifies the DirectDraw device.
    ///    hMonitor = Handle to the monitor associated with the DirectDraw device.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetDDrawDevice(IDirectDraw7 lpDDrawDevice, ptrdiff_t hMonitor);
    ///The <code>ChangeDDrawDevice</code> method notifies the VMR that the DirectDraw playback device has changed. For
    ///example, on a multi-monitor system, the user has moved the video rectangle from one monitor to another.
    ///Params:
    ///    lpDDrawDevice = Specifies the DirectDraw device.
    ///    hMonitor = Specifies the handle to the monitor associated with the DirectDraw device.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT ChangeDDrawDevice(IDirectDraw7 lpDDrawDevice, ptrdiff_t hMonitor);
    ///The <code>RestoreDDrawSurfaces</code> method notifies the VMR that a DirectDraw surface "loss" has been detected.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT RestoreDDrawSurfaces();
    ///The <code>NotifyEvent</code> method is called by the allocator-presenter to inform the VMR of any significant
    ///DirectShow events during the allocation or presentation processes.
    ///Params:
    ///    EventCode = Specifies the event code.
    ///    Param1 = Specifies Param1 of the event code.
    ///    Param2 = Specifies Param2 of the event code.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT NotifyEvent(int EventCode, ptrdiff_t Param1, ptrdiff_t Param2);
    ///The <code>SetBorderColor</code> method specifies to the VMR which color to use in areas of the display rectangle
    ///which are not being used for video, for example when the video is letterboxed.
    ///Params:
    ///    clrBorder = Specifies the border color.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetBorderColor(uint clrBorder);
}

///The <code>IVMRWindowlessControl</code> interface controls how the Video Mixing Renderer Filter 7 (VMR-7) renders a
///video stream within a container window. Applications must first put the VMR-7 into windowless mode before using this
///interface. For the VMR-9, use the IVMRWindowlessControl9 interface.
@GUID("0EB1088C-4DCD-46F0-878F-39DAE86A51B7")
interface IVMRWindowlessControl : IUnknown
{
    ///The <code>GetNativeVideoSize</code> method retrieves the un-stretched video size and aspect ratio of the video.
    ///Params:
    ///    lpWidth = Pointer that receives the width of the native video rectangle.
    ///    lpHeight = Pointer that receives the height of the native video rectangle.
    ///    lpARWidth = Pointer that receives the aspect ratio width of the native video rectangle.
    ///    lpARHeight = Pointer that receives the aspect ratio height of the native video rectangle.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Returns E_POINTER if all four input parameters are <b>NULL</b>.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The VMR is not in windowless mode. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetNativeVideoSize(int* lpWidth, int* lpHeight, int* lpARWidth, int* lpARHeight);
    ///The <code>GetMinIdealVideoSize</code> method retrieves the minimum video size that the VMR can display without
    ///incurring significant performance or image quality degradation.
    ///Params:
    ///    lpWidth = Pointer to a LONG value that receives the minimum ideal width.
    ///    lpHeight = Pointer to a LONG value that receives the minimum ideal height.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The VMR is not in windowless mode. </td> </tr> </table>
    ///    
    HRESULT GetMinIdealVideoSize(int* lpWidth, int* lpHeight);
    ///The <code>GetMaxIdealVideoSize</code> method retrieves the maximum video size that the VMR can display without
    ///incurring significant performance or image quality degradation.
    ///Params:
    ///    lpWidth = Pointer that receives the maximum ideal width.
    ///    lpHeight = Pointer that receives the maximum ideal height.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The VMR is not in windowless mode. </td> </tr> </table>
    ///    
    HRESULT GetMaxIdealVideoSize(int* lpWidth, int* lpHeight);
    ///The <code>SetVideoPosition</code> method sets the source and destination rectangles for the video.
    ///Params:
    ///    lpSRCRect = Pointer to a <b>RECT</b> structure that specifies the source rectangle. If <b>NULL</b>, the source rectangle
    ///                does not change. The default source rectangle is the entire video image.
    ///    lpDSTRect = Pointer to a <b>RECT</b> structure that specifies the destination rectangle. If <b>NULL</b>, the destination
    ///                rectangle does not change. The default destination rectangle is {0, 0, 0, 0}.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The VMR is not in windowless mode. </td> </tr> </table>
    ///    
    HRESULT SetVideoPosition(const(RECT)* lpSRCRect, const(RECT)* lpDSTRect);
    ///The <code>GetVideoPosition</code> method retrieves the current source and destination rectangles used to display
    ///the video.
    ///Params:
    ///    lpSRCRect = Pointer that receives the current source rectangle.
    ///    lpDSTRect = Pointer that receives the current destination rectangle.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The VMR is not in windowless mode. </td> </tr> </table>
    ///    
    HRESULT GetVideoPosition(RECT* lpSRCRect, RECT* lpDSTRect);
    ///The <code>GetAspectRatioMode</code> method queries whether the VMR will preserve the aspect ratio of the source
    ///video.
    ///Params:
    ///    lpAspectRatioMode = Pointer to a variable that receives a VMR_ASPECT_RATIO_MODE value indicating the aspect ratio mode.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetAspectRatioMode(uint* lpAspectRatioMode);
    ///The <code>SetAspectRatioMode</code> method specifies whether the VMR will preserve the aspect ratio of the source
    ///video.
    ///Params:
    ///    AspectRatioMode = Specifies a member of the VMR_ASPECT_RATIO_MODE enumeration type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td
    ///    width="60%"> The VMR is not in windowless mode. </td> </tr> </table>
    ///    
    HRESULT SetAspectRatioMode(uint AspectRatioMode);
    ///The <code>SetVideoClippingWindow</code> method specifies the container window that video should be clipped to.
    ///Params:
    ///    hwnd = Specifies the window to which the video should be clipped.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The VMR is not in windowless mode. </td> </tr> </table>
    ///    
    HRESULT SetVideoClippingWindow(HWND hwnd);
    ///The <code>RepaintVideo</code> method repaints the current video frame.
    ///Params:
    ///    hwnd = Specifies the handle of the window in which the repainting should occur.
    ///    hdc = Specifies the handle to the device context for the window.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The VMR is not in windowless mode. </td> </tr> </table>
    ///    
    HRESULT RepaintVideo(HWND hwnd, HDC hdc);
    ///The <code>DisplayModeChanged</code> method informs the VMR that a WM_DISPLAYCHANGE message has been received by
    ///the application.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The VMR is not in windowless mode. </td> </tr> </table>
    ///    
    HRESULT DisplayModeChanged();
    ///The <code>GetCurrentImage</code> method retrieves a copy of the current image being displayed by the VMR.
    ///Params:
    ///    lpDib = Address of a pointer to a BYTE array.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The VMR is not in windowless mode. </td> </tr> </table>
    ///    
    HRESULT GetCurrentImage(ubyte** lpDib);
    ///The <code>SetBorderColor</code> method sets the border color to be used by the VMR.
    ///Params:
    ///    Clr = Specifies the border color.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The VMR is not in windowless mode. </td> </tr> </table>
    ///    
    HRESULT SetBorderColor(uint Clr);
    ///The <code>GetBorderColor</code> method retrieves the current border color used by the VMR.
    ///Params:
    ///    lpClr = Pointer to a <b>COLORREF</b> variable that receives the current border color.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The VMR is not in windowless mode. </td> </tr> </table>
    ///    
    HRESULT GetBorderColor(uint* lpClr);
    ///The <code>SetColorKey</code> method sets the source color key value that the VMR should use.
    ///Params:
    ///    Clr = Specifies the source color key.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The VMR is not in windowless mode. </td> </tr> </table>
    ///    
    HRESULT SetColorKey(uint Clr);
    ///The <code>GetColorKey</code> method retrieves the current source color key value used by the VMR.
    ///Params:
    ///    lpClr = Pointer to a <b>COLORREF</b> variable that receives the current color key value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The VMR is not in windowless mode. </td> </tr> </table>
    ///    
    HRESULT GetColorKey(uint* lpClr);
}

///The <code>IVMRMixerControl</code> interface is enables an application to manipulate the incoming video streams on the
///Video Mixing Renderer Filter 7 (VMR-7). Although this interface is implemented on the filter, it is actually the
///mixer component that is being configured. For this reason, this interface is only available when the mixer has been
///loaded through a call to IVMRFilterConfig::SetNumberOfStreams. This interface is intended for use by applications
///only; it should not be used by upstream filters. For the VMR-9, use the IVMRMixerControl9 interface.
@GUID("1C1A17B0-BED0-415D-974B-DC6696131599")
interface IVMRMixerControl : IUnknown
{
    ///The <code>SetAlpha</code> method sets a constant alpha value that is applied to this video stream.
    ///Params:
    ///    dwStreamID = Specifies the input stream.
    ///    Alpha = Specifies the alpha blending value to be applied to all the pixels in this stream.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl>
    ///    </td> <td width="60%"> The pin is not connected. </td> </tr> </table>
    ///    
    HRESULT SetAlpha(uint dwStreamID, float Alpha);
    ///The <code>GetAlpha</code> method retrieves the constant alpha value that is applied to this video stream.
    ///Params:
    ///    dwStreamID = Specifies the input stream.
    ///    pAlpha = Pointer to a variable of type float that receives the current alpha value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <i>pAlpha</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pin is not connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAlpha(uint dwStreamID, float* pAlpha);
    ///The <code>SetZOrder</code> method sets this video stream's position in the Z-order; larger values are further
    ///away.
    ///Params:
    ///    dwStreamID = Specifies the input stream.
    ///    dwZ = Double word containing the stream's position within the Z-order.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl>
    ///    </td> <td width="60%"> The pin is not connected. </td> </tr> </table>
    ///    
    HRESULT SetZOrder(uint dwStreamID, uint dwZ);
    ///The <code>GetZOrder</code> method retrieves this video stream's position in the Z order.
    ///Params:
    ///    dwStreamID = Specifies the input stream.
    ///    pZ = Pointer to a DWORD that receives the current position in the Z-order.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <i>pZOrder</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pin is not connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetZOrder(uint dwStreamID, uint* pZ);
    ///The <code>SetOutputRect</code> method sets the position of this stream within the composition rectangle.
    ///Params:
    ///    dwStreamID = Specifies the input stream.
    ///    pRect = Pointer to a [NORMALIZEDRECT](/windows/desktop/api/strmif/ns-strmif-normalizedrect) structure that specifies
    ///            the position of the rectangle with composition space.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <i>pRect</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pin is not connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetOutputRect(uint dwStreamID, const(NORMALIZEDRECT)* pRect);
    ///The <code>GetOutputRect</code> method retrieves the position of this stream's video rectangle within the
    ///composition rectangle.
    ///Params:
    ///    dwStreamID = Specifies the input stream.
    ///    pRect = Pointer to a [NORMALIZEDRECT](/windows/desktop/api/strmif/ns-strmif-normalizedrect) structure that receives
    ///            the destination rectangle in composition space.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <i>pRect</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pin is not connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetOutputRect(uint dwStreamID, NORMALIZEDRECT* pRect);
    ///Sets the background color on the output rectangle.
    ///Params:
    ///    ClrBkg = Specifies the background color.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetBackgroundClr(uint ClrBkg);
    ///Gets the current background color on the output rectangle.
    ///Params:
    ///    lpClrBkg = Address of a variable that receives the background color.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetBackgroundClr(uint* lpClrBkg);
    ///Sets the mixing preferences for the stream.
    ///Params:
    ///    dwMixerPrefs = Bitwise <b>OR</b> combination of VMRMixerPrefs flags.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetMixingPrefs(uint dwMixerPrefs);
    ///Retrieves the mixing preferences for the stream.
    ///Params:
    ///    pdwMixerPrefs = Address of a variable that receives a bitwise OR combination of VMRMixerPrefs flags.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetMixingPrefs(uint* pdwMixerPrefs);
}

///The <code>IVMRMonitorConfig</code> interface is implemented by the Video Mixing Renderer Filter 7 (VMR-7).
///Applications use this interface to determine the capabilities of the display devices on the system and to control
///which device is used to display the output. For example, if the system contains a hardware DVD decoder and the VMR is
///rendering the output from that decoder, then on a multi-monitor system, an application must use this interface to
///specify the display device that is connected to the decoder. The VMR-7 supports a maximum of 15 display devices. It
///is the responsibility of the application to ensure that the playback window is positioned on the desired monitor
///before the window is displayed. Otherwise the playback window will be displayed at a location chosen by the Windows
///Shell (Explorer) which may not be on the desired monitor. For the VMR-9, use the IVMRMonitorConfig9 interface.
@GUID("9CF0B1B6-FBAA-4B7F-88CF-CF1F130A0DCE")
interface IVMRMonitorConfig : IUnknown
{
    ///On a multi-monitor system, the <code>SetMonitor</code> method specifies the monitor that this instance of the VMR
    ///should use for video playback.
    ///Params:
    ///    pGUID = Pointer to a [VMRGUID](/windows/desktop/api/strmif/ns-strmif-vmrguid) structure that identifies the monitor.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The allocator-presenter has not been loaded.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetMonitor(const(VMRGUID)* pGUID);
    ///The <code>GetMonitor</code> method retrieves the monitor that this instance of the VMR is using for video
    ///playback.
    ///Params:
    ///    pGUID = Pointer to a [VMRGUID](/windows/desktop/api/strmif/ns-strmif-vmrguid) structure allocated by the caller. The
    ///            method fills this structure with a GUID that identifies the monitor.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The allocator-presenter has not been loaded. </td> </tr> </table>
    ///    
    HRESULT GetMonitor(VMRGUID* pGUID);
    ///The <code>SetDefaultMonitor</code> method specifies the default monitor that all future instances of the VMR
    ///should use for video playback.
    ///Params:
    ///    pGUID = Pointer to a [VMRGUID](/windows/desktop/api/strmif/ns-strmif-vmrguid) structure that identifies the monitor.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Could not set the specified monitor as the default. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. The specified monitor does not
    ///    exist, or the pGUID parameter was not formatted correctly. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The allocator-presenter has
    ///    not been loaded. </td> </tr> </table>
    ///    
    HRESULT SetDefaultMonitor(const(VMRGUID)* pGUID);
    ///The <code>GetDefaultMonitor</code> method retrieves the default monitor that all future instances of the VMR will
    ///use for video playback.
    ///Params:
    ///    pGUID = Pointer to a [VMRGUID](/windows/desktop/api/strmif/ns-strmif-vmrguid) structure that identifies the default
    ///            monitor on the system.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The allocator-presenter has not been loaded. </td> </tr> </table>
    ///    
    HRESULT GetDefaultMonitor(VMRGUID* pGUID);
    ///The <code>GetAvailableMonitors</code> method retrieves information about the monitors currently available on the
    ///system.
    ///Params:
    ///    pInfo = Pointer to an array of [VMRMONITORINFO](/windows/desktop/api/strmif/ns-strmif-vmrmonitorinfo) structures that
    ///            contain information about each monitor on the system.
    ///    dwMaxInfoArraySize = Specifies the maximum number of members in the array.
    ///    pdwNumDevices = Pointer to a variable that receives the number of devices retrieved.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument; <i>dwMaxInfoArraySize</i> must be greater than zero. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAvailableMonitors(VMRMONITORINFO* pInfo, uint dwMaxInfoArraySize, uint* pdwNumDevices);
}

///The <code>IVMRFilterConfig</code> interface is used to configure the operating mode and video rendering mechanisms of
///the Video Mixing Renderer Filter 7 (VMR-7). For the VMR-9, use the IVMRFilterConfig9 interface. Applications must add
///the VMR to the graph and configure it before connecting it to any upstream filters (for example, in a call to
///IGraphBuilder::RenderFile). Once a filter has been connected to the VMR, the VMR's configuration is locked and all
///future attempts to alter it fail.
@GUID("9E5530C5-7034-48B4-BB46-0B8A6EFC8E36")
interface IVMRFilterConfig : IUnknown
{
    ///The <code>SetImageCompositor</code> method installs an application-provided image compositor.
    ///Params:
    ///    lpVMRImgCompositor = Pointer to the image compositor's IVMRImageCompositor interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The mixer is not currently loaded. </td> </tr> </table>
    ///    
    HRESULT SetImageCompositor(IVMRImageCompositor lpVMRImgCompositor);
    ///The <code>SetNumberOfStreams</code> method sets the number of streams to be mixed and instructs the VMR to go
    ///into mixer mode.
    ///Params:
    ///    dwMaxStreams = Double word containing the maximum number of input streams that the VMR will be required to mix. Must not be
    ///                   greater than MAX_MIXER_STREAMS (16).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> The mixer is already configured. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An attempt was made to configure the mixer for more
    ///    than 16 input streams. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Memory to manage the streams could not be allocated. </td> </tr> </table>
    ///    
    HRESULT SetNumberOfStreams(uint dwMaxStreams);
    ///The <code>GetNumberOfStreams</code> method retrieves the number of input streams being mixed.
    ///Params:
    ///    pdwMaxStreams = Pointer to a double word that receives the number of streams being mixed, which is equal to the number of
    ///                    input pins on the VMR.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <i>pdwMaxStreams</i> is invalid </td> </tr> </table>
    ///    
    HRESULT GetNumberOfStreams(uint* pdwMaxStreams);
    ///The <code>SetRenderingPrefs</code> method sets various application preferences related to video rendering.
    ///Params:
    ///    dwRenderFlags = Double word containing a bitwise OR of VMRRenderPrefs values specifying the rendering preferences.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> No allocator-presenter is present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>dwRenderFlags</i> is invalid. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetRenderingPrefs(uint dwRenderFlags);
    ///The <code>GetRenderingPrefs</code> method retrieves the current set of rendering preferences being used by the
    ///VMR.
    ///Params:
    ///    pdwRenderFlags = Receives a member of the VMRRenderPrefs enumeration, indicating the current rendering preferences.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <i>pdwRenderingPrefs</i> is invalid </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> No allocator-presenter object is currently
    ///    loaded. </td> </tr> </table>
    ///    
    HRESULT GetRenderingPrefs(uint* pdwRenderFlags);
    ///The <code>SetRenderingMode</code> method sets the rendering mode used by the VMR.
    ///Params:
    ///    Mode = Specifies the rendering mode as a VMRMode value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> An invalid rendering mode was specified. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The mode cannot be changed for some reason.
    ///    See Remarks. </td> </tr> </table>
    ///    
    HRESULT SetRenderingMode(uint Mode);
    ///The <code>GetRenderingMode</code> method retrieves the rendering mode currently being used by the VMR.
    ///Params:
    ///    pMode = Pointer to a <b>DWORD</b> that receives a VMRMode value indicating the current rendering mode.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <i>pMode</i> is invalid </td> </tr> </table>
    ///    
    HRESULT GetRenderingMode(uint* pMode);
}

///The <code>IVMRAspectRatioControl</code> interface controls whether the Video Mixing Renderer Filter 7 (VMR-7)
///preserves the aspect ratio of the source video. This interface is available when the VMR-7 is operating in either
///windowed or windowless modes. In windowless mode, the same functionality is provided by the IVMRWindowlessControl
///interface.
@GUID("EDE80B5C-BAD6-4623-B537-65586C9F8DFD")
interface IVMRAspectRatioControl : IUnknown
{
    ///The <code>GetAspectRatioMode</code> method queries whether the VMR will preserve the aspect ratio of the source
    ///video.
    ///Params:
    ///    lpdwARMode = Pointer to a variable that receives a VMR_ASPECT_RATIO_MODE value indicating the aspect ratio mode.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetAspectRatioMode(uint* lpdwARMode);
    ///The <code>SetAspectRatioMode</code> method specifies whether the VMR will preserve the aspect ratio of the source
    ///video.
    ///Params:
    ///    dwARMode = Specifies a member of the VMR_ASPECT_RATIO_MODE enumeration type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT SetAspectRatioMode(uint dwARMode);
}

///The <b>IVMRDeinterlaceControl</b> interface provides support for advanced hardware-accelerated deinterlacing using
///the Video Mixing Renderer Filter 7 (VMR-7). This interface enables applications or other filters to control how the
///VMR manages DirectX Video Acceleration (DirectX VA) hardware deinterlacing.
@GUID("BB057577-0DB8-4E6A-87A7-1A8C9A505A0F")
interface IVMRDeinterlaceControl : IUnknown
{
    ///The <b>GetNumberOfDeinterlaceModes</b> method retrieves the deinterlacing modes available to the VMR for the
    ///specified video format.
    ///Params:
    ///    lpVideoDescription = Pointer to a [VMRVideoDesc](/windows/desktop/api/strmif/ns-strmif-vmrvideodesc) structure that describes the
    ///                         video.
    ///    lpdwNumDeinterlaceModes = Pointer to a <b>DWORD</b> value. On input, this value specifies the size of the array given in
    ///                              <i>lpDeinterlaceModes</i>. On output, it receives number of GUIDs the method copied into the array.
    ///    lpDeinterlaceModes = Address of an array allocated by caller. The method fills the array with GUID values. To determine the size
    ///                         of the array that is needed, set this parameter to <b>NULL</b> and check the value returned in
    ///                         <i>lpdwNumDeinterlaceModes</i>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt> </dl>
    ///    </td> <td width="60%"> The VMR is not in mixer mode. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DDRAW_CAPS_NOT_SUITABLE</b></dt> </dl> </td> <td width="60%"> The video card does not support
    ///    hardware deinterlacing. </td> </tr> </table>
    ///    
    HRESULT GetNumberOfDeinterlaceModes(VMRVideoDesc* lpVideoDescription, uint* lpdwNumDeinterlaceModes, 
                                        GUID* lpDeinterlaceModes);
    ///The <b>GetDeinterlaceModeCaps</b> method retrieves the capabilities of a specific deinterlacing mode supported by
    ///the graphics device driver.
    ///Params:
    ///    lpDeinterlaceMode = Pointer to a GUID that identifies the deinterlacing mode. Call the GetNumberOfDeinterlaceModes method to
    ///                        obtain a list of GUIDs supported by the driver.
    ///    lpVideoDescription = Pointer to a [VMRVideoDesc](/windows/desktop/api/strmif/ns-strmif-vmrvideodesc) structure describing the
    ///                         video to deinterlace. Set the <b>dwSize</b> member of the structure before calling the method.
    ///    lpDeinterlaceCaps = Pointer to a [VMRDeinterlaceCaps](/windows/desktop/api/strmif/ns-strmif-vmrdeinterlacecaps) structure. Set
    ///                        the <b>dwSize</b> member of the structure before calling the method. The method fills the structure with
    ///                        information about the specified deinterlacing mode.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DDRAW_CAPS_NOT_SUITABLE</b></dt> </dl> </td> <td width="60%"> The video card does not support
    ///    hardware deinterlacing. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_VMR_NO_DEINTERLACE_HW</b></dt>
    ///    </dl> </td> <td width="60%"> The video card does not support hardware deinterlacing. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt> </dl> </td> <td width="60%"> The VMR is not in
    ///    mixer mode. </td> </tr> </table>
    ///    
    HRESULT GetDeinterlaceModeCaps(GUID* lpDeinterlaceMode, VMRVideoDesc* lpVideoDescription, 
                                   VMRDeinterlaceCaps* lpDeinterlaceCaps);
    ///The <b>GetDeinterlaceMode</b> method retrieves the deinterlacing mode for the specified video stream.
    ///Params:
    ///    dwStreamID = Index of the video stream to check.
    ///    lpDeinterlaceMode = Pointer to a variable that receives a GUID. The GUID identifies the deinterlacing mode currently in use. If
    ///                        no deinterlacing mode was set, the value is GUID_NULL.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid stream number. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No deinterlacing mode was set. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt> </dl> </td> <td width="60%"> The VMR is not in
    ///    mixer mode. </td> </tr> </table>
    ///    
    HRESULT GetDeinterlaceMode(uint dwStreamID, GUID* lpDeinterlaceMode);
    ///The <b>SetDeinterlaceMode</b> method sets the deinterlacing mode for the specified video stream.
    ///Params:
    ///    dwStreamID = Index of the video stream to set. To set all streams, use the value 0xFFFFFFFF.
    ///    lpDeinterlaceMode = Pointer to a GUID that specifies the deinterlacing mode. To turn off deinterlacing, use the value GUID_NULL.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid stream number. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt> </dl> </td> <td width="60%"> The VMR is not in mixer mode. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetDeinterlaceMode(uint dwStreamID, GUID* lpDeinterlaceMode);
    ///The <b>GetDeinterlacePrefs</b> method queries how the VMR will select a deinterlacing mode if it cannot use the
    ///preferred deinterlacing mode.
    ///Params:
    ///    lpdwDeinterlacePrefs = Pointer to a variable that receives a member of the VMRDeinterlacePrefs enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt>
    ///    </dl> </td> <td width="60%"> The VMR is not in mixer mode. </td> </tr> </table>
    ///    
    HRESULT GetDeinterlacePrefs(uint* lpdwDeinterlacePrefs);
    ///The <b>SetDeinterlacePrefs</b> method specifies how the VMR will select a deinterlacing mode if it cannot use the
    ///preferred deinterlacing mode.
    ///Params:
    ///    dwDeinterlacePrefs = A member of the VMRDeinterlacePrefs enumeration type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt>
    ///    </dl> </td> <td width="60%"> The VMR is not in mixer mode. </td> </tr> </table>
    ///    
    HRESULT SetDeinterlacePrefs(uint dwDeinterlacePrefs);
    ///The <b>GetActualDeinterlaceMode</b> method returns the deinterlacing mode that the VMR is using for a specified
    ///stream.
    ///Params:
    ///    dwStreamID = Index of the video stream.
    ///    lpDeinterlaceMode = Pointer to a variable that receives a GUID value that identifies the deinterlacing mode. The method returns
    ///                        GUID_NULL if the VMR has not initialized the deinterlacing hardware, or if the VMR determines that this
    ///                        stream should not be deinterlaced.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid stream number. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt> </dl> </td> <td width="60%"> The VMR is not in mixer mode. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetActualDeinterlaceMode(uint dwStreamID, GUID* lpDeinterlaceMode);
}

///The <b>IVMRMixerBitmap</b> interface enables an application to blend a static image from a bitmap or DirectDraw
///surface onto the video stream, when using the Video Mixing Renderer Filter 7 (VMR-7). <div class="alert"><b>Note</b>
///For the VMR-9, use the IVMRMixerBitmap9 interface.</div> <div> </div> You can pass images to the VMR as frequently as
///you like, but changing the image several times per second may impact the performance and smoothness of the video
///being rendered. The new image will be blended with the next and all subsequent video frames rendered by the VMR.
///Internally, the VMR uses its mixer component to perform the blending operation. Therefore the VMR must be configured
///correctly prior to commencing video playback. Even if only a single video stream is present, applications should call
///IVMRFilterConfig::SetNumberOfStreams with a value of "1" to cause the VMR to load the mixer and compositor. The image
///can contain embedded per pixel alpha information; this allows the image to contain regions that are transparent.
///Transparent areas can also be identified by a color key value. Changes in the image are only shown on the screen
///while the filter graph is running.
@GUID("1E673275-0257-40AA-AF20-7C608D4A0428")
interface IVMRMixerBitmap : IUnknown
{
    ///The <b>SetAlphaBitmap</b> method specifies a new bitmap image and the source location of the bitmap and how and
    ///where it should be rendered on the destination rectangle.
    ///Params:
    ///    pBmpParms = A oointer to a [VMRALPHABITMAP](/windows/desktop/api/strmif/ns-strmif-vmralphabitmap) structure that contains
    ///                information about the bitmap.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <i>pBmpParms</i> is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. See Remarks. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Could not create a destination
    ///    DC or DIBSection for the bitmap. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> BitBlt to bitmap surface failed. </td> </tr> </table>
    ///    
    HRESULT SetAlphaBitmap(const(VMRALPHABITMAP)* pBmpParms);
    ///The <b>UpdateAlphaBitmapParameters</b> method changes the bitmap location, size and blending value.
    ///Params:
    ///    pBmpParms = A pointer to a [VMRALPHABITMAP](/windows/desktop/api/strmif/ns-strmif-vmralphabitmap) structure.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT UpdateAlphaBitmapParameters(VMRALPHABITMAP* pBmpParms);
    ///The <b>GetAlphaBitmapParameters</b> method retrieves a copy of the current image and related blending parameters.
    ///Params:
    ///    pBmpParms = A pointer to a [VMRALPHABITMAP](/windows/desktop/api/strmif/ns-strmif-vmralphabitmap) structure that receives
    ///                the bitmap, information about the blending values, and the location to blend it.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <i>pBmpParms</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The mixer has not been loaded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAlphaBitmapParameters(VMRALPHABITMAP* pBmpParms);
}

///The <code>IVMRImageCompositor</code> interface is implemented by the default compositor for the Video Mixing Renderer
///Filter 7 (VMR-7). It must also be implemented by any plug-in compositor that an application provides for the VMR-7.
///The VMR-7 calls the methods on this interface to inform the Compositor that it should composite the incoming video
///frames into a single output frame. Applications do not use this interface. For the VMR-9, use the
///IVMRImageCompositor9 interface.
@GUID("7A4FB5AF-479F-4074-BB40-CE6722E43C82")
interface IVMRImageCompositor : IUnknown
{
    ///The <code>InitCompositionTarget</code> method informs the compositor that a new composition target has been
    ///created. The compositor should perform any necessary configuration work in this method. This could include
    ///attaching a Z or stencil buffer buffer for the new render target
    ///Params:
    ///    pD3DDevice = Pointer to the <b>IUnknown</b> interface of the Direct3D device object.
    ///    pddsRenderTarget = Specifies the DirectDraw surface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT InitCompositionTarget(IUnknown pD3DDevice, IDirectDrawSurface7 pddsRenderTarget);
    ///The <code>TermCompositionTarget</code> method informs the compositor that the current composition target is being
    ///replaced. Compositors should perform any necessary cleanup of the composition target in this method.
    ///Params:
    ///    pD3DDevice = Pointer to the <b>IUnknown</b> interface of the Direct3D device object.
    ///    pddsRenderTarget = Specifies the DirectDraw surface
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT TermCompositionTarget(IUnknown pD3DDevice, IDirectDrawSurface7 pddsRenderTarget);
    ///The <code>SetStreamMediaType</code> method sets the media type for the input stream.
    ///Params:
    ///    dwStrmID = Specifies the input stream. The value must be from 1 through 16.
    ///    pmt = Pointer to an AM_MEDIA_TYPE structure that specifies the media type.
    ///    fTexture = If <b>TRUE</b>, specifies that the target surface is a Direct3D texture surface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetStreamMediaType(uint dwStrmID, AM_MEDIA_TYPE* pmt, BOOL fTexture);
    ///The <code>CompositeImage</code> method composites the current frames available in each input stream.
    ///Params:
    ///    pD3DDevice = Pointer to the <b>IUnknown</b> interface of the Direct3D device. The compositor must cast this to a
    ///                 <b>LPDIRECT3DDEVICE7</b> type.
    ///    pddsRenderTarget = Specifies the DirectDraw surface that all drawing should be performed on.
    ///    pmtRenderTarget = Specifies the media type of the DirectDraw surface.
    ///    rtStart = Specifies the start time.
    ///    rtEnd = Specifies the end time.
    ///    dwClrBkGnd = Specifies the background color.
    ///    pVideoStreamInfo = Pointer to an array of video stream info objects.
    ///    cStreams = Specifies the number of streams to be mixed, which is equal to the size of the pVideoStreamInfo array.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT CompositeImage(IUnknown pD3DDevice, IDirectDrawSurface7 pddsRenderTarget, 
                           AM_MEDIA_TYPE* pmtRenderTarget, long rtStart, long rtEnd, uint dwClrBkGnd, 
                           VMRVIDEOSTREAMINFO* pVideoStreamInfo, uint cStreams);
}

///The <code>IVMRVideoStreamControl</code> interface is implemented on each input pin of the Video Mixing Renderer
///Filter 7 (VMR-7). The interface operates on the input stream represented by the pin. This interface is used by
///upstream filters (typically decoders) to get or set the active state of individual streams, or the source color key
///for the composited image. Applications in general should not use this interface. The VMR-9 input pins expose the
///IVMRVideoStreamControl9 interface.
@GUID("058D1F11-2A54-4BEF-BD54-DF706626B727")
interface IVMRVideoStreamControl : IUnknown
{
    ///The <code>SetColorKey</code> method sets the source color key that the VMR will use when compositing the video
    ///image.
    ///Params:
    ///    lpClrKey = Specifies the source color key as a DDCOLORKEY type.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetColorKey(DDCOLORKEY* lpClrKey);
    ///The <code>GetColorKey</code> method retrieves the source color key currently set for this stream.
    ///Params:
    ///    lpClrKey = Address of a DDCOLORKEY structure that receives the source color key.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetColorKey(DDCOLORKEY* lpClrKey);
    ///The <code>SetStreamActiveState</code> method activates or inactivates an input stream.
    ///Params:
    ///    fActive = Specifies the state of the stream. <b>TRUE</b> means active; <b>FALSE</b> means inactive.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetStreamActiveState(BOOL fActive);
    ///The <code>GetStreamActiveState</code> method retrieves the state of the stream.
    ///Params:
    ///    lpfActive = Receives the current state of the stream. <b>TRUE</b> means the stream is active; <b>FALSE</b> means that it
    ///                is inactive.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetStreamActiveState(int* lpfActive);
}

///The <code>IVMRSurface</code> interface is implemented on the media samples used by the Video Mixing Renderer Filter 7
///(VMR-7). Filters can use this interface to access the underlying DirectDraw surface on which the media sample is
///based. Filters must always lock and unlock the surface using the methods available on this interface. Filters must
///never call lock or unlock directly on the DirectDraw surface interface returned from the GetSurface method.
///Applications do not use this interface.
@GUID("A9849BBE-9EC8-4263-B764-62730F0D15D0")
interface IVMRSurface : IUnknown
{
    ///The <code>IsSurfaceLocked</code> method indicates whether the DirectDraw surface attached to this media sample is
    ///locked.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT IsSurfaceLocked();
    ///The <code>LockSurface</code> method locks the attached DirectDraw surface.
    ///Params:
    ///    lpSurface = Address of a variable that receives a pointer to the locked bits.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <i>lpSurface</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> No DirectDraw surface is attached to this sample. </td> </tr> </table>
    ///    
    HRESULT LockSurface(ubyte** lpSurface);
    ///The <code>UnlockSurface</code> method unlocks the attached DirectDraw surface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> No DirectDraw surface is attached to this sample. </td> </tr> </table>
    ///    
    HRESULT UnlockSurface();
    ///The <code>GetSurface</code> method retrieves the attached DirectDraw surface interface.
    ///Params:
    ///    lplpSurface = Address of a variable that receives a pointer to the <b>IDirectDrawSurface7</b> interface. The caller must
    ///                  release the interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt>
    ///    </dl> </td> <td width="60%"> No DirectDraw surface is attached to this sample. </td> </tr> </table>
    ///    
    HRESULT GetSurface(IDirectDrawSurface7* lplpSurface);
}

///The <code>IVMRImagePresenterConfig</code> interface provides methods for setting the renderering preferences on the
///allocator-presenter used by the Video Mixing Renderer Filter 7 (VMR-7). Applications should not use this interface
///directly. The VMR-7 filter's <b>IVMRFilterConfig</b> interface calls methods on this interface. The default
///allocator-presenter implements this interface. Custom allocator-presenters can also expose this interface. For the
///VMR-9, use the IVMRImagePresenterConfig9 interface.
@GUID("9F3A1C85-8555-49BA-935F-BE5B5B29D178")
interface IVMRImagePresenterConfig : IUnknown
{
    ///The <code>SetRenderingPrefs</code> method sets the rendering preferences on the VMR-7 filter's
    ///allocator-presenter. The VMR-7 filter's IVMRFilterConfig::SetRenderingPrefs method calls through to this method.
    ///Params:
    ///    dwRenderFlags = A bitwise OR combination of VMRRenderPrefs flags that will be used to configure the allocator-presenter.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetRenderingPrefs(uint dwRenderFlags);
    ///The <code>GetRenderingPrefs</code> method retrieves the current rendering preferences from the VMR-7 filter's
    ///allocator-presenter. The VMR-7 filter's IVMRFilterConfig::GetRenderingPrefs method calls through to this method.
    ///Params:
    ///    dwRenderFlags = Receives a bitwise OR of flags from the VMRRenderPrefs enumeration, indicating the current rendering settings
    ///                    on the allocator-presenter.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetRenderingPrefs(uint* dwRenderFlags);
}

///The <code>IVMRImagePresenterExclModeConfig</code> interface inherits from IVMRImagePresenterConfig and provides
///methods for setting and retrieving the renderering preferences on the Exclusive Mode Allocator-Presenter. This
///interface is exposed on the DirectDraw Exclusive Mode Allocator-Presenter object. When applications run in DirectDraw
///Exclusive Mode, they must create their own DirectDraw object, configure the VMR to use the Exclusive Mode
///Allocator-Presenter, and use this interface to inform the VMR about the DirectDraw object and the primary surface
///associated with it. For more information, see DirectDraw Exclusive Mode.
@GUID("E6F7CE40-4673-44F1-8F77-5499D68CB4EA")
interface IVMRImagePresenterExclModeConfig : IVMRImagePresenterConfig
{
    ///The <code>SetXlcModeDDObjAndPrimarySurface</code> method informs the VMR of the DirectDraw object and primary
    ///surface that were created by the application.
    ///Params:
    ///    lpDDObj = Specifies the Exclusive Mode DirectDraw object created by the application.
    ///    lpPrimarySurf = Specifies the primary surface associated with the DirectDraw object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetXlcModeDDObjAndPrimarySurface(IDirectDraw7 lpDDObj, IDirectDrawSurface7 lpPrimarySurf);
    ///The <code>GetXlcModeDDObjAndPrimarySurface</code> method retrieves the DirectDraw object and primary surface
    ///currently being used by a VMR that has been configured for DirectDraw Exclusive Mode using the
    ///<b>SetXlcModeDDObjAndPrimarySurface</b> method.
    ///Params:
    ///    lpDDObj = Retrieves the Exclusive Mode DirectDraw object created by the application.
    ///    lpPrimarySurf = Retrieves the primary surface associated with the DirectDraw object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetXlcModeDDObjAndPrimarySurface(IDirectDraw7* lpDDObj, IDirectDrawSurface7* lpPrimarySurf);
}

///The <code>IVPManager</code> interface is implemented on the Video Port Manager (VPM). The interface provides methods
///for applications to specify and retrieve indexes for ports when there are multiple video ports on a system, and to
///specify and retrieve the rectangle used by the video port. Currently, only the two index-related methods are
///implemented.
@GUID("AAC18C18-E186-46D2-825D-A1F8DC8E395A")
interface IVPManager : IUnknown
{
    ///The <code>SetVideoPortIndex</code> method instructs the Video Port Manager (VPM) to connect to the specified
    ///video port.
    ///Params:
    ///    dwVideoPortIndex = Double word containing the video port index.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetVideoPortIndex(uint dwVideoPortIndex);
    ///The <code>GetVideoPortIndex</code> method returns the current video port index being used by the Video Port
    ///Manager (VPM).
    ///Params:
    ///    pdwVideoPortIndex = Pointer to a double word containing the index of the video port that the VPM is currently connected to.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetVideoPortIndex(uint* pdwVideoPortIndex);
}

///<div class="alert"><b>Note</b> This interface has been deprecated. It will continue to be supported for backward
///compatibility with existing applications, but new applications should use IDvdControl2.</div> <div> </div> The
///<code>IDvdControl</code> interface controls the playback and search mechanisms of a DVD title that contains one or
///more video movies. Use this interface to control playback (set root drive, play, stop, and so forth) or use
///DVD-specific functionality such as menus and buttons when playing DVD-Video files.
@GUID("A70EFE61-E2A3-11D0-A9BE-00AA0061BE93")
interface IDvdControl : IUnknown
{
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Finds the media file with the specified title index and plays it back.
    ///Params:
    ///    ulTitle = Value that specifies the title number DirectShow will play back; this value must be from 1 through 99.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value .
    ///    
    HRESULT TitlePlay(uint ulTitle);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Plays the media file with the specified title index and chapter value.
    ///Params:
    ///    ulTitle = Value that specifies the title number DirectShow will play back; this value must be from 1 through 99.
    ///    ulChapter = Value that specifies the chapter within the specified title where DirectShow will start playback; this value
    ///                must be from 1 through 999.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT ChapterPlay(uint ulTitle, uint ulChapter);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Plays the media file with the specified title index, starting at the specified time.
    ///Params:
    ///    ulTitle = Value that specifies the title number DirectShow will play back; this value must be from 1 through 99.
    ///    bcdTime = Pointer to the [DVD_TIMECODE](/windows/desktop/api/strmif/ns-strmif-dvd_timecode) structure where DirectShow
    ///              will start playback.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value .
    ///    
    HRESULT TimePlay(uint ulTitle, uint bcdTime);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Transitions playback to the DVD_DOMAIN_Stop state after saving resume information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT StopForResume();
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Halts playback of the current media file and starts playback of the designated previous program
    ///chain (PGC).
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GoUp();
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Halts playback of the current chapter and starts playback from the specified time in the same media
    ///file.
    ///Params:
    ///    bcdTime = Pointer to the [DVD_TIMECODE](/windows/desktop/api/strmif/ns-strmif-dvd_timecode) structure where DirectShow
    ///              will start playback.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT TimeSearch(uint bcdTime);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Halts playback of the current chapter and starts playback from the specified chapter within the same
    ///title.
    ///Params:
    ///    ulChapter = Chapter value that specifies the point where playback will begin.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT ChapterSearch(uint ulChapter);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Halts playback of the current program and starts playback from the previous program within the
    ///program chain (PGC).
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT PrevPGSearch();
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Halts playback of the current program and restarts playback of the current program within the
    ///program chain (PGC).
    ///Returns:
    ///    Returns an <b>HRESULT</b> value .
    ///    
    HRESULT TopPGSearch();
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Halts playback of the current program and starts playback from the next program within the program
    ///chain (PGC).
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT NextPGSearch();
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Searches forward through the current disc at the specified speed.
    ///Params:
    ///    dwSpeed = Value that specifies how quickly DirectShow will search through the media file. This value is a multiplier,
    ///              where 1.0 is the authored speed, so a value of 2.5 will search forward at two and one-half times the authored
    ///              speed, while a value of 0.5 will search forward at half the authored speed. Note that the actual speed of
    ///              playback depends on the capabilities of the video decoder, and might differ from the specified rate.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT ForwardScan(double dwSpeed);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Searches backward through the current disc at the specified speed.
    ///Params:
    ///    dwSpeed = Value that specifies how quickly DirectShow will search through the media file. This value is a multiplier,
    ///              where 1.0 is the authored speed, so a value of 2.5 will search backward at two and one-half times the
    ///              authored speed, while a value of 0.5 will search backward at half the authored speed. The actual speed of
    ///              playback depends on the capabilities of the video decoder, and might differ from the specified rate.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT BackwardScan(double dwSpeed);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Displays the specified menu on the screen.
    ///Params:
    ///    MenuID = Value that specifies the menu to display. Member of the DVD_MENU_ID enumerated data type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT MenuCall(DVD_MENU_ID MenuID);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Returns to playing back a title from a menu.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT Resume();
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Selects the upper directional button from the displayed menu.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value .
    ///    
    HRESULT UpperButtonSelect();
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Selects the lower directional button from the displayed menu.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT LowerButtonSelect();
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Selects the left directional button from the displayed menu.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT LeftButtonSelect();
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Selects the right directional button from the displayed menu.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT RightButtonSelect();
    ///<div class="alert"><b>Note</b> The IDvdControl interface is deprecated. Use IDvdControl2 instread.</div> <div>
    ///</div> Activates the selected button.
    ///Returns:
    ///    This method does not return a value.
    ///    
    HRESULT ButtonActivate();
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Selects and activates the specified button.
    ///Params:
    ///    ulButton = Value that specifies the button that will be selected and activated, which must be from 1 through 36.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT ButtonSelectAndActivate(uint ulButton);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Resumes playback, canceling still mode.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value .
    ///    
    HRESULT StillOff();
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Pauses the current media file playback.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT PauseOn();
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Resumes playback of the current media file after a pause.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT PauseOff();
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Sets the displayed language for navigation menus.
    ///Params:
    ///    Language = Value that specifies the new language.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT MenuLanguageSelect(uint Language);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Sets the current audio stream.
    ///Params:
    ///    ulAudio = Value that specifies the audio track to use, which must be from 0 through 7.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT AudioStreamChange(uint ulAudio);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Selects the new subpicture stream and enables or disables it for display.
    ///Params:
    ///    ulSubPicture = Value that specifies the source of the subpicture, which must be from 0 through 32, or 63. <table> <tr>
    ///                   <th>Value </th> <th>Description </th> </tr> <tr> <td>0-31</td> <td>Indicates that the stream is valid.</td>
    ///                   </tr> <tr> <td>32</td> <td>Enables you to toggle the display without changing the current stream (that is,
    ///                   change <i>bDisplay</i> without altering the current stream).</td> </tr> <tr> <td>63</td> <td>Indicates that
    ///                   the stream is the dummy stream.</td> </tr> </table>
    ///    bDisplay = Value that specifies whether the subpicture is enabled; <b>TRUE</b> makes the subpicture visible and
    ///               <b>FALSE</b> hides it.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SubpictureStreamChange(uint ulSubPicture, BOOL bDisplay);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Sets the new display angle.
    ///Params:
    ///    ulAngle = Value of the new angle, which must be from 1 through 9.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT AngleChange(uint ulAngle);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Sets the parental access level for the current media file.
    ///Params:
    ///    ulParentalLevel = Value that specifies the current media file parental access level. Should be a value from 1 to 8, inclusive.
    ///                      Predefined parental levels are as follows: <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                      <td>1</td> <td>The rating is G, General.</td> </tr> <tr> <td>3</td> <td>The rating is PG, Parental Guidance
    ///                      Suggested.</td> </tr> <tr> <td>4</td> <td>The rating is PG-13, Parental Guidance Suggested, not recommended
    ///                      for those under 13.</td> </tr> <tr> <td>6</td> <td>The rating is R, Restricted.</td> </tr> <tr> <td>7</td>
    ///                      <td>The rating is NC-17.</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT ParentalLevelSelect(uint ulParentalLevel);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Sets the current country/region for controlling parental access levels.
    ///Params:
    ///    wCountry = Value that specifies the current country/region according to the Alpha-2 Code defined in ISO3166. See
    ///               Remarks.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT ParentalCountrySelect(ushort wCountry);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Sets the audio playback mode to karaoke.
    ///Params:
    ///    ulMode = Requested audio playback mode.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT KaraokeAudioPresentationModeChange(uint ulMode);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Sets the video display mode the user prefers.
    ///Params:
    ///    ulPreferredDisplayMode = Value that specifies the new display mode for DVD content. Member of the
    ///                             [DVD_PREFERRED_DISPLAY_MODE](/windows/desktop/api/strmif/ne-strmif-dvd_preferred_display_mode) enumerated
    ///                             data type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value .
    ///    
    HRESULT VideoModePreferrence(uint ulPreferredDisplayMode);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Sets the root directory containing the DVD-Video volume.
    ///Params:
    ///    pszPath = Pointer to the directory name to set as the root directory.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetRoot(const(wchar)* pszPath);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Selects and activates a DVD button in response to a mouse click.
    ///Params:
    ///    point = Specified point within the display window.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value .
    ///    
    HRESULT MouseActivate(POINT point);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Selects a DVD button in response to mouse movement.
    ///Params:
    ///    point = Specified point within the display window.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT MouseSelect(POINT point);
    ///<div class="alert"><b>Note</b> The <b>IDvdControl</b> interface is deprecated. Use IDvdControl2 instread.</div>
    ///<div> </div> Instructs the DVD player to start playing at the specified chapter within the specified title and
    ///play the number of chapters specified.
    ///Params:
    ///    ulTitle = Title number for playback.
    ///    ulChapter = Chapter number to start playback.
    ///    ulChaptersToPlay = Number of chapters to play from the start chapter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT ChapterPlayAutoStop(uint ulTitle, uint ulChapter, uint ulChaptersToPlay);
}

///<div class="alert"><b>Note</b> This interface has been deprecated. It will continue to be supported for backward
///compatibility with existing applications, but new applications should use IDvdInfo2.</div> <div> </div> The
///<b>IDvdInfo</b> interface enables an application to query for attributes of available DVD titles and the DVD player
///status. It also allows for control of a DVD player beyond Annex J in the DVD specification. Use this interface to
///retrieve details about a DVD-Video or about the current state of the DVD player filter graph.
@GUID("A70EFE60-E2A3-11D0-A9BE-00AA0061BE93")
interface IDvdInfo : IUnknown
{
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the current DVD domain of the DVD player.
    ///Params:
    ///    pDomain = Pointer to the current domain that is a member of the DVD_DOMAIN enumerated type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value . <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentDomain(DVD_DOMAIN* pDomain);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the current playback location.
    ///Params:
    ///    pLocation = Pointer to the retrieved playback location information in a
    ///                [DVD_PLAYBACK_LOCATION](/windows/desktop/api/strmif/ns-strmif-dvd_playback_location) structure.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentLocation(DVD_PLAYBACK_LOCATION* pLocation);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the total playback time for the current title.
    ///Params:
    ///    pulTotalTime = Pointer to the total time in [DVD_TIMECODE](/windows/desktop/api/strmif/ns-strmif-dvd_timecode) format, which
    ///                   includes hours, minutes, seconds, and frames.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTotalTitleTime(uint* pulTotalTime);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the number of available buttons and the currently selected button number.
    ///Params:
    ///    pulButtonsAvailable = Pointer to the number of buttons available.
    ///    pulCurrentButton = Pointer to the number of the current button.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value . <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentButton(uint* pulButtonsAvailable, uint* pulCurrentButton);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the number of available angles and the currently selected angle number.
    ///Params:
    ///    pulAnglesAvailable = Pointer to the retrieved number of available angles. If the value pointed to equals 1, then the current video
    ///                         does not contain multiple angles.
    ///    pulCurrentAngle = Pointer to the retrieved current angle number.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentAngle(uint* pulAnglesAvailable, uint* pulCurrentAngle);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the number of available audio streams and the number of the currently selected audio stream.
    ///Params:
    ///    pulStreamsAvailable = Pointer to the retrieved number of available audio streams
    ///    pulCurrentStream = Pointer to the current stream number.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentAudio(uint* pulStreamsAvailable, uint* pulCurrentStream);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the number of available subpicture streams, the currently selected subpicture stream number, and
    ///whether the subpicture display is disabled.
    ///Params:
    ///    pulStreamsAvailable = Pointer to the retrieved number of available subpicture streams.
    ///    pulCurrentStream = Pointer to the retrieved number of the currently selected subpicture stream.
    ///    pIsDisabled = Pointer to a value indicating whether the subpicture display is disabled.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value . <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentSubpicture(uint* pulStreamsAvailable, uint* pulCurrentStream, int* pIsDisabled);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves which IDvdControl methods are currently valid.
    ///Params:
    ///    pUOP = Pointer to a <b>DWORD</b> value containing bits for all user operations (UOP). Each bit in the <b>DWORD</b>
    ///           represents the state (valid or not valid) of a user operation. If the bit corresponding to a user operation
    ///           is set, then that user operation is prohibited. For more information, see Remarks.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentUOPS(uint* pUOP);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the current contents of all system parameter registers (SPRMs).
    ///Params:
    ///    pRegisterArray = Pointer to the retrieved array of system parameter registers.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAllSPRMs(ushort** pRegisterArray);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the current contents of all general parameter registers (GPRMs).
    ///Params:
    ///    pRegisterArray = Pointer to the retrieved array of general parameter registers.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAllGPRMs(ushort** pRegisterArray);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the language of the specified audio stream within the current title.
    ///Params:
    ///    ulStream = Stream number.
    ///    pLanguage = Pointer to the retrieved language.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAudioLanguage(uint ulStream, uint* pLanguage);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the language of the specified subpicture stream within the current title.
    ///Params:
    ///    ulStream = Stream number.
    ///    pLanguage = Pointer to the retrieved language.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value . <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetSubpictureLanguage(uint ulStream, uint* pLanguage);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves attributes of all video, audio, and subpicture streams for the specified title, including menus.
    ///Params:
    ///    ulTitle = Requested title number. Specify 0xFFFFFFFF for the current title.
    ///    pATR = Pointer to the retrieved attributes structure.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTitleAttributes(uint ulTitle, DVD_ATR* pATR);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves attributes of all video, audio, and subpicture streams for video manager (VMG) menus.
    ///Params:
    ///    pATR = Pointer to the retrieved attributes structure.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetVMGAttributes(DVD_ATR* pATR);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the current video attributes for the current title or menu.
    ///Params:
    ///    pATR = Pointer to the retrieved video attributes.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value . <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentVideoAttributes(ubyte** pATR);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the attributes for the current audio stream in the current title or menu.
    ///Params:
    ///    pATR = Pointer to the retrieved audio attributes.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentAudioAttributes(ubyte** pATR);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the attributes for the current subpicture stream in the current title or menu.
    ///Params:
    ///    pATR = Pointer to the retrieved subpicture attributes.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value . <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt>
    ///    </dl> </td> <td width="60%"> Requested action cannot occur at this point in the movie due to the authoring of
    ///    the current DVD-Video disc. </td> </tr> </table>
    ///    
    HRESULT GetCurrentSubpictureAttributes(ubyte** pATR);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the current DVD volume information.
    ///Params:
    ///    pulNumOfVol = Pointer to the retrieved number of volumes in the volume set.
    ///    pulThisVolNum = Pointer to the retrieved volume number for this root directory.
    ///    pSide = Pointer to the retrieved current disc side
    ///            ([DVD_DISC_SIDE](/windows/desktop/api/strmif/ne-strmif-dvd_disc_side)).
    ///    pulNumOfTitles = Pointer to the retrieved number of titles available in this volume.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value . <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentVolumeInfo(uint* pulNumOfVol, uint* pulThisVolNum, DVD_DISC_SIDE* pSide, 
                                 uint* pulNumOfTitles);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the <b>TXTDT_MG</b> structure, which can contain text descriptions for title name, volume name,
    ///producer name, vocalist name, and so on, in various languages.
    ///Params:
    ///    pTextManager = Pointer to the retrieved text manager.
    ///    ulBufSize = Size of the buffer for <i>pTextManager</i>, in bytes.
    ///    pulActualSize = Pointer to a value containing the number of bytes of data returned.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value . <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetDVDTextInfo(char* pTextManager, uint ulBufSize, uint* pulActualSize);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the current parental level and country/region code settings for the DVD player.
    ///Params:
    ///    pulParentalLevel = Pointer to a value indicating the current parental level.
    ///    pulCountryCode = Pointer to a value indicating the current country/region code.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetPlayerParentalLevel(uint* pulParentalLevel, uint* pulCountryCode);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the number of chapters that are defined for a given title.
    ///Params:
    ///    ulTitle = Title for which to retrieve the number of chapters.
    ///    pulNumberOfChapters = Pointer to the retrieved number of chapters for the specified title.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetNumberOfChapters(uint ulTitle, uint* pulNumberOfChapters);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the parental levels that are defined for a particular title.
    ///Params:
    ///    ulTitle = Title for which parental levels are requested.
    ///    pulParentalLevels = Pointer to a logical OR combination of the parental levels defined for the title. A higher setting will block
    ///                        out more content than a lower setting. Valid parental levels are the following: <ul>
    ///                        <li>DVD_PARENTAL_LEVEL_1</li> <li>DVD_PARENTAL_LEVEL_2</li> <li>DVD_PARENTAL_LEVEL_3</li>
    ///                        <li>DVD_PARENTAL_LEVEL_4</li> <li>DVD_PARENTAL_LEVEL_5</li> <li>DVD_PARENTAL_LEVEL_6</li>
    ///                        <li>DVD_PARENTAL_LEVEL_7</li> <li>DVD_PARENTAL_LEVEL_8</li> </ul>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value . <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTitleParentalLevels(uint ulTitle, uint* pulParentalLevels);
    ///<div class="alert"><b>Note</b> The <b>IDvdInfo</b> interface is deprecated. Use IDvdInfo2 instead.</div> <div>
    ///</div> Retrieves the root directory that is set in the player.
    ///Params:
    ///    pRoot = Pointer to the buffer to receive the root string. Note that the root string uses ANSI characters.
    ///    ulBufSize = Size of buffer passed in, in bytes.
    ///    pulActualSize = Pointer to a value containing the size of the actual data returned.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD is not initialized or domain
    ///    is not DVD_DOMAIN_Title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> Requested action is not supported on this domain (DVD_DOMAIN). </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> Requested action
    ///    cannot occur at this point in the movie due to the authoring of the current DVD-Video disc. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRoot(const(char)* pRoot, uint ulBufSize, uint* pulActualSize);
}

///The <code>IDvdCmd</code> interface waits for DVD commands to start or end. The DVD Navigator creates synchronization
///objects that expose this interface. The application can use the object to block the DVD Navigator until the command
///starts or completes. For more information on using this interface, see Synchronizing DVD Commands. (This topic also
///discusses other ways to synchronize commands without using synchronization objects.)
@GUID("5A4A97E4-94EE-4A55-9751-74B5643AA27D")
interface IDvdCmd : IUnknown
{
    ///The <code>WaitForStart</code> method blocks the DVD Navigator until the command associated with this object
    ///begins.
    ///Returns:
    ///    Returns S_OK if successful or an <b>HRESULT</b> error code otherwise.
    ///    
    HRESULT WaitForStart();
    ///The <code>WaitForEnd</code> method blocks the DVD Navigator until the command associated with this object
    ///completes or is canceled.
    ///Returns:
    ///    Returns S_OK if successful or an <b>HRESULT</b> error code otherwise.
    ///    
    HRESULT WaitForEnd();
}

///The <b>IDvdState</b> interface caches the current state. The object that implements this interface is called a <i>DVD
///bookmark</i>. You can use it to save and restore the DVD state, which includes the playback location, the user's
///parental level, and the DVD region.
@GUID("86303D6D-1C4A-4087-AB42-F711167048EF")
interface IDvdState : IUnknown
{
    ///The <code>GetDiscID</code> method retrieves the unique ID of the disc from which the bookmark was made.
    ///Params:
    ///    pullUniqueID = Receives the ID.
    ///Returns:
    ///    Returns one of the values shown in the following table. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid
    ///    argument </td> </tr> </table>
    ///    
    HRESULT GetDiscID(ulong* pullUniqueID);
    ///The <code>GetParentalLevel</code> method retrieves the user's parental level as saved in the <b>DvdState</b>
    ///object.
    ///Params:
    ///    pulParentalLevel = Receives the parental level.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument </td> </tr> </table>
    ///    
    HRESULT GetParentalLevel(uint* pulParentalLevel);
}

///The <code>IDvdControl2</code> interface navigates and plays DVD-Video titles. The DirectShow DVD Navigator source
///filter implements this interface. After creating a DVD filter graph through the IDvdGraphBuilder interface, a DVD
///player application uses the methods of the <b>IDvdControl2</b> and IDvdInfo2 interfaces to send DVD commands to and
///retrieve state information from the DVD Navigator. <code>IDvdControl2</code> provides the full functionality required
///by the DVD Annex J specification, as well as methods for playback, menu navigation, and parental control. For more
///information on writing a DVD player application using the DVD Navigator, including topics on the DVD filter graph,
///command synchronization, parental controls, menus, and karaoke support, see DVD Applications.</p>Playback
@GUID("33BC7430-EEC0-11D2-8201-00A0C9D74842")
interface IDvdControl2 : IUnknown
{
    ///The <code>PlayTitle</code> method starts playback from the beginning of the specified title.
    ///Params:
    ///    ulTitle = Value that specifies the title number; this value must be from 1 through 99.
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT PlayTitle(uint ulTitle, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>PlayChapterInTitle</code> method starts playback from the beginning of the specified chapter of the
    ///specified title.
    ///Params:
    ///    ulTitle = Value that specifies the title in which the chapter is located; this value must be from 1 through 99.
    ///    ulChapter = Value that specifies the chapter in the specified title where the DVD Navigator will start playback; this
    ///                value must be from 1 through 999.
    ///    dwFlags = Bitwise <b>OR</b> of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT PlayChapterInTitle(uint ulTitle, uint ulChapter, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>PlayAtTimeInTitle</code> method starts playback from the specified time in the specified title.
    ///Params:
    ///    ulTitle = Value that specifies the number of the title to play; this value must be from 1 through 99.
    ///    pStartTime = Pointer to a [DVD_HMSF_TIMECODE](/windows/desktop/api/strmif/ns-strmif-dvd_hmsf_timecode) structure that
    ///                 specifies where playback will begin.
    ///    dwFlags = Bitwise <b>OR</b> of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT PlayAtTimeInTitle(uint ulTitle, DVD_HMSF_TIMECODE* pStartTime, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>Stop</code> method stops playback of a title or menu by moving the DVD Navigator into the DVD Stop
    ///domain.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> Invalid domain. </td>
    ///    </tr> </table>
    ///    
    HRESULT Stop();
    ///The <code>ReturnFromSubmenu</code> method returns the display from a submenu to its parent menu.
    ///Params:
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_NO_GOUP_PGC</b></dt> </dl>
    ///    </td> <td width="60%"> The operation cannot be performed because no GoUp program chain (PGC) is available.
    ///    </td> </tr> </table>
    ///    
    HRESULT ReturnFromSubmenu(uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>PlayAtTime</code> method starts playback from the specified time in the current title.
    ///Params:
    ///    pTime = Pointer to a [DVD_HMSF_TIMECODE](/windows/desktop/api/strmif/ns-strmif-dvd_hmsf_timecode) structure that
    ///            specifies the time at which to start playback.
    ///    dwFlags = Bitwise <b>OR</b> of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP
    ///    control prohibits the operation. </td> </tr> </table>
    ///    
    HRESULT PlayAtTime(DVD_HMSF_TIMECODE* pTime, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>PlayChapter</code> method starts playback from the specified chapter in the current title.
    ///Params:
    ///    ulChapter = Value that specifies the chapter in the current title where the DVD Navigator will start playback; this value
    ///                must be from 1 through 999.
    ///    dwFlags = Bitwise <b>OR</b> of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT PlayChapter(uint ulChapter, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>PlayPrevChapter</code> method starts playback from the beginning of the previous chapter in the current
    ///title.
    ///Params:
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> </table>
    ///    
    HRESULT PlayPrevChapter(uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>ReplayChapter</code> method starts playback from the beginning of the current chapter.
    ///Params:
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> </table>
    ///    
    HRESULT ReplayChapter(uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>PlayNextChapter</code> method starts playback from the beginning of the next chapter in the current
    ///title.
    ///Params:
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> </table>
    ///    
    HRESULT PlayNextChapter(uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>PlayForwards</code> method plays forward at the specified speed from the current location.
    ///Params:
    ///    dSpeed = Value that specifies the playback speed. This value is a multiplier, where 1.0 is the authored speed, so a
    ///             value of 2.5 plays at two and one-half times the authored speed, while a value of 0.5 plays at half the
    ///             authored speed. The actual speed of playback depends on the capabilities of the video decoder. Values below
    ///             0.00001 are converted to 0.00001.
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> </table>
    ///    
    HRESULT PlayForwards(double dSpeed, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>PlayBackwards</code> method plays backward at the specified speed from the current location.
    ///Params:
    ///    dSpeed = Value that specifies the speed of backward play. This value is a multiplier, where 1.0 is the authored speed.
    ///             So, a value of 2.5 plays backward at two and one-half times the authored speed, while a value of 0.5 plays
    ///             backward at half the authored speed. The actual speed of playback depends on the video decoder's capabilities
    ///             and might differ from the specified rate. For reverse play, audio is muted and no subpicture is displayed.
    ///             Any speed below 0.00001 is converted to 0.00001.
    ///    dwFlags = Bitwise <b>OR</b> of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> </table>
    ///    
    HRESULT PlayBackwards(double dSpeed, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>ShowMenu</code> method displays the specified menu, if available.
    ///Params:
    ///    MenuID = A DVD_MENU_ID enumeration value that specifies the menu to display.
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>MenuID</i> parameter is
    ///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid domain. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_MENU_DOES_NOT_EXIST</b></dt> </dl> </td> <td width="60%"> The specified menu does not exist.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td
    ///    width="60%"> UOP control prohibits the operation. </td> </tr> </table>
    ///    
    HRESULT ShowMenu(DVD_MENU_ID MenuID, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>Resume</code> method leaves a menu and resumes playback.
    ///Params:
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_NO_RESUME_INFORMATION</b></dt> </dl> </td> <td width="60%"> Resume was called from the Video
    ///    Manager Menu. </td> </tr> </table>
    ///    
    HRESULT Resume(uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>SelectRelativeButton</code> method sets the specified relative button (upper, lower, right, or left).
    ///Params:
    ///    buttonDir = [DVD_RELATIVE_BUTTON](/windows/desktop/api/strmif/ne-strmif-dvd_relative_button) enumeration value indicating
    ///                the button to select.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> The DVD Navigator
    ///    filter is not in a valid domain. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control prohibits the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT SelectRelativeButton(DVD_RELATIVE_BUTTON buttonDir);
    ///The <code>ActivateButton</code> method activates the currently selected menu button.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is
    ///    in an invalid domain. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt>
    ///    </dl> </td> <td width="60%"> UOP control prohibits the DVD Navigator from entering a paused state. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_NO_BUTTON</b></dt> </dl> </td> <td width="60%"> No button
    ///    is selected. </td> </tr> </table>
    ///    
    HRESULT ActivateButton();
    ///The <code>SelectButton</code> method selects the specified menu button.
    ///Params:
    ///    ulButton = Value from 1 through 36 that specifies the button to select.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is
    ///    in an invalid domain. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_NO_BUTTON</b></dt> </dl> </td>
    ///    <td width="60%"> No button is selected. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control prohibits the DVD
    ///    Navigator from entering a paused state. </td> </tr> </table>
    ///    
    HRESULT SelectButton(uint ulButton);
    ///The <code>SelectAndActivateButton</code> method selects and activates the specified menu button.
    ///Params:
    ///    ulButton = Value from 1 through 36 that specifies the button to select and activate.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>ulButton</i> is out of range.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>ulButton</i> value is valid, but the DVD Navigator filter couldn't activate it. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> </table>
    ///    
    HRESULT SelectAndActivateButton(uint ulButton);
    ///The <code>StillOff</code> method resumes playback, canceling still mode.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The DVD Navigator filter is in a
    ///    menu domain and the menu has buttons. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> Invalid domain. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> </table>
    ///    
    HRESULT StillOff();
    ///<div class="alert"><b>Note</b> This method is deprecated. Applications should call IMediaControl::Pause instead.
    ///For more information, see Data Flow in the DVD Navigator.</div> <div> </div> The <code>Pause</code> method pauses
    ///or resumes playback at the current location.
    ///Params:
    ///    bState = Value of type Boolean that specifies whether to pause playback; <b>TRUE</b> means to pause.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> Invalid domain. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%">
    ///    UOP control prohibits the DVD Navigator from entering a paused state. </td> </tr> </table>
    ///    
    HRESULT Pause(BOOL bState);
    ///The <code>SelectAudioStream</code> method selects the audio stream to play.
    ///Params:
    ///    ulAudio = Value that specifies the audio stream. Valid stream numbers are 0 through 7, or
    ///              <b>DVD_DEFAULT_AUDIO_STREAM</b> to specify the default stream.
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command. This parameter is currently ignored; use DVD_CMD_FLAG_None.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No default audio stream was found; or
    ///    <i>dwFlags</i> is not zero. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> <i>ulAudio</i> is out of range, or doesn't correspond to an audio stream. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The <i>ulAudio</i> value is
    ///    valid, but the DVD Navigator could not set it for some reason. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control prohibits the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_STREAM_DISABLED</b></dt> </dl> </td> <td
    ///    width="60%"> The specified stream is disabled. </td> </tr> </table>
    ///    
    HRESULT SelectAudioStream(uint ulAudio, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>SelectSubpictureStream</code> method sets the subpicture stream to display.
    ///Params:
    ///    ulSubPicture = Value that specifies the subpicture stream, which must be from 0 through 31, or 63. <table> <tr> <th>Value
    ///                   </th> <th>Description </th> </tr> <tr> <td>0-31</td> <td>The stream is valid.</td> </tr> <tr> <td>63</td>
    ///                   <td>The stream is the <i>dummy stream</i>, which means it is a muted, low-bitrate stream.</td> </tr> </table>
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>ulSubPicture</i> is out of
    ///    range or doesn't correspond to an SP stream. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The <i>ulSubPicture</i> parameter is valid, but DVD
    ///    Navigator cannot set it for some other reason. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control prohibits the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid domain. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_STREAM_DISABLED</b></dt>
    ///    </dl> </td> <td width="60%"> The specified stream is disabled. </td> </tr> </table>
    ///    
    HRESULT SelectSubpictureStream(uint ulSubPicture, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>SetSubpictureState</code> method turns the subpicture display on or off.
    ///Params:
    ///    bState = Boolean value that specifies whether the subpicture display is on; <b>TRUE</b> sets subpicture display on for
    ///             subsequent playback.
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is
    ///    in the First Play domain. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control prohibits the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT SetSubpictureState(BOOL bState, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>SelectAngle</code> method sets the new angle when the DVD Navigator is in an angle block.
    ///Params:
    ///    ulAngle = Value of the new angle, which must be from 1 through 9.
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>ulAngle</i> is out of range.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%">
    ///    The DVD Navigator is in the First Play domain. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control prohibits the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_WRONG_SPEED</b></dt> </dl> </td> <td
    ///    width="60%"> The operation cannot be performed at the current playback speed. Set the speed to 1.0. </td>
    ///    </tr> </table>
    ///    
    HRESULT SelectAngle(uint ulAngle, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>SelectParentalLevel</code> method sets the parental access level for the logged-on user.
    ///Params:
    ///    ulParentalLevel = Value that specifies the parental access level for the current user. For details, see Remarks.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> Invalid
    ///    domain. </td> </tr> </table>
    ///    
    HRESULT SelectParentalLevel(uint ulParentalLevel);
    ///The <code>SelectParentalCountry</code> method sets the country/region for interpreting parental access levels and
    ///setting default languages.
    ///Params:
    ///    bCountry = Array of bytes that specifies the current country/region according to ISO 3166.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> The DVD
    ///    Navigator filter is not in a valid domain. </td> </tr> </table>
    ///    
    HRESULT SelectParentalCountry(ubyte* bCountry);
    ///The <code>SelectKaraokeAudioPresentationMode</code> method sends karaoke auxiliary channels to the left or right
    ///speakers.
    ///Params:
    ///    ulMode = Bitwise OR of [DVD_KARAOKE_DOWNMIX](/windows/desktop/api/strmif/ne-strmif-dvd_karaoke_downmix) enumeration
    ///             indicating how to downmix the five karaoke channels to channels 0 and 1, which are usually output to the left
    ///             and right speakers.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_PROP_SET_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The audio decoder does
    ///    not support downmixing. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> The DVD Navigator filter is in an invalid domain. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control prohibits the
    ///    current operation. </td> </tr> </table>
    ///    
    HRESULT SelectKaraokeAudioPresentationMode(uint ulMode);
    ///The <code>SelectVideoModePreference</code> method sets the specified video mode display (wide screen, letterbox,
    ///or pan-scan) for playback.
    ///Params:
    ///    ulPreferredDisplayMode = Value that specifies the new display mode for DVD content. Member of the
    ///                             [DVD_PREFERRED_DISPLAY_MODE](/windows/desktop/api/strmif/ne-strmif-dvd_preferred_display_mode) enumeration.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> Invalid
    ///    domain. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td
    ///    width="60%"> UOP control prohibits the operation. </td> </tr> </table>
    ///    
    HRESULT SelectVideoModePreference(uint ulPreferredDisplayMode);
    ///The <code>SetDVDDirectory</code> method sets the DVD drive that the DVD Navigator filter will read from.
    ///Params:
    ///    pszwPath = Pointer to a wide-character string that specifies the path of the root directory.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pszwPath</i> parameter
    ///    points to an invalid DVD path, or a DVD drive is not found while enumerating. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid domain. For details, see Remarks. </td> </tr> </table>
    ///    
    HRESULT SetDVDDirectory(const(wchar)* pszwPath);
    ///The <code>ActivateAtPosition</code> method activates the menu button under the mouse pointer position.
    ///Params:
    ///    point = Point on the client window area, in screen pixel coordinates.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The click occurred in the highlighted
    ///    button rectangle, and the button was successfully activated. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The point lies outside the valid video region.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The button
    ///    is present but is not working. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt>
    ///    </dl> </td> <td width="60%"> The DVD Navigator is not in a menu domain. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VFW_E_DVD_NO_BUTTON</b></dt> </dl> </td> <td width="60%"> There is no menu button under the mouse
    ///    pointer position. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl>
    ///    </td> <td width="60%"> The operation is inhibited by user operation (UOP) control. </td> </tr> </table>
    ///    
    HRESULT ActivateAtPosition(POINT point);
    ///The <code>SelectAtPosition</code> method highlights the menu button under the mouse pointer position.
    ///Params:
    ///    point = Point on the screen, in screen pixel coordinates.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_NO_BUTTON</b></dt> </dl> </td> <td width="60%"> No button is present at
    ///    the mouse pointer position. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt>
    ///    </dl> </td> <td width="60%"> The DVD Navigator is in the Stop domain. </td> </tr> </table>
    ///    
    HRESULT SelectAtPosition(POINT point);
    ///The <code>PlayChaptersAutoStop</code> method plays the number of chapters specified, starting at the specified
    ///chapter within the specified title.
    ///Params:
    ///    ulTitle = Value that specifies the title in which the chapter is located; this value must be from 1 through 99.
    ///    ulChapter = Value that specifies the chapter in the specified title where the DVD Navigator will start playback; this
    ///                value must be from 1 through 999.
    ///    ulChaptersToPlay = Number of chapters to play from the start chapter.
    ///    dwFlags = Bitwise <b>OR</b> of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is not
    ///    initialized or the title is not a One Sequential PGC Title. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ulTitle</i> value does not exist or is
    ///    greater than the number of titles, or <i>ulChapter</i> does not exist or is greater than the number of
    ///    chapters, or <i>ulChapter</i> plus <i>ulChaptersToPlay</i> is greater than the number of chapters. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_GRAPHNOTREADY</b></dt> </dl> </td> <td width="60%"> The
    ///    graph is not in a running state. </td> </tr> </table>
    ///    
    HRESULT PlayChaptersAutoStop(uint ulTitle, uint ulChapter, uint ulChaptersToPlay, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>AcceptParentalLevelChange</code> method accepts or rejects a request from the DVD Navigator to play
    ///content at a higher parental management level.
    ///Params:
    ///    bAccept = Flag that indicates whether the application accepts the parental management level change. Specify <b>TRUE</b>
    ///              to accept the change and play the higher-level content, or <b>FALSE</b> to reject the change.
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT AcceptParentalLevelChange(BOOL bAccept);
    ///The <b>SetOption</b> method enables or disables an internal behavior flag on the DVD Navigator filter.
    ///Params:
    ///    flag = Specifies which behavior to modify, as a member of the
    ///           [DVD_OPTION_FLAG](/windows/desktop/api/strmif/ne-strmif-dvd_option_flag) enumeration type.
    ///    fState = Specifies the new value of the option given in the <i>flag</i> parameter.
    ///             [DVD_OPTION_FLAG](/windows/desktop/api/strmif/ne-strmif-dvd_option_flag) reference page. </div> <div> </div>
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid flag. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetOption(DVD_OPTION_FLAG flag, BOOL fState);
    ///The <code>SetState</code> method saves the current disc position and state of the DVD Navigator filter.
    ///Params:
    ///    pState = Pointer to the IDvdState interface on the object that contains the state information.
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value otherwise.
    ///    
    HRESULT SetState(IDvdState pState, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>PlayPeriodInTitleAutoStop</code> method starts playback in the specified title from the specified start
    ///time until the specified end time.
    ///Params:
    ///    ulTitle = Value that specifies the title; this value must be from 1 through 99.
    ///    pStartTime = Pointer to a [DVD_HMSF_TIMECODE](/windows/desktop/api/strmif/ns-strmif-dvd_hmsf_timecode) structure that
    ///                 specifies the time at which to start playing.
    ///    pEndTime = Pointer to a [DVD_HMSF_TIMECODE](/windows/desktop/api/strmif/ns-strmif-dvd_hmsf_timecode) structure that
    ///               specifies the time at which to stop playing.
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_OPERATION_INHIBITED</b></dt> </dl> </td> <td width="60%"> UOP control
    ///    prohibits the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT PlayPeriodInTitleAutoStop(uint ulTitle, DVD_HMSF_TIMECODE* pStartTime, DVD_HMSF_TIMECODE* pEndTime, 
                                      uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>SetGPRM</code> method sets a general parameter register value.
    ///Params:
    ///    ulIndex = Register index; may be a value from zero through 15.
    ///    wValue = A 16-bit value contained in the specified register.
    ///    dwFlags = Bitwise OR of one or more flags from the DVD_CMD_FLAGS enumeration, specifying how to synchronize the
    ///              command.
    ///    ppCmd = Receives a pointer to an IDvdCmd object that can be used to synchronize DVD commands. The caller must release
    ///            the interface. This parameter can be <b>NULL</b>. For more information, see Synchronizing DVD Commands.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ulIndex</i> parameter is
    ///    greater than 15 or any other of the input parameters are invalid. </td> </tr> </table>
    ///    
    HRESULT SetGPRM(uint ulIndex, ushort wValue, uint dwFlags, IDvdCmd* ppCmd);
    ///The <code>SelectDefaultMenuLanguage</code> method sets the default language for all menus and menu buttons.
    ///Params:
    ///    Language = Variable of type LCID that specifies the default language.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> The DVD
    ///    Navigator is not in a valid domain. </td> </tr> </table>
    ///    
    HRESULT SelectDefaultMenuLanguage(uint Language);
    ///The <code>SelectDefaultAudioLanguage</code> method sets the default audio language.
    ///Params:
    ///    Language = Locale identifier that specifies the default language.
    ///    audioExtension = [DVD_AUDIO_LANG_EXT](/windows/desktop/api/strmif/ne-strmif-dvd_audio_lang_ext) enumeration that specifies the
    ///                     default audio language extension.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>audioExtension</i> value
    ///    is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td
    ///    width="60%"> The DVD Navigator filter is not in the Stop domain. </td> </tr> </table>
    ///    
    HRESULT SelectDefaultAudioLanguage(uint Language, DVD_AUDIO_LANG_EXT audioExtension);
    ///The <code>SelectDefaultSubpictureLanguage</code> method sets the default language for subpicture text.
    ///Params:
    ///    Language = Locale identifier that specifies the default language.
    ///    subpictureExtension = [DVD_SUBPICTURE_LANG_EXT](/windows/desktop/api/strmif/ne-strmif-dvd_subpicture_lang_ext) enumeration that
    ///                          specifies the default subpicture extension.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>Language</i> is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> The DVD
    ///    Navigator filter is not in a valid domain. </td> </tr> </table>
    ///    
    HRESULT SelectDefaultSubpictureLanguage(uint Language, DVD_SUBPICTURE_LANG_EXT subpictureExtension);
}

///The <code>IDvdInfo2</code> interface reports attributes of a DVD disc or the current state of DVD playback and
///navigation. The DVD Navigator filter implements this interface. <code>IDvdInfo2</code> is the companion interface to
///IDvdControl2 interface. <code>IDvdInfo2</code> groups the DVD Navigator's "get" methods and <b>IDvdControl2</b>
///groups the "set" methods. Together they provide DVD navigation and playback functionality beyond the DVD Annex J
///specification. <div class="alert"><b>Note</b> The information provided by some of these methods can also be obtained
///through event notifications sent from the DVD Navigator to the application's message loop. For example, to get the
///current DVD domain, you can call IDvdInfo2::GetCurrentDomain or you can handle the EC_DVD_DOMAIN_CHANGE event in your
///application's message loop and extract the new domain from the event's <i>lParam1</i> parameter.</div> <div> </div>
@GUID("34151510-EEC0-11D2-8201-00A0C9D74842")
interface IDvdInfo2 : IUnknown
{
    ///The <code>GetCurrentDomain</code> method retrieves the domain in which the DVD Navigator is currently located.
    ///Params:
    ///    pDomain = Pointer to a variable of type DVD_DOMAIN that receives the current domain.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetCurrentDomain(DVD_DOMAIN* pDomain);
    ///The <code>GetCurrentLocation</code> method retrieves the current playback location.
    ///Params:
    ///    pLocation = Pointer to a variable of type
    ///                [DVD_PLAYBACK_LOCATION2](/windows/desktop/api/strmif/ns-strmif-dvd_playback_location2) that receives the
    ///                playback location information.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pLocation</i>
    ///    parameter is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl>
    ///    </td> <td width="60%"> The DVD Navigator is in an invalid domain. </td> </tr> </table>
    ///    
    HRESULT GetCurrentLocation(DVD_PLAYBACK_LOCATION2* pLocation);
    ///The <code>GetTotalTitleTime</code> method retrieves the total playback time for the current title.
    ///Params:
    ///    pTotalTime = Pointer to a [DVD_HMSF_TIMECODE](/windows/desktop/api/strmif/ns-strmif-dvd_hmsf_timecode) structure that
    ///                 receives the total time in hours, minutes, seconds, and frames.
    ///    ulTimeCodeFlags = Receives a [DVD_TIMECODE_FLAGS](/windows/desktop/api/strmif/ne-strmif-dvd_timecode_flags) value indicating
    ///                      the frame rate at which the disc was authored to play. Specify <b>NULL</b> if you don't want to receive the
    ///                      timecode information.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> The DVD
    ///    Navigator is not in the title domain. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_S_DVD_NON_ONE_SEQUENTIAL</b></dt> </dl> </td> <td width="60%"> The title is not a one sequential
    ///    video title, so the timing information might not be continuous. </td> </tr> </table>
    ///    
    HRESULT GetTotalTitleTime(DVD_HMSF_TIMECODE* pTotalTime, uint* ulTimeCodeFlags);
    ///The <code>GetCurrentButton</code> method retrieves the number of available buttons and the number of the
    ///currently selected button.
    ///Params:
    ///    pulButtonsAvailable = Receives the number of buttons available.
    ///    pulCurrentButton = Receives the number (from 1 through 36) of the currently selected button.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> One of the pointer arguments is
    ///    not valid. </td> </tr> </table>
    ///    
    HRESULT GetCurrentButton(uint* pulButtonsAvailable, uint* pulCurrentButton);
    ///The <code>GetCurrentAngle</code> method retrieves the number of available angles in the current angle block and
    ///the currently selected angle number.
    ///Params:
    ///    pulAnglesAvailable = Receives the number of available angles. There are up to nine angles in an angle block, numbered 1 through 9.
    ///                         If the value equals 1, then the DVD Navigator is not in an angle block.
    ///    pulCurrentAngle = Receives the current angle number.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> DVD Navigator
    ///    is not initialized or not in a valid domain. </td> </tr> </table>
    ///    
    HRESULT GetCurrentAngle(uint* pulAnglesAvailable, uint* pulCurrentAngle);
    ///The <code>GetCurrentAudio</code> method retrieves the number of available audio streams and the number of the
    ///currently selected audio stream.
    ///Params:
    ///    pulStreamsAvailable = Receives the number of available audio streams.
    ///    pulCurrentStream = Receives the currently selected audio stream number in the current title.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Input arguments are invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%">
    ///    The DVD Navigator is not initialized or not in a valid domain. </td> </tr> </table>
    ///    
    HRESULT GetCurrentAudio(uint* pulStreamsAvailable, uint* pulCurrentStream);
    ///The <code>GetCurrentSubpicture</code> method retrieves the number of available subpicture streams in the current
    ///title, the currently selected subpicture stream number, and the state of the subpicture.
    ///Params:
    ///    pulStreamsAvailable = Receives the number of available subpicture streams.
    ///    pulCurrentStream = Receives the number of the currently selected subpicture stream.
    ///    pbIsDisabled = Receives a Boolean value that indicates whether the subpicture display is disabled; <b>TRUE</b> means it is
    ///                   disabled.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> The DVD
    ///    Navigator is not initialized or not in the Title domain. </td> </tr> </table>
    ///    
    HRESULT GetCurrentSubpicture(uint* pulStreamsAvailable, uint* pulCurrentStream, int* pbIsDisabled);
    ///The <code>GetCurrentUOPS</code> method retrieves a set of flags indicating which navigation commands, if any, the
    ///content authors have explicitly disabled for the current disc location.
    ///Params:
    ///    pulUOPs = Receives a bitwise [VALID_UOP_FLAG](/windows/desktop/api/strmif/ne-strmif-valid_uop_flag) values. Each bit
    ///              represents the state (valid or not valid) of a user operation (UOP). If the bit is set, then that user
    ///              operation is prohibited. See Remarks.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <i>pulUOPs</i> is not a valid
    ///    pointer. </td> </tr> </table>
    ///    
    HRESULT GetCurrentUOPS(uint* pulUOPs);
    ///The <b>GetAllSPRMs</b> method retrieves the current contents of all system parameter registers (SPRMs).
    ///Params:
    ///    pRegisterArray = Pointer to an array of type SPRMARRAY that receives the address of an array of SPRMs.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAllSPRMs(ushort** pRegisterArray);
    ///The <b>GetAllGPRMs</b> method retrieves the current contents of all general parameter registers (GPRMs).
    ///Params:
    ///    pRegisterArray = Pointer to an array of type GPRMARRAY that receives all 16 current GPRM values.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAllGPRMs(ushort** pRegisterArray);
    ///The <code>GetAudioLanguage</code> method retrieves the language of the specified audio stream within the current
    ///title.
    ///Params:
    ///    ulStream = Audio stream number for the language being retrieved.
    ///    pLanguage = Receives the language information.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pLanguage</i>
    ///    parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The DVD Navigator is not initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> DVD Navigator is not in a valid domain.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetAudioLanguage(uint ulStream, uint* pLanguage);
    ///The <code>GetSubpictureLanguage</code> method retrieves the language of the specified subpicture stream within
    ///the current title.
    ///Params:
    ///    ulStream = Number of the subpicture stream for which the language is being retrieved.
    ///    pLanguage = Pointer to an LCID that receives the locale information. The language information can then be extracted from
    ///                the LCID by using the Win32 <b>MAKELANGID</b> macro.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> The DVD
    ///    Navigator is not initialized or not in a valid domain. </td> </tr> </table>
    ///    
    HRESULT GetSubpictureLanguage(uint ulStream, uint* pLanguage);
    ///The <code>GetTitleAttributes</code> method retrieves attributes of all video, audio, and subpicture streams for
    ///the specified title and its menus.
    ///Params:
    ///    ulTitle = Variable of type ULONG, from 1 through 99, specifying the requested title number. Specify 0xFFFFFFFF for the
    ///              current title.
    ///    pMenu = Pointer to a [DVD_MenuAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_menuattributes) structure that
    ///            receives the attributes of the menu associated with the specified title.
    ///    pTitle = Pointer to a [DVD_TitleAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_titleattributes) structure that
    ///             receives the attributes of the specified title.
    ///Returns:
    ///    Returns one of the following <code>HRESULT</code> values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>nTitle</i> parameter is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDDOMAIN</b></dt>
    ///    </dl> </td> <td width="60%"> The DVD Navigator is not in the title domain. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pMenu</i> or <i>pTitle</i> parameter is
    ///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD
    ///    Navigator is not initialized or some other internal error occurred. </td> </tr> </table>
    ///    
    HRESULT GetTitleAttributes(uint ulTitle, DVD_MenuAttributes* pMenu, DVD_TitleAttributes* pTitle);
    ///The <code>GetVMGAttributes</code> method retrieves attributes of all video, audio, and subpicture streams for the
    ///Video Manager Menu.
    ///Params:
    ///    pATR = Pointer to a [DVD_MenuAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_menuattributes) structure that
    ///           receives the attributes.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is not
    ///    initialized. </td> </tr> </table>
    ///    
    HRESULT GetVMGAttributes(DVD_MenuAttributes* pATR);
    ///The <code>GetCurrentVideoAttributes</code> method retrieves the video attributes of the current title or menu.
    ///Params:
    ///    pATR = Pointer to a DVD_VideoAttributes structure that receives the attributes.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is not
    ///    initialized. </td> </tr> </table>
    ///    
    HRESULT GetCurrentVideoAttributes(DVD_VideoAttributes* pATR);
    ///The <code>GetAudioAttributes</code> method retrieves the attributes of the specified audio stream in the current
    ///title or menu.
    ///Params:
    ///    ulStream = Variable of type ULONG specifying the audio stream whose attributes you wish to query. See Remarks.
    ///    pATR = Pointer to a [DVD_AudioAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_audioattributes) structure that
    ///           is filled with the attributes of the specified audio stream.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_NO_ATTRIBUTES</b></dt> </dl> </td> <td
    ///    width="60%"> The stream's audio attributes are not available. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT GetAudioAttributes(uint ulStream, DVD_AudioAttributes* pATR);
    ///The <code>GetKaraokeAttributes</code> method retrieves the karaoke attributes of the specified audio stream in
    ///the current title or menu.
    ///Params:
    ///    ulStream = Specifies the index of the audio stream whose attributes you want to query. See Remarks.
    ///    pAttributes = Pointer to a [DVD_KaraokeAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_karaokeattributes) structure
    ///                  that is filled with the karaoke attributes.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_NOT_IN_KARAOKE_MODE</b></dt> </dl> </td>
    ///    <td width="60%"> The specified stream is not in karaoke format. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is not in the title
    ///    domain. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_NO_ATTRIBUTES</b></dt> </dl> </td> <td
    ///    width="60%"> The karaoke attributes for the specified stream are not available. </td> </tr> </table>
    ///    
    HRESULT GetKaraokeAttributes(uint ulStream, DVD_KaraokeAttributes* pAttributes);
    ///The <code>GetSubpictureAttributes</code> method retrieves the attributes of the specified subpicture stream in
    ///the specified title or menu.
    ///Params:
    ///    ulStream = Index number, from 0 through 31, of the subpicture stream to query. See Remarks.
    ///    pATR = Pointer to a [DVD_SubpictureAttributes](/windows/desktop/api/strmif/ns-strmif-dvd_subpictureattributes)
    ///           structure that receives the subpicture attributes.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> No subpicture streams were found.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_NO_ATTRIBUTES</b></dt> </dl> </td> <td
    ///    width="60%"> The subpicture has no defined attributes. </td> </tr> </table>
    ///    
    HRESULT GetSubpictureAttributes(uint ulStream, DVD_SubpictureAttributes* pATR);
    ///The <code>GetDVDVolumeInfo</code> method retrieves the current DVD volume information.
    ///Params:
    ///    pulNumOfVolumes = Receives the number of volumes in the volume set.
    ///    pulVolume = Receives the volume number for this root directory.
    ///    pSide = Pointer to a variable of type [DVD_DISC_SIDE](/windows/desktop/api/strmif/ne-strmif-dvd_disc_side) that
    ///            receives the current disc side.
    ///    pulNumOfTitles = Pointer to a variable of type ULONG that receives the number of titles available in this volume.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetDVDVolumeInfo(uint* pulNumOfVolumes, uint* pulVolume, DVD_DISC_SIDE* pSide, uint* pulNumOfTitles);
    ///The <code>GetDVDTextNumberOfLanguages</code> method retrieves the number of languages in which DVD text strings
    ///appear.
    ///Params:
    ///    pulNumOfLangs = Receives the number of text languages.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected internal
    ///    error occurred. </td> </tr> </table>
    ///    
    HRESULT GetDVDTextNumberOfLanguages(uint* pulNumOfLangs);
    ///The <code>GetDVDTextLanguageInfo</code> method retrieves information about the text strings for a specified
    ///language. The method retrieves the number of strings for that language, the locale identifier, and the character
    ///set.
    ///Params:
    ///    ulLangIndex = Zero-based index of the language to query. To find the number of text-string languages on the DVD, call
    ///                  IDvdInfo2::GetDVDTextNumberOfLanguages.
    ///    pulNumOfStrings = Receives the number of text strings for the specified language.
    ///    pLangCode = Receives a <i>locale identifier</i> (LCID) that specifies the language in which the text is written. For
    ///                example, the LCID for "en-us" is 0x0409.
    ///    arg4 = Receives a member of the DVD_TextCharSet enumeration. The value specifies the character set of the text
    ///           string.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> This DVD does not have any
    ///    text strings, or the <i>ulLangIndex</i> parameter is out of bounds. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected internal error
    ///    occurred. </td> </tr> </table>
    ///    
    HRESULT GetDVDTextLanguageInfo(uint ulLangIndex, uint* pulNumOfStrings, uint* pLangCode, 
                                   DVD_TextCharSet* pbCharacterSet);
    ///The <code>GetDVDTextStringAsNative</code> method retrieves a DVD text string for a specified language, and
    ///returns the text string as an array of bytes.
    ///Params:
    ///    ulLangIndex = Zero-based index of the language. To find the number of text-string languages on the DVD, call
    ///                  IDvdInfo2::GetDVDTextNumberOfLanguages.
    ///    ulStringIndex = Zero-based index of the string to retrieve. To find the number of strings for a given language, call
    ///                    IDvdInfo2::GetDVDTextLanguageInfo.
    ///    pbBuffer = Pointer to a buffer that receives the text string. If <i>pchBuffer</i> is <b>NULL</b>, this method returns
    ///               the size of the string in <i>pulActualSize</i>.
    ///    ulMaxBufferSize = Size of the <i>pchBuffer</i> in bytes
    ///    pulActualSize = Receives the actual length of the string in bytes, including the terminating <b>NULL</b>.
    ///    arg6 = Receives a member of the DVD_TextStringType enumeration. The value indicates the type of text string, such as
    ///           movie title or song name. This parameter can also receive values that are not defined in the
    ///           <b>DVD_TextStringType</b> enumeration.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected internal
    ///    error occurred. </td> </tr> </table>
    ///    
    HRESULT GetDVDTextStringAsNative(uint ulLangIndex, uint ulStringIndex, ubyte* pbBuffer, uint ulMaxBufferSize, 
                                     uint* pulActualSize, DVD_TextStringType* pType);
    ///The <code>GetDVDTextStringAsUnicode</code> method retrieves a DVD text string for a specified language, and
    ///returns the text string as a Unicode string.
    ///Params:
    ///    ulLangIndex = Zero-based index of the language. To find the number of text-string languages on the DVD, call
    ///                  IDvdInfo2::GetDVDTextNumberOfLanguages.
    ///    ulStringIndex = Zero-based index of the string to retrieve. To find the number of strings for a given language, call
    ///                    IDvdInfo2::GetDVDTextLanguageInfo.
    ///    pchwBuffer = Pointer to a buffer that receives the text string. If <i>pchBuffer</i> is <b>NULL</b>, this method returns
    ///                 the size of the string in <i>pulActualSize</i>.
    ///    ulMaxBufferSize = Size of the <i>pchBuffer</i> buffer, in <b>WCHARs</b>.
    ///    pulActualSize = Receives the actual length of the string in characters, including the terminating <b>NULL</b>.
    ///    arg6 = Receives a member of the DVD_TextStringType enumeration. The value indicates the type of text string, such as
    ///           movie title or song name. This parameter can also receive values that are not defined in the
    ///           <b>DVD_TextStringType</b> enumeration.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unsupported te </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected internal error
    ///    occurred. </td> </tr> </table>
    ///    
    HRESULT GetDVDTextStringAsUnicode(uint ulLangIndex, uint ulStringIndex, ushort* pchwBuffer, 
                                      uint ulMaxBufferSize, uint* pulActualSize, DVD_TextStringType* pType);
    ///The <code>GetPlayerParentalLevel</code> method retrieves the current parental level and ISO 3166 country/region
    ///code settings for the DVD Navigator.
    ///Params:
    ///    pulParentalLevel = Receives a value indicating the current parental level. Valid parental levels are 1 through 8 if parental
    ///                       management is enabled, 0xFFFFFFFF if parental management is disabled.
    ///    pbCountryCode = Address of a two-byte array that receives the current country/region code (ISO 3166 Alpha-2 Code).
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> A parameter is invalid. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetPlayerParentalLevel(uint* pulParentalLevel, ubyte* pbCountryCode);
    ///The <code>GetNumberOfChapters</code> method retrieves the number of chapters in a given title.
    ///Params:
    ///    ulTitle = Specifies the title.
    ///    pulNumOfChapters = Receives the number of chapters for the specified title.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> A parameter is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The DVD
    ///    Navigator is not initialized. </td> </tr> </table>
    ///    
    HRESULT GetNumberOfChapters(uint ulTitle, uint* pulNumOfChapters);
    ///The <code>GetTitleParentalLevels</code> method retrieves the parental levels that are defined for a particular
    ///title.
    ///Params:
    ///    ulTitle = Title for which parental levels are requested. Specify 0xfffffff to return the parental levels for the
    ///              current title.
    ///    pulParentalLevels = Pointer to a variable of type ULONG that receives a bitwise OR combination of
    ///                        [DVD_PARENTAL_LEVEL](/windows/desktop/api/strmif/ne-strmif-dvd_parental_level) values defined for the title.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is not
    ///    initialized. </td> </tr> </table>
    ///    
    HRESULT GetTitleParentalLevels(uint ulTitle, uint* pulParentalLevels);
    ///The <code>GetDVDDirectory</code> method retrieves the root directory that is set in the DVD Navigator.
    ///Params:
    ///    pszwPath = Pointer to a buffer that receives the path string.
    ///    ulMaxSize = Size of the buffer, in WCHARs.
    ///    pulActualSize = Pointer to a variable that receives the size of actual data returned, in WCHARs.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The buffer is not large
    ///    enough to hold the string. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt>
    ///    </dl> </td> <td width="60%"> The DVD Navigator is not in a valid domain. </td> </tr> </table>
    ///    
    HRESULT GetDVDDirectory(const(wchar)* pszwPath, uint ulMaxSize, uint* pulActualSize);
    ///The <code>IsAudioStreamEnabled</code> method determines if the specified audio stream is enabled in the current
    ///title.
    ///Params:
    ///    ulStreamNum = Audio stream number to test.
    ///    pbEnabled = Pointer to a variable of type BOOL that receives a value of <b>TRUE</b> if the audio stream is enabled, or
    ///                <b>FALSE</b> otherwise.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is not
    ///    initialized. </td> </tr> </table>
    ///    
    HRESULT IsAudioStreamEnabled(uint ulStreamNum, int* pbEnabled);
    ///The <code>GetDiscID</code> method retrieves a system-generated 64-bit identification number for the specified
    ///DVD.
    ///Params:
    ///    pszwPath = Path of the volume to use for the disc ID. Specify <b>NULL</b> to use the current or default DVD volume.
    ///    pullDiscID = Receives the 64-bit disc ID.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_INVALID_DISC</b></dt> </dl> </td> <td
    ///    width="60%"> The specified path is not a valid DVD disc. </td> </tr> </table>
    ///    
    HRESULT GetDiscID(const(wchar)* pszwPath, ulong* pullDiscID);
    ///The <code>GetState</code> method retrieves a bookmark containing the disc location and DVD Navigator state
    ///information.
    ///Params:
    ///    pStateData = Receives a pointer to the IDvdState interface of a <b>DvdState</b> object allocated by the DVD Navigator.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> DVD Navigator is not
    ///    initialized. </td> </tr> </table>
    ///    
    HRESULT GetState(IDvdState* pStateData);
    ///The <code>GetMenuLanguages</code> method retrieves all the languages available for all menus on the disc.
    ///Params:
    ///    pLanguages = Pointer to an <b>LCID</b> array that receives the languages returned. To retrieve only the number of
    ///                 languages available for menus, and not the actual languages themselves, specify <b>NULL</b> for
    ///                 <i>pLanguages</i>.
    ///    ulMaxLanguages = Maximum number of languages to retrieve.
    ///    pulActualLanguages = Receives the actual number of languages retrieved.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is not
    ///    initialized. </td> </tr> </table>
    ///    
    HRESULT GetMenuLanguages(uint* pLanguages, uint ulMaxLanguages, uint* pulActualLanguages);
    ///The <code>GetButtonAtPosition</code> method retrieves the button located at the specified point within the
    ///display window.
    ///Params:
    ///    point = Current mouse pointer position as retrieved through the Win32 WM_MOUSEMOVE message.
    ///    pulButtonIndex = Receives the index (from 1 through 36) of the button at the current mouse pointer position.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>puButtonIndex</i>
    ///    parameter is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_NO_BUTTON</b></dt> </dl> </td>
    ///    <td width="60%"> No button at <i>point</i>. </td> </tr> </table>
    ///    
    HRESULT GetButtonAtPosition(POINT point, uint* pulButtonIndex);
    ///The <code>GetCmdFromEvent</code> method retrieves an IDvdCmd object from an EC_DVD_CMD_START or EC_DVD_CMD_END
    ///event.
    ///Params:
    ///    lParam1 = Event notification's <i>lParam1</i> parameter.
    ///    pCmdObj = Receives a pointer to the IDvdCmd interface that is associated with the command that fired the event.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The command no longer exists. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid argument.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetCmdFromEvent(ptrdiff_t lParam1, IDvdCmd* pCmdObj);
    ///The <code>GetDefaultMenuLanguage</code> method retrieves the default menu language.
    ///Params:
    ///    pLanguage = Receives the language information.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pLanguage</i>
    ///    parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The DVD Navigator is not initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> DVD Navigator is not in a valid domain.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetDefaultMenuLanguage(uint* pLanguage);
    ///The <code>GetDefaultAudioLanguage</code> method retrieves the default audio language.
    ///Params:
    ///    pLanguage = Receives the default language information.
    ///    pAudioExtension = Pointer to a variable of type [DVD_AUDIO_LANG_EXT](/windows/desktop/api/strmif/ne-strmif-dvd_audio_lang_ext)
    ///                      that receives a value indicating the default DVD audio language extension.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pLanguage</i>
    ///    parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The DVD Navigator is not initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> DVD Navigator is not in a valid domain.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetDefaultAudioLanguage(uint* pLanguage, DVD_AUDIO_LANG_EXT* pAudioExtension);
    ///The <code>GetDefaultSubpictureLanguage</code> method retrieves the default subpicture language.
    ///Params:
    ///    pLanguage = Receives the language information.
    ///    pSubpictureExtension = Pointer to a variable of type
    ///                           [DVD_SUBPICTURE_LANG_EXT](/windows/desktop/api/strmif/ne-strmif-dvd_subpicture_lang_ext) that receives one of
    ///                           the allowable values indicating the default language extension.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pLanguage</i>
    ///    parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The DVD Navigator is not initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_INVALIDDOMAIN</b></dt> </dl> </td> <td width="60%"> DVD Navigator is not in a valid domain.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetDefaultSubpictureLanguage(uint* pLanguage, DVD_SUBPICTURE_LANG_EXT* pSubpictureExtension);
    ///The <code>GetDecoderCaps</code> method retrieves the DVD decoder's maximum data rate for video, audio, and
    ///subpicture (in forward and reverse) as well as support for various types of audio (AC-3, MPEG-2, DTS, SDDS,
    ///LPCM).
    ///Params:
    ///    pCaps = Pointer to a variable of type [DVD_DECODER_CAPS](/windows/desktop/api/strmif/ns-strmif-dvd_decoder_caps) that
    ///            receives the information about the decoder.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The filter graph has not
    ///    been initialized. </td> </tr> </table>
    ///    
    HRESULT GetDecoderCaps(DVD_DECODER_CAPS* pCaps);
    ///The <code>GetButtonRect</code> method retrieves the rectangle coordinates for the specified menu button. <div
    ///class="alert"><b>Note</b> This method is currently not implemented.</div> <div> </div>
    ///Params:
    ///    ulButton = Specifies the menu button.
    ///    pRect = Pointer to a variable of type RECT that receives the coordinates of the button's rectangle.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is
    ///    currently not implemented </td> </tr> </table>
    ///    
    HRESULT GetButtonRect(uint ulButton, RECT* pRect);
    ///The <code>IsSubpictureStreamEnabled</code> method determines if the specified subpicture stream is enabled in the
    ///current title.
    ///Params:
    ///    ulStreamNum = Subpicture stream number to test.
    ///    pbEnabled = Pointer to a variable of type BOOL that receives a value of <b>TRUE</b> if the audio stream is enabled, or
    ///                <b>FALSE</b> otherwise.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The DVD Navigator is not
    ///    initialized. </td> </tr> </table>
    ///    
    HRESULT IsSubpictureStreamEnabled(uint ulStreamNum, int* pbEnabled);
}

///The <code>IDvdGraphBuilder</code> interface builds a filter graph for DVD-Video playback. The DVD Graph Builder
///object implements this interface. The RenderDvdVideoVolume method builds a DVD playback graph from the available
///software and hardware on the system. For information on how to build the DVD filter graph and obtain the pointers to
///all the necessary interfaces, see Building the DVD Filter Graph. <div class="alert"><b>Note</b> A DVD filter graph
///requires either a hardware or software MPEG-2 decoder.</div> <div> </div> Generally, you should not add, remove,
///connect, disconnect, or access individual filters in the graph created by <b>RenderDvdVideoVolume</b>, because doing
///so might confuse the cleanup code. The purpose of the <b>DvdGraphBuilder</b> object is to simplify the development of
///DVD-Video applications. If you need a specific type of graph for a particular solution, you should manually create
///the entire filter graph.
@GUID("FCC152B6-F372-11D0-8E00-00C04FD7C08B")
interface IDvdGraphBuilder : IUnknown
{
    ///The <code>GetFiltergraph</code> method retrieves the IGraphBuilder interface for the filter graph used by the
    ///DVD-Video graph builder object.
    ///Params:
    ///    ppGB = Address of a pointer to the IGraphBuilder interface that the DVD-Video graph builder object is using.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. The current DirectShow
    ///    implementation returns E_INVALIDARG if <i>ppGB</i> is invalid.
    ///    
    HRESULT GetFiltergraph(IGraphBuilder* ppGB);
    ///The <b>GetDvdInterface</b> method retrieves interfaces from the DVD-Video playback graph to make DVD-Video
    ///playback development easier.
    ///Params:
    ///    riid = IID of the requested interface.
    ///    ppvIF = Receives a pointer to the interface. The application must release the interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppvIF</i> parameter is invalid. This parameter must not be <b>NULL</b>. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The requested interface
    ///    could not be returned. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_GRAPHNOTREADY</b></dt> </dl>
    ///    </td> <td width="60%"> The graph is not built yet. See Remarks. </td> </tr> </table>
    ///    
    HRESULT GetDvdInterface(const(GUID)* riid, void** ppvIF);
    ///The <code>RenderDvdVideoVolume</code> method completes building a filter graph according to user specifications
    ///for playing a DVD-Video volume.
    ///Params:
    ///    lpcwszPathName = Pointer to the path for the DVD-Video volume to play. Can be <b>NULL</b>.
    ///    dwFlags = Bitwise OR of flags from AM_DVD_GRAPH_FLAGS enumeration, specifying how to build the DVD playback graph.
    ///    pStatus = Pointer to a AM_DVD_RENDERSTATUS structure. When the method returns, the structure indicates any rendering
    ///              failures.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. The DirectShow
    ///    implementation return values include the following: <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>dwFlags</i>
    ///    parameter specifies conflicting options. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The method partially succeeded. To find out which errors occurred, examine the
    ///    <i>pStatus</i> parameter. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded, and all streams were rendered. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_DECNOTENOUGH</b></dt> </dl> </td> <td width="60%"> One or more streams could not be
    ///    rendered. If you specified the AM_DVD_HWDEC_ONLY or AM_DVD_SWDEC_ONLY flag in the <i>dwFlags</i> parameter,
    ///    try calling the method again with the AM_DVD_HWDEC_PREFER or AM_DVD_SWDEC_PREFER flag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_DVD_NON_EVR_RENDERER_IN_FILTER_GRAPH</b></dt> </dl> </td> <td width="60%"> The
    ///    filter graph already contains a video renderer. The method returns this error code if you specify the
    ///    AM_DVD_EVR_ONLY flag in the <i>dwFlags</i> parameter but the graph already contains a video renderer other
    ///    than the Enhanced Video Renderer (VMR) filter. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DVD_RENDERFAIL</b></dt> </dl> </td> <td width="60%"> An error occurred while building the graph.
    ///    For example, the DVD Graph Builder could not create a required filter or could not render any of the streams.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_DVD_TOO_MANY_RENDERERS_IN_FILTER_GRAPH</b></dt> </dl>
    ///    </td> <td width="60%"> The filter graph contains more than one video renderer. </td> </tr> </table>
    ///    
    HRESULT RenderDvdVideoVolume(const(wchar)* lpcwszPathName, uint dwFlags, AM_DVD_RENDERSTATUS* pStatus);
}

///The <code>IDDrawExclModeVideo</code> interface enables video playback in DirectDraw exclusive full-screen mode. The
///Overlay Mixer Filter implements this interface. Game applications can use DirectDraw in exclusive full-screen mode
///and continue playing video. For example, the video can be in the background and graphics can be used on top of it.
///The application passes in a DirectDraw object and primary surface, and these are passed to the Overlay Mixer filter
///in the filter graph. The DVD graph builder object uses <code>IDDrawExclModeVideo</code> to play DVD content while in
///DirectDraw exclusive full-screen mode. This interface can also be used alone to play MPEG-1 or AVI videos in games.
@GUID("153ACC21-D83B-11D1-82BF-00A0C9696C8F")
interface IDDrawExclModeVideo : IUnknown
{
    ///The <code>SetDDrawObject</code> method sets the DirectDraw object to be used in subsequent drawing.
    ///Params:
    ///    pDDrawObject = Pointer to the <b>IDirectDraw</b> interface on the object to use.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>A DirectDraw error code</b></dt> </dl>
    ///    </td> <td width="60%"> A DirectDraw error is encountered when trying to set the specified surface on the
    ///    Overlay Mixer. </td> </tr> </table>
    ///    
    HRESULT SetDDrawObject(IDirectDraw pDDrawObject);
    ///The <code>GetDDrawObject</code> method retrieves the DirectDraw object being used by the Overlay Mixer filter.
    ///Params:
    ///    ppDDrawObject = Address of a pointer to the <b>IDirectDraw</b> interface that the Overlay Mixer is using.
    ///    pbUsingExternal = Pointer to a variable that receives a Boolean value. It receives the value <b>TRUE</b> if the Overlay Mixer
    ///                      is using a DirectDraw object specified by IDDrawExclModeVideo::SetDDrawObject, or <b>FALSE</b> otherwise.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>A DirectDraw error code</b></dt> </dl>
    ///    </td> <td width="60%"> A DirectDraw error is encountered when trying to set the specified surface on the
    ///    Overlay Mixer. </td> </tr> </table>
    ///    
    HRESULT GetDDrawObject(IDirectDraw* ppDDrawObject, int* pbUsingExternal);
    ///The <code>SetDDrawSurface</code> method specifies the DirectDraw surface to be used in subsequent drawing.
    ///Params:
    ///    pDDrawSurface = Pointer to the <b>IDirectDrawSurface</b> interface on the surface to use.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. The current DirectShow
    ///    implementation return values include the following. <table> <tr> <th>Return value</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt>E_INVALIDARG</dt> </dl> </td> <td width="60%"> Argument is invalid. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt>A DirectDraw error code</dt> </dl> </td> <td width="60%"> A DirectDraw error is
    ///    encountered when trying to set the specified surface on the Overlay Mixer. </td> </tr> </table>
    ///    
    HRESULT SetDDrawSurface(IDirectDrawSurface pDDrawSurface);
    ///The <code>GetDDrawSurface</code> method retrieves the DirectDraw surface being used by the Overlay Mixer.
    ///Params:
    ///    ppDDrawSurface = Address of a pointer to the <b>IDirectDrawSurface</b> interface that is being used by the Overlay Mixer.
    ///    pbUsingExternal = Pointer to a variable that receives a Boolean value. It receives the value <b>TRUE</b> if the Overlay Mixer
    ///                      is using a DirectDraw surface specified by IDDrawExclModeVideo::SetDDrawSurface, or <b>FALSE</b> otherwise.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>A DirectDraw error code</b></dt> </dl>
    ///    </td> <td width="60%"> A DirectDraw error is encountered when trying to set the specified surface on the
    ///    Overlay Mixer. </td> </tr> </table>
    ///    
    HRESULT GetDDrawSurface(IDirectDrawSurface* ppDDrawSurface, int* pbUsingExternal);
    ///The <code>SetDrawParameters</code> method specifies which part of the original video will appear at which
    ///position of the screen.
    ///Params:
    ///    prcSource = Pointer to the <b>RECT</b> structure of the original video.
    ///    prcTarget = Pointer to the <b>RECT</b> that indicates where the video will appear on the screen.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface.
    ///    
    HRESULT SetDrawParameters(const(RECT)* prcSource, const(RECT)* prcTarget);
    ///The <code>GetNativeVideoProps</code> method retrieves the current video size and picture aspect ratio of the
    ///Overlay Mixer's primary stream.
    ///Params:
    ///    pdwVideoWidth = Address of variable that receives the width of the video.
    ///    pdwVideoHeight = Address of variable that receives the height of the video.
    ///    pdwPictAspectRatioX = Address of variable that receives the x-axis aspect ratio.
    ///    pdwPictAspectRatioY = Address of variable that receives the y-axis aspect ratio.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Argument is invalid. </td> </tr> </table>
    ///    
    HRESULT GetNativeVideoProps(uint* pdwVideoWidth, uint* pdwVideoHeight, uint* pdwPictAspectRatioX, 
                                uint* pdwPictAspectRatioY);
    ///The <code>SetCallbackInterface</code> method retrieves a pointer to the callback interface of the Overlay Mixer
    ///so that the calling application can be notified about adjustments to the display during video playback.
    ///Params:
    ///    pCallback = Pointer to the object that implements the IDDrawExclModeVideoCallback interface. If <i>pCallback</i> is
    ///                <b>NULL</b>, the callback interface is set to <b>NULL</b> and no more callbacks are made. If there was a
    ///                previous callback interface, it is released and no more callbacks are made to it. If <i>pCallback</i> is not
    ///                <b>NULL</b> and this method returns S_OK, then the reference count of the object <i>pCallback</i> points to
    ///                is incremented.
    ///    dwFlags = Must be zero.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Argument is invalid. </td> </tr> </table>
    ///    
    HRESULT SetCallbackInterface(IDDrawExclModeVideoCallback pCallback, uint dwFlags);
}

///The <code>IDDrawExclModeVideoCallback</code> interface is a callback interface for the IDDrawExclModeVideo interface.
///This callback interface enables applications to get synchronous notification about changes to the overlay position,
///size, visibility, and so on, so that the application can adjust its video visibility, size, and position. This avoids
///any color key flash at the beginning, end, or during playback. The application must implement the interface. It is
///important that none of the methods block or slow down the video processing, because this will cause problems with
///playback. Use this interface if you are writing a filter that supports <b>IDDrawExclModeVideo</b> or needs to
///generate callbacks to enable an application to draw color keys at the right time.
@GUID("913C24A0-20AB-11D2-9038-00A0C9697298")
interface IDDrawExclModeVideoCallback : IUnknown
{
    ///The <code>OnUpdateOverlay</code> method informs the application when the overlay surface for the video is about
    ///to become visible, invisible, change size, or change position, so that the application can repaint its window
    ///appropriately.
    ///Params:
    ///    bBefore = Boolean value specifying whether the call is being made before or after the overlay-related change.
    ///              <b>TRUE</b> specifies before, <b>FALSE</b> specifies after.
    ///    dwFlags = Value from the AM_OVERLAY_NOTIFY_FLAGS enumeration that specifies what is about to change or what changed.
    ///    bOldVisible = Boolean value specifying whether the old window is visible. <b>TRUE</b> means the old window is visible.
    ///    prcOldSrc = Pointer to the rectangle representing the old source position of the DirectDraw surface.
    ///    prcOldDest = Pointer to the rectangle representing the old destination position of the rectangle in the overlay surface.
    ///    bNewVisible = Boolean specifying whether the new window is visible. <b>TRUE</b> means the new window is visible.
    ///    prcNewSrc = Pointer to the rectangle representing the new source position of the DirectDraw surface.
    ///    prcNewDest = Pointer to the rectangle representing the new destination position of the rectangle in the overlay surface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid parameter. </td> </tr> </table>
    ///    
    HRESULT OnUpdateOverlay(BOOL bBefore, uint dwFlags, BOOL bOldVisible, const(RECT)* prcOldSrc, 
                            const(RECT)* prcOldDest, BOOL bNewVisible, const(RECT)* prcNewSrc, 
                            const(RECT)* prcNewDest);
    ///The <code>OnUpdateColorKey</code> method informs the application that the color key has changed so that the
    ///application can use the new color key to overlay graphics on the video.
    ///Params:
    ///    pKey = Pointer to a [COLORKEY](/windows/desktop/api/strmif/ns-strmif-colorkey) structure that contains the key type
    ///           and a palette index.
    ///    dwColor = Value indicating the 8-bit palette index of the <b>COLORKEY</b> returned in <i>pKey</i>, if the current
    ///              display mode is 8-bit palettized. Otherwise, it is a value representing the color key in the pixel format of
    ///              the current display mode.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One
    ///    of the parameters is invalid. </td> </tr> </table>
    ///    
    HRESULT OnUpdateColorKey(const(COLORKEY)* pKey, uint dwColor);
    ///The <code>OnUpdateSize</code> method informs the application that the size of the video rectangle is about to
    ///change.
    ///Params:
    ///    dwWidth = The new width, in pixels, of the video stream.
    ///    dwHeight = The new height, in pixels, of the video stream.
    ///    dwARWidth = The new horizontal value of the aspect ratio.
    ///    dwARHeight = The new vertical value of the aspect ratio.
    ///Returns:
    ///    Returns an HRESULT value.
    ///    
    HRESULT OnUpdateSize(uint dwWidth, uint dwHeight, uint dwARWidth, uint dwARHeight);
}

///The <b>IBDA_NetworkProvider</b> interface is implemented on a Network Provider filter. It provides methods that BDA
///device filters call to register themselves after they are added to the graph.
@GUID("FD501041-8EBE-11CE-8183-00AA00577DA2")
interface IBDA_NetworkProvider : IUnknown
{
    ///The <b>PutSignalSource</b> method specifies the signal source.
    ///Params:
    ///    ulSignalSource = Specifies the signal source.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PutSignalSource(uint ulSignalSource);
    ///The <b>GetSignalSource</b> method retrieves the signal source.
    ///Params:
    ///    pulSignalSource = Receives a value specifying the signal source.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetSignalSource(uint* pulSignalSource);
    ///The <b>GetNetworkType</b> method retrieves the network type.
    ///Params:
    ///    pguidNetworkType = Receives a GUID specifying the network type.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetNetworkType(GUID* pguidNetworkType);
    ///The <b>PutTuningSpace</b> method specifies the tuning space.
    ///Params:
    ///    guidTuningSpace = Specifies the tuning space.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PutTuningSpace(const(GUID)* guidTuningSpace);
    ///The <b>GetTuningSpace</b> method retrieves the tuning space.
    ///Params:
    ///    pguidTuingSpace = Receives a GUID specifying the tuning space.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetTuningSpace(GUID* pguidTuingSpace);
    ///The <b>RegisterDeviceFilter</b> method is called by a BDA device filter to register itself in the filter graph.
    ///Params:
    ///    pUnkFilterControl = Pointer to the filter's <b>IUnknown</b> interface.
    ///    ppvRegisitrationContext = Pointer that receives the registration context. The filter should store this value and return it in the call
    ///                              to <b>UnRegisterDeviceFilter</b>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT RegisterDeviceFilter(IUnknown pUnkFilterControl, uint* ppvRegisitrationContext);
    ///The <b>UnRegisterDeviceFilter</b> method is called by BDA device filters when they are removed from the filter
    ///graph.
    ///Params:
    ///    pvRegistrationContext = The registration context that the filter received in the call to <b>RegisterDeviceFilter</b>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT UnRegisterDeviceFilter(uint pvRegistrationContext);
}

///The <b>IBDA_EthernetFilter</b> interface is implemented on a Network Provider. The methods are called by the BDA
///IPSink filter in order to give the Network Provider a list of multicast Ethernet addresses being requested by an
///application. The Network Provider then informs all registered transport information filters (TIFs) of the new
///addresses. The TIF(s) are responsible for mapping those addresses to PIDs and passing the PIDs back to the Network
///Provider, which then resets the PID list for the IP data output pin on the MPEG-2 Demultiplexer. This causes the IP
///data on the specified PIDs to be routed through the data services segment of the graph and on to Winsock where the
///listening application can receive it. The IBDA_IPV4Filter interface performs the same function for IPv4 multicast
///addresses.
@GUID("71985F43-1CA1-11D3-9CC8-00C04F7971E0")
interface IBDA_EthernetFilter : IUnknown
{
    ///The <b>GetMulticastListSize</b> method retrieves the number of addresses currently in the list.
    ///Params:
    ///    pulcbAddresses = Pointer that receives the number of addresses currently in the Network Provider's list.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetMulticastListSize(uint* pulcbAddresses);
    ///The <b>PutMulticastList</b> method sets the list of multicast addresses on the Network Provider.
    ///Params:
    ///    ulcbAddresses = Specifies the number of addresses in the list, multiplied by the number of bytes per address.
    ///    pAddressList = Pointer to an array of addresses whose size in bytes is equal to <i>ulcbAddresses</i>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PutMulticastList(uint ulcbAddresses, char* pAddressList);
    ///The <b>GetMulticastList</b> method retrieves the list of multicast addresses on the Network Provider.
    ///Params:
    ///    pulcbAddresses = On input, specifies the maximum number of addresses to retrieve, multiplied by the number of bytes per
    ///                     address. On output, receives the actual number of bytes retrieved.
    ///    pAddressList = Pointer that receives an array of addresses whose size in bytes is equal to <i>ulcbAddresses</i>. See
    ///                   Remarks.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetMulticastList(uint* pulcbAddresses, char* pAddressList);
    ///The <b>PutMulticastMode</b> method sets the multicast mode.
    ///Params:
    ///    ulModeMask = Specifies the multicast mode.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PutMulticastMode(uint ulModeMask);
    ///The <b>GetMulticastMode</b> method retrieves the multicast mode.
    ///Params:
    ///    pulModeMask = Pointer that receives the multicast mode.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetMulticastMode(uint* pulModeMask);
}

///The <b>IBDA_ IPV4Filter</b> interface is implemented on a Network Provider. The methods are called by the BDA IPSink
///filter in order to give the Network Provider a list of multicast Ethernet addresses being requested by an
///application. The Network Provider then informs all registered transport information filters (TIFs) of the new
///addresses. The TIF(s) are responsible for mapping those addresses to PIDs and passing the PIDs back to the Network
///Provider, which then resets the PID list for the IP data output pin on the MPEG-2 Demultiplexer. This causes the IP
///data on the specified PIDs to be routed through the data services segment of the graph and on to Winsock where the
///listening application can receive it. The IBDA_EthernetFilter interface performs the same function for Ethernet
///multicast addresses.
@GUID("71985F44-1CA1-11D3-9CC8-00C04F7971E0")
interface IBDA_IPV4Filter : IUnknown
{
    ///The <b>GetMulticastListSize</b> method retrieves the number of addresses in the list.
    ///Params:
    ///    pulcbAddresses = Pointer that receives the number of addresses multiplied by the size of an IPv4 address.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetMulticastListSize(uint* pulcbAddresses);
    ///The <b>PutMulticastList</b> method sets the list of multicast addresses on the Network Provider.
    ///Params:
    ///    ulcbAddresses = Specifies the number of addresses in the list, times the number of bytes per address.
    ///    pAddressList = Pointer that receives an array of addresses whose size in bytes is equal to <i>ulcbAddresses</i>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PutMulticastList(uint ulcbAddresses, char* pAddressList);
    ///The <b>GetMulticastList</b> method retrieves the list of multicast addresses on the Network Provider.
    ///Params:
    ///    pulcbAddresses = On input, specifies the maximum number of addresses to retrieve, multiplied by the number of bytes per
    ///                     address. On output, receives the actual number of bytes retrieved.
    ///    pAddressList = Pointer that receives an array of addresses whose size in bytes is equal to <i>ulcbAddresses</i>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetMulticastList(uint* pulcbAddresses, char* pAddressList);
    ///The <b>PutMulticastMode</b> method sets the multicast mode.
    ///Params:
    ///    ulModeMask = Specifies the multicast mode.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PutMulticastMode(uint ulModeMask);
    ///The <b>GetMulticastMode</b> method retrieves the multicast mode.
    ///Params:
    ///    pulModeMask = Pointer that receives the mask. See the Windows DDK for possible values.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetMulticastMode(uint* pulModeMask);
}

///This interface is not supported.
@GUID("E1785A74-2A23-4FB3-9245-A8F88017EF33")
interface IBDA_IPV6Filter : IUnknown
{
    ///The <b>GetMulticastListSize</b> method retrieves the size in bytes of the list of multicast addresses.
    ///Params:
    ///    pulcbAddresses = Pointer that receives the size in bytes.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetMulticastListSize(uint* pulcbAddresses);
    ///The <b>PutMulticastList</b> method specifies the parameters of the multicast list.
    ///Params:
    ///    ulcbAddresses = Specifies the number of addresses in the list, multiplied by the number of bytes per address.
    ///    pAddressList = Pointer to an array of addresses whose size in bytes is equal to <i>ulcbAddresses</i>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PutMulticastList(uint ulcbAddresses, char* pAddressList);
    ///The <b>GetMulticastList</b> method retrieves the list of multicast addresses on the Network Provider.
    ///Params:
    ///    pulcbAddresses = On input, specifies the maximum number of addresses to retrieve, multiplied by the number of bytes per
    ///                     address. On output, receives the actual number of bytes retrieved.
    ///    pAddressList = Pointer that receives an array of addresses whose size in bytes is equal to <i>ulcbAddresses</i>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetMulticastList(uint* pulcbAddresses, char* pAddressList);
    ///The <b>PutMulticastMode</b> method specifies the multicast mode.
    ///Params:
    ///    ulModeMask = Specifies the mode mask.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PutMulticastMode(uint ulModeMask);
    ///The <b>GetMulticastMode</b> method retrieves the mode(s) of the multicast.
    ///Params:
    ///    pulModeMask = Pointer that receives the mode mask.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetMulticastMode(uint* pulModeMask);
}

///The <b>IBDA_DeviceControl</b> interface is implemented on all BDA device filters. The methods provided by this
///interface are called by a Network Provider to control a BDA device. Each instance of a device has one transaction
///list. A Network Provider first calls the StartChanges method. This deletes any previous uncommitted changes that were
///still pending. Then a Network Provider modifies whatever properties on the filter are required for the particular
///tuning operation. Then it calls the CheckChanges method to determine whether the modifications will be successful,
///without instructing the filter to actually make the changes. If this call succeeds, then a Network Provider calls
///CommitChanges to cause the filter to actually modify the specified properties. For more information, see "Changing
///BDA Filter Properties" in the Windows DDK. <b>OCUR Devices: </b>This interface supports OpenCable Unidirectional
///Cable Receiver (OCUR) devices. See OCUR Devices.
@GUID("FD0A5AF3-B41D-11D2-9C95-00C04F7971E0")
interface IBDA_DeviceControl : IUnknown
{
    ///The <b>StartChanges</b> method is called by a Network Provider before it begins to modify a set of properties on
    ///a BDA device filter.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT StartChanges();
    ///The <b>CheckChanges</b> method queries the device filter as to whether the changes that are pending would succeed
    ///if they were committed.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT CheckChanges();
    ///The <b>CommitChanges</b> method instructs the device to perform the changes specified in the previous call to
    ///<b>StartChanges</b>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT CommitChanges();
    ///The <b>GetChangeState</b> method returns a value indicating whether any uncommitted changes are currently pending
    ///in the filter.
    ///Params:
    ///    pState = Receives the current state of the filter. See BDA_CHANGE_STATE in the Windows DDK for possible values.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetChangeState(uint* pState);
}

///The <b>IBDA_PinControl</b> interface is exposed on a BDA device filter's pins. A Network Provider calls these methods
///to determine the type and identifier of each pin on the filter. A Network Provider uses this information when
///building the graph.
@GUID("0DED49D5-A8B7-4D5D-97A1-12B0C195874D")
interface IBDA_PinControl : IUnknown
{
    ///The <b>GetPinID</b> method retrieves the ID of the pin.
    ///Params:
    ///    pulPinID = Pointer that receives the pin's identifier.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetPinID(uint* pulPinID);
    ///The <b>GetPinType</b> method retrieves the type of the pin.
    ///Params:
    ///    pulPinType = Pointer that receives the pin type.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetPinType(uint* pulPinType);
    ///The <b>RegistrationContext</b> method retrieves the registration context of a particular pin.
    ///Params:
    ///    pulRegistrationCtx = Pointer that receives the registration context.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT RegistrationContext(uint* pulRegistrationCtx);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IBDA_SignalProperties</b> interface is implemented by a BDA device filter. Through this interface, the network
///provider informs a BDA device filter about the current tuning request. The network provider calls the <b>PutXxx</b>
///methods in the interface at the time that the BDA device is registered with the network provider. Thereafter, the
///network provider calls these methods whenever the current tuning request is modified.
@GUID("D2F1644B-B409-11D2-BC69-00A0C9EE9E16")
interface IBDA_SignalProperties : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>PutNetworkType</b> method specifies the network type for the current tuning request.
    ///Params:
    ///    guidNetworkType = Specifies the network type.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PutNetworkType(const(GUID)* guidNetworkType);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetNetworkType</b> method retrieves the network type for the current tuning request.
    ///Params:
    ///    pguidNetworkType = Receives a GUID identifying the network type.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetNetworkType(GUID* pguidNetworkType);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>PutSignalSource</b> method specifies the signal source for the current tuning request.
    ///Params:
    ///    ulSignalSource = Specifies the signal source.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PutSignalSource(uint ulSignalSource);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetSignalSource</b> method retrieves the signal source for the current tuning request.
    ///Params:
    ///    pulSignalSource = Receives a value identifying the signal source. The value is an arbitrary identifier set by the network
    ///                      provider. If two tuners share the same signal source, they should have the same identifier.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetSignalSource(uint* pulSignalSource);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>PutTuningSpace</b> method specifies the tuning space for the current tuning request.
    ///Params:
    ///    guidTuningSpace = Specifies the tuning space.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PutTuningSpace(const(GUID)* guidTuningSpace);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTuningSpace</b> method retrieves the tuning space for the current tuning request.
    ///Params:
    ///    pguidTuingSpace = Pointer to a variable that receives a GUID identifying the tuning space.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetTuningSpace(GUID* pguidTuingSpace);
}

///The <b>IBDA_SignalStatistics</b> interface is implemented on a BDA device filter and provides methods by which the
///filter can describe the condition of a signal that is being received.
@GUID("1347D106-CF3A-428A-A5CB-AC0D9A2A4338")
interface IBDA_SignalStatistics : IUnknown
{
    ///The <b>put_SignalStrength</b> method specifies the strength of the signal in decibels.
    ///Params:
    ///    lDbStrength = Long integer that specifies the db strength.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_SignalStrength(int lDbStrength);
    ///The <b>get_SignalStrength</b> method retrieves a value that indicates the strength of the signal in decibels.
    ///Params:
    ///    plDbStrength = Pointer that receives the signal strength value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SignalStrength(int* plDbStrength);
    ///The <b>put_SignalQuality</b> method specifies the quality of the signal.
    ///Params:
    ///    lPercentQuality = Long integer that specifies the quality of the signal as a percentage. 100 indicates best quality and 0
    ///                      indicates worst quality.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_SignalQuality(int lPercentQuality);
    ///The <b>get_SignalQuality</b> method retrieves a value from 1 to 100 indicating the quality of the signal.
    ///Params:
    ///    plPercentQuality = Pointer that receives the value as a percentage. 100 indicates best quality and 0 indicates worst quality.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SignalQuality(int* plPercentQuality);
    ///The <b>put_SignalPresent</b> method specifies whether a signal is present.
    ///Params:
    ///    fPresent = Flag indicating whether the signal is present. <b>TRUE</b> means a signal is present.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_SignalPresent(ubyte fPresent);
    ///The <b>get_SignalPresent</b> method retrieves a Boolean value indicating whether a signal is present.
    ///Params:
    ///    pfPresent = Pointer to a flag indicating whether a signal is present.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SignalPresent(ubyte* pfPresent);
    ///The <b>put_SignalLocked</b> method specifies whether the signal is locked.
    ///Params:
    ///    fLocked = Flag that indicates whether to lock the signal.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_SignalLocked(ubyte fLocked);
    ///The <b>get_SignalLocked</b> method retrieves a Boolean value indicating whether the signal is locked.
    ///Params:
    ///    pfLocked = Pointer to a flag indicating whether the signal is locked.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SignalLocked(ubyte* pfLocked);
    ///The <b>put_SampleTime</b> method specifies the sample time of the signal.
    ///Params:
    ///    lmsSampleTime = Specifies the sample time.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_SampleTime(int lmsSampleTime);
    ///The <b>get_SampleTime</b> method retrieves the sample time used to measure the signal.
    ///Params:
    ///    plmsSampleTime = Pointer that receives the sample time.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SampleTime(int* plmsSampleTime);
}

///The <b>IBDA_Topology</b> interface is implemented on BDA device filters. A single filter may represent multiple
///hardware devices (called control nodes) which may be connected in various ways within the filter itself. These
///connections generally represent hardware paths on the card. This interface provides methods that enable a Network
///Provider to configure or discover the types of nodes within the filter, and how these nodes are connected. The
///methods correspond closely to the Ring 0 property sets which are documented in the Windows DDK. <b>OCUR Devices:
///</b>This interface supports OpenCable Unidirectional Cable Receiver (OCUR) devices. See OCUR Devices.
@GUID("79B56888-7FEA-4690-B45D-38FD3C7849BE")
interface IBDA_Topology : IUnknown
{
    ///The <b>GetNodeTypes</b> method retrieves a list of all the node types in the template topology for this filter
    ///and network type.
    ///Params:
    ///    pulcNodeTypes = Pointer that receives the number of node types in the list.
    ///    ulcNodeTypesMax = The maximum number of node types that can be held by the <i>rgulNodeTypes</i> buffer.
    ///    rgulNodeTypes = Pointer to a buffer that receives the list of node types.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetNodeTypes(uint* pulcNodeTypes, uint ulcNodeTypesMax, char* rgulNodeTypes);
    ///The <b>GetNodeDescriptors</b> method retrieves a list of descriptors for the nodes in the topology.
    ///Params:
    ///    ulcNodeDescriptors = Receives a count of the number of node descriptors written to the <i>rgNodeDescriptors</i> array.
    ///    ulcNodeDescriptorsMax = Specifies the maximum number of node descriptors that the <i>rgNodeDescriptors</i> array can hold.
    ///    rgNodeDescriptors = Pointer to a buffer that receives an array of node descriptors. Each node descriptor is a structure of type
    ///                        BDANODE_DESCRIPTOR.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetNodeDescriptors(uint* ulcNodeDescriptors, uint ulcNodeDescriptorsMax, char* rgNodeDescriptors);
    ///The <b>GetNodeInterfaces</b> method retrieves a list of the interfaces supported by a node type.
    ///Params:
    ///    ulNodeType = Specifies the node type for which the interface list is being requested.
    ///    pulcInterfaces = Pointer that receives the number of interfaces in the list.
    ///    ulcInterfacesMax = Specifies the maximum number of interfaces that <i>rgguidInterfaces</i> can hold.
    ///    rgguidInterfaces = Pointer to a buffer that holds the list of interface GUIDs.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetNodeInterfaces(uint ulNodeType, uint* pulcInterfaces, uint ulcInterfacesMax, char* rgguidInterfaces);
    ///The <b>GetPinTypes</b> method retrieves a list of all the pin types in the template topology for this filter and
    ///network type.
    ///Params:
    ///    pulcPinTypes = Pointer to a value that receives the number of pin types in the list.
    ///    ulcPinTypesMax = The maximum number of pin types that can be held by the <i>rgulPinTypes</i> buffer.
    ///    rgulPinTypes = Pointer to a buffer to receive the list of pin types.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetPinTypes(uint* pulcPinTypes, uint ulcPinTypesMax, char* rgulPinTypes);
    ///The <b>GetTemplateConnections</b> method retrieves a list of all template connections that appear in the template
    ///topology for this filter and network type.
    ///Params:
    ///    pulcConnections = Pointer to a value to receive the number of connections in the list.
    ///    ulcConnectionsMax = The maximum number of connections that can be held by the <i>rgConnections</i> buffer.
    ///    rgConnections = Pointer to a buffer that receives the list of connections.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetTemplateConnections(uint* pulcConnections, uint ulcConnectionsMax, char* rgConnections);
    ///The <b>CreatePin</b> method creates an instance of a specified pin type.
    ///Params:
    ///    ulPinType = Specifies the type of pin to create. To obtain the available values, call IBDA_Topology::GetPinTypes.
    ///    pulPinId = Pointer that receives the identifier for the new pin.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT CreatePin(uint ulPinType, uint* pulPinId);
    ///The <b>DeletePin</b> method deletes a pin from the filter's topology.
    ///Params:
    ///    ulPinId = Specifies the identifier of the pin to be deleted.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT DeletePin(uint ulPinId);
    ///The <b>SetMediaType</b> method sets the media type for a pin on a BDA device filter.
    ///Params:
    ///    ulPinId = The identifier of the pin on which to set the media type.
    ///    pMediaType = Pointer to an AM_MEDIA_TYPE structure that contains the media type.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetMediaType(uint ulPinId, AM_MEDIA_TYPE* pMediaType);
    ///The <b>SetMedium</b> method configures the medium on which a particular pin sends data.
    ///Params:
    ///    ulPinId = Specifies the identifier of the pin on which to set the medium.
    ///    pMedium = Pointer to the medium on which the pin will send data.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetMedium(uint ulPinId, REGPINMEDIUM* pMedium);
    ///The <b>CreateTopology</b> method associates an instance of an input pin with an instance of an output pin.
    ///Params:
    ///    ulInputPinId = Specifies the identifier of the input pin for which a topology should be created.
    ///    ulOutputPinId = Specifies the identifier of the output pin for which a topology should be created.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT CreateTopology(uint ulInputPinId, uint ulOutputPinId);
    ///The <b>GetControlNode</b> method retrieves an <b>IUnknown</b> interface pointer for a specified control node.
    ///Params:
    ///    ulInputPinId = Specifies the identifier of the input pin for which a topology should be created.
    ///    ulOutputPinId = Specifies the identifier of the output pin for which a topology should be created.
    ///    ulNodeType = The type of node to be opened.
    ///    ppControlNode = Pointer to a pointer to the control node's <b>IUnknown</b> interface
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetControlNode(uint ulInputPinId, uint ulOutputPinId, uint ulNodeType, IUnknown* ppControlNode);
}

///The <b>IBDA_VoidTransform</b> interface is implemented on a BDA device filter. It is used by the Network Provider to
///inactivate a portion of a filter graph without stopping the graph.
@GUID("71985F46-1CA1-11D3-9CC8-00C04F7971E0")
interface IBDA_VoidTransform : IUnknown
{
    ///The <b>Start</b> method restarts data flow through a control node.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT Start();
    ///The <b>Stop</b> method stops data flow through a control node.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT Stop();
}

///The <b>IBDA_NullTransform</b> interface is implemented on all BDA device filters. The Network Provider filter calls
///these methods to instruct the filter to either pass data through without modifying it, or else to perform its
///particular transformation on the data.
@GUID("DDF15B0D-BD25-11D2-9CA0-00C04F7971E0")
interface IBDA_NullTransform : IUnknown
{
    ///The <b>Start</b> method restarts the transforms on data flowing through the control node.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT Start();
    ///The <b>Stop</b> method stops the transforms on data flowing through the control node.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT Stop();
}

///The <b>IBDA_FrequencyFilter</b> interface is implemented on a BDA tuner device, and is used by the Network Provider
///to tell the tuner how to set its frequencies.
@GUID("71985F47-1CA1-11D3-9CC8-00C04F7971E0")
interface IBDA_FrequencyFilter : IUnknown
{
    ///The <b>put_Autotune</b> method specifies whether to activate the device's autotune capabilities.
    ///Params:
    ///    ulTransponder = Specifies the transponder frequency.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Autotune(uint ulTransponder);
    ///The <b>get_Autotune</b> method retrieves the autotune frequency.
    ///Params:
    ///    pulTransponder = Specifies the transponder frequency.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Autotune(uint* pulTransponder);
    ///The <b>put_Frequency</b> method specifies the frequency.
    ///Params:
    ///    ulFrequency = Specifies the frequency. The units are 1 Hz x the frequency multiplier, where the <i>frequency multiplier</i>
    ///                  is the value returned by the IBDA_FrequencyFilter::get_FrequencyMultiplier method. The default frequency
    ///                  multiplier is 1000, so the default units are kilohertz (kHz).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Frequency(uint ulFrequency);
    ///The <b>get_Frequency</b> method retrieves the frequency.
    ///Params:
    ///    pulFrequency = Pointer that receives the frequency. The units are 1 Hz x the frequency multiplier, where the <i>frequency
    ///                   multiplier</i> is the value returned by the IBDA_FrequencyFilter::get_FrequencyMultiplier method. The default
    ///                   frequency multiplier is 1000, so the default units are kilohertz (kHz).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Frequency(uint* pulFrequency);
    ///The <b>put_Polarity</b> method specifies the polarity of the signal.
    ///Params:
    ///    Polarity = Specifies the polarity as a member of the Polarisation enumerated type.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Polarity(Polarisation Polarity);
    ///The <b>get_Polarity</b> method retrieves the polarity.
    ///Params:
    ///    pPolarity = Pointer that receives a Polarisation variable.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Polarity(Polarisation* pPolarity);
    ///The <b>put_Range</b> method specifies the tuner range. The <i>tuner range</i> is the frequency domain on which to
    ///find a particular carrier frequency
    ///Params:
    ///    ulRange = Specifies the tuner range. The units are 1 Hz x the frequency multiplier, where the <i>frequency
    ///              multiplier</i> is the value returned by the IBDA_FrequencyFilter::get_FrequencyMultiplier method. The default
    ///              frequency multiplier is 1000, so the default units are kilohertz (kHz). If you set this parameter value to
    ///              -1, the tuner range is not set. If you set the parameter value to 0, the tuner range is undefined.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Range(uint ulRange);
    ///The get_Range method retrieves the tuner range. The <i>tuner range</i> is the frequency domain on which to find a
    ///particular carrier frequency
    ///Params:
    ///    pulRange = Pointer that receives the tuner range. The units are 1 Hz x the frequency multiplier, where the <i>frequency
    ///               multiplier</i> is the value returned by the IBDA_FrequencyFilter::get_FrequencyMultiplier method. The default
    ///               frequency multiplier is 1000, so the default units are kilohertz (kHz). A value of -1 for this parameter
    ///               indicates that the tuner range is not set. A value of 0 for this parameter indicates that the tuner range is
    ///               undefined.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Range(uint* pulRange);
    ///The <b>put_Bandwidth</b> method specifies the bandwidth.
    ///Params:
    ///    ulBandwidth = Specifies the bandwidth. The units are 1 Hz x the frequency multiplier, where the <i>frequency multiplier</i>
    ///                  is the value returned by the IBDA_FrequencyFilter::get_FrequencyMultiplier method. The default frequency
    ///                  multiplier is 1000, so the default units are kilohertz (kHz).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Bandwidth(uint ulBandwidth);
    ///The <b>get_Bandwidth</b> method retrieves the bandwidth.
    ///Params:
    ///    pulBandwidth = Pointer that receives the bandwidth. The units are 1 Hz x the frequency multiplier, where the <i>frequency
    ///                   multiplier</i> is the value returned by the IBDA_FrequencyFilter::get_FrequencyMultiplier method. The default
    ///                   frequency multiplier is 1000, so the default units are kilohertz (kHz).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Bandwidth(uint* pulBandwidth);
    ///The <b>put_FrequencyMultiplier</b> method specifies the frequency multiplier. The frequency multiplier determines
    ///the frequency units for the methods on this interface. The default value is 1000, meaning that frequencies are
    ///expressed in kilohertz (kHz).
    ///Params:
    ///    ulMultiplier = Specifies the multiplier.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_FrequencyMultiplier(uint ulMultiplier);
    ///The <b>get_FrequencyMultiplier</b> method retrieves the frequency multiplier. The frequency multiplier determines
    ///the frequency units for the methods on this interface. The default value is 1000, meaning that frequencies are
    ///expressed in kilohertz (kHz).
    ///Params:
    ///    pulMultiplier = Pointer that receives the multiplier.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_FrequencyMultiplier(uint* pulMultiplier);
}

///The <b>IBDA_LNBInfo</b> interface is implemented on a BDA device filter, specifically an LNB device. The methods are
///called by the Network Provider to instruct the device on how to acquire the satellite signal.
@GUID("992CF102-49F9-4719-A664-C4F23E2408F4")
interface IBDA_LNBInfo : IUnknown
{
    ///The <b>put_LocalOscilatorFrequencyLowBand</b> method specifies the frequency of the local oscillator's low band.
    ///Params:
    ///    ulLOFLow = Specifies the low band frequency. The units are 1 Hz x the frequency multiplier, where the <i>frequency
    ///               multiplier</i> is the value returned by the IBDA_FrequencyFilter::get_FrequencyMultiplier method. The default
    ///               frequency multiplier is 1000, so the default units are kilohertz (kHz).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_LocalOscilatorFrequencyLowBand(uint ulLOFLow);
    ///The <b>get_LocalOscilatorFrequencyLowBand</b> method retrieves the low band of the local oscillator frequency.
    ///Params:
    ///    pulLOFLow = Pointer that receives the low band of the frequency. The units are 1 Hz x the frequency multiplier, where the
    ///                <i>frequency multiplier</i> is the value returned by the IBDA_FrequencyFilter::get_FrequencyMultiplier
    ///                method. The default frequency multiplier is 1000, so the default units are kilohertz (kHz).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_LocalOscilatorFrequencyLowBand(uint* pulLOFLow);
    ///The <b>put_LocalOscilatorFrequencyHighBand</b> method specifies the frequency of the local oscillator's high
    ///band.
    ///Params:
    ///    ulLOFHigh = Specifies the frequency's high band. The units are 1 Hz x the frequency multiplier, where the <i>frequency
    ///                multiplier</i> is the value returned by the IBDA_FrequencyFilter::get_FrequencyMultiplier method. The default
    ///                frequency multiplier is 1000, so the default units are kilohertz (kHz).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_LocalOscilatorFrequencyHighBand(uint ulLOFHigh);
    ///The <b>get_LocalOscilatorFrequencyHighBand</b> method retrieves the high band of the local oscillator frequency.
    ///Params:
    ///    pulLOFHigh = Pointer that receives the high band value. The units are 1 Hz x the frequency multiplier, where the
    ///                 <i>frequency multiplier</i> is the value returned by the IBDA_FrequencyFilter::get_FrequencyMultiplier
    ///                 method. The default frequency multiplier is 1000, so the default units are kilohertz (kHz).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_LocalOscilatorFrequencyHighBand(uint* pulLOFHigh);
    ///The <b>put_HighLowSwitchFrequency</b> method specifies the frequency of the high-low switch.
    ///Params:
    ///    ulSwitchFrequency = Specifies the frequency. The units are 1 Hz x the frequency multiplier, where the <i>frequency multiplier</i>
    ///                        is the value returned by the IBDA_FrequencyFilter::get_FrequencyMultiplier method. The default frequency
    ///                        multiplier is 1000, so the default units are kilohertz (kHz).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_HighLowSwitchFrequency(uint ulSwitchFrequency);
    ///The <b>get_HighLowSwitchFrequency</b> method retrieves the frequency of the high-low switch.
    ///Params:
    ///    pulSwitchFrequency = Pointer that receives the frequency. The units are 1 Hz x the frequency multiplier, where the <i>frequency
    ///                         multiplier</i> is the value returned by the IBDA_FrequencyFilter::get_FrequencyMultiplier method. The default
    ///                         frequency multiplier is 1000, so the default units are kilohertz (kHz).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_HighLowSwitchFrequency(uint* pulSwitchFrequency);
}

///Controls cable television satelite equipment, using Digital Satellite Equipment Control (DiSEqC) commands.
@GUID("F84E2AB0-3C6B-45E3-A0FC-8669D4B81F11")
interface IBDA_DiseqCommand : IUnknown
{
    ///Enables or disables the use of Digital Satellite Equipment Control (DiSEqC) commands.
    ///Params:
    ///    bEnable = If <b>TRUE</b>, DiSEqC commands are enabled. Otherwise, DiSEqC commands are disabled.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_EnableDiseqCommands(ubyte bEnable);
    ///Sets the low-noise block (LNB) converter source.
    ///Params:
    ///    ulLNBSource = The LNB converter source to use. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                  id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> Source position A. </td> </tr> <tr> <td
    ///                  width="40%"><a id="1"></a><dl> <dt><b>1</b></dt> </dl> </td> <td width="60%"> Source position B. </td> </tr>
    ///                  <tr> <td width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> Source position C.
    ///                  </td> </tr> <tr> <td width="40%"><a id="3"></a><dl> <dt><b>3</b></dt> </dl> </td> <td width="60%"> Source
    ///                  position D. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_DiseqLNBSource(uint ulLNBSource);
    ///Enables or disables Tone-Burst commands.
    ///Params:
    ///    bUseToneBurst = If <b>TRUE</b>, Tone-Burst commands are enabled. Otherwise, Tone-Burst commands are disabled.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_DiseqUseToneBurst(ubyte bUseToneBurst);
    ///Enables or disables repeated Digital Satellite Equipment Control (DiSEqC) commands.
    ///Params:
    ///    ulRepeats = The number of times to repeat each DiSEqC command. To disable repeated commands, set <i>ulRepeats</i> to 0.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_DiseqRepeats(uint ulRepeats);
    ///Sends a Digital Satellite Equipment Control (DiSEqC) command.
    ///Params:
    ///    ulRequestId = An identifier for the command that is assigned by the application.
    ///    ulcbCommandLen = The size of the <i>pbCommand</i> array, in bytes.
    ///    pbCommand = Pointer to a byte array that contains the DiSEqC command, starting with the framing byte. The driver inserts
    ///                the parity bits for the command.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_DiseqSendCommand(uint ulRequestId, uint ulcbCommandLen, char* pbCommand);
    ///Gets the driver's response to a Digital Satellite Equipment Control (DiSEqC) command.
    ///Params:
    ///    ulRequestId = The identifier of the command. The application assigns this value when it calls
    ///                  IBDA_DiseqCommand::put_DiseqSendCommand.
    ///    pulcbResponseLen = On input, specifies the size of the <i>pbResponse</i> array, in bytes. On output, receives the number of
    ///                       bytes of data written into the <i>pbResponse</i> buffer.
    ///    pbResponse = Pointer to a byte array that receives the driver's response.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>BDA_E_BUFFER_TOO_SMALL</b></b></dt> </dl> </td> <td width="60%">
    ///    The buffer given in the <i>pbResponse</i> parameter is too small. </td> </tr> </table>
    ///    
    HRESULT get_DiseqResponse(uint ulRequestId, uint* pulcbResponseLen, char* pbResponse);
}

///If a BDA device filter, specifically a demodulator, exposes this interface, it indicates that the filter can
///automatically detect signal characteristics. With this information, the Network Provider can be more efficient in
///managing the tuning process. For more information, see <b>KSPROPSETID_BdaAutodemodulate</b> in the Windows DDK.
@GUID("DDF15B12-BD25-11D2-9CA0-00C04F7971E0")
interface IBDA_AutoDemodulate : IUnknown
{
    ///The <b>put_AutoDemodulate</b> method instructs the BDA device filter to automatically detect signal
    ///characteristics.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_AutoDemodulate();
}

///The <b>IBDA_AutoDemodulateEx</b> interface extends IBDA_AutoDemodulate. If a BDA device filter, specifically a
///demodulator, exposes this interface, it indicates that the filter can automatically detect signal characteristics.
///With this information, the Network Provider can be more efficient in managing the tuning process. For more
///information, see <b>KSPROPSETID_BdaAutodemodulate</b> in the Windows DDK. <b>OCUR Devices: </b>This interface
///supports OpenCable Unidirectional Cable Receiver (OCUR) devices. See OCUR Devices.
@GUID("34518D13-1182-48E6-B28F-B24987787326")
interface IBDA_AutoDemodulateEx : IBDA_AutoDemodulate
{
    ///The <b>get_SupportedDeviceNodeTypes</b> method retrieves a list of the device node types that the demodulator
    ///supports.
    ///Params:
    ///    ulcDeviceNodeTypesMax = Specifies the size of the <i>pguidDeviceNodeTypes</i> array.
    ///    pulcDeviceNodeTypes = If <i>pguidDeviceNodeTypes</i> is <b>NULL</b>, receives the number of device node types that the demodulator
    ///                          supports. If <i>pguidDeviceNodeTypes</i> is not <b>NULL</b>, receives the number of node types that were
    ///                          copied into the <i>pguidDeviceNodeTypes</i> array.
    ///    pguidDeviceNodeTypes = Pointer to an array of GUIDs, or <b>NULL</b>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SupportedDeviceNodeTypes(uint ulcDeviceNodeTypesMax, uint* pulcDeviceNodeTypes, 
                                         GUID* pguidDeviceNodeTypes);
    ///The <b>get_SupportedVideoFormats</b> method retrieves the video formats that are supported by the demodulator.
    ///Params:
    ///    pulAMTunerModeType = Pointer to a variable that receives a mask that indicates the frequency ranges that are supported by the BDA
    ///                         device filter. For a list of valid mask bits, see AMTunerModeType Enumeration.
    ///    pulAnalogVideoStandard = Pointer to a variable that receives a mask that indicates the analog television signal formats that are
    ///                             supported by the BDA device filter. For a list of valid mask bits, see AnalogVideoStandard Enumeration.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SupportedVideoFormats(uint* pulAMTunerModeType, uint* pulAnalogVideoStandard);
    ///The <b>get_AuxInputCount</b> method retrieves a count of the number of auxiliary inputs on the demodulator.
    ///Params:
    ///    pulCompositeCount = Pointer to a variable that receives a count of the number of composite-video input connectors on the device.
    ///    pulSvideoCount = Pointer to a variable that receives a count of the number of S-Video input connectors on the device.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_AuxInputCount(uint* pulCompositeCount, uint* pulSvideoCount);
}

///The <b>IBDA_DigitalDemodulator</b> interface is exposed on BDA device filters, specifically demodulators, that are
///not capable of automatically detecting the characteristics of a signal. A Network Provider calls these methods on the
///filter to provide the demodulator with the information it needs to acquire a particular signal. The Network Provider
///obtains these values from the Locator object associated with the tune request or tuning space. <b>OCUR Devices:
///</b>This interface supports OpenCable Unidirectional Cable Receiver (OCUR) devices. See OCUR Devices.
@GUID("EF30F379-985B-4D10-B640-A79D5E04E1E0")
interface IBDA_DigitalDemodulator : IUnknown
{
    ///The <b>put_ModulationType</b> method specifies the modulation type for the signal.
    ///Params:
    ///    pModulationType = Pointer to a ModulationType variable that specifies the modulation type.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_ModulationType(ModulationType* pModulationType);
    ///The <b>get_ModulationType</b> method retrieves the modulation type for the signal.
    ///Params:
    ///    pModulationType = Pointer that receives a ModulationType variable indicating the modulation type.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_ModulationType(ModulationType* pModulationType);
    ///The <b>put_InnerFECMethod</b> method specifies the inner forward error correction method for the signal.
    ///Params:
    ///    pFECMethod = Pointer to an FECMethod variable that specifies the inner forward error correction method.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_InnerFECMethod(FECMethod* pFECMethod);
    ///The <b>get_InnerFECMethod</b> method retrieves the inner forward error correction method.
    ///Params:
    ///    pFECMethod = Pointer that receives an FECMethod variable.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_InnerFECMethod(FECMethod* pFECMethod);
    ///The <b>put_InnerFECRate</b> method specifies the inner forward error correction rate.
    ///Params:
    ///    pFECRate = Pointer to a BinaryConvolutionCodeRate variable that specifies the inner FEC rate.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_InnerFECRate(BinaryConvolutionCodeRate* pFECRate);
    ///The <b>get_InnerFECRate</b> method retrieves the inner forward error correction rate being used on the signal.
    ///Params:
    ///    pFECRate = Pointer that receives a BinaryConvolutionCodeRate variable that indicates the rate.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_InnerFECRate(BinaryConvolutionCodeRate* pFECRate);
    ///The <b>put_OuterFECMethod</b> method specifies the outer forward error correction method for the signal.
    ///Params:
    ///    pFECMethod = Pointer to an FECMethod variable.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_OuterFECMethod(FECMethod* pFECMethod);
    ///The <b>get_OuterFECMethod</b> method retrieves the outer forward error correction method for the signal .
    ///Params:
    ///    pFECMethod = Pointer that receives an FECMethod variable that indicates the FEC method.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_OuterFECMethod(FECMethod* pFECMethod);
    ///The <b>put_OuterFECRate</b> method specifies the outer forward error correction rate for the signal.
    ///Params:
    ///    pFECRate = Pointer to a BinaryConvolutionCodeRate variable that specifies the FEC rate.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_OuterFECRate(BinaryConvolutionCodeRate* pFECRate);
    ///The <b>get_OuterFECRate</b> method retrieves the outer forward error correction rate for the signal.
    ///Params:
    ///    pFECRate = Pointer that receives a BinaryConvolutionCodeRate variable that indicates the rate.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_OuterFECRate(BinaryConvolutionCodeRate* pFECRate);
    ///The <b>put_SymbolRate</b> method specifies the symbol rate for the signal.
    ///Params:
    ///    pSymbolRate = Pointer to a ULONG that specifies the symbol rate.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_SymbolRate(uint* pSymbolRate);
    ///The <b>get_SymbolRate</b> method retrieves the symbol rate for the signal.
    ///Params:
    ///    pSymbolRate = Pointer that receives the symbol rate.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SymbolRate(uint* pSymbolRate);
    ///The <b>put_SpectralInversion</b> method specifies the spectral inversion value for the signal.
    ///Params:
    ///    pSpectralInversion = Pointer to a SpectralInversion variable.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_SpectralInversion(SpectralInversion* pSpectralInversion);
    ///The <b>get_SpectralInversion</b> method retrieves the spectral inversion value for the signal.
    ///Params:
    ///    pSpectralInversion = Pointer that receives a SpectralInversion variable.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SpectralInversion(SpectralInversion* pSpectralInversion);
}

///Controls a Broadcast Driver Architecture (BDA) demodulator filter. Demodulation filters for Digital Video
///Broadcasting-Satellite version 2 (DVB-S2) implement this interface.
@GUID("525ED3EE-5CF3-4E1E-9A06-5368A84F9A6E")
interface IBDA_DigitalDemodulator2 : IBDA_DigitalDemodulator
{
    ///Sets the demodulator's guard interval.
    ///Params:
    ///    pGuardInterval = Pointer to a variable that contains the guard interval, specified as a member of the GuardInterval
    ///                     enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_GuardInterval(GuardInterval* pGuardInterval);
    ///Gets the demodulator's guard interval.
    ///Params:
    ///    pGuardInterval = Receives the guard interval, specified as a member of the GuardInterval enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_GuardInterval(GuardInterval* pGuardInterval);
    ///Sets the demodulator's transmission mode.
    ///Params:
    ///    pTransmissionMode = Pointer to a variable that contains the transmission mode, specified as a member of the TransmissionMode
    ///                        enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_TransmissionMode(TransmissionMode* pTransmissionMode);
    ///Gets the demodulator's transmission mode.
    ///Params:
    ///    pTransmissionMode = Receives the transmission mode, specified as a member of the <b>TransmissionMode</b> enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_TransmissionMode(TransmissionMode* pTransmissionMode);
    ///Sets the demodulator's roll-off factor.
    ///Params:
    ///    pRollOff = Pointer to a variable that contains the roll-off factor, specified as a member of the RollOff enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_RollOff(RollOff* pRollOff);
    ///Gets the demodulator's roll-off factor.
    ///Params:
    ///    pRollOff = Receives the roll-off factor, specified as a member of the RollOff enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_RollOff(RollOff* pRollOff);
    ///Sets the current pilot mode for Digital Video Broadcasting-S2 (DVB-S2).
    ///Params:
    ///    pPilot = Pointer to a variable that contains the pilot mode, specified as a member of the Pilot enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_Pilot(Pilot* pPilot);
    ///Gets the current pilot mode for Digital Video Broadcasting-S2 (DVB-S2).
    ///Params:
    ///    pPilot = Receives the pilot mode, specified as a member of the Pilot enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Pilot(Pilot* pPilot);
}

@GUID("13F19604-7D32-4359-93A2-A05205D90AC9")
interface IBDA_DigitalDemodulator3 : IBDA_DigitalDemodulator2
{
    HRESULT put_SignalTimeouts(BDA_SIGNAL_TIMEOUTS* pSignalTimeouts);
    HRESULT get_SignalTimeouts(BDA_SIGNAL_TIMEOUTS* pSignalTimeouts);
    HRESULT put_PLPNumber(uint* pPLPNumber);
    HRESULT get_PLPNumber(uint* pPLPNumber);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>ICCSubStreamFiltering</b> interface sets the filtering on the closed captioning (CC) pins of the VBICodec filter.
///The CC output pins on the VBICodec filter both expose this interface. Use this interface to select which CC services
///are delivered by each pin. The CC pins are independent, so you can select different services on each pin. For
///example, you might select CC1 and CC2 on one pin and extended data services (XDS) on the other.
@GUID("4B2BD7EA-8347-467B-8DBF-62F784929CC3")
interface ICCSubStreamFiltering : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>get_SubstreamTypes</b> method retrieves the list of closed captioning services this pin is delivering.
    ///Params:
    ///    pTypes = Receives a bitwise OR of flags that specify the closed captioning services. For a list of flags, see
    ///             KS_CC_SUBSTREAM Constants.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_SubstreamTypes(int* pTypes);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>get_SubstreamTypes</b> method sets the closed captioning services the pin will deliver.
    ///Params:
    ///    Types = Bitwise OR of flags that specify the closed captioning services. For a list of flags, see KS_CC_SUBSTREAM
    ///            Constants. Any services that are not selected are simply dropped.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_SubstreamTypes(int Types);
}

///This interface is available for use in the Microsoft Windows 2000, Windows XP, and Windows Server 2003 operating
///systems. It may be altered or unavailable in subsequent versions. The <b>IBDA_IPSinkControl</b> interface is
///implemented on the BDA IP Sink filter, which manages the delivery of in-band IP data to the network stack. This
///interface is superseded by IBDA_IPSinkInfo.
@GUID("3F4DC8E2-4050-11D3-8F4B-00C04F7971E2")
interface IBDA_IPSinkControl : IUnknown
{
    ///This interface is available for use in the Microsoft Windows 2000, Windows XP, and Windows Server 2003 operating
    ///systems. It may be altered or unavailable in subsequent versions. The <b>GetMulticastList</b> method retrieves a
    ///list of the multicast addresses to which the IP Sink filter is listening.
    ///Params:
    ///    pulcbSize = Receives the length of the buffer, in bytes.
    ///    pbBuffer = Pointer to a byte array containing the multicast list.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetMulticastList(uint* pulcbSize, ubyte** pbBuffer);
    ///This interface is available for use in the Microsoft Windows 2000, Windows XP, and Windows Server 2003 operating
    ///systems. It may be altered or unavailable in subsequent versions. The <b>GetAdapterIPAddress</b> method retrieves
    ///the IP address of the NIC.
    ///Params:
    ///    pulcbSize = Receives the length of the buffer, in bytes.
    ///    pbBuffer = Pointer to a byte array containing the address.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetAdapterIPAddress(uint* pulcbSize, ubyte** pbBuffer);
}

///This interface is available for use in the Microsoft Windows 2000, Windows XP, and Windows Server 2003 operating
///systems. It may be altered or unavailable in subsequent versions. The <b>IBDA_IPSinkInfo</b> interface is implemented
///on the BDA IP Sink filter, which manages the delivery of in-band IP data to the network stack. This interface
///supersedes IBDA_IPSinkControl.
@GUID("A750108F-492E-4D51-95F7-649B23FF7AD7")
interface IBDA_IPSinkInfo : IUnknown
{
    ///This interface is available for use in the Microsoft Windows 2000, Windows XP, and Windows Server 2003 operating
    ///systems. It may be altered or unavailable in subsequent versions. The <b>get_MulticastList</b> method retrieves a
    ///list of the multicast addresses to which the IP Sink filter is listening. This method returns a list of IP
    ///addresses in 6-byte IEEE 802.3 format; the list is returned as an array of bytes.
    ///Params:
    ///    pulcbAddresses = Receives the number of bytes in the returned array.
    ///    ppbAddressList = Pointer to variable that receives an array of bytes, of size *<i>pulcbAddresses</i>. Each IP address is 6
    ///                     consecutive bytes.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_MulticastList(uint* pulcbAddresses, char* ppbAddressList);
    ///This interface is available for use in the Microsoft Windows 2000, Windows XP, and Windows Server 2003 operating
    ///systems. It may be altered or unavailable in subsequent versions. The <b>get_AdapterIPAddress</b> method
    ///retrieves the IP address of the data that the IP Sink filter receives. This address is assigned by the system; it
    ///is not guaranteed to be the same for any two instances of the IP Sink filter.
    ///Params:
    ///    pbstrBuffer = Pointer to a <b>BSTR</b> that receives the IP address. The returned string has the form <code>N.N.N.N</code>;
    ///                  for example, <code>3.0.0.0</code>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_AdapterIPAddress(BSTR* pbstrBuffer);
    ///This interface is available for use in the Microsoft Windows 2000, Windows XP, and Windows Server 2003 operating
    ///systems. It may be altered or unavailable in subsequent versions. The <b>get_AdapterDescription</b> method
    ///retrieves the description of the network adapter.
    ///Params:
    ///    pbstrBuffer = Pointer to a <b>BSTR</b> that receives the description.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_AdapterDescription(BSTR* pbstrBuffer);
}

///The <code>IEnumPIDMap</code> interface enumerates a collection of Packet ID (PID) maps. Each PID map describes how
///the MPEG-2 Demultiplexer filter maps a PID to an output pin on the filter. PID mappings are created by calling the
///IMPEG2PIDMap::MapPID method on the filter's output pin. To obtain the <code>IEnumPIDMap</code> interface, call the
///IMPEG2PIDMap::EnumPIDMap method on the output pin. Typically, output pins for audio and video streams have at most
///one PID mapped at any given time. This interface implements a standard Component Object Model (COM) collection
///object. The collection object represents a snapshot of the PID map when the collection is created. The collection is
///not updated automatically.
@GUID("AFB6C2A2-2C41-11D3-8A60-0000F81E0E4A")
interface IEnumPIDMap : IUnknown
{
    ///The <code>Next</code> method retrieves the next <i>n</i> elements in the collection.
    ///Params:
    ///    cRequest = The number of elements to retrieve.
    ///    pPIDMap = Address of an array allocated by the caller, containing <i>cRequest</i> elements. The array is filled with
    ///              PID_MAP structures that describe the PID mapping.
    ///    pcReceived = Pointer to a variable that receives the number of elements actually retrieved. This parameter cannot be
    ///                 <b>NULL</b>. If <i>cRequest</i> equals zero, this parameter receives the total number of items in the
    ///                 collection.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument; <i>pPidMap</i> and <i>pcReceived</i> cannot be <b>NULL</b>. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Reached the end of the collection.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr>
    ///    </table>
    ///    
    HRESULT Next(uint cRequest, char* pPIDMap, uint* pcReceived);
    ///The <code>Skip</code> method skips the specified number of elements in the collection.
    ///Params:
    ///    cRecords = Specifies the number of elements to skip.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Reached the end of the collection. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT Skip(uint cRecords);
    ///The <code>Reset</code> method moves the iterator to the beginning of the collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails,an <b>HRESULT</b> error code is returned.
    ///    
    HRESULT Reset();
    ///The <code>Clone</code> method creates a copy the collection.
    ///Params:
    ///    ppIEnumPIDMap = Receives an IEnumPIDMap interface pointer, representing the new collection. The caller must release the
    ///                    interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument; <i>ppIEnumPIDMap</i> cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumPIDMap* ppIEnumPIDMap);
}

///This interface is implemented on each output pin of the MPEG-2 Demultiplexer filter (Demux) and is used in transport
///stream mode only. It is called by applications or other filters to associate the pin with one or more Packet IDs
///(PID). Once a PID has been mapped, the Demux will deliver all packets with that ID to the output pin. This interface
///is not exposed when the filter is playing back a file (pull-mode). For program streams, use the IMPEG2StreamIdMap
///interface. <b>OCUR Devices: </b>This interface supports OpenCable Unidirectional Cable Receiver (OCUR) devices. See
///OCUR Devices.
@GUID("AFB6C2A1-2C41-11D3-8A60-0000F81E0E4A")
interface IMPEG2PIDMap : IUnknown
{
    ///The <code>MapPID</code> method maps one or more PIDs to the pin.
    ///Params:
    ///    culPID = The number of elements in the <i>pulPID</i> array.
    ///    pulPID = Pointer to an array of size <i>culPID</i>, allocated by the caller. Each element in the array contains a PID
    ///             to be mapped.
    ///    MediaSampleContent = Variable of type MEDIA_SAMPLE_CONTENT that specifies the contents of the stream.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT MapPID(uint culPID, uint* pulPID, MEDIA_SAMPLE_CONTENT MediaSampleContent);
    ///The <code>UnmapPID</code> method unmaps one or more PIDs.
    ///Params:
    ///    culPID = The number of elements in the <i>pulPID</i> array.
    ///    pulPID = Pointer to an array of size <i>culPID</i>, allocated by the caller. Each element in the array contains a PID
    ///             to be unmapped
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT UnmapPID(uint culPID, uint* pulPID);
    ///The <code>EnumPIDMap</code> method returns a collection of all the currently mapped PIDs on this pin.
    ///Params:
    ///    pIEnumPIDMap = Receives an IEnumPIDMap pointer. Use this interface to enumerate the mapped PIDs. The caller must release the
    ///                   interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT EnumPIDMap(IEnumPIDMap* pIEnumPIDMap);
}

///The <b>IFrequencyMap</b> interface sets the frequency table used by the BDA Network Provider filter. A frequency
///table is a list of broadcast or cable frequencies for a given country/region. The Network Provider uses a frequency
///table to find the next frequency when IScanningTuner methods are called. On startup, the Network Provider loads a
///default frequency table. An application can use the <b>IFrequencyMap</b> interface to specify the user's
///country/region, which causes the Network Provider filter to load the corresponding frequency table. The application
///can also modify the current table, or provide a completely new table, using the put_FrequencyMapping method.
///Frequencies used by this interface are measured in units of kilohertz (kHz), and refer to the center frequency of
///each band. For more information, see "Terrestrial delivery system descriptor" in the ETSI EN 300 468 standard. <div
///class="alert"><b>Note</b> Currently only the DVB-T Network Provider supports this interface.</div> <div> </div>
@GUID("06FB45C1-693C-4EA7-B79F-7A6A54D8DEF2")
interface IFrequencyMap : IUnknown
{
    ///The <b>get_FrequencyMapping</b> method returns the Network Provider filter's current frequency table.
    ///Params:
    ///    ulCount = Pointer to a variable that receives the size of the frequency table.
    ///    ppulList = Pointer to a variable that receives the address of the frequency table. The frequency table is an array of
    ///               size <i>pulCount</i>, allocated by the method. The caller must free the array by calling
    ///               <b>CoTaskMemFree</b>.
    ///Returns:
    ///    Each entry in the frequency table is a tuning frequency, in kilohertz (kHz). If the method succeeds, it
    ///    returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_FrequencyMapping(uint* ulCount, uint** ppulList);
    ///The <b>put_FrequencyMapping</b> method sets the frequency table.
    ///Params:
    ///    ulCount = Specifies the size of the array given in <i>pList</i>.
    ///    pList = Address of an array of size <i>ulCount</i>, allocated by the caller. The array should contain a list of all
    ///            the frequencies (in kHz) that are valid in the current country/region.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_FrequencyMapping(uint ulCount, char* pList);
    ///The <b>get_CountryCode</b> method returns the country/region code the Network Provider is currently using. The
    ///country/region code determines which frequency table the Network Provider loads.
    ///Params:
    ///    pulCountryCode = Pointer to a variable that receives the country/region code.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_CountryCode(uint* pulCountryCode);
    ///The <b>put_CountryCode</b> method sets the country/region code on the Network Provider filter.
    ///Params:
    ///    ulCountryCode = Specifies the country/region code.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_CountryCode(uint ulCountryCode);
    ///The <b>get_DefaultFrequencyMapping</b> method returns the default frequency table for a given country/region
    ///code. This method returns the frequency table, but does not set the country/region code on Network Provider. The
    ///Network Provider continues to use the same frequency table it was using before the method was called.
    ///Params:
    ///    ulCountryCode = Specifies the country/region code.
    ///    pulCount = Pointer to a variable that receives the size of the frequency table.
    ///    ppulList = Pointer to a variable that receives the address of the frequency table. The frequency table is an array of
    ///               size <i>pulCount</i>, allocated by the method. The caller must free the array by calling
    ///               <b>CoTaskMemFree</b>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_DefaultFrequencyMapping(uint ulCountryCode, uint* pulCount, uint** ppulList);
    ///The <b>get_CountryCodeList</b> method returns a list of all the country/region codes for which the Network
    ///Provider has a frequency table.
    ///Params:
    ///    pulCount = Pointer to a variable that receives the number of country/region codes.
    ///    ppulList = Pointer to a variable that receives the address of an array of size <i>pulCount</i>, allocated by the method.
    ///               The array contains a list of the country/region codes. The caller must free the array by calling
    ///               <b>CoTaskMemFree</b>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_CountryCodeList(uint* pulCount, uint** ppulList);
}

///The <b>IBDA_EasMessage</b> interface represents an ATSC emergency alert system (EAS) message table. This interface is
///currently implemented on the TIF and registered as a service by the TIF.
@GUID("D806973D-3EBE-46DE-8FBB-6358FE784208")
interface IBDA_EasMessage : IUnknown
{
    ///The <b>get_EasMessage</b> method retrieves an EAS message.
    ///Params:
    ///    ulEventID = Specifies the event ID of the EAS message.
    ///    ppEASObject = Pointer to a pointer variable that receives a pointer to the <b>IUnknown</b> interface of the EAS object. The
    ///                  caller can query this object for its ISCTE_EAS interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_EasMessage(uint ulEventID, IUnknown* ppEASObject);
}

///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition
///2005 and later.</div> <div> </div> The <b>IBDA_TransportStreamInfo</b> interface returns the time when the most
///recent Program Association Table (PAT) section was received. The BDA MPEG-2 Transport Information Filter implements
///this interface and registers it as a graph service. To obtain a pointer to this interface, call
///<b>IServiceProvider::QueryService</b> with the service identifier <b>SID_BDA_TransportStreamInfo</b>.
@GUID("8E882535-5F86-47AB-86CF-C281A72A0549")
interface IBDA_TransportStreamInfo : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>get_PatTableTickCount</b> method returns the time when the most recent Program Association Table (PAT) section
    ///was received. The time is expressed in terms of the tick count, which is the number of milliseconds that have
    ///elapsed since the system was started. For more information, see <b>GetTickCount</b> in the Platform SDK
    ///documentation.
    ///Params:
    ///    pPatTickCount = Receives the tick count when the last PAT section was received.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_PatTableTickCount(uint* pPatTickCount);
}

///The <b>IBDA_ConditionalAccess</b> interface provides conditional access to program content. <b>OCUR Devices: </b>This
///interface supports OpenCable Unidirectional Cable Receiver (OCUR) devices. See OCUR Devices.
@GUID("CD51F1E0-7BE9-4123-8482-A2A796C0A6B0")
interface IBDA_ConditionalAccess : IUnknown
{
    ///The <b>get_SmartCardStatus</b> method retrieves the status of the smart card.
    ///Params:
    ///    pCardStatus = Pointer to a variable of type SmartCardStatusType that receives the card status type.
    ///    pCardAssociation = Pointer to a variable of type SmartCardAssociationType that receives the card association type.
    ///    pbstrCardError = Receives a string containing the card error. When the string is no longer required, call the
    ///                     <b>SysFreeString</b> function to free it.
    ///    pfOOBLocked = Receives a value indicating if the operation is blocked.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SmartCardStatus(SmartCardStatusType* pCardStatus, SmartCardAssociationType* pCardAssociation, 
                                BSTR* pbstrCardError, short* pfOOBLocked);
    ///The <b>get_SmartCardInfo</b> method retrieves information about the smart card.
    ///Params:
    ///    pbstrCardName = Receives a string containing the card name. When the string is no longer required, call the
    ///                    <b>SysFreeString</b> function to free it.
    ///    pbstrCardManufacturer = Receives a string containing the name of the card manufacturer. When the string is no longer required, call
    ///                            the <b>SysFreeString</b> function to free it.
    ///    pfDaylightSavings = Receives a value indicating whether daylight savings is in effect. If the value is VARIANT_TRUE, daylight
    ///                        savings is in effect. If the value is VARIANT_FALSE, daylight savings is not in effect.
    ///    pbyRatingRegion = Receives a value indicating the rating region.
    ///    plTimeZoneOffsetMinutes = Receives the time zone offset in minutes.
    ///    pbstrLanguage = Receives a string indicating the language. When the string is no longer required, call the
    ///                    <b>SysFreeString</b> function to free it.
    ///    pEALocationCode = Pointer to a buffer that receives the emergency alert location code information. The buffer size must be at
    ///                      least <code>sizeof(EALocationCodeType)</code>. The method writes a structure of type EALocationCodeType to
    ///                      the buffer. The structure specifies the location code scheme (for example, SCTE 18), state, county, and
    ///                      county subdivision for the emergency alert.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SmartCardInfo(BSTR* pbstrCardName, BSTR* pbstrCardManufacturer, short* pfDaylightSavings, 
                              ubyte* pbyRatingRegion, int* plTimeZoneOffsetMinutes, BSTR* pbstrLanguage, 
                              EALocationCodeType* pEALocationCode);
    ///The <b>get_SmartCardApplications</b> method retrieves a list of the smart card applications.
    ///Params:
    ///    pulcApplications = Receives a count of the number of smart card applications in the <i>rgApplications</i> array.
    ///    ulcApplicationsMax = The maximum number of smart card applications that the <i>rgApplications</i> buffer can hold.
    ///    rgApplications = Pointer to a buffer that receives an array of smart card applications. Each array element is a
    ///                     SmartCardApplication structure.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SmartCardApplications(uint* pulcApplications, uint ulcApplicationsMax, char* rgApplications);
    ///The <b>get_Entitlement</b> method retrieves the entitlement type for a virtual channel. Currently not
    ///implemented.
    ///Params:
    ///    usVirtualChannel = Specifies the virtual channel number.
    ///    pEntitlement = Receives the entitlement type.
    ///Returns:
    ///    Returns <b>E_NOTIMPL</b>.
    ///    
    HRESULT get_Entitlement(ushort usVirtualChannel, EntitlementType* pEntitlement);
    ///The <b>TuneByChannel</b> method tunes to a virtual channel.
    ///Params:
    ///    usVirtualChannel = Specifies the virtual channel number.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT TuneByChannel(ushort usVirtualChannel);
    ///The <b>SetProgram</b> method sets the program number.
    ///Params:
    ///    usProgramNumber = Specifies the program number.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetProgram(ushort usProgramNumber);
    ///Currently not implemented.
    ///Params:
    ///    usProgramNumber = Reserved.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT AddProgram(ushort usProgramNumber);
    ///Currently not implemented.
    ///Params:
    ///    usProgramNumber = Reserved.
    ///Returns:
    ///    Returns <b>E_NOTIMPL</b>.
    ///    
    HRESULT RemoveProgram(ushort usProgramNumber);
    ///The <b>GetModuleUI</b> method retrieves the URL for a user interface dialog.
    ///Params:
    ///    byDialogNumber = Specifies the dialog number.
    ///    pbstrURL = Pointer to a pointer variable that receives a pointer to a string containing the URL. When the string is no
    ///               longer required, call the <b>SysFreeString</b> function to free it.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetModuleUI(ubyte byDialogNumber, BSTR* pbstrURL);
    ///The <b>InformUIClosed</b> method informs the device that the user-interface dialog is closed.
    ///Params:
    ///    byDialogNumber = Specifies the dialog number.
    ///    CloseReason = Specifies the reason for closing the dialog, as a member of the UICloseReasonType enumeration.
    ///Returns:
    ///    If the method succeeds, it returns <b>S_OK</b>. It returns <b>S_FALSE</b> if a dialog with the specified
    ///    dialog number cannot be found. If the method fails, it returns an error code.
    ///    
    HRESULT InformUIClosed(ubyte byDialogNumber, UICloseReasonType CloseReason);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later.
@GUID("20E80CB5-C543-4C1B-8EB3-49E719EEE7D4")
interface IBDA_DiagnosticProperties : IPropertyBag
{
}

///The <b>IBDA_DRM</b> interface is used to request a tuner to perform a DRM handshake with the user's computer. Some
///tuners require a DRM handshake to verify that the user can receive content from the tuner. The BDA tuner filter
///exposes this interface; it is implemented by the tuner mini-driver. <b>OCUR Devices: </b>This interface supports
///OpenCable Unidirectional Cable Receiver (OCUR) devices. See OCUR Devices.
@GUID("F98D88B0-1992-4CD6-A6D9-B9AFAB99330D")
interface IBDA_DRM : IUnknown
{
    ///The <b>GetDRMPairingStatus</b> method queries the status of the DRM handshake.
    ///Params:
    ///    pdwStatus = Receives a value from the BDA_DrmPairingError enumeration.
    ///    phError = Receives an <b>HRESULT</b> value indicating the success or failure of the DRM handshake.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The device does not support this functionality, or the handshake is still in progress.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetDRMPairingStatus(uint* pdwStatus, int* phError);
    ///The <b>PerformDRMPairing</b> method requests the tuner to perform a DRM handshake with the user's computer.
    ///Params:
    ///    fSync = If <b>TRUE</b>, the method blocks until the operation is completed. If <b>FALSE</b>, the operation is
    ///            completed asynchronously.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT PerformDRMPairing(BOOL fSync);
}

///Retrieves name/value pairs from a media transform device (MTD) through the device's General Purpose Name Value
///Service (GPNVS). Name/value pairs are used to get the capabilities of the device.
@GUID("7F0B3150-7B81-4AD4-98E3-7E9097094301")
interface IBDA_NameValueService : IUnknown
{
    ///Gets a name, specified by index, from the device's list of name/value pairs.
    ///Params:
    ///    ulIndex = The zero-based index of the name to get.
    ///    pbstrName = Receives the name as a <b>BSTR</b>. The caller must free the <b>BSTR</b> by calling <b>SysFreeString</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>BDA_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>ulIndex</i> parameter is out of bounds. </td> </tr> </table>
    ///    
    HRESULT GetValueNameByIndex(uint ulIndex, BSTR* pbstrName);
    ///Gets a value by name.
    ///Params:
    ///    bstrName = The name of the value to retrieve.
    ///    bstrLanguage = The language for the value. If the value of the name/value pair is localizable, this string must contain an
    ///                   ISO 639-2 language code with a dash followed by an ISO 3166 country/region code. Otherwise, this parameter
    ///                   may contain an empty string.
    ///    pbstrValue = Receives the value as a <b>BSTR</b>. The caller must free the <b>BSTR</b> by calling <b>SysFreeString</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetValue(BSTR bstrName, BSTR bstrLanguage, BSTR* pbstrValue);
    ///Sets a name/value pair in device memory.
    ///Params:
    ///    ulDialogRequest = Specifies a logical link with a user interface (MMI) dialog box that might be triggered by setting the value.
    ///    bstrLanguage = The language of the dialog box. This string contains an ISO 639-2 language code with a dash followed by an
    ///                   ISO 3166 country/region code.
    ///    bstrName = The name of the name/value pair to set.
    ///    bstrValue = The value to set.
    ///    ulReserved = Reserved. Set to zero.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetValue(uint ulDialogRequest, BSTR bstrLanguage, BSTR bstrName, BSTR bstrValue, uint ulReserved);
}

///Provides access to a device's Conditional Access Service (CAS), which manages access to protected content.
@GUID("497C3418-23CB-44BA-BB62-769F506FCEA7")
interface IBDA_ConditionalAccessEx : IUnknown
{
    ///Checks the access availability of content that is identified by an entitlement token. An <i>entitlement token</i>
    ///is a binary blob used to obtain access to a piece of content or to identify an event in a stream.
    ///Params:
    ///    ulDialogRequest = A dialog request number that specifies the dialog that might be triggered by setting the value. A dialog is
    ///                      part of the device's user interface (MMI).
    ///    bstrLanguage = The language of the dialog. This string contains an ISO 639-2 language code with a dash followed by an ISO
    ///                   3166 country/region code.
    ///    RequestType = The type of access that is being requested, specified as a member of the BDA_CONDITIONALACCESS_REQUESTTYPE
    ///                  enumeration.
    ///    ulcbEntitlementTokenLen = The size, in bytes, of the <i>pbEntitlementToken</i> array.
    ///    pbEntitlementToken = Pointer to a byte array that contains the entitlement token.
    ///    pulDescrambleStatus = Receives a status code indicating the descrambling status. For more information, see <i>Protected Broadcast
    ///                          Driver Architecture, Part 1: Core Services</i>, section 5.5.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CheckEntitlementToken(uint ulDialogRequest, BSTR bstrLanguage, 
                                  BDA_CONDITIONALACCESS_REQUESTTYPE RequestType, uint ulcbEntitlementTokenLen, 
                                  char* pbEntitlementToken, uint* pulDescrambleStatus);
    ///Requests special events that are identified by a capture token. A <i>capture token</i> is a binary blob that
    ///indicates a specific purchase option for content.
    ///Params:
    ///    ulcbCaptureTokenLen = The size, in bytes, of the <i>pbCaptureToken</i> array.
    ///    pbCaptureToken = Pointer to a byte array that contains the capture token.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCaptureToken(uint ulcbCaptureTokenLen, char* pbCaptureToken);
    ///Responds to a BroadcastMMI event. When a device receives a BroadcastMMI event, it calls this method one time for
    ///each user interface (MMI) dialog box that is displayed to the user.
    ///Params:
    ///    ulDialogRequest = A logical link with the MMI dialog box that was triggered by the action.
    ///    bstrLanguage = The language of the dialog box. This string contains an ISO 639-2 language code with a dash followed by an
    ///                   ISO 3166 country/region code.
    ///    EventId = The event identifier of the BroadcastMMI event.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OpenBroadcastMmi(uint ulDialogRequest, BSTR bstrLanguage, uint EventId);
    ///Notifies the Conditional Access Service (CAS) that the media sink device (MSD) has closed a user interface (MMI)
    ///dialog.
    ///Params:
    ///    ulDialogRequest = A logical link with the user interface (MMI) dialog that was triggered by the action.
    ///    bstrLanguage = The language for any dialogs resulting from this action. This string contains an ISO 639-2 language code with
    ///                   a dash followed by an ISO 3166 country/region code.
    ///    ulDialogNumber = The dialog number of the dialog that was closed.
    ///    ReasonCode = The reason for closing the dialog, specified as a member of the BDA_CONDITIONALACCESS_MMICLOSEREASON
    ///                 enumeration.
    ///    pulSessionResult = Receives the result code for the MMI session. For more information, see <i>Protected Broadcast Driver
    ///                       Architecture, Part 1: Core Services - CAS</i>, section 2.6.6.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CloseMmiDialog(uint ulDialogRequest, BSTR bstrLanguage, uint ulDialogNumber, 
                           BDA_CONDITIONALACCESS_MMICLOSEREASON ReasonCode, uint* pulSessionResult);
    ///Gets a new dialog box request number.
    ///Params:
    ///    pulDialogRequestNumber = Receives the dialog box request number.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateDialogRequestNumber(uint* pulDialogRequestNumber);
}

///Sends conditional access system (CAS) commands for Integrated Services Digital Broadcasting (ISDB). For more
///information, refer to ARIB STD-B25, <i>Conditional Access System Specifications for Digital Broadcasting</i>. (This
///resource may not be available in some languages and countries.)
@GUID("5E68C627-16C2-4E6C-B1E2-D00170CDAA0F")
interface IBDA_ISDBConditionalAccess : IUnknown
{
    ///Sends a conditional access system (CAS) command for Integrated Services Digital Broadcasting (ISDB).
    ///Params:
    ///    ulRequestId = The numeric code for the CAS command. The ARIB standard defines these values. Enumeration constants for some
    ///                  commands are defined in the ISDBCAS_REQUEST_ID enumeration.
    ///    ulcbRequestBufferLen = Size of the <i>pbRequestBuffer</i> array, in bytes.
    ///    pbRequestBuffer = Pointer to a byte array that contains the data for the command.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetIsdbCasRequest(uint ulRequestId, uint ulcbRequestBufferLen, char* pbRequestBuffer);
}

///Provides access to a device's Eventing Service.
@GUID("207C413F-00DC-4C61-BAD6-6FEE1FF07064")
interface IBDA_EventingService : IUnknown
{
    ///Notifies the media transform device (MTD) when the media sink device (MSD) completes an event.
    ///Params:
    ///    ulEventID = The identifier of the event.
    ///    ulEventResult = The result code of the event.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CompleteEvent(uint ulEventID, uint ulEventResult);
}

///Gets the capabilities of a device's auxiliary input connectors. This interface provides access to a device's Aux
///Service.
@GUID("7DEF4C09-6E66-4567-A819-F0E17F4A81AB")
interface IBDA_AUX : IUnknown
{
    ///Gets the number of auxiliary connectors on the device.
    ///Params:
    ///    pdwNumAuxInputsBSTR = Receives the number of auxiliary connectors.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT QueryCapabilities(uint* pdwNumAuxInputsBSTR);
    ///Gets the capabilities of an auxiliary connector, specified by index.
    ///Params:
    ///    dwIndex = The zero-based index of the auxiliary connector. To get the number of connectors on the device, call
    ///              IBDA_AUX::QueryCapabilities.
    ///    dwInputID = Receives a unique identifier for the auxiliary connector.
    ///    pConnectorType = Receives a GUID that specifies the type of connector. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///                     <td width="40%"><a id="PBDA_AUX_CONNECTOR_TYPE_Composite"></a><a
    ///                     id="pbda_aux_connector_type_composite"></a><a id="PBDA_AUX_CONNECTOR_TYPE_COMPOSITE"></a><dl>
    ///                     <dt><b>PBDA_AUX_CONNECTOR_TYPE_Composite</b></dt> </dl> </td> <td width="60%"> Composite video connector.
    ///                     </td> </tr> <tr> <td width="40%"><a id="PBDA_AUX_CONNECTOR_TYPE_SVideo"></a><a
    ///                     id="pbda_aux_connector_type_svideo"></a><a id="PBDA_AUX_CONNECTOR_TYPE_SVIDEO"></a><dl>
    ///                     <dt><b>PBDA_AUX_CONNECTOR_TYPE_SVideo</b></dt> </dl> </td> <td width="60%"> S-Video connector. </td> </tr>
    ///                     </table>
    ///    ConnTypeNum = Receives a numeric identifier for the auxiliary input.
    ///    NumVideoStds = Receives the number of analog video standards that the connector supports.
    ///    AnalogStds = Receives a bitwise <b>OR</b> of flags from the AnalogVideoStandard enumeration, specifying which analog video
    ///                 standards the connector supports.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnumCapability(uint dwIndex, uint* dwInputID, GUID* pConnectorType, uint* ConnTypeNum, 
                           uint* NumVideoStds, ulong* AnalogStds);
}

///Provides access to a device's Encoder Service.
@GUID("3A8BAD59-59FE-4559-A0BA-396CFAA98AE3")
interface IBDA_Encoder : IUnknown
{
    ///Gets the number of encoding formats supported by the device.
    ///Params:
    ///    NumAudioFmts = Receives the number of audio formats.
    ///    NumVideoFmts = Receives the number of video formats.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT QueryCapabilities(uint* NumAudioFmts, uint* NumVideoFmts);
    ///Gets one of the audio formats supported by the device.
    ///Params:
    ///    FmtIndex = The zero-based index of the audio format to retrieve. To get the number of audio formats, call
    ///               IBDA_Encoder::QueryCapabilities.
    ///    MethodID = Receives a value that uniquely identifies this audio method.
    ///    AlgorithmType = Receives the type of encoding algorithm. The following values are defined. <table> <tr> <th>Value</th>
    ///                    <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PBDA_Encoder_Audio_AlgorithmType_MPEG1LayerII"></a><a
    ///                    id="pbda_encoder_audio_algorithmtype_mpeg1layerii"></a><a
    ///                    id="PBDA_ENCODER_AUDIO_ALGORITHMTYPE_MPEG1LAYERII"></a><dl>
    ///                    <dt><b>PBDA_Encoder_Audio_AlgorithmType_MPEG1LayerII</b></dt> <dt>0x00000000</dt> </dl> </td> <td
    ///                    width="60%"> MPEG-1 Layer II. </td> </tr> <tr> <td width="40%"><a
    ///                    id="PBDA_Encoder_Audio_AlgorithmType_AC3"></a><a id="pbda_encoder_audio_algorithmtype_ac3"></a><a
    ///                    id="PBDA_ENCODER_AUDIO_ALGORITHMTYPE_AC3"></a><dl> <dt><b>PBDA_Encoder_Audio_AlgorithmType_AC3</b></dt>
    ///                    <dt>0x00000001</dt> </dl> </td> <td width="60%"> Dolby AC3. </td> </tr> </table>
    ///    SamplingRate = Receives the audio sampling rate, in Hz.
    ///    BitDepth = Receives the number of bits per audio sample.
    ///    NumChannels = Receives the number of audio channels.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnumAudioCapability(uint FmtIndex, uint* MethodID, uint* AlgorithmType, uint* SamplingRate, 
                                uint* BitDepth, uint* NumChannels);
    ///Gets one of the video formats supported by the device.
    ///Params:
    ///    FmtIndex = The zero-based index of the video format to retrieve. To get the number of video formats, call
    ///               IBDA_Encoder::QueryCapabilities.
    ///    MethodID = Receives a value that uniquely identifies this video method.
    ///    AlgorithmType = Receives the type of encoding algorithm. The following values are defined. <table> <tr> <th>Value</th>
    ///                    <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PBDA_Encoder_Video_MPEG2PartII"></a><a
    ///                    id="pbda_encoder_video_mpeg2partii"></a><a id="PBDA_ENCODER_VIDEO_MPEG2PARTII"></a><dl>
    ///                    <dt><b>PBDA_Encoder_Video_MPEG2PartII</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> MPEG-2, Part
    ///                    2. </td> </tr> <tr> <td width="40%"><a id="PBDA_Encoder_Video_MPEG4Part10"></a><a
    ///                    id="pbda_encoder_video_mpeg4part10"></a><a id="PBDA_ENCODER_VIDEO_MPEG4PART10"></a><dl>
    ///                    <dt><b>PBDA_Encoder_Video_MPEG4Part10</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> MPEG-4, Part
    ///                    10. </td> </tr> <tr> <td width="40%"><a id="PBDA_Encoder_Video_AVC"></a><a id="pbda_encoder_video_avc"></a><a
    ///                    id="PBDA_ENCODER_VIDEO_AVC"></a><dl> <dt><b>PBDA_Encoder_Video_AVC</b></dt> <dt>0x00000001</dt> </dl> </td>
    ///                    <td width="60%"> AVC video. </td> </tr> <tr> <td width="40%"><a id="PBDA_Encoder_Video_H264"></a><a
    ///                    id="pbda_encoder_video_h264"></a><a id="PBDA_ENCODER_VIDEO_H264"></a><dl>
    ///                    <dt><b>PBDA_Encoder_Video_H264</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> H.264 video. </td>
    ///                    </tr> </table>
    ///    VerticalSize = Receives the vertical_size_value field.
    ///    HorizontalSize = Receives the horizontal_size_value field.
    ///    AspectRatio = Receives the aspect_ratio_information field.
    ///    FrameRateCode = Receives the frame_rate_code field.
    ///    ProgressiveSequence = Receives the progressive_sequence field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnumVideoCapability(uint FmtIndex, uint* MethodID, uint* AlgorithmType, uint* VerticalSize, 
                                uint* HorizontalSize, uint* AspectRatio, uint* FrameRateCode, 
                                uint* ProgressiveSequence);
    ///Sets the parameters for the Encoder Service.
    ///Params:
    ///    AudioBitrateMode = The audio compression mode. The following values are defined. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///                       </tr> <tr> <td width="40%"><a id="PBDA_Encoder_BitrateMode_Constant"></a><a
    ///                       id="pbda_encoder_bitratemode_constant"></a><a id="PBDA_ENCODER_BITRATEMODE_CONSTANT"></a><dl>
    ///                       <dt><b>PBDA_Encoder_BitrateMode_Constant</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Constant
    ///                       bit rate (CBR) mode. </td> </tr> <tr> <td width="40%"><a id="PBDA_Encoder_BitrateMode_Variable"></a><a
    ///                       id="pbda_encoder_bitratemode_variable"></a><a id="PBDA_ENCODER_BITRATEMODE_VARIABLE"></a><dl>
    ///                       <dt><b>PBDA_Encoder_BitrateMode_Variable</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Variable
    ///                       bit rate (VBR) mode. </td> </tr> <tr> <td width="40%"><a id="PBDA_Encoder_BitrateMode_Average"></a><a
    ///                       id="pbda_encoder_bitratemode_average"></a><a id="PBDA_ENCODER_BITRATEMODE_AVERAGE"></a><dl>
    ///                       <dt><b>PBDA_Encoder_BitrateMode_Average</b></dt> <dt>0x00000003</dt> </dl> </td> <td width="60%"> Average bit
    ///                       rate (ABR) mode. </td> </tr> </table>
    ///    AudioBitrate = The audio bit rate.
    ///    AudioMethodID = The active audio encoder method.
    ///    AudioProgram = The audio program number.
    ///    VideoBitrateMode = The video compression mode. For a list of values, see <i>AudioBitrateMode</i>.
    ///    VideoBitrate = The video bit rate.
    ///    VideoMethodID = The active video encoder method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetParameters(uint AudioBitrateMode, uint AudioBitrate, uint AudioMethodID, uint AudioProgram, 
                          uint VideoBitrateMode, uint VideoBitrate, uint VideoMethodID);
    ///Queries the current state of the Encoder Service.
    ///Params:
    ///    AudioBitrateMax = Receives the maximum audio bit rate.
    ///    AudioBitrateMin = Receives the minimum audio bit rate.
    ///    AudioBitrateMode = Receives the audio compression mode. The following values are defined. <table> <tr> <th>Value</th>
    ///                       <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PBDA_Encoder_BitrateMode_Constant"></a><a
    ///                       id="pbda_encoder_bitratemode_constant"></a><a id="PBDA_ENCODER_BITRATEMODE_CONSTANT"></a><dl>
    ///                       <dt><b>PBDA_Encoder_BitrateMode_Constant</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Constant
    ///                       bit rate (CBR) mode. </td> </tr> <tr> <td width="40%"><a id="PBDA_Encoder_BitrateMode_Variable"></a><a
    ///                       id="pbda_encoder_bitratemode_variable"></a><a id="PBDA_ENCODER_BITRATEMODE_VARIABLE"></a><dl>
    ///                       <dt><b>PBDA_Encoder_BitrateMode_Variable</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Variable
    ///                       bit rate (VBR) mode. </td> </tr> <tr> <td width="40%"><a id="PBDA_Encoder_BitrateMode_Average"></a><a
    ///                       id="pbda_encoder_bitratemode_average"></a><a id="PBDA_ENCODER_BITRATEMODE_AVERAGE"></a><dl>
    ///                       <dt><b>PBDA_Encoder_BitrateMode_Average</b></dt> <dt>0x00000003</dt> </dl> </td> <td width="60%"> Average bit
    ///                       rate (ABR) mode. </td> </tr> </table>
    ///    AudioBitrateStepping = Receives the minimum increment for the audio bit rate.
    ///    AudioBitrate = Receives the audio bit rate.
    ///    AudioMethodID = Receives the active audio encoder method.
    ///    AvailableAudioPrograms = Receives the number of audio programs available to the encoder.
    ///    AudioProgram = Receives the program number of the audio program that is currently being encoded.
    ///    VideoBitrateMax = Receives the maximum video bit rate.
    ///    VideoBitrateMin = Receives the minimum video bit rate.
    ///    VideoBitrateMode = Receives the video compression mode. For a list of values, see <i>AudioBitrateMode</i>.
    ///    VideoBitrate = Receives the video bit rate.
    ///    VideoBitrateStepping = Receives the minimum increment for the video bit rate.
    ///    VideoMethodID = Receives the active video encoder method.
    ///    SignalSourceID = Receives the identifier of the signal source. The value is an auxiliary connector ID, as returned by the
    ///                     IBDA_AUX::EnumCapability method.
    ///    SignalFormat = Receives a value from the AnalogVideoStandard enumeration. This value specifies the analog video standard
    ///                   that is received on the auxiliary input.
    ///    SignalLock = Receives the value <b>TRUE</b> if the device has a signal lock, and <b>FALSE</b> otherwise.
    ///    SignalLevel = Receives the signal level in decibels.
    ///    SignalToNoiseRatio = Receives a value between 0 and 100, indicating the signal-to-noise ratio.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetState(uint* AudioBitrateMax, uint* AudioBitrateMin, uint* AudioBitrateMode, 
                     uint* AudioBitrateStepping, uint* AudioBitrate, uint* AudioMethodID, 
                     uint* AvailableAudioPrograms, uint* AudioProgram, uint* VideoBitrateMax, uint* VideoBitrateMin, 
                     uint* VideoBitrateMode, uint* VideoBitrate, uint* VideoBitrateStepping, uint* VideoMethodID, 
                     uint* SignalSourceID, ulong* SignalFormat, int* SignalLock, int* SignalLevel, 
                     uint* SignalToNoiseRatio);
}

///Provides access to a device's Forward Data Channel (FDC) Service. The FDC is an out-of-band channel that carries
///configuration and control messages.
@GUID("138ADC7E-58AE-437F-B0B4-C9FE19D5B4AC")
interface IBDA_FDC : IUnknown
{
    ///Gets the tuning status of the Forward Data Channel (FDC) stream.
    ///Params:
    ///    CurrentBitrate = Receives the expected bit rate of the FDC stream, in kilobits per second (kbps).
    ///    CarrierLock = Receives the carrier lock status.
    ///    CurrentFrequency = Receives the current frequency of the FDC tuner, in kHz.
    ///    CurrentSpectrumInversion = Receives the expected spectrum inversion status of the FDC stream.
    ///    CurrentPIDList = Receives a comma-separated list of packet identifiers (PIDs). The caller must release the string by calling
    ///                     <b>SysFreeString</b>.
    ///    CurrentTIDList = Receives a comma-separated list of table identifiers (TIDs). The caller must release the string by calling
    ///                     <b>SysFreeString</b>.
    ///    Overflow = Receives the overflow status.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStatus(uint* CurrentBitrate, int* CarrierLock, uint* CurrentFrequency, 
                      int* CurrentSpectrumInversion, BSTR* CurrentPIDList, BSTR* CurrentTIDList, int* Overflow);
    ///Requests MPEG-2 table sections, filtered by table identifier (TID).
    ///Params:
    ///    TableIDs = A comma-separated list of TIDs.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RequestTables(BSTR TableIDs);
    ///Adds one or more packet identifiers (PIDs) to the MPEG flow.
    ///Params:
    ///    PidsToAdd = A comma-separated list of PIDs.
    ///    RemainingFilterEntries = Receives the number of remaining MPEG flows on the device.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddPid(BSTR PidsToAdd, uint* RemainingFilterEntries);
    ///Removes one or more packet identifiers (PIDs) from the MPEG flow.
    ///Params:
    ///    PidsToRemove = A comma-separated list of PIDs to remove.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemovePid(BSTR PidsToRemove);
    ///Adds one or more table identifiers (TIDs) to the MPEG flow.
    ///Params:
    ///    TidsToAdd = A comma-separated list of TIDs.
    ///    CurrentTidList = Receives a comma-separated list of the current TIDs. The caller must release the string by calling
    ///                     <b>SysFreeString</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddTid(BSTR TidsToAdd, BSTR* CurrentTidList);
    ///Removes one or more table identifiers (TIDs) from the MPEG flow.
    ///Params:
    ///    TidsToRemove = A comma-separated list of TIDs to remove.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveTid(BSTR TidsToRemove);
    ///Gets the latest table section.
    ///Params:
    ///    Pid = Receives the packet identifier (PID) of the table.
    ///    MaxBufferSize = The size of the <i>SecBuffer</i> array, in bytes.
    ///    ActualSize = Receives the number of bytes that the method copies into the <i>SecBuffer</i> array.
    ///    SecBuffer = A byte array, allocated by the caller, that receives the table section.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTableSection(uint* Pid, uint MaxBufferSize, uint* ActualSize, ubyte* SecBuffer);
}

///Retrieves out-of-band guide data from a media transform device (MTD). This interface provides access to a device's
///Guide Data Delivery Service.
@GUID("C0AFCB73-23E7-4BC6-BAFA-FDC167B4719F")
interface IBDA_GuideDataDeliveryService : IUnknown
{
    ///Gets the format UUID for the data that is retrieved on this service.
    ///Params:
    ///    pguidDataType = Receives either a UUID that identifies the format of the guide data or the network GUID that the tuner
    ///                    supports for in-band guide purposes. Possible values include the following. <table> <tr> <th>Value</th>
    ///                    <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CLSID_PBDA_GDDS_DATA_TYPE"></a><a
    ///                    id="clsid_pbda_gdds_data_type"></a><dl> <dt><b>CLSID_PBDA_GDDS_DATA_TYPE</b></dt> </dl> </td> <td
    ///                    width="60%"> Protected Broadcast Driver Architecture Service Information (PBDA-SI) format. </td> </tr>
    ///                    </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetGuideDataType(GUID* pguidDataType);
    ///Gets the next set of guide data that is available.
    ///Params:
    ///    pulcbBufferLen = Size of the <i>pbBuffer</i> array, in bytes.
    ///    pbBuffer = Pointer to a byte array that receives the guide data.
    ///    pulGuideDataPercentageProgress = Receives a value from 0 to 100. The value specifies the percent of guide data that was transferred from the
    ///                                     media transform device (MTD) to the media sink device (MSD) since the last call to
    ///                                     IBDA_GuideDataDeliveryService::RequestGuideDataUpdate.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return value</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt>BDA_E_NO_MORE_DATA</dt> </dl> </td> <td width="60%"> The MTD has
    ///    no more data to return. </td> </tr> </table>
    ///    
    HRESULT GetGuideData(uint* pulcbBufferLen, ubyte* pbBuffer, uint* pulGuideDataPercentageProgress);
    ///Requests updated guide data from the media transform device (MTD).
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RequestGuideDataUpdate();
    ///Converts a service identifier into an XML tune request. A service identifier (<i>ServiceIdx</i>) is a 64-bit
    ///identifier, used in the PBDA EIT guide delivery format. An XML tune request (<i>TuneXml</i>) is an XML string
    ///that can be used to tune to the service.
    ///Params:
    ///    ul64ServiceIdx = Identifier for the service.
    ///    pbstrTuneXml = Receives the XML tune request. The caller must release the string by calling <b>SysFreeString</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTuneXmlFromServiceIdx(ulong ul64ServiceIdx, BSTR* pbstrTuneXml);
    ///Gets a list of services that are available on the the media transform device (MTD).
    ///Params:
    ///    pulcbBufferLen = On input, specifies the size of the <i>pbBuffer</i> array, in bytes. On output, receives the size of the data
    ///                     that was written to the <i>pbBuffer</i> array.
    ///    pbBuffer = Pointer to a byte array that receives a list of service identifiers. A service identifier is a 64-bit value.
    ///               To translate a service identifier into a tune request, call
    ///               IBDA_GuideDataDeliveryService::GetTuneXmlFromServiceIdx.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServices(uint* pulcbBufferLen, ubyte* pbBuffer);
    ///Gets service information from an XML tune request.
    ///Params:
    ///    bstrTuneXml = The XML tune request. For more information, see IBDA_GuideDataDeliveryService::GetTuneXmlFromServiceIdx.
    ///    pbstrServiceDescription = Receives an XML string that contains information about the service. The caller must release the string by
    ///                              calling <b>SysFreeString</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceInfoFromTuneXml(BSTR bstrTuneXml, BSTR* pbstrServiceDescription);
}

///Provides access to a device's Digital Rights Management (DRM) Service.
@GUID("BFF6B5BB-B0AE-484C-9DCA-73528FB0B46E")
interface IBDA_DRMService : IUnknown
{
    ///Activates a digital rights management (DRM) system on the media transform device (MTD).
    ///Params:
    ///    puuidNewDrm = Pointer to a GUID that specifies the DRM system.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDRM(GUID* puuidNewDrm);
    ///Gets the current digital rights management (DRM) status.
    ///Params:
    ///    pbstrDrmUuidList = Receives a comma-separated list of GUIDs that identify the DRM systems supported by the media transform
    ///                       device (MTD). Each GUID is represented in following format: "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx". The
    ///                       caller must release the string by calling <b>SysFreeString</b>.
    ///    DrmUuid = Receives a GUID that identifies which DRM system is currently active.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDRMStatus(BSTR* pbstrDrmUuidList, GUID* DrmUuid);
}

@GUID("4BE6FA3D-07CD-4139-8B80-8C18BA3AEC88")
interface IBDA_WMDRMSession : IUnknown
{
    HRESULT GetStatus(uint* MaxCaptureToken, uint* MaxStreamingPid, uint* MaxLicense, uint* MinSecurityLevel, 
                      uint* RevInfoSequenceNumber, ulong* RevInfoIssuedTime, uint* RevInfoTTL, uint* RevListVersion, 
                      uint* ulState);
    HRESULT SetRevInfo(uint ulRevInfoLen, char* pbRevInfo);
    HRESULT SetCrl(uint ulCrlLen, char* pbCrlLen);
    HRESULT TransactMessage(uint ulcbRequest, char* pbRequest, uint* pulcbResponse, ubyte* pbResponse);
    HRESULT GetLicense(GUID* uuidKey, uint* pulPackageLen, ubyte* pbPackage);
    HRESULT ReissueLicense(GUID* uuidKey);
    HRESULT RenewLicense(uint ulInXmrLicenseLen, char* pbInXmrLicense, uint ulEntitlementTokenLen, 
                         char* pbEntitlementToken, uint* pulDescrambleStatus, uint* pulOutXmrLicenseLen, 
                         ubyte* pbOutXmrLicense);
    HRESULT GetKeyInfo(uint* pulKeyInfoLen, ubyte* pbKeyInfo);
}

@GUID("86D979CF-A8A7-4F94-B5FB-14C0ACA68FE6")
interface IBDA_WMDRMTuner : IUnknown
{
    HRESULT PurchaseEntitlement(uint ulDialogRequest, BSTR bstrLanguage, uint ulPurchaseTokenLen, 
                                char* pbPurchaseToken, uint* pulDescrambleStatus, uint* pulCaptureTokenLen, 
                                ubyte* pbCaptureToken);
    HRESULT CancelCaptureToken(uint ulCaptureTokenLen, char* pbCaptureToken);
    HRESULT SetPidProtection(uint ulPid, GUID* uuidKey);
    HRESULT GetPidProtection(uint pulPid, GUID* uuidKey);
    HRESULT SetSyncValue(uint ulSyncValue);
    HRESULT GetStartCodeProfile(uint* pulStartCodeProfileLen, ubyte* pbStartCodeProfile);
}

///The <b>IBDA_DRIDRMService</b> interface implements a Digital Rights Management (DRM) service for Media Transform
///Devices (MTDs) under the Protected Broadcast Driver Architecture (PBDA). This service allows conditional-access (CA)
///content to move between an MTD and a Media Sink Device (MSD) under DRM protection in a PBDA graph.
@GUID("1F9BC2A5-44A3-4C52-AAB1-0BBCE5A1381D")
interface IBDA_DRIDRMService : IUnknown
{
    ///Selects a Digital Rights Management (DRM) application for a Media Transform Device (MTD) in a Protected Broadcast
    ///Device Architecture (PBDA) graph. The MTD sets the DRMPairingStatus value to "Red", which indicates an unpaired
    ///state, and switches to the designated DRM application within five seconds.
    ///Params:
    ///    bstrNewDrm = Address of the GUID that identifies the new DRM application.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDRM(BSTR bstrNewDrm);
    ///The GetDRMSTatus method returns the current status of the Digital Rights Management (DRM) system for a Media
    ///Transform Device (MTD) in a graph under the Protected Broadcast Device Architecture (PBDA).
    ///Params:
    ///    pbstrDrmUuidList = Address of a variable that gets a comma-delimited string of UUID values that identify the DRM systems
    ///                       supported by the MTD. This method allocates the memory for the variable by calling <b>SysAllocString</b> and
    ///                       returns the associated pointer in this parameter. The caller is memory and is responsible for deallocating it
    ///                       by calling <b>SysFreeString</b>.
    ///    DrmUuid = Address of a variable that gets a GUID identifying the active DRM system for the MTD.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDRMStatus(BSTR* pbstrDrmUuidList, GUID* DrmUuid);
    ///The <b>GetPairingStatus</b> method gets the Digital Rights Management (DRM) pairing status for a Media Transform
    ///Device (MTD) in a graph under the Protected Broadcast Driver Architecture (PBDA). This status indicates whether a
    ///secure pairing exists between the MTD and a Media Sink Device (MSD) so that controlled-access (CA) content can be
    ///released.
    ///Params:
    ///    penumPairingStatus = Address of a variable that gets the pairing device status. The caller passes in a pointer to this variable,
    ///                         and this method returns the correct status value in this parameter. The pairing status that is passed back
    ///                         can be any of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///                         width="40%"><a id="_Green_"></a><a id="_green_"></a><a id="_GREEN_"></a><dl> <dt><b>"Green"</b></dt> </dl>
    ///                         </td> <td width="60%"> The MTD is paired with an MSD, so CA content is released under DRM protection. </td>
    ///                         </tr> <tr> <td width="40%"><a id="_Orange_"></a><a id="_orange_"></a><a id="_ORANGE_"></a><dl>
    ///                         <dt><b>"Orange"</b></dt> </dl> </td> <td width="60%"> The MTD is paired with an MSD, but this pairing is
    ///                         about to time out. The MSD is expected to refresh its pairing in the background. CA content is released under
    ///                         DRM protection. </td> </tr> <tr> <td width="40%"><a id="_Red_"></a><a id="_red_"></a><a id="_RED_"></a><dl>
    ///                         <dt><b>"Red"</b></dt> </dl> </td> <td width="60%"> The MTD is not paired with an MSD, so CA content is is not
    ///                         released. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPairingStatus(BDA_DrmPairingError* penumPairingStatus);
}

@GUID("05C690F8-56DB-4BB2-B053-79C12098BB26")
interface IBDA_DRIWMDRMSession : IUnknown
{
    HRESULT AcknowledgeLicense(HRESULT hrLicenseAck);
    HRESULT ProcessLicenseChallenge(uint dwcbLicenseMessage, char* pbLicenseMessage, uint* pdwcbLicenseResponse, 
                                    char* ppbLicenseResponse);
    HRESULT ProcessRegistrationChallenge(uint dwcbRegistrationMessage, char* pbRegistrationMessage, 
                                         uint* pdwcbRegistrationResponse, ubyte** ppbRegistrationResponse);
    HRESULT SetRevInfo(uint dwRevInfoLen, char* pbRevInfo, uint* pdwResponse);
    HRESULT SetCrl(uint dwCrlLen, char* pbCrlLen, uint* pdwResponse);
    HRESULT GetHMSAssociationData();
    HRESULT GetLastCardeaError(uint* pdwError);
}

///Provides access to a device's Mux Service. The Mux Service is used to specify which packet identifiers (PIDs) in the
///MPEG transport stream are delivered to a media sink device (MSD).
@GUID("942AAFEC-4C05-4C74-B8EB-8706C2A4943F")
interface IBDA_MUX : IUnknown
{
    ///Sets the list of packet identifiers (PIDs) that are enabled to go across the Protected Broadcast Driver
    ///Architecture (PBDA) interface.
    ///Params:
    ///    ulPidListCount = The number of elements in the <i>pbPidListBuffer</i> array.
    ///    pbPidListBuffer = Pointer to an array of BDA_MUX_PIDLISTITEM structures.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPidList(uint ulPidListCount, char* pbPidListBuffer);
    ///Gets the list of packet identifiers (PIDs) that are enabled to go across the Protected Broadcast Driver
    ///Architecture (PBDA) interface.
    ///Params:
    ///    pulPidListCount = On input, specifies the size, in array elements, of the <i>pbPidListBuffer</i> array. On output, receives the
    ///                      number of PIDs.
    ///    pbPidListBuffer = Pointer to an array of BDA_MUX_PIDLISTITEM structures. The method fills in the array with the list of PIDs.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_NOT_SUFFICIENT_BUFFER</b></b></dt> </dl> </td> <td width="60%">
    ///    The <i>pbPidListBuffer</i> array is too small. </td> </tr> </table>
    ///    
    HRESULT GetPidList(uint* pulPidListCount, BDA_MUX_PIDLISTITEM* pbPidListBuffer);
}

@GUID("1DCFAFE9-B45E-41B3-BB2A-561EB129AE98")
interface IBDA_TransportStreamSelector : IUnknown
{
    HRESULT SetTSID(ushort usTSID);
    HRESULT GetTSInformation(uint* pulTSInformationBufferLen, char* pbTSInformationBuffer);
}

///Defines methods that detect user activity in a Protected Broadcast Driver Architecture (PBDA) media graph.
@GUID("53B14189-E478-4B7A-A1FF-506DB4B99DFE")
interface IBDA_UserActivityService : IUnknown
{
    ///Specifies the current tuner use reason for a Media Sink Device (MSD) in a Protected Broadcast Driver Architecture
    ///(PBDA) media graph. A <i>current tuner use reason</i> records the reason that the MSD is currently using the
    ///tuner on a Media Transform Device (MTD). An MSD calls this method every time the current tuner use reason
    ///changes. For example, when an MSD starts a recording, it calls this method and sets the use reason as "user
    ///directed recording." An MSD must also call this method every time it sets a tuner device, even if the use reason
    ///has not changed.
    ///Params:
    ///    dwUseReason = Specifies the tuner use reason. This is one of the following values: <table> <tr> <th>Value</th>
    ///                  <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Setup or
    ///                  scanning </td> </tr> <tr> <td width="40%"> <dl> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Playback for
    ///                  a user </td> </tr> <tr> <td width="40%"> <dl> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Picture in
    ///                  Picture (PIP) playback for a user </td> </tr> <tr> <td width="40%"> <dl> <dt>0x00000008</dt> </dl> </td> <td
    ///                  width="60%"> User-directed recording </td> </tr> <tr> <td width="40%"> <dl> <dt>0x00000010</dt> </dl> </td>
    ///                  <td width="60%"> Speculative recording </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCurrentTunerUseReason(uint dwUseReason);
    ///Gets the interval that a Media Sink Device (MSD) in a Protected Broadcast Driver Architecture (PBDA) media graph
    ///waits before calling the UserActivityDetected method after the MSD detects user activity. This interval is known
    ///as the <i>user activity interval</i>. An MSD must call this method before it calls <b>UserActivityDetected</b>
    ///for the first time, but does not need to call this method thereafter while the graph is running.
    ///Params:
    ///    pdwActivityInterval = Gets the user activity interval, in seconds.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetUserActivityInterval(uint* pdwActivityInterval);
    ///Indicates that a Media Sink Device (MSD) in a Protected Broadcast Driver Architecture (PBDA) media graph has
    ///detected user activity and is informing a Media Transfer Device (MTD) of this activity. The MSD calls this method
    ///only if the current activity interval has elapsed since the the MSD most recently called this method. The
    ///GetUserActivityInterval method sets or obtains the value of the current activity interval.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> User activity service failed.
    ///    </td> </tr> </table>
    ///    
    HRESULT UserActivityDetected();
}

///Implements a generic event interface that can deliver and encapsulate events that are raised by devices that work
///with the Protected Broadcast Driver Interface (PBDA). PBDA devices pass <b>IESEvent</b> objects in calls to
///IESEventService::FireESEvent. Any devices that have registered to receive an event can call <b>IESEvent</b> methods
///to get data from the event.
@GUID("1F0E5357-AF43-44E6-8547-654C645145D2")
interface IESEvent : IUnknown
{
    ///Gets the unique identifier from an event that is derived from the IESEvent interface. The event identifier is
    ///contained in an <b>IESEvent</b> object, which ispassed in a call to IESEventService::FireESEvent.
    ///Params:
    ///    pdwEventId = Receives the event identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEventId(uint* pdwEventId);
    ///Gets the GUID that identifies an event that is derived from the IESEvent interface. The GUID is contained in an
    ///<b>IESEvent</b> object, which ispassed in a call to IESEventService::FireESEvent.
    ///Params:
    ///    pguidEventType = Pointer to the GUID that uniquely identifies the event type.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEventType(GUID* pguidEventType);
    ///Sets the completion status for an event that is derived from the IESEvent interface. The device handling the
    ///event sets the completion status in the <b>IESEvent</b> object that is passed in a call to
    ///IESEventService::FireESEvent. If an event originates from a PBDA device, the event object automatically calls the
    ///IBDA_EventingService::CompleteEvent method with the result set in the <b>SetCompletionStatus</b> call at the time
    ///it is released. If the client is a managed application, it should dispose of the event object immediately after
    ///it is finished with the event. This disposition ensures that the <b>IBDA_EventingService::CompleteEvent</b>
    ///method is called in a timely manner
    ///Params:
    ///    dwResult = Completion status for the event.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCompletionStatus(uint dwResult);
    ///Gets data from an event that is derived from the IESEvent interface. This method gets a byte array that contains
    ///the data in an <b>IESEvent</b> object, which is passed in a call to IESEventService::FireESEvent.
    ///Params:
    ///    pbData = Pointer to <b>SAFEARRAY</b> that receives the event data. The caller is responsible for freeing the
    ///             <b>SAFEARRAY</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetData(SAFEARRAY** pbData);
    ///Gets the data from an event that is derived from the IESEvent interface, in Unicode string format. The data is
    ///contained in an <b>IESEvent</b> object, which ispassed in a call to IESEventService::FireESEvent.
    ///Params:
    ///    pbstrData = Pointer to a buffer that receives the data that is passed with the <b>IESEvent</b> object, in Unicode string
    ///                format. The caller must release this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStringData(BSTR* pbstrData);
}

///Implements event handling for devices that have registered to receive specific events derived from the IESEvent
///interface. In a Protected Broadcast Driver Architecture graph, Media Sink Devices implement this interface to
///register for events.
@GUID("ABD414BF-CFE5-4E5E-AF5B-4B4E49C5BFEB")
interface IESEvents : IUnknown
{
    ///Defines a handler for an event that is derived from the IESEvent interface. In a Protected Broadcast Driver
    ///Architecture graph, Media Sink Devices that implement the IESEvents interface use this method to obtain data from
    ///Event System events that these devices receive. In this context, <i>Event System events</i> refer to event
    ///objects that that implement the <b>IESEvent</b> interface. If an event originates from a PBDA device, the event
    ///object automatically calls the IBDA_EventingService::CompleteEvent method with the result set in the
    ///SetCompletionStatus call at the time it is released. If the client is a managed application, it should dispose of
    ///the event object immediately after it is finished with the event. This disposition ensures that the
    ///<b>IBDA_EventingService::CompleteEvent</b> method is called in a timely manner This method is called from an
    ///event service thread that is initialized with multithreaded COM concurrency. The receiving object must use the
    ///multithreaded threading model or the single-threaded model with proper marshaling.
    ///Params:
    ///    guidEventType = GUID for the type of event being handled.
    ///    pESEvent = Pointer to an IESEvent object that contains data from the event being handled.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnESEventReceived(GUID guidEventType, IESEvent pESEvent);
}

///The <b>IBroadcastEvent</b> interface enables an object to receive events from another object without setting up a
///direct connection point. Applications typically do not need to use this interface.
@GUID("3B21263F-26E8-489D-AAC4-924F7EFD9511")
interface IBroadcastEvent : IUnknown
{
    ///The <b>Fire</b> method fires a broadcast event.
    ///Params:
    ///    EventID = GUID that specifies the event.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT Fire(GUID EventID);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
///<b>IBroadcastEventEx</b> interface is an extended version of the IBroadcastEvent interface. Like IBroadcastEvent, the
///<b>IBroadcastEventEx</b> interface enables an object to receive events from another object without setting up a
///direct connection point. Applications typically do not need to use either of these interfaces. For information about
///implementing a class that can source or sink broadcast events, see the example code in IBroadcastEvent Interface.
@GUID("3D9E3887-1929-423F-8021-43682DE95448")
interface IBroadcastEventEx : IBroadcastEvent
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>FireEx</b>
    ///method fires a broadcast event.
    ///Params:
    ///    EventID = GUID that specifies the event.
    ///    Param1 = Specifies the first implementation-dependent parameter.
    ///    Param2 = Specifies the second implementation-dependent parameter.
    ///    Param3 = Specifies the third implementation-dependent parameter.
    ///    Param4 = Specifies the fourth implementation-dependent parameter.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT FireEx(GUID EventID, uint Param1, uint Param2, uint Param3, uint Param4);
}

///The <code>IAMNetShowConfig</code> interface configures the legacy Windows Media Player 6.4 source filter. The Windows
///Media Source filter implements this interface.
interface IAMNetShowConfig : IDispatch
{
    ///The <code>get_BufferingTime</code> method retrieves the buffering time.
    ///Params:
    ///    pBufferingTime = Pointer that receives the buffering time, in seconds.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_BufferingTime(double* pBufferingTime);
    ///The <code>put_BufferingTime</code> method specifies the buffering time.
    ///Params:
    ///    BufferingTime = Specifies the buffering time, in seconds.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_BufferingTime(double BufferingTime);
    ///The <code>get_UseFixedUDPPort</code> method queries whether the filter should use the fixed UDP port.
    ///Params:
    ///    pUseFixedUDPPort = Pointer to a variable that receives a Boolean value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_UseFixedUDPPort(short* pUseFixedUDPPort);
    ///The <code>put_UseFixedUDPPort</code> method specifies whether to use a fixed UDP port number.
    ///Params:
    ///    UseFixedUDPPort = Specify one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                      <td>VARIANT_TRUE</td> <td>Use a fixed UDP port.</td> </tr> <tr> <td>VARIANT_FALSE</td> <td>Use a dynamic UDP
    ///                      port.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_UseFixedUDPPort(short UseFixedUDPPort);
    ///The <code>get_FixedUDPPort</code> method gets the fixed UDP port number.
    ///Params:
    ///    pFixedUDPPort = Pointer to a variable that receives the fixed UDP port number.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_FixedUDPPort(int* pFixedUDPPort);
    ///The <code>put_FixedUDPPort</code> method specifies the fixed UDP port.
    ///Params:
    ///    FixedUDPPort = Specifies the fixed UDP port number.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_FixedUDPPort(int FixedUDPPort);
    ///The <code>get_UseHTTPProxy</code> method queries whether the filter should use the HTTP proxy server.
    ///Params:
    ///    pUseHTTPProxy = Pointer to a variable that receives a Boolean value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_UseHTTPProxy(short* pUseHTTPProxy);
    ///The <code>put_UseHTTPProxy</code> method specifies whether to use an HTTP proxy server.
    ///Params:
    ///    UseHTTPProxy = Specify one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                   <td>VARIANT_TRUE</td> <td>Use an HTTP proxy server.</td> </tr> <tr> <td>VARIANT_FALSE</td> <td>Do not use an
    ///                   HTTP proxy server.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_UseHTTPProxy(short UseHTTPProxy);
    ///The <code>get_EnableAutoProxy</code> method queries whether the control or filter should use the browser's proxy
    ///settings.
    ///Params:
    ///    pEnableAutoProxy = Pointer to a variable that receives a Boolean value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_EnableAutoProxy(short* pEnableAutoProxy);
    ///The <code>put_EnableAutoProxy</code> method enables or disables auto-proxy.
    ///Params:
    ///    EnableAutoProxy = Specify one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                      <td>VARIANT_TRUE</td> <td>Enable auto-proxy.</td> </tr> <tr> <td>VARIANT_FALSE</td> <td>Disable
    ///                      auto-proxy.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_EnableAutoProxy(short EnableAutoProxy);
    ///The <code>get_HTTPProxyHost</code> method retrieves the HTTP address of the proxy host.
    ///Params:
    ///    pbstrHTTPProxyHost = Pointer to a variable that receives the HTTP address.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_HTTPProxyHost(BSTR* pbstrHTTPProxyHost);
    ///The <code>put_HTTPProxyHost</code> method specifies the address of the HTTP proxy server.
    ///Params:
    ///    bstrHTTPProxyHost = Specifies the proxy's address.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_HTTPProxyHost(BSTR bstrHTTPProxyHost);
    ///The <code>get_HTTPProxyPort</code> method retrieves the HTTP proxy port.
    ///Params:
    ///    pHTTPProxyPort = Pointer to a variable that receives the port number.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_HTTPProxyPort(int* pHTTPProxyPort);
    ///The <code>put_HTTPProxyPort</code> method specifies the port for the HTTP proxy server.
    ///Params:
    ///    HTTPProxyPort = Specifies the HTTP proxy port.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_HTTPProxyPort(int HTTPProxyPort);
    ///The <code>get_EnableMulticast</code> method queries whether multicast-type streaming is enabled.
    ///Params:
    ///    pEnableMulticast = Pointer to a variable that receives a Boolean value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_EnableMulticast(short* pEnableMulticast);
    ///The <code>put_EnableMulticast</code> method enables or disables multicast-based streaming.
    ///Params:
    ///    EnableMulticast = Specify one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                      <td>VARIANT_TRUE</td> <td>Enable multicast-based streaming.</td> </tr> <tr> <td>VARIANT_FALSE</td>
    ///                      <td>Disable multicast-based streaming.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_EnableMulticast(short EnableMulticast);
    ///The <code>get_EnableUDP</code> method queries whether UDP-based streaming is enabled.
    ///Params:
    ///    pEnableUDP = Pointer to a variable that receives a Boolean value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_EnableUDP(short* pEnableUDP);
    ///The <code>put_EnableUDP</code> method enables or disablles UDP-based streaming.
    ///Params:
    ///    EnableUDP = Specify one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                <td>VARIANT_TRUE</td> <td>Enable UDP-based streaming.</td> </tr> <tr> <td>VARIANT_FALSE</td> <td>Disable
    ///                UDP-based streaming.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_EnableUDP(short EnableUDP);
    ///The <code>get_EnableTCP</code> method queries whether TCP-based streaming is enabled.
    ///Params:
    ///    pEnableTCP = Pointer to a variable that receives a Boolean value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_EnableTCP(short* pEnableTCP);
    ///The <code>put_EnableTCP</code> method enables or disables TCP-based streaming.
    ///Params:
    ///    EnableTCP = Specify one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                <td>VARIANT_TRUE</td> <td>Enable TCP-based streaming.</td> </tr> <tr> <td>VARIANT_FALSE</td> <td>Disable
    ///                TCP-based streaming.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_EnableTCP(short EnableTCP);
    ///The <code>get_EnableHTTP</code> method queries whether HTTP-type streaming is enabled.
    ///Params:
    ///    pEnableHTTP = Pointer to a variable that receives a Boolean value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_EnableHTTP(short* pEnableHTTP);
    ///The <code>put_EnableHTTP</code> method enables or disables HTTP-based streaming.
    ///Params:
    ///    EnableHTTP = Specify one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                 <td>VARIANT_TRUE</td> <td>Enable HTTP-based streaming.</td> </tr> <tr> <td>VARIANT_FALSE</td> <td>Disable
    ///                 HTTP-based streaming.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_EnableHTTP(short EnableHTTP);
}

///The <b>IAMChannelInfo</b> interface gets and sets channel information for Windows Media Station (.nsc) files. This
///interface is exposed by the Windows Media Source filter only when the filter is reading Windows Media Station (.nsc)
///files. The Windows Media Source filter uses .nsc files to get the information it needs to receive multicast content
///over the Internet. These files contain information such as stream location and rollover URL, as well as descriptive
///information about the station.
interface IAMChannelInfo : IDispatch
{
    ///The <code>get_ChannelName</code> method retrieves the channel name.
    ///Params:
    ///    pbstrChannelName = Pointer to a variable that receives a string containing the channel name.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_ChannelName(BSTR* pbstrChannelName);
    ///The <code>get_ChannelDescription</code> method retrieves the description of the channel.
    ///Params:
    ///    pbstrChannelDescription = Receives the channel description.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_ChannelDescription(BSTR* pbstrChannelDescription);
    ///The <code>get_ChannelURL</code> method retrieves the channel URL.
    ///Params:
    ///    pbstrChannelURL = Pointer to a variable that receives the URL.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_ChannelURL(BSTR* pbstrChannelURL);
    ///The <code>get_ContactAddress</code> method retrieves the contact address.
    ///Params:
    ///    pbstrContactAddress = Pointer to a variable that receives the contact address.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_ContactAddress(BSTR* pbstrContactAddress);
    ///The <code>get_ContactPhone</code> method retrieves the phone number of the contact.
    ///Params:
    ///    pbstrContactPhone = Pointer to a variable that receives the contact's phone number.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_ContactPhone(BSTR* pbstrContactPhone);
    ///The <b>get_ContactEmail</b> method gets the email address of the contact.
    ///Params:
    ///    pbstrContactEmail = Receives the contact email.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_ContactEmail(BSTR* pbstrContactEmail);
}

///The <code>IAMNetworkStatus</code> interface reports the quality of the network connection for the legacy Windows
///Media Player 6.4 source filter. The Windows Media Source filter implements this interface. It enables clients to
///retrieve information about the quality of the network connection.
interface IAMNetworkStatus : IDispatch
{
    ///The <code>get_ReceivedPackets</code> method retrieves the number of packets that have been received.
    ///Params:
    ///    pReceivedPackets = Pointer to a variable that receives the number of received packets.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_ReceivedPackets(int* pReceivedPackets);
    ///The <code>get_RecoveredPackets</code> method retrieves the number of recovered packets.
    ///Params:
    ///    pRecoveredPackets = Pointer to a variable that receives the number of recovered packets.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_RecoveredPackets(int* pRecoveredPackets);
    ///The <code>get_LostPackets</code> method retrieves the number of packets that have been lost.
    ///Params:
    ///    pLostPackets = Pointer to a variable that receives the number of lost packets.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_LostPackets(int* pLostPackets);
    ///The <code>get_ReceptionQuality</code> method retrieves a value indicating the reception quality.
    ///Params:
    ///    pReceptionQuality = Pointer to a variable that receives a value from 0 to 100, indicating the reception quality. This value is
    ///                        percentage of packets that the filter received without requiring resending or error correction.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_ReceptionQuality(int* pReceptionQuality);
    ///The <code>get_BufferingCount</code> method retrieves the number of times the network source has buffered the
    ///data.
    ///Params:
    ///    pBufferingCount = Pointer to a variable that receives the buffering count.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_BufferingCount(int* pBufferingCount);
    ///The <code>get_IsBroadcast</code> method retrieves a value indicating whether the current stream is a broadcast
    ///stream.
    ///Params:
    ///    pIsBroadcast = Pointer to a variable that receives a Boolean value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_IsBroadcast(short* pIsBroadcast);
    ///The <code>get_BufferingProgress</code> method retrieves a value indicating the buffering progress.
    ///Params:
    ///    pBufferingProgress = Pointer to a variable that receives a value from 0 to 100, indicating what percentage has completed.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_BufferingProgress(int* pBufferingProgress);
}

///The <code>IAMExtendedSeeking</code> interface seeks to a marker in a Windows Media stream or changes the playback
///rate for a Windows Media file. This interface is implemented by the Windows Media Source filter and the WM ASF Reader
///filter.
interface IAMExtendedSeeking : IDispatch
{
    ///The <code>get_ExSeekCapabilities</code> method retrieves the extended seeking capabilities of the filter.
    ///Params:
    ///    pExCapabilities = Pointer to a variable that receives a bitwise OR of AMExtendedSeekingCapabilities flags.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_ExSeekCapabilities(int* pExCapabilities);
    ///The <code>get_MarkerCount</code> method retrieves the number of markers in the current stream.
    ///Params:
    ///    pMarkerCount = Pointer to a variable that receives the marker count.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_MarkerCount(int* pMarkerCount);
    ///The <code>get_CurrentMarker</code> method retrieves the current marker.
    ///Params:
    ///    pCurrentMarker = Pointer to a variable that receives the current marker.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_CurrentMarker(int* pCurrentMarker);
    ///The <b>GetMarkerTime</b> method retrieves the presentation time associated with the specified marker.
    ///Params:
    ///    MarkerNum = Specifies the marker number.
    ///    pMarkerTime = Pointer to a variable that receives the marker time.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetMarkerTime(int MarkerNum, double* pMarkerTime);
    ///The <code>GetMarkerName</code> method retrieves the name associated with the specified marker.
    ///Params:
    ///    MarkerNum = Specifies the marker number.
    ///    pbstrMarkerName = Pointer to a variable that receives the marker name.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetMarkerName(int MarkerNum, BSTR* pbstrMarkerName);
    ///The <code>put_PlaybackSpeed</code> method specifies the playback speed.
    ///Params:
    ///    Speed = Specifies the playback speed. The value may be positive or negative, but not zero.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_PlaybackSpeed(double Speed);
    ///The <code>get_PlaybackSpeed</code> method retrieves the playback speed.
    ///Params:
    ///    pSpeed = Pointer to a variable that receives the playback speed.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_PlaybackSpeed(double* pSpeed);
}

///The <code>IAMNetShowExProps</code> interface configures the legacy Windows Media Player 6.4 source filter. The
///Windows Media Source filter implements this interface.
interface IAMNetShowExProps : IDispatch
{
    ///The <code>get_SourceProtocol</code> method retrieves the source protocol.
    ///Params:
    ///    pSourceProtocol = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///                      </th> </tr> <tr> <td>0</td> <td>Unknown protocol</td> </tr> <tr> <td>1</td> <td>Multicast</td> </tr> <tr>
    ///                      <td>2</td> <td>Multisession bridge</td> </tr> <tr> <td>3</td> <td>UDP</td> </tr> <tr> <td>4</td> <td>TCP</td>
    ///                      </tr> <tr> <td>5</td> <td>Media Streaming Broadcast Distribution (MSBD)</td> </tr> <tr> <td>6</td>
    ///                      <td>HTTP</td> </tr> <tr> <td>7</td> <td>File</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_SourceProtocol(int* pSourceProtocol);
    ///The <code>get_Bandwidth</code> method retrieves the bandwidth.
    ///Params:
    ///    pBandwidth = Pointer to a variable that receives the bandwidth.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_Bandwidth(int* pBandwidth);
    ///The <code>get_ErrorCorrection</code> method retrieves the current error correction method.
    ///Params:
    ///    pbstrErrorCorrection = Pointer to a variable that receives a string describing the error correction method.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_ErrorCorrection(BSTR* pbstrErrorCorrection);
    ///The <code>get_CodecCount</code> method retrieves the number codecs needed to play the file.
    ///Params:
    ///    pCodecCount = Pointer to a variable that receives the number of codecs.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_CodecCount(int* pCodecCount);
    ///The <code>GetCodecInstalled</code> method queries whether a specified codec is installed on the local system.
    ///Params:
    ///    CodecNum = Specifies the codec to query, indexed from zero. Call <b>get_CodecCount</b> to obtain the number of codecs.
    ///    pCodecInstalled = Pointer that receives a Boolean value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetCodecInstalled(int CodecNum, short* pCodecInstalled);
    ///The <code>GetCodecDescription</code> method retrieves a user-friendly description of a specified codec.
    ///Params:
    ///    CodecNum = Specifies the codec to query, indexed from zero. Call <b>get_CodecCount</b> to obtain the number of codecs.
    ///    pbstrCodecDescription = Pointer to a variable that receives the description.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetCodecDescription(int CodecNum, BSTR* pbstrCodecDescription);
    ///The <code>GetCodecURL</code> method retrieves the URL where the codec may be downloaded.
    ///Params:
    ///    CodecNum = Specifies the codec to query, indexed from zero. Call <b>get_CodecCount</b> to obtain the number of codecs.
    ///    pbstrCodecURL = Pointer that receives the URL.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetCodecURL(int CodecNum, BSTR* pbstrCodecURL);
    ///The <code>get_CreationDate</code> method retrieves the creation date of the source file.
    ///Params:
    ///    pCreationDate = Pointer to a variable that receives the date.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_CreationDate(double* pCreationDate);
    ///The <code>get_SourceLink</code> method retrieves the source link.
    ///Params:
    ///    pbstrSourceLink = Pointer to a variable that receives the source link.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_SourceLink(BSTR* pbstrSourceLink);
}

///The <code>IAMExtendedErrorInfo</code> interface is used to obtain error information. <div class="alert"><b>Note</b>
///This interface is not implemented by any default components in DirectShow.</div> <div> </div>
interface IAMExtendedErrorInfo : IDispatch
{
    ///The <code>get_HasError</code> method queries whether an error occurred.
    ///Params:
    ///    pHasError = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///                </th> </tr> <tr> <td>VARIANT_FALSE</td> <td>No error.</td> </tr> <tr> <td>VARIANT_TRUE</td> <td>An error
    ///                occurred.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_HasError(short* pHasError);
    ///The <code>get_ErrorDescription</code> method retrieves the extended error description.
    ///Params:
    ///    pbstrErrorDescription = Pointer to a variable that receives the error description.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_ErrorDescription(BSTR* pbstrErrorDescription);
    ///The <code>get_ErrorCode</code> method retrieves the current error code.
    ///Params:
    ///    pErrorCode = Pointer to a variable that receives the error code.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_ErrorCode(int* pErrorCode);
}

///The <b>IAMMediaContent</b> interface retrieves metadata from a stream. Applications can use this interface to
///retrieve information encoded into a stream, such as the author, title, and copyright. This interface is exposed by
///the AVI Splitter filter and the MPEG-1 Stream Splitter filter. Depending on the stream type, a filter might support a
///subset of the methods on this interface. For example, the AVI Splitter retrieves the copyright, author name, and
///title from INFO chunks in the AVI file. The remaining methods return <b> E_NOTIMPL</b>. <div
///class="alert"><b>Note</b> Windows Media Player does not use this interface to display metadata.</div> <div> </div>
interface IAMMediaContent : IDispatch
{
    ///The <code>get_AuthorName</code> method retrieves the author name.
    ///Params:
    ///    pbstrAuthorName = Pointer to a variable that receives a <b>BSTR</b> with the information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Item not found. </td> </tr> </table>
    ///    
    HRESULT get_AuthorName(BSTR* pbstrAuthorName);
    ///The <code>get_Title</code> method retrieves the title.
    ///Params:
    ///    pbstrTitle = Pointer to a variable that receives a <b>BSTR</b> with the information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Item not found. </td> </tr> </table>
    ///    
    HRESULT get_Title(BSTR* pbstrTitle);
    ///The <code>get_Rating</code> method retrieves the rating.
    ///Params:
    ///    pbstrRating = Pointer to a variable that receives a <b>BSTR</b> with the information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Item not found. </td> </tr> </table>
    ///    
    HRESULT get_Rating(BSTR* pbstrRating);
    ///The <code>get_Description</code> method retrieves a description of the content.
    ///Params:
    ///    pbstrDescription = Pointer to a variable that receives a <b>BSTR</b> with the information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Item not found. </td> </tr> </table>
    ///    
    HRESULT get_Description(BSTR* pbstrDescription);
    ///The <code>get_Copyright</code> method retrieves copyright information.
    ///Params:
    ///    pbstrCopyright = Pointer to a variable that receives a <b>BSTR</b> with the information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Item not found. </td> </tr> </table>
    ///    
    HRESULT get_Copyright(BSTR* pbstrCopyright);
    ///The <b>get_BaseURL</b> method gets a base URL for the related web content.
    ///Params:
    ///    pbstrBaseURL = Receives a <b>BSTR</b> with the information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Item not found. </td> </tr> </table>
    ///    
    HRESULT get_BaseURL(BSTR* pbstrBaseURL);
    ///The <code>get_LogoURL</code> method retrieves a URL for the logo.
    ///Params:
    ///    pbstrLogoURL = Pointer to a variable that receives a <b>BSTR</b> with the information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Item not found. </td> </tr> </table>
    ///    
    HRESULT get_LogoURL(BSTR* pbstrLogoURL);
    ///The <code>get_LogoIconURL</code> method retrieves a URL for the logo icon.
    ///Params:
    ///    pbstrLogoURL = Pointer to a variable that receives a <b>BSTR</b> with the information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Item not found. </td> </tr> </table>
    ///    
    HRESULT get_LogoIconURL(BSTR* pbstrLogoURL);
    ///The <code>get_WatermarkURL</code> method retrieves a URL for the watermark.
    ///Params:
    ///    pbstrWatermarkURL = Pointer to a variable that receives a <b>BSTR</b> with the information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Item not found. </td> </tr> </table>
    ///    
    HRESULT get_WatermarkURL(BSTR* pbstrWatermarkURL);
    ///The <code>get_MoreInfoURL</code> method retrieves a URL for additional information about the content.
    ///Params:
    ///    pbstrMoreInfoURL = Pointer to a variable that receives a <b>BSTR</b> with the information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Item not found. </td> </tr> </table>
    ///    
    HRESULT get_MoreInfoURL(BSTR* pbstrMoreInfoURL);
    ///The <code>get_MoreInfoBannerImage</code> method retrieves an image for a related-information banner.
    ///Params:
    ///    pbstrMoreInfoBannerImage = Pointer to a variable that receives a <b>BSTR</b> with the information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Item not found. </td> </tr> </table>
    ///    
    HRESULT get_MoreInfoBannerImage(BSTR* pbstrMoreInfoBannerImage);
    ///The <code>get_MoreInfoBannerURL</code> method retrieves a URL for a related-information banner.
    ///Params:
    ///    pbstrMoreInfoBannerURL = Pointer to a variable that receives a <b>BSTR</b> with the information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Item not found. </td> </tr> </table>
    ///    
    HRESULT get_MoreInfoBannerURL(BSTR* pbstrMoreInfoBannerURL);
    ///The <code>get_MoreInfoText</code> method retrieves additional information as text.
    ///Params:
    ///    pbstrMoreInfoText = Pointer to a variable that receives a <b>BSTR</b> with the information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Item not found. </td> </tr> </table>
    ///    
    HRESULT get_MoreInfoText(BSTR* pbstrMoreInfoText);
}

///The <code>IAMMediaContent2</code> interface retrieves custom parameters and playlists from ASX files. This interface
///is not implemented by any default components in DirectShow.
interface IAMMediaContent2 : IDispatch
{
    ///The <code>get_MediaParameter</code> method retrieves the value of a custom parameter in the ASX file. This
    ///interface is not supported.
    ///Params:
    ///    EntryNum = Specifies the location of the parameter in the ASX file. <table> <tr> <th>Value </th> <th>Description </th>
    ///               </tr> <tr> <td>0</td> <td>The parameter is a direct child of the ASX node.</td> </tr> <tr> <td>&gt; 0</td>
    ///               <td>The parameter is located inside an ENTRY tag; <i>EntryNum</i> specifies the entry, indexed from 1.</td>
    ///               </tr> </table>
    ///    bstrName = Specifies the name of the parameter.
    ///    pbstrValue = Pointer to a variable that receives the value of the parameter.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_MediaParameter(int EntryNum, BSTR bstrName, BSTR* pbstrValue);
    ///The <code>get_MediaParameterName</code> method retrieves the name of a custom parameter in an ASX file. This
    ///interface is not supported.
    ///Params:
    ///    EntryNum = Specifies the location of the parameter in the ASX file. <table> <tr> <th>Value </th> <th>Description </th>
    ///               </tr> <tr> <td>0</td> <td>The parameter is a direct child of the ASX node.</td> </tr> <tr> <td>&gt; 0</td>
    ///               <td>The parameter is located inside an ENTRY tag; <i>EntryNum</i> specifies the entry, indexed from 1.</td>
    ///               </tr> </table>
    ///    Index = Specifies the index of the parameter to retrieve, indexed from 1.
    ///    pbstrName = Pointer to a variable that receives the parameter name.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_MediaParameterName(int EntryNum, int Index, BSTR* pbstrName);
    ///The <code>get_PlaylistCount</code> method retrieves the number of entries in an ASX file. This interface is not
    ///supported.
    ///Params:
    ///    pNumberEntries = Pointer to a variable that receives the number of entries.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_PlaylistCount(int* pNumberEntries);
}

///The <code>IAMNetShowPreroll</code> interface sets and retrieves the preroll settings for the legacy Windows Media
///Player 6.4 source filter. The Windows Media Source filter implements this interface. The filter's default preroll
///time is five seconds.
interface IAMNetShowPreroll : IDispatch
{
    ///The <code>put_Preroll</code> method specifies whether the filter should start prerolling.
    ///Params:
    ///    fPreroll = Specifies one of the following values: <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///               <td>VARIANT_TRUE</td> <td>Begin prerolling.</td> </tr> <tr> <td>VARIANT_FALSE</td> <td>Stop prerolling.</td>
    ///               </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_Preroll(short fPreroll);
    ///The <code>get_Preroll</code> method queries whether the filter is currently prerolling.
    ///Params:
    ///    pfPreroll = Pointer to a variable that receives a Boolean value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_Preroll(short* pfPreroll);
}

///The <b>IDShowPlugin</b> interface enables the Windows Media Source filter to communicate with the Windows Media
///Player 6.4 Plug-in for Netscape Navigator. If Windows Media Player 6.4 is hosted in the Netscape Navigator browser,
///the Windows Media Source filter uses this interface to retrieve the URL and the User-Agent heading. This interface is
///not used when the player is hosted as an ActiveX control in Microsoft Internet Explorer. Applications cannot access
///this interface. It is documented here for completeness, because it is defined in the header file Qnetwork.h.
interface IDShowPlugin : IUnknown
{
    ///The <b>get_URL</b> method retrieves the URL of the current web page.
    ///Params:
    ///    pURL = Receives the URL.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_URL(BSTR* pURL);
    ///The <code>get_UserAgent</code> method retrieves the User-Agent field from the HTTP header.
    ///Params:
    ///    pUserAgent = Pointer to a variable that receives the User-Agent string.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_UserAgent(BSTR* pUserAgent);
}

///The <code>IAMDirectSound</code> interface specifies which window has focus for controlling DirectSound audio
///playback. DirectShow provides limited support for this interface: <ul> <li>The DirectSound Renderer implements the
///<b>GetFocusWindow</b> and <b>SetFocusWindow</b> methods. It does not implement the other methods on the
///interface.</li> <li>The Audio Renderer (WaveOut) exposes the interface but does not implement any of its
///methods.</li> </ul>
interface IAMDirectSound : IUnknown
{
    ///The <code>GetDirectSoundInterface</code> method is not implemented.
    ///Params:
    ///    lplpds = 
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT GetDirectSoundInterface(IDirectSound* lplpds);
    ///The <code>GetPrimaryBufferInterface</code> method is not implemented.
    ///Params:
    ///    lplpdsb = 
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT GetPrimaryBufferInterface(IDirectSoundBuffer* lplpdsb);
    ///The <code>GetSecondaryBufferInterface</code> method is not implemented.
    ///Params:
    ///    lplpdsb = 
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT GetSecondaryBufferInterface(IDirectSoundBuffer* lplpdsb);
    ///The <code>ReleaseDirectSoundInterface</code> method is not implemented.
    ///Params:
    ///    lpds = 
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT ReleaseDirectSoundInterface(IDirectSound lpds);
    ///The <code>ReleasePrimaryBufferInterface</code> method is not implemented.
    ///Params:
    ///    lpdsb = 
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT ReleasePrimaryBufferInterface(IDirectSoundBuffer lpdsb);
    ///The <code>ReleaseSecondaryBufferInterface</code> method is not implemented.
    ///Params:
    ///    lpdsb = 
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT ReleaseSecondaryBufferInterface(IDirectSoundBuffer lpdsb);
    ///The <code>SetFocusWindow</code> method specifies a window to handle sound playback.
    ///Params:
    ///    arg1 = Specifies a handle to the window. If this value is <b>NULL</b>, the sound will not be associated with any
    ///           window.
    ///    arg2 = Specifies whether to mix the sound when the window loses focus. <table> <tr> <th>Value </th> <th>Description
    ///           </th> </tr> <tr> <td><b>TRUE</b></td> <td>The sound is audible when the window loses focus.</td> </tr> <tr>
    ///           <td><b>FALSE</b></td> <td>The sound is not audible when the window loses focus.</td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetFocusWindow(HWND param0, BOOL param1);
    ///The <code>GetFocusWindow</code> method retrieves the window that is handling sound playback.
    ///Params:
    ///    arg1 = Pointer to a variable that receives a handle to the window. If sound playback is not associated with a
    ///           window, the returned value is <b>NULL</b>.
    ///    arg2 = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///           </th> </tr> <tr> <td><b>TRUE</b></td> <td>The sound is audible when the window loses focus.</td> </tr> <tr>
    ///           <td><b>FALSE</b></td> <td>The sound is not audible when the window loses focus.</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetFocusWindow(HWND* param0, int* param1);
}

///The <code>IAMLine21Decoder</code> interface sets and retrieves information about closed captions. The Line 21 Decoder
///filter exposes this interface. Applications can use this interface to enable or disable closed captions, select the
///closed captioning service, and set other closed captioning properties. Closed-captioned information is transmitted on
///line 21 of field 1 in the vertical blanking interval (VBI) of television signals. Video cassette recorders record
///this information on video tape, and you can use the Line21 Decoder and other DirectShow filters to capture the line
///21 data and save it on disk in a media file format such as Audio-Video Interleaved (AVI). The closed-captioned
///information appears as a separate stream within the media file. Closed-captioned text is used in television
///programming and DVD movies. DVD movies contain line 21 data as part of the user data section of each Group of
///Pictures (GOP) in the video stream. Television receiver cards with Windows Driver Model (WDM) drivers provide line 21
///data.
interface IAMLine21Decoder : IUnknown
{
    ///The <code>GetDecoderLevel</code> method retrieves the closed-captioned decoder level.
    ///Params:
    ///    lpLevel = Pointer to a variable that receives a member of the AM_LINE21_CCLEVEL enumeration. The returned value is
    ///              always <b>AM_L21_CCLEVEL_TC2</b> (TeleCaption II).
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetDecoderLevel(AM_LINE21_CCLEVEL* lpLevel);
    ///The <code>GetCurrentService</code> method retrieves the current closed captioning service.
    ///Params:
    ///    lpService = Pointer to a variable that receives a member of the AM_LINE21_CCSERVICE enumeration. The default service is
    ///                CC1.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetCurrentService(AM_LINE21_CCSERVICE* lpService);
    ///The <code>SetCurrentService</code> method sets the closed captioning service.
    ///Params:
    ///    Service = Member of the AM_LINE21_CCSERVICE enumeration that specifies the closed captioning service. The default
    ///              service is CC1.
    ///Returns:
    ///    <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>E_INVALIDARG</td> <td>Invalid argument</td>
    ///    </tr> <tr> <td>E_NOTIMPL</td> <td>The requested service is not implemented.</td> </tr> <tr> <td>S_OK</td>
    ///    <td>Success</td> </tr> </table>
    ///    
    HRESULT SetCurrentService(AM_LINE21_CCSERVICE Service);
    ///The <code>GetServiceState</code> method indicates whether closed captioning is on or off.
    ///Params:
    ///    lpState = Pointer to a variable that receives a member of the AM_LINE21_CCSTATE enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetServiceState(AM_LINE21_CCSTATE* lpState);
    ///The <code>SetServiceState</code> method enables or disables closed captions.
    ///Params:
    ///    State = Member of the AM_LINE21_CCSTATE enumeration, specify whether to enable or disable closed captions.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT SetServiceState(AM_LINE21_CCSTATE State);
    ///The <code>GetOutputFormat</code> method retrieves the Line 21 Decoder filter's output format.
    ///Params:
    ///    lpbmih = Pointer to a caller-allocated BITMAPINFOHEADER structure.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> The output format has not been set. </td> </tr> </table>
    ///    
    HRESULT GetOutputFormat(BITMAPINFOHEADER* lpbmih);
    ///The <code>SetOutputFormat</code> method sets the Line 21 Decoder filter's output format. This method is currently
    ///not implemented.
    ///Params:
    ///    lpbmi = Pointer to a <b>BITMAPINFO</b> structure that describes the output format.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT SetOutputFormat(BITMAPINFO* lpbmi);
    ///The <code>GetBackgroundColor</code> method retrieves the background color used by the Line 21 Decoder filter for
    ///overlay. The default background color is magenta.
    ///Params:
    ///    pdwPhysColor = Pointer to a variable that receives the background color as a pixel color value. The meaning of the pixel
    ///                   value is defined by the bit depth of the filter's current output format.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetBackgroundColor(uint* pdwPhysColor);
    ///The <code>SetBackgroundColor</code> method sets the background color that the Line 21 Decoder filter uses for
    ///overlay. The default background color is magenta. Generally, applications should not call this method. The
    ///background color must match the overlay color key, which is defined by the downstream rendering filter.
    ///Params:
    ///    dwPhysColor = Sets the background color as a pixel color value. The meaning of the pixel value is defined by the bit depth
    ///                  of the filter's current output format.
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT SetBackgroundColor(uint dwPhysColor);
    ///The <code>GetRedrawAlways</code> method indicates whether the Line 21 Decoder filter redraws the entire output
    ///bitmap for each sample.
    ///Params:
    ///    lpbOption = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///                </th> </tr> <tr> <td><b>TRUE</b></td> <td>The filter always redraws the entire bitmap.</td> </tr> <tr>
    ///                <td><b>FALSE</b></td> <td>The filter does not always redraw the entire bitmap. (Default)</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetRedrawAlways(int* lpbOption);
    ///The <code>SetRedrawAlways</code> method specifies whether the Line 21 Decoder filter redraws the entire output
    ///bitmap for each sample.
    ///Params:
    ///    bOption = Specifies one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///              <td><b>TRUE</b></td> <td>The filter always redraws the entire bitmap.</td> </tr> <tr> <td><b>FALSE</b></td>
    ///              <td>The filter does not always redraw the entire bitmap. (Default)</td> </tr> </table>
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT SetRedrawAlways(BOOL bOption);
    ///The <code>GetDrawBackgroundMode</code> method indicates whether the Line 21 Decoder filter draws the captions on
    ///a transparent background or an opaque background. By default, the caption background is opaque.
    ///Params:
    ///    lpMode = Pointer a variable that receives a member of the AM_LINE21_DRAWBGMODE enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetDrawBackgroundMode(AM_LINE21_DRAWBGMODE* lpMode);
    ///The <code>SetDrawBackgroundMode</code> method specifies whether the Line 21 Decoder filter draws the captions on
    ///a transparent background or an opaque background. By default, the caption background is opaque.
    ///Params:
    ///    Mode = Specifies a member of the AM_LINE21_DRAWBGMODE enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT SetDrawBackgroundMode(AM_LINE21_DRAWBGMODE Mode);
}

///The <code>IAMParse</code> interface sets and retrieves the <i>parse time</i> for an MPEG-2 stream. The parse time is
///a notional time associated with the current position in the stream of bytes supplied to the parser filter. This time
///is also tied to the origin of the time stamps in that time stamp zero corresponds to parse time zero. The MPEG-2
///Splitter filter implements this interface. Use this interface to retrieve or set the current stream parse time or to
///clear the data buffer of its current data.
interface IAMParse : IUnknown
{
    ///The <code>GetParseTime</code> method retrieves the current stream parse time. For MPEG-2, this corresponds to the
    ///system clock time computed for the current stream position.
    ///Params:
    ///    prtCurrent = Pointer to the current parse time.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The parse time is not available, because the input pin is not connected </td> </tr> </table>
    ///    
    HRESULT GetParseTime(long* prtCurrent);
    ///The <code>SetParseTime</code> method sets the current stream parse time. For MPEG-2, this corresponds to the
    ///system clock time computed for the current stream position.
    ///Params:
    ///    rtCurrent = Current stream parse time.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The parse time is not available, because the input pin is not connected </td> </tr> </table>
    ///    
    HRESULT SetParseTime(long rtCurrent);
    ///The <code>Flush</code> method clears the current file data to allow for a more rapid switch to a new file.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT Flush();
}

@GUID("56A868B9-0AD4-11CE-B03A-0020AF0BA770")
interface IAMCollection : IDispatch
{
    HRESULT get_Count(int* plCount);
    HRESULT Item(int lItem, IUnknown* ppUnk);
    HRESULT get__NewEnum(IUnknown* ppUnk);
}

///The <code>IMediaControl</code> interface provides methods for controlling the flow of data through the filter graph.
///It includes methods for running, pausing, and stopping the graph. The Filter Graph Manager implements this interface.
///For more information on filter graph states, see Data Flow in the Filter Graph.
@GUID("56A868B1-0AD4-11CE-B03A-0020AF0BA770")
interface IMediaControl : IDispatch
{
    ///The <code>Run</code> method runs all the filters in the filter graph. While the graph is running, data moves
    ///through the graph and is rendered.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    The graph is preparing to run, but some filters have not completed the transition to a running state. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> All filters in the graph
    ///    completed the transition to a running state. </td> </tr> </table>
    ///    
    HRESULT Run();
    ///The <code>Pause</code> method pauses all the filters in the filter graph.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    The graph paused successfully, but some filters have not completed the state transition. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> All filters in the graph completed the
    ///    transition to a paused state. </td> </tr> </table>
    ///    
    HRESULT Pause();
    ///The <code>Stop</code> method stops all the filters in the graph.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> value that indicates the cause of the error.
    ///    
    HRESULT Stop();
    ///The <code>GetState</code> method retrieves the state of the filter graph—paused, running, or stopped. State
    ///transitions are not necessarily synchronous. Therefore, when you call this method, the filter graph might be in
    ///transition to a new state. In that case, the method blocks until the transition completes or until the specified
    ///time-out elapses.
    ///Params:
    ///    msTimeout = Duration of the time-out, in milliseconds, or INFINITE to specify an infinite time-out.
    ///    pfs = Receives a member of the [FILTER_STATE](/windows/desktop/api/strmif/ne-strmif-filter_state) enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_S_STATE_INTERMEDIATE</b></dt> </dl> </td> <td
    ///    width="60%"> The filter graph is still in transition to the indicated state. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_S_CANT_CUE</b></dt> </dl> </td> <td width="60%"> The filter graph is paused, but
    ///    cannot cue data. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> </table>
    ///    
    HRESULT GetState(int msTimeout, int* pfs);
    ///The <code>RenderFile</code> method builds a filter graph that renders the specified file. This method is intended
    ///for use by Visual Basic 6.0 applications. It was documented for Visual Basic 6.0 as the
    ///<b>FilgraphManager.RenderFile</b> method. C++ applications should use the IGraphBuilder::RenderFile method
    ///instead.
    ///Params:
    ///    strFilename = Specifies the name of the file to load.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RenderFile(BSTR strFilename);
    ///The <code>AddSourceFilter</code> method adds a source filter to the filter graph. This method is intended for use
    ///by Visual Basic 6.0 applications. It was documented for Visual Basic 6.0 as the
    ///<b>FilgraphManager.AddSourceFilter</b> method. C++ applications should use the IGraphBuilder::AddSourceFilter
    ///method instead.
    ///Params:
    ///    strFilename = Specifies the name of the file to load.
    ///    ppUnk = Receives a pointer to the <b>IDispatch</b> interface. The caller must release the interface. You can query
    ///            the returned pointer for the <b>IFilterInfo</b> interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddSourceFilter(BSTR strFilename, IDispatch* ppUnk);
    ///The <code>get_FilterCollection</code> method retrieves a collection of the filters in the filter graph. This
    ///method is intended for use by Visual Basic 6.0 applications. It was documented for Visual Basic 6.0 as the
    ///<b>FilgraphManager.FilterCollection</b> property. C++ applications should use the IFilterGraph::EnumFilters
    ///method instead.
    ///Params:
    ///    ppUnk = Receives a pointer to the <b>IDispatch</b> interface. The caller must release the interface. You can query
    ///            the returned pointer for the <b>IAMCollection</b> interface. The collection contains a list of
    ///            <b>IFilterInfo</b> pointers.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_FilterCollection(IDispatch* ppUnk);
    ///The <code>get_RegFilterCollection</code> method retrieves a collection of all the filters listed in the registry.
    ///This method is intended for use by Visual Basic 6.0 applications. It was documented for Visual Basic 6.0 as the
    ///<b>FilgraphManager.RegFilterCollection</b> property. C++ applications should use the
    ///IFilterMapper2::EnumMatchingFilters method instead.
    ///Params:
    ///    ppUnk = Receives a pointer to the <b>IDispatch</b> interface. The caller must release the interface. You can query
    ///            the returned pointer for the <b>IAMCollection</b> interface. The collection contains a list of
    ///            <b>IRegFilterInfo</b> pointers.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_RegFilterCollection(IDispatch* ppUnk);
    ///The <code>StopWhenReady</code> method pauses the filter graph, allowing filters to queue data, and then stops the
    ///filter graph.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The
    ///    graph was still transitioning to the paused state when the method returned. </td> </tr> </table>
    ///    
    HRESULT StopWhenReady();
}

///The <code>IMediaEvent</code> interface contains methods for retrieving event notifications and for overriding the
///Filter Graph Manager's default handling of events. The IMediaEventEx interface inherits this interface and extends
///it. The Filter Graph Manager implements this interface. Applications can use it to respond to events that occur in
///the filter graph, such as the end of a stream or a rendering error. Filters post events to the filter graph using the
///IMediaEventSink interface. For more information about event notification, see Event Notification in DirectShow. For a
///list of system-defined event notifications, see Event Notification Codes.
@GUID("56A868B6-0AD4-11CE-B03A-0020AF0BA770")
interface IMediaEvent : IDispatch
{
    ///The <code>GetEventHandle</code> method retrieves a handle to a manual-reset event that remains signaled while the
    ///queue contains event notifications.
    ///Params:
    ///    hEvent = Pointer to a variable that receives the event handle.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT GetEventHandle(ptrdiff_t* hEvent);
    ///The <code>GetEvent</code> method retrieves the next event notification from the event queue.
    ///Params:
    ///    lEventCode = Pointer to a variable that receives the event code.
    ///    lParam1 = Pointer to a variable that receives the first event parameter.
    ///    lParam2 = Pointer to a variable that receives the second event parameter.
    ///    msTimeout = Time-out interval, in milliseconds. Use INFINITE to block until there is an event.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td
    ///    width="60%"> Timeout expired. </td> </tr> </table>
    ///    
    HRESULT GetEvent(int* lEventCode, ptrdiff_t* lParam1, ptrdiff_t* lParam2, int msTimeout);
    ///The <code>WaitForCompletion</code> method waits for the filter graph to render all available data. The filter
    ///graph must be running or the method fails.
    ///Params:
    ///    msTimeout = Time-out interval, in milliseconds. Pass zero to return immediately. Pass the value INFINITE to block
    ///                indefinitely.
    ///    pEvCode = Pointer to a variable that receives an event code. See Remarks for more information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%"> Time-out
    ///    expired. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td
    ///    width="60%"> The filter graph is not running. </td> </tr> </table>
    ///    
    HRESULT WaitForCompletion(int msTimeout, int* pEvCode);
    ///The <code>CancelDefaultHandling</code> method cancels the Filter Graph Manager's default handling for a specified
    ///event. The event notification is passed to the application.
    ///Params:
    ///    lEvCode = Event code for which to cancel default handling.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those shown in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> No default handling for this event. </td> </tr> </table>
    ///    
    HRESULT CancelDefaultHandling(int lEvCode);
    ///The <code>RestoreDefaultHandling</code> method restores the Filter Graph Manager's default handling for a
    ///specified event.
    ///Params:
    ///    lEvCode = Event code for which to restore default handling.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> No
    ///    default handling for this event. </td> </tr> </table>
    ///    
    HRESULT RestoreDefaultHandling(int lEvCode);
    ///The <code>FreeEventParams</code> method frees resources associated with the parameters of an event.
    ///Params:
    ///    lEvCode = Event code.
    ///    lParam1 = First event parameter.
    ///    lParam2 = Second event parameter.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT FreeEventParams(int lEvCode, ptrdiff_t lParam1, ptrdiff_t lParam2);
}

///The <b>IMediaEventEx</b> interface inherits the IMediaEvent interface, which contains methods for retrieving event
///notifications and for overriding the filter graph's default handling of events. <b>IMediaEventEx</b> adds methods
///that enable an application window to receive messages when events occur. The Filter Graph Manager implements this
///interface. For more information about event notification, see Event Notification in DirectShow. For a list of
///system-defined event notifications, see Event Notification Codes.
@GUID("56A868C0-0AD4-11CE-B03A-0020AF0BA770")
interface IMediaEventEx : IMediaEvent
{
    ///The <code>SetNotifyWindow</code> method registers a window to process event notifications.
    ///Params:
    ///    hwnd = Handle to the window, or <b>NULL</b> to stop receiving event messages.
    ///    lMsg = Window message to be passed as the notification.
    ///    lInstanceData = Value to be passed as the <i>lParam</i> parameter for the <i>lMsg</i> message.
    ///Returns:
    ///    Returns S_OK if successful or E_INVALIDARG if the <i>hwnd</i> parameter is not a valid handle to a window.
    ///    
    HRESULT SetNotifyWindow(ptrdiff_t hwnd, int lMsg, ptrdiff_t lInstanceData);
    ///The <code>SetNotifyFlags</code> method enables or disables event notifications.
    ///Params:
    ///    lNoNotifyFlags = Value indicating whether to enable or disable event notifications. Must be one of the following values:
    ///                     <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>Zero</td> <td>Enable event
    ///                     notifications.</td> </tr> <tr> <td>AM_MEDIAEVENT_NONOTIFY</td> <td>Disable event notifications.</td> </tr>
    ///                     </table>
    ///Returns:
    ///    Returns S_OK if successful, or E_INVALIDARG if the <i>lNoNotifyFlags</i> parameter is invalid.
    ///    
    HRESULT SetNotifyFlags(int lNoNotifyFlags);
    ///The <code>GetNotifyFlags</code> method determines whether event notifications are enabled.
    ///Params:
    ///    lplNoNotifyFlags = Pointer to a variable that receives one of the following values: <table> <tr> <th>Value </th> <th>Description
    ///                       </th> </tr> <tr> <td>Zero</td> <td>Event notifications are enabled.</td> </tr> <tr>
    ///                       <td>AM_MEDIAEVENT_NONOTIFY</td> <td>Event notifications are disabled.</td> </tr> </table>
    ///Returns:
    ///    Returns S_OK if successful, or E_POINTER if the <i>lplNoNotifyFlags</i> parameter is <b>NULL</b>.
    ///    
    HRESULT GetNotifyFlags(int* lplNoNotifyFlags);
}

///The <b>IMediaPosition</b> interface contains methods for seeking to a position within a stream. <div
///class="alert"><b>Note</b> Applications should use IMediaSeeking instead of <b>IMediaPosition</b>. </div> <div> </div>
///This interface is exposed by the Filter Graph Manager as well as by individual filters. Applications should obtain an
///<b>IMediaPosition</b> interface pointer from the Filter Graph Manager, not from a filter. The Filter Graph Manager
///distributes method calls to all of the renderer filters. The renderer filters propagate the calls upstream to the
///source filters. This sequence of events ensures that all streams remain synchronized. If one of the distributed calls
///returns an error, the Filter Graph Manager returns the first error value it received. Some of the distributed calls
///may have succeeded in this case. However, the filter graph does not return <b>E_NOTIMPL</b> unless all the
///distributed calls return <b>E_NOTIMPL</b>. If at least one filter in the graph implements the method, the Filter
///Graph Manager does not return <b>E_NOTIMPL</b>.
@GUID("56A868B2-0AD4-11CE-B03A-0020AF0BA770")
interface IMediaPosition : IDispatch
{
    ///The <code>get_Duration</code> method retrieves the duration of the stream.
    ///Params:
    ///    plength = Pointer to a variable that receives the total stream length, in seconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Duration(double* plength);
    ///The <code>put_CurrentPosition</code> method sets the current position, relative to the total duration of the
    ///stream.
    ///Params:
    ///    llTime = New position, in seconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Graph was paused and is in transition back to a running state. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td> </tr> </table>
    ///    
    HRESULT put_CurrentPosition(double llTime);
    ///The <code>get_CurrentPosition</code> method retrieves the current position, relative to the total duration of the
    ///stream.
    ///Params:
    ///    pllTime = Pointer to a variable that receives the current position, in seconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_CurrentPosition(double* pllTime);
    ///The <code>get_StopTime</code> method retrieves the time at which the playback will stop, relative to the duration
    ///of the stream.
    ///Params:
    ///    pllTime = Pointer to a variable that receives the stop time, in seconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_StopTime(double* pllTime);
    ///The <code>put_StopTime</code> method sets the time at which the playback will stop, relative to the duration of
    ///the stream.
    ///Params:
    ///    llTime = Stop time, in seconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> </table>
    ///    
    HRESULT put_StopTime(double llTime);
    ///The <code>get_PrerollTime</code> method retrieves the amount of data that will be queued before the start
    ///position.
    ///Params:
    ///    pllTime = Pointer to a variable that receives the preroll time, in seconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_PrerollTime(double* pllTime);
    ///The <b>put_PrerollTime</b> method sets the amount of data that will be queued before the start position.
    ///Params:
    ///    llTime = Preroll time, in seconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> </table>
    ///    
    HRESULT put_PrerollTime(double llTime);
    ///The put_Rate method sets the playback rate.
    ///Params:
    ///    dRate = Playback rate. Must not be zero.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> </table>
    ///    
    HRESULT put_Rate(double dRate);
    ///The <code>get_Rate</code> method retrieves the playback rate.
    ///Params:
    ///    pdRate = Pointer to a variable that receives the playback rate.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Rate(double* pdRate);
    ///The <code>CanSeekForward</code> method determines whether the filter graph can seek forward in the stream.
    ///Params:
    ///    pCanSeekForward = Pointer to a variable that receives the value OATRUE if the graph can seek forward, or OAFALSE otherwise.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT CanSeekForward(int* pCanSeekForward);
    ///The <code>CanSeekBackward</code> method determines whether the filter graph can seek backward in the stream.
    ///Params:
    ///    pCanSeekBackward = Pointer to a variable that receives the value OATRUE if the graph can seek backward, or OAFALSE otherwise.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT CanSeekBackward(int* pCanSeekBackward);
}

///The <code>IBasicAudio</code> interface controls the volume and balance of the audio stream. This interface is
///implemented on the Audio Renderer (WaveOut) filter and the DirectSound Renderer filter, but is exposed to
///applications through the Filter Graph Manager. Applications should always retrieve this interface from the Filter
///Graph Manager.
@GUID("56A868B3-0AD4-11CE-B03A-0020AF0BA770")
interface IBasicAudio : IDispatch
{
    ///The <code>put_Volume</code> method sets the volume (amplitude) of the audio signal.
    ///Params:
    ///    lVolume = Specifies the volume, as a number from –10,000 to 0, inclusive. Full volume is 0, and –10,000 is silence.
    ///              Multiply the desired decibel level by 100. For example, –10,000 = –100 dB.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The
    ///    underlying audio device returned an error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The value of <i>lVolume</i> is invalid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The filter graph does not
    ///    contain an audio renderer filter. (Possibly the source does not contain an audio stream.) </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT put_Volume(int lVolume);
    ///The <code>get_Volume</code> method retrieves the volume (amplitude) of the audio signal.
    ///Params:
    ///    plVolume = Pointer to a variable that receive the volume. Divide by 100 to get equivalent decibel value. For example,
    ///               –10,000 is –100 dB.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%">
    ///    The filter graph does not contain an audio renderer filter. (Possibly the source does not contain an audio
    ///    stream.) </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_Volume(int* plVolume);
    ///The <code>put_Balance</code> method sets the balance of the audio signal.
    ///Params:
    ///    lBalance = Specifies the balance. The value can range from -10,000 to 10,000. The value -10,000 means the right channel
    ///               is attenuated by 100 dB and is effectively silent. The value 10,000 means the left channel is silent. The
    ///               neutral value is 0, which means that both channels are at full volume. When one channel is attenuated, the
    ///               other remains at full volume.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The
    ///    underlying audio device returned an error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The value of <i>lBalance</i> is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The filter graph does
    ///    not contain an audio renderer filter. (Possibly the source does not contain an audio stream.) </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT put_Balance(int lBalance);
    ///The <code>get_Balance</code> method retrieves the balance for the audio signal.
    ///Params:
    ///    plBalance = Pointer to a variable that receives the balance.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%">
    ///    The filter graph does not contain an audio renderer filter. (Possibly the source does not contain an audio
    ///    stream.) </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_Balance(int* plBalance);
}

///The <code>IVideoWindow</code> interface sets properties on the video window. Applications can use it to set the
///window owner, the position and dimensions of the window, and other properties. <div class="alert"><b>Note</b> The
///IVMRWindowlessControl or IVMRWindowlessControl9 interface is now preferred over <code>IVideoWindow</code>. For more
///information, see Using Windowless Mode.</div> <div> </div> The Video Renderer filter and the Filter Graph Manager
///both expose this interface. The Filter Graph Manager forwards all method calls to the Video Renderer. It also
///forwards certain window messages that the Video Renderer needs to receive, such as WM_DISPLAYCHANGE. Because the
///video window is usually a child of an application window, the filter would not otherwise receive these messages.
///Therefore it relies on the Filter Graph Manager to forward them. In most cases, an application should query the
///Filter Graph Manager for this interface, and not call the filter directly, because of the messaging issue just
///described. However, if the filter graph has more than one Video Renderer, the Filter Graph Manager only communicates
///with one of them, selected arbitrarily. Therefore, if your application uses multiple video windows, use the
///<code>IVideoWindow</code> interface directly on the filters. In that case, you must forward window messages to each
///Video Renderer instance, using the IVideoWindow::NotifyOwnerMessage method. To prevent the video window from
///flickering during repaints, override the default handling for the WM_ERASEBKGND message and do not erase the window.
///(For MFC applications, override <b>CWnd::OnEraseBkgnd</b> with an empty handler.) Properties set on a video renderer
///persist between successive connections and disconnections. Because this interface is Automation-compatible, all
///Boolean values are defined as OAFALSE (0) and OATRUE (–1). <b>Error codes: </b>If the video renderer filter is not
///connected to another filter, all methods return the error code VFW_E_NOT_CONNECTED. For the Filter Graph Manager's
///implementation, if the graph does not contain a video renderer filter, all methods return E_NOINTERFACE. Note that
///the Filter Graph Manager exposes the interface even when the graph does not contain a video renderer, so an
///application can query for the interface before it builds the graph. <b>Filter Developers: </b>You can use the
///CBaseVideoWindow class to help implement this interface.
@GUID("56A868B4-0AD4-11CE-B03A-0020AF0BA770")
interface IVideoWindow : IDispatch
{
    ///The <code>put_Caption</code> method sets the video window caption.
    ///Params:
    ///    strCaption = A <b>BSTR</b> that contains the caption.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT put_Caption(BSTR strCaption);
    ///The <code>get_Caption</code> method retrieves the video window caption.
    ///Params:
    ///    strCaption = Pointer to a <b>BSTR</b> that receives the caption.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_Caption(BSTR* strCaption);
    ///The <code>put_WindowStyle</code> method sets the window styles on the video window.
    ///Params:
    ///    WindowStyle = One or more flags from the GWL_STYLE value of the Windows <b>SetWindowLong</b> function.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer filter
    ///    is not connected. </td> </tr> </table>
    ///    
    HRESULT put_WindowStyle(int WindowStyle);
    ///The <code>get_WindowStyle</code> method retrieves the window styles on the video window.
    ///Params:
    ///    WindowStyle = Receives the window style flags.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_WindowStyle(int* WindowStyle);
    ///The <code>put_WindowStyleEx</code> method sets the extended window styles on the video window.
    ///Params:
    ///    WindowStyleEx = One or more flags from the GWL_EXSTYLE value of the Windows <b>SetWindowLong</b> function.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer filter
    ///    is not connected. </td> </tr> </table>
    ///    
    HRESULT put_WindowStyleEx(int WindowStyleEx);
    ///The <code>get_WindowStyleEx</code> method retrieves the extended window styles on the video window.
    ///Params:
    ///    WindowStyleEx = Receives the window style flags.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_WindowStyleEx(int* WindowStyleEx);
    ///The <code>put_AutoShow</code> method specifies whether the video renderer automatically shows the video window
    ///when it receives video data.
    ///Params:
    ///    AutoShow = Specifies whether the video renderer automatically shows the video window. Must be one of the following
    ///               values: <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>OATRUE </td> <td>If the video
    ///               renderer pauses or runs, it will automatically show the video window. (Default.)</td> </tr> <tr> <td>OAFALSE
    ///               </td> <td>The video renderer will not automatically show the video window.</td> </tr> </table>
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT put_AutoShow(int AutoShow);
    ///The <code>get_AutoShow</code> method queries whether the video renderer automatically shows the video window when
    ///it receives video data.
    ///Params:
    ///    AutoShow = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///               <td>OATRUE </td> <td>If the video renderer pauses or runs, it will automatically show the video window.</td>
    ///               </tr> <tr> <td>OAFALSE </td> <td>The video renderer will not automatically show the video window.</td> </tr>
    ///               </table>
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_AutoShow(int* AutoShow);
    ///The <code>put_WindowState</code> method shows, hides, minimizes, or maximizes the video window.
    ///Params:
    ///    WindowState = Flag that specifies how the window is to be shown. The value can be any constant defined for the
    ///                  <i>nCmdShow</i> parameter of the ShowWindow function.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer filter
    ///    is not connected. </td> </tr> </table>
    ///    
    HRESULT put_WindowState(int WindowState);
    ///The <code>get_WindowState</code> method queries whether the video window is visible, hidden, minimized, or
    ///maximized.
    ///Params:
    ///    WindowState = Receives one of the following flags: <ul> <li>SW_HIDE</li> <li>SW_MAXIMIZE</li> <li>SW_MINIMIZE</li>
    ///                  <li>SW_SHOW</li> </ul> The meanings of these flags are defined by the Windows <b>ShowWindow</b> function.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_WindowState(int* WindowState);
    ///The <code>put_BackgroundPalette</code> method specifies whether the video window realizes its palette in the
    ///background.
    ///Params:
    ///    BackgroundPalette = Specifies whether the video renderer realizes it palette in the background. Must be one of the following
    ///                        values: <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>OATRUE </td> <td>The video renderer
    ///                        realizes the palette in the background.</td> </tr> <tr> <td>OAFALSE </td> <td>The video renderer does not
    ///                        realize the palette in the background. (Default.)</td> </tr> </table>
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT put_BackgroundPalette(int BackgroundPalette);
    ///The <code>get_BackgroundPalette</code> method queries whether the video window realizes its palette in the
    ///background..
    ///Params:
    ///    pBackgroundPalette = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                         <td>OATRUE </td> <td>The video window realizes the palette in the background.</td> </tr> <tr> <td>OAFALSE
    ///                         </td> <td>The video window does not realize the palette in the background.</td> </tr> </table>
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_BackgroundPalette(int* pBackgroundPalette);
    ///The <code>put_Visible</code> method shows or hides the video window.
    ///Params:
    ///    Visible = Specifies whether to show or hide the window. Must be one of the following values: <table> <tr> <th>Value
    ///              </th> <th>Description </th> </tr> <tr> <td>OATRUE </td> <td>Show the window.</td> </tr> <tr> <td>OAFALSE
    ///              </td> <td>Hide the window.</td> </tr> </table>
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT put_Visible(int Visible);
    ///The <code>get_Visible</code> method queries whether the video window is visible.
    ///Params:
    ///    pVisible = Receives the value OATRUE if the window is visible, or OAFALSE if the window is hidden.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_Visible(int* pVisible);
    ///The <code>put_Left</code> method sets the x-coordinate of the video window.
    ///Params:
    ///    Left = The x-coordinate, in pixels.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT put_Left(int Left);
    ///The <code>get_Left</code> method retrieves the video window's x-axis coordinate.
    ///Params:
    ///    pLeft = Receives the x-axis coordinate, in pixels.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_Left(int* pLeft);
    ///The <code>put_Width</code> method specifies the width of the video window.
    ///Params:
    ///    Width = The width, in pixels.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT put_Width(int Width);
    ///The <code>get_Width</code> method retrieves the width of the video window.
    ///Params:
    ///    pWidth = Receives the width, in pixels.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_Width(int* pWidth);
    ///The <code>put_Top</code> method specifies the y-coordinate of the video window.
    ///Params:
    ///    Top = The y-coordinate, in pixels.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT put_Top(int Top);
    ///The <code>get_Top</code> method retrieves the video window's y-coordinate.
    ///Params:
    ///    pTop = Receives the y-coordinate, in pixels.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_Top(int* pTop);
    ///The <code>put_Height</code> method sets the height of the video window.
    ///Params:
    ///    Height = The height, in pixels.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT put_Height(int Height);
    ///The <code>get_Height</code> method retrieves the height of the video window.
    ///Params:
    ///    pHeight = Receives the height, in pixels.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_Height(int* pHeight);
    ///The <code>put_Owner</code> method specifies a parent window for the video window.
    ///Params:
    ///    Owner = A handle to the parent window, as an OAHWND value, or <b>NULL</b> to remove the existing parent.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer filter
    ///    is not connected. </td> </tr> </table>
    ///    
    HRESULT put_Owner(ptrdiff_t Owner);
    ///The <code>get_Owner</code> method retrieves the video window's parent window, if any.
    ///Params:
    ///    Owner = Receives a handle to the window, as an OAHWND type. If the video window has no parent, this parameter
    ///            receives the value <b>NULL</b>.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_Owner(ptrdiff_t* Owner);
    ///The <code>put_MessageDrain</code> method specifies a window to receive mouse and keyboard messages from the video
    ///window.
    ///Params:
    ///    Drain = A handle to the window, as an OAHWND value.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer filter
    ///    is not connected. </td> </tr> </table>
    ///    
    HRESULT put_MessageDrain(ptrdiff_t Drain);
    ///The <code>get_MessageDrain</code> method retrieves the window that receives mouse and keyboard messages from the
    ///video window, if any.
    ///Params:
    ///    Drain = Receives a handle to the window, as an OAHWND type. If no message drain was set, this parameter receives the
    ///            value <b>NULL</b>.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_MessageDrain(ptrdiff_t* Drain);
    ///The <code>get_BorderColor</code> method retrieves the color that appears around the edges of the destination
    ///rectangle.
    ///Params:
    ///    Color = Receives a <b>COLORREF</b> value.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_BorderColor(int* Color);
    ///The <code>put_BorderColor</code> method sets the color that appears around the edges of the destination
    ///rectangle.
    ///Params:
    ///    Color = The border color, specified as a <b>COLORREF</b> value.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer filter
    ///    is not connected. </td> </tr> </table>
    ///    
    HRESULT put_BorderColor(int Color);
    ///The <code>get_FullScreenMode</code> method queries whether the video renderer is in full-screen mode.
    ///Params:
    ///    FullScreenMode = Receives the value OATRUE if the video renderer is in full-screen mode, or OAFALSE otherwise.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This filter does not
    ///    support full-screen mode. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td>
    ///    <td width="60%"> The video renderer filter is not connected. </td> </tr> </table>
    ///    
    HRESULT get_FullScreenMode(int* FullScreenMode);
    ///The <code>put_FullScreenMode</code> method enables or disables full-screen video rendering.
    ///Params:
    ///    FullScreenMode = Boolean value that specifies whether to enable or disable full-screen mode. Must be one of the following
    ///                     values: <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>OATRUE </td> <td>Switch to
    ///                     full-screen mode.</td> </tr> <tr> <td>OAFALSE </td> <td>Disable full-screen mode. (Default.)</td> </tr>
    ///                     </table>
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Filter does not support
    ///    full-screen mode. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Already in the requested mode. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NO_FULLSCREEN</b></dt> </dl> </td>
    ///    <td width="60%"> Could not find any filter that supports full-screen mode. </td> </tr> </table>
    ///    
    HRESULT put_FullScreenMode(int FullScreenMode);
    ///The <code>SetWindowForeground</code> method places the video window at the top of the Z order.
    ///Params:
    ///    Focus = Specifies whether to give the window focus. Must be one of the following values: <table> <tr> <th>Value </th>
    ///            <th>Description </th> </tr> <tr> <td>OATRUE </td> <td>Give the window focus.</td> </tr> <tr> <td>OAFALSE
    ///            </td> <td>Do not give the window focus.</td> </tr> </table>
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT SetWindowForeground(int Focus);
    ///The <code>NotifyOwnerMessage</code> method forwards a message to the video window.
    ///Params:
    ///    hwnd = A handle to the window, as an OAHWND value.
    ///    uMsg = Specifies the message.
    ///    wParam = Message parameter.
    ///    lParam = Message parameter.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer filter
    ///    is not connected. </td> </tr> </table>
    ///    
    HRESULT NotifyOwnerMessage(ptrdiff_t hwnd, int uMsg, ptrdiff_t wParam, ptrdiff_t lParam);
    ///The <code>SetWindowPosition</code> method sets the position of the video window.
    ///Params:
    ///    Left = The x-coordinate, in pixels.
    ///    Top = The y-coordinate, in pixels.
    ///    Width = The width, in pixels.
    ///    Height = The height, in pixels.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT SetWindowPosition(int Left, int Top, int Width, int Height);
    ///The <code>GetWindowPosition</code> method retrieves the position of the video window.
    ///Params:
    ///    pLeft = Receives the x-coordinate, in pixels.
    ///    pTop = Receives the y-coordinate, in pixels.
    ///    pWidth = Receives the width of the window, in pixels.
    ///    pHeight = Receives the height of the window, in pixels.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT GetWindowPosition(int* pLeft, int* pTop, int* pWidth, int* pHeight);
    ///The <code>GetMinIdealImageSize</code> method retrieves the minimum ideal size for the video image.
    ///Params:
    ///    pWidth = Receives the minimum ideal width, in pixels.
    ///    pHeight = Receives the minimum ideal height, in pixels.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Could not retrieve a
    ///    minimum image size. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td
    ///    width="60%"> Filter is stopped. </td> </tr> </table>
    ///    
    HRESULT GetMinIdealImageSize(int* pWidth, int* pHeight);
    ///The <code>GetMaxIdealImageSize</code> method retrieves the maximum ideal image size for the video image.
    ///Params:
    ///    pWidth = Receives the maximum ideal width, in pixels.
    ///    pHeight = Receives the maximum ideal height, in pixels.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Could not retrieve a
    ///    maximum image size. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td
    ///    width="60%"> Filter is stopped. </td> </tr> </table>
    ///    
    HRESULT GetMaxIdealImageSize(int* pWidth, int* pHeight);
    ///The <code>GetRestorePosition</code> method retrieves the restored window position.
    ///Params:
    ///    pLeft = Receives the x-coordinate, in pixels.
    ///    pTop = Receives the y-coordinate, in pixels.
    ///    pWidth = Receives the width of the window, in pixels.
    ///    pHeight = Receives the height of the window, in pixels.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT GetRestorePosition(int* pLeft, int* pTop, int* pWidth, int* pHeight);
    ///The <code>HideCursor</code> method shows or hides the cursor when the mouse is positioned over the video window.
    ///Params:
    ///    HideCursor = Specifies whether to show or hide the cursor. Must be one of the following values: <table> <tr>
    ///                 <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="OATRUE"></a><a id="oatrue"></a><dl>
    ///                 <dt><b>OATRUE</b></dt> </dl> </td> <td width="60%"> Hide the cursor. </td> </tr> <tr> <td width="40%"><a
    ///                 id="OAFALSE"></a><a id="oafalse"></a><dl> <dt><b>OAFALSE</b></dt> </dl> </td> <td width="60%"> Show the
    ///                 cursor. </td> </tr> </table>
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT HideCursor(int HideCursor);
    ///The <code>IsCursorHidden</code> method queries whether the cursor is hidden.
    ///Params:
    ///    CursorHidden = Receives the value OATRUE if the cursor is hidden, or OAFALSE if the cursor is displayed.
    ///Returns:
    ///    Possible return values include the following: <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer
    ///    filter is not connected. </td> </tr> </table>
    ///    
    HRESULT IsCursorHidden(int* CursorHidden);
}

///The <code>IBasicVideo</code> interface sets video properties such as the destination and source rectangles. The Video
///Renderer filter and Video Mixing Renderer filters implement this interface, but the interface is exposed to
///applications through the Filter Graph Manager. Applications should always retrieve this interface from the Filter
///Graph Manager. The <code>IBasicVideo</code> interface manipulates the following rectangles associated with the video
///image: <ul> <li>The <i>source</i> rectangle is the portion of the original image that gets displayed.</li> <li>The
///<i>destination</i> rectangle is the portion of the video window the receives the source rectangle.</li> <li>The
///<i>video</i> rectangle is the original video image.</li> </ul> In other words, the video renderer crops the image to
///the source rectangle, and then stretches or shrinks the cropped image to the destination rectangle. All rectangle
///dimensions are given in pixels. Properties set on the Video Renderer persist between successive connections and
///disconnections. <b>Error codes</b>: If the video renderer filter is not connected to another filter, all methods
///return the error code VFW_E_NOT_CONNECTED. For the Filter Graph Manager's implementation, if the graph does not
///contain a video renderer filter, all methods return E_NOINTERFACE. Note that the Filter Graph Manager exposes the
///interface even when the graph does not contain a video renderer, so an application can query for the interface before
///it builds the graph.
@GUID("56A868B5-0AD4-11CE-B03A-0020AF0BA770")
interface IBasicVideo : IDispatch
{
    ///The <code>get_AvgTimePerFrame</code> method retrieves the average time between successive frames.
    ///Params:
    ///    pAvgTimePerFrame = Pointer to a variable of type REFTIME that receives the average frame time, in seconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_AvgTimePerFrame(double* pAvgTimePerFrame);
    ///The <code>get_BitRate</code> method retrieves the approximate bit rate of the video stream.
    ///Params:
    ///    pBitRate = Pointer to a variable that receives the approximate bit rate, in bits per second.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_BitRate(int* pBitRate);
    ///The <code>get_BitErrorRate</code> method retrieves the approximate bit error rate of the video stream
    ///Params:
    ///    pBitErrorRate = Pointer to a variable that receives the approximate number of bits per error.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_BitErrorRate(int* pBitErrorRate);
    ///The get_VideoWidth method retrieves the native width of the video.
    ///Params:
    ///    pVideoWidth = Pointer to a variable that receives the width of the video, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_VideoWidth(int* pVideoWidth);
    ///The <code>get_VideoHeight</code> method retrieves the native height of the video.
    ///Params:
    ///    pVideoHeight = Pointer to a variable that receives the height, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_VideoHeight(int* pVideoHeight);
    ///The <code>put_SourceLeft</code> method sets the x-coordinate of the source rectangle.
    ///Params:
    ///    SourceLeft = Specifies the x-coordinate, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td>
    ///    <td width="60%"> The video renderer's input pin is not connected. </td> </tr> </table>
    ///    
    HRESULT put_SourceLeft(int SourceLeft);
    ///The <code>get_SourceLeft</code> method retrieves the x-coordinate of the source rectangle.
    ///Params:
    ///    pSourceLeft = Pointer to a variable that receives the x-coordinate, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_SourceLeft(int* pSourceLeft);
    ///The <code>put_SourceWidth</code> method sets the width of the source rectangle.
    ///Params:
    ///    SourceWidth = Specifies the width, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_SourceWidth(int SourceWidth);
    ///The <code>get_SourceWidth</code> method retrieves the width of the source rectangle.
    ///Params:
    ///    pSourceWidth = Pointer to a variable that receives the width, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_SourceWidth(int* pSourceWidth);
    ///The <code>put_SourceTop</code> method sets the y-coordinate of the source rectangle.
    ///Params:
    ///    SourceTop = Specifies the y-coordinate, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td>
    ///    <td width="60%"> The video renderer's input pin is not connected. </td> </tr> </table>
    ///    
    HRESULT put_SourceTop(int SourceTop);
    ///The <code>get_SourceTop</code> method retrieves the y-coordinate of the source rectangle.
    ///Params:
    ///    pSourceTop = Pointer a variable that receives the y-coordinate, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_SourceTop(int* pSourceTop);
    ///The <code>put_SourceHeight</code> method sets the height of the source rectangle.
    ///Params:
    ///    SourceHeight = Specifies the height, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_SourceHeight(int SourceHeight);
    ///The <code>get_SourceHeight</code> method retrieves the height of the source rectangle.
    ///Params:
    ///    pSourceHeight = Pointer to a variable that receives the current height, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_SourceHeight(int* pSourceHeight);
    ///The <code>put_DestinationLeft</code> method sets the x-coordinate of the destination rectangle.
    ///Params:
    ///    DestinationLeft = Specifies the x-coordinate, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_DestinationLeft(int DestinationLeft);
    ///The <code>get_DestinationLeft</code> method retrieves the x-coordinate of the destination rectangle.
    ///Params:
    ///    pDestinationLeft = Pointer to a variable that receives the x-coordinate, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_DestinationLeft(int* pDestinationLeft);
    ///The <code>put_DestinationWidth</code> method sets the width of the destination rectangle.
    ///Params:
    ///    DestinationWidth = Specifies the width, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. <i>DestinationWidth</i> must be larger than zero. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer is
    ///    not connected. </td> </tr> </table>
    ///    
    HRESULT put_DestinationWidth(int DestinationWidth);
    ///The <code>get_DestinationWidth</code> method retrieves the width of the destination rectangle.
    ///Params:
    ///    pDestinationWidth = Pointer to a variable that receives the width, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_DestinationWidth(int* pDestinationWidth);
    ///The <code>put_DestinationTop</code> method sets the y-coordinate of the destination rectangle.
    ///Params:
    ///    DestinationTop = Specifies the y-coordinate, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_DestinationTop(int DestinationTop);
    ///The <code>get_DestinationTop</code> method retrieves the y-coordinate of the destination rectangle.
    ///Params:
    ///    pDestinationTop = Pointer to a variable that receives the y-coordinate, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_DestinationTop(int* pDestinationTop);
    ///The <code>put_DestinationHeight</code> method sets the height of the destination rectangle.
    ///Params:
    ///    DestinationHeight = Specifies the height, in pixels.
    ///Returns:
    ///    Returns an <code>HRESULT</code> value. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. <i>DestinationHeight</i> must be larger than zero. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer is
    ///    not connected. </td> </tr> </table>
    ///    
    HRESULT put_DestinationHeight(int DestinationHeight);
    ///The <code>get_DestinationHeight</code> method retrieves the height of the destination rectangle.
    ///Params:
    ///    pDestinationHeight = Pointer to a variable that receives the height, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_DestinationHeight(int* pDestinationHeight);
    ///The <code>SetSourcePosition</code> method sets the source rectangle.
    ///Params:
    ///    Left = Specifies the x-coordinate, in pixels.
    ///    Top = Specifies the y-coordinate, in pixels.
    ///    Width = Specifies the width, in pixels.
    ///    Height = Specifies the height, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetSourcePosition(int Left, int Top, int Width, int Height);
    ///The <code>GetSourcePosition</code> method retrieves the position of the source rectangle.
    ///Params:
    ///    pLeft = Pointer to a variable that receives the x-coordinate, in pixels.
    ///    pTop = Pointer to a variable that receives the y-coordinate, in pixels.
    ///    pWidth = Pointer to a variable that receives the width, in pixels.
    ///    pHeight = Pointer to a variable that receives the height, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetSourcePosition(int* pLeft, int* pTop, int* pWidth, int* pHeight);
    ///The <code>SetDefaultSourcePosition</code> method reverts to the default source rectangle. After this method is
    ///called, the video renderer uses the entire video image, without cropping.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetDefaultSourcePosition();
    ///The <code>SetDestinationPosition</code> method sets the destination rectangle.
    ///Params:
    ///    Left = Specifies the x-coordinate, in pixels.
    ///    Top = Specifies the y-coordinate, in pixels.
    ///    Width = Specifies the width, in pixels.
    ///    Height = Specifies the height, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. <i>Width</i> and <i>Height</i> must be larger than zero. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The video renderer is
    ///    not connected. </td> </tr> </table>
    ///    
    HRESULT SetDestinationPosition(int Left, int Top, int Width, int Height);
    ///The <code>GetDestinationPosition</code> method retrieves the position of the destination rectangle.
    ///Params:
    ///    pLeft = Pointer to a variable that receives the x-coordinate, in pixels.
    ///    pTop = Pointer to a variable that receives the y-coordinate, in pixels.
    ///    pWidth = Pointer to a variable that receives the width, in pixels.
    ///    pHeight = Pointer to a variable that receives the height, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetDestinationPosition(int* pLeft, int* pTop, int* pWidth, int* pHeight);
    ///The <code>SetDefaultDestinationPosition</code> method reverts to the default destination rectangle. After this
    ///method is called, the video renderer uses the entire window for playback.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetDefaultDestinationPosition();
    ///The <code>GetVideoSize</code> method retrieves the native video dimensions.
    ///Params:
    ///    pWidth = Pointer to a variable that receives the width of the video image, in pixels.
    ///    pHeight = Pointer to a variable that receives the height of the video image, in pixels.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetVideoSize(int* pWidth, int* pHeight);
    ///The <code>GetVideoPaletteEntries</code> method retrieves the palette colors for the video.
    ///Params:
    ///    StartIndex = Start index for the palette.
    ///    Entries = Number of palette entries to retrieve.
    ///    pRetrieved = Pointer to a variable that receives the number of entries returned in <i>pPallette</i>.
    ///    pPalette = Pointer to an array of PALETTEENTRY structures of size <i>Entries</i>. Cast the pointer to a long pointer
    ///               type. The method fills the array.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NO_PALETTE_AVAILABLE</b></dt> </dl> </td> <td width="60%"> No palette is available. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The Video
    ///    Renderer's input pin is not connected. </td> </tr> </table>
    ///    
    HRESULT GetVideoPaletteEntries(int StartIndex, int Entries, int* pRetrieved, int* pPalette);
    ///The <code>GetCurrentImage</code> method retrieves the current image waiting at the renderer.
    ///Params:
    ///    pBufferSize = Pointer to a variable that contains the size of the buffer that the caller is passing in. If <i>pDIBImage</i>
    ///                  is <b>NULL</b>, this parameter receives the required buffer size.
    ///    pDIBImage = Pointer to a buffer where the complete image will be stored in device-independent bitmap (DIB) format. Cast
    ///                the pointer to a long pointer type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetCurrentImage(int* pBufferSize, int* pDIBImage);
    ///The <code>IsUsingDefaultSource</code> method queries whether the renderer is using the default source rectangle.
    ///Returns:
    ///    Returns S_OK if the renderer is using the default source rectangle, or S_FALSE otherwise.
    ///    
    HRESULT IsUsingDefaultSource();
    ///The <code>IsUsingDefaultDestination</code> method queries whether the renderer is using the default destination
    ///rectangle.
    ///Returns:
    ///    Returns S_OK if the renderer is using the default destination rectangle, or S_FALSE otherwise.
    ///    
    HRESULT IsUsingDefaultDestination();
}

///The <code>IBasicVideo2</code> interface extends the IBasicVideo interface. The Video Renderer filter and Video Mixing
///Renderer filters implement this interface, but the interface is exposed to applications through the Filter Graph
///Manager. Applications should always retrieve this interface from the Filter Graph Manager.
@GUID("329BB360-F6EA-11D1-9038-00A0C9697298")
interface IBasicVideo2 : IBasicVideo
{
    ///The <code>GetPreferredAspectRatio</code> method retrieves the preferred aspect ratio.
    ///Params:
    ///    plAspectX = Pointer to a value that indicates the x-axis aspect ratio.
    ///    plAspectY = Pointer to a value that indicates the y-axis aspect ratio.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One
    ///    or both of the parameters are invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt>
    ///    </dl> </td> <td width="60%"> The renderer does not implement <b>IBasicVideo2</b>. </td> </tr> </table>
    ///    
    HRESULT GetPreferredAspectRatio(int* plAspectX, int* plAspectY);
}

///The <code>IDeferredCommand</code> interface cancels or modify graph-control commands that were queued using the
///IQueueCommand interface. When an application calls an <b>IQueueCommand</b> method on the Filter Graph Manager, it
///receives a pointer to the <code>IDeferredCommand</code> interface. The application can use the interface to cancel or
///postpone the command, or retrieve the return value from the command.
@GUID("56A868B8-0AD4-11CE-B03A-0020AF0BA770")
interface IDeferredCommand : IUnknown
{
    ///The <code>Cancel</code> method cancels a command that the application previously queued.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_ALREADY_CANCELLED</b></dt> </dl> </td> <td
    ///    width="60%"> The request was already canceled. </td> </tr> </table>
    ///    
    HRESULT Cancel();
    ///The <code>Confidence</code> method retrieves a confidence value that indicates how likely it is for the command
    ///to be invoked at the requested time. This method is not implemented and returns E_NOTIMPL.
    ///Params:
    ///    pConfidence = Receives the confidence level, on a scale of 0 to 100.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT Confidence(int* pConfidence);
    ///The <code>Postpone</code> method specifies a new invocation time for the command.
    ///Params:
    ///    newtime = New time at which to invoke the command.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_TIME_ALREADY_PASSED</b></dt> </dl> </td> <td
    ///    width="60%"> The specified time has already passed. </td> </tr> </table>
    ///    
    HRESULT Postpone(double newtime);
    ///The <code>GetHResult</code> method retrieves the return value from the invoked command.
    ///Params:
    ///    phrResult = Receives the <b>HRESULT</b> value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%"> Command
    ///    has not yet been invoked. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetHResult(int* phrResult);
}

///The <code>IQueueCommand</code> interface queues a command for processing at a designated time. The Filter Graph
///Manager exposes this interface. Applications can use it to queue graph-control commands in advance. The methods in
///<code>IQueueCommand</code> are modeled after the <b>IDispatch::InvokeAt</b> method. The application specifies an
///interface, a method on the interface, parameters to the method, and a reference time. The Filter Graph Manager queues
///this information and then invokes the method at the specified time. The requested interface must inherit
///<b>IDispatch</b> and must be exposed by the Filter Graph Manager. Examples include IMediaControl, IMediaEventEx, and
///IMediaPosition. When the command is queued, the filter graph manager returns a pointer to the IDeferredCommand
///interface. The application can use this interface to cancel or modify the command. <div class="alert"><b>Note</b> The
///two methods in <code>IQueueCommand</code> refer to stream time and presentation time, respectively. In the context of
///the Filter Graph Manager, stream time and presentation time are identical, so there is no functional difference
///between the two methods. Other objects could implement <code>IQueueCommand</code> differently. For more information
///about stream time and presentation time, see Time and Clocks in DirectShow.</div> <div> </div>
@GUID("56A868B7-0AD4-11CE-B03A-0020AF0BA770")
interface IQueueCommand : IUnknown
{
    ///The <code>InvokeAtStreamTime</code> method queues a method or property change for execution at a specified stream
    ///time (that is, presentation time relative to the current stream time offset).
    ///Params:
    ///    pCmd = Address of a variable that receives an IDeferredCommand interface pointer.
    ///    time = Time at which to invoke the command.
    ///    iid = Pointer to the interface identifier (IID) of interface.
    ///    dispidMethod = Dispatch identifier (DISPID) of a method or property on the interface. Equivalent to the <i>dispIdMember</i>
    ///                   parameter of the <b>IDispatch::Invoke</b> method.
    ///    wFlags = Flags describing the context of the call. Equivalent to the <i>wFlags</i> parameter of the
    ///             <b>IDispatch::Invoke</b> method.
    ///    cArgs = Number of arguments in <i>pDispParams</i>. Equivalent to the <b>cArgs</b> member of the <b>DISPPARAMS</b>
    ///            structure.
    ///    pDispParams = Pointer to an array that contains the arguments. Equivalent to the <b>rgvarg</b> member of the
    ///                  <b>DISPPARAMS</b> structure.
    ///    pvarResult = Pointer to a VARIANT that receives the result. Equivalent to the <i>pVarResult</i> parameter of the
    ///                 <b>IDispatch::Invoke</b> method.
    ///    puArgErr = Pointer to a variable that receives the index of the first argument that has an error. Equivalent to the
    ///               <i>puArgErr</i> parameter of the <b>IDispatch::Invoke</b> method.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT InvokeAtStreamTime(IDeferredCommand* pCmd, double time, GUID* iid, int dispidMethod, short wFlags, 
                               int cArgs, VARIANT* pDispParams, VARIANT* pvarResult, short* puArgErr);
    ///The <code>InvokeAtPresentationTime</code> method queues a method to be invoked at the specified presentation
    ///time.
    ///Params:
    ///    pCmd = Address of a variable that receives an IDeferredCommand interface pointer.
    ///    time = Time at which to invoke the command.
    ///    iid = Pointer to the interface identifier (IID) of interface.
    ///    dispidMethod = Dispatch identifier (DISPID) of a method or property on the interface. Equivalent to the <i>dispIdMember</i>
    ///                   parameter of the <b>IDispatch::Invoke</b> method.
    ///    wFlags = Flags describing the context of the call. Equivalent to the <i>wFlags</i> parameter of the
    ///             <b>IDispatch::Invoke</b> method.
    ///    cArgs = Number of arguments in <i>pDispParams</i>. Equivalent to the <b>cArgs</b> member of the <b>DISPPARAMS</b>
    ///            structure.
    ///    pDispParams = Pointer to an array that contains the arguments. Equivalent to the <b>rgvarg</b> member of the
    ///                  <b>DISPPARAMS</b> structure.
    ///    pvarResult = Pointer a VARIANT that receives the result. Equivalent to the <i>pVarResult</i> parameter of the
    ///                 <b>IDispatch::Invoke</b> method.
    ///    puArgErr = Pointer to a variable that receives the index of the first argument that has an error. Equivalent to the
    ///               <i>puArgErr</i> parameter of the <b>IDispatch::Invoke</b> method.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT InvokeAtPresentationTime(IDeferredCommand* pCmd, double time, GUID* iid, int dispidMethod, 
                                     short wFlags, int cArgs, VARIANT* pDispParams, VARIANT* pvarResult, 
                                     short* puArgErr);
}

@GUID("56A868BA-0AD4-11CE-B03A-0020AF0BA770")
interface IFilterInfo : IDispatch
{
    HRESULT FindPin(BSTR strPinID, IDispatch* ppUnk);
    HRESULT get_Name(BSTR* strName);
    HRESULT get_VendorInfo(BSTR* strVendorInfo);
    HRESULT get_Filter(IUnknown* ppUnk);
    HRESULT get_Pins(IDispatch* ppUnk);
    HRESULT get_IsFileSource(int* pbIsSource);
    HRESULT get_Filename(BSTR* pstrFilename);
    HRESULT put_Filename(BSTR strFilename);
}

@GUID("56A868BB-0AD4-11CE-B03A-0020AF0BA770")
interface IRegFilterInfo : IDispatch
{
    HRESULT get_Name(BSTR* strName);
    HRESULT Filter(IDispatch* ppUnk);
}

@GUID("56A868BC-0AD4-11CE-B03A-0020AF0BA770")
interface IMediaTypeInfo : IDispatch
{
    HRESULT get_Type(BSTR* strType);
    HRESULT get_Subtype(BSTR* strType);
}

@GUID("56A868BD-0AD4-11CE-B03A-0020AF0BA770")
interface IPinInfo : IDispatch
{
    HRESULT get_Pin(IUnknown* ppUnk);
    HRESULT get_ConnectedTo(IDispatch* ppUnk);
    HRESULT get_ConnectionMediaType(IDispatch* ppUnk);
    HRESULT get_FilterInfo(IDispatch* ppUnk);
    HRESULT get_Name(BSTR* ppUnk);
    HRESULT get_Direction(int* ppDirection);
    HRESULT get_PinID(BSTR* strPinID);
    HRESULT get_MediaTypes(IDispatch* ppUnk);
    HRESULT Connect(IUnknown pPin);
    HRESULT ConnectDirect(IUnknown pPin);
    HRESULT ConnectWithType(IUnknown pPin, IDispatch pMediaType);
    HRESULT Disconnect();
    HRESULT Render();
}

///The <code>IAMStats</code> interface retrieves performance data from the Filter Graph Manager. Filters can use this
///interface to record performance data. <b>Filter developers</b>: As with all Filter Graph Manager interfaces, a filter
///must not hold a reference count on this interface, or it will cause a circular reference count. For more information,
///see IBaseFilter::JoinFilterGraph.
@GUID("BC9BCF80-DCD2-11D2-ABF6-00A0C905F375")
interface IAMStats : IDispatch
{
    ///The <code>Reset</code> method resets all statistics to zero.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> error code.
    ///    
    HRESULT Reset();
    ///The <code>get_Count</code> method retrieves the number of statistics.
    ///Params:
    ///    plCount = Receives the number of statistics.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Count(int* plCount);
    ///The <code>GetValueByIndex</code> method retrieves a statistic, by index.
    ///Params:
    ///    lIndex = Zero-based index of the statistic.
    ///    szName = Pointer to a variable that receives the name of the statistic.
    ///    lCount = Pointer to a variable that receives the number of values that were recorded.
    ///    dLast = Pointer to a variable that receives the most recent value that was recorded.
    ///    dAverage = Pointer to a variable that receives the average value.
    ///    dStdDev = Pointer to a variable that receives the standard deviation of the values. If the count is less than two, the
    ///              standard deviation is zero.
    ///    dMin = Pointer to a variable that receives the minimum value that was recorded.
    ///    dMax = Pointer to a variable that receives the maximum value that was recorded.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Index out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetValueByIndex(int lIndex, BSTR* szName, int* lCount, double* dLast, double* dAverage, 
                            double* dStdDev, double* dMin, double* dMax);
    ///The <code>GetValueByName</code> method retrieves a statistic, by name.
    ///Params:
    ///    szName = Specifies the name of the statistic.
    ///    lIndex = Pointer to a variable that receives the index of this statistic.
    ///    lCount = Pointer to a variable that receives the number of values that were recorded.
    ///    dLast = Pointer to a variable that receives the most recent value that was recorded.
    ///    dAverage = Pointer to a variable that receives the average value.
    ///    dStdDev = Pointer to a variable that receives the standard deviation of the values. If the count is less than two, the
    ///              standard deviation is zero.
    ///    dMin = Pointer to a variable that receives the minimum value that was recorded.
    ///    dMax = Pointer to a variable that receives the maximum value that was recorded.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> No
    ///    match for this name. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetValueByName(BSTR szName, int* lIndex, int* lCount, double* dLast, double* dAverage, double* dStdDev, 
                           double* dMin, double* dMax);
    ///The <code>GetIndex</code> method retrieves the index for a named statistic, or creates a new statistic.
    ///Params:
    ///    szName = Specifies the name of the statistic.
    ///    lCreate = Specifies whether to create the statistic, if it is not defined already. If the value is <b>TRUE</b>, the
    ///              method creates a new index for the statistic when it cannot find an existing entry with that name. If the
    ///              value is <b>FALSE</b>, the method fails when the statistic does not already exist.
    ///    plIndex = Receives the index.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_NOT_FOUND)</b></dt> </dl>
    ///    </td> <td width="60%"> No match for this name. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT GetIndex(BSTR szName, int lCreate, int* plIndex);
    ///The <code>AddValue</code> method records a new value.
    ///Params:
    ///    lIndex = Specifies the index of the statistic.
    ///    dValue = Specifies the value to record.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Index out of range. </td> </tr> </table>
    ///    
    HRESULT AddValue(int lIndex, double dValue);
}

///The <b>IAMVideoAcceleratorNotify</b> interface is a callback interface used in conjunction with the
///IAMVideoAccelerator interface. It enables the video renderer filter to communicate with the video decoder when
///configuring DirectX Video Acceleration (DXVA) decoding.
@GUID("256A6A21-FBAD-11D1-82BF-00A0C9696C8F")
interface IAMVideoAcceleratorNotify : IUnknown
{
    ///The <b>GetUncompSurfacesInfo</b> method queries the decoder for the number of uncompressed surfaces to allocate
    ///and the pixel format.
    ///Params:
    ///    pGuid = Pointer to a GUID that specifies the DXVA profile in use.
    ///    pUncompBufferInfo = Pointer to a AMVAUncompBufferInfo structure. The decoder fills in this structure with the decoder's
    ///                        requirements for the minimum and maximum number of surfaces and the pixel format. To get the list of
    ///                        supported pixel formats, the decoder should call IAMVideoAccelerator::GetUncompFormatsSupported.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. <b>HRESULT</b> can
    ///    include one of the following standard constants, or other values not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetUncompSurfacesInfo(const(GUID)* pGuid, AMVAUncompBufferInfo* pUncompBufferInfo);
    ///The <b>SetUncompSurfacesInfo</b> method notifies the decoder of how many uncompressed surfaces were created.
    ///Params:
    ///    dwActualUncompSurfacesAllocated = The number of surfaces allocated.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. <b>HRESULT</b> can
    ///    include one of the following standard constants, or other values not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetUncompSurfacesInfo(uint dwActualUncompSurfacesAllocated);
    ///The <b>GetCreateVideoAcceleratorData</b> method gets information needed to create a video accelerator object.
    ///Params:
    ///    pGuid = Pointer to a GUID that specifies the DXVA profile in use.
    ///    pdwSizeMiscData = Receives the size of the data returned in <i>ppMiscData</i>, in bytes.
    ///    ppMiscData = Receives a pointer to a buffer that contains a <b>DXVA_ConnectMode</b>structure. The decoder must call
    ///                 <b>CoTaskMemAlloc</b> to allocate the memory for the structure. The caller must free the memory by calling
    ///                 <b>CoTaskMemFree</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. <b>HRESULT</b> can
    ///    include one of the following standard constants, or other values not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetCreateVideoAcceleratorData(const(GUID)* pGuid, uint* pdwSizeMiscData, void** ppMiscData);
}

///The <b>IAMVideoAccelerator</b> interface enables a video decoder filter to access DirectX Video Acceleration (DXVA)
///1.0 functionality. Applications should not call methods on this interface. The Video Mixing Renderer filter's input
///pins support this interface, and so does pin 0 on the Overlay Mixer. If a video decoder filter calls methods on this
///interface, the decoder should support the IAMVideoAcceleratorNotify interface on its output pin. For more information
///on how to use this interface, see How Decoders Use IAMVideoAccelerator.
@GUID("256A6A22-FBAD-11D1-82BF-00A0C9696C8F")
interface IAMVideoAccelerator : IUnknown
{
    ///The <b>GetVideoAcceleratorGUIDs</b> method gets a list of DirectX Video Acceleration (DXVA) profiles supported by
    ///the display driver.
    ///Params:
    ///    pdwNumGuidsSupported = On input, specifies the number of elements in the <i>pGuidsSupported</i> array. If <i>pGuidsSupported</i> is
    ///                           <b>NULL</b>, the value of <code>*pdwNumGuidsSupported</code> must be zero. On output, if
    ///                           <i>pGuidsSupported</i> is <b>NULL</b>, <i>pdwNumGuidsSupported</i> receives the number of restricted-mode
    ///                           DXVA profiles. Otherwise, <i>pdwNumGuidsSupported</i> receives the actual number of GUIDs copied to the
    ///                           <i>pGuidsSupported</i> array.
    ///    pGuidsSupported = Address of an array of GUIDs, or <b>NULL</b>. If the value is non-<b>NULL</b>, the array receives a list of
    ///                      GUIDs that specify restricted-mode DXVA profiles. These GUIDs are defined in the header file dxva.h, and are
    ///                      documented in the DXVA 1.0 specification.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. <b>HRESULT</b> can
    ///    include one of the following standard constants, or other values not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> The method is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> Invalid state. The video
    ///    renderer has not created the Direct3D or DirectDraw device. </td> </tr> </table>
    ///    
    HRESULT GetVideoAcceleratorGUIDs(uint* pdwNumGuidsSupported, char* pGuidsSupported);
    ///The <b>GetUncompFormatsSupported</b> method gets a list of uncompressed pixel formats that can be rendered using
    ///a specified DirectX Video Acceleration (DXVA) profile.
    ///Params:
    ///    pGuid = Pointer to a GUID that specifies the DXVA profile. To get a list of supported profiles, call
    ///            IAMVideoAccelerator::GetVideoAcceleratorGUIDs.
    ///    pdwNumFormatsSupported = On input, specifies the number of elements in the <i>pFormatsSupported</i> array. If <i>pFormatsSupported</i>
    ///                             is <b>NULL</b>, the value of <code>*pdwNumFormatsSupported</code> must be zero. On output, if
    ///                             <i>pFormatsSupported</i> is <b>NULL</b>, <i>pdwNumFormatsSupported</i> receives the number of supported pixel
    ///                             formats. Otherwise, <i>pdwNumFormatsSupported</i> receives the actual number of pixel formats copied to the
    ///                             <i>pFormatsSupported</i> array.
    ///    pFormatsSupported = Address of an array of <b>DDPIXELFORMAT</b> structures, or <b>NULL</b>. If the value is non-<b>NULL</b>, the
    ///                        array receives a list of pixel formats.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>DDERR_MOREDATA</b></dt> </dl> </td> <td width="60%"> The method returned fewer
    ///    formats than the total number that are supported, because the array was too small. Although this value is a
    ///    failure code, you can ignore the error if you intentionally allocated a smaller array. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetUncompFormatsSupported(const(GUID)* pGuid, uint* pdwNumFormatsSupported, char* pFormatsSupported);
    ///The <b>GetInternalMemInfo</b> method queries for the amount of scratch memory the hardware abstraction layer
    ///(HAL) will allocate for its private use.
    ///Params:
    ///    pGuid = Pointer to a GUID that specifies the DXVA profile in use.
    ///    pamvaUncompDataInfo = Pointer to an AMVAUncompDataInfo structure that specifies the size and pixel format of the uncompressed data.
    ///    pamvaInternalMemInfo = Pointer to an AMVAInternalMemInfo structure that receives the amount of scratch memory the HAL will allocate.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. <b>HRESULT</b> can
    ///    include one of the following standard constants, or other values not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetInternalMemInfo(const(GUID)* pGuid, const(AMVAUncompDataInfo)* pamvaUncompDataInfo, 
                               AMVAInternalMemInfo* pamvaInternalMemInfo);
    ///The <b>GetCompBufferInfo</b> method gets information about the compressed buffers used for DirectX Video
    ///Acceleration (DXVA) decoding.
    ///Params:
    ///    pGuid = Pointer to a GUID that specifies the DXVA profile in use.
    ///    pamvaUncompDataInfo = Pointer to an AMVAUncompDataInfo structure that specifies the size and pixel format of the uncompressed data.
    ///    pdwNumTypesCompBuffers = On input, specifies the number of elements in the <i>pamvaCompBufferInfo</i> array. If
    ///                             <i>pamvaCompBufferInfo</i> is <b>NULL</b>, the value of <code>*pdwNumTypesCompBuffers</code> must be zero. On
    ///                             output, if <i>pamvaCompBufferInfo</i> is <b>NULL</b>, <i>pdwNumTypesCompBuffers</i> receives the size of
    ///                             array to allocate. Otherwise, <i>pdwNumTypesCompBuffers</i> receives the actual number of elements copied to
    ///                             the <i>pamvaCompBufferInfo</i> array.
    ///    pamvaCompBufferInfo = Address of an array of AMVACompBufferInfo structures, or <b>NULL</b>. If the value is non-<b>NULL</b>, the
    ///                          method copies a list of <b>AMVACompBufferInfo</b> structures to this array. Each structure corresponds to one
    ///                          type of compressed data buffer used by the video accelerator. Set all of the array elements to zero before
    ///                          calling this method. Each array index corresponds to one of the DXVA surface types defined in dxva.h. The
    ///                          video accelerator will return a list of up to <b>DXVA_NUM_TYPES_COMP_BUFFERS</b>array entries. For details,
    ///                          refer to the DXVA 1.0 specification, section 3.4, "Buffer Description List." If a particular buffer type is
    ///                          not used by the DXVA profile in question, the entry at that index contains zeroes for all values.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. <b>HRESULT</b> can
    ///    include one of the following standard constants, or other values not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetCompBufferInfo(const(GUID)* pGuid, const(AMVAUncompDataInfo)* pamvaUncompDataInfo, 
                              uint* pdwNumTypesCompBuffers, char* pamvaCompBufferInfo);
    ///The <b>GetInternalCompBufferInfo</b> method gets information about the compressed buffers used for DirectX Video
    ///Acceleration (DXVA) decoding. Call this method after the decoder has connected to the video renderer's input pin.
    ///During the pin connection process, use the IAMVideoAccelerator::GetCompBufferInfo method instead.
    ///Params:
    ///    pdwNumTypesCompBuffers = On input, specifies the number of elements in the <i>pamvaCompBufferInfo</i> array. If
    ///                             <i>pamvaCompBufferInfo</i> is <b>NULL</b>, the value of <code>*pdwNumTypesCompBuffers</code> must be zero. On
    ///                             output, if <i>pamvaCompBufferInfo</i> is <b>NULL</b>, <i>pdwNumTypesCompBuffers</i> receives the size of
    ///                             array to allocate. Otherwise, <i>pdwNumTypesCompBuffers</i> receives the actual number of elements copied to
    ///                             the <i>pamvaCompBufferInfo</i> array.
    ///    pamvaCompBufferInfo = Address of an array of AMVACompBufferInfo structures, or <b>NULL</b>. If the value is non-<b>NULL</b>, the
    ///                          method copies a list of <b>AMVACompBufferInfo</b> structures to this array. Each structure corresponds to one
    ///                          type of compressed data buffer used by the video accelerator. Set all of the array elements to zero before
    ///                          calling this method. Each array index corresponds to one of the DXVA surface types defined in dxva.h. The
    ///                          video accelerator will return a list of up to <b>DXVA_NUM_TYPES_COMP_BUFFERS</b>array entries. For details,
    ///                          refer to the DXVA 1.0 specification, section 3.4, "Buffer Description List." If a particular buffer type is
    ///                          not used by the DXVA profile in question, the entry at that index contains zeroes for all values.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. <b>HRESULT</b> can
    ///    include one of the following standard constants, or other values not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_INVALIDSUBTYPE</b></dt> </dl> </td> <td width="60%"> The decoder did not use a
    ///    DXVA decoding type when it connected to the video renderer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pins on the decoder and video renderer
    ///    filters are not connected. </td> </tr> </table>
    ///    
    HRESULT GetInternalCompBufferInfo(uint* pdwNumTypesCompBuffers, char* pamvaCompBufferInfo);
    ///The <b>BeginFrame</b> method begins the processing to create a decoded picture.
    ///Params:
    ///    amvaBeginFrameInfo = Pointer to an AMVABeginFrameInfo structure that contains information needed to begin processing the frame.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. <b>HRESULT</b> can
    ///    include one of the following standard constants, or other values not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PENDING </b></dt> </dl>
    ///    </td> <td width="60%"> The uncompressed surface is not yet available for use. For example, it is being read
    ///    for display. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_INVALIDSUBTYPE</b></dt> </dl> </td>
    ///    <td width="60%"> The decoder did not use a DXVA decoding type when it connected to the video renderer. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pins on
    ///    the decoder and video renderer filters are not connected. </td> </tr> </table>
    ///    
    HRESULT BeginFrame(const(AMVABeginFrameInfo)* amvaBeginFrameInfo);
    ///The <b>EndFrame</b> method ends frame processing.
    ///Params:
    ///    pEndFrameInfo = Pointer to an AMVAEndFrameInfo structure.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. <b>HRESULT</b> can
    ///    include one of the following standard constants, or other values not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_INVALIDSUBTYPE</b></dt> </dl> </td> <td width="60%"> The decoder did not use a
    ///    DXVA decoding type when it connected to the video renderer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pins on the decoder and video renderer
    ///    filters are not connected. </td> </tr> </table>
    ///    
    HRESULT EndFrame(const(AMVAEndFrameInfo)* pEndFrameInfo);
    ///The <b>GetBuffer</b> method gets a pointer to a compressed or uncompressed surface that was allocated for DirectX
    ///Video Acceleration (DXVA) decoding.
    ///Params:
    ///    dwTypeIndex = Specifies the surface type: <ul> <li>To get a pointer to a compressed surface, specify one of the DXVA
    ///                  surface types defined in dxva.h. </li> <li>To get a pointer to an uncompressed output surface, set this
    ///                  parameter to 0xFFFFFFFF. </li> </ul> The value 0xFFFFFFFF is valid only between calls to
    ///                  IAMVideoAccelerator::BeginFrame and IAMVideoAccelerator::EndFrame.
    ///    dwBufferIndex = The zero-based index of the surface, within the pool of surfaces that were allocated for the specified
    ///                    surface type. <ul> <li>Compressed surfaces: To get the number of allocated surfaces for each surface type,
    ///                    call IAMVideoAccelerator::GetInternalCompBufferInfo.</li> <li>Uncompressed surfaces: The buffer index must
    ///                    equal the <b>dwDestSurfaceIndex</b> member of the AMVABeginFrameInfo structure that was passed to the most
    ///                    recent IAMVideoAccelerator::BeginFrame call.</li> </ul>
    ///    bReadOnly = Specifies whether the decoder will write to the surface memory. For read-only access, specify <b>TRUE</b>.
    ///                This might allow faster access to reference frames that are currently in use.
    ///    ppBuffer = Receives a pointer to the surface memory. To get the size of the buffer in bytes, call the
    ///               IAMVideoAccelerator::GetInternalCompBufferInfo method. The size is given in the <b>dwBytesToAllocate</b>
    ///               member of the AMVACompBufferInfo structure that corresponds to <i>dwTypeIndex</i>.
    ///    lpStride = Receives the surface stride, in bytes.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. <b>HRESULT</b> can
    ///    include one of the following standard constants, or other values not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_INVALIDSUBTYPE</b></dt> </dl> </td> <td width="60%"> The decoder did not use a
    ///    DXVA decoding type when it connected to the video renderer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pins on the decoder and video renderer
    ///    filters are not connected. </td> </tr> </table>
    ///    
    HRESULT GetBuffer(uint dwTypeIndex, uint dwBufferIndex, BOOL bReadOnly, void** ppBuffer, int* lpStride);
    ///The <b>ReleaseBuffer</b> method releases a buffer that was locked by a previous call to
    ///IAMVideoAccelerator::GetBuffer.
    ///Params:
    ///    dwTypeIndex = The surface type of the buffer. Use the same value that was passed to the <i>dwTypeIndex</i> parameter of the
    ///                  GetBuffer method.
    ///    dwBufferIndex = The zero-based index of the buffer. Use the same value that was passed to the <i>dwBufferIndex</i> parameter
    ///                    of the GetBuffer method.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. <b>HRESULT</b> can
    ///    include one of the following standard constants, or other values not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_INVALIDSUBTYPE</b></dt> </dl> </td> <td width="60%"> The decoder did not use a
    ///    DXVA decoding type when it connected to the video renderer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pins on the decoder and video renderer
    ///    filters are not connected. </td> </tr> </table>
    ///    
    HRESULT ReleaseBuffer(uint dwTypeIndex, uint dwBufferIndex);
    ///The <b>Execute</b> method performs a DirectX Video Acceleration (DXVA) decoding operation.
    ///Params:
    ///    dwFunction = Contains one or more DXVA function numbers.
    ///    lpPrivateInputData = Pointer to input data for the decoding operation. The meaning of this data depends on the surface type and
    ///                         function number. For details, refer to the DXVA 1.0 specification.
    ///    cbPrivateInputData = Size of the input data, in bytes.
    ///    lpPrivateOutputDat = Pointer to a buffer where the video accelerator will write output data.
    ///    cbPrivateOutputData = Size of the <i>lpPrivateOutputData</i> buffer, in bytes.
    ///    dwNumBuffers = Number of elements in the <i>pamvaBufferInfo</i> array.
    ///    pamvaBufferInfo = Pointer to an array of AMVABUFFERINFO structures.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. <b>HRESULT</b> can
    ///    include one of the following standard constants, or other values not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_INVALIDSUBTYPE</b></dt> </dl> </td> <td width="60%"> The decoder did not use a
    ///    DXVA decoding type when it connected to the video renderer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pins on the decoder and video renderer
    ///    filters are not connected. </td> </tr> </table>
    ///    
    HRESULT Execute(uint dwFunction, void* lpPrivateInputData, uint cbPrivateInputData, void* lpPrivateOutputDat, 
                    uint cbPrivateOutputData, uint dwNumBuffers, char* pamvaBufferInfo);
    ///The <b>QueryRenderStatus</b> method queries the read/write status of a DirectX Video Acceleration (DXVA) decoding
    ///surface.
    ///Params:
    ///    dwTypeIndex = Specifies the type of surface to query: <ul> <li>For a compressed surface, specify one of the DXVA surface
    ///                  types defined in dxva.h. </li> <li>For an uncompressed output surface, set this parameter to 0xFFFFFFFF.
    ///                  </li> </ul>
    ///    dwBufferIndex = The zero-based index of the surface, within the pool of surfaces that were allocated for the specified
    ///                    surface type.
    ///    dwFlags = Specifies the type of query to perform. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///              width="40%"><a id="Zero"></a><a id="zero"></a><a id="ZERO"></a><dl> <dt><b>Zero</b></dt> </dl> </td> <td
    ///              width="60%"> Test whether the surface is safe to use for writing. </td> </tr> <tr> <td width="40%"><a
    ///              id="AMVA_QUERYRENDERSTATUSF_READ"></a><a id="amva_queryrenderstatusf_read"></a><dl>
    ///              <dt><b><b>AMVA_QUERYRENDERSTATUSF_READ</b></b></dt> </dl> </td> <td width="60%"> Test whether the surface is
    ///              safe to use for reading. </td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PENDING</b></dt> </dl> </td> <td width="60%">
    ///    The operation is still in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The operation is complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_INVALIDSUBTYPE</b></dt> </dl> </td> <td width="60%"> The decoder did not use a DXVA decoding
    ///    type when it connected to the video renderer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pins on the decoder and video renderer
    ///    filters are not connected. </td> </tr> </table>
    ///    
    HRESULT QueryRenderStatus(uint dwTypeIndex, uint dwBufferIndex, uint dwFlags);
    ///The <b>DisplayFrame</b> method causes the video renderer to display a decoded frame.
    ///Params:
    ///    dwFlipToIndex = The surface index of the decoded frame to display.
    ///    pMediaSample = Pointer to the IMediaSample interface of a media sample. This sample does not contain a video frame, but is
    ///                   used to specify the time stamp and any sample flags. (For more information about sample flags, see
    ///                   AM_SAMPLE2_PROPERTIES.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that depends on the implementation of the interface. <b>HRESULT</b> can
    ///    include one of the following standard constants, or other values not listed. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Method is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_INVALIDSUBTYPE</b></dt> </dl> </td> <td width="60%"> The decoder did not use a
    ///    DXVA decoding type when it connected to the video renderer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pins on the decoder and video renderer
    ///    filters are not connected. </td> </tr> </table>
    ///    
    HRESULT DisplayFrame(uint dwFlipToIndex, IMediaSample pMediaSample);
}

///The <code>IAMWstDecoder</code> interface sets and retrieves information about World Standard Teletext (WST). The WST
///Decoder filter implements this interface.
interface IAMWstDecoder : IUnknown
{
    ///Applications use the <code>GetDecoderLevel</code> method to retrieve the WST decoder level. This method is not
    ///implemented and always returns AM_WST_LEVEL_1_5.
    ///Params:
    ///    lpLevel = Receives a member of the AM_WST_LEVEL enumeration, indicting the decoder level.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetDecoderLevel(AM_WST_LEVEL* lpLevel);
    ///Applications use the <code>GetCurrentService</code> method to retrieve the current WST service.
    ///Params:
    ///    lpService = Specifies a pointer to an AM_WST_SERVICE enumeration to receive the service currently being used. <table>
    ///                <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>AM_WST_SERVICE_None</td> <td>No service is
    ///                currently available.</td> </tr> <tr> <td>AM_WST_SERVICE_Text</td> <td>The service is providing text.</td>
    ///                </tr> <tr> <td>AM_WST_SERVICE_IDS</td> <td>The service is providing IDS data.</td> </tr> <tr>
    ///                <td>AM_WST_SERVICE_Invalid</td> <td>The service is invalid.</td> </tr> </table>
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetCurrentService(AM_WST_SERVICE* lpService);
    ///Applications use the <code>GetServiceState</code> method to retrieve the current service state.
    ///Params:
    ///    lpState = Pointer to a variable that receives the state, specified as a member of the AM_WST_STATE enumeration. The
    ///              following values are possible. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///              <td>AM_WST_STATE_On</td> <td>The WST service is on.</td> </tr> <tr> <td>AM_WST_STATE_Off</td> <td>The WST
    ///              service is off.</td> </tr> </table>
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetServiceState(AM_WST_STATE* lpState);
    ///Applications use the <code>SetServiceState</code> method to assign the service state.
    ///Params:
    ///    State = Specifies a member of an AM_WST_STATE enumeration to assign the service state. <table> <tr> <th>Value </th>
    ///            <th>Description </th> </tr> <tr> <td>AM_WST_STATE_On</td> <td>Closed captioning on.</td> </tr> <tr>
    ///            <td>AM_WST_STATE_Off</td> <td>Closed captioning off.</td> </tr> </table>
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <code>HRESULT</code> error code.
    ///    
    HRESULT SetServiceState(AM_WST_STATE State);
    ///Downstream filters use the <code>GetOutputFormat</code> method to retrieve the size, bit depth, and other
    ///parameters of the output video.
    ///Params:
    ///    lpbmih = A pointer to a BITMAPINFOHEADER structure that receives the size, bit depth, and other properties of the
    ///             output video.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetOutputFormat(BITMAPINFOHEADER* lpbmih);
    ///Downstream filters use the <code>SetOutputFormat</code> method to define an output video format.
    ///Params:
    ///    lpbmi = A pointer to a <b>BITMAPINFO</b> structure that describes the output video format, such as size, bit depth,
    ///            and other properties.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> So far, downstream filters have defined no output format. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Downstream filters have already defined
    ///    an output format. </td> </tr> </table>
    ///    
    HRESULT SetOutputFormat(BITMAPINFO* lpbmi);
    ///Downstream filters use the <code>GetBackgroundColor</code> method to retrieve the current physical color used in
    ///color keying the background for overlay mixing.
    ///Params:
    ///    pdwPhysColor = Receives the physical color as an RGB value.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetBackgroundColor(uint* pdwPhysColor);
    ///Downstream filters use the <code>SetBackgroundColor</code> method to assign the physical color to be used in
    ///color keying the background for overlay mixing.
    ///Params:
    ///    dwPhysColor = Specifies a <b>DWORD</b> containing the physical color.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetBackgroundColor(uint dwPhysColor);
    ///Downstream filters use the <code>GetRedrawAlways</code> method to retrieve a value that indicates whether the
    ///whole output bitmap is redrawn for each sample.
    ///Params:
    ///    lpbOption = Pointer to a <b>BOOL</b> to receive the redraw-always value. <table> <tr> <th>Value </th> <th>Description
    ///                </th> </tr> <tr> <td><b>TRUE</b></td> <td>Redraw the whole output bitmap for each sample.</td> </tr> <tr>
    ///                <td><b>FALSE</b></td> <td>Do not redraw the whole output bitmap for each sample.</td> </tr> </table>
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetRedrawAlways(int* lpbOption);
    ///Downstream filters use the <code>SetRedrawAlways</code> method to determine whether the whole output bitmap
    ///should be redrawn for each sample.
    ///Params:
    ///    bOption = Specifies a <b>BOOL</b> to assign whether the whole output bitmap should be redrawn for each sample. <table>
    ///              <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td><b>TRUE</b></td> <td>Redraw the whole output bitmap
    ///              for each sample.</td> </tr> <tr> <td><b>FALSE</b></td> <td>Do not redraw the whole output bitmap for each
    ///              sample.</td> </tr> </table>
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetRedrawAlways(BOOL bOption);
    ///Downstream filters use the <code>GetDrawBackgroundMode</code> method to determine whether the caption text
    ///background is opaque or transparent.
    ///Params:
    ///    lpMode = Receives a member of the AM_WST_DRAWBGMODE enumeration. This parameter receives one of the following values.
    ///             <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>AM_WST_DRAWBGMODE_Opaque</td> <td>Caption
    ///             text background is opaque.</td> </tr> <tr> <td>AM_WST_DRAWBGMODE_Transparent</td> <td>Caption text background
    ///             is transparent.</td> </tr> </table>
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetDrawBackgroundMode(AM_WST_DRAWBGMODE* lpMode);
    ///Downstream filters use the <code>SetDrawBackgroundMode</code> method to assign whether the caption text
    ///background is to be opaque or transparent.
    ///Params:
    ///    Mode = A member of the AM_WST_DRAWBGMODE enumeration that specifies whether the caption text background is to be
    ///           opaque or transparent. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///           <td>AM_WST_DRAWBGMODE_Opaque</td> <td>Caption text background is opaque.</td> </tr> <tr>
    ///           <td>AM_WST_DRAWBGMODE_Transparent</td> <td>Caption text background is transparent.</td> </tr> </table>
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetDrawBackgroundMode(AM_WST_DRAWBGMODE Mode);
    ///Downstream filters use the <code>SetAnswerMode</code> method to assign the current answer mode.
    ///Params:
    ///    bAnswer = Specifies the current answer mode. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///              <td><b>TRUE</b></td> <td>Hidden text exposed.</td> </tr> <tr> <td><b>FALSE</b></td> <td>Hidden text not
    ///              exposed.</td> </tr> </table>
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetAnswerMode(BOOL bAnswer);
    ///Downstream filters use the <code>GetAnswerMode</code> method to retrieve the current answer mode.
    ///Params:
    ///    pbAnswer = Receives the current answer mode. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///               <td><b>TRUE</b></td> <td>Hidden text exposed.</td> </tr> <tr> <td><b>FALSE</b></td> <td>Hidden text not
    ///               exposed.</td> </tr> </table>
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> code.
    ///    
    HRESULT GetAnswerMode(int* pbAnswer);
    ///Downstream filters use the <code>SetHoldPage</code> method to tell the WST decoder to hold the current WST page.
    ///When the WST decoder holds a page, any updates from the TV stream are turned off. It is as though the page was
    ///paused in real time.
    ///Params:
    ///    bHoldPage = Specifies whether to hold the current page. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                <td><b>TRUE</b></td> <td>Hold the current page</td> </tr> <tr> <td><b>FALSE</b></td> <td>Release the current
    ///                page.</td> </tr> </table>
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetHoldPage(BOOL bHoldPage);
    ///Downstream filters use the <code>GetHoldPage</code> method to determine whether the current WST page is held.
    ///When the WST decoder holds a page, any updates from the TV stream are turned off. It is though the page was
    ///paused in real time.
    ///Params:
    ///    pbHoldPage = Pointer to a <b>BOOL</b> to receive the status of the WST page. <table> <tr> <th>Value </th> <th>Description
    ///                 </th> </tr> <tr> <td><b>TRUE</b></td> <td>The current page is held.</td> </tr> <tr> <td><b>FALSE</b></td>
    ///                 <td>The current page is not held.</td> </tr> </table>
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetHoldPage(int* pbHoldPage);
    ///Downstream filters use the <code>GetCurrentPage</code> method to retrieve the current WST page.
    ///Params:
    ///    pWstPage = A pointer to an AM_WST_PAGE structure to receive the current page.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetCurrentPage(AM_WST_PAGE* pWstPage);
    ///Downstream filters use the <code>SetCurrentPage</code> method to assign the current page.
    ///Params:
    ///    WstPage = Specifies an AM_WST_PAGE structure that is used to assign the current page.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetCurrentPage(AM_WST_PAGE WstPage);
}

///The <code>IKsTopologyInfo</code> interface enumerates the nodes in a stream class driver. The KsProxy filter exposes
///this interface. Applications can use this interface to examine the internal topology of a kernel-mode filter.
@GUID("720D4AC0-7533-11D0-A5D6-28DB04C10000")
interface IKsTopologyInfo : IUnknown
{
    ///The <code>get_NumCategories</code> method returns the number of categories for this filter.
    ///Params:
    ///    pdwNumCategories = Receives the number of categories.
    ///Returns:
    ///    The method returns an HRES<b></b>ULT. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_NumCategories(uint* pdwNumCategories);
    ///The <code>get_Category</code> method returns one of the filter categories for this stream class driver.
    ///Params:
    ///    dwIndex = Index of the category GUID to retrieve. To find the number of categories, call the
    ///              IKsTopologyInfo::get_NumCategories method.
    ///    pCategory = Receives a GUID that defines the category. Microsoft provides standard categories in the header files Ks.h
    ///                and Ksmedia.h.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_Category(uint dwIndex, GUID* pCategory);
    ///The <code>get_NumConnections</code> method returns the number of node connections within the filter.
    ///Params:
    ///    pdwNumConnections = Receives the number of connections.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_NumConnections(uint* pdwNumConnections);
    ///The <code>get_ConnectionInfo</code> method returns information about one node connection in the filter.
    ///Params:
    ///    dwIndex = Index of the connection. To find the number of connections, call the IKsTopologyInfo::get_NumConnections
    ///              method.
    ///    pConnectionInfo = Pointer to a KSTOPOLOGY_CONNECTION structure allocated by the caller. The method fills in this structure with
    ///                      the connection information.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_ConnectionInfo(uint dwIndex, KSTOPOLOGY_CONNECTION* pConnectionInfo);
    ///The <code>get_NodeName</code> method returns the name of the node.
    ///Params:
    ///    dwNodeId = Index of the node. To find the number of nodes, call the IKsTopologyInfo::get_NumNodes method.
    ///    pwchNodeName = Pointer to a wide-character array that receives the name. To find the required buffer size, set this
    ///                   parameter to <b>NULL</b>. The size is returned in the <i>pdwNameLen</i> parameter.
    ///    dwBufSize = Size of the <i>pwchNodeName</i> array, in bytes.
    ///    pdwNameLen = Receives the buffer size required to hold the name, in bytes. This parameter cannot be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>WIN32_FROM_HRESULT(ERROR_MORE_DATA)</b></dt> </dl> </td> <td width="60%"> The buffer is not large
    ///    enough. </td> </tr> </table>
    ///    
    HRESULT get_NodeName(uint dwNodeId, char* pwchNodeName, uint dwBufSize, uint* pdwNameLen);
    ///The <code>get_NumNodes</code> method returns the number of nodes in the filter.
    ///Params:
    ///    pdwNumNodes = Receives the number of nodes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_NumNodes(uint* pdwNumNodes);
    ///The <code>get_NodeType</code> method returns the node type for a given node.
    ///Params:
    ///    dwNodeId = Index of the node. To find the number of nodes, call the IKsTopologyInfo::get_NumNodes method.
    ///    pNodeType = Receives a GUID that defines the node type. For a list of node types, see KS Node Types.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_NodeType(uint dwNodeId, GUID* pNodeType);
    ///The <code>CreateNodeInstance</code> method creates a COM object that represents a node in the filter.
    ///Params:
    ///    dwNodeId = Index of the node to create. To find the number of nodes, call the IKsTopologyInfo::get_NumNodes method.
    ///    iid = Interface identifier (IID) of the interface to return.
    ///    ppvObject = Receives a pointer to the requested interface on the node object. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CreateNodeInstance(uint dwNodeId, const(GUID)* iid, void** ppvObject);
}

///The <code>ISelector</code> interface is used to select source nodes in a stream class driver. Applications can use
///this interface to select which input is active on the device. For example, if a USB video capture device has a camera
///and a tape transport, these inputs could be represented as source nodes.
@GUID("1ABDAECA-68B6-4F83-9371-B413907C7B9F")
interface ISelector : IUnknown
{
    ///The <code>get_NumSources</code> method returns the number of source nodes connected to the selector node.
    ///Params:
    ///    pdwNumSources = Receives the number of source nodes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_NumSources(uint* pdwNumSources);
    ///The <code>get_SourceNodeId</code> method returns the index of the active source node.
    ///Params:
    ///    pdwPinId = Receives the index of the source node that is currently active.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_SourceNodeId(uint* pdwPinId);
    ///The <code>put_SourceNodeId</code> method activates a source node.
    ///Params:
    ///    dwPinId = Index of the source node to activate.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_SourceNodeId(uint dwPinId);
}

///The <code>ICameraControl</code> interface controls the camera settings on a capture device. This interface may be
///exposed by one or more nodes in a capture filter. It is not exposed at the level of the filter itself. To enumerate
///the nodes, query the filter for the IKsTopologyInfo interface. For each node, call IKsTopologyInfo::get_NodeType to
///get the node type. The <code>ICameraControl</code> interface is exposed by nodes of type
///KSNODETYPE_VIDEO_CAMERA_TERMINAL. Get the interface pointer by calling IKsTopologyInfo::CreateNodeInstance with the
///value IID_ICameraControl. This interface corresponds to the PROPSETID_VIDCAP_CAMERACONTROL property set, which is
///documented in the Windows DDK.
@GUID("2BA1785D-4D1B-44EF-85E8-C7F1D3F20184")
interface ICameraControl : IUnknown
{
    ///The <code>get_Exposure</code> method returns the camera's exposure time.
    ///Params:
    ///    pValue = Receives the exposure time, in log base 2 seconds. If the value is <i>n</i>, the exposure time is 2^n
    ///             seconds.
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Exposure(int* pValue, int* pFlags);
    ///The <code>put_Exposure</code> method sets the camera's exposure time.
    ///Params:
    ///    Value = Exposure time, in log base 2 seconds. If the value is <i>n</i>, the exposure time is 2^n seconds.
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Exposure(int Value, int Flags);
    ///The <code>getRange_Exposure</code> method returns the range of exposure times supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum exposure time, in log base 2 seconds. If the value is <i>n</i>, the exposure time is 2^n
    ///           seconds.
    ///    pMax = Receives the maximum exposure time, in log base 2 seconds.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default exposure time.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Exposure(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_Focus</code> method returns the distance that is optimally in focus.
    ///Params:
    ///    pValue = Receives the distance that is in focus, in millimeters.
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Focus(int* pValue, int* pFlags);
    ///The <code>put_Focus</code> method sets the distance that is optimally in focus.
    ///Params:
    ///    Value = Specifies the focus distance, in millimeters.
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Focus(int Value, int Flags);
    ///The <code>getRange_Focus</code> method returns the range of focal distances supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum focus distance, in millimeters.
    ///    pMax = Receives the maximum focus distance, in millimeters.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default focus distance.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Focus(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_Iris</code> method returns the camera's aperture setting.
    ///Params:
    ///    pValue = Receives the aperture setting, in units of f-stop * 10.
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Iris(int* pValue, int* pFlags);
    ///The <code>put_Iris</code> method sets the camera's aperture setting.
    ///Params:
    ///    Value = Specifies the aperture setting, in units of f-stop * 10.
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Iris(int Value, int Flags);
    ///The <code>getRange_Iris</code> method returns the range of aperture settings supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum aperture setting, in units of f-stop * 100.
    ///    pMax = Receives the maximum aperture setting, in units of f-stop * 100.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default aperture setting.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Iris(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_Zoom</code> method returns the camera's optical zoom level.
    ///Params:
    ///    pValue = Receives the zoom level. The units for this setting are not defined. For information about calculating
    ///             magnification from zoom level, see ICameraControl::get_FocalLengths.
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Zoom(int* pValue, int* pFlags);
    ///The <code>put_Zoom</code> method sets the camera's zoom level.
    ///Params:
    ///    Value = Specifies the zoom level. The units for this setting are not defined. For information about calculating
    ///            magnification from zoom level, see ICameraControl::get_FocalLengths.
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Zoom(int Value, int Flags);
    ///The <code>getRange_Zoom</code> method returns the range of zoom levels supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum zoom.
    ///    pMax = Receives the maximum zoom.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default zoom.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Zoom(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_FocalLengths</code> method returns the focal lengths of the camera lenses.
    ///Params:
    ///    plOcularFocalLength = Receives the ocular focal length.
    ///    plObjectiveFocalLengthMin = Receives the minimum objective focal length.
    ///    plObjectiveFocalLengthMax = Receives the maximum objective focal length.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_FocalLengths(int* plOcularFocalLength, int* plObjectiveFocalLengthMin, 
                             int* plObjectiveFocalLengthMax);
    ///The <code>get_Pan</code> method returns the camera's panning angle.
    ///Params:
    ///    pValue = Receives the panning angle, in degrees. Positive values are clockwise when viewing the camera from above, and
    ///             negative values are counter clockwise. Theoretical values range from –180 degrees to +180 degrees, but the
    ///             actual range depends on the camera. See ICameraControl::getRange_Pan.
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Pan(int* pValue, int* pFlags);
    ///The <code>put_Pan</code> method sets the camera's panning angle.
    ///Params:
    ///    Value = Specifies the panning angle, in degrees. Positive values are clockwise when viewing the camera from above,
    ///            and negative values are counter clockwise. Theoretical values range from –180 degrees to +180 degrees, but
    ///            the actual range depends on the camera. See ICameraControl::getRange_Pan.
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Pan(int Value, int Flags);
    ///The <code>getRange_Pan</code> method returns the range of panning angles supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum panning angle, in units of 1 arc second.
    ///    pMax = Receives the maximum panning angle, in units of 1 arc second.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default panning angle.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Pan(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_Tilt</code> method returns the camera's tilt angle.
    ///Params:
    ///    pValue = Receives the tilt angle, in degrees. Positive values point the camera up, and negative values point the
    ///             camera down. Theoretical values range from –180 degrees to +180 degrees, but the actual range depends on
    ///             the camera. See ICameraControl::getRange_Tilt.
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Tilt(int* pValue, int* pFlags);
    ///The <code>put_Tilt</code> method sets the camera's tilt angle.
    ///Params:
    ///    Value = Specifies the tilt angle, in degrees. Positive values point the camera up, and negative values point the
    ///            camera down. Theoretical values range from –180 degrees to +180 degrees, but the actual range depends on
    ///            the camera. See ICameraControl::getRange_Tilt.
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Tilt(int Value, int Flags);
    ///The <code>getRange_Tilt</code> method returns the range of tilt angles supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum tilt angle, in units of 1 arc second.
    ///    pMax = Receives the maximum tilt angle, in units of 1 arc second.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default tilt angle, in units of 1 arc second.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Tilt(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_PanTilt</code> method returns the camera's pan and tilt angles.
    ///Params:
    ///    pPanValue = Receives the current panning angle, in arc seconds. An arc second is 1/3600th of a degree. See
    ///                ICameraControl::get_Pan.
    ///    pTiltValue = Receives the current tilt angle, in arc seconds. See ICameraControl::get_Tilt.
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_PanTilt(int* pPanValue, int* pTiltValue, int* pFlags);
    ///The <code>put_PanTilt</code> method sets the camera's pan and tilt angles.
    ///Params:
    ///    PanValue = Specifies the panning angle, in arc seconds. An arc second is 1/3600th of a degree. See
    ///               ICameraControl::put_Pan.
    ///    TiltValue = Specifies the tilt angle, in arc seconds. See ICameraControl::put_Tilt.
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_PanTilt(int PanValue, int TiltValue, int Flags);
    ///The <code>get_Roll</code> method returns the camera's roll angle.
    ///Params:
    ///    pValue = Receives the roll angle, in degrees. Positive values are clockwise along the image viewing axis, and negative
    ///             values are counter clockwise. Theoretical values range from –180 degrees to +180 degrees, but the actual
    ///             range depends on the camera. See ICameraControl::getRange_Roll.
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Roll(int* pValue, int* pFlags);
    ///The <code>put_Roll</code> method sets the camera's roll angle.
    ///Params:
    ///    Value = Specifies the roll angle, in degrees. Positive values are clockwise along the image viewing axis, and
    ///            negative values are counter clockwise. Theoretical values range from –180 degrees to +180 degrees, but the
    ///            actual range depends on the camera. See ICameraControl::getRange_Roll.
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Roll(int Value, int Flags);
    ///The <code>getRange_Roll</code> method returns the range of roll angles supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum roll angle, in degrees.
    ///    pMax = Receives the maximum roll angle, in degrees.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default roll angle, in degrees.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Roll(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_ExposureRelative</code> method returns the camera's relative exposure time. The relative exposure
    ///time is expressed as a number of steps, where the size of each step depends on the camera model.
    ///Params:
    ///    pValue = Receives the relative exposure. To get the range of possible values, call
    ///             ICameraControl::getRange_ExposureRelative. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///             <td>0</td> <td>Default exposure time.</td> </tr> <tr> <td>Postive value</td> <td>Incremented by one
    ///             step.</td> </tr> <tr> <td>Negative value</td> <td>Decremented by one step.</td> </tr> </table>
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_ExposureRelative(int* pValue, int* pFlags);
    ///The <code>put_ExposureRelative</code> method sets the camera's relative exposure time. The relative exposure time
    ///is expressed as a number of steps, where the size of each step depends on the camera model.
    ///Params:
    ///    Value = Specifies the relative exposure. To get the range of possible values, call
    ///            ICameraControl::getRange_ExposureRelative. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>0</td> <td>Set the exposure to the default exposure time, which is implementation dependent.</td> </tr>
    ///            <tr> <td>Postive value</td> <td>Increment the exposure time by one step.</td> </tr> <tr> <td>Negative
    ///            value</td> <td>Decrement the exposure time by one step.</td> </tr> </table>
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_ExposureRelative(int Value, int Flags);
    ///The <code>getRange_ExposureRelative</code> method returns the range of relative exposure times supported by the
    ///camera. The relative exposure time is expressed as a number of steps, where the absolute value of each step
    ///depends on the camera model.
    ///Params:
    ///    pMin = Receives the minimum relative exposure time.
    ///    pMax = Receives the maximum relative exposure time.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default relative exposure time.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_ExposureRelative(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_FocusRelative</code> method returns the relative focus. The relative focus indicates the direction
    ///in which the lens group is moving.
    ///Params:
    ///    pValue = Receives the relative focus. The size of the value represents the speed at which the focal point changes; a
    ///             higher value represents a higher speed. To get the range of possible values, call
    ///             ICameraControl::getRange_FocusRelative. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///             <td>0</td> <td>Stopped.</td> </tr> <tr> <td>Positive value</td> <td>Focus is moving closer to the
    ///             object.</td> </tr> <tr> <td>Negative value</td> <td>Focus is moving farther away from the object.</td> </tr>
    ///             </table>
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_FocusRelative(int* pValue, int* pFlags);
    ///The <code>put_FocusRelative</code> method sets the relative focus. The relative focus indicates the direction in
    ///which the lens group is moving.
    ///Params:
    ///    Value = Specifies the relative focus. The size of the value represents the speed at which the focal point changes; a
    ///            higher value represents a higher speed. To get the possible range of values, call
    ///            ICameraControl::getRange_FocusRelative. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>0</td> <td>Stop focus motion.</td> </tr> <tr> <td>Positive value</td> <td>Start moving the focus closer
    ///            to the object.</td> </tr> <tr> <td>Negative value</td> <td>Start moving the focus farther away from the
    ///            object.</td> </tr> </table>
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_FocusRelative(int Value, int Flags);
    ///The <code>getRange_FocusRelative</code> method returns the range of relative focal distances supported by the
    ///camera. The relative focus indicates the direction in which the lens group is moving.
    ///Params:
    ///    pMin = Receives the minimum relative focus.
    ///    pMax = Receives the minimum relative focus.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default relative focus.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_FocusRelative(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_IrisRelative</code> method returns the camera's relative aperture setting. The relative aperture is
    ///expressed as a number of steps, where the size of each step depends on the camera model.
    ///Params:
    ///    pValue = Receives the relative aperture setting. To get the range of possible values, call
    ///             ICameraControl::getRange_IrisRelative. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///             <td>0</td> <td>Default aperture setting.</td> </tr> <tr> <td>Postive value</td> <td>Open by one step.</td>
    ///             </tr> <tr> <td>Negative value</td> <td>Close by one step.</td> </tr> </table>
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_IrisRelative(int* pValue, int* pFlags);
    ///The <code>put_IrisRelative</code> method sets the camera's relative aperture setting. The relative aperture is
    ///expressed as a number of steps, where the size of each step depends on the camera model.
    ///Params:
    ///    Value = Specifies the relative aperture setting. To get the range of possible values, call
    ///            ICameraControl::getRange_IrisRelative. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>0</td> <td>Set the default aperture setting, which is implementation dependent.</td> </tr> <tr>
    ///            <td>Postive value</td> <td>Open the iris one step.</td> </tr> <tr> <td>Negative value</td> <td>Close the iris
    ///            one step.</td> </tr> </table>
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_IrisRelative(int Value, int Flags);
    ///The <code>getRange_IrisRelative</code> method returns the range of relative aperture settings supported by the
    ///camera. The relative aperture is expressed as a number of steps, where the size of each step depends on the
    ///camera model.
    ///Params:
    ///    pMin = Receives the minimum relative aperture setting.
    ///    pMax = Receives the maximum relative aperture setting.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default relative aperture setting.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_IrisRelative(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_ZoomRelative</code> method returns the camera's relative zoom. The relative zoom indicates the
    ///direction in which the lens is moving.
    ///Params:
    ///    pValue = Receives the relative zoom. The size of the value represents the desired zoom speed; a higher value
    ///             represents a higher speed. To get the range of possible values, call ICameraControl::getRange_ZoomRelative.
    ///             <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>0</td> <td>Stopped.</td> </tr> <tr>
    ///             <td>Positive value</td> <td>Zoom lens moving in the telephoto direction.</td> </tr> <tr> <td>Negative
    ///             value</td> <td>Zoom lens moving in the wide angle direction.</td> </tr> </table>
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_ZoomRelative(int* pValue, int* pFlags);
    ///The <code>put_ZoomRelative</code> method sets the camera's relative zoom. The relative zoom indicates the
    ///direction in which the lens is moving.
    ///Params:
    ///    Value = Specifies the relative zoom. The size of the value represents the desired zoom speed; a higher value
    ///            represents a higher speed. To get the range of possible values, call ICameraControl::getRange_ZoomRelative.
    ///            <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>0</td> <td>Stop zoom lens motion.</td>
    ///            </tr> <tr> <td>Positive value</td> <td>Start moving the zoom lens in the telephoto direction (initiate
    ///            zoom-in).</td> </tr> <tr> <td>Negative value</td> <td>Start moving the zoom lens in the wide angle direction
    ///            (initiate zoom-out).</td> </tr> </table>
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_ZoomRelative(int Value, int Flags);
    ///The <code>getRange_ZoomRelative</code> method returns the range of relative zoom levels supported by the camera.
    ///The relative zoom indicates the direction in which the lens is moving.
    ///Params:
    ///    pMin = Receives the minimum relative zoom.
    ///    pMax = Receives the maximum relative zoom.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default relative zoom.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_ZoomRelative(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_PanRelative</code> method returns the camera's relative pan. The relative pan is expressed as a
    ///number of steps, where the size of each step depends on the camera model.
    ///Params:
    ///    pValue = Receives the relative pan. The size of the value represents the desired pan speed; a higher value represents
    ///             a higher speed. To get the range of possible values, call ICameraControl::getRange_PanRelative. <table> <tr>
    ///             <th>Value </th> <th>Description </th> </tr> <tr> <td>0</td> <td>Stopped.</td> </tr> <tr> <td>Positive
    ///             value</td> <td>Panning to the right.</td> </tr> <tr> <td>Negative value</td> <td>Panning to the left.</td>
    ///             </tr> </table>
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_PanRelative(int* pValue, int* pFlags);
    ///The <code>put_PanRelative</code> method sets the camera's relative pan. The relative pan is expressed as a number
    ///of steps, where the size of each step depends on the camera model.
    ///Params:
    ///    Value = Specifies the relative pan. The size of the value represents the desired pan speed; a higher value represents
    ///            a higher speed. To get the range of possible values, call ICameraControl::getRange_PanRelative. <table> <tr>
    ///            <th>Value </th> <th>Description </th> </tr> <tr> <td>0</td> <td>Stop panning.</td> </tr> <tr> <td>Positive
    ///            value</td> <td>Start panning to the right.</td> </tr> <tr> <td>Negative value</td> <td>Start panning to the
    ///            left.</td> </tr> </table>
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_PanRelative(int Value, int Flags);
    ///This topic applies only to Windows XP Service Pack 2 and later. The <code>get_TiltRelative</code> method returns
    ///the camera's relative tilt. The relative tilt is expressed as a number of steps, where the size of each step
    ///depends on the camera model.
    ///Params:
    ///    pValue = Receives the relative tilt. The size of the value represents the desired tilt speed; a higher value
    ///             represents a higher speed. To get the range of possible values, call ICameraControl::getRange_TiltRelative.
    ///             <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>0</td> <td>Stopped.</td> </tr> <tr>
    ///             <td>Positive value</td> <td>Tilting up.</td> </tr> <tr> <td>Negative value</td> <td>Tilting down.</td> </tr>
    ///             </table>
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_TiltRelative(int* pValue, int* pFlags);
    ///The <code>put_TiltRelative</code> method sets the camera's relative tilt. The relative tilt is expressed as a
    ///number of steps, where the size of each step depends on the camera model.
    ///Params:
    ///    Value = Specifies the relative tilt. The size of the value represents the desired tilt speed; a higher value
    ///            represents a higher speed. To get the range of possible values, call ICameraControl::getRange_TiltRelative.
    ///            <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>0</td> <td>Stop tilting.</td> </tr> <tr>
    ///            <td>Positive value</td> <td>Start tilting up.</td> </tr> <tr> <td>Negative value</td> <td>Start tilting
    ///            down.</td> </tr> </table>
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_TiltRelative(int Value, int Flags);
    ///The <code>getRange_TiltRelative</code> method returns the range of relative tilt angles supported by the camera.
    ///The relative tilt is expressed as a number of steps, where the size of each step depends on the camera model.
    ///Params:
    ///    pMin = Receives the minimum relative tilt angle.
    ///    pMax = Receives the maximum relative title angle.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default relative tilt angle.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_TiltRelative(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_PanTiltRelative</code> method returns the camera's relative pan and tilt. The relative pan and tilt
    ///are expressed as a number of steps, where the size of each step depends on the camera model.
    ///Params:
    ///    pPanValue = Receives the relative pan. See ICameraControl::get_PanRelative.
    ///    pTiltValue = Receives the relative tilt. See ICameraControl::get_TiltRelative.
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_PanTiltRelative(int* pPanValue, int* pTiltValue, int* pFlags);
    ///The <code>put_PanTiltRelative</code> method sets the camera's relative pan and tilt. The relative pan and tilt
    ///are expressed as a number of steps, where the size of each step depends on the camera model.
    ///Params:
    ///    PanValue = Specifies the relative pan. See ICameraControl::put_PanRelative.
    ///    TiltValue = Specifies the relative tilt. See ICameraControl::put_TiltRelative.
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_PanTiltRelative(int PanValue, int TiltValue, int Flags);
    ///The <code>getRange_PanRelative</code> method returns the range of relative panning angles supported by the
    ///camera. The relative pan is expressed as a number of steps, where the size of each step depends on the camera
    ///model.
    ///Params:
    ///    pMin = Receives the minimum relative panning angle.
    ///    pMax = Receives the maximum relative panning angle.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default relative panning angle.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_PanRelative(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_RollRelative</code> method returns the camera's relative roll. The relative roll is expressed as a
    ///number of steps, where the size of each step depends on the camera model.
    ///Params:
    ///    pValue = Receives the relative roll. The size of the value represents the desired rotation speed; a higher value
    ///             represents a higher speed. To get the range of possible values, call ICameraControl::getRange_RollRelative.
    ///             <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>0</td> <td>Stopped.</td> </tr> <tr>
    ///             <td>Positive value</td> <td>Rotating clockwise around the viewing axis.</td> </tr> <tr> <td>Negative
    ///             value</td> <td>Rotating counterclockwise around the viewing axis.</td> </tr> </table>
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_RollRelative(int* pValue, int* pFlags);
    ///The <code>put_RollRelative</code> method sets the camera's relative roll. The relative roll is expressed as a
    ///number of steps, where the size of each step depends on the camera model.
    ///Params:
    ///    Value = Specifies the relative roll. The size of the value represents the desired rotation speed; a higher value
    ///            represents a higher speed. To get the range of possible values, call ICameraControl::getRange_RollRelative.
    ///            <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>0</td> <td>Stop the roll.</td> </tr> <tr>
    ///            <td>Positive value</td> <td>Start rotating clockwise around the viewing axis.</td> </tr> <tr> <td>Negative
    ///            value</td> <td>Start rotating counterclockwise around the viewing axis.</td> </tr> </table>
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_RollRelative(int Value, int Flags);
    ///The <code>getRange_RollRelative</code> method returns the range of relative roll angles supported by the camera.
    ///The relative roll is expressed as a number of steps, where the size of each step depends on the camera model.
    ///Params:
    ///    pMin = Receives the minimum relative roll angle.
    ///    pMax = Receives the maximum relative roll angle.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default relative roll angle.
    ///    pCapsFlag = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_RollRelative(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_ScanMode</code> method returns the current scanning mode (interlaced or progressive).
    ///Params:
    ///    pValue = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///             <td>0</td> <td>Interlaced video.</td> </tr> <tr> <td>1</td> <td>Progressive video.</td> </tr> </table>
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_ScanMode(int* pValue, int* pFlags);
    ///The <code>put_ScanMode</code> method sets the camera's scanning mode (interlaced or progressive).
    ///Params:
    ///    Value = Specifies one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>0</td> <td>Interlaced.</td> </tr> <tr> <td>1</td> <td>Progressive.</td> </tr> </table>
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_ScanMode(int Value, int Flags);
    ///The <code>get_PrivacyMode</code> method returns the camera's privacy setting. The privacy setting controls
    ///whether camera sensor captures video.
    ///Params:
    ///    pValue = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///             <td>0</td> <td>The sensor is able to capture video.</td> </tr> <tr> <td>1</td> <td>The sensor is not able to
    ///             capture video.</td> </tr> </table>
    ///    pFlags = Receives one or more flags. See CameraControlFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_PrivacyMode(int* pValue, int* pFlags);
    ///The <code>put_PrivacyMode</code> method sets the camera's privacy setting. The privacy setting controls whether
    ///the camera sensor captures video.
    ///Params:
    ///    Value = Specifies one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>0</td> <td>The sensor is able to capture video.</td> </tr> <tr> <td>1</td> <td>The sensor is not able to
    ///            capture video.</td> </tr> </table>
    ///    Flags = Zero or more flags. See CameraControlFlags. If the CameraControl_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_PrivacyMode(int Value, int Flags);
}

///The <code>IVideoProcAmp</code> interface controls the image adjustment (ProcAmp) settings on a capture device. This
///interface may be exposed by one or more nodes in a capture filter. It is not exposed at the level of the filter
///itself. To enumerate the nodes, query the filter for the IKsTopologyInfo interface. For each node, call
///IKsTopologyInfo::get_NodeType to get the node type. The <code>IVideoProcAmp</code> interface is exposed by nodes of
///type KSNODETYPE_VIDEO_PROCESSING. Get the interface pointer by calling IKsTopologyInfo::CreateNodeInstance with the
///value IID_IVideoProcAmp. This interface corresponds to the PROPSETID_VIDCAP_VIDEOPROCAMP property set, which is
///documented in the Windows DDK.
@GUID("4050560E-42A7-413A-85C2-09269A2D0F44")
interface IVideoProcAmp : IUnknown
{
    ///The <code>get_BacklightCompensation</code> method returns the camera's backlight compensation setting.
    ///Params:
    ///    pValue = Receives the backlight compensation setting. If the value is zero, backlight compensation is disabled.
    ///             Otherwise, backlight compensation is enabled. The camera may support a Boolean setting (0/1) or a range of
    ///             settings. If it supports a range of settings, higher numbers indicate a greater degree of backlight
    ///             compensation.
    ///    pFlags = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_BacklightCompensation(int* pValue, int* pFlags);
    ///The <code>put_BacklightCompensation</code> method sets the camera's backlight compensation.
    ///Params:
    ///    Value = Specifies the backlight compensation setting. If the value is zero, backlight compensation is disabled.
    ///            Otherwise, backlight compensation is enabled. The camera may support a Boolean setting (0/1) or a range of
    ///            settings. If it supports a range of settings, higher numbers indicate a greater degree of backlight
    ///            compensation.
    ///    Flags = Zero or more flags. See VideoProcAmpFlags. If the VideoProcAmp_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_BacklightCompensation(int Value, int Flags);
    ///The <code>getRange_BacklightCompensation</code> method returns the range of backlight compensation settings
    ///supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum backlight compensation setting.
    ///    pMax = Receives the maximum backlight compensation setting.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default backlight compensation setting.
    ///    pCapsFlag = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_BacklightCompensation(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, 
                                           int* pCapsFlag);
    ///The <code>get_Brightness</code> method returns the camera's brightness setting.
    ///Params:
    ///    pValue = Receives the brightness setting. Larger values indicate increased brightness.
    ///    pFlags = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Brightness(int* pValue, int* pFlags);
    ///The <code>put_Brightness</code> method sets the camera's brightness setting.
    ///Params:
    ///    Value = Specifies the brightness setting. Larger values indicate increased brightness.
    ///    Flags = Zero or more flags. See VideoProcAmpFlags. If the VideoProcAmp_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Brightness(int Value, int Flags);
    ///The <code>getRange_Brightness</code> method returns the range of brightness settings supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum brightness setting.
    ///    pMax = Receives the maximum brightness setting.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default brightness setting.
    ///    pCapsFlag = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Brightness(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_ColorEnable</code> method returns the camera's color-enable setting.
    ///Params:
    ///    pValue = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///             <td>0</td> <td>Color disabled.</td> </tr> <tr> <td>1</td> <td>Color enabled.</td> </tr> </table>
    ///    pFlags = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_ColorEnable(int* pValue, int* pFlags);
    ///The <code>put_ColorEnable</code> method sets the camera's color-enable setting.
    ///Params:
    ///    Value = Specifies one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>0</td> <td>Color disabled.</td> </tr> <tr> <td>1</td> <td>Color enabled.</td> </tr> </table>
    ///    Flags = Zero or more flags. See VideoProcAmpFlags. If the VideoProcAmp_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_ColorEnable(int Value, int Flags);
    ///The <code>getRange_ColorEnable</code> method returns the range of color-enable settings supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum color-enable setting.
    ///    pMax = Receives the maximum color-enable setting.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default color-enable setting.
    ///    pCapsFlag = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_ColorEnable(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_Contrast</code> method returns the camera's contrast setting.
    ///Params:
    ///    pValue = Receives the contrast setting. Larger values indicate increased contrast.
    ///    pFlags = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Contrast(int* pValue, int* pFlags);
    ///The <code>put_Contrast</code> method sets the camera's contrast setting.
    ///Params:
    ///    Value = Specifies the contrast setting. Larger values indicate increased contrast.
    ///    Flags = Zero or more flags. See VideoProcAmpFlags. If the VideoProcAmp_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Contrast(int Value, int Flags);
    ///The <code>getRange_Contrast</code> method returns the range of contrast settings supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum contrast setting.
    ///    pMax = Receives the maximum contrast setting.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default contrast setting.
    ///    pCapsFlag = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Contrast(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_Gamma</code> method returns the camera's gamma setting.
    ///Params:
    ///    pValue = Receives the gamma setting, in units of gamma * 100. Theoretical values range from 1 to 500, but the actual
    ///             range depends on the camera. See IVideoProcAmp::getRange_Gamma.
    ///    pFlags = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Gamma(int* pValue, int* pFlags);
    ///The <code>put_Gamma</code> method sets the camera's gamma setting.
    ///Params:
    ///    Value = Specifies the gamma setting, in units of gamma * 100. Theoretical values range from 1 to 500, but the actual
    ///            range depends on the camera. See IVideoProcAmp::getRange_Gamma.
    ///    Flags = Zero or more flags. See VideoProcAmpFlags. If the VideoProcAmp_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Gamma(int Value, int Flags);
    ///The <code>getRange_Gamma</code> method returns the range of gamma settings supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum gamma setting.
    ///    pMax = Receives the maximum gamma setting.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default gamma setting.
    ///    pCapsFlag = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Gamma(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_Saturation</code> method returns the camera's saturation setting.
    ///Params:
    ///    pValue = Receives the saturation setting. Larger values indicate greater saturation. The value zero indicates
    ///             grayscale.
    ///    pFlags = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Saturation(int* pValue, int* pFlags);
    ///The <code>put_Saturation</code> method sets the camera's saturation setting.
    ///Params:
    ///    Value = Specifies the saturation setting. Larger values indicate greater saturation. The value zero indicates
    ///            grayscale.
    ///    Flags = Zero or more flags. See VideoProcAmpFlags. If the VideoProcAmp_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Saturation(int Value, int Flags);
    ///The <code>getRange_Saturation</code> method returns the range of saturation settings supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum saturation setting.
    ///    pMax = Receives the maximum saturation setting.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default saturation setting.
    ///    pCapsFlag = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Saturation(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_Sharpness</code> method returns the camera's sharpness setting.
    ///Params:
    ///    pValue = Receives the sharpness setting. Larger values indicate increasing sharpness.
    ///    pFlags = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Sharpness(int* pValue, int* pFlags);
    ///The <code>put_Sharpness</code> method sets the camera's sharpness setting.
    ///Params:
    ///    Value = Specifies the sharpness setting. Larger values indicate increasing sharpness.
    ///    Flags = Zero or more flags. See VideoProcAmpFlags. If the VideoProcAmp_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Sharpness(int Value, int Flags);
    ///The <code>getRange_Sharpness</code> method returns the range of sharpness settings supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum sharpness setting.
    ///    pMax = Receives the maximum sharpness setting.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default sharpness setting.
    ///    pCapsFlag = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Sharpness(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_WhiteBalance</code> method returns the camera's white balance, specified as a color temperature.
    ///Params:
    ///    pValue = Receives the white balance, in degrees Kelvin.
    ///    pFlags = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_WhiteBalance(int* pValue, int* pFlags);
    ///The <code>put_WhiteBalance</code> method sets the camera's white balance, specified as a color temperature.
    ///Params:
    ///    Value = Specifies the white balance, in degrees Kelvin.
    ///    Flags = Zero or more flags. See VideoProcAmpFlags. If the VideoProcAmp_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_WhiteBalance(int Value, int Flags);
    ///The <code>getRange_WhiteBalance</code> method returns the range of white balance settings supported by the
    ///camera, expressed as color temperature.
    ///Params:
    ///    pMin = Receives the minimum white balance, in degrees Kelvin.
    ///    pMax = Receives the maximum white balance, in degrees Kelvin.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default white balance.
    ///    pCapsFlag = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_WhiteBalance(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_Gain</code> method returns the camera's gain setting.
    ///Params:
    ///    pValue = Receives the gain setting. Larger values indicate higher gain.
    ///    pFlags = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Gain(int* pValue, int* pFlags);
    ///The <code>put_Gain</code> method sets the camera's gain setting.
    ///Params:
    ///    Value = Specifies the gain setting. Larger values indicate higher gain.
    ///    Flags = Zero or more flags. See VideoProcAmpFlags. If the VideoProcAmp_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Gain(int Value, int Flags);
    ///The <code>getRange_Gain</code> method returns the range of gain settings supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum gain setting.
    ///    pMax = Receives the maximum gain setting.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default gain setting.
    ///    pCapsFlag = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Gain(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_Hue</code> method returns the camera's hue setting.
    ///Params:
    ///    pValue = Receives the hue setting, in units of degrees * 100. Theoretical values range from –180 degrees to +180
    ///             degrees, but the actual range depends on the camera. See IVideoProcAmp::getRange_Hue.
    ///    pFlags = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Hue(int* pValue, int* pFlags);
    ///The <code>put_Hue</code> method sets the camera's hue setting.
    ///Params:
    ///    Value = Specifies the hue setting, in units of degrees * 100. Theoretical values range from –180 degrees to +180
    ///            degrees, but the actual range depends on the camera. See IVideoProcAmp::getRange_Hue.
    ///    Flags = Zero or more flags. See VideoProcAmpFlags. If the VideoProcAmp_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_Hue(int Value, int Flags);
    ///The <code>getRange_Hue</code> method returns the range of hue settings supported by the camera.
    ///Params:
    ///    pMin = Receives the minimum hue setting.
    ///    pMax = Receives the maximum hue setting.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default hue setting.
    ///    pCapsFlag = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_Hue(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_DigitalMultiplier</code> method returns the camera's digital zoom level.
    ///Params:
    ///    pValue = Receives the digital zoom multiplier.
    ///    pFlags = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_DigitalMultiplier(int* pValue, int* pFlags);
    ///The <code>put_DigitalMultiplier</code> method sets the camera's digital zoom level.
    ///Params:
    ///    Value = Specifies the digital zoom multiplier.
    ///    Flags = Zero or more flags. See VideoProcAmpFlags. If the VideoProcAmp_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_DigitalMultiplier(int Value, int Flags);
    ///The <code>getRange_DigitalMultiplier</code> method returns the range of digital zoom levels supported by the
    ///camera.
    ///Params:
    ///    pMin = Receives the minimum digital zoom level.
    ///    pMax = Receives the maximum digital zoom level.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default digital zoom level.
    ///    pCapsFlag = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_DigitalMultiplier(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_PowerlineFrequency</code> method returns the camera's power line frequency setting. This setting
    ///enables the camera to perform anti-flicker processing.
    ///Params:
    ///    pValue = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///             <td>0</td> <td>Disabled.</td> </tr> <tr> <td>1</td> <td>50 Hz.</td> </tr> <tr> <td>2</td> <td>60 Hz.</td>
    ///             </tr> </table>
    ///    pFlags = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_PowerlineFrequency(int* pValue, int* pFlags);
    ///The <code>put_PowerlineFrequency</code> method sets the camera's power line frequency setting. This setting
    ///enables the camera to perform anti-flicker processing.
    ///Params:
    ///    Value = Specifies one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>0</td> <td>Disabled.</td> </tr> <tr> <td>1</td> <td>50 Hz.</td> </tr> <tr> <td>2</td> <td>60 Hz.</td>
    ///            </tr> </table>
    ///    Flags = Zero or more flags. See VideoProcAmpFlags. If the VideoProcAmp_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_PowerlineFrequency(int Value, int Flags);
    ///The <code>getRange_PowerlineFrequency</code> method returns the range of power line frequency settings supported
    ///by the camera.
    ///Params:
    ///    pMin = Receives the minimum power line frequency setting.
    ///    pMax = Receives the maximum power line frequency setting.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default power line frequency setting.
    ///    pCapsFlag = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_PowerlineFrequency(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, int* pCapsFlag);
    ///The <code>get_WhiteBalanceComponent</code> method returns the camera's white balance, specified as red and blue
    ///component values.
    ///Params:
    ///    pValue1 = Receives the red component.
    ///    pValue2 = Receives the blue component.
    ///    pFlags = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_WhiteBalanceComponent(int* pValue1, int* pValue2, int* pFlags);
    ///The <code>put_WhiteBalanceComponent</code> method sets the camera's white balance, specified as red and blue
    ///component values.
    ///Params:
    ///    Value1 = Specifies the red component.
    ///    Value2 = Specifies the blue component.
    ///    Flags = Zero or more flags. See VideoProcAmpFlags. If the VideoProcAmp_Flags_Auto flag is used, the <i>Value</i>
    ///            parameter is ignored and the camera sets the default value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT put_WhiteBalanceComponent(int Value1, int Value2, int Flags);
    ///The <code>getRange_WhiteBalanceComponent</code> method returns the range of white balance settings supported by
    ///the camera, expressed as red and blue component values.
    ///Params:
    ///    pMin = Receives the minimum white balance.
    ///    pMax = Receives the maximum white balance.
    ///    pSteppingDelta = Receives the smallest step between settings.
    ///    pDefault = Receives the default white balance.
    ///    pCapsFlag = Receives one or more flags. See VideoProcAmpFlags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT getRange_WhiteBalanceComponent(int* pMin, int* pMax, int* pSteppingDelta, int* pDefault, 
                                           int* pCapsFlag);
}

///The <code>IKsNodeControl</code> interface must be implemented by USB Video Class (UVC) extension units. A UVC
///extension unit is a COM object that provides extended functionality to a USB video device, beyond the functionality
///provided by the UVC class driver. The <code>IKsNodeControl</code> interface is used by the KsProxy filter to
///communicate with the extension unit. Applications do not use this interface. For more information, see the topic "USB
///Video Class Extension Units" in the Windows DDK.
@GUID("11737C14-24A7-4BB5-81A0-0D003813B0C4")
interface IKsNodeControl : IUnknown
{
    ///Sets the node identifier for the extension unit.
    ///Params:
    ///    dwNodeId = Node identifier.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_NodeId(uint dwNodeId);
    ///Provides an instance of the <b>IKsControl</b> interface to the extension unit.
    ///Params:
    ///    pKsControl = Pointer to the <b>IKsControl</b> interface, typed as a void pointer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_KsControl(void* pKsControl);
}

///The <code>IConfigAsfWriter</code> interface configures the WM ASF Writer filter. It provides methods for getting and
///setting the profiles and indexing mode. When the WM ASF Writer filter is created, it is configured automatically with
///a default ASF audio-visual profile based on the incoming streams. A profile describes various attributes of an ASF
///file such as bit rate, number and type of streams, compression quality, and so on. The filter uses the profile to
///determine what kind of ASF file to write, how many input pins to create, and what media types to accept. When the WM
///ASF Writer filter is first created, it is configured automatically with the following default profile:
///WMProfile_V80_256Video. However, using this profile is not recommended because it does not use the Windows Media
///Audio and Video 9 Series codecs.
@GUID("45086030-F7E4-486A-B504-826BB5792A3B")
interface IConfigAsfWriter : IUnknown
{
    ///The <code>ConfigureFilterUsingProfileId</code> method sets a Windows Media Format 4.0 profile on the WM ASF
    ///Writer filter. This method is deprecated. Applications should use the
    ///IConfigAsfWriter::ConfigureFilterUsingProfile method to set the profile.
    ///Params:
    ///    dwProfileId = Profile ID as defined in version 4.0 of the Windows Media Format SDK.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The profile is invalid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The filter graph is
    ///    stopped. </td> </tr> </table>
    ///    
    HRESULT ConfigureFilterUsingProfileId(uint dwProfileId);
    ///The <code>GetCurrentProfileId</code> method retrieves the identifier of the WM ASF Writer filter's profile, only
    ///when the filter is using a Windows Media Format 4.0 profile. (Deprecated.)
    ///Params:
    ///    pdwProfileId = Receives the current profile ID.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> error code otherwise.
    ///    
    HRESULT GetCurrentProfileId(uint* pdwProfileId);
    ///The <code>ConfigureFilterUsingProfileGuid</code> method sets a predefined system profile on the WM ASF Writer
    ///filter. This method is deprecated. Applications should use the IConfigAsfWriter::ConfigureFilterUsingProfile
    ///method to set the profile.
    ///Params:
    ///    guidProfile = Profile <b>GUID</b> as defined in the header file Wmsysprf.h.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The profile is invalid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The filter graph is
    ///    stopped. </td> </tr> </table>
    ///    
    HRESULT ConfigureFilterUsingProfileGuid(const(GUID)* guidProfile);
    ///The <code>GetCurrentProfileGuid</code> method retrieves the GUID of the WM ASF Writer filter's current system
    ///profile, if any. (Deprecated.)
    ///Params:
    ///    pProfileGuid = Receives the <b>GUID</b> of the system profile.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> error code otherwise.
    ///    
    HRESULT GetCurrentProfileGuid(GUID* pProfileGuid);
    ///The <code>ConfigureFilterUsingProfile</code> method sets an ASF profile on the WM ASF Writer filter. This method
    ///is the recommended way to set a profile on the WM ASF Writer filter.
    ///Params:
    ///    pProfile = Pointer to the IWMProfile interface of the profile.
    ///Returns:
    ///    Returns one of the following <b>HRESULT</b> values. <table> <tr> <th>Return code</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The graph is stopped.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The IWMProfile
    ///    interface pointer is invalid. </td> </tr> </table>
    ///    
    HRESULT ConfigureFilterUsingProfile(IWMProfile pProfile);
    ///The <code>GetCurrentProfile</code> method retrieves the current ASF profile from the WM ASF Writer filter.
    ///Params:
    ///    ppProfile = Receives a pointer to the IWMProfile interface of the profile. The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> error code otherwise.
    ///    
    HRESULT GetCurrentProfile(IWMProfile* ppProfile);
    ///The <code>SetIndexMode</code> method controls whether the WM ASF Writer filter creates a file with a temporal
    ///index.
    ///Params:
    ///    bIndexFile = Specifies the index mode. If <b>TRUE</b>, the file will be indexed.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> error code otherwise.
    ///    
    HRESULT SetIndexMode(BOOL bIndexFile);
    ///The <code>GetIndexMode</code> method retrieves the current index mode.
    ///Params:
    ///    pbIndexFile = Receives the index mode setting. A value of <b>TRUE</b> indicates that the WM ASF Writer is configured to
    ///                  write indexed files.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> error code otherwise.
    ///    
    HRESULT GetIndexMode(int* pbIndexFile);
}

///The <code>IConfigAsfWriter2</code> interface extends the IConfigAsfWriter interface, which configures the WM ASF
///Writer filter. The <code>IConfigAsfWriter2</code> interface provides additional methods to support the capabilities
///introduced in the Windows Media Format 9 Series SDK, such as two-pass encoding and support for interlaced output.
@GUID("7989CCAA-53F0-44F0-884A-F3B03F6AE066")
interface IConfigAsfWriter2 : IConfigAsfWriter
{
    ///The <code>StreamNumFromPin</code> method retrieves the stream number associated with the specified input pin.
    ///Params:
    ///    pPin = Pointer to the IPin interface on the input pin.
    ///    pwStreamNum = Receives the stream number.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT StreamNumFromPin(IPin pPin, ushort* pwStreamNum);
    ///The <code>SetParam</code> method sets the value of the specified filter configuration parameter.
    ///Params:
    ///    dwParam = Specifies the parameter to set,as a member of the _AM_ASFWRITERCONFIG_PARAM enumeration.
    ///    dwParam1 = Specifies the value to assign to the <i>dwParam</i> parameter.
    ///    dwParam2 = Reserved. Must be zero.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetParam(uint dwParam, uint dwParam1, uint dwParam2);
    ///The <code>GetParam</code> method retrieves the current value of the specified filter configuration parameter.
    ///Params:
    ///    dwParam = Specifies the parameter to retrieve, as a member of the _AM_ASFWRITERCONFIG_PARAM enumeration.
    ///    pdwParam1 = Receives the value of the parameter specified in <i>dwParam</i>.
    ///    pdwParam2 = Reserved. Must be zero.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetParam(uint dwParam, uint* pdwParam1, uint* pdwParam2);
    ///The <code>ResetMultiPassState</code> method resets the filter when a preprocessing encoding pass is canceled
    ///before it is completed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VFW_E_NOT_STOPPED</b></dt> </dl> </td> <td width="60%"> The filter was not in a stopped state.
    ///    </td> </tr> </table>
    ///    
    HRESULT ResetMultiPassState();
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///The <code>IMultiMediaStream</code> interface is exposed by the AMMultimediaStream object. It contains methods for
///enumerating the media streams, retrieving information about them, and running and stopping them.
@GUID("B502D1BC-9A57-11D0-8FDE-00C04FD9189D")
interface IMultiMediaStream : IUnknown
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetInformation</code> method retrieves the capabilities of the multimedia stream object.
    ///Params:
    ///    pdwFlags = Pointer to a variable that receives a bitwise combination of the following flags. <table> <tr> <th>Value
    ///               </th> <th>Description </th> </tr> <tr> <td>MMSSF_ASYNCHRONOUS</td> <td>The object supports asynchronous
    ///               sample updates. This flag is always returned.</td> </tr> <tr> <td>MMSSF_HASCLOCK</td> <td>The object has a
    ///               clock.</td> </tr> <tr> <td>MMSSF_SUPPORTSEEK</td> <td>The object supports seeking.</td> </tr> </table> This
    ///               parameter can be <b>NULL</b>.
    ///    pStreamType = Pointer to a variable that receives a member of the STREAM_TYPE enumeration. This value indicates whether the
    ///                  multimedia stream is read-only, write-only, or read/write. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Unexpected error. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetInformation(uint* pdwFlags, STREAM_TYPE* pStreamType);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetMediaStream</code> method retrieves a media stream, specified by purpose ID.
    ///Params:
    ///    idPurpose = Reference to an MSPID that identifies the media stream to retrieve.
    ///    ppMediaStream = Address of variable that receives an IMediaStream interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MS_E_NOSTREAM</b></dt> </dl> </td>
    ///    <td width="60%"> No matching stream. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetMediaStream(GUID* idPurpose, IMediaStream* ppMediaStream);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>EnumMediaStreams</code> method retrieves a media stream object, specified by index.
    ///Params:
    ///    Index = Zero-based index of the media stream to retrieve.
    ///    ppMediaStream = Address of a variable that receives an IMediaStream interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> Index is out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT EnumMediaStreams(int Index, IMediaStream* ppMediaStream);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetState</code> method retrieves the current state of the multimedia stream object.
    ///Params:
    ///    pCurrentState = Pointer to a variable that receives a member of the STREAM_STATE enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetState(STREAM_STATE* pCurrentState);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SetState</code> method runs or stops the multimedia stream object.
    ///Params:
    ///    NewState = A member of the STREAM_STATE enumeration, specifying the new state (running or stopped).
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetState(STREAM_STATE NewState);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <b>GetTime</b> method retrieves the current stream time.
    ///Params:
    ///    pCurrentTime = Pointer to a variable that receives the stream time, in 100-nanosecond units.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> Could not get the stream time, or there is no clock. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetTime(long* pCurrentTime);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetDuration</code> method retrieves the duration of the multimedia stream.
    ///Params:
    ///    pDuration = Pointer to a variable that receives of the multimedia stream, in 100-nanosecond units.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
    ///    width="60%"> This multimedia stream does not support seeking. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer value. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MS_E_INVALIDSTREAMTYPE</b></dt> </dl> </td> <td width="60%"> This multimedia stream
    ///    is not read-only. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Could not determine the duration. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetDuration(long* pDuration);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>Seek</code> method seeks all of the media streams to a new position.
    ///Params:
    ///    SeekTime = STREAM_TIME value that specifies the new position.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
    ///    width="60%"> The media streams do not support seeking. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT Seek(long SeekTime);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetEndOfStreamEventHandle</code> method retrieves an event that is signaled when the multimedia
    ///stream completes playback.
    ///Params:
    ///    phEOS = Pointer to a variable that receives a handle to the event. The event is signaled when all of the streams in
    ///            the multimedia stream object complete playback.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MS_E_BUSY</b></dt> </dl> </td>
    ///    <td width="60%"> The multimedia stream is not stopped. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetEndOfStreamEventHandle(HANDLE* phEOS);
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///The <b>IMediaStream</b> interface provides access to the characteristics of a media stream, such as the stream's
///media type and purpose ID. It also has methods that create data samples. For sample code that implements the
///multimedia streaming interfaces, see Multimedia Streaming Sample Code. Implement this interface when you want to add
///media type-specific functionality to your media stream. This interface is implemented on multimedia stream objects.
///<b>IMediaStream</b> provides generic sample-creation methods, but you usually want to write a more powerful version
///of these methods that will take advantage of your media type's specific characteristics. Use this interface when your
///application needs to access a stream's media type information and create data samples.
@GUID("B502D1BD-9A57-11D0-8FDE-00C04FD9189D")
interface IMediaStream : IUnknown
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Retrieves a pointer to the multimedia stream that contains the specified media stream.
    ///Params:
    ///    ppMultiMediaStream = Address of a pointer to an IMultiMediaStream interface object that will point to the multimedia stream from
    ///                         which the current media stream was created.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if <i>ppMultiMediaStream</i> is invalid.
    ///    
    HRESULT GetMultiMediaStream(IMultiMediaStream* ppMultiMediaStream);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Retrieves the stream's purpose ID and media type.
    ///Params:
    ///    pPurposeId = Pointer to an <b>MSPID</b> value that will contain the stream's purpose ID (see Multimedia Streaming Data
    ///                 Types). If this parameter is <b>NULL</b> on entry, the method won't retrieve the purpose ID.
    ///    pType = Pointer to a STREAM_TYPE enumerated data type value that will contain the stream's media type. If this
    ///            parameter is <b>NULL</b> on entry, the method won't retrieve the media type.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if one of the parameters is invalid.
    ///    
    HRESULT GetInformation(GUID* pPurposeId, STREAM_TYPE* pType);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Sets the media stream to the same format as a previous stream.
    ///Params:
    ///    pStreamThatHasDesiredFormat = Pointer to a media stream object that has the same format.
    ///    dwFlags = Reserved for flag data. Must be zero.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if one of the parameters is invalid.
    ///    
    HRESULT SetSameFormat(IMediaStream pStreamThatHasDesiredFormat, uint dwFlags);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Allocates a new stream sample object for the current media stream.
    ///Params:
    ///    dwFlags = Flags. Must be zero.
    ///    ppSample = Address of a pointer to the newly created stream sample's IStreamSample interface.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There isn't enough memory
    ///    available to create a stream sample. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> A parameter is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT AllocateSample(uint dwFlags, IStreamSample* ppSample);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Creates a new stream sample that shares the same backing object as the existing sample.
    ///Params:
    ///    pExistingSample = Pointer to the existing sample.
    ///    dwFlags = Reserved for flag data. Must be zero.
    ///    ppNewSample = Address of a pointer to an IStreamSample interface that will point to the newly created shared sample.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There isn't enough memory
    ///    available to create the sample. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> One of the parameters is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MS_E_INCOMPATIBLE</b></dt> </dl> </td> <td width="60%"> The existing sample isn't compatible with the
    ///    specified media stream. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success; <i>ppNewSample</i> points to the newly created sample. </td> </tr> </table>
    ///    
    HRESULT CreateSharedSample(IStreamSample pExistingSample, uint dwFlags, IStreamSample* ppNewSample);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Forces the current stream to end. If the current stream isn't writable, this method does nothing.
    ///Params:
    ///    dwFlags = Reserved for flag data. Must be zero.
    ///Returns:
    ///    Returns S_OK if successful or MS_E_INCOMPATIBLE if the existing sample isn't compatible with the current
    ///    media stream.
    ///    
    HRESULT SendEndOfStream(uint dwFlags);
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///The <code>IStreamSample</code> interface provides control over the behavior of stream samples. You can retrieve the
///media stream that created the sample, set or retrieve sample start and stop times, check the sample's completion
///status, and perform a developer-specified function on the sample itself. Implement this interface when you implement
///a media stream for a new media type. The interface is exposed on sample objects created by media streams. Use this
///interface when you want to control data samples created by IMediaStream or its derived interfaces. In addition to the
///methods inherited from <b>IUnknown</b>, the <code>IStreamSample</code> interface exposes the following methods.
@GUID("B502D1BE-9A57-11D0-8FDE-00C04FD9189D")
interface IStreamSample : IUnknown
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Retrieves a pointer to the media stream object that created the current sample.
    ///Params:
    ///    ppMediaStream = Address of a pointer to an IMediaStream interface that will point to the media stream that created the
    ///                    current sample.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if <i>ppMediaStream</i> is invalid.
    ///    
    HRESULT GetMediaStream(IMediaStream* ppMediaStream);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Retrieves the current sample's start and end times. If the sample is updating, this method returns the
    ///times after the update completes.
    ///Params:
    ///    pStartTime = Pointer to a STREAM_TIME value that will contain the sample's start time.
    ///    pEndTime = Pointer to a STREAM_TIME value that will contain the sample's end time.
    ///    pCurrentTime = Pointer to a STREAM_TIMEvalue that will contain the media stream's current media time.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if one of the parameters is invalid.
    ///    
    HRESULT GetSampleTimes(long* pStartTime, long* pEndTime, long* pCurrentTime);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Sets the current sample's start and end times. You can call this method prior to updating the sample.
    ///Params:
    ///    pStartTime = Pointer to a STREAM_TIME value that contains the sample's new start time.
    ///    pEndTime = Pointer to a STREAM_TIME value that contains the sample's new end time.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if one of the parameters is <b>NULL</b>.
    ///    
    HRESULT SetSampleTimes(const(long)* pStartTime, const(long)* pEndTime);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Performs a synchronous or an asynchronous update on the current sample.
    ///Params:
    ///    dwFlags = Flag that specifies whether the update is synchronous or asynchronous. The SSUPDATE_ASYNC flag specifies an
    ///              asynchronous update, which you can set if both <i>hEvent</i> and <i>pfnAPC</i> are <b>NULL</b>. Use
    ///              SSUPDATE_CONTINUOUS to continuously update the sample until you call the IStreamSample::CompletionStatus
    ///              method.
    ///    hEvent = Handle to an event that this method will trigger when the update is complete.
    ///    pfnAPC = Pointer to a Win32 asynchronous procedure call (APC) function that this method will call after it completes
    ///             the sample update.
    ///    dwAPCData = Value that this method passes to the function specified by the <i>pfnAPC</i> parameter.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%"> The update aborted. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameters is
    ///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> One of
    ///    the parameters is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MS_E_BUSY</b></dt> </dl> </td> <td
    ///    width="60%"> This sample already has a pending update. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MS_S_ENDOFSTREAM</b></dt> </dl> </td> <td width="60%"> Reached the end of the stream; the sample
    ///    wasn't updated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MS_S_PENDING</b></dt> </dl> </td> <td
    ///    width="60%"> The asynchronous update is pending. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_COMMITTED</b></dt> </dl> </td> <td width="60%"> Cannot allocate a sample because the
    ///    allocator is not committed. </td> </tr> </table>
    ///    
    HRESULT Update(uint dwFlags, HANDLE hEvent, PAPCFUNC pfnAPC, size_t dwAPCData);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Retrieves the status of the current sample's latest asynchronous update. If the update isn't complete, you
    ///can force it to complete.
    ///Params:
    ///    dwFlags = Value that specifies whether to forcibly complete the update. This value is a combination of one or more of
    ///              the following flags. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>COMPSTAT_NOUPDATEOK
    ///              (0x01)</td> <td>Force the update to complete as soon as possible, even if the sample update isn't yet
    ///              complete. If the sample is updating and you didn't set the COMPSTAT_WAIT flag, the method returns
    ///              MS_S_PENDING. If the sample is waiting to be updated, this method removes it from the queue and returns
    ///              MS_S_NOTUPDATED.</td> </tr> <tr> <td>COMPSTAT_WAIT (0x02)</td> <td>Wait until the sample finishes updating
    ///              before returning from this method.</td> </tr> <tr> <td>COMPSTAT_ABORT (0x04)</td> <td>Forces the update to
    ///              complete, even if it's currently updating. This leaves the sample data in an undefined state. Combine this
    ///              value with the COMPSTAT_WAITFORCOMPLETION flag to ensure that the update canceled.</td> </tr> </table>
    ///    dwMilliseconds = If the <i>dwFlags</i> parameter is COMPSTAT_WAIT, this value is the number of milliseconds to wait for the
    ///                     update to complete. Specify INFINITE to indicate that you want to wait until the sample updates before this
    ///                     call returns.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%"> The update aborted. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>MS_S_ENDOFSTREAM</b></dt> </dl> </td> <td width="60%"> The sample wasn't updated
    ///    because it reached the end of the stream. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MS_S_NOUPDATE</b></dt> </dl> </td> <td width="60%"> The update was forcibly completed; the sample was
    ///    not updated by the stream. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MS_S_PENDING</b></dt> </dl> </td>
    ///    <td width="60%"> An asynchronous update is pending. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT CompletionStatus(uint dwFlags, uint dwMilliseconds);
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///The <code>IDirectDrawMediaStream</code> interface controls media streams that appear on Microsoft DirectDraw
///surfaces. To stream to a DirectDraw surface, DirectDraw must support the video stream format. For sample code that
///implements the multimedia streaming interfaces, see Multimedia Streaming Sample Code. This interface isn't intended
///for implementation by application developers. It is exposed on DirectDraw media streams that can be added to a
///DirectShow multimedia stream. Use this interface when you want to send a video stream to a DirectDraw surface.
@GUID("F4104FCE-9A70-11D0-8FDE-00C04FD9189D")
interface IDirectDrawMediaStream : IMediaStream
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Retrieves the current media stream's format and, optionally, its desired format.
    ///Params:
    ///    pDDSDCurrent = Pointer to a DirectDraw surface description that will contain the current media stream's format.
    ///    ppDirectDrawPalette = Address of a pointer to an <b>IDirectDrawPalette</b> interface if one exists.
    ///    pDDSDDesired = Pointer to a DirectDraw surface description that will contain the current media stream's desired format.
    ///    pdwFlags = Pointer to the flags set in a <b>DDSURFACEDESC</b> structure. Flags of interest include: <table> <tr>
    ///               <th>Flag </th> <th>Description </th> </tr> <tr> <td>DDSD_CAPS</td> <td>Indicates that the surface capability
    ///               member of the structure is valid.</td> </tr> <tr> <td>DDSD_HEIGHT</td> <td>Indicates that the height member
    ///               of the structure is valid.</td> </tr> <tr> <td>DDSD_PIXELFORMAT</td> <td>Indicates that the pixel format
    ///               member of the structure is valid.</td> </tr> <tr> <td>DDSD_WIDTH</td> <td>Indicates that the width member of
    ///               the structure is valid.</td> </tr> </table>
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>DDERR_INVALIDPARAMS</b></dt> </dl> </td> <td width="60%"> One of the DirectDraw
    ///    surface parameters is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> One or more of the required parameters is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetFormat(DDSURFACEDESC* pDDSDCurrent, IDirectDrawPalette* ppDirectDrawPalette, 
                      DDSURFACEDESC* pDDSDDesired, uint* pdwFlags);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Sets the format of the current media stream.
    ///Params:
    ///    pDDSurfaceDesc = Pointer to a DirectDraw surface description that contains the new format.
    ///    pDirectDrawPalette = Optional parameter that is a pointer to an <b>IDirectDrawPalette</b> interface.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>DDERR_INVALIDSURFACETYPE</b></dt> </dl> </td> <td width="60%"> The specified format
    ///    is incompatible with the current stream. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MS_E_SAMPLEALLOC</b></dt> </dl> </td> <td width="60%"> Can't change the format because one or more
    ///    stream samples are already allocated for this stream. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetFormat(const(DDSURFACEDESC)* pDDSurfaceDesc, IDirectDrawPalette pDirectDrawPalette);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Retrieves a pointer to the DirectDraw object used by the current media stream.
    ///Params:
    ///    ppDirectDraw = Address of a pointer to an <b>IDirectDraw</b> interface that will contain the current media stream's
    ///                   associated DirectDraw object.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if the parameter is invalid.
    ///    
    HRESULT GetDirectDraw(IDirectDraw* ppDirectDraw);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Sets the current media stream's DirectDraw object.
    ///Params:
    ///    pDirectDraw = Pointer to an <b>IDirectDraw</b> interface that contains the media stream's new DirectDraw object.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if the pointer is invalid.
    ///    
    HRESULT SetDirectDraw(IDirectDraw pDirectDraw);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Creates a stream sample using the specified DirectDraw surface object.
    ///Params:
    ///    pSurface = Pointer to an existing DirectDraw surface. Use <b>QueryInterface</b> to obtain the <b>IDirectDrawSurface</b>
    ///               interface from an <b>IDirectDrawSurface7</b> interface pointer.
    ///    pRect = Pointer to the clipping rectangle you want to use with the specified surface. Set this parameter to
    ///            <b>NULL</b> if you want to use the entire surface.
    ///    dwFlags = Specifies miscellaneous flags. The following flag is defined: <table> <tr> <th>Value </th> <th>Description
    ///              </th> </tr> <tr> <td>DDSFF_PROGRESSIVERENDER</td> <td>If this flag is set, sample updates are performed
    ///              directly on the surface. When this flag is absent, if the decoder uses delta frames, an extra copy is
    ///              performed internally. Setting this flag can improve performance but can also introduce tearing.</td> </tr>
    ///              </table>
    ///    ppSample = Address of a pointer to an IDirectDrawStreamSample interface that will point to the newly created sample.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>DDERR_INVALIDPIXELFORMAT</b></dt> </dl> </td> <td width="60%"> The specified pixel
    ///    format is incompatible with the stream format. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DDERR_INVALIDRECT</b></dt> </dl> </td> <td width="60%"> The specified clipping rectangle is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DDERR_INVALIDSURFACETYPE</b></dt> </dl> </td> <td width="60%">
    ///    The specified surface is incompatible with the stream format. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> One or more of the required parameters is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MS_E_SAMPLEALLOC</b></dt> </dl> </td> <td width="60%"> The
    ///    stream already has allocated samples and the surface doesn't match the sample format. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT CreateSample(IDirectDrawSurface pSurface, const(RECT)* pRect, uint dwFlags, 
                         IDirectDrawStreamSample* ppSample);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Retrieves the average frames per second from a video stream.
    ///Params:
    ///    pFrameTime = Pointer to a <b>STREAM_TIME</b> value that indicates the average time per frame in 100-nanosecond units. (See
    ///                 Multimedia Streaming Data Types.)
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if the pointer is invalid.
    ///    
    HRESULT GetTimePerFrame(long* pFrameTime);
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///The <code>IDirectDrawStreamSample</code> interface provides methods that set and retrieve pointers to the Microsoft
///DirectDraw surface associated with the current stream sample. This interface isn't intended for implementation by
///application developers. It is exposed by sample objects created by the DirectDraw stream. Use this interface when
///applications need to set clipping rectangles and retrieve the rendering surface for DirectDraw stream samples.
@GUID("F4104FCF-9A70-11D0-8FDE-00C04FD9189D")
interface IDirectDrawStreamSample : IStreamSample
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Retrieves pointers to the current sample's DirectDraw surface and associated clipping rectangle.
    ///Params:
    ///    ppDirectDrawSurface = Address of a pointer to an <b>IDirectDrawSurface</b> interface that specifies the sample's new surface. Set
    ///                          this parameter to <b>NULL</b> if you don't want to specify a new surface.
    ///    pRect = Pointer to a <b>RECT</b> structure that will contain the current sample's clipping rectangle. Set this
    ///            parameter to <b>NULL</b> if you don't want to retrieve the clipping rectangle.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetSurface(IDirectDrawSurface* ppDirectDrawSurface, RECT* pRect);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Changes the clipping rectangle for a sample.
    ///Params:
    ///    pRect = Pointer to a <b>RECT</b> structure that specifies the stream's new clipping rectangle.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>DDERR_INVALIDPIXELFORMAT</b></dt> </dl> </td> <td width="60%"> The stream isn't
    ///    compatible with the pixel format. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DDERR_INVALIDRECT</b></dt>
    ///    </dl> </td> <td width="60%"> The specified rectangle is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DDERR_INVALIDSURFACETYPE</b></dt> </dl> </td> <td width="60%"> The stream isn't compatible with the
    ///    surface. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> One of
    ///    the pointers is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MS_E_SAMPLEALLOC</b></dt> </dl> </td>
    ///    <td width="60%"> The stream format doesn't match the surface and samples are currently allocated to the
    ///    stream. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetRect(const(RECT)* pRect);
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///The <code>IAudioMediaStream</code> interface controls audio media streams by providing methods that set and get the
///stream's format. This interface inherits from the IMediaStream interface and is used to create one or more
///IAudioStreamSample objects. You can also use it to set and retrieve the stream data's current format. This interface
///is currently defined only for PCM format audio data. For sample code that implements the audio streaming interfaces,
///see Multimedia Streaming Sample Code. Like video, audio is contained in a self-describing container object. Implement
///this interface when an object needs to control streaming audio. Use this interface when you want to generate audio in
///your application.
@GUID("F7537560-A3BE-11D0-8212-00C04FC32C45")
interface IAudioMediaStream : IMediaStream
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Retrieves the stream data's current format.
    ///Params:
    ///    pWaveFormatCurrent = Pointer to a WAVEFORMATEX structure that contains the stream data's current format.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if the required parameter is <b>NULL</b>.
    ///    
    HRESULT GetFormat(WAVEFORMATEX* pWaveFormatCurrent);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Sets the format for the stream.
    ///Params:
    ///    lpWaveFormat = Pointer to a WAVEFORMATEX structure that contains stream format information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value, which can include the following values or others not listed. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>MS_E_INCOMPATIBLE</b></dt>
    ///    </dl> </td> <td width="60%"> Format of the IAudioData object is not compatible with stream. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetFormat(const(WAVEFORMATEX)* lpWaveFormat);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Creates an audio stream sample for use with the specified stream.
    ///Params:
    ///    pAudioData = Pointer to an IAudioData container. <b>IAudioData</b> objects can be referenced by samples in more than one
    ///                 stream.
    ///    dwFlags = Reserved for flag data. Must be zero.
    ///    ppSample = Address of a pointer to the new IAudioStreamSample interface.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if one or more of the required parameters are <b>NULL</b>.
    ///    
    HRESULT CreateSample(IAudioData pAudioData, uint dwFlags, IAudioStreamSample* ppSample);
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///The <code>IAudioStreamSample</code> interface retrieves information from the underlying IAudioData data objects. For
///sample code that implements the audio streaming interfaces, see Multimedia Streaming Sample Code. Implement this
///interface on audio stream sample objects when they need access to an IAudioData object's data. Use this interface
///when your application needs to access an IAudioData object's data for its audio stream.
@GUID("345FEE00-ABA5-11D0-8212-00C04FC32C45")
interface IAudioStreamSample : IStreamSample
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Retrieves the address of a pointer to the IAudioData object associated with the sample.
    ///Params:
    ///    ppAudio = Address of a pointer to the IAudioData object.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if the parameter is <b>NULL</b>.
    ///    
    HRESULT GetAudioData(IAudioData* ppAudio);
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///The <code>IMemoryData</code> interface contains methods that set and retrieve memory data on audio data objects.
///Audio data objects provide the underlying data which stream samples access. This interface provides a way to
///initialize memory buffers and to set actual amounts of audio data in the objects. Additionally, the GetInfo method
///can be used to retrieve audio memory data. Implement this interface on underlying audio data objects that audio
///stream sample objects will access. Typically these methods are called by the IAudioMediaStream or IAudioStreamSample
///object, rather than by the application. In addition to the methods inherited from <b>IUnknown</b>, the
///<code>IMemoryData</code> interface exposes the following methods.
@GUID("327FC560-AF60-11D0-8212-00C04FC32C45")
interface IMemoryData : IUnknown
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Initializes a memory buffer with a pointer to memory and length.
    ///Params:
    ///    cbSize = Size of memory pointed to by <i>pbData</i>, in bytes.
    ///    pbData = Pointer to memory that this object will use.
    ///    dwFlags = Reserved for flag data. Must be zero.
    ///Returns:
    ///    Returns S_OK if successful or E_INVALIDARG if <i>cbSize</i> is zero or <i>pbData</i> is <b>NULL</b>.
    ///    
    HRESULT SetBuffer(uint cbSize, ubyte* pbData, uint dwFlags);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Retrieves information describing an audio data object.
    ///Params:
    ///    pdwLength = Length of memory in bytes, if non-<b>NULL</b>.
    ///    ppbData = Pointer to the memory, if non-<b>NULL</b>.
    ///    pcbActualData = Length of data in bytes, if non-<b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetInfo(uint* pdwLength, ubyte** ppbData, uint* pcbActualData);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> Sets the amount of audio data currently in the object.
    ///Params:
    ///    cbDataValid = Amount of data, in bytes.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if the required parameter is <b>NULL</b>.
    ///    
    HRESULT SetActual(uint cbDataValid);
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///The <code>IAudioData</code> interface provides methods that enable applications to set and get the underlying audio
///data that audio streams will reference. The audio data format is set in the WAVEFORMATEX structure. Implement this
///interface on underlying audio data objects that audio stream sample objects will access. Applications use this
///interface to set and retrieve information on underlying data objects that an audio stream will reference.
@GUID("54C719C0-AF60-11D0-8212-00C04FC32C45")
interface IAudioData : IMemoryData
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetFormat</code> method retrieves the current data format.
    ///Params:
    ///    pWaveFormatCurrent = Pointer to a WAVEFORMATEX structure that contains the current data format.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if pointer is invalid.
    ///    
    HRESULT GetFormat(WAVEFORMATEX* pWaveFormatCurrent);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SetFormat</code> method sets the current data format.
    ///Params:
    ///    lpWaveFormat = Pointer to a WAVEFORMATEX structure that will contain the current data format.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value, which can include the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    Invalid pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid format. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetFormat(const(WAVEFORMATEX)* lpWaveFormat);
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///The <code>IAMMultiMediaStream</code> interface is supported by the multimedia stream object. It contains methods for
///creating the underlying filter graph that the object manages.
@GUID("BEBE595C-9A6F-11D0-8FDE-00C04FD9189D")
interface IAMMultiMediaStream : IMultiMediaStream
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>Initialize</code> method initializes the multimedia stream object.
    ///Params:
    ///    StreamType = Member of the STREAM_TYPE enumeration, specifying whether the streams are read-only, write-only, or
    ///                 read/write.
    ///    dwFlags = Must be one of the following values: <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///              <td>Zero</td> <td>Create a filter graph that runs on a separate thread.</td> </tr> <tr>
    ///              <td>AMMSF_NOGRAPHTHREAD</td> <td>Create a filter graph that runs on the calling thread.</td> </tr> </table>
    ///    pFilterGraph = [optional] Pointer to the IGraphBuilder interface, or <b>NULL</b>. If this parameter is non-<b>NULL</b>, it
    ///                   specifies a filter graph that the multimedia stream object will use. Otherwise, the multimedia stream object
    ///                   creates a new filter graph.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT Initialize(STREAM_TYPE StreamType, uint dwFlags, IGraphBuilder pFilterGraph);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetFilterGraph</code> method retrieves the Filter Graph Manager that is managed by the
    ///multimedia stream object.
    ///Params:
    ///    ppGraphBuilder = Address of a variable that receives an IGraphBuilder interface pointer. If there is no filter graph
    ///                     associated with the multimedia stream object, the returned pointer is <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetFilterGraph(IGraphBuilder* ppGraphBuilder);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetFilter</code> method retrieves the Media Stream filter, which is used internally by the
    ///multimedia stream object.
    ///Params:
    ///    ppFilter = Address of a variable that receives an IMediaStreamFilter interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetFilter(IMediaStreamFilter* ppFilter);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>AddMediaStream</code> method adds a new media stream to the filter graph.
    ///Params:
    ///    pStreamObject = Pointer to the <b>IUnknown</b> interface of an object that is used to create the new media stream. This
    ///                    parameter can be <b>NULL</b>. See Remarks for more information.
    ///    PurposeId = Pointer an MSPID the specifies the type of media stream to create. This parameter can be <b>NULL</b>.
    ///    dwFlags = Bitwise combination of zero or more of the following flags. <table> <tr> <th>Value </th> <th>Description
    ///              </th> </tr> <tr> <td>AMMSF_ADDDEFAULTRENDERER</td> <td>Add a default renderer (audio streams only).</td>
    ///              </tr> <tr> <td>AMMSF_CREATEPEER</td> <td>Create a new stream based on the object specified in
    ///              <i>pStreamObject</i>.</td> </tr> <tr> <td>AMMSF_NOSTALL</td> <td>Create a stream that does not block waiting
    ///              for <b>Update</b> calls.</td> </tr> <tr> <td>AMMSF_STOPIFNOSAMPLES</td> <td>Create a stream that stops if
    ///              there are not samples.</td> </tr> </table>
    ///    ppNewStream = Address of a variable that receives an IMediaStream interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MS_E_PURPOSEID</b></dt> </dl> </td> <td width="60%"> Invalid purpose ID. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT AddMediaStream(IUnknown pStreamObject, const(GUID)* PurposeId, uint dwFlags, IMediaStream* ppNewStream);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>OpenFile</code> method opens and automatically creates a filter graph for the specified media
    ///file. If DirectShow doesn't support the file format, this method does nothing.
    ///Params:
    ///    pszFileName = Pointer to the name of the file you want to open.
    ///    dwFlags = Value that modifies how the filter graph will render the specified file. This value is a combination of one
    ///              or more of the following flags. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///              <td>AMMSF_NOCLOCK</td> <td>Run the stream with no clock.</td> </tr> <tr> <td>AMMSF_NORENDER</td> <td>Open the
    ///              file, but do not render any streams. This flag should always be accompanied with the AMMSF_RUN flag.</td>
    ///              </tr> <tr> <td>AMMSF_RENDERALLSTREAMS</td> <td>Render all streams, including those that do not have an
    ///              existing media stream.</td> </tr> <tr> <td>AMMSF_RENDERTOEXISTING</td> <td>Only render to existing
    ///              streams.</td> </tr> <tr> <td>AMMSF_RUN</td> <td>Set the stream into the run state.</td> </tr> </table>
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>dwFlags</i> parameter is
    ///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> This
    ///    method tried to access an invalid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT OpenFile(const(wchar)* pszFileName, uint dwFlags);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>OpenMoniker</code> method opens a file or device moniker; you can read media data from this
    ///moniker if DirectShow supports the moniker.
    ///Params:
    ///    pCtx = Pointer to the bind context associated with the moniker.
    ///    pMoniker = Pointer to an <b>IMoniker</b> interface that specifies the moniker you want to open.
    ///    dwFlags = Value that modifies how the filter graph will render the specified file. This value is a combination of one
    ///              or more of the following flags. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///              <td>AMMSF_NOCLOCK</td> <td>Run the stream with no clock.</td> </tr> <tr> <td>AMMSF_NORENDER</td> <td>Open the
    ///              file, but do not render any streams. This flag should always be accompanied with the AMMSF_RUN flag.</td>
    ///              </tr> <tr> <td>AMMSF_RENDERALLSTREAMS</td> <td>Render all streams, including those that do not have an
    ///              existing media stream.</td> </tr> <tr> <td>AMMSF_RENDERTOEXISTING</td> <td>Only render to existing
    ///              streams.</td> </tr> <tr> <td>AMMSF_RUN</td> <td>Set the stream into the run state.</td> </tr> </table>
    ///Returns:
    ///    Returns S_OK if successful or E_INVALIDARG if the <i>dwFlags</i> parameter is invalid.
    ///    
    HRESULT OpenMoniker(IBindCtx pCtx, IMoniker pMoniker, uint dwFlags);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>Render</code> method renders the current filter graph.
    ///Params:
    ///    dwFlags = Value that specifies how the filter graph renders the current multimedia stream. This value currently must be
    ///              AMMSF_NOCLOCK.
    ///Returns:
    ///    Returns S_OK if successful or E_INVALIDARG if the <i>dwFlags</i> parameter is invalid.
    ///    
    HRESULT Render(uint dwFlags);
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///The <code>IAMMediaStream</code> interface handles the internal connections between Microsoft DirectShow filters and
///filter graphs in applications that use multimedia streaming. This enables applications to automatically negotiate the
///transfer and conversion of data from the source to the application without having to write code to handle the
///connection, transfer of data, data conversion, and actual data rendering or file storage. This provides a uniform and
///predictable method of data access and control. This interface isn't intended for implementation or use by application
///developers.
@GUID("BEBE595D-9A6F-11D0-8FDE-00C04FD9189D")
interface IAMMediaStream : IMediaStream
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>Initialize</code> method creates and initializes a new media stream with the specified stream
    ///type and purpose ID.
    ///Params:
    ///    pSourceObject = Pointer to an <b>IUnknown</b> source object.
    ///    dwFlags = Value that modifies the media stream's behavior; it is a combination of one or more of the following values.
    ///              <table> <tr> <th>Value </th> <th>Description</th> </tr> <tr> <td>AMMSF_ADDDEFAULTRENDERER</td> <td>Add a
    ///              default renderer.</td> </tr> <tr> <td>AMMSF_CREATEPEER</td> <td>Create a peer stream based on the same object
    ///              as a <i>pStreamObject</i>.</td> </tr> <tr> <td>AMMSF_NOSTALL</td> <td>Run the stream even if Update is not
    ///              called.</td> </tr> <tr> <td>AMMSF_STOPIFNOSAMPLES</td> <td>Terminates the stream if no samples were created
    ///              or if the last sample is deleted.</td> </tr> </table>
    ///    PurposeId = Purpose ID for the new media stream.
    ///    StreamType = STREAM_TYPE enumeration value that specifies the new media stream's media type.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if one or more of the required parameters are invalid.
    ///    
    HRESULT Initialize(IUnknown pSourceObject, uint dwFlags, GUID* PurposeId, const(STREAM_TYPE) StreamType);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SetState</code> method sets the filter state.
    ///Params:
    ///    State = Sets the filter's state, as specified by the FILTER_STATE enumerated type.
    ///Returns:
    ///    Returns S_OK if successful or E_INVALIDARG if the <i>State</i> parameter is invalid.
    ///    
    HRESULT SetState(FILTER_STATE State);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The IAMMultiMediaStream::AddMediaStream method calls this method, which adds the specified media stream to
    ///the current multimedia stream.
    ///Params:
    ///    pAMMultiMediaStream = Pointer to the IAMMultiMediaStream object to add the current media stream to.
    ///Returns:
    ///    Returns S_OK if successful or MS_E_SAMPLEALLOC if the media stream already has allocated stream samples.
    ///    
    HRESULT JoinAMMultiMediaStream(IAMMultiMediaStream pAMMultiMediaStream);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>JoinFilter</code> method connects a media stream to the Media Stream filter, which is used
    ///internally by the multimedia stream object. Applications should not call this method.
    ///Params:
    ///    pMediaStreamFilter = Pointer to the filter's IMediaStreamFilter interface.
    ///Returns:
    ///    Returns S_OK if successful.
    ///    
    HRESULT JoinFilter(IMediaStreamFilter pMediaStreamFilter);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>JoinFilterGraph</code> method connects a media stream filter to a filter graph.
    ///Params:
    ///    pFilterGraph = Pointer to the current media stream filter to add to the specified filter graph.
    ///Returns:
    ///    Returns S_OK if successful or E_POINTER if <i>pGraph</i> is <b>NULL</b>.
    ///    
    HRESULT JoinFilterGraph(IFilterGraph pFilterGraph);
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///The <code>IMediaStreamFilter</code> interface is supported by the Media Stream filter, which is used internally by
///the multimedia stream object. Applications should not use this interface.
@GUID("BEBE595E-9A6F-11D0-8FDE-00C04FD9189D")
interface IMediaStreamFilter : IBaseFilter
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>AddMediaStream</code> method connects a media stream object to the underlying filter graph.
    ///Params:
    ///    pAMMediaStream = Pointer to the media stream object's IAMMediaStream interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MS_E_PURPOSEID</b></dt> </dl>
    ///    </td> <td width="60%"> Duplicate purpose ID </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT AddMediaStream(IAMMediaStream pAMMediaStream);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetMediaStream</code> method retrieves a media stream, specified by purpose ID.
    ///Params:
    ///    idPurpose = Reference to an MSPID value that specifies which stream to retrieve.
    ///    ppMediaStream = Address of a variable that receives an IMediaStream interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MS_E_NOSTREAM</b></dt> </dl>
    ///    </td> <td width="60%"> No matching stream was found. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetMediaStream(GUID* idPurpose, IMediaStream* ppMediaStream);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>EnumMediaStreams</code> method retrieves a media stream, specified by index.
    ///Params:
    ///    Index = Index of the media stream to retrieve.
    ///    ppMediaStream = Address of a variable that receives an IMediaStream interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Index out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT EnumMediaStreams(int Index, IMediaStream* ppMediaStream);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SupportSeeking</code> method initializes the filter to support seeking. The multimedia stream
    ///object calls this method.
    ///Params:
    ///    bRenderer = Boolean value that specifies whether the streams are being rendered. Use the value <b>TRUE</b> if the stream
    ///                type is STREAMTYPE_READ, or <b>FALSE</b> otherwise.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
    ///    width="60%"> The graph does not contain any seekable streams. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SupportSeeking(BOOL bRenderer);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <b>ReferenceTimeToStreamTime</b> method converts a reference time to stream time.
    ///Params:
    ///    pTime = On input, specifies the reference time to convert. On output, contains the equivalent stream time.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    The graph does not have a reference clock. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT ReferenceTimeToStreamTime(long* pTime);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <b>GetCurrentStreamTime</b> method retrieves the current stream time.
    ///Params:
    ///    pCurrentStreamTime = Pointer to a variable that receives the stream time, in 100-nanosecond units.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> The graph is not running, or there is no reference clock. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetCurrentStreamTime(long* pCurrentStreamTime);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <b>WaitUntil</b> method causes the filter to block until a specified stream time. The filter's pins
    ///call this method. They can interrupt the wait by flushing the filter.
    ///Params:
    ///    WaitStreamTime = Specifies the stream time, in 100-nanosecond units.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The wait
    ///    was interrupted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT WaitUntil(long WaitStreamTime);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>Flush</code> method notifies the filter that one of its pins has flushed data. The filter's
    ///input pins call this method.
    ///Params:
    ///    bCancelEOS = Boolean value that indicates whether to cancel the pin's previous end-of-stream notification. If <b>TRUE</b>,
    ///                 the filter decrements the internal end-of-stream count.
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT Flush(BOOL bCancelEOS);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>EndOfStream</code> method signals the end of a stream. The Media Stream filter's input pins call
    ///this method on the filter.
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT EndOfStream();
}

///The <code>IDirectDrawMediaSampleAllocator</code> interface allocates samples that contain DirectDraw surfaces. The
///Overlay Mixer filter's input pin creates an allocator that implements this interface. This allocator allocates
///IDirectDrawMediaSample media samples that also support the IMediaSample interface. Decoder filters should not have to
///use this interface to connect to the Overlay Mixer. Applications never use this interface.
@GUID("AB6B4AFC-F6E4-11D0-900D-00C04FD9189D")
interface IDirectDrawMediaSampleAllocator : IUnknown
{
    ///The <code>GetDirectDraw</code> method retrieves a pointer to the DirectDraw instance used to allocate surfaces.
    ///Params:
    ///    ppDirectDraw = Address of a pointer that receives the DirectDraw object's <b>IDirectDraw</b> interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetDirectDraw(IDirectDraw* ppDirectDraw);
}

///The <code>IDirectDrawMediaSample</code> interface provides access to DirectDraw surfaces allocated by the Overlay
///Mixer filter. The allocator for the Overlay Mixer filter creates samples that expose this interface. These samples
///are used for connections between the Overlay Mixer and upstream decoder filters. Decoder filters can use this
///interface to unlock the DirectDraw surface while still holding it, so that other components can access the surface.
///Samples that support this interface also support the IMediaSample interface. The Overlay Mixer's allocator exposes
///the IDirectDrawMediaSampleAllocator.
@GUID("AB6B4AFE-F6E4-11D0-900D-00C04FD9189D")
interface IDirectDrawMediaSample : IUnknown
{
    ///The <code>GetSurfaceAndReleaseLock</code> method retrieves and unlocks the surface that the sample represents.
    ///Params:
    ///    ppDirectDrawSurface = Address of a pointer to the sample's <b>IDirectDrawSurface</b> interface.
    ///    pRect = Pointer to a variable that receives the address of the rectangle defining the part of the surface that the
    ///            sample represents.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetSurfaceAndReleaseLock(IDirectDrawSurface* ppDirectDrawSurface, RECT* pRect);
    ///The <code>LockMediaSamplePointer</code> method locks the surface that the sample represents.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT LockMediaSamplePointer();
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///This interface contains methods for creating multimedia streams with arbitrary media types. Use this interface if you
///need to create a multimedia stream with a format that is not supported by the other Microsoft DirectShow multimedia
///streaming interfaces. <div class="alert"><b>Note</b> For video streams, use the IDirectDrawMediaStream interface
///instead of this interface. For audio streams, use the IAudioMediaStream interface.</div> <div> </div>
@GUID("AB6B4AFA-F6E4-11D0-900D-00C04FD9189D")
interface IAMMediaTypeStream : IMediaStream
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetFormat</code> method retrieves the format of the stream.
    ///Params:
    ///    pMediaType = Pointer to an AM_MEDIA_TYPE structure that receives the stream format.
    ///    dwFlags = Reserved.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MS_E_NOSTREAM</b></dt> </dl> </td> <td width="60%"> No stream is associated with
    ///    this object. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT GetFormat(AM_MEDIA_TYPE* pMediaType, uint dwFlags);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SetFormat</code> method sets the format of the stream.
    ///Params:
    ///    pMediaType = Pointer to an AM_MEDIA_TYPE structure that contains the stream format.
    ///    dwFlags = Reserved.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MS_E_SAMPLEALLOC</b></dt> </dl> </td> <td width="60%"> The stream has already
    ///    allocated a sample with another media type. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetFormat(AM_MEDIA_TYPE* pMediaType, uint dwFlags);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>CreateSample</code> method creates a stream sample and optionally specifies the sample buffer.
    ///Params:
    ///    lSampleSize = Size of the sample.
    ///    pbBuffer = [optional] Pointer to an array of bytes that contains the sample data, or <b>NULL</b>.
    ///    dwFlags = Reserved.
    ///    pUnkOuter = [optional] Pointer to the interface of an object that aggregates the stream sample.
    ///    ppAMMediaTypeSample = Address of an IAMMediaTypeSample interface pointer that receives a pointer to the created sample.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> </table>
    ///    
    HRESULT CreateSample(int lSampleSize, ubyte* pbBuffer, uint dwFlags, IUnknown pUnkOuter, 
                         IAMMediaTypeSample* ppAMMediaTypeSample);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetStreamAllocatorRequirements</code> retrieves the allocator requirements for the stream. This
    ///method is not currently implemented.
    ///Params:
    ///    pProps = Pointer to an ALLOCATOR_PROPERTIES structure that receives the stream allocator requirements.
    ///Returns:
    ///    Returns E_FAIL.
    ///    
    HRESULT GetStreamAllocatorRequirements(ALLOCATOR_PROPERTIES* pProps);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SetStreamAllocatorRequirements</code> sets the allocator requirements for the stream. This
    ///method is not currently implemented.
    ///Params:
    ///    pProps = Pointer to an ALLOCATOR_PROPERTIES structure that contains the stream allocator requirements.
    ///Returns:
    ///    Returns E_FAIL.
    ///    
    HRESULT SetStreamAllocatorRequirements(ALLOCATOR_PROPERTIES* pProps);
}

///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div> </div>
///This interface contains methods for manipulating stream samples with arbitrary media types. Call the
///IAMMediaTypeStream::CreateSample method to create a sample that exposes this interface. The methods in this interface
///parallel those of the IMediaSample interface, although <b>IAMMediaTypeSample</b> contains a SetPointer method in
///addition to the GetPointer method.
@GUID("AB6B4AFB-F6E4-11D0-900D-00C04FD9189D")
interface IAMMediaTypeSample : IStreamSample
{
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SetPointer</code> method sets the pointer to the media sample's memory buffer.
    ///Params:
    ///    pBuffer = Pointer to a memory buffer allocated by the caller, or <b>NULL</b>.
    ///    lSize = Size of the buffer, in bytes.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetPointer(ubyte* pBuffer, int lSize);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetPointer</code> method retrieves a read/write pointer to the buffer's memory.
    ///Params:
    ///    ppBuffer = Address of a pointer to the buffer.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT GetPointer(ubyte** ppBuffer);
    ///> [!NOTE] > This interface is deprecated. New applications should not use it. The <code>GetSize</code> method
    ///retrieves the size of the buffer data area, in bytes.
    ///Returns:
    ///    Returns the size of the buffer data area, in bytes.
    ///    
    int     GetSize();
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetTime</code> method retrieves the stream times at which the sample should start and stop.
    ///Params:
    ///    pTimeStart = Pointer to a variable that receives the start time.
    ///    pTimeEnd = Pointer to a variable that receives the stop time. If the sample has no stop time, the value is set to the
    ///               start time plus one.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_SAMPLE_TIME_NOT_SET</b></dt> </dl> </td> <td width="60%"> The sample does not
    ///    have any time stamps. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_S_NO_STOP_TIME</b></dt> </dl> </td>
    ///    <td width="60%"> The sample has a valid start time but no stop time. </td> </tr> </table>
    ///    
    HRESULT GetTime(long* pTimeStart, long* pTimeEnd);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SetTime</code> method sets the stream times at which the sample should start and stop.
    ///Params:
    ///    pTimeStart = Pointer to a variable that contains the start time.
    ///    pTimeEnd = Pointer to a variable that contains the stop time.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT SetTime(long* pTimeStart, long* pTimeEnd);
    ///> [!NOTE] > This interface is deprecated. New applications should not use it. The <code>IsSyncPoint</code> method
    ///determines if the beginning of a sample is a synchronization point.
    ///Returns:
    ///    Returns S_OK if the beginning of the sample is a synchronization point, or S_FALSE otherwise.
    ///    
    HRESULT IsSyncPoint();
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SetSyncPoint</code> method specifies whether the beginning of this sample is a synchronization
    ///point.
    ///Params:
    ///    bIsSyncPoint = Boolean value that specifies whether the beginning of this sample is a synchronization point. If <b>TRUE</b>,
    ///                   the beginning of the sample is a synchronization point.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT SetSyncPoint(BOOL bIsSyncPoint);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>IsPreroll</code> method determines if this sample is part of the preroll. A preroll sample
    ///should not be displayed.
    ///Returns:
    ///    Returns S_OK if the sample is a preroll sample, or S_FALSE otherwise.
    ///    
    HRESULT IsPreroll();
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SetPreroll</code> method specifies whether this is a preroll sample. A preroll sample should not
    ///be displayed.
    ///Params:
    ///    bIsPreroll = Boolean value that specifies whether the sample is a preroll sample. If <b>TRUE</b>, it is for preroll and
    ///                 should not be displayed.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT SetPreroll(BOOL bIsPreroll);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetActualDataLength</code> method retrieves the data length of the sample, in bytes.
    ///Returns:
    ///    Returns the data length of the sample, in bytes.
    ///    
    int     GetActualDataLength();
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SetActualDataLength</code> method sets the sample's data length.
    ///Params:
    ///    __MIDL__IAMMediaTypeSample0000 = Length of the data in the media sample, in bytes.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_BUFFER_OVERFLOW</b></dt> </dl> </td> <td width="60%"> The buffer is not big
    ///    enough. </td> </tr> </table>
    ///    
    HRESULT SetActualDataLength(int __MIDL__IAMMediaTypeSample0000);
    ///> [!NOTE] > This interface is deprecated. New applications should not use it. The <code>GetMediaType</code>
    ///method retrieves the media type of the sample. If the format has not changed from the previous sample, the sample
    ///might not carry a media type.
    ///Params:
    ///    ppMediaType = Address of a pointer that receives an AM_MEDIA_TYPE structure.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The format has not changed
    ///    from the previous sample. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetMediaType(AM_MEDIA_TYPE** ppMediaType);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SetMediaType</code> method sets the media type for the sample.
    ///Params:
    ///    pMediaType = Pointer to an AM_MEDIA_TYPE structure that describes the media type.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetMediaType(AM_MEDIA_TYPE* pMediaType);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>IsDiscontinuity</code> method determines if this sample represents a discontinuity in the data
    ///stream.
    ///Returns:
    ///    Returns S_OK if this sample is a discontinuity, or S_FALSE otherwise.
    ///    
    HRESULT IsDiscontinuity();
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SetDiscontinuity</code> method sets the discontinuity property.
    ///Params:
    ///    bDiscontinuity = Value that specifies whether this sample is a discontinuity. If the sample is discontinuous with the previous
    ///                     sample, set the value to <b>TRUE</b>. Otherwise, set the value to <b>FALSE</b>.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT SetDiscontinuity(BOOL bDiscontinuity);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>GetMediaTime</code> method retrieves the media time stamps for the sample.
    ///Params:
    ///    pTimeStart = Pointer to a variable that receives the media start time.
    ///    pTimeEnd = Pointer to a variable that receives the media stop time.
    ///Returns:
    ///    Returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_MEDIA_TIME_NOT_SET</b></dt> </dl> </td> <td width="60%"> No media time stamp
    ///    was set for this sample. </td> </tr> </table>
    ///    
    HRESULT GetMediaTime(long* pTimeStart, long* pTimeEnd);
    ///<div class="alert"><b>Note</b> This interface is deprecated. New applications should not use it.</div> <div>
    ///</div> The <code>SetMediaTime</code> method sets the media time stamps for this sample.
    ///Params:
    ///    pTimeStart = Pointer to a variable that contains the media start time.
    ///    pTimeEnd = Pointer to a variable that contains the media stop time.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT SetMediaTime(long* pTimeStart, long* pTimeEnd);
}

///The <code>IDirectDrawVideo</code> interface queries the Video Renderer filter about DirectDraw surfaces and hardware
///capabilities. Applications can use this interface to control what DirectDraw features the Video Renderer will take
///advantage of. For example, if you are positive that you don't want the Video Renderer to use a hardware overlay you
///can disable its use via the SetSwitches method. <div class="alert"><b>Note</b> You can't use this interface to force
///the Video Renderer to use a particular DirectDraw feature; you can only stop it from using that feature.</div> <div>
///</div> There is some duplication in this interface with the <b>IDirectDraw</b> interface; however, this interface
///enables simple access to that information without calling the DirectDraw provider directly. The Video Renderer does
///not load DirectDraw until it is connected, and likewise DirectDraw is unloaded only when the renderer is
///disconnected. When the renderer has allocated the DirectDraw surfaces it will use for video playback, an application
///can obtain a <b>DDSURFACEDESC</b> structure describing it. By passing in a pointer to a <b>DDSURFACEDESC</b>
///structure, the renderer will fill in the structure with the details of the current surface. If DirectDraw has not
///been loaded, the renderer will return E_FAIL. If the renderer is using DCI (the predecessor to DirectDraw), the
///<b>DDSURFACEDESC</b> structure is not filled in but the call will return S_FALSE. The only type of DCI surfaces the
///renderer uses are primary surfaces.
interface IDirectDrawVideo : IUnknown
{
    ///The <code>GetSwitches</code> method retrieves the surface types that the renderer is allowed to use.
    ///Params:
    ///    pSwitches = Pointer to a bit mask containing one or more of the following DirectShow DirectDraw Surface (AMDDS) surface
    ///                types. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>AMDDS_NONE</td> <td>No use for
    ///                DCI/DirectDraw.</td> </tr> <tr> <td>AMDDS_DCIPS</td> <td>Use DCI primary surface.</td> </tr> <tr>
    ///                <td>AMDDS_PS</td> <td>Use DirectDraw primary surface.</td> </tr> <tr> <td>AMDDS_RGBOVR</td> <td>RGB overlay
    ///                surfaces.</td> </tr> <tr> <td>AMDDS_YUVOVR</td> <td>YUV overlay surfaces.</td> </tr> <tr>
    ///                <td>AMDDS_RGBOFF</td> <td>RGB off-screen surfaces.</td> </tr> <tr> <td>AMDDS_YUVOFF</td> <td>YUV off-screen
    ///                surfaces.</td> </tr> <tr> <td>AMDDS_RGBFLP</td> <td>RGB flipping surfaces.</td> </tr> <tr>
    ///                <td>AMDDS_YUVFLP</td> <td>YUV flipping surfaces.</td> </tr> <tr> <td>AMDDS_ALL</td> <td>All the previous
    ///                flags.</td> </tr> <tr> <td>AMDDS_DEFAULT</td> <td>Use all available surfaces.</td> </tr> <tr>
    ///                <td>AMDDS_YUV</td> <td>(AMDDS_YUVOFF | AMDDS_YUVOVR | AMDDS_YUVFLP).</td> </tr> <tr> <td>AMDDS_RGB</td>
    ///                <td>(AMDDS_RGBOFF | AMDDS_RGBOVR | AMDDS_RGBFLP).</td> </tr> <tr> <td>AMDDS_PRIMARY</td> <td>(AMDDS_DCIPS |
    ///                AMDDS_PS).</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetSwitches(uint* pSwitches);
    ///The <code>SetSwitches</code> method sets the surface types that the renderer is allowed to use.
    ///Params:
    ///    Switches = Bit mask containing one or more of the following DirectShow DirectDraw Surface (AMDDS) surface types. <table>
    ///               <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>AMDDS_NONE</td> <td>No use for DCI/DirectDraw.</td>
    ///               </tr> <tr> <td>AMDDS_DCIPS</td> <td>Use DCI primary surface.</td> </tr> <tr> <td>AMDDS_PS</td> <td>Use
    ///               DirectDraw primary surface.</td> </tr> <tr> <td>AMDDS_RGBOVR</td> <td>RGB overlay surfaces.</td> </tr> <tr>
    ///               <td>AMDDS_YUVOVR</td> <td>YUV overlay surfaces.</td> </tr> <tr> <td>AMDDS_RGBOFF</td> <td>RGB off-screen
    ///               surfaces.</td> </tr> <tr> <td>AMDDS_YUVOFF</td> <td>YUV off-screen surfaces.</td> </tr> <tr>
    ///               <td>AMDDS_RGBFLP</td> <td>RGB flipping surfaces.</td> </tr> <tr> <td>AMDDS_YUVFLP</td> <td>YUV flipping
    ///               surfaces.</td> </tr> <tr> <td>AMDDS_ALL</td> <td>All the previous flags.</td> </tr> <tr>
    ///               <td>AMDDS_DEFAULT</td> <td>Use all available surfaces.</td> </tr> <tr> <td>AMDDS_YUV</td> <td>(AMDDS_YUVOFF |
    ///               AMDDS_YUVOVR | AMDDS_YUVFLP).</td> </tr> <tr> <td>AMDDS_RGB</td> <td>(AMDDS_RGBOFF | AMDDS_RGBOVR |
    ///               AMDDS_RGBFLP).</td> </tr> <tr> <td>AMDDS_PRIMARY</td> <td>(AMDDS_DCIPS | AMDDS_PS).</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetSwitches(uint Switches);
    ///The <code>GetCaps</code> method retrieves a DirectDraw-defined DDCAPS structure containing the hardware
    ///capabilities.
    ///Params:
    ///    pCaps = Pointer to a DDCAPS structure containing the hardware capabilities.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetCaps(DDCAPS_DX7* pCaps);
    ///The <code>GetEmulatedCaps</code> method retrieves a DirectDraw-defined DDCAPS structure containing the emulated
    ///capabilities.
    ///Params:
    ///    pCaps = Pointer to a <b>DDCAPS</b> structure containing the emulated capabilities.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. If the renderer has not loaded DirectDraw, this method returns E_FAIL.
    ///    
    HRESULT GetEmulatedCaps(DDCAPS_DX7* pCaps);
    ///The <code>GetSurfaceDesc</code> method retrieves a <b>DDSURFACEDESC</b> structure describing the current
    ///DirectDraw surface.
    ///Params:
    ///    pSurfaceDesc = Pointer to a <b>DDSURFACEDESC</b> structure describing the current DirectDraw surface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. If no surface has been allocated, this method will return E_FAIL. If a DCI
    ///    primary surface is in use, the <b>DDSURFACEDESC</b> structure will not be filled in and the call will return
    ///    S_FALSE.
    ///    
    HRESULT GetSurfaceDesc(DDSURFACEDESC* pSurfaceDesc);
    ///The <code>GetFourCCCodes</code> method retrieves the multimedia format type.
    ///Params:
    ///    pCount = Pointer to the number of FOURCC codes in the <i>pCodes</i> array.
    ///    pCodes = Pointer to an array of <b>DWORD</b> media tags formerly used for Microsoft multimedia types.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetFourCCCodes(uint* pCount, uint* pCodes);
    ///The <code>SetDirectDraw</code> method passes the <b>IDirectDraw</b> interface to a loaded driver.
    ///Params:
    ///    pDirectDraw = Pointer to the <b>IDirectDraw</b> interface to be passed.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetDirectDraw(IDirectDraw pDirectDraw);
    ///The <code>GetDirectDraw</code> method retrieves the <b>IDirectDraw</b> interface.
    ///Params:
    ///    ppDirectDraw = Address of a pointer to the <b>IDirectDraw</b> interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetDirectDraw(IDirectDraw* ppDirectDraw);
    ///The <code>GetSurfaceType</code> method retrieves the actual surface type as a DirectShow DirectDraw Surface
    ///(AMDDS) definition.
    ///Params:
    ///    pSurfaceType = Pointer to variable that receives a bitwise-<b>OR</b> of one or more of the following values. <table> <tr>
    ///                   <th>Value </th> <th>Description </th> </tr> <tr> <td>AMDDS_NONE</td> <td>No use for DCI/DirectDraw.</td>
    ///                   </tr> <tr> <td>AMDDS_DCIPS</td> <td>Use DCI primary surface.</td> </tr> <tr> <td>AMDDS_PS</td> <td>Use
    ///                   DirectDraw primary surface.</td> </tr> <tr> <td>AMDDS_RGBOVR</td> <td>RGB overlay surfaces.</td> </tr> <tr>
    ///                   <td>AMDDS_YUVOVR</td> <td>YUV overlay surfaces.</td> </tr> <tr> <td>AMDDS_RGBOFF</td> <td>RGB off-screen
    ///                   surfaces.</td> </tr> <tr> <td>AMDDS_YUVOFF</td> <td>YUV off-screen surfaces.</td> </tr> <tr>
    ///                   <td>AMDDS_RGBFLP</td> <td>RGB flipping surfaces.</td> </tr> <tr> <td>AMDDS_YUVFLP</td> <td>YUV flipping
    ///                   surfaces.</td> </tr> <tr> <td>AMDDS_ALL</td> <td>All the previous flags.</td> </tr> <tr>
    ///                   <td>AMDDS_DEFAULT</td> <td>Use all available surfaces.</td> </tr> <tr> <td>AMDDS_YUV</td> <td>(AMDDS_YUVOFF |
    ///                   AMDDS_YUVOVR | AMDDS_YUVFLP).</td> </tr> <tr> <td>AMDDS_RGB</td> <td>(AMDDS_RGBOFF | AMDDS_RGBOVR |
    ///                   AMDDS_RGBFLP).</td> </tr> <tr> <td>AMDDS_PRIMARY</td> <td>(AMDDS_DCIPS | AMDDS_PS).</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetSurfaceType(uint* pSurfaceType);
    ///The <code>SetDefault</code> method makes the current property settings the global default.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetDefault();
    ///The <code>UseScanLine</code> method determines whether the renderer should check the current scan line when
    ///drawing a video.
    ///Params:
    ///    UseScanLine = Long integer value that specifies whether or not to use the scan line information. Set to <b>OATRUE</b> to
    ///                  use scan line information or <b>OAFALSE</b> to ignore it.
    ///Returns:
    ///    Returns E_INVALIDARG if the argument is invalid or S_OK otherwise.
    ///    
    HRESULT UseScanLine(int UseScanLine);
    ///The <code>CanUseScanLine</code> method determines whether the renderer will check the current scan line when
    ///drawing.
    ///Params:
    ///    UseScanLine = Pointer to a value indicating whether the renderer will use scan line information. OATRUE indicates the
    ///                  renderer will check the current scan line when drawing; OAFALSE indicates it will not.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT CanUseScanLine(int* UseScanLine);
    ///The <code>UseOverlayStretch</code> method determines whether the renderer should check overlay stretch
    ///limitations.
    ///Params:
    ///    UseOverlayStretch = Value specifying whether the renderer checks overlay stretching. Set to OATRUE for the renderer to check
    ///                        overlay stretching; otherwise, set to OAFALSE.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT UseOverlayStretch(int UseOverlayStretch);
    ///The <code>CanUseOverlayStretch</code> method determines whether the renderer will check overlay restrictions.
    ///Params:
    ///    UseOverlayStretch = Pointer to a value indicating whether the renderer can use overlay restrictions. OATRUE indicates the
    ///                        renderer will check overlay restrictions; OAFALSE indicates it will not.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT CanUseOverlayStretch(int* UseOverlayStretch);
    ///The <code>UseWhenFullScreen</code> method determines whether DirectShow should change display mode when going to
    ///full-screen mode.
    ///Params:
    ///    UseWhenFullScreen = Value specifying whether to change the display mode. Set to OATRUE to cause the renderer to use DirectShow in
    ///                        full-screen mode; otherwise, set to OAFALSE.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT UseWhenFullScreen(int UseWhenFullScreen);
    ///The <code>WillUseFullScreen</code> method determines whether DirectShow will change display mode when going to
    ///full-screen mode.
    ///Params:
    ///    UseWhenFullScreen = Pointer to a value indicating whether DirectShow will use DirectX in full-screen mode. OATRUE indicates it
    ///                        will use full-screen mode; OAFALSE indicates it will not.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT WillUseFullScreen(int* UseWhenFullScreen);
}

///The <b>IQualProp</b> interface provides methods for retrieving performance information from video renderers. The
///values returned through the interface are reset each time the filter is stopped. The Video Renderer filter and the
///Full Screen Renderer filter expose this interface. Applications can use this interface to retrieve video performance
///information.
interface IQualProp : IUnknown
{
    ///The <code>get_FramesDroppedInRenderer</code> method retrieves the number of frames dropped by the renderer.
    ///Params:
    ///    pcFrames = Pointer to the number of frames dropped by the renderer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_FramesDroppedInRenderer(int* pcFrames);
    ///The <code>get_FramesDrawn</code> method retrieves the number of frames actually drawn since streaming started.
    ///Params:
    ///    pcFramesDrawn = Pointer to the number of frames drawn since streaming started.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_FramesDrawn(int* pcFramesDrawn);
    ///The <code>get_AvgFrameRate</code> method retrieves the actual average frame rate since streaming started.
    ///Params:
    ///    piAvgFrameRate = Pointer to a variable that receives the actual number of frames per second, multiplied by 100. For example,
    ///                     an average frame rate of 30 frames per second will be represented as 3000.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_AvgFrameRate(int* piAvgFrameRate);
    ///The <b>get_Jitter</b> method gets the jitter (variation in time) between successive frames delivered to the video
    ///renderer.
    ///Params:
    ///    iJitter = Receives the standard deviation of the interframe time, in milliseconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_Jitter(int* iJitter);
    ///The <code>get_AvgSyncOffset</code> method retrieves the average time difference between when the video frames
    ///should have been displayed and when they actually were.
    ///Params:
    ///    piAvg = Pointer to the time difference, expressed in milliseconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_AvgSyncOffset(int* piAvg);
    ///The <code>get_DevSyncOffset</code> method retrieves the average time difference between when the video frames
    ///should have been displayed and when they actually were. This method is the same as the
    ///IQualProp::get_AvgSyncOffset method except that the value returned is calculated as a standard deviation rather
    ///than as a simple average.
    ///Params:
    ///    piDev = Pointer to a value denoting the accuracy of the video frames displayed.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT get_DevSyncOffset(int* piDev);
}

interface IFullScreenVideo : IUnknown
{
    HRESULT CountModes(int* pModes);
    HRESULT GetModeInfo(int Mode, int* pWidth, int* pHeight, int* pDepth);
    HRESULT GetCurrentMode(int* pMode);
    HRESULT IsModeAvailable(int Mode);
    HRESULT IsModeEnabled(int Mode);
    HRESULT SetEnabled(int Mode, int bEnabled);
    HRESULT GetClipFactor(int* pClipFactor);
    HRESULT SetClipFactor(int ClipFactor);
    HRESULT SetMessageDrain(HWND hwnd);
    HRESULT GetMessageDrain(HWND* hwnd);
    HRESULT SetMonitor(int Monitor);
    HRESULT GetMonitor(int* Monitor);
    HRESULT HideOnDeactivate(int Hide);
    HRESULT IsHideOnDeactivate();
    HRESULT SetCaption(BSTR strCaption);
    HRESULT GetCaption(BSTR* pstrCaption);
    HRESULT SetDefault();
}

///The <code>IFullScreenVideoEx</code> interface is implemented on the Full Screen Renderer filter, which provides
///full-screen video rendering on older hardware. Newer video cards can stretch the video efficiently enough that the
///Full Screen Renderer is not required. Therefore, both the filter and this interface are now deprecated.
interface IFullScreenVideoEx : IFullScreenVideo
{
    ///The <code>SetAcceleratorTable</code> method specifies an accelerator table that will be used to translate
    ///keyboard messages. The Full Screen Renderer filter does not support this method.
    ///Params:
    ///    hwnd = Handle of the window that will receive the translated messages.
    ///    hAccel = Handle to the accelerator table.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetAcceleratorTable(HWND hwnd, HACCEL hAccel);
    ///The <code>GetAcceleratorTable</code> method retrieves the accelerator table currently being used to translate
    ///keyboard messages. The Full Screen Renderer filter does not support this method.
    ///Params:
    ///    phwnd = Pointer to a variable that receives a window handle. The window receives translated messages.
    ///    phAccel = Pointer to a variable that receives a handle to the accelerator table.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetAcceleratorTable(HWND* phwnd, HACCEL* phAccel);
    ///The <code>KeepPixelAspectRatio</code> method specifies whether to maintain the pixel aspect ratio. The Full
    ///Screen Renderer filter does not support this method; it always maintains the pixel aspect ratio.
    ///Params:
    ///    KeepAspect = Specifies whether to maintain the aspect ratio. The value must be OATRUE or OAFALSE.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT KeepPixelAspectRatio(int KeepAspect);
    ///The <code>IsKeepPixelAspectRatio</code> method queries whether the pixel aspect ratio is maintained. The Full
    ///Screen Renderer filter does not support this method; it always maintains the pixel aspect ratio.
    ///Params:
    ///    pKeepAspect = Pointer to a variable that receives the value OATRUE or OAFALSE.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT IsKeepPixelAspectRatio(int* pKeepAspect);
}

interface IBaseVideoMixer : IUnknown
{
    HRESULT SetLeadPin(int iPin);
    HRESULT GetLeadPin(int* piPin);
    HRESULT GetInputPinCount(int* piPinCount);
    HRESULT IsUsingClock(int* pbValue);
    HRESULT SetUsingClock(int bValue);
    HRESULT GetClockPeriod(int* pbValue);
    HRESULT SetClockPeriod(int bValue);
}

///The <code>IDMOWrapperFilter</code> interface enables an application to use a DirectX Media Object (DMO) inside a
///filter graph. The DMO Wrapper filter exposes this interface. To add a DMO to the filter graph, create an instance of
///the DMO Wrapper filter and query it for the <code>IDMOWrapperFilter</code> interface. Then call the
///IDMOWrapperFilter::Init method to initialize the filter with the DMO.
@GUID("52D6F586-9F0F-4824-8FC8-E32CA04930C2")
interface IDMOWrapperFilter : IUnknown
{
    ///The <code>Init</code> method initializes the DMO Wrapper filter with the specified DMO.
    ///Params:
    ///    clsidDMO = Class identifier (CLSID) of the DMO.
    ///    catDMO = CLSID that specifies the category of the DMO.
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT Init(const(GUID)* clsidDMO, const(GUID)* catDMO);
}

@GUID("28F54685-06FD-11D2-B27A-00A0C9223196")
interface IKsControl : IUnknown
{
    HRESULT KsProperty(char* Property, uint PropertyLength, char* PropertyData, uint DataLength, 
                       uint* BytesReturned);
    HRESULT KsMethod(char* Method, uint MethodLength, char* MethodData, uint DataLength, uint* BytesReturned);
    HRESULT KsEvent(char* Event, uint EventLength, char* EventData, uint DataLength, uint* BytesReturned);
}

@GUID("7F40EAC0-3947-11D2-874E-00A0C9223196")
interface IKsAggregateControl : IUnknown
{
    HRESULT KsAddAggregate(const(GUID)* AggregateClass);
    HRESULT KsRemoveAggregate(const(GUID)* AggregateClass);
}

@GUID("28F54683-06FD-11D2-B27A-00A0C9223196")
interface IKsTopology : IUnknown
{
    HRESULT CreateNodeInstance(uint NodeId, uint Flags, uint DesiredAccess, IUnknown UnkOuter, 
                               const(GUID)* InterfaceId, void** Interface);
}

///The <code>IMixerOCXNotify</code> interface is implemented by clients and called by the Overlay Mixer to send
///notifications of events affecting the video display rectangle.
@GUID("81A3BD31-DEE1-11D1-8508-00A0C91F9CA0")
interface IMixerOCXNotify : IUnknown
{
    ///The <code>OnInvalidateRect</code> method notifies the client that the video rectangle has been invalidated.
    ///Params:
    ///    lpcRect = Specifies the rectangle that has been invalidated, in screen coordinates.
    ///Returns:
    ///    If the method succeeds, it returns S_OK.
    ///    
    HRESULT OnInvalidateRect(RECT* lpcRect);
    ///The <code>OnStatusChange</code> method informs the client that a status change has occurred.
    ///Params:
    ///    ulStatusFlags = Bitwise OR of one or more of the following status flags. <table> <tr> <th>Flag </th> <th>Description </th>
    ///                    </tr> <tr> <td>MIXER_STATE_UNCONNECTED (0x00000000)</td> <td>The Overlay Mixer is unconnected and
    ///                    stopped.</td> </tr> <tr> <td>MIXER_STATE_CONNECTED_STOPPED (0x00000001)</td> <td>The Overlay Mixer is
    ///                    connected and stopped.</td> </tr> <tr> <td>MIXER_STATE_CONNECTED_PAUSED (0x00000002)</td> <td>The Overlay
    ///                    Mixer is connected and paused.</td> </tr> <tr> <td>MIXER_STATE_CONNECTED_PLAYING (0x00000003)</td> <td>The
    ///                    Overlay Mixer is connected and playing.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK.
    ///    
    HRESULT OnStatusChange(uint ulStatusFlags);
    ///The <code>OnDataChange</code> method notifies the client when the video rectangle's aspect ratio or size, or the
    ///display palette, has changed.
    ///Params:
    ///    ulDataFlags = Flag indicating which set of data has changed. The following flags are defined. <table> <tr> <th>Flags </th>
    ///                  <th>Description </th> </tr> <tr> <td>MIXER_DATA_ASPECT_RATIO (0x00000001)</td> <td>Picture aspect ratio.</td>
    ///                  </tr> <tr> <td>MIXER_DATA_NATIVE_SIZE (0x00000002)</td> <td>The video stream's native size changed.</td>
    ///                  </tr> <tr> <td>MIXER_DATA_PALETTE (0x00000004)</td> <td>The video palette changed.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK.
    ///    
    HRESULT OnDataChange(uint ulDataFlags);
}

///The <code>IMixerOCX</code> interface is implemented on the Overlay Mixer. This interface enables clients that do not
///own their own windows, such as an ActiveX control, to set properties of the video rectangle and advise the filter of
///events. <div class="alert"><b>Note</b> Applications should generally use the Video Mixing Renderer Filter 9 (VMR-9)
///and not the Overlay Mixer. The only scenario that requires the Overlay Mixer is when the video capture or decoder
///hardware uses video ports to transfer video data to the graphics card. The VMR-9 does not support video ports.</div>
///<div> </div>
@GUID("81A3BD32-DEE1-11D1-8508-00A0C91F9CA0")
interface IMixerOCX : IUnknown
{
    ///The <code>OnDisplayChange</code> method informs the Overlay Mixer that the monitor's display settings have
    ///changed. (Not implemented.)
    ///Params:
    ///    ulBitsPerPixel = Specifies the new bits per pixel setting.
    ///    ulScreenWidth = Specifies the new screen width in pixels.
    ///    ulScreenHeight = Specifies the new screen height in pixels.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT OnDisplayChange(uint ulBitsPerPixel, uint ulScreenWidth, uint ulScreenHeight);
    ///The <code>GetAspectRatio</code> method returns the current aspect ratio setting on the Overlay Mixer. (Currently
    ///not implemented.)
    ///Params:
    ///    pdwPictAspectRatioX = Pointer that receives the value of the X dimension.
    ///    pdwPictAspectRatioY = Pointer that receives the value of the Y dimension.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT GetAspectRatio(uint* pdwPictAspectRatioX, uint* pdwPictAspectRatioY);
    ///The <code>GetVideoSize</code> method retrieves the current size of the video rectangle.
    ///Params:
    ///    pdwVideoWidth = Pointer that receives the video width in pixels.
    ///    pdwVideoHeight = Pointer that receives the video height in pixels.
    ///Returns:
    ///    If the method succeeds, it returns S_OK.
    ///    
    HRESULT GetVideoSize(uint* pdwVideoWidth, uint* pdwVideoHeight);
    ///The <code>GetStatus</code> method returns the current status of the Overlay Mixer. (Not implemented.)
    ///Params:
    ///    pdwStatus = Pointer that receives the current status of the Overlay Mixer.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT GetStatus(uint** pdwStatus);
    ///The <code>OnDraw</code> method instructs the Overlay Mixer to draw the video rectangle.
    ///Params:
    ///    hdcDraw = Specifies the device context associated with the parent window.
    ///    prcDraw = Specifies the rectangle coordinates of the video rectangle.
    ///Returns:
    ///    If the method succeeds, it returns S_OK.
    ///    
    HRESULT OnDraw(HDC hdcDraw, RECT* prcDraw);
    ///The <code>SetDrawRegion</code> method specifies the location and dimensions of the video and clipping rectangles
    ///in screen coordinates.
    ///Params:
    ///    lpptTopLeftSC = Specifies the top left of the video rectangle in screen coordinates. (The Overlay Mixer filter ignores this
    ///                    parameter. This parameter should be set to <b>NULL</b>.)
    ///    prcDrawCC = Specifies the video rectangle in screen coordinates. This parameter cannot be <b>NULL</b>.
    ///    lprcClip = Specifies the clipping rectangle in screen coordinates. This parameter cannot be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b> value. Possible values include those in the following table. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Either <i>prcDrawCC</i> or <i>lprcClip</i> are
    ///    <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT SetDrawRegion(POINT* lpptTopLeftSC, RECT* prcDrawCC, RECT* lprcClip);
    ///The <code>Advise</code> method provides the Overlay Mixer with a pointer to the client's <b>IMixerOCXNotify</b>
    ///interface for callback notifications.
    ///Params:
    ///    pmdns = Specifies the client's IMixerOCXNotify interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK.
    ///    
    HRESULT Advise(IMixerOCXNotify pmdns);
    ///The <code>UnAdvise</code> method instructs the Overlay Mixer to release its pointer to the client's
    ///IMixerOCXNotify interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK.
    ///    
    HRESULT UnAdvise();
}

///The <code>IMixerPinConfig</code> interface is exposed on the input pins of the Overlay Mixer filter and contains
///methods that manipulate video streams in various ways. The Overlay Mixer contains multiple input pins that are
///dynamically created as video input streams are added. The video stream on the first pin is known as the <i>primary
///stream</i> and subsequent streams are known as <i>secondary streams</i>. Use this interface to manipulate the
///parameters involved in mixing various video streams. These parameters include getting and setting position, z-order,
///blending and transparency levels, aspect ratio correction, and color keys of streams. When setting the position of
///video streams in the display window, the default relative position of all secondary streams is {0, 0, 0, 0}.
///Therefore, use the IMixerPinConfig::SetRelativePosition method on secondary streams to ensure that all video streams
///are placed properly. Applications use this interface to get and set attributes when mixing multiple video streams.
interface IMixerPinConfig : IUnknown
{
    ///The <code>SetRelativePosition</code> method sets the position of the stream in the display window.
    ///Params:
    ///    dwLeft = Value specifying the x-coordinate in the upper-left corner of the display window.
    ///    dwTop = Value specifying the y-coordinate in the upper-left corner of the display window.
    ///    dwRight = Value specifying the x-coordinate in the bottom-right corner of the display window.
    ///    dwBottom = Value specifying the y-coordinate in the bottom-right corner of the display window.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Coordinates not in the {0, 0, 10,000, 10,000} range. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetRelativePosition(uint dwLeft, uint dwTop, uint dwRight, uint dwBottom);
    ///The <code>GetRelativePosition</code> method retrieves the position of the stream in the display window.
    ///Params:
    ///    pdwLeft = Pointer to a value indicating the x-coordinate in the top-left corner of the display window.
    ///    pdwTop = Pointer to a value indicating the y-coordinate in the top-left corner of the display window.
    ///    pdwRight = Pointer to a value indicating the x-coordinate in the bottom-right corner of the display window.
    ///    pdwBottom = Pointer to a value indicating the y-coordinate in the bottom-right corner of the display window.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Coordinates not in the {0, 0, 10,000, 10,000} range. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetRelativePosition(uint* pdwLeft, uint* pdwTop, uint* pdwRight, uint* pdwBottom);
    ///The <code>SetZOrder</code> method sets the z-order of a particular video stream. This method is not currently
    ///implemented and returns E_NOTIMPL.
    ///Params:
    ///    dwZOrder = Value indicating the order in which streams will clip each other.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT SetZOrder(uint dwZOrder);
    ///The <code>GetZOrder</code> method retrieves the z-order of a particular video stream. This method is not
    ///currently implemented and returns E_NOTIMPL.
    ///Params:
    ///    pdwZOrder = Pointer to a value indicating the order in which streams will clip each other.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT GetZOrder(uint* pdwZOrder);
    ///The <code>SetColorKey</code> method sets the color key being used by a video stream.
    ///Params:
    ///    pColorKey = Pointer to a [COLORKEY](../strmif/ns-strmif-colorkey.md) structure.
    ///Returns:
    ///    Returns an <code>HRESULT</code> value.
    ///    
    HRESULT SetColorKey(COLORKEY* pColorKey);
    ///The <code>GetColorKey</code> method retrieves the color key being used by a video stream.
    ///Params:
    ///    pColorKey = Pointer to a [COLORKEY](../strmif/ns-strmif-colorkey.md) structure that contains the key type and a palette
    ///                index.
    ///    pColor = Pointer to a value indicating the 8-bit palette index of the [COLORKEY](../strmif/ns-strmif-colorkey.md)
    ///             returned if the current display mode is 8-bit palettized. Otherwise it is a value representing the color key
    ///             in the pixel format of the current display mode.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid arguments, both parameters are <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> <code>GetColorKey</code> failed because the color key
    ///    isn't known. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>NOERROR</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT GetColorKey(COLORKEY* pColorKey, uint* pColor);
    ///The <code>SetBlendingParameter</code> method sets the blending parameter that defines how a secondary stream is
    ///blended with a primary stream.
    ///Params:
    ///    dwBlendingParameter = Value between 0 and 255 that indicates the amount of blending between a primary stream and a secondary
    ///                          stream.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Method called on primary stream. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Value outside of possible range (0 to 255). </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetBlendingParameter(uint dwBlendingParameter);
    ///The <code>GetBlendingParameter</code> method retrieves the value of the blending parameter that defines how a
    ///secondary stream is blended with a primary stream.
    ///Params:
    ///    pdwBlendingParameter = Pointer to a value between 0 and 255 that indicates the amount of blending between a primary stream and a
    ///                           secondary stream.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Method called on primary stream. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Value outside of possible range (0-255). </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetBlendingParameter(uint* pdwBlendingParameter);
    ///The <code>SetAspectRatioMode</code> method sets the aspect ratio correction mode for window resizing.
    ///Params:
    ///    amAspectRatioMode = Value specifying one of the AM_ASPECT_RATIO_MODE enumerated type members.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%">
    ///    Method called on secondary stream. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetAspectRatioMode(AM_ASPECT_RATIO_MODE amAspectRatioMode);
    ///The <code>GetAspectRatioMode</code> method retrieves the aspect ratio correction mode for window resizing.
    ///Params:
    ///    pamAspectRatioMode = Pointer to an AM_ASPECT_RATIO_MODE enumerated type member.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%">
    ///    Method called on secondary stream. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Value invalid or <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetAspectRatioMode(AM_ASPECT_RATIO_MODE* pamAspectRatioMode);
    ///The <code>SetStreamTransparent</code> method sets the stream to transparent.
    ///Params:
    ///    bStreamTransparent = Value specifying the transparency of the stream. Pass in <b>TRUE</b> to indicate stream is transparent;
    ///                         <b>FALSE</b> to indicate not a transparent stream.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetStreamTransparent(BOOL bStreamTransparent);
    ///The <code>GetStreamTransparent</code> method determines whether a stream is transparent.
    ///Params:
    ///    pbStreamTransparent = Pointer to a value indicating whether the stream is transparent. <b>TRUE</b> indicates transparent stream;
    ///                          <b>FALSE</b> indicates not a transparent stream.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td>
    ///    <td width="60%"> Method is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetStreamTransparent(int* pbStreamTransparent);
}

///The <code>IMixerPinConfig2</code> interface is exposed on the input pins of the Overlay Mixer and contains methods
///that manipulate video color controls, if the VGA chip supports it. This interface derives from the IMixerPinConfig
///interface. Applications use this interface to get and set video color controls when mixing multiple video streams.
interface IMixerPinConfig2 : IMixerPinConfig
{
    ///Sets the color control settings associated with the specified overlay surface.
    ///Params:
    ///    pColorControl = Address of a pointer to the <b>DDCOLORCONTROL</b> structure containing the new values to be applied to the
    ///                    specified surface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. If the allocator on the pin is not using an overlay surface, the method
    ///    returns E_FAIL.
    ///    
    HRESULT SetOverlaySurfaceColorControls(DDCOLORCONTROL* pColorControl);
    ///The <code>GetOverlaySurfaceColorControls</code> method retrieves the color control settings associated with the
    ///specified overlay surface.
    ///Params:
    ///    pColorControl = Address of a pointer to the <b>DDCOLORCONTROL</b> structure containing the color values currently applied to
    ///                    the specified surface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. If the allocator on the pin is not using an overlay surface, the method
    ///    returns E_FAIL.
    ///    
    HRESULT GetOverlaySurfaceColorControls(DDCOLORCONTROL* pColorControl);
}

///The <code>IMpegAudioDecoder</code> interface is exposed on the MPEG-1 Audio Decoder filter and it enables
///applications to control decoding parameters. Most of these methods are useful only when an application is running on
///an older system and needs to sacrifice quality to increase performance. The default values provide the optimal
///decoding quality. The two methods that are still useful in some scenarios are get_DualMode and put_DualMode. These
///methods enable applications to access either the right or left channel in VCD-based karaoke discs.
interface IMpegAudioDecoder : IUnknown
{
    ///Returns the frequency divider as a quality setting equal to CD Audio, FM Radio, or AM Radio.
    ///Params:
    ///    pDivider = Receives the frequency divider.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_FrequencyDivider(uint* pDivider);
    ///Specifies the frequency divider as a three-level setting corresponding to the quality of CD Audio, FM Radio, or
    ///AM Radio.
    ///Params:
    ///    Divider = Specifies the divider. 1 = "CD Audio"; 2 = "FM Radio"; 4 = "AM Radio".
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_FrequencyDivider(uint Divider);
    ///Returns the decoder accuracy as a three-level quality setting.
    ///Params:
    ///    pAccuracy = Indicates the quality setting. 0 = best, 0x4000 = high, and 0x8000 = full.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_DecoderAccuracy(uint* pAccuracy);
    ///Specifies the decoder accuracy as a three-level quality setting.
    ///Params:
    ///    Accuracy = Indicates the quality setting. 0 = best, 0x4000 = high, 0x8000 = full.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_DecoderAccuracy(uint Accuracy);
    ///Returns whether the decoder is decoding the encoded stream into stereo or mono PCM.
    ///Params:
    ///    pStereo = Indicates whether the decoder is outputting to PCM mono or stereo.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_Stereo(uint* pStereo);
    ///Specifies whether the decoder will decode the encoded stream into stereo or mono PCM.
    ///Params:
    ///    Stereo = Specifies the decoded output type. 1 = mono and 2 = stereo.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_Stereo(uint Stereo);
    ///Returns the word size used to decode, either eight or 16 bit.
    ///Params:
    ///    pWordSize = Indicates the word size; the value is either 8 or 16.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_DecoderWordSize(uint* pWordSize);
    ///Specifies the word size used by the decoder.
    ///Params:
    ///    WordSize = Specifies the word size; value must be 8 or 16.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_DecoderWordSize(uint WordSize);
    ///Returns whether the decoder is currently using integer-based decoding as opposed to floating point decoding.
    ///Params:
    ///    pIntDecode = Indicates whether the decoder is using integer-based decoding. Zero means it is using floating point-based
    ///                 decoding and one means it is using integer-based decoding.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_IntegerDecode(uint* pIntDecode);
    ///Specifies whether the decoder will use integer-based decoding.
    ///Params:
    ///    IntDecode = Specifies the decoding mode. 0 = floating point mode and 1 = integer mode.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_IntegerDecode(uint IntDecode);
    ///Returns which channel is currently being decoded.
    ///Params:
    ///    pIntDecode = Indicates the channel(s) to be decoded.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_DualMode(uint* pIntDecode);
    ///Specifies the channel to be decoded.
    ///Params:
    ///    IntDecode = Specifies the channel(s) to be decoded. See remarks for valid values.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_DualMode(uint IntDecode);
    ///Returns the audio format of the connected input pin.
    ///Params:
    ///    lpFmt = Pointer to an MPEG1WAVEFORMAT structure. The method copies the format data into the structure.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_AudioFormat(MPEG1WAVEFORMAT* lpFmt);
}

///The <code>IVMRImagePresenter9</code> interface is implemented by the default allocator-presenter for the Video Mixing
///Renderer Filter 9 (VMR-9). It must also be implemented by any plug-in allocator-presenter that an application
///provides for the VMR-9. The VMR-9 uses this interface to inform the allocator-presenter that it should present the
///video frame contained in the supplied Direct3D surface. Applications do not use this interface.
@GUID("69188C61-12A3-40F0-8FFC-342E7B433FD7")
interface IVMRImagePresenter9 : IUnknown
{
    ///The <code>StartPresenting</code> method is called just before the video starts playing. The allocator-presenter
    ///should perform any necessary configuration in this method.
    ///Params:
    ///    dwUserID = An application-defined <b>DWORD_PTR</b> cookie that uniquely identifies this instance of the VMR for use in
    ///               scenarios when one instance of the allocator-presenter is used with multiple VMR instances.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT StartPresenting(size_t dwUserID);
    ///The <code>StopPresenting</code> method is called just after the video stops playing. The allocator-presenter
    ///should perform any necessary cleanup in this method.
    ///Params:
    ///    dwUserID = An application-defined <b>DWORD_PTR</b> cookie that uniquely identifies this instance of the VMR for use in
    ///               scenarios when one instance of the allocator-presenter is used with multiple VMR instances.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT StopPresenting(size_t dwUserID);
    ///The <code>PresentImage</code> method is called at precisely the moment this video frame should be presented.
    ///Params:
    ///    dwUserID = An application-defined DWORD_PTR that uniquely identifies this instance of the VMR in scenarios when multiple
    ///               instances of the VMR are being used with a single instance of an allocator-presenter. See Remarks.
    ///    lpPresInfo = Specifies a VMR9PresentationInfo structure that contains information about the video frame.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT PresentImage(size_t dwUserID, VMR9PresentationInfo* lpPresInfo);
}

///The <b>IVMRSurfaceAllocator9</b> interface is implemented by the default allocator-presenter for the Video Mixing
///Renderer Filter 9 (VMR-9). It must also be implemented by any plug-in allocator-presenter object that an application
///provides to the VMR-9. The VMR-9 uses the methods on this interface to allocate, prepare and free Direct3D surfaces.
///Applications do not use this interface.
@GUID("8D5148EA-3F5D-46CF-9DF1-D1B896EEDB1F")
interface IVMRSurfaceAllocator9 : IUnknown
{
    ///The <b>InitializeDevice</b> method is called by the Video Mixing Renderer 9 (VMR-9) when it needs the
    ///allocator-presenter to allocate surfaces.
    ///Params:
    ///    dwUserID = Application-defined identifier. This value is the same value that the application passed to the
    ///               IVMRSurfaceAllocatorNotify9::AdviseSurfaceAllocator method in the <i>dwUserID</i> parameter.
    ///    lpAllocInfo = Pointer to a VMR9AllocationInfo structure that contains a description of the surfaces to create.
    ///    lpNumBuffers = On input, specifies the number of surfaces to create. When the method returns, this parameter contains the
    ///                   number of buffers that were actually allocated.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT InitializeDevice(size_t dwUserID, VMR9AllocationInfo* lpAllocInfo, uint* lpNumBuffers);
    ///The <b>TerminateDevice</b> method releases the Direct3D device.
    ///Params:
    ///    dwID = Application-defined identifier. This value is the same value that the application passed to the
    ///           IVMRSurfaceAllocatorNotify9::AdviseSurfaceAllocator method in the <i>dwUserID</i> parameter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT TerminateDevice(size_t dwID);
    ///The <b>GetSurface</b> method gets a Direct3D surface from the allocator-presenter.
    ///Params:
    ///    dwUserID = Application-defined identifier. This value is the same value that the application passed to the
    ///               IVMRSurfaceAllocatorNotify9::AdviseSurfaceAllocator method in the <i>dwUserID</i> parameter.
    ///    SurfaceIndex = Specifies the index of the surface to retrieve.
    ///    SurfaceFlags = Reserved.
    ///    lplpSurface = Receives a pointer to the <b>IDirect3DSurface9</b> interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSurface(size_t dwUserID, uint SurfaceIndex, uint SurfaceFlags, IDirect3DSurface9* lplpSurface);
    ///The <b>AdviseNotify</b> method provides the allocator-presenter with the VMR-9 filter's interface for
    ///notification callbacks. If you are using a custom allocator-presenter, the application must call this method on
    ///the allocator-presenter, with a pointer to the VMR's IVMRSurfaceAllocatorNotify9 interface. The
    ///allocator-presenter uses this interface to communicate with the VMR. If you are not using a custom
    ///allocator-presenter, the application does not have to call this method.
    ///Params:
    ///    lpIVMRSurfAllocNotify = Specifies the IVMRSurfaceAllocatorNotify9 interface that the allocator-presenter will use to pass
    ///                            notifications back to the VMR.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AdviseNotify(IVMRSurfaceAllocatorNotify9 lpIVMRSurfAllocNotify);
}

///The <b>IVMRSurfaceAllocatorEx9</b> interface provides a way for custom allocator-presenters to control where the
///Video Mixing Renderer Filter 9 (VMR-9) draws the composited image. To use this interface, implement it on your
///allocator-presenter. At the start of each frame, the VMR-9 calls <b>QueryInterface</b> on the allocator-presenter for
///the <b>IVMRSurfaceAllocatorEx9</b> interface. If the allocator-presenter returns the interface, the VMR-9 calls the
///IVMRSurfaceAllocatorEx9::GetSurfaceEx method instead of the usual IVMRSurfaceAllocator9::GetSurface method. This
///enables your allocator-presenter to specify the rectangle within the returned <b>IDirect3DSurface9</b> where the
///composed video image will be written. This feature enables all of the video image scaling operations to be performed
///in a single stage, and is available in both RGB and YUV mixing modes.
@GUID("6DE9A68A-A928-4522-BF57-655AE3866456")
interface IVMRSurfaceAllocatorEx9 : IVMRSurfaceAllocator9
{
    ///The <b>GetSurfaceEx</b> method retrieves a Direct3D surface and a destination rectangle.
    ///Params:
    ///    dwUserID = Application-defined identifier. This value is the same value that the application passed to the
    ///               IVMRSurfaceAllocatorNotify9::AdviseSurfaceAllocator method in the <i>dwUserID</i> parameter..
    ///    SurfaceIndex = Index of the surface to retrieve.
    ///    SurfaceFlags = Surface flags.
    ///    lplpSurface = Receives a pointer to the <b>IDirect3DSurface9</b> interface. The caller must release the interface.
    ///    lprcDst = Location within the surface where the VMR-9 should write the composited image.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSurfaceEx(size_t dwUserID, uint SurfaceIndex, uint SurfaceFlags, IDirect3DSurface9* lplpSurface, 
                         RECT* lprcDst);
}

///The <b>IVMRSurfaceAllocatorNotify9</b> interface is implemented by the Video Mixing Renderer Filter 9 (VMR-9).
///Applications use this interface to set a custom allocator-presenter and the allocator-presenter uses this interface
///to inform the VMR of changes to the system environment that affect the Direct3D surfaces.
@GUID("DCA3F5DF-BB3A-4D03-BD81-84614BFBFA0C")
interface IVMRSurfaceAllocatorNotify9 : IUnknown
{
    ///The <code>AdviseSurfaceAllocator</code> method is called by an application to instruct the VMR-9 to use a custom
    ///allocator-presenter.
    ///Params:
    ///    dwUserID = Application-defined value that identifies this instance of the VMR-9.
    ///    lpIVRMSurfaceAllocator = Pointer to the IVMRSurfaceAllocator9 interface on the custom surface allocator object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AdviseSurfaceAllocator(size_t dwUserID, IVMRSurfaceAllocator9 lpIVRMSurfaceAllocator);
    ///The <code>SetD3DDevice</code> method sets the Direct3D device.
    ///Params:
    ///    lpD3DDevice = Pointer to the <b>IDirect3DDevice9</b> interface of the device.
    ///    hMonitor = Handle to a monitor.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetD3DDevice(IDirect3DDevice9 lpD3DDevice, ptrdiff_t hMonitor);
    ///The <code>ChangeD3DDevice</code> method notifies the VMR that the Direct3D device has changed.
    ///Params:
    ///    lpD3DDevice = Pointer to the <b>IDirect3DDevice9</b> interface of the new device.
    ///    hMonitor = Handle to the monitor associated with the new device.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ChangeD3DDevice(IDirect3DDevice9 lpD3DDevice, ptrdiff_t hMonitor);
    ///The <code>AllocateSurfaceHelper</code> method allocates a Direct3D surface based on application-specified
    ///parameters. If you are implementing a custom allocator-presenter for the VMR-9, you can use this method to
    ///allocate the surfaces.
    ///Params:
    ///    lpAllocInfo = Pointer to a VMR9AllocationInfo structure that describes the surfaces to create.
    ///    lpNumBuffers = On input, this parameter specifies the number of surfaces to create. On output, this parameter contains the
    ///                   number of surfaces that the method created.
    ///    lplpSurface = Address of an array of <b>IDirect3DSurface9</b> interface pointers. The size of the array must equal the
    ///                  value in <i>lpNumBuffers</i>. The method fills the array with valid <b>IDirect3DSurface9</b> pointers for
    ///                  each Direct3D surface that it creates. The caller must release the interface pointers. (Do not put any valid
    ///                  pointers into the array before you call this method, because the method will overwrite them, causing a memory
    ///                  leak.)
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AllocateSurfaceHelper(VMR9AllocationInfo* lpAllocInfo, uint* lpNumBuffers, 
                                  IDirect3DSurface9* lplpSurface);
    ///The <code>NotifyEvent</code> method is called by the allocator-presenter to inform the VMR of any significant
    ///DirectShow events that it (the allocator presenter) generates during the allocation or presentation processes.
    ///Params:
    ///    EventCode = Specifies the DirectShow event code.
    ///    Param1 = Specifies the first event parameter. The meaning depends on the event code. See Event Notification Codes.
    ///    Param2 = Specifies the second event parameter. The meaning depends on the event code.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT NotifyEvent(int EventCode, ptrdiff_t Param1, ptrdiff_t Param2);
}

///The <b>IVMRWindowlessControl9</b> interface controls how the Video Mixing Renderer Filter 9 (VMR-9) renders a video
///stream within a container window.
@GUID("8F537D09-F85E-4414-B23B-502E54C79927")
interface IVMRWindowlessControl9 : IUnknown
{
    ///The <code>GetNativeVideoSize</code> method retrieves the un-stretched video size and aspect ratio of the video.
    ///Params:
    ///    lpWidth = Pointer that receives the width of the native video rectangle.
    ///    lpHeight = Pointer that receives the height of the native video rectangle.
    ///    lpARWidth = Pointer that receives the aspect ratio width of the native video rectangle.
    ///    lpARHeight = Pointer that receives the aspect ratio height of the native video rectangle.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The VMR is not in windowless mode. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetNativeVideoSize(int* lpWidth, int* lpHeight, int* lpARWidth, int* lpARHeight);
    ///The <code>GetMinIdealVideoSize</code> method retrieves the minimum video size that the VMR can display without
    ///incurring significant performance or image quality degradation.
    ///Params:
    ///    lpWidth = Pointer that receives the minimum ideal width.
    ///    lpHeight = Pointer that receives the minimum ideal height.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The VMR is not in windowless mode. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetMinIdealVideoSize(int* lpWidth, int* lpHeight);
    ///The <code>GetMaxIdealVideoSize</code> method retrieves the maximum video size that the VMR can display without
    ///incurring significant performance or image quality degradation.
    ///Params:
    ///    lpWidth = Pointer that receives the maximum ideal width.
    ///    lpHeight = Pointer that receives the maximum ideal height.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The VMR is not in windowless mode. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetMaxIdealVideoSize(int* lpWidth, int* lpHeight);
    ///The <code>SetVideoPosition</code> method sets the source and destination rectangles for the video.
    ///Params:
    ///    lpSRCRect = Pointer to a <b>RECT</b> structure that specifies the source rectangle. If <b>NULL</b>, the source rectangle
    ///                does not change. The default source rectangle is the entire video image.
    ///    lpDSTRect = Pointer to a <b>RECT</b> structure that specifies the destination rectangle. If <b>NULL</b>, the destination
    ///                rectangle does not change. The default destination rectangle is {0, 0, 0, 0}.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The VMR is not in windowless mode. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetVideoPosition(const(RECT)* lpSRCRect, const(RECT)* lpDSTRect);
    ///The <code>GetVideoPosition</code> method retrieves the current source and destination rectangles used to display
    ///the video.
    ///Params:
    ///    lpSRCRect = Pointer that receives the current source rectangle.
    ///    lpDSTRect = Pointer that receives the current destination rectangle.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The VMR is not in windowless mode. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetVideoPosition(RECT* lpSRCRect, RECT* lpDSTRect);
    ///The <code>GetAspectRatioMode</code> method retrieves the current aspect ratio display mode.
    ///Params:
    ///    lpAspectRatioMode = Pointer to a DWORD that receives a VMR9AspectRatioMode value that indicates the current aspect ratio mode.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>lpAspectRatioMode</i> is invalid </td> </tr> </table>
    ///    
    HRESULT GetAspectRatioMode(uint* lpAspectRatioMode);
    ///The <code>SetAspectRatioMode</code> method sets the current aspect ratio display mode.
    ///Params:
    ///    AspectRatioMode = A VMR9AspectRatioMode value that specifies the aspect ratio mode.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The VMR is not in windowless mode. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetAspectRatioMode(uint AspectRatioMode);
    ///The <code>SetVideoClippingWindow</code> method specifies the container window that video should be clipped to.
    ///Params:
    ///    hwnd = Specifies the window to which the video should be clipped.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The <i>hwnd</i> parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The VMR is not in windowless mode. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetVideoClippingWindow(HWND hwnd);
    ///The <code>RepaintVideo</code> method repaints the current video frame.
    ///Params:
    ///    hwnd = Specifies the handle of the window in which the repainting should occur.
    ///    hdc = Specifies the handle to the device context for the window.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The VMR is not in windowless mode. </td> </tr>
    ///    </table>
    ///    
    HRESULT RepaintVideo(HWND hwnd, HDC hdc);
    ///The <code>DisplayModeChanged</code> method informs the VMR that a WM_DISPLAYCHANGE message has been received by
    ///the application.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT DisplayModeChanged();
    ///The <code>GetCurrentImage</code> method retrieves a copy of the current image being displayed by the VMR.
    ///Params:
    ///    lpDib = Address of a pointer to a BYTE that will receive the DIB.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The VMR is not in windowless mode. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentImage(ubyte** lpDib);
    ///The <code>SetBorderColor</code> method sets the border color to be used by the VMR.
    ///Params:
    ///    Clr = Specifies the color as a <b>COLORREF</b> value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetBorderColor(uint Clr);
    ///The <code>GetBorderColor</code> method retrieves the current border color used by the VMR.
    ///Params:
    ///    lpClr = Pointer to a <b>COLORREF</b> variable that receives the current border color.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The VMR is not in windowless mode. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetBorderColor(uint* lpClr);
}

///The <b>IVMRMixerControl9</b> interface enables an application to manipulate the incoming video streams on the Video
///Mixing Renderer Filter 9 (VMR-9). This interface is intended for use by applications only; it should not be used by
///upstream filters.
@GUID("1A777EAA-47C8-4930-B2C9-8FEE1C1B0F3B")
interface IVMRMixerControl9 : IUnknown
{
    ///The <code>SetAlpha</code> method sets a constant alpha value that is applied to this video stream.
    ///Params:
    ///    dwStreamID = Specifies the input stream. This value corresponds to the input pin. For example, the first input pin is
    ///                 stream 0.
    ///    Alpha = Specifies the alpha blending value to be applied to all the pixels in this stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pin is not connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetAlpha(uint dwStreamID, float Alpha);
    ///The <code>GetAlpha</code> method retrieves the constant alpha value that is applied to this video stream.
    ///Params:
    ///    dwStreamID = Specifies the input stream. This value corresponds to the input pin. For example, the first input pin is
    ///                 stream 0.
    ///    pAlpha = Pointer to a variable that receives the current alpha value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>pAlpha</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pin is not connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAlpha(uint dwStreamID, float* pAlpha);
    ///The <code>SetZOrder</code> method sets this video stream's position in the Z-order; larger values are further
    ///away.
    ///Params:
    ///    dwStreamID = Specifies the input stream. This value corresponds to the input pin. For example, the first input pin is
    ///                 stream 0.
    ///    dwZ = Double word containing the stream's position within the Z-order.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pin is not connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetZOrder(uint dwStreamID, uint dwZ);
    ///The <code>GetZOrder</code> method retrieves this video stream's position in the Z-order.
    ///Params:
    ///    dwStreamID = Specifies the input stream. This value corresponds to the input pin. For example, the first input pin is
    ///                 stream 0.
    ///    pZ = Pointer that receives the current position in the Z-order.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>pZ</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pin is not connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetZOrder(uint dwStreamID, uint* pZ);
    ///The <code>SetOutputRect</code> method sets the position of this stream within the composition rectangle.
    ///Params:
    ///    dwStreamID = Specifies the input stream. This value corresponds to the input pin. For example, the first input pin is
    ///                 stream 0.
    ///    pRect = Pointer to a VMR9NormalizedRect structure that specifies the position of the rectangle with composition
    ///            space.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>pRect</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pin is not connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetOutputRect(uint dwStreamID, const(VMR9NormalizedRect)* pRect);
    ///The <code>GetOutputRect</code> method retrieves the position of this stream's video rectangle within the
    ///composition rectangle.
    ///Params:
    ///    dwStreamID = Specifies the input stream. This value corresponds to the input pin. For example, the first input pin is
    ///                 stream 0.
    ///    pRect = Pointer to a NORMALIZEDRECT structure that receives the destination rectangle in composition space.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>pRect</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The pin is not connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetOutputRect(uint dwStreamID, VMR9NormalizedRect* pRect);
    ///The <code>SetBackgroundClr</code> method sets the background color on the output rectangle.
    ///Params:
    ///    ClrBkg = Specifies the background color.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetBackgroundClr(uint ClrBkg);
    ///The <code>GetBackgroundClr</code> method gets the current background color on the output rectangle.
    ///Params:
    ///    lpClrBkg = Pointer to a variable that receives the background color.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetBackgroundClr(uint* lpClrBkg);
    ///The <code>SetMixingPrefs</code> method sets the mixing preferences for the stream.
    ///Params:
    ///    dwMixerPrefs = Bitwise OR combination of VMR9MixerPrefs flags.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetMixingPrefs(uint dwMixerPrefs);
    ///The <code>GetMixingPrefs</code> method retrieves the mixing preferences for the stream.
    ///Params:
    ///    pdwMixerPrefs = Address of a variable that receives a bitwise OR combination of VMR9MixerPrefs flags.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetMixingPrefs(uint* pdwMixerPrefs);
    ///The <code>SetProcAmpControl</code> method sets the image adjustment for the VMR-9. Image adjustment includes
    ///brightness, contrast, hue, and saturation, and is performed by the graphics device. If the graphics driver does
    ///not support hardware image adjustment, this method fails.
    ///Params:
    ///    dwStreamID = Specifies the input stream. This value corresponds to the input pin. For example, the first input pin is
    ///                 stream 0.
    ///    lpClrControl = Pointer to a VMR9ProcAmpControl structure that contains the image adjustment settings.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. Possible causes of this error include: <ul> <li>The stream number is
    ///    invalid</li> <li>The value of <b>dwSize</b> in the <b>VMR9ProcAmpControl</b> structure is invalid.</li> </ul>
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b>
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The pin is not connected. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_VMR_NO_PROCAMP_HW</b></dt> </dl> </td> <td width="60%"> The graphics hardware does not support
    ///    ProcAmp controls. </td> </tr> </table>
    ///    
    HRESULT SetProcAmpControl(uint dwStreamID, VMR9ProcAmpControl* lpClrControl);
    ///The <code>GetProcAmpControl</code> method retrieves the current image adjustment settings for the VMR-9. Image
    ///adjustment includes brightness, contrast, hue, and saturation, and is performed by the graphics device. If the
    ///graphics driver does not support hardware image adjustment, this method fails.
    ///Params:
    ///    dwStreamID = Specifies the input stream. This value corresponds to the input pin. For example, the first input pin is
    ///                 stream 0.
    ///    lpClrControl = Pointer to a VMR9ProcAmpControl structure that receives the image adjustment settings. When the method
    ///                   returns, the <b>dwFlags</b> field indicates which properties are supported by the graphics driver. Set the
    ///                   <b>dwSize</b> member in the structure before calling this method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. Possible causes of this error include: <ul> <li>The stream number is
    ///    invalid</li> <li>The value of <b>dwSize</b> in the <b>VMR9ProcAmpControl</b> structure is invalid.</li> </ul>
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b>
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The pin is not connected. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_VMR_NO_PROCAMP_HW</b></dt> </dl> </td> <td width="60%"> The graphics hardware does not support
    ///    ProcAmp controls. </td> </tr> </table>
    ///    
    HRESULT GetProcAmpControl(uint dwStreamID, VMR9ProcAmpControl* lpClrControl);
    ///The <code>GetProcAmpControlRange</code> method retrieves the range of values for an image adjustment setting,
    ///such as brightness, contrast, hue, or saturation. Image adjustment is performed by the graphics device, so the
    ///valid range depends on the graphics driver. If the driver does not support hardware image adjustment, this method
    ///fails.
    ///Params:
    ///    dwStreamID = Specifies the input stream. This value corresponds to the input pin. For example, the first input pin is
    ///                 stream 0.
    ///    lpClrControl = Pointer to a VMR9ProcAmpControlRange structure that receives the range. The caller must set the <b>dwSize</b>
    ///                   and <b>dwProperty</b> fields.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. Possible causes of this error include: <ul> <li>The stream number is
    ///    invalid</li> <li>The value of <b>dwSize</b> or <b>dwProperty</b> in the <b>VMR9ProcAmpControl</b> structure
    ///    is invalid.</li> </ul> </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_NOT_CONNECTED</b></dt>
    ///    </dl> </td> <td width="60%"> The pin is not connected. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_VMR_NO_PROCAMP_HW</b></dt> </dl> </td> <td width="60%"> The graphics hardware does not support
    ///    ProcAmp controls. </td> </tr> </table>
    ///    
    HRESULT GetProcAmpControlRange(uint dwStreamID, VMR9ProcAmpControlRange* lpClrControl);
}

///The <b>IVMRMixerBitmap9</b> interface enables an application to blend a static image from a bitmap or Direct3D
///surface onto the video stream, when using the Video Mixing Renderer Filter 9 (VMR-9). You can pass images to the VMR
///as frequently as you like, but changing the image several times per second may impact the performance and smoothness
///of the video being rendered. The new image will be blended with the next and all subsequent video frames rendered by
///the VMR. Internally, the VMR uses its mixer component to perform the blending operation. In the VMR-9, the mixer is
///always present by default except in "renderless" mode in which the application is performing its own rendering. The
///image can contain embedded per pixel alpha information; this allows the image to contain regions that are
///transparent. Transparent areas can also be identified by a color key value. Changes in the image are only shown on
///the screen while the filter graph is running.
@GUID("CED175E5-1935-4820-81BD-FF6AD00C9108")
interface IVMRMixerBitmap9 : IUnknown
{
    ///The <code>SetAlphaBitmap</code> method specifies a new bitmap image and the source location of the bitmap and how
    ///and where it should be rendered on the destination rectangle.
    ///Params:
    ///    pBmpParms = Pointer to a VMR9AlphaBitmap structure that contains information about the bitmap.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>pBmpParms</i> is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. See Remarks. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Could not create a destination
    ///    DC or DIBSection for the bitmap. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> BitBlt to bitmap surface failed. </td> </tr> </table>
    ///    
    HRESULT SetAlphaBitmap(const(VMR9AlphaBitmap)* pBmpParms);
    ///The <code>UpdateAlphaBitmapParameters</code> method changes the bitmap location, size and blending value.
    ///Params:
    ///    pBmpParms = Pointer to a VMR9AlphaBitmap structure.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT UpdateAlphaBitmapParameters(const(VMR9AlphaBitmap)* pBmpParms);
    ///The <code>GetAlphaBitmapParameters</code> method retrieves a copy of the current image and related blending
    ///parameters.
    ///Params:
    ///    pBmpParms = Pointer to a VMR9AlphaBitmap structure that receives the bitmap, information about the blending values, and
    ///                the location to blend it.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>pBmpParms</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The mixer has not been loaded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAlphaBitmapParameters(VMR9AlphaBitmap* pBmpParms);
}

///The <code>IVMRSurface9</code> interface is implemented on the media samples used by the Video Mixing Renderer Filter
///9. Filters can use this interface to access the underlying Direct3D surface on which the media sample is based.
///Filters must always lock and unlock the surface using the methods available on this interface. Filters must never
///call lock or unlock directly on the Direct3D surface interface returned from the GetSurface method. Applications do
///not use this interface.
@GUID("DFC581A1-6E1F-4C3A-8D0A-5E9792EA2AFC")
interface IVMRSurface9 : IUnknown
{
    ///The <code>IsSurfaceLocked</code> method indicates whether the Direct3D surface attached to this media sample is
    ///locked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT IsSurfaceLocked();
    ///The <code>LockSurface</code> method locks the attached Direct3D surface.
    ///Params:
    ///    lpSurface = Address of a variable that receives a pointer to the locked bits.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt>
    ///    </dl> </td> <td width="60%"> No Direct3D surface is attached to this sample. </td> </tr> </table>
    ///    
    HRESULT LockSurface(ubyte** lpSurface);
    ///The <code>UnlockSurface</code> method unlocks the attached Direct3D surface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> No Direct3D surface is attached to this sample. </td> </tr> </table>
    ///    
    HRESULT UnlockSurface();
    ///The <code>GetSurface</code> method retrieves the attached Direct3D surface.
    ///Params:
    ///    lplpSurface = Address of a variable that receives an <b>IDirect3DSurface9</b> interface pointer. The caller must release
    ///                  the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>lplpSurface</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> No Direct3D surface is attached to this sample. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetSurface(IDirect3DSurface9* lplpSurface);
}

///The IVMRImagePresenterConfig interface provides methods for setting the renderering preferences on the
///allocator-presenter used by the Video Mixing Renderer Filter 9 (VMR-9). Applications should not use this interface
///directly. The VMR-9 filter's IVMRFilterConfig9 interface calls methods on this interface. The default
///allocator-presenter implements this interface. Custom allocator-presenters can also expose this interface.
@GUID("45C15CAB-6E22-420A-8043-AE1F0AC02C7D")
interface IVMRImagePresenterConfig9 : IUnknown
{
    ///The <code>SetRenderingPrefs</code> method sets the rendering preferences on the VMR-9 filter's
    ///allocator-presenter. The VMR-9 filter's IVMRFilterConfig9::SetRenderingPrefs method calls through to this method.
    ///Params:
    ///    dwRenderFlags = A bitwise OR combination of VMR9RenderPrefs flags that will be used to configure the allocator-presenter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetRenderingPrefs(uint dwRenderFlags);
    ///The <code>GetRenderingPrefs</code> method gets the current rendering preferences from the VMR-9 filter's
    ///allocator-presenter. The VMR-9 filter's IVMRFilterConfig9::GetRenderingPrefs method calls through to this method.
    ///Params:
    ///    dwRenderFlags = Receives a bitwise OR of flag from the VMR9RenderPrefs enumeration, indicating the current rendering settings
    ///                    on the allocator-presenter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRenderingPrefs(uint* dwRenderFlags);
}

///The <code>IVMRVideoStreamControl9</code> interface is implemented on each input pin of the Video Mixing Renderer
///Filter 9. The interface operates on the input stream represented by the pin. This interface is used by upstream
///filters (typically decoders) to get or set the active state of individual streams. Applications in general should not
///use this interface.
@GUID("D0CFE38B-93E7-4772-8957-0400C49A4485")
interface IVMRVideoStreamControl9 : IUnknown
{
    ///The <code>SetStreamActiveState</code> method activates or inactivates an input stream.
    ///Params:
    ///    fActive = Specifies the state of the stream. <b>TRUE</b> means active; <b>FALSE</b> means inactive.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetStreamActiveState(BOOL fActive);
    ///The <code>GetStreamActiveState</code> method retrieves the state of the stream.
    ///Params:
    ///    lpfActive = Receives the current state of the stream. <b>TRUE</b> means the stream is active; <b>FALSE</b> means that it
    ///                is inactive.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT GetStreamActiveState(int* lpfActive);
}

///The <code>IVMRFilterConfig9</code> interface is implemented by the Video Mixing Renderer Filter 9. Applications use
///this interface to configure the VMR's operating mode and video rendering mechanisms. Applications must add the VMR to
///the graph and configure it before it is connected to any upstream filters (for example, in a call to
///IGraphBuilder::RenderFile). Once a filter has been connected to the VMR, the VMR's configuration is locked and all
///future attempts to alter it fail.
@GUID("5A804648-4F66-4867-9C43-4F5C822CF1B8")
interface IVMRFilterConfig9 : IUnknown
{
    ///The <code>SetImageCompositor</code> method installs an application-provided image compositor object.
    ///Params:
    ///    lpVMRImgCompositor = Pointer to the image compositor object provided by the application.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> Cannot change the compositor when the VMR filter's pins are connected. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The VMR is
    ///    not in mixing mode. </td> </tr> </table>
    ///    
    HRESULT SetImageCompositor(IVMRImageCompositor9 lpVMRImgCompositor);
    ///The <code>SetNumberOfStreams</code> method sets the number of streams to be mixed and instructs the VMR to go
    ///into mixer mode.
    ///Params:
    ///    dwMaxStreams = Double word containing the maximum number of input streams that the VMR will be required to mix.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> The mixer is already configured. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An attempt was made to configure the mixer for more
    ///    than 16 input streams. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Memory to manage the streams could not be allocated. </td> </tr> </table>
    ///    
    HRESULT SetNumberOfStreams(uint dwMaxStreams);
    ///The <code>GetNumberOfStreams</code> method retrieves the number of input streams being mixed.
    ///Params:
    ///    pdwMaxStreams = Receives the number of streams being mixed, which is equal to the number of input pins on the VMR.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>PdwMaxStreams</i> is invalid </td> </tr> </table>
    ///    
    HRESULT GetNumberOfStreams(uint* pdwMaxStreams);
    ///The <code>SetRenderingPrefs</code> method sets various application preferences related to video rendering.
    ///Params:
    ///    dwRenderFlags = Double word containing a bitwise OR of VMR9RenderPrefs values specifying the rendering preferences.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> No allocator-presenter is present. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>dwRenderFlags</i> is
    ///    invalid. </td> </tr> </table>
    ///    
    HRESULT SetRenderingPrefs(uint dwRenderFlags);
    ///The <b>GetRenderingPrefs</b> method retrieves the current set of rendering preferences being used by the VMR-9.
    ///Params:
    ///    pdwRenderFlags = Receives a VMR9RenderPrefs value indicating the current rendering preferences.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The VMR has not created an
    ///    allocator-presenter, or the allocator-presenter does not implement the IVMRImagePresenterConfig9 interface.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetRenderingPrefs(uint* pdwRenderFlags);
    ///The <code>SetRenderingMode</code> method sets the rendering mode used by the VMR.
    ///Params:
    ///    Mode = Specifies the rendering mode as a VMR9Mode value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> An invalid rendering mode was specified. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The mode cannot be changed for some reason.
    ///    See Remarks. </td> </tr> </table>
    ///    
    HRESULT SetRenderingMode(uint Mode);
    ///The <code>GetRenderingMode</code> method retrieves the rendering mode currently being used by the VMR.
    ///Params:
    ///    pMode = Receives a member of the VMR9Mode emumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>pMode</i> is invalid </td> </tr> </table>
    ///    
    HRESULT GetRenderingMode(uint* pMode);
}

///The <code>IVMRAspectRatioControl9</code> interface controls whether the Video Mixing Renderer Filter 9 (VMR-9)
///preserves the aspect ratio of the source video. This interface is available when the VMR is operating in either
///windowed or windowless modes. In windowless mode, the same functionality is provided by the IVMRWindowlessControl
///interface.
@GUID("00D96C29-BBDE-4EFC-9901-BB5036392146")
interface IVMRAspectRatioControl9 : IUnknown
{
    ///The <code>GetAspectRatioMode</code> method queries whether the VMR preserves the aspect ratio of the source
    ///video.
    ///Params:
    ///    lpdwARMode = Pointer to a variable that receives a member of the VMR_ASPECT_RATIO_MODE enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetAspectRatioMode(uint* lpdwARMode);
    ///The <code>SetAspectRatioMode</code> method specifies whether the VMR preserves the aspect ratio of the source
    ///video.
    ///Params:
    ///    dwARMode = Specifies a member of the VMR_ASPECT_RATIO_MODE enumeration type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT SetAspectRatioMode(uint dwARMode);
}

///The <code>IVMRMonitorConfig9</code> interface is implemented by the Video Mixing Renderer Filter 9 (VMR-9).
///Applications use this interface to determine the capabilities of the display devices on the system and to control
///which device is used to display the output. For example, if the system contains a hardware DVD decoder and the VMR is
///rendering the output from that decoder, then on a multi-monitor system, an application must use this interface to
///specify the display device that is connected to the decoder. The VMR-9 supports a maximum of 16 display devices.
@GUID("46C2E457-8BA0-4EEF-B80B-0680F0978749")
interface IVMRMonitorConfig9 : IUnknown
{
    ///On a multi-monitor system, the <code>SetMonitor</code> method specifies the monitor that the VMR should use when
    ///it creates the Direct3D device.
    ///Params:
    ///    uDev = Index that specifies the monitor.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument; <i>uDev</i> does not correspond to a valid monitor. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> Cannot set the monitor
    ///    after the VMR's input pins have been connected. </td> </tr> </table>
    ///    
    HRESULT SetMonitor(uint uDev);
    ///The <code>GetMonitor</code> method retrieves the monitor that this instance of the VMR is using for video
    ///playback.
    ///Params:
    ///    puDev = Pointer that receives an index that identifies the monitor currently in use.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The allocator-presenter has not been loaded.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetMonitor(uint* puDev);
    ///The <code>SetDefaultMonitor</code> method specifies the default monitor that all future instances of the VMR
    ///should use for video playback.
    ///Params:
    ///    uDev = Index that specifies the default monitor.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> Could not set the specified monitor as the default. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>uDev</i> does not correspond
    ///    to a valid monitor. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> The allocator-presenter has not been loaded. </td> </tr> </table>
    ///    
    HRESULT SetDefaultMonitor(uint uDev);
    ///The <code>GetDefaultMonitor</code> method retrieves the default monitor that all future instances of the VMR will
    ///use for video playback.
    ///Params:
    ///    puDev = Pointer that receives an index that identifies the default monitor on the system.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%"> The allocator-presenter has not been loaded.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetDefaultMonitor(uint* puDev);
    ///The <code>GetAvailableMonitors</code> method retrieves information about the monitors currently available on the
    ///system.
    ///Params:
    ///    pInfo = Pointer to an array of VMR9MonitorInfo structures that contain information about each monitor on the system.
    ///    dwMaxInfoArraySize = Specifies the maximum number of members in the array.
    ///    pdwNumDevices = If <i>pInfo</i> is <b>NULL</b>, this parameter receives the required array size. Otherwise, it receives the
    ///                    actual number of devices retrieved.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument; <i>dwMaxInfoArraySize</i> must be greater than zero. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetAvailableMonitors(VMR9MonitorInfo* pInfo, uint dwMaxInfoArraySize, uint* pdwNumDevices);
}

///The <b>IVMRDeinterlaceControl9</b> interface supports hardware-accelerated deinterlacing using the Video Mixing
///Renderer Filter 9 (VMR-9). This interface enables applications or other filters to control how the VMR manages
///DirectX Video Acceleration (DirectX VA) hardware deinterlacing.
@GUID("A215FB8D-13C2-4F7F-993C-003D6271A459")
interface IVMRDeinterlaceControl9 : IUnknown
{
    ///The <b>GetNumberOfDeinterlaceModes</b> method retrieves the deinterlacing modes available to the VMR for the
    ///specified video format.
    ///Params:
    ///    lpVideoDescription = Pointer to a VMR9VideoDesc structure that describes the video.
    ///    lpdwNumDeinterlaceModes = Pointer to a <b>DWORD</b> value. On input, this value specifies the size of the array given in
    ///                              <i>lpDeinterlaceModes</i>. On output, it receives number of GUIDs the method copied into the array.
    ///    lpDeinterlaceModes = Address of an array allocated by caller. The method fills the array with GUID values. To determine the size
    ///                         of the array that is needed, set this parameter to <b>NULL</b> and check the value returned in
    ///                         <i>lpdwNumDeinterlaceModes</i>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt> </dl>
    ///    </td> <td width="60%"> The VMR is not in mixer mode. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DDRAW_CAPS_NOT_SUITABLE</b></dt> </dl> </td> <td width="60%"> The video card does not support
    ///    hardware deinterlacing. </td> </tr> </table>
    ///    
    HRESULT GetNumberOfDeinterlaceModes(VMR9VideoDesc* lpVideoDescription, uint* lpdwNumDeinterlaceModes, 
                                        GUID* lpDeinterlaceModes);
    ///The <b>GetDeinterlaceModeCaps</b> method gets the capabilities of a deinterlacing mode supported by the graphics
    ///device driver.
    ///Params:
    ///    lpDeinterlaceMode = Pointer to a GUID that identifies the deinterlacing mode. Call the
    ///                        IVMRDeinterlaceControl9::GetNumberOfDeinterlaceModes method to obtain a list of GUIDs supported by the
    ///                        driver.
    ///    lpVideoDescription = Pointer to a VMR9VideoDesc structure describing the video to deinterlace. Set the <b>dwSize</b> member of the
    ///                         structure before calling the method.
    ///    lpDeinterlaceCaps = Pointer to a VMR9DeinterlaceCaps structure. Set the <b>dwSize</b> member of the structure before calling the
    ///                        method. The method fills the structure with information about the specified deinterlacing mode.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_DDRAW_CAPS_NOT_SUITABLE</b></dt> </dl> </td> <td width="60%"> The video card does not support
    ///    hardware deinterlacing. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_VMR_NO_DEINTERLACE_HW</b></dt>
    ///    </dl> </td> <td width="60%"> The video card does not support hardware deinterlacing. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt> </dl> </td> <td width="60%"> The VMR is not in
    ///    mixer mode. </td> </tr> </table>
    ///    
    HRESULT GetDeinterlaceModeCaps(GUID* lpDeinterlaceMode, VMR9VideoDesc* lpVideoDescription, 
                                   VMR9DeinterlaceCaps* lpDeinterlaceCaps);
    ///The <b>GetDeinterlaceMode</b> method retrieves the deinterlacing mode for the specified video stream.
    ///Params:
    ///    dwStreamID = Index of the video stream to check.
    ///    lpDeinterlaceMode = Pointer to a variable that receives a GUID. The GUID identifies the deinterlacing mode currently in use. If
    ///                        no deinterlacing mode was set, or the pin corresponding to the stream ID is not connected to an interlaced
    ///                        stream, the value is GUID_NULL.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid stream number. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No deinterlacing mode was set. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt> </dl> </td> <td width="60%"> The VMR is not in
    ///    mixer mode. </td> </tr> </table>
    ///    
    HRESULT GetDeinterlaceMode(uint dwStreamID, GUID* lpDeinterlaceMode);
    ///The <b>SetDeinterlaceMode</b> method sets the deinterlacing mode for the specified video stream.
    ///Params:
    ///    dwStreamID = Index of the video stream to set. To set all streams, use the value 0xFFFFFFFF.
    ///    lpDeinterlaceMode = Pointer to a GUID that specifies the deinterlacing mode. To turn off deinterlacing, use the value GUID_NULL.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid stream number. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt> </dl> </td> <td width="60%"> The VMR is not in mixer mode. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetDeinterlaceMode(uint dwStreamID, GUID* lpDeinterlaceMode);
    ///The <b>GetDeinterlacePrefs</b> method queries how the VMR will select a deinterlacing mode if it cannot use the
    ///preferred deinterlacing mode.
    ///Params:
    ///    lpdwDeinterlacePrefs = Pointer to a variable that receives a member of the VMR9DeinterlacePrefs enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt>
    ///    </dl> </td> <td width="60%"> The VMR is not in mixer mode. </td> </tr> </table>
    ///    
    HRESULT GetDeinterlacePrefs(uint* lpdwDeinterlacePrefs);
    ///The <b>SetDeinterlacePrefs</b> method specifies how the VMR will select a deinterlacing mode if it cannot use the
    ///preferred deinterlacing mode.
    ///Params:
    ///    dwDeinterlacePrefs = Specifies a member of the VMR9DeinterlacePrefs enumeration type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt>
    ///    </dl> </td> <td width="60%"> The VMR is not in mixer mode. </td> </tr> </table>
    ///    
    HRESULT SetDeinterlacePrefs(uint dwDeinterlacePrefs);
    ///The <b>GetActualDeinterlaceMode</b> method returns the deinterlacing mode that the VMR is using for a specified
    ///stream.
    ///Params:
    ///    dwStreamID = Index of the video stream.
    ///    lpDeinterlaceMode = Pointer to a variable that receives a GUID value that identifies the deinterlacing mode. The method returns
    ///                        GUID_NULL if the VMR has not initialized the deinterlacing hardware, or if the VMR determines that this
    ///                        stream should not be deinterlaced.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid stream number. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VFW_E_VMR_NOT_IN_MIXER_MODE</b></dt> </dl> </td> <td width="60%"> The VMR is not in mixer mode. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetActualDeinterlaceMode(uint dwStreamID, GUID* lpDeinterlaceMode);
}

///The <code>IVMRImageCompositor9</code> interface is implemented by the default compositor for the Video Mixing
///Renderer Filter 9 (VMR-9). It must also be implemented by any plug-in compositor that an application provides for the
///VMR-9. The VMR-9 calls the methods on this interface to inform the compositor that it should composite the incoming
///video frames into a single output frame. Applications do not use this interface.
@GUID("4A5C89EB-DF51-4654-AC2A-E48E02BBABF6")
interface IVMRImageCompositor9 : IUnknown
{
    ///The <code>InitCompositionDevice</code> method informs the compositor that a new composition target has been
    ///created. The compositor should perform any necessary configuration work in this method. This could include
    ///attaching a Z or stencil buffer for the new render target.
    ///Params:
    ///    pD3DDevice = Pointer to the <b>IUnknown</b> interface of the Direct3D device object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT InitCompositionDevice(IUnknown pD3DDevice);
    ///The <code>TermCompositionDevice</code> method informs the compositor that the current composition target is being
    ///replaced. Compositors should perform any necessary cleanup of the composition target in this method.
    ///Params:
    ///    pD3DDevice = Pointer to the <b>IUnknown</b> interface of the Direct3D device object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT TermCompositionDevice(IUnknown pD3DDevice);
    ///The <code>SetStreamMediaType</code> method sets the media type for the input stream.
    ///Params:
    ///    dwStrmID = Specifies the input stream; must be from 1 through 16.
    ///    pmt = Pointer to the AM_MEDIA_TYPE struct that specifies the media type.
    ///    fTexture = If <b>TRUE</b>, specifies that the target surface is a Direct3D texture surface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetStreamMediaType(uint dwStrmID, AM_MEDIA_TYPE* pmt, BOOL fTexture);
    ///The <code>CompositeImage</code> method composites the current frames available in each input stream.
    ///Params:
    ///    pD3DDevice = Pointer to the <b>IUnknown</b> interface of the Direct3D device object.
    ///    pddsRenderTarget = Specifies the Direct3D surface that all drawing should be performed on.
    ///    pmtRenderTarget = Pointer to an AM_MEDIA_TYPE structure that contains the media type of the target surface.
    ///    rtStart = Specifies the start time.
    ///    rtEnd = Specifies the end time.
    ///    dwClrBkGnd = Specifies the background color, as a <b>D3DCOLOR</b> type.
    ///    pVideoStreamInfo = Pointer to an array of VMR9VideoStreamInfo structures, which descibe each video stream.
    ///    cStreams = Specifies the number of streams to mix, which is also the size of the <i>pVideoStreamInfo</i> array.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CompositeImage(IUnknown pD3DDevice, IDirect3DSurface9 pddsRenderTarget, AM_MEDIA_TYPE* pmtRenderTarget, 
                           long rtStart, long rtEnd, uint dwClrBkGnd, VMR9VideoStreamInfo* pVideoStreamInfo, 
                           uint cStreams);
}

///<code>IVPBaseConfig</code> is implemented on a filter that wraps a hardware device such as a decoder or capture
///device, if the device has a video port to the graphics adapter. This interface allows the video port to communicate
///with the Overlay Mixer filter regarding configuration information. The IVPConfig interface derives from this
///interface. Applications should never use this interface.
interface IVPBaseConfig : IUnknown
{
    ///The <code>GetConnectInfo</code> method retrieves information about the connections supported by the VPE object.
    ///Params:
    ///    pdwNumConnectInfo = Pointer to a variable that specifies the number of <b>DDVIDEOPORTCONNECT</b> structures in the
    ///                        <i>pddVPConnectInfo</i> array. On input, specifies the size of the array (in number of array elements). On
    ///                        output, contains the actual number of <b>DDVIDEOPORTCONNECT</b> structures that were copied into the array.
    ///                        If <i>pddVPConnectInfo</i> is <b>NULL</b>, the method returns the required array size.
    ///    pddVPConnectInfo = Pointer to an array of <b>DDVIDEOPORTCONNECT</b> structures, allocated by the caller. The device fills in the
    ///                       array with the connection information.
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT GetConnectInfo(uint* pdwNumConnectInfo, char* pddVPConnectInfo);
    ///The <code>SetConnectInfo</code> method sets the video port connection parameters.
    ///Params:
    ///    dwChosenEntry = Specifies the index of connect information to pass to the driver. The value is a zero-based index into the
    ///                    array returned by the IVPBaseConfig::GetConnectInfo method.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetConnectInfo(uint dwChosenEntry);
    ///The <code>GetVPDataInfo</code> method retrieves the current video port data information.
    ///Params:
    ///    pamvpDataInfo = Pointer to an AMVPDATAINFO structure allocated by the caller. The device fills in the structure with
    ///                    information about the video port.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetVPDataInfo(AMVPDATAINFO* pamvpDataInfo);
    ///The <code>GetMaxPixelRate</code> method retrieves the maximum pixel rate the device will output for a given width
    ///and height.
    ///Params:
    ///    pamvpSize = Pointer to an AMVPSIZE structure containing the desired width and height.
    ///    pdwMaxPixelsPerSecond = Pointer to a variable that receives the maximum pixel rate, in pixels per second.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetMaxPixelRate(AMVPSIZE* pamvpSize, uint* pdwMaxPixelsPerSecond);
    ///The <code>InformVPInputFormats</code> method informs the device what video formats the video port supports.
    ///Params:
    ///    dwNumFormats = Number of video formats contained in the <i>pDDPixelFormats</i> parameter.
    ///    pDDPixelFormats = Pointer to an array of pixel format structures (<b>DDPIXELFORMAT</b>) to send to the device.
    ///Returns:
    ///    Returns S_FALSE if failure, or S_OK otherwise.
    ///    
    HRESULT InformVPInputFormats(uint dwNumFormats, DDPIXELFORMAT* pDDPixelFormats);
    ///The <code>GetVideoFormats</code> method retrieves the video formats the driver supports.
    ///Params:
    ///    pdwNumFormats = Pointer to a variable that specifies the number of <b>DDPIXELFORMAT</b> structures in the
    ///                    <i>pddPixelFormats</i> array. On input, specifies the size of the array (in number of array elements). On
    ///                    output, contains the actual number of <b>DDPIXELFORMAT</b> structures that were copied into the array. If
    ///                    <i>pddPixelFormat</i> is <b>NULL</b>, the method returns the required array size.
    ///    pddPixelFormats = Pointer to an array of <b>DDPIXELFORMAT</b> structures, allocated by the caller. The device fills in the
    ///                      array with the format information.
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT GetVideoFormats(uint* pdwNumFormats, char* pddPixelFormats);
    ///The <code>SetVideoFormat</code> method sets the video format.
    ///Params:
    ///    dwChosenEntry = Value specifying the index (zero-based) of the video pixel format to use.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetVideoFormat(uint dwChosenEntry);
    ///The <code>SetInvertPolarity</code> method reverses the current polarity the device uses.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetInvertPolarity();
    ///The <code>GetOverlaySurface</code> method queries whether the caller should use the driver's overlay surface. If
    ///so, the method returns a pointer to the surface.
    ///Params:
    ///    ppddOverlaySurface = Address of a pointer to the <b>IDirectDrawSurface</b> interface. If the caller should use the driver's
    ///                         overlay surface, it sets this variable equal to the <b>IDirectDrawSurface</b> interface for the overlay
    ///                         surface.
    ///Returns:
    ///    Returns S_OK if the overlay surface object was returned.
    ///    
    HRESULT GetOverlaySurface(IDirectDrawSurface* ppddOverlaySurface);
    ///The <code>SetDirectDrawKernelHandle</code> method sets the kernel-mode handle to the DirectDraw object. This
    ///handle enables the device's mini-driver to communicate with DirectDraw.
    ///Params:
    ///    dwDDKernelHandle = Specifies the kernel-mode handle of the DirectDraw object.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetDirectDrawKernelHandle(size_t dwDDKernelHandle);
    ///The <code>SetVideoPortID</code> method specifies the ID of the hardware video port to use.
    ///Params:
    ///    dwVideoPortID = Specifies the video port ID. This value corresponds to the <b>dwVideoPortID</b> member of the
    ///                    <b>DDVIDEOPORTDESC</b> structure, which is documented in the Windows DDK.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetVideoPortID(uint dwVideoPortID);
    ///The <code>SetDDSurfaceKernelHandles</code> method specifies the kernel-mode handles of the DirectDraw surfaces to
    ///be used for the overlay suface.
    ///Params:
    ///    cHandles = Specifies the number of handles in the <i>rgDDKernelHandles</i> array.
    ///    rgDDKernelHandles = Address of an array of kernel-mode handles.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetDDSurfaceKernelHandles(uint cHandles, size_t* rgDDKernelHandles);
    ///The <code>SetSurfaceParameters</code> method informs the device of the layout of the overlay surface. The
    ///downstream filter (the Overlay Mixer, VBI Surface Allocator, or Video Port Manager) calls this method after it
    ///creates the overlay surface.
    ///Params:
    ///    dwPitch = Specifies the stride of the surface (also called the <i>pitch</i>), in pixels.
    ///    dwXOrigin = Specifies the X-coordinate of the pixel at which valid data starts.
    ///    dwYOrigin = Specifies the Y-coordinate of the pixel at which valid data starts.
    ///Returns:
    ///    Returns S_OK if successful, or E_NOTIMPL.
    ///    
    HRESULT SetSurfaceParameters(uint dwPitch, uint dwXOrigin, uint dwYOrigin);
}

///The <b>IVPConfig</b> interface must be implemented by any filter that wraps a hardware decoder with a video port.
///This enables the Overlay Mixer, through its IVPNotify interface, to set and retrieve configuration information on the
///video port regarding the video memory on the display adapter. This interface derives from IVPBaseConfig. Applications
///never use this interface.
interface IVPConfig : IVPBaseConfig
{
    ///The <code>IsVPDecimationAllowed</code> method, given the context, retrieves whether scaling at the video port is
    ///possible.
    ///Params:
    ///    pbIsDecimationAllowed = Receives a Boolean value indicating whether decimation is possible.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT IsVPDecimationAllowed(int* pbIsDecimationAllowed);
    ///The <code>SetScalingFactors</code> method sets the factors by which the decoder should scale the video stream.
    ///Params:
    ///    pamvpSize = Pointer to the new scaling size structure (AMVPSIZE) to use to specify the width and height.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetScalingFactors(AMVPSIZE* pamvpSize);
}

interface IVPVBIConfig : IVPBaseConfig
{
}

///Enables the Overlay Mixer to control the properties of a hardware device such as a decoder that uses a video port.
///The IVPNotify interface derives from this interface. Applications should never use this interface.
interface IVPBaseNotify : IUnknown
{
    ///The <code>RenegotiateVPParameters</code> method initializes the connection to the decoder.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT RenegotiateVPParameters();
}

///Supports a private communication mechanism between the Overlay Mixer filter and a VPE decoder filter that represents
///a hardware decoder. Only the Overlay Mixer filter implements this interface. Applications should never use it.
interface IVPNotify : IVPBaseNotify
{
    ///Sets the mode (such as bob or weave).
    ///Params:
    ///    mode = Specified mode. This value is a member of the AMVP_MODE enumerated data type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetDeinterlaceMode(AMVP_MODE mode);
    ///The <code>GetDeinterlaceMode</code> method retrieves the mode (such as bob or weave). This method is not
    ///currently implemented and returns E_NOTIMPL.
    ///Params:
    ///    pMode = Pointer to the retrieved mode. This value is a member of the AMVP_MODE enumerated data type.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT GetDeinterlaceMode(AMVP_MODE* pMode);
}

///The <code>IVPNotify2</code> interface inherits from IVPNotify and is implemented by the Overlay Mixer filter. This
///interface enables the Overlay Mixer to communicate with a video port (on a hardware device such as a decoder) that
///implements IVPConfig. Applications should never use this interface.
interface IVPNotify2 : IVPNotify
{
    ///The <code>SetVPSyncMaster</code> method sets whether the video port controls vertical synchronization of the VGA.
    ///Params:
    ///    bVPSyncMaster = Value specifying whether the video port controls the vertical synchronization of the VGA monitor. <b>TRUE</b>
    ///                    if the port controls the monitor's synchronization; <b>FALSE</b> otherwise.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetVPSyncMaster(BOOL bVPSyncMaster);
    ///The <code>GetVPSyncMaster</code> method checks whether the video port controls the synchronization of the VGA.
    ///Params:
    ///    pbVPSyncMaster = Pointer to a value indicating whether the video port controls the vertical synchronization of the VGA
    ///                     monitor. <b>TRUE</b> if the port controls the monitor's synchronization; <b>FALSE</b> otherwise.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT GetVPSyncMaster(int* pbVPSyncMaster);
}

interface IVPVBINotify : IVPBaseNotify
{
}

///The <b>IXMLGraphBuilder</b> interface is used to persist a DirectShow filter graph using an XML file format. <div
///class="alert"><b>Note</b> Support for this interface was removed in Windows 7. New applications should not use this
///interface.</div> <div> </div>
interface IXMLGraphBuilder : IUnknown
{
    ///The <b>BuildFromXML</b> method loads a filter graph from an XML element. <div class="alert"><b>Note</b> Support
    ///for this interface was removed in Windows 7. New applications should not use this interface.</div><div> </div>
    ///Params:
    ///    pGraph = Pointer to the Filter Graph Manager's IGraphBuilder interface. To create the Filter Graph Manager, call
    ///             <b>CoCreateInstance</b>. Do not add any filters to the graph before calling this method.
    ///    pxml = Pointer to the <b>IXMLElement</b> interface of an XML element object. The XML element object must contain the
    ///           string returned by the IXMLGraphBuilder::SaveToXML method. <div class="alert"><b>Note</b> The
    ///           <b>IXMLElement</b> interface is implemented in Microsoft XML Core Services (MSXML) version 1.0 but is not
    ///           implemented in more recent versions of MSXML.</div> <div> </div>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT BuildFromXML(IGraphBuilder pGraph, IXMLElement pxml);
    ///The <b>SaveToXML</b> method saves a filter graph to an XML element. <div class="alert"><b>Note</b> Support for
    ///this interface was removed in Windows 7. New applications should not use this interface.</div><div> </div>
    ///Params:
    ///    pGraph = Pointer to the Filter Graph Manager's IGraphBuilder interface.
    ///    pbstrxml = Pointer to a <b>BSTR</b> that receives the XML element. The caller must release the string by calling
    ///               <b>SysFreeString</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SaveToXML(IGraphBuilder pGraph, BSTR* pbstrxml);
    ///The <b>BuildFromXMLFile</b> method loads a filter graph from an XML file. <div class="alert"><b>Note</b> Support
    ///for this interface was removed in Windows 7. New applications should not use this interface.</div><div> </div>
    ///Params:
    ///    pGraph = Pointer to the Filter Graph Manager's IGraphBuilder interface. To create the Filter Graph Manager, call
    ///             <b>CoCreateInstance</b>. Do not add any filters to the graph before calling this method.
    ///    wszFileName = Wide-character string that contains the full path name of an XML file. The XML file must contain the string
    ///                  returned by the IXMLGraphBuilder::SaveToXML method.
    ///    wszBaseURL = Reserved. Set to <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT BuildFromXMLFile(IGraphBuilder pGraph, const(wchar)* wszFileName, const(wchar)* wszBaseURL);
}

///The <code>IMediaParamInfo</code> interface retrieves information about the parameters that an object supports. The
///set of parameters that an object supports will not change over the lifetime of an application. To set parameter
///values, use the IMediaParams interface.
@GUID("6D6CBB60-A223-44AA-842F-A2F06750BE6D")
interface IMediaParamInfo : IUnknown
{
    ///The <code>GetParamCount</code> method retrieves the number of parameters that the object supports.
    ///Params:
    ///    pdwParams = Pointer to a variable that receives the number of parameters.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetParamCount(uint* pdwParams);
    ///The <code>GetParamInfo</code> method retrieves information about a specified parameter.
    ///Params:
    ///    dwParamIndex = Zero-based index of the parameter.
    ///    pInfo = Pointer to an MP_PARAMINFO structure that is filled with the parameter information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Index out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetParamInfo(uint dwParamIndex, MP_PARAMINFO* pInfo);
    ///The <code>GetParamText</code> method retrieves a series of text strings that describe the parameter.
    ///Params:
    ///    dwParamIndex = Zero-based index of the parameter.
    ///    ppwchText = Address of a variable that receives a pointer to a series of Unicode™ strings.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Index out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetParamText(uint dwParamIndex, ushort** ppwchText);
    ///The <code>GetNumTimeFormats</code> method retrieves the number of time formats that the object supports.
    ///Params:
    ///    pdwNumTimeFormats = Pointer to a variable that receives the number of supported time formats.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetNumTimeFormats(uint* pdwNumTimeFormats);
    ///The <code>GetSupportedTimeFormat</code> method retrieves a supported time format.
    ///Params:
    ///    dwFormatIndex = Index of the time format to retrieve.
    ///    pguidTimeFormat = Pointer to a variable that receives a time format GUID.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Index out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetSupportedTimeFormat(uint dwFormatIndex, GUID* pguidTimeFormat);
    ///The <code>GetCurrentTimeFormat</code> method retrieves the current time format.
    ///Params:
    ///    pguidTimeFormat = Pointer to a variable that receives a time format GUID.
    ///    pTimeData = Pointer to a variable that receives an <b>MP_TIMEDATA</b> value specifying the unit of measure for the new
    ///                format.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetCurrentTimeFormat(GUID* pguidTimeFormat, uint* pTimeData);
}

///The <code>IMediaParams</code> interface sets and retrieves envelope-following parameters on an object. To reduce
///overhead, parameters are referenced by index value, and all parameter values are 32 bits, defined as type
///<b>MP_DATA</b>. Use the IMediaParamInfo interface to determine whether a given parameter is an integer,
///floating-point value, Boolean value, or member of an enumerated type.
@GUID("6D6CBB61-A223-44AA-842F-A2F06750BE6E")
interface IMediaParams : IUnknown
{
    ///The <code>GetParam</code> method retrieves the current value of the specified parameter. If the parameter is
    ///currently within an envelope segment, the returned value is the value on the most recently processed sample.
    ///Params:
    ///    dwParamIndex = Zero-based index of the parameter.
    ///    pValue = Pointer to a variable of type <b>MP_DATA</b> that receives the parameter value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Index out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetParam(uint dwParamIndex, float* pValue);
    ///The <code>SetParam</code> method sets the value of a parameter.
    ///Params:
    ///    dwParamIndex = Zero-based index of the parameter, or DWORD_ALLPARAMS to apply the value to every parameter.
    ///    value = New value of the parameter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Index out of range, or illegal parameter value. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetParam(uint dwParamIndex, float value);
    ///The <code>AddEnvelope</code> method adds an envelope to a parameter.
    ///Params:
    ///    dwParamIndex = Zero-based index of the parameter, or DWORD_ALLPARAMS to add the envelope to every parameter.
    ///    cSegments = Number of segments in the envelope.
    ///    pEnvelopeSegments = Pointer to an array of MP_ENVELOPE_SEGMENT structures that define the envelope segments. The size of the
    ///                        array is given in the <i>cPoints</i> parameter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Index out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMEORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT AddEnvelope(uint dwParamIndex, uint cSegments, MP_ENVELOPE_SEGMENT* pEnvelopeSegments);
    ///The <code>FlushEnvelope</code> method flushes envelope data for a specified parameter over the specified time
    ///range.
    ///Params:
    ///    dwParamIndex = Zero-based index of the parameter, or DWORD_ALLPARAMS to flush envelope data from every parameter.
    ///    refTimeStart = Start time of the envelope data to flush.
    ///    refTimeEnd = Stop time of the envelope data to flush.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Index out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT FlushEnvelope(uint dwParamIndex, long refTimeStart, long refTimeEnd);
    ///The <code>SetTimeFormat</code> method specifies the time format for the object.
    ///Params:
    ///    guidTimeFormat = Time format GUID that specifies the time format.
    ///    mpTimeData = Value of type <b>MP_TIMEDATA</b> that specifies the unit of measure for the new format.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Object does not support this time format. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT SetTimeFormat(GUID guidTimeFormat, uint mpTimeData);
}

///The <b>ICreatePropBagOnRegKey</b> interface creates a property bag that can store information in the system registry.
///Use this interface to store the default tune request in the registry. When Microsoft® Internet Explorer® loads a
///"tv:" object in a Web page, it automatically tunes to the default tune request.
@GUID("8A674B48-1F63-11D3-B64C-00C04F79498E")
interface ICreatePropBagOnRegKey : IUnknown
{
    ///The <b>Create</b> method creates a property bag that can store information in the system registry.
    ///Params:
    ///    hkey = Specifies a handle to the registry key.
    ///    subkey = Specifies the subkey.
    ///    ulOptions = Reserved; must be zero.
    ///    samDesired = Specifies the desired access rights to the key. The value can be any combination of flags from the
    ///                 <i>samDesired</i> parameter in the Win32 <b>RegOpenKeyEx</b> function.
    ///    iid = Specifies the interface identifier (IID) of a property bag interface. Use the value IID_IPropertyBag or
    ///          IID_IPropertyBag2.
    ///    ppBag = Address of a variable that receives the interface specified by the <i>iid</i> parameter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The
    ///    specified IID is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT Create(HKEY hkey, ushort* subkey, uint ulOptions, uint samDesired, const(GUID)* iid, void** ppBag);
}

///The <b>ITuningSpaces</b> interface represents a collection of tuning spaces.
@GUID("901284E4-33FE-4B69-8D63-634A596F3756")
interface ITuningSpaces : IDispatch
{
    ///The <b>get_Count</b> method returns the number of tuning spaces in the collection.
    ///Params:
    ///    Count = Pointer to a variable that receives the number of items in the collection.
    ///Returns:
    ///    Returns S_OK if successful.
    ///    
    HRESULT get_Count(int* Count);
    ///The <b>get__NewEnum</b> method returns an enumerator for the collection. This method is provided to enable
    ///scripting and Visual Basic applications to iterate through the collection in a <code>For...Each</code> loop. C++
    ///applications should use the ITuningSpaces::get_EnumTuningSpaces method.
    ///Params:
    ///    NewEnum = Pointer to a variable that receives an <b>IEnumVARIANT</b> interface pointer. The caller must release the
    ///              interface.
    ///Returns:
    ///    Returns S_OK if successful.
    ///    
    HRESULT get__NewEnum(IEnumVARIANT* NewEnum);
    ///The <b>get_Item</b> method returns the specified item in the collection.
    ///Params:
    ///    varIndex = <b>VARIANT</b> type that specifies the ID of the tuning space. The ID uniquely identifies the tuning space
    ///               within the <b>SystemTuningSpaces</b> object.
    ///    TuningSpace = Address of a variable that receives a pointer to the tuning space's ITuningSpace interface. The caller must
    ///                  release the interface.
    ///Returns:
    ///    Returns S_OK if successful.
    ///    
    HRESULT get_Item(VARIANT varIndex, ITuningSpace* TuningSpace);
    ///The <b>get_EnumTuningSpaces</b> method returns an enumerator for the collection.
    ///Params:
    ///    NewEnum = Pointer to a variable that receives an IEnumTuningSpaces interface pointer. Use this interface to iterate
    ///              through the collection. The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful.
    ///    
    HRESULT get_EnumTuningSpaces(IEnumTuningSpaces* NewEnum);
}

///The <b>ITuningSpaceContainer</b> interface is implemented on the SystemTuningSpaces object. It provides access to all
///tuning spaces installed on the host system.
@GUID("5B692E84-E2F1-11D2-9493-00C04F72D980")
interface ITuningSpaceContainer : IDispatch
{
    ///The <b>get_Count</b> method retrieves the number of tuning spaces currently available on the local system.
    ///Params:
    ///    Count = Pointer to a variable receives the number of tuning spaces.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Count(int* Count);
    ///The <b>get__NewEnum</b> method supports <code>For...Each</code> loops in Automation clients.
    ///Params:
    ///    NewEnum = Pointer to a variable that receives an <b>IEnumVARIANT</b> interface pointer. The caller must release the
    ///              interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get__NewEnum(IEnumVARIANT* NewEnum);
    ///The <b>get_Item</b> method retrieves a tuning space with the specified ID.
    ///Params:
    ///    varIndex = <b>VARIANT</b> that specifies the ID of the tuning space.
    ///    TuningSpace = Address of an ITuningSpace interface pointer that will be set to the returned interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Item(VARIANT varIndex, ITuningSpace* TuningSpace);
    ///The <b>put_Item</b> method saves changes to an existing tuning space in the collection.
    ///Params:
    ///    varIndex = <b>VARIANT</b> that specifies the index of the tuning space.
    ///    TuningSpace = Pointer to the ITuningSpace interface of the tuning space.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success. </td> </tr> </table> If the method fails, error information can be retrieved
    ///    using the standard COM <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Item(VARIANT varIndex, ITuningSpace TuningSpace);
    ///The <b>TuningSpacesForCLSID</b> method retrieves a collection of tuning spaces that match the specified CLSID.
    ///This method is intended for Automation clients, because it returns the CLSID as a <b>BSTR</b>. C++ applications
    ///can use the ITuningSpaceContainer::_TuningSpacesForCLSID method instead, which returns a GUID value.
    ///Params:
    ///    SpaceCLSID = String representation of the CLSID of the tuning space.
    ///    NewColl = Receives a pointer to the ITuningSpaces interface. The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT TuningSpacesForCLSID(BSTR SpaceCLSID, ITuningSpaces* NewColl);
    HRESULT _TuningSpacesForCLSID2(const(GUID)* SpaceCLSID, ITuningSpaces* NewColl);
    ///The <b>TuningSpacesForName</b> method retrieves a collection of tuning spaces that match the specified name.
    ///Params:
    ///    Name = String that contains a regular expression to match against either the friendly name or the unique name of the
    ///           tuning space.
    ///    NewColl = Address of variable that receives an ITuningSpaces interface pointer. Use this interface to enumerate the
    ///              collection. The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT TuningSpacesForName(BSTR Name, ITuningSpaces* NewColl);
    ///The <b>FindID</b> method retrieves the ID of a specified tuning space within the collection.
    ///Params:
    ///    TuningSpace = Pointer to the <b>ITuningSpace</b> interface of the tuning space.
    ///    ID = Pointer to a variable that receives the ID of the tuning space. The returned value is specific to this
    ///         collection object (which represents the local system).
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The specified tuning space is not a member of this collection. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT FindID(ITuningSpace TuningSpace, int* ID);
    ///The <b>Add</b> method adds a new persistent tuning space to the system.
    ///Params:
    ///    TuningSpace = Pointer to the ITuningSpace interface of the new tuning space
    ///    NewIndex = Pointer to a variable of type <b>VARIANT</b> that receives the ID of the new tuning space within the current
    ///               collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Add(ITuningSpace TuningSpace, VARIANT* NewIndex);
    ///The <b>get_EnumTuningSpaces</b> method retrieves a collection of all tuning spaces available on the local system.
    ///Params:
    ///    ppEnum = Pointer to a variable that receives an IEnumTuningSpaces interface pointer. Use this interface to enumerate
    ///             the collection. The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_EnumTuningSpaces(IEnumTuningSpaces* ppEnum);
    ///The <b>Remove</b> method permanently removes a tuning space from the system.
    ///Params:
    ///    Index = Variable of type <b>VARIANT</b> that specifies the ID of the tuning space to remove.
    ///Returns:
    ///    Returns S_OK if successful. If the specified tuning space was invalid or corrupted in the Registry, this
    ///    method will delete whatever information is there and return S_FALSE.
    ///    
    HRESULT Remove(VARIANT Index);
    ///The <b>get_MaxCount</b> method retrieves the maximum number of tuning spaces allowed on the system.
    ///Params:
    ///    MaxCount = Pointer to a variable that receives the maximum number of tuning spaces.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_MaxCount(int* MaxCount);
    ///The <b>put_MaxCount</b> method sets the maximum number of tuning spaces allowed on the system.
    ///Params:
    ///    MaxCount = Specifies the maximum number of tuning spaces.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_MaxCount(int MaxCount);
}

///The <b>ITuningSpace</b> interface provides the common functionality for all network-specific tuning spaces.
///Applications can obtain tuning spaces from the SystemTuningSpaces collection. A tuning space generally exposes an
///interface that inherits <b>ITuningSpace</b>, such as IATSCTuningSpace.
@GUID("061C6E30-E622-11D2-9493-00C04F72D980")
interface ITuningSpace : IDispatch
{
    ///The <b>get_UniqueName</b> method retrieves the unique name of the tuning space.
    ///Params:
    ///    Name = Pointer to a variable that receives the unique name.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_UniqueName(BSTR* Name);
    ///The <b>put_UniqueName</b> method sets a unique name for the tuning space.
    ///Params:
    ///    Name = Variable of type <b>BSTR</b> that specifies the unique name.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_UniqueName(BSTR Name);
    ///The <b>get_FriendlyName</b> method retrieves the localized, user-friendly name of the tuning space.
    ///Params:
    ///    Name = Pointer to a variable receives the user-friendly name.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_FriendlyName(BSTR* Name);
    ///The <b>put_FriendlyName</b> method sets the localized, user-friendly name of the tuning space.
    ///Params:
    ///    Name = Specifies the user-friendly name.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_FriendlyName(BSTR Name);
    ///The <b>get_CLSID</b> method gets the CLSID of the tuning space as a <b>BSTR</b>.
    ///Params:
    ///    SpaceCLSID = Pointer to a variable that receives a string representation of the tuning space CLSID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_CLSID(BSTR* SpaceCLSID);
    ///The <b>get_NetworkType</b> method retrieves the network type of the tuning space as a <b>BSTR</b>. This method is
    ///intended for Automation clients, because it returns the CLSID as a <b>BSTR</b>. C++ applications can use the
    ///ITuningSpace::get__NetworkType method instead, which returns a GUID value
    ///Params:
    ///    NetworkTypeGuid = Pointer to a variable that receives a string containing the network type GUID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_NetworkType(BSTR* NetworkTypeGuid);
    ///The <b>put_NetworkType</b> method specifies the network type of the tuning space as a <b>BSTR</b>. This method is
    ///intended for Automation clients, because it specifies the CLSID as a <b>BSTR</b>. C++ applications can use the
    ///ITuningSpace::put__NetworkType method instead, which takes a GUID value.
    ///Params:
    ///    NetworkTypeGuid = Contains the string representation of the network type GUID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_NetworkType(BSTR NetworkTypeGuid);
    ///The <b>get_NetworkType</b> method retrieves the network type for this tuning space.
    ///Params:
    ///    NetworkTypeGuid = Pointer to a variable that receives the network type GUID. This GUID corresponds to the CLSID of the Network
    ///                      Provider for the tuning space. For some tuning spaces, the network type is GUID_NULL, which means the tuning
    ///                      space does not use a Network Provider filter.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get__NetworkType(GUID* NetworkTypeGuid);
    ///The <b>put_NetworkType</b> method specifies the network type of the tuning space.
    ///Params:
    ///    NetworkTypeGuid = Specifies the network type GUID. This GUID corresponds to the CLSID of the Network Provider for the tuning
    ///                      space. The value GUID_NULL means the tuning space does not use a Network Provider filter.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put__NetworkType(const(GUID)* NetworkTypeGuid);
    ///The <b>CreateTuneRequest</b> method creates an empty (uninitialized) tune request.
    ///Params:
    ///    TuneRequest = Address of a variable that receives a pointer to the ITuneRequest interface of the new tune request object.
    ///                  The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT CreateTuneRequest(ITuneRequest* TuneRequest);
    ///Currently not implemented. The <b>EnumCategoryGUIDs</b> method creates an enumerator for the DirectShow category
    ///of filters that support the tuning space.
    ///Params:
    ///    ppEnum = Address of an <b>IEnumGUID</b> interface pointer that receives the returned enumeration object.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT EnumCategoryGUIDs(IEnumGUID* ppEnum);
    ///<div class="alert"><b>Note</b> Currently not implemented. </div> <div> </div> The <b>EnumDeviceMonikers</b>
    ///method creates an enumerator of device monikers representing the tuner filters that support this tuning space.
    ///Params:
    ///    ppEnum = Address of an <b>IEnumMoniker</b> interface pointer that receives the returned enumeration object.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT EnumDeviceMonikers(IEnumMoniker* ppEnum);
    ///The <b>get_DefaultPreferredComponentTypes</b> method returns an list of the default preferred component types for
    ///this tuning space.
    ///Params:
    ///    ComponentTypes = Address of a variable that receives an IComponentTypes interface pointer. Use this interface to enumerate the
    ///                     component types. The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_DefaultPreferredComponentTypes(IComponentTypes* ComponentTypes);
    ///The <b>put_DefaultPreferredComponentTypes</b> method specifies the default preferred component types for this
    ///tuning space.
    ///Params:
    ///    NewComponentTypes = Pointer to the IComponentTypes interface of the component types collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_DefaultPreferredComponentTypes(IComponentTypes NewComponentTypes);
    ///The <b>get_FrequencyMapping</b> method retrieves the frequency mapping previously created by the network provider
    ///by a call to <b>put_FrequencyMapping</b>.
    ///Params:
    ///    pMapping = Pointer to a variable that receives the frequency mappings created by the Network Provider filter.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_FrequencyMapping(BSTR* pMapping);
    ///The <b>put_FrequencyMapping</b> method creates a frequency/channel map, frequency/transponder map, or whatever
    ///other mapping from carrier frequencies to frequency identifiers is appropriate for the tuning space.
    ///Params:
    ///    Mapping = <b>BSTR</b> that contains the frequency mappings.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_FrequencyMapping(BSTR Mapping);
    ///The <b>get_DefaultLocator</b> method retrieves the default locator for this tuning space.
    ///Params:
    ///    LocatorVal = Address of a variable that receives a pointer to ILocator interface. The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_DefaultLocator(ILocator* LocatorVal);
    ///The <b>put_DefaultLocator</b> method sets the default locator for this tuning space.
    ///Params:
    ///    LocatorVal = Pointer to the ILocator interface of the locator object.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_DefaultLocator(ILocator LocatorVal);
    ///The <b>Clone</b> method creates a new copy of the tuning space.
    ///Params:
    ///    NewTS = Receives a pointer to the ITuningSpace interface of the new tuning space object. The caller must release the
    ///            interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Clone(ITuningSpace* NewTS);
}

///The <b>IEnumTuningSpaces</b> interface is implemented on a standard COM collection of tuning space objects and is
///obtained through various ITuningSpaceContainer.
@GUID("8B8EB248-FC2B-11D2-9D8C-00C04F72D980")
interface IEnumTuningSpaces : IUnknown
{
    ///The <b>Next</b> method retrieves the next n elements in the collection.
    ///Params:
    ///    celt = The number of elements to retrieve.
    ///    rgelt = Address of an array of ITuningSpace interface pointers that will receive the retrieved Tuning Space objects.
    ///    pceltFetched = Receives the number of elements actually retrieved.
    ///Returns:
    ///    Returns S_OK if successful. This method will succeed even if <i>celt</i> is zero. If the method fails, error
    ///    information can be retrieved using the standard COM <b>IErrorInfo</b> interface.
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///The <b>Skip</b> method skips the specified element in the collection.
    ///Params:
    ///    celt = The index of the element to skip.
    ///Returns:
    ///    Returns S_OK if successful. This method will succeed even if <i>celt</i> is zero. If the method fails, error
    ///    information can be retrieved using the standard COM <b>IErrorInfo</b> interface.
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Reset</b> method moves the iterator to the beginning of the collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Reset();
    ///The <b>Clone</b> method creates a new copy of the collection and all its sub-objects.
    ///Params:
    ///    ppEnum = Address of an IEnumTuningSpaces interface pointer that will receive the returned interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Clone(IEnumTuningSpaces* ppEnum);
}

///The <b>IDVBTuningSpace</b> interface is implemented on the DVBTuningSpace object. <div class="alert"><b>Note</b> New
///applications should use the IDVBTuningSpace2 interface, which inherits <b>IDVBTuningSpace</b> and adds additional
///methods.</div> <div> </div>
@GUID("ADA0B268-3B19-4E5B-ACC4-49F852BE13BA")
interface IDVBTuningSpace : ITuningSpace
{
    ///The <b>get_SystemType</b> method retrieves the system type.
    ///Params:
    ///    SysType = Pointer to a variable of type DVBSystemType that receives the system type.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_SystemType(DVBSystemType* SysType);
    ///The <b>put_SystemType</b> method sets the system type.
    ///Params:
    ///    SysType = Variable of type DVBSystemType that specifies the system type.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_SystemType(DVBSystemType SysType);
}

///The <b>IDVBTuningSpace2</b> interface is implemented on the DVBTuningSpace object. It provides methods for working
///with tuning spaces with a network type of DVB.
@GUID("843188B4-CE62-43DB-966B-8145A094E040")
interface IDVBTuningSpace2 : IDVBTuningSpace
{
    ///The <b>get_NetworkID</b> method retrieves the Network ID of the DVB system.
    ///Params:
    ///    NetworkID = Receive the network ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_NetworkID(int* NetworkID);
    ///The <b>put_NetworkID</b> method sets the Network ID of the DVB system.
    ///Params:
    ///    NetworkID = Specifies the <i>NetworkID</i> as a <b>long</b> integer.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_NetworkID(int NetworkID);
}

///The <b>IDVBSTuningSpace</b> interface is implemented on the <b>DVBTuningSpace</b> object and provides methods for
///working with tuning spaces with a DVBS network type.
@GUID("CDF7BE60-D954-42FD-A972-78971958E470")
interface IDVBSTuningSpace : IDVBTuningSpace2
{
    ///The <b>get_LowOscillator</b> method retrieves the low oscillator frequency.
    ///Params:
    ///    LowOscillator = Receives the low oscillator frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_LowOscillator(int* LowOscillator);
    ///The <b>put_LowOscillator</b> method sets the low oscillator frequency.
    ///Params:
    ///    LowOscillator = Specifies the low oscillator frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_LowOscillator(int LowOscillator);
    ///The <b>get_HighOscillator</b> method retrieves the high oscillator frequency.
    ///Params:
    ///    HighOscillator = Receives the high oscillator frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_HighOscillator(int* HighOscillator);
    ///The <b>put_HighOscillator</b> method sets the high oscillator frequency.
    ///Params:
    ///    HighOscillator = Specifies the high oscillator frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_HighOscillator(int HighOscillator);
    ///The <b>get_LNBSwitch</b> method retrieves the LNB switch.
    ///Params:
    ///    LNBSwitch = Receives the LNB switch frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_LNBSwitch(int* LNBSwitch);
    ///The <b>put_LNBSwitch</b> method sets the LNB switch frequency.
    ///Params:
    ///    LNBSwitch = Specifies the LNB switch frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_LNBSwitch(int LNBSwitch);
    ///The <b>get_InputRange</b> method retrieves an integer indicating which option or switch contains the requested
    ///signal source.
    ///Params:
    ///    InputRange = Receives the input range.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_InputRange(BSTR* InputRange);
    ///The <b>put_InputRange</b> method sets a value indicating which option or switch contains the requested signal
    ///source.
    ///Params:
    ///    InputRange = Specifies which option or switch contains the requested signal source.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_InputRange(BSTR InputRange);
    ///The <b>get_SpectralInversion</b> method retrieves an integer indicating the spectral inversion.
    ///Params:
    ///    SpectralInversionVal = Receives the spectral inversion.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_SpectralInversion(SpectralInversion* SpectralInversionVal);
    ///The <b>put_SpectralInversion</b> method sets a value indicating the spectral inversion.
    ///Params:
    ///    SpectralInversionVal = The spectral inversion.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_SpectralInversion(SpectralInversion SpectralInversionVal);
}

///The <b>IAuxInTuningSpace</b> interface is implemented on AuxInTuningSpace objects, which represent auxiliary video
///inputs such as S-video or composite video on a hardware device that is connected to the computer.
@GUID("E48244B8-7E17-4F76-A763-5090FF1E2F30")
interface IAuxInTuningSpace : ITuningSpace
{
}

///This topic applies to Windows XP Media Center Edition 2004 and later. The <b>IAuxInTuningSpace2</b> interface is
///implemented on AuxInTuningSpace objects, which represent auxiliary video inputs such as S-video or composite video on
///a hardware device that is connected to the computer.
@GUID("B10931ED-8BFE-4AB0-9DCE-E469C29A9729")
interface IAuxInTuningSpace2 : IAuxInTuningSpace
{
    ///This topic applies to Windows XP Media Center Edition 2004 and later. The <b>get_CountryCode</b> method gets the
    ///country/region code of the tuning space (based on TAPI country/region codes).
    ///Params:
    ///    CountryCodeVal = Pointer to a variable that receives the country/region code.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved by using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_CountryCode(int* CountryCodeVal);
    ///This topic applies to Windows XP Media Center Edition 2004 and later. The <b>put_CountryCode</b> method sets the
    ///country/region code of the tuning space (based on TAPI country/region codes).
    ///Params:
    ///    NewCountryCodeVal = The country/region code.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved by using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_CountryCode(int NewCountryCodeVal);
}

///The <b>IAnalogTVTuningSpace</b> interface provides methods for getting and setting parameters associated with analog
///TV tuning spaces. The Video Control uses these methods when building and controlling a WDM Analog TV filter graph.
@GUID("2A6E293C-2595-11D3-B64C-00C04F79498E")
interface IAnalogTVTuningSpace : ITuningSpace
{
    ///The <b>get_MinChannel</b> method gets the lowest channel number for this tuning space.
    ///Params:
    ///    MinChannelVal = Receives the lowest channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_MinChannel(int* MinChannelVal);
    ///The <b>put_MinChannel</b> method sets the lowest channel number for this tuning space.
    ///Params:
    ///    NewMinChannelVal = The lowest channel number.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_MinChannel(int NewMinChannelVal);
    ///The <b>get_MaxChannel</b> method gets the highest channel number for this tuning space.
    ///Params:
    ///    MaxChannelVal = Receives the highest channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_MaxChannel(int* MaxChannelVal);
    ///The <b>put_MaxChannel</b> method sets the highest channel number for this tuning space.
    ///Params:
    ///    NewMaxChannelVal = The highest channel number.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_MaxChannel(int NewMaxChannelVal);
    ///The <b>get_InputType</b> method gets the input type (antenna or cable) intended for the tuning space.
    ///Params:
    ///    InputTypeVal = Pointer to a variable of type TunerInputType that receives the input type.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_InputType(TunerInputType* InputTypeVal);
    ///The <b>put_InputType</b> method sets the input type (antenna or cable) intended for the tuning space.
    ///Params:
    ///    NewInputTypeVal = Variable of type TunerInputType that specifies the input type.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_InputType(TunerInputType NewInputTypeVal);
    ///The <b>get_CountryCode</b> method gets the country/region code of the tuning space (based on TAPI country/region
    ///codes).
    ///Params:
    ///    CountryCodeVal = Receives the value for the country/region code.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_CountryCode(int* CountryCodeVal);
    ///The <b>put_CountryCode</b> method sets the country/region code of the tuning space (based on TAPI country/region
    ///codes).
    ///Params:
    ///    NewCountryCodeVal = The country/region code.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_CountryCode(int NewCountryCodeVal);
}

///The <b>IATSCTuningSpace</b> interface is implemented on ATSCTuningSpace objects, which represent any tuning space
///with an ATSC network type. Microsoft provides a default ATSC tuning space with Windows XP, and also with DirectX 9.0.
///Third parties such as cable providers may install a custom tuning space using the ITuningSpaceContainer interface. An
///ATSCTuningSpace object creates tune requests that expose IATSCChannelTuneRequest.
@GUID("0369B4E2-45B6-11D3-B650-00C04F79498E")
interface IATSCTuningSpace : IAnalogTVTuningSpace
{
    ///The <b>get_MinMinorChannel</b> method gets the lowest minor channel number ever allowed for this tuning space.
    ///Params:
    ///    MinMinorChannelVal = Receives the lowest minor channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_MinMinorChannel(int* MinMinorChannelVal);
    ///The <b>put_MinMinorChannel</b> method sets the lowest minor channel number ever allowed for this tuning space.
    ///Params:
    ///    NewMinMinorChannelVal = Variable of type <b>long</b> that specifies the lowest minor channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_MinMinorChannel(int NewMinMinorChannelVal);
    ///The <b>get_MaxMinorChannel</b> method gets the highest minor channel number for this tuning space.
    ///Params:
    ///    MaxMinorChannelVal = Receives the highest minor channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_MaxMinorChannel(int* MaxMinorChannelVal);
    ///The <b>put_MaxMinorChannel</b> method gets the highest minor channel number for this tuning space.
    ///Params:
    ///    NewMaxMinorChannelVal = The highest minor channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_MaxMinorChannel(int NewMaxMinorChannelVal);
    ///The <b>get_MinPhysicalChannel</b> method sets the lowest physical channel number for this tuning space.
    ///Params:
    ///    MinPhysicalChannelVal = Receives the lowest physical channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_MinPhysicalChannel(int* MinPhysicalChannelVal);
    ///The <b>put_MinPhysicalChannel</b> method sets the lowest physical channel number for this tuning space.
    ///Params:
    ///    NewMinPhysicalChannelVal = Variable of type <b>long</b> that specifies the lowest physical channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_MinPhysicalChannel(int NewMinPhysicalChannelVal);
    ///The <b>get_MaxPhysicalChannel</b> method gets the highest physical channel number for this tuning space.
    ///Params:
    ///    MaxPhysicalChannelVal = Receives the highest physical channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_MaxPhysicalChannel(int* MaxPhysicalChannelVal);
    ///The <b>put_MaxPhysicalChannel</b> method sets the highest physical channel number for this tuning space.
    ///Params:
    ///    NewMaxPhysicalChannelVal = Variable of type <b>long</b> that specifies the highest physical channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_MaxPhysicalChannel(int NewMaxPhysicalChannelVal);
}

///The <b>IDigitalCableTuningSpace</b> interface is implemented on the DigitalTuningSpace object and provides methods
///for working with tuning spaces that have a digital cable network type.
@GUID("013F9F9C-B449-4EC7-A6D2-9D4F2FC70AE5")
interface IDigitalCableTuningSpace : IATSCTuningSpace
{
    ///The <b>get_MinMajorChannel</b> method retrieves the lowest major channel number for this tuning space.
    ///Params:
    ///    MinMajorChannelVal = Receives the lowest major channel number.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_MinMajorChannel(int* MinMajorChannelVal);
    ///The <b>put_MinMajorChannel</b> method sets the lowest major channel number for this tuning space.
    ///Params:
    ///    NewMinMajorChannelVal = Specifies the lowest major channel number.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_MinMajorChannel(int NewMinMajorChannelVal);
    ///The <b>get_MaxMajorChannel</b> method retrieves the highest major channel number for this tuning space.
    ///Params:
    ///    MaxMajorChannelVal = Receives the highest major channel number.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_MaxMajorChannel(int* MaxMajorChannelVal);
    ///The <b>put_MaxMajorChannel</b> method sets the highest major channel number for this tuning space.
    ///Params:
    ///    NewMaxMajorChannelVal = Specifies the highest major channel number.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_MaxMajorChannel(int NewMaxMajorChannelVal);
    ///The <b>get_MinSourceID</b> method retrieves the lowest source identifier for this tuning space.
    ///Params:
    ///    MinSourceIDVal = Receives the lowest source identifier.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_MinSourceID(int* MinSourceIDVal);
    ///The <b>put_MinSourceID</b> method sets the lowest source identifier for this tuning space.
    ///Params:
    ///    NewMinSourceIDVal = Specifies the lowest source identifier.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_MinSourceID(int NewMinSourceIDVal);
    ///The <b>get_MaxSourceID</b> method retrieves the highest source identifier for this tuning space.
    ///Params:
    ///    MaxSourceIDVal = Receives the highest source identifier.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_MaxSourceID(int* MaxSourceIDVal);
    ///The <b>put_MaxSourceID</b> method sets the highest source identifier for this tuning space.
    ///Params:
    ///    NewMaxSourceIDVal = Specifies the highest source identifier.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_MaxSourceID(int NewMaxSourceIDVal);
}

///The <b>IAnalogRadioTuningSpace</b> interface provides methods for getting and setting parameters associated with
///tuning spaces for analog radio transmissions.
@GUID("2A6E293B-2595-11D3-B64C-00C04F79498E")
interface IAnalogRadioTuningSpace : ITuningSpace
{
    ///The <b>get_MinFrequency</b> method retrieves the minimum frequency for this tuning space.
    ///Params:
    ///    MinFrequencyVal = Pointer to a variable that receives the minimum frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT get_MinFrequency(int* MinFrequencyVal);
    ///The <b>put_MinFrequency</b> method sets the minimum frequency for this tuning space.
    ///Params:
    ///    NewMinFrequencyVal = Specifies the minimum frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT put_MinFrequency(int NewMinFrequencyVal);
    ///The <b>get_MaxFrequency</b> method retrieves the maximum frequency for this tuning space.
    ///Params:
    ///    MaxFrequencyVal = Pointer to a variable that receives the maximum frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT get_MaxFrequency(int* MaxFrequencyVal);
    ///The <b>put_MaxFrequency</b> method sets the maximum frequency for this tuning space.
    ///Params:
    ///    NewMaxFrequencyVal = Specifies the maximum frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT put_MaxFrequency(int NewMaxFrequencyVal);
    ///The <b>get_Step</b> method retrieves the step value to the next frequency.
    ///Params:
    ///    StepVal = Pointer to a variable receives the step value to the next frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT get_Step(int* StepVal);
    ///The <b>put_Step</b> method sets the step value to the next frequency.
    ///Params:
    ///    NewStepVal = Specifies the step value to the next frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT put_Step(int NewStepVal);
}

///This topic applies to Windows XP Media Center Edition 2004 and later. The <b>IAnalogRadioTuningSpace2</b> interface
///provides methods for getting and setting parameters associated with tuning spaces for analog radio transmission,
///including the source country code.
@GUID("39DD45DA-2DA8-46BA-8A8A-87E2B73D983A")
interface IAnalogRadioTuningSpace2 : IAnalogRadioTuningSpace
{
    ///This topic applies to Windows XP Media Center Edition 2004 and later. The <b>get_CountryCode</b> method gets the
    ///country/region code of the tuning space (based on TAPI country/region codes).
    ///Params:
    ///    CountryCodeVal = Pointer to a variable that receives the country/region code.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved by using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_CountryCode(int* CountryCodeVal);
    ///This topic applies to Windows XP Media Center Edition 2004 and later. The <b>put_CountryCode</b> method sets the
    ///country/region code of the tuning space (based on TAPI country/region codes).
    ///Params:
    ///    NewCountryCodeVal = The country/region code.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved by using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_CountryCode(int NewCountryCodeVal);
}

///The <b>ITuneRequest</b> interface is the base interface for all tune requests. Each tune request object supports a
///network-specific interface that derives from <b>ITuneRequest</b>, such as IATSCChannelTuneRequest or IDVBTuneRequest.
///This interface is used by any application that creates tune requests, such as a Guide Store loader. A tune request
///must be associated with a specific network type. When a tune request is submitted, the derived interfaces are used by
///the Network Provider to extract the tuning information required by the hardware. All tune request objects also
///support <b>IPersistPropertyBag</b>, which enables them to be persisted in some type of third-party storage mechanism.
@GUID("07DDC146-FC3D-11D2-9D8C-00C04F72D980")
interface ITuneRequest : IDispatch
{
    ///The <b>get_TuningSpace</b> method retrieves the tuning space that was used to create this tune request.
    ///Params:
    ///    TuningSpace = Receives a pointer to the ITuningSpace interface. The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_TuningSpace(ITuningSpace* TuningSpace);
    ///The <b>get_Components</b> method retrieves the components contained in this tune request.
    ///Params:
    ///    Components = Receives an IComponents interface pointer. The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Components(IComponents* Components);
    ///The <b>Clone</b> method returns a new copy of this tune request.
    ///Params:
    ///    NewTuneRequest = Address of an <b>ITuneRequest</b> interface pointer that will be set to the new object.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Clone(ITuneRequest* NewTuneRequest);
    ///The <b>get_Locator</b> method is called from the Network Provider to get the ILocator object associated with the
    ///requested broadcast.
    ///Params:
    ///    Locator = Address of an <b>ILocator</b> interface pointer that will be set to the new object.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Locator(ILocator* Locator);
    ///The <b>put_Locator</b> method is called from the Network Provider to set the ILocator object associated with the
    ///requested broadcast.
    ///Params:
    ///    Locator = Pointer to an <b>ILocator</b> interface that specifies the new locator.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Locator(ILocator Locator);
}

///Implements methods that support channel requests using a string identifier.
@GUID("156EFF60-86F4-4E28-89FC-109799FD57EE")
interface IChannelIDTuneRequest : ITuneRequest
{
    ///Provider-defined channel identifier in string format. This property is read/write.
    HRESULT get_ChannelID(BSTR* ChannelID);
    ///Provider-defined channel identifier in string format. This property is read/write.
    HRESULT put_ChannelID(BSTR ChannelID);
}

///The <b>IChannelTuneRequest</b> interface is implemented on tuning request objects that support channel numbers,
///including analog TV and ATSC. This interface enables a guide store loader running on Windows XP to create tuning
///requests for analog TV networks that an application can pass to the Video Control. The Video Control examines all
///tuning requests that it receives. If it is an analog tuning request, the Video Control creates a filter graph that
///can play the specified channel. Applications running on earlier versions of Windows are responsible for creating
///their own analog graphs if the user selects a program on an analog channel. Downlevel applications should not pass an
///analog tune request to a BDA tuning device because the device cannot interpret it.
@GUID("0369B4E0-45B6-11D3-B650-00C04F79498E")
interface IChannelTuneRequest : ITuneRequest
{
    ///The <b>get_Channel</b> method gets the channel to be tuned.
    ///Params:
    ///    Channel = Pointer to a variable of type <b>long</b> that receives the current channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Channel(int* Channel);
    ///The <b>put_Channel</b> method sets the channel to be tuned.
    ///Params:
    ///    Channel = Variable of type <b>long</b> that specifies the channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    IErrorInfo interface.
    ///    
    HRESULT put_Channel(int Channel);
}

///The <b>IATSCChannelTuneRequest</b> interface provides methods for tuning to a channel in an ATSC network. The
///ATSCChannelTuneRequest object implements this interface.
@GUID("0369B4E1-45B6-11D3-B650-00C04F79498E")
interface IATSCChannelTuneRequest : IChannelTuneRequest
{
    ///The <b>get_MinorChannel</b> method gets the current minor channel.
    ///Params:
    ///    MinorChannel = Receives the current minor channel. If the value received is -1, the tuner should tune to the first valid
    ///                   minor channel it finds.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_MinorChannel(int* MinorChannel);
    ///The <b>put_MinorChannel</b> method sets the minor channel to be tuned.
    ///Params:
    ///    MinorChannel = Specifies the minor channel. If the value is -1, the tuner tunes to the first valid minor channel it finds.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_MinorChannel(int MinorChannel);
}

///The <b>IDigitalCableTuneRequest</b> interface provides methods for tuning to a channel in a digital cable network.
///The <b>DigitalCableTuneRequest</b> object implements this interface. <b>OCUR Devices: </b>This interface supports
///OpenCable Unidirectional Cable Receiver (OCUR) devices. See OCUR Devices.
@GUID("BAD7753B-6B37-4810-AE57-3CE0C4A9E6CB")
interface IDigitalCableTuneRequest : IATSCChannelTuneRequest
{
    ///The <b>get_MajorChannel</b> method retrieves the major channel number.
    ///Params:
    ///    pMajorChannel = Receives the major channel number. If the value received is BDA_UNDEFINED_CHANNEL, the major channel number
    ///                    is not used.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_MajorChannel(int* pMajorChannel);
    ///The <b>put_MajorChannel</b> method sets the major channel number.
    ///Params:
    ///    MajorChannel = Specifies the major channel number.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_MajorChannel(int MajorChannel);
    ///The <b>get_SourceID</b> method retrieves the source identifier, which maps to a physical channel.
    ///Params:
    ///    pSourceID = Receives the source identifier. If the value received is BDA_UNDEFINED_CHANNEL, the source identifier is not
    ///                used.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SourceID(int* pSourceID);
    ///The <b>put_SourceID</b> method sets the source identifier, which maps to a physical channel.
    ///Params:
    ///    SourceID = Specifies the source identifier.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_SourceID(int SourceID);
}

///The <b>IDVBTuneRequest</b> interface is implemented on the DVBTuneRequest object. It provides methods for acquiring a
///transport stream, and a service on that stream, in tuning spaces with a DVB network type. This information is
///obtained by the Guide Store loader from the TIF, stored in the tune request, and ultimately used by the Network
///Provider to configure the MPEG-2 Demultiplexer so that the correct packets are decoded and passed on to the
///downstream filters.
@GUID("0D6F567E-A636-42BB-83BA-CE4C1704AFA2")
interface IDVBTuneRequest : ITuneRequest
{
    ///The <b>get_ONID</b> method retrieves the original network ID.
    ///Params:
    ///    ONID = Receives the original network ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_ONID(int* ONID);
    ///The <b>put_ONID</b> method sets the original network ID.
    ///Params:
    ///    ONID = The original network ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_ONID(int ONID);
    ///The <b>get_TSID</b> method retrieves the transport stream ID.
    ///Params:
    ///    TSID = Receives the transport stream ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_TSID(int* TSID);
    ///The <b>put_TSID</b> method sets the transport stream ID.
    ///Params:
    ///    TSID = The transport stream ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_TSID(int TSID);
    ///The <b>get_SID</b> method retrieves the service ID for the network.
    ///Params:
    ///    SID = Receives the service ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_SID(int* SID);
    ///The <b>put_SID</b> method sets the service ID.
    ///Params:
    ///    SID = The service ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_SID(int SID);
}

///The <b>IMPEG2TuneRequest</b> interface represents a tune request for a basic MPEG-2 transport stream containing the
///minimal tables. Use the IMPEG2TuneRequestFactory::CreateTuneRequest method to obtain this interface. It returns the
///minimal MPEG-2 tune request for a specified tuning space. To create a full tune request, use the
///<b>CreateTuneRequest</b> method provided by one of the tuning space objects.
@GUID("EB7D987F-8A01-42AD-B8AE-574DEEE44D1A")
interface IMPEG2TuneRequest : ITuneRequest
{
    ///The <b>get_TSID</b> method retrieves the transport stream ID.
    ///Params:
    ///    TSID = Pointer to a variable that receives the transport stream ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_TSID(int* TSID);
    ///The <b>put_TSID</b> method sets the transport stream ID.
    ///Params:
    ///    TSID = Specifies the transport stream ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_TSID(int TSID);
    ///The <b>get_ProgNo</b> method retrieves the program number ID.
    ///Params:
    ///    ProgNo = Pointer to a variable that receives the program number ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_ProgNo(int* ProgNo);
    ///The <b>put_ProgNo</b> method sets the program number ID.
    ///Params:
    ///    ProgNo = Specifies the program number ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_ProgNo(int ProgNo);
}

///The <b>IMPEG2TuneRequestFactory</b> interface creates a tune request for a basic MPEG-2 transport stream containing
///the minimal tables. To obtain this interface, call <b>CoCreateInstance</b> with the class identifier
///CLSID_MPEG2TuneRequestFactory.
@GUID("14E11ABD-EE37-4893-9EA1-6964DE933E39")
interface IMPEG2TuneRequestFactory : IDispatch
{
    ///The <b>CreateTuneRequest</b> method creates the minimal MPEG-2 tune request for a specified tuning space.
    ///Params:
    ///    TuningSpace = Pointer to the ITuningSpace interface of the tuning space.
    ///    TuneRequest = Address of a variable that receives a pointer to the IMPEG2TuneRequest interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT CreateTuneRequest(ITuningSpace TuningSpace, IMPEG2TuneRequest* TuneRequest);
}

///Indicates that the default network provider for a tuning space allows tuning through the IMPEG2TuneRequest interface
///as well as tuning through the native tuning request type implemented by that tuning space's CreateTuneRequest method.
///For example, the DVBTuningSpace object implements the <b>IMPEG2TuneRequestSupport</b> interface. This indicates that
///the default network provider for the <b>DVBTuningSpace</b> object supports tuning through both the object's native
///IDVBTuneRequest::CreateTuneRequest method and the <b>IMPEG2TuneRequest::CreateTuneRequest</b> method. (In both cases,
///the tune request interfaces inherit the <b>CreateTuneRequest</b> method from the ITuneRequest interface). The
///following tuning space objects support the <b>IMPEG2TuneRequestSupport</b> interface: <ul> <li> DVBSTuningSpace
///object</li> <li> DVBTuningSpace object</li> <li> ATSCTuningSpace object</li> </ul>
@GUID("1B9D5FC3-5BBC-4B6C-BB18-B9D10E3EEEBF")
interface IMPEG2TuneRequestSupport : IUnknown
{
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>ITunerCap</b>
///interface provides information about the capabilities of a BDA device filter that represents a TV tuner.
@GUID("E60DFA45-8D56-4E65-A8AB-D6BE9412C249")
interface ITunerCap : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_SupportedNetworkTypes</b> method retrieves a list of the network types that are supported by the TV tuner.
    ///Params:
    ///    ulcNetworkTypesMax = The maximum number of network-type GUIDs that the <i>pguidNetworkTypes</i> buffer can hold.
    ///    pulcNetworkTypes = Receives a count of the number of network-type GUIDs actually written to the <i>pguidNetworkTypes</i> buffer.
    ///    pguidNetworkTypes = Receives an array of network-type GUIDs. For the list of valid network-type GUIDs, see Default Tuning Spaces.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_SupportedNetworkTypes(uint ulcNetworkTypesMax, uint* pulcNetworkTypes, GUID* pguidNetworkTypes);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_SupportedVideoFormats</b> method retrieves the video formats that are supported by the TV tuner.
    ///Params:
    ///    pulAMTunerModeType = Receives a bitmask that indicates the frequency ranges that are supported by the BDA device filter. For a
    ///                         list of valid mask bits, see AMTunerModeType Enumeration.
    ///    pulAnalogVideoStandard = Receives a bitmask that indicates the analog television signal formats that are supported by the BDA device
    ///                             filter. For a list of valid mask bits, see AnalogVideoStandard Enumeration.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_SupportedVideoFormats(uint* pulAMTunerModeType, uint* pulAnalogVideoStandard);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_AuxInputCount</b> method retrieves a count of the number of auxiliary inputs on the TV tuner.
    ///Params:
    ///    pulCompositeCount = Receives a count of the number of composite-video input connectors on the device.
    ///    pulSvideoCount = Receives a count of the number of S-video input connectors on the device.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_AuxInputCount(uint* pulCompositeCount, uint* pulSvideoCount);
}

///Provides information about the capabilities of a BDA device filter that represents a TV tuner. This interface extends
///the ITunerCap interface.
@GUID("ED3E0C66-18C8-4EA6-9300-F6841FDD35DC")
interface ITunerCapEx : IUnknown
{
    ///Gets a flag indicating whether a BDA tuner device supports 608/708 closed captioning for ATSC, digital cable, or
    ///analog cable. In 608/708 closed captioning, the broadcast includes closed-captioning data. This property is
    ///read-only.
    HRESULT get_Has608_708Caption(short* pbHasCaption);
}

///The <b>ITuner</b> interface is implemented on the Microsoft BDA Network Provider filters. It provides methods for
///passing tune requests down to the hardware device and receiving current tuning settings. Generally, applications
///should use the derived interface IScanningTuner instead of <b>ITuner</b>. <div class="alert"><b>Note</b> Only
///applications that are intended to run on Windows 2000 should use this interface. Starting in Windows XP, the Video
///Control handles all tuning interactions with the Network Provider.</div> <div> </div>
@GUID("28C52640-018A-11D3-9D8E-00C04F72D980")
interface ITuner : IUnknown
{
    ///The <b>get_TuningSpace</b> method gets the tuning space currently in effect for the Network Provider.
    ///Params:
    ///    TuningSpace = Address of an ITuningSpace interface pointer that will be set to the current tuning space.
    ///Returns:
    ///    When the method is successful, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_TuningSpace(ITuningSpace* TuningSpace);
    ///The <b>put_TuningSpace</b> method sets the tuning space for the Network Provider.
    ///Params:
    ///    TuningSpace = Pointer to the tuning space that will be set in the Network Provider.
    ///Returns:
    ///    When the method is successful, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_TuningSpace(ITuningSpace TuningSpace);
    ///The <b>EnumTuningSpaces</b> method creates a collection of tuning spaces preferred by this implementation.
    ///Params:
    ///    ppEnum = Address of a IEnumTuningSpaces interface pointer that will be set to the returned collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT EnumTuningSpaces(IEnumTuningSpaces* ppEnum);
    ///The <b>get_TuneRequest</b> method gets the tune request currently in effect for the Network Provider.
    ///Params:
    ///    TuneRequest = Address of an ITuneRequest interface pointer that will be set to the returned object.
    ///Returns:
    ///    When the method is successful, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_TuneRequest(ITuneRequest* TuneRequest);
    ///The <b>put_TuneRequest</b> method sets the tune request currently in effect for the Network Provider.
    ///Params:
    ///    TuneRequest = Pointer to an ITuneRequest object that will be used to set the Network Provider.
    ///Returns:
    ///    When the method is successful, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_TuneRequest(ITuneRequest TuneRequest);
    ///The <b>Validate</b> method returns a value indicating that the tune request can be carried out.
    ///Params:
    ///    TuneRequest = Pointer to the tune request object.
    ///Returns:
    ///    When the method is successful, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT Validate(ITuneRequest TuneRequest);
    ///The <b>get_PreferredComponentTypes</b> method gets the collection of ComponentType objects used for default
    ///component selection.
    ///Params:
    ///    ComponentTypes = Address of an IComponentTypes interface pointer that receives the collection of ComponentType objects.
    ///Returns:
    ///    When the method is successful, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_PreferredComponentTypes(IComponentTypes* ComponentTypes);
    ///The <b>put_PreferredComponentTypes</b> method sets the collection of <b>ComponentType</b> objects used for
    ///default component selection.
    ///Params:
    ///    ComponentTypes = Pointer to an IComponentTypes interface that contains the collection of ComponentType objects.
    ///Returns:
    ///    When the method is successful, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT put_PreferredComponentTypes(IComponentTypes ComponentTypes);
    ///The <b>get_SignalStrength</b> method retrieves the Network Provider-specific signal strength metric.
    ///Params:
    ///    Strength = Receives the signal strength.
    ///Returns:
    ///    When the method is successful, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT get_SignalStrength(int* Strength);
    ///The <b>TriggerSignalEvents</b> method enables the tuner to raise an event when the status of the signal changes.
    ///Params:
    ///    Interval = Specifies the time-out interval in milliseconds.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT TriggerSignalEvents(int Interval);
}

///The <b>IScanningTuner</b> interface is implemented on the BDA Network Provider filter. It inherits from ITuner and
///permits direct control of a tuner that supports searching for valid programming. The client must provide a valid
///tuning space (using ITuner::put_TuningSpace or ITuner::put_TuneRequest) before calling any of the methods in this
///interface. This interface is meant to be used in conjunction with the IBroadcastEvent outbound interface. <div
///class="alert"><b>Note</b> Only applications intended to run on Microsoft® Windows® 98 or Windows 2000 should use
///this interface. On Windows XP, the Video Control handles all tuning interactions with the Network Provider.</div>
///<div> </div>
@GUID("1DFD0A5C-0284-11D3-9D8E-00C04F72D980")
interface IScanningTuner : ITuner
{
    ///The <b>SeekUp</b> method changes the channel to the next higher channel with valid programming.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SeekUp();
    ///The <b>SeekDown</b> method changes the channel to the next lower channel with valid programming.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SeekDown();
    ///The <b>ScanUp</b> method changes the channel to the next higher channel with valid programming, pauses for the
    ///specified number of milliseconds, then repeats until canceled.
    ///Params:
    ///    MillisecondsPause = The number of milliseconds to pause.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT ScanUp(int MillisecondsPause);
    ///The <b>ScanDown</b> method changes the channel to the next lower channel with valid programming, pauses for the
    ///specified number of milliseconds, then repeats until canceled.
    ///Params:
    ///    MillisecondsPause = The number of milliseconds to pause.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT ScanDown(int MillisecondsPause);
    ///The <b>AutoProgram</b> method scans for all channels with valid programming.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT AutoProgram();
}

///This topic applies to Windows Vista. The <b>IScanningTunerEx</b> interface is an extended version of IScanningTuner
///and is exposed by the BDA Network Provider filter. It inherits from <b>IScanningTuner</b> and permits direct control
///of a tuner that supports searching for valid programming. The client must provide a valid tuning space (using
///ITuner::put_TuningSpace or ITuner::put_TuneRequest) before calling any of the methods in this interface. This
///interface is meant to be used in conjunction with the IBroadcastEvent outbound interface.
@GUID("04BBD195-0E2D-4593-9BD5-4F908BC33CF5")
interface IScanningTunerEx : IScanningTuner
{
    ///This topic applies to Windows Vista and later. The <b>GetCurrentLocator</b> method retrieves the current locator
    ///object.
    ///Params:
    ///    pILocator = Receives a pointer to the ILocator interface of the locator object. The caller must release the interface.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetCurrentLocator(ILocator* pILocator);
    ///This topic applies to Windows Vista and later. The <b>PerformExhaustiveScan</b> method scans a range of
    ///frequencies until the tuner locks onto a signal.
    ///Params:
    ///    dwLowerFreq = Lowest frequency in the range of frequencies to scan. A value of -1 specifies the minimum frequency as
    ///                  determined by the device.
    ///    dwHigherFreq = Highest frequency in the range of frequencies to scan. A value of -1 specifies the maximum frequency as
    ///                   determined by the device.
    ///    bFineTune = Specifies whether the tuner performs fine tuning. When the tuner locks onto a frequency, if this parameter is
    ///                <b>VARIANT_TRUE</b>, the tuner does fine tuning to find the best possible signal around that frequency.
    ///    hEvent = Handle to an event created by the application. When the tuner locks onto a signal, it signals this event.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return value</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> No scan
    ///    is currently in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt>E_INVALIDARG</dt> </dl> </td> <td
    ///    width="60%"> Invalid frequency argument (for example, 0 <i>dwLowerFrequency</i> or <i>dwHigherFreq</i> value
    ///    or <i>dwLowerFrequency</i> &gt;= <i>dwHigherFreq</i>). </td> </tr> <tr> <td width="40%"> <dl> <dt>S_OK</dt>
    ///    </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT PerformExhaustiveScan(int dwLowerFreq, int dwHigherFreq, short bFineTune, size_t hEvent);
    ///This topic applies to Windows Vista and later. The <b>TerminateCurrentScan</b> method interrupts the current
    ///scan, if a scan is in progress.
    ///Params:
    ///    pcurrentFreq = Receives the last frequency that the tuner scanned before halting.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return value</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> No scan
    ///    is currently in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT TerminateCurrentScan(int* pcurrentFreq);
    ///This topic applies to Windows Vista and later. The <b>ResumeCurrentScan</b> method resumes scanning the range of
    ///frequencies specified in PerformExhaustiveScan.
    ///Params:
    ///    hEvent = Handle to an event created by the application. When the tuner locks onto a signal, it signals this event.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return value</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> No scan
    ///    has been started yet. </td> </tr> <tr> <td width="40%"> <dl> <dt>E_INVALIDARG</dt> </dl> </td> <td
    ///    width="60%"> Invalid <i>hEvent</i> argument. </td> </tr> <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> </table> When the method succeeds, it returns S_OK. Otherwise it
    ///    returns an <b>HRESULT</b> error code.
    ///    
    HRESULT ResumeCurrentScan(size_t hEvent);
    ///This topic applies to Windows Vista and later. The <b>GetTunerScanningCapability</b> method retrieves the set of
    ///broadcast standards supported by the tuner and the tuner's scanning capability.
    ///Params:
    ///    HardwareAssistedScanning = Receives a Boolean value. If the value is <b>TRUE</b>, the scanning algorithm is implemented entirely by the
    ///                               tuner hardware. Otherwise, the tuner filter implements part of the scanning algorithm in software.
    ///    NumStandardsSupported = Receives the number of broadcast standards supported by the tuner.
    ///    BroadcastStandards = Pointer to an array of GUIDs. The array must be large enough to hold a number of elements equal to the value
    ///                         returned in the <i>NumStandardsSupported</i> parameter. To find the required array size, call the method once
    ///                         and set this parameter to <b>NULL</b>. Then allocate the array and call the method again, setting this
    ///                         parameter to the address of the array.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetTunerScanningCapability(int* HardwareAssistedScanning, int* NumStandardsSupported, 
                                       GUID* BroadcastStandards);
    ///This topic applies to Windows Vista and later. The <b>GetTunerStatus</b> method returns the current status of the
    ///most recent call to PerformExhaustiveScan.
    ///Params:
    ///    SecondsLeft = Receives the estimated number of seconds remaining for the scan to complete.
    ///    CurrentLockType = Receives a member of the TunerLockType enumeration, indicating how well the tuner locked onto a signal.
    ///    AutoDetect = Receives a Boolean value. If the value is <b>TRUE</b>, the tuner is in auto-detect mode.
    ///    CurrentFreq = Receives the frequency that was most recently scanned.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetTunerStatus(int* SecondsLeft, int* CurrentLockType, int* AutoDetect, int* CurrentFreq);
    ///This topic applies to Windows Vista and later. The <b>GetCurrentTunerStandardCapability</b> method retrieves the
    ///tuner's capabilities for a specified broadcast standard.
    ///Params:
    ///    CurrentBroadcastStandard = GUID that specifies the broadcast standard to query. To find the broadcast standards supported by the tuner,
    ///                               call GetTunerScanningCapability.
    ///    SettlingTime = Receives the approximate amount of time the tuner requires to tune to a frequency, in milliseconds.
    ///    TvStandardsSupported = If <i>CurrentBroadcastStandard</i> is ANALOG_TV_NETWORK_TYPE, this parameter receives a bitwise OR of flags
    ///                           from the AnalogVideoStandard enumeration, indicating which analog television formats are supported by the
    ///                           tuner. Otherwise, this parameter is ignored.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT GetCurrentTunerStandardCapability(GUID CurrentBroadcastStandard, int* SettlingTime, 
                                              int* TvStandardsSupported);
    ///This topic applies to Windows Vista and later. Not implemented in this release. The
    ///<b>SetScanSignalTypeFilter</b> method specifies the type of signal to scan for. Applications can optionally call
    ///this method before calling PerformExhaustiveScan, to filter the signal types that the tuner will search for.
    ///Params:
    ///    ScanModulationTypes = Specifies the modulation types, as a bitwise OR of flags from the ScanModulationTypes enumeration. If the
    ///                          value is 0xFFFFFFFF, the tuner does not filter out any specific modulation types.
    ///    AnalogVideoStandard = Specifies the analog standards, as a bitwise OR of flags from the AnalogVideoStandard enumeration. If the
    ///                          value is 0xFFFFFFFF, the tuner does not filter out any specific analog video standards.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT SetScanSignalTypeFilter(int ScanModulationTypes, int AnalogVideoStandard);
}

///The <b>IComponentType</b> interface is implemented on ComponentType objects, and contains methods for setting and
///retrieving various properties for a Component. Every Component object has an associated ComponentType object that is
///set or retrieved with the <b>get_Type</b> and <b>put_Type</b> methods.
@GUID("6A340DC0-0311-11D3-9D8E-00C04F72D980")
interface IComponentType : IDispatch
{
    ///The <b>get_Category</b> method retrieves the component category.
    ///Params:
    ///    Category = Pointer to a ComponentCategory data type that will receive the category.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Category(ComponentCategory* Category);
    ///The <b>put_Category</b> method sets the component category.
    ///Params:
    ///    Category = A ComponentCategory value that specifies the new category for this component type.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Category(ComponentCategory Category);
    ///The <b>get_MediaMajorType</b> method retrieves the DirectShow media major type as a <b>BSTR</b>.
    ///Params:
    ///    MediaMajorType = Pointer to a <b>BSTR</b> that will receive the GUID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_MediaMajorType(BSTR* MediaMajorType);
    ///The <b>put_MediaMajorType</b> method sets the DirectShow media major type.
    ///Params:
    ///    MediaMajorType = <b>BSTR</b> that specifies the GUID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_MediaMajorType(BSTR MediaMajorType);
    ///The <b>get__MediaMajorType</b> method retrieves the DirectShow media format type as a GUID.
    ///Params:
    ///    MediaMajorTypeGuid = Pointer to a GUID that will receive the major type.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get__MediaMajorType(GUID* MediaMajorTypeGuid);
    ///The <b>put__MediaMajorType</b> method sets the DirectShow media major type.
    ///Params:
    ///    MediaMajorTypeGuid = <b>REFCLSID</b> that specifies the media major type.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put__MediaMajorType(const(GUID)* MediaMajorTypeGuid);
    ///The <b>get_MediaSubType</b> method retrieves the DirectShow media subtype as a BSTR.
    ///Params:
    ///    MediaSubType = Pointer to a <b>BSTR</b> that will receive the GUID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_MediaSubType(BSTR* MediaSubType);
    ///The <b>put_MediaSubType</b> method sets the DirectShow media subtype.
    ///Params:
    ///    MediaSubType = <b>BSTR</b> that specifies the GUID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_MediaSubType(BSTR MediaSubType);
    ///The <b>get__MediaSubType</b> method retrieves the DirectShow media subtype as a GUID.
    ///Params:
    ///    MediaSubTypeGuid = Pointer to a GUID that will receive the major type.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get__MediaSubType(GUID* MediaSubTypeGuid);
    ///The <b>put__MediaSubType</b> method sets the DirectShow media subtype.
    ///Params:
    ///    MediaSubTypeGuid = <b>REFCLSID</b> that specifies the media sub type.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put__MediaSubType(const(GUID)* MediaSubTypeGuid);
    ///The <b>get_MediaFormatType</b> method retrieves the DirectShow media format type as a <b>BSTR</b>.
    ///Params:
    ///    MediaFormatType = Pointer to a <b>BSTR</b> that will receive the GUID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_MediaFormatType(BSTR* MediaFormatType);
    ///The <b>put_MediaFormatType</b> method sets the DirectShow media format type.
    ///Params:
    ///    MediaFormatType = <b>BSTR</b> that specifies the GUID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_MediaFormatType(BSTR MediaFormatType);
    ///The <b>get__MediaFormatType</b> method retrieves the DirectShow media format type as a GUID.
    ///Params:
    ///    MediaFormatTypeGuid = Pointer to a GUID that will receive the format type.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get__MediaFormatType(GUID* MediaFormatTypeGuid);
    ///The <b>put__MediaFormatType</b> method sets the DirectShow media format type.
    ///Params:
    ///    MediaFormatTypeGuid = <b>REFCLSID</b> that specifies the media format type.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put__MediaFormatType(const(GUID)* MediaFormatTypeGuid);
    ///The <b>get_MediaType</b> method retrieves the DirectShow AM_MEDIA_TYPE structure for the component.
    ///Params:
    ///    MediaType = Pointer to an AM_MEDIA_TYPE structure that will be filled in with the values associated with the current
    ///                ComponentType.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_MediaType(AM_MEDIA_TYPE* MediaType);
    ///The <b>put_MediaType</b> method sets the DirectShow <b>AM_MEDIA_TYPE</b> structure for the component.
    ///Params:
    ///    MediaType = An AM_MEDIA_TYPE structure that specifies the major type, subtype, format, and so on.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_MediaType(AM_MEDIA_TYPE* MediaType);
    ///The <b>Clone</b> method creates a new copy of this component type.
    ///Params:
    ///    NewCT = Address of the IComponentType interface pointer that will be set to the returned interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Clone(IComponentType* NewCT);
}

///The <b>ILanguageComponentType</b> interface is implemented on LanguageComponentType objects. It provides methods that
///define the language of the stream content. Not all streams have a language component.
@GUID("B874C8BA-0FA2-11D3-9D8E-00C04F72D980")
interface ILanguageComponentType : IComponentType
{
    ///The <b>get_LangID</b> method retrieves the LCID that identifies the language.
    ///Params:
    ///    LangID = Pointer to a variable that receives the LCID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_LangID(int* LangID);
    ///The <b>put_LangID</b> method specifies the LCID that identifies the language
    ///Params:
    ///    LangID = Specifies the LCID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_LangID(int LangID);
}

///The <b>IMPEG2ComponentType</b> interface is implemented on MPEG2ComponentType objects. It enables applications to set
///and retrieve information about MPEG2 stream types.
@GUID("2C073D84-B51C-48C9-AA9F-68971E1F6E38")
interface IMPEG2ComponentType : ILanguageComponentType
{
    ///The <b>get_StreamType</b> method retrieves the stream type.
    ///Params:
    ///    MP2StreamType = Pointer to a variable of type MPEG2StreamType that receives the stream type value.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_StreamType(MPEG2StreamType* MP2StreamType);
    ///The <b>put_StreamType</b> method sets the MPEG2 stream type.
    ///Params:
    ///    MP2StreamType = Variable of type MPEG2StreamType that specifies the stream type.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_StreamType(MPEG2StreamType MP2StreamType);
}

///The <b>IATSCComponentType</b> interface represents a component type for a component in an ATSC broadcast. The
///ATSCComponentType object exposes this interface. Use this interface to determine if an audio stream is in AC-3
///format.
@GUID("FC189E4D-7BD4-4125-B3B3-3A76A332CC96")
interface IATSCComponentType : IMPEG2ComponentType
{
    ///The <b>get_Flags</b> method queries whether an audio component is in AC-3 format.
    ///Params:
    ///    Flags = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>Zero</td> <td>The component does not contain AC-3 audio</td> </tr> <tr> <td>ATSCCT_AC3</td> <td>The
    ///            component contains AC-3 audio</td> </tr> </table> See ATSCComponentTypeFlags Enumeration.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Flags(int* Flags);
    ///The <b>put_Flags</b> method specifies whether an audio component is in AC-3 format.
    ///Params:
    ///    flags = Specifies one of the following values: <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>Zero</td> <td>The component does not contain AC-3 audio</td> </tr> <tr> <td>ATSCCT_AC3</td> <td>The
    ///            component contains AC-3 audio</td> </tr> </table> See ATSCComponentTypeFlags Enumeration.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Flags(int flags);
}

///The <b>IEnumComponentTypes</b> interface is implemented on a standard COM collection of ComponentType objects
///associated with a given broadcast stream, and returned through a call to IComponentTypes::EnumComponentTypes.
@GUID("8A674B4A-1F63-11D3-B64C-00C04F79498E")
interface IEnumComponentTypes : IUnknown
{
    ///The <b>Next</b> method retrieves the next <i>n</i> elements in the collection.
    ///Params:
    ///    celt = The number of elements to retrieve.
    ///    rgelt = Address of an array of IComponentType interface pointers that will receive the returned ComponentType
    ///            objects.
    ///    pceltFetched = Receives the number of elements actually retrieved.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///The <b>Skip</b> method skips the element at the specified index.
    ///Params:
    ///    celt = Index of the element to skip.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Reset</b> method moves the iterator to the beginning of the collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Reset();
    ///The <b>Clone</b> method creates a new copy of the collection and all its sub-objects.
    ///Params:
    ///    ppEnum = Address of an <b>IEnumComponentTypes</b> interface pointer that will be set to the returned collection
    ///             object.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Clone(IEnumComponentTypes* ppEnum);
}

///The <b>IComponentTypes</b> interface is implemented on ComponentTypes objects and contains methods that enable
///applications to enumerate, add, remove and retrieve individual ComponentType objects. All ComponentTypes objects also
///support <b>IPersistPropertyBag</b>.
@GUID("0DC13D4A-0313-11D3-9D8E-00C04F72D980")
interface IComponentTypes : IDispatch
{
    ///The <b>get_Count</b> method returns the number of component types in the collection.
    ///Params:
    ///    Count = Receives the number of items in the collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Count(int* Count);
    ///The <b>get__NewEnum</b> enumeration method supports <code>For...Each</code> loops in Automation clients.
    ///Params:
    ///    ppNewEnum = Address of an interface pointer to an <b>IEnumVARIANT</b> object that will receive the new collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get__NewEnum(IEnumVARIANT* ppNewEnum);
    ///The <b>EnumComponentTypes</b> method returns an <b>IEnumComponentTypes</b> enumerator for all component types in
    ///the collection.
    ///Params:
    ///    ppNewEnum = Receives a pointer to the IEnumComponentTypes interface. The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT EnumComponentTypes(IEnumComponentTypes* ppNewEnum);
    ///The <b>get_Item</b> method retrieves the IComponentType interface pointer at the specified index number.
    ///Params:
    ///    Index = The index number of the object to retrieve.
    ///    ComponentType = Receives a pointer to the IComponentType interface. The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Item(VARIANT Index, IComponentType* ComponentType);
    ///The <b>put_Item</b> method replaces the ComponentType object at the specified index with a new
    ///<b>ComponentType</b> object.
    ///Params:
    ///    Index = Index number of the item to be replaced.
    ///    ComponentType = Pointer to the IComponentType object that will be inserted into the collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Item(VARIANT Index, IComponentType ComponentType);
    ///The <b>Add</b> method adds a new ComponentType object to the collection.
    ///Params:
    ///    ComponentType = Pointer to the IComponentType object that will be added to the collection.
    ///    NewIndex = The index number of the component type after it has been added to the collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Add(IComponentType ComponentType, VARIANT* NewIndex);
    ///The <b>Remove</b> method removes the ComponentType object at the specified index number.
    ///Params:
    ///    Index = Index of the item to remove.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Remove(VARIANT Index);
    ///The <b>Clone</b> method creates a new copy of the collection.
    ///Params:
    ///    NewList = Address of an <b>IComponentTypes</b> interface pointer that will be set to the new ComponentTypes object.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Clone(IComponentTypes* NewList);
}

///The <b>IComponent</b> interface a base class for all derived interfaces such as IMPEG2Component and it describes the
///general characteristics of a component, which is an elementary stream within the program stream. The derived
///interfaces describe the properties of a component that are specific to a given network type. Component objects are
///created and attached to the tune request by the BDA Transport Information Filter (TIF) after reception has begun. All
///component objects also support <b>IPersistPropertyBag</b>.
@GUID("1A5576FC-0E19-11D3-9D8E-00C04F72D980")
interface IComponent : IDispatch
{
    ///The <b>get_Type</b> method retrieves an IComponentType interface describing the general characteristics of the
    ///component.
    ///Params:
    ///    CT = Address of an IComponentType interface pointer that will be set to the retrieved component.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Type(IComponentType* CT);
    ///The <b>put_Type</b> method sets an IComponentType object describing the general characteristics of the component.
    ///Params:
    ///    CT = Pointer to an IComponentType object that specifies the new values for the component.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Type(IComponentType CT);
    ///The <b>get_DescLangID</b> method retrieves the language identifier for the description property.
    ///Params:
    ///    LangID = Receives the language identifier.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_DescLangID(int* LangID);
    ///The <b>put_DescLangID</b> method sets the language for presentation of the description.
    ///Params:
    ///    LangID = Specifies the language ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_DescLangID(int LangID);
    ///The <b>get_Status</b> method retrieves the requested or actual status of the component.
    ///Params:
    ///    Status = Pointer to a ComponentStatus enumeration that receives the status value.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Status(ComponentStatus* Status);
    ///The <b>put_Status</b> method sets the requested or actual status of the component.
    ///Params:
    ///    Status = A variable of type ComponentStatus that specifies the status value.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Status(ComponentStatus Status);
    ///The <b>get_Description</b> method retrieves the description of the component.
    ///Params:
    ///    Description = Pointer to a variable that receives the description.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Description(BSTR* Description);
    ///The <b>put_Description</b> method sets the description of the component.
    ///Params:
    ///    Description = Variable of type <b>BSTR</b> that contains the new description.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Description(BSTR Description);
    ///The <b>Clone</b> method creates a copy of the component.
    ///Params:
    ///    NewComponent = Receives an IComponent interface pointer. The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Clone(IComponent* NewComponent);
}

///The <b>IAnalogAudioComponentType</b> interface provides methods for accessing the analog audio mode.
@GUID("2CFEB2A8-1787-4A24-A941-C6EAEC39C842")
interface IAnalogAudioComponentType : IComponentType
{
    ///The <b>get_AnalogAudioMode</b> method retrieves the analog audio mode.
    ///Params:
    ///    Mode = Pointer to a TVAudioMode variable that receives the analog audio mode.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved by using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_AnalogAudioMode(TVAudioMode* Mode);
    ///The <b>put_AnalogAudioMode</b> method specifies the analog audio mode.
    ///Params:
    ///    Mode = Specifies the analog audio mode. This parameter is a variable of type TVAudioMode.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved by using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_AnalogAudioMode(TVAudioMode Mode);
}

///The <b>IMPEG2Component</b> interface contains methods for getting and setting properties that describe an MPEG2
///elementary stream. These properties are set by the TIF or Guide Store loader based on data in the transport stream
///tables. After the tune request is retrieved from the Guide Store and submitted either to the Video Control or
///directly to the Network Provider, these properties are used by the Network Provider and MPEG-2 Demultiplexer to
///acquire the specified substream and pass it to the downstream filters.
@GUID("1493E353-1EB6-473C-802D-8E6B8EC9D2A9")
interface IMPEG2Component : IComponent
{
    HRESULT put_DescLangID(int LangID);
    HRESULT get_Status(ComponentStatus* Status);
    HRESULT put_Status(ComponentStatus Status);
    HRESULT get_Description(BSTR* Description);
    HRESULT put_Description(BSTR Description);
    HRESULT Clone(IComponent* NewComponent);
    ///The <b>get_PID</b> method returns the packet identifier (PID) for this substream.
    ///Params:
    ///    PID = Pointer to a variable that receives the PID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_PID(int* PID);
    ///The <b>put_PID</b> method sets the packet identifier (PID) for this substream.
    ///Params:
    ///    PID = Specifies the PID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_PID(int PID);
    ///The <b>get_PCRPID</b> method returns the packet identifier (PID) for the packets that contain the PCR for this
    ///substream.
    ///Params:
    ///    PCRPID = Pointer to a variable that receives the PCR PID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_PCRPID(int* PCRPID);
    ///The <b>put_PCRPID</b> method sets the packet identifier (PID) for the packets that contain the PCR for this
    ///substream.
    ///Params:
    ///    PCRPID = Specifies the PCR PID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_PCRPID(int PCRPID);
    ///The <b>get_ProgramNumber</b> method returns the program number for this substream.
    ///Params:
    ///    ProgramNumber = Pointer to a variable that receives the program number.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_ProgramNumber(int* ProgramNumber);
    ///The <b>put_ProgramNumber</b> method sets the program number for this substream.
    ///Params:
    ///    ProgramNumber = Specifies the program number.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_ProgramNumber(int ProgramNumber);
}

///The <b>IEnumComponents</b> interface provides a standard COM enumeration object for the components (substreams) in a
///given program stream. C++ applications should use this interface to enumerate components, rather than using the
///IComponents collection interface, which is intended for Automation clients.
@GUID("2A6E2939-2595-11D3-B64C-00C04F79498E")
interface IEnumComponents : IUnknown
{
    ///The <b>Next</b> method retrieves the next <i>n</i> elements in the collection.
    ///Params:
    ///    celt = The number of elements to retrieve.
    ///    rgelt = Address of an array of IComponent interface pointers that will receive the retrieved Component objects.
    ///    pceltFetched = Receives the number of elements actually retrieved.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///The <b>Skip</b> method skips the specified element in the collection without retrieving it.
    ///Params:
    ///    celt = Specifies the element to skip.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Reset</b> method resets the enumerator to the beginning of the collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Reset();
    ///The <b>Clone</b> method creates a new copy of the entire collection.
    ///Params:
    ///    ppEnum = Address of an <b>IEnumComponents</b> interface pointer that will be set to the new collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Clone(IEnumComponents* ppEnum);
}

///The <b>IComponents</b> interface represents a collection of components. In digital television, the term
///<i>component</i> refers to a substream within the program stream. For example, a program stream may have three audio
///streams in different languages; in this case each audio stream is a component of the program stream. The
///<b>IComponents</b> interface is implemented on the Components object, which is a collection of components. The
///Components object enables applications to enumerate components within a program stream and perform operations related
///to individual components in the collection. The Components object also supports <b>IPersistPropertyBag</b>.
@GUID("39A48091-FFFE-4182-A161-3FF802640E26")
interface IComponents : IDispatch
{
    ///The <b>get_Count</b> method gets the number of <b>Component</b> objects in the collection.
    ///Params:
    ///    Count = Pointer to a variable of type <b>long</b> that receives the number of components.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Count(int* Count);
    ///The <b>get__NewEnum</b> enumeration method supports <code>For...Each</code> loops in Automation clients.
    ///Params:
    ///    ppNewEnum = Address of an <b>IEnumVARIANT</b> interface pointer that will receive the enumeration.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get__NewEnum(IEnumVARIANT* ppNewEnum);
    ///The <b>EnumComponents</b> method returns an enumerator for the components in the collection.
    ///Params:
    ///    ppNewEnum = Address of a variable that receives an IEnumComponents interface pointer.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT EnumComponents(IEnumComponents* ppNewEnum);
    ///The <b>get_Item</b> method enables the caller to access a component by index.
    ///Params:
    ///    Index = Variable of type <b>VARIANT</b> specifying the zero-based index in the collection.
    ///    ppComponent = Address of an IComponent interface pointer that will receive the <b>Component</b> object at the specified
    ///                  index.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Item(VARIANT Index, IComponent* ppComponent);
    ///The <b>Add</b> method adds a <b>Component</b> object to the collection.
    ///Params:
    ///    Component = Pointer to the <b>Component</b> object to be added.
    ///    NewIndex = Pointer to a <b>VARIANT</b> that will receive the index of the <b>Component</b> object after it has been
    ///               added.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Add(IComponent Component, VARIANT* NewIndex);
    ///The <b>Remove</b> method removes a <b>Component</b> object from the collection.
    ///Params:
    ///    Index = Variable of type <b>VARIANT</b> that specifies the index number of the <b>Component</b> object to be removed.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Remove(VARIANT Index);
    ///The <b>Clone</b> method creates a new copy of the collection.
    ///Params:
    ///    NewList = Address of an IComponents interface pointer that will be set to the new <b>Components</b> object.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Clone(IComponents* NewList);
    ///The <b>put_Item</b> method inserts a component into the collection, replacing the item that is identified by the
    ///specified index.
    ///Params:
    ///    Index = Specifies the index to assign to the component. This parameter is a value of type <b>VARIANT</b>.
    ///    ppComponent = Pointer to the IComponent interface of the component object. The method creates a clone of the component and
    ///                  inserts the clone into the collection.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Item(VARIANT Index, IComponent ppComponent);
}

@GUID("FCD01846-0E19-11D3-9D8E-00C04F72D980")
interface IComponentsOld : IDispatch
{
    HRESULT get_Count(int* Count);
    HRESULT get__NewEnum(IEnumVARIANT* ppNewEnum);
    HRESULT EnumComponents(IEnumComponents* ppNewEnum);
    HRESULT get_Item(VARIANT Index, IComponent* ppComponent);
    HRESULT Add(IComponent Component, VARIANT* NewIndex);
    HRESULT Remove(VARIANT Index);
    HRESULT Clone(IComponents* NewList);
}

///The <b>ILocator</b> interface is implemented (through derived interfaces such as IATSCLocator) on Locator objects
///that contain tuning information about the tuning space. This base interface is never used directly, but only through
///the derived interfaces that are specific for a given network type. Locator objects can be created dynamically by
///Guide Store Loaders that have the necessary information about the tuning space, or a default locator for a tuning
///space can be installed by the third party who installs the tuning space. In any case, applications never create or
///examine locators except in certain testing or debugging scenarios. All Locator objects also support
///<b>IPersistPropertyBag</b>.
@GUID("286D7F89-760C-4F89-80C4-66841D2507AA")
interface ILocator : IDispatch
{
    ///The <b>get_CarrierFrequency</b> method gets the frequency of the RF signal.
    ///Params:
    ///    Frequency = Receives the frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_CarrierFrequency(int* Frequency);
    ///The <b>put_CarrierFrequency</b> method sets the frequency of the RF signal.
    ///Params:
    ///    Frequency = The frequency, in kilohertz (kHz).
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_CarrierFrequency(int Frequency);
    ///The <b>get_InnerFEC</b> method gets the type of inner FEC that is used.
    ///Params:
    ///    FEC = Pointer to a variable of type FECMethod that receives the type of inner FEC.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_InnerFEC(FECMethod* FEC);
    ///The <b>put_InnerFEC</b> method sets the type of inner FEC to use.
    ///Params:
    ///    FEC = Specifies the inner FEC. This parameter is a value of type FECMethod.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_InnerFEC(FECMethod FEC);
    ///The <b>get_InnerFECRate</b> method gets the inner FEC rate.
    ///Params:
    ///    FEC = Pointer to a variable of type BinaryConvolutionCodeRate that receives the inner FEC rate.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_InnerFECRate(BinaryConvolutionCodeRate* FEC);
    ///The <b>put_InnerFECRate</b> method sets the inner FEC rate.
    ///Params:
    ///    FEC = Specifies the inner FEC rate. This parameter is a value of type BinaryConvolutionCodeRate.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_InnerFECRate(BinaryConvolutionCodeRate FEC);
    ///The <b>get_OuterFEC</b> method gets the type of outer FEC that is used.
    ///Params:
    ///    FEC = Pointer to a variable of type FECMethod that receives the type of outer FEC.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_OuterFEC(FECMethod* FEC);
    ///The <b>put_OuterFEC</b> method sets the type of outer FEC to use.
    ///Params:
    ///    FEC = Specifies the outer FEC. This parameter is a value of type FECMethod.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_OuterFEC(FECMethod FEC);
    ///The <b>get_OuterFECRate</b> method gets the outer FEC rate.
    ///Params:
    ///    FEC = Pointer to a variable of type BinaryConvolutionCodeRate that receives the outer FEC rate.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_OuterFECRate(BinaryConvolutionCodeRate* FEC);
    ///The <b>put_OuterFECRate</b> method sets the outer FEC rate.
    ///Params:
    ///    FEC = Specifies the outer FEC rate. This parameter is a value of type BinaryConvolutionCodeRate.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_OuterFECRate(BinaryConvolutionCodeRate FEC);
    ///The <b>get_Modulation</b> method gets the modulation type.
    ///Params:
    ///    Modulation = Receives the modulation type, as a member of the ModulationType enumeration.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Modulation(ModulationType* Modulation);
    ///The <b>put_Modulation</b> method sets the modulation type.
    ///Params:
    ///    Modulation = The modulation type, as a member of the ModulationType enumeration.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Modulation(ModulationType Modulation);
    ///The <b>get_SymbolRate</b> method gets the QPSK symbol rate.
    ///Params:
    ///    Rate = Receives the QPSK symbol rate. The rate is expressed in symbols per second.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_SymbolRate(int* Rate);
    ///The <b>put_SymbolRate</b> method sets the QPSK symbol rate.
    ///Params:
    ///    Rate = Specifies the QPSK symbol rate. The rate is expressed in symbols per second.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_SymbolRate(int Rate);
    ///The <b>Clone</b> method creates a copy of the Locator.
    ///Params:
    ///    NewLocator = Receives a pointer to the ILocator interface. The caller must release the interface.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT Clone(ILocator* NewLocator);
}

///The <b>IAnalogLocator</b> interface provides tuning information for an analog television network.
@GUID("34D1F26B-E339-430D-ABCE-738CB48984DC")
interface IAnalogLocator : ILocator
{
    ///The <b>get_VideoStandard</b> method retrieves the format of the analog television signal.
    ///Params:
    ///    AVS = Pointer to an AnalogVideoStandard variable that receives the format of the analog television signal.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved by using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_VideoStandard(AnalogVideoStandard* AVS);
    ///The <b>put_VideoStandard</b> method specifies the format of the analog television signal.
    ///Params:
    ///    AVS = Specifies the format of the analog television signal. This parameter is of type AnalogVideoStandard.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved by using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_VideoStandard(AnalogVideoStandard AVS);
}

///The <b>IDigitalLocator</b> interface serves as the base interface for Locator objects that contain tuning information
///about the tuning space for a digital network. This interface is used only through derived interfaces such as
///IATSCLocator.
@GUID("19B595D8-839A-47F0-96DF-4F194F3C768C")
interface IDigitalLocator : ILocator
{
}

///The <b>IATSCLocator</b> interface is implemented on the ATSCLocator object and contains methods that enable the
///network provider to determine the physical channel and transport stream ID of an ATSC transmission. Applications do
///not use Locator interfaces except possibly for debugging purposes. All Locator objects also support
///<b>IPersistPropertyBag</b>.
@GUID("BF8D986F-8C2B-4131-94D7-4D3D9FCC21EF")
interface IATSCLocator : IDigitalLocator
{
    ///The <b>get_PhysicalChannel</b> method retrieves the physical channel.
    ///Params:
    ///    PhysicalChannel = Receives the physical channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_PhysicalChannel(int* PhysicalChannel);
    ///The <b>put_PhysicalChannel</b> method sets the physical channel.
    ///Params:
    ///    PhysicalChannel = The physical channel.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_PhysicalChannel(int PhysicalChannel);
    ///The <b>get_TSID</b> method retrieves the transport stream ID.
    ///Params:
    ///    TSID = Receives the transport stream ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_TSID(int* TSID);
    ///The <b>put_TSID</b> method sets the transport stream ID.
    ///Params:
    ///    TSID = The transport stream ID.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_TSID(int TSID);
}

///The <b>IATASCLocator2</b> interface enables the network provider to determine the physical channel, transport stream
///ID, and program number of an ATSC transmission.
@GUID("612AA885-66CF-4090-BA0A-566F5312E4CA")
interface IATSCLocator2 : IATSCLocator
{
    ///The <b>get_ProgramNumber</b> method retrieves the program number.
    ///Params:
    ///    ProgramNumber = Pointer to a variable that receives the program number.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_ProgramNumber(int* ProgramNumber);
    ///The <b>put_ProgramNumber</b> method specifies the program number.
    ///Params:
    ///    ProgramNumber = Specifies the program number.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_ProgramNumber(int ProgramNumber);
}

///The <b>IDigitalCableLocator</b> interface provides tuning information for a digital cable network. OCUR Devices: This
///interface supports OpenCable Unidirectional Cable Receiver (OCUR) devices. See OCUR Devices.
@GUID("48F66A11-171A-419A-9525-BEEECD51584C")
interface IDigitalCableLocator : IATSCLocator2
{
}

///The <b>IDVBTLocator</b> interface is implemented on the DVBTLocator object. It provides methods to enable a tuner to
///acquire a terrestrial DVB (DVB-T) transport stream. The data types are defined in Bdatypes.h. Locator data is meant
///for consumption by the BDA hardware drivers. Applications do not need to interpret any of this data except perhaps
///for some debugging purposes. Locators can be created dynamically when the tune request is created, by a loader that
///has access to the necessary information about the tuning space, or a default locator can be installed when the tuning
///space is first installed, and the loader can use the default locator when creating tune requests. Applications do not
///need to use any of the Locator interfaces unless they are creating tune requests. All Locator objects also support
///<b>IPersistPropertyBag</b>.
@GUID("8664DA16-DDA2-42AC-926A-C18F9127C302")
interface IDVBTLocator : IDigitalLocator
{
    ///The <b>get_Bandwidth</b> method retrieves the bandwidth of the frequency.
    ///Params:
    ///    BandWidthVal = Receives the bandwidth, in megahertz (MHz).
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Bandwidth(int* BandWidthVal);
    ///The <b>put_BandWidth</b> method sets the bandwidth of the frequency.
    ///Params:
    ///    BandwidthVal = Specifies the bandwidth, in megahertz (MHz). The value should be taken from the bandwidth field in the
    ///                   terrestrial delivery system descriptor.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Bandwidth(int BandwidthVal);
    ///The <b>get_LPInnerFEC</b> method retrieves the inner FEC type of the low-priority stream.
    ///Params:
    ///    FEC = Receives a member of the FECMethod enumeration.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_LPInnerFEC(FECMethod* FEC);
    ///The <b>put_LPInnerFEC</b> method sets the inner FEC type of the low-priority stream.
    ///Params:
    ///    FEC = Variable of type FECMethod that specifies the FEC type.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_LPInnerFEC(FECMethod FEC);
    ///The <b>get_LPInnerFECRate</b> method retrieves the inner FEC rate of the low-priority stream.
    ///Params:
    ///    FEC = Receives a member of the BinaryConvolutionCodeRate enumeration.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_LPInnerFECRate(BinaryConvolutionCodeRate* FEC);
    ///The <b>put_LPInnerFECRate</b> method sets the inner FEC rate of the low-priority stream.
    ///Params:
    ///    FEC = Variable of type BinaryConvolutionCodeRate that specifies the rate.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_LPInnerFECRate(BinaryConvolutionCodeRate FEC);
    ///The <b>get_HAlpha</b> method retrieves the hierarchy alpha.
    ///Params:
    ///    Alpha = Receives a member of the HierarchyAlpha enumeration.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_HAlpha(HierarchyAlpha* Alpha);
    ///The <b>put_HAlpha</b> method sets the hierarchy alpha.
    ///Params:
    ///    Alpha = Variable of type HierarchyAlpha that specifies the hierarchy alpha.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_HAlpha(HierarchyAlpha Alpha);
    ///The <b>get_Guard</b> method retrieves the guard interval.
    ///Params:
    ///    GI = Receives a member of the GuardInterval enumeration.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Guard(GuardInterval* GI);
    ///The <b>put_Guard</b> method sets the guard interval.
    ///Params:
    ///    GI = Variable of type GuardInterval that specifies the guard interval.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Guard(GuardInterval GI);
    ///The <b>get_Mode</b> method receives the transmission mode.
    ///Params:
    ///    mode = Receives a member of the TransmissionMode enumeration.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Mode(TransmissionMode* mode);
    ///The <b>put_Mode</b> method sets the transmission mode.
    ///Params:
    ///    mode = Specifies the transmission mode as a member of the TransmissionMode enumeration.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Mode(TransmissionMode mode);
    ///The <b>get_OtherFrequencyInUse</b> method indicates whether the frequency is being used by another DVB-T
    ///broadcaster.
    ///Params:
    ///    OtherFrequencyInUseVal = Receives that value VARIANT_TRUE if the frequency is being used by another DVB-T broadcaster, or
    ///                             VARIANT_FALSE otherwise.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_OtherFrequencyInUse(short* OtherFrequencyInUseVal);
    ///The <b>put_OtherFrequencyInUse</b> method specifies whether the frequency is being used by another DVB-T
    ///broadcaster.
    ///Params:
    ///    OtherFrequencyInUseVal = Specify VARIANT_TRUE if the frequency is being used by another DVB-T broadcaster, or VARIANT_FALSE otherwise.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_OtherFrequencyInUse(short OtherFrequencyInUseVal);
}

///Gets or sets tuning information for a Digital Video Broadcast - Second Generation Terrestrial (DVB-T2) network.
@GUID("448A2EDF-AE95-4B43-A3CC-747843C453D4")
interface IDVBTLocator2 : IDVBTLocator
{
    ///Identifies a Physical Layer Pipe (PLP) that carries a T2 logical data stream. This property is read/write.
    HRESULT get_PhysicalLayerPipeId(int* PhysicalLayerPipeIdVal);
    ///Identifies a Physical Layer Pipe (PLP) that carries a T2 logical data stream. This property is read/write.
    HRESULT put_PhysicalLayerPipeId(int PhysicalLayerPipeIdVal);
}

///The <b>IDVBSLocator</b> interface is implemented on the DVBSLocator object. It provides information to enable a tuner
///to acquire a satellite DVB (DVB-S) transmission. The methods for acquiring a transport stream once the signal is
///tuned are provided by IDVBTuneRequest. Locator data is meant for consumption by the BDA hardware drivers.
///Applications do not need to interpret any of this data except perhaps for some debugging purposes. Locators can be
///created dynamically when the tune request is created, by a loader that has access to the necessary information about
///the tuning space, or a default locator can be installed when the tuning space is first installed, and the loader can
///use the default locator when creating tune requests. Applications do not need to use any of the Locator interfaces
///unless they are creating tune requests. All Locator objects also support <b>IPersistPropertyBag</b>.
@GUID("3D7C353C-0D04-45F1-A742-F97CC1188DC8")
interface IDVBSLocator : IDigitalLocator
{
    ///The <b>get_SignalPolarisation</b> method retrieves the signal polarisation.
    ///Params:
    ///    PolarisationVal = Pointer to a variable of type Polarisation that receives the polarisation value.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_SignalPolarisation(Polarisation* PolarisationVal);
    ///The <b>put_SignalPolarisation</b> method sets the signal polarisation.
    ///Params:
    ///    PolarisationVal = Variable of type Polarisation that specifies the signal polarisation value.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_SignalPolarisation(Polarisation PolarisationVal);
    ///The <b>get_WestPosition</b> method retrieves a value indicating whether the orbital position is given in east or
    ///west longitude.
    ///Params:
    ///    WestLongitude = Pointer to a variable of type <b>VARIANT_BOOL</b>; a value of true means "west longitude."
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_WestPosition(short* WestLongitude);
    ///The <b>put_WestPosition</b> method sets the longitudinal position as west longitude or east longitude.
    ///Params:
    ///    WestLongitude = Specifies whether the following longitude values that follow will be west or east longitude. True means "west
    ///                    longitude."
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_WestPosition(short WestLongitude);
    ///The <b>get_OrbitalPosition</b> method retrieves the setting for the satellite's orbital position.
    ///Params:
    ///    longitude = Receives the longitude setting in tenths of a degree.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_OrbitalPosition(int* longitude);
    ///The <b>put_OrbitalPosition</b> method sets the setting for the satellite's orbital position.
    ///Params:
    ///    longitude = The satellite's longitude in tenths of a degree.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_OrbitalPosition(int longitude);
    ///The <b>get_Azimuth</b> method retrieves the azimuth setting used for positioning the satellite dish.
    ///Params:
    ///    Azimuth = Receives the azimuth in tenths of a degree.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Azimuth(int* Azimuth);
    ///The <b>put_Azimuth</b> method adjusts the azimuth setting used for positioning the satellite dish.
    ///Params:
    ///    Azimuth = The azimuth, in tenths of a degree.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Azimuth(int Azimuth);
    ///The <b>get_Elevation</b> method retrieves the elevation of the satellite in tenths of a degree.
    ///Params:
    ///    Elevation = Receives the elevation setting in tenths of a degree.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT get_Elevation(int* Elevation);
    ///The <b>put_Elevation</b> method sets the elevation of the satellite in tenths of a degree.
    ///Params:
    ///    Elevation = The elevation, in tenths of a degree.
    ///Returns:
    ///    Returns S_OK if successful. If the method fails, error information can be retrieved using the standard COM
    ///    <b>IErrorInfo</b> interface.
    ///    
    HRESULT put_Elevation(int Elevation);
}

///Provides information to enable a tuner to acquire a Digital Video Broadcasting-Satellite (DVB-S) transmission. This
///interface extends the capabilities in the IDVBSLocator interface to support the DVB-S, Second Generation (DVB-S2)
///specification, the Digital Satellite Equipment Control (DiSEqC) protocol, and low-noise block converters (LNBs).
@GUID("6044634A-1733-4F99-B982-5FB12AFCE4F0")
interface IDVBSLocator2 : IDVBSLocator
{
    ///Specifies the input for a Digital Satellite Equipment Control (DiSEqC) low-noise block converter (LNB). This
    ///property is read/write.
    HRESULT get_DiseqLNBSource(LNB_Source* DiseqLNBSourceVal);
    ///Specifies the input for a Digital Satellite Equipment Control (DiSEqC) low-noise block converter (LNB). This
    ///property is read/write.
    HRESULT put_DiseqLNBSource(LNB_Source DiseqLNBSourceVal);
    ///Specifies the low oscillator frequency of a Digital Video Broadcasting (DVB) system, in kHz. This property is
    ///read/write.
    HRESULT get_LocalOscillatorOverrideLow(int* LocalOscillatorOverrideLowVal);
    ///Specifies the low oscillator frequency of a Digital Video Broadcasting (DVB) system, in kHz. This property is
    ///read/write.
    HRESULT put_LocalOscillatorOverrideLow(int LocalOscillatorOverrideLowVal);
    ///Specifies the high oscillator frequency of a Digital Video Broadcasting (DVB) system, in kHz. This property is
    ///read/write.
    HRESULT get_LocalOscillatorOverrideHigh(int* LocalOscillatorOverrideHighVal);
    ///Specifies the high oscillator frequency of a Digital Video Broadcasting (DVB) system, in kHz. This property is
    ///read/write.
    HRESULT put_LocalOscillatorOverrideHigh(int LocalOscillatorOverrideHighVal);
    ///Specifies the switch frequency for the low-noise block converter (LNB) of a Digital Video Broadcasting (DVB)
    ///system, in kHz. This property is read/write.
    HRESULT get_LocalLNBSwitchOverride(int* LocalLNBSwitchOverrideVal);
    ///Specifies the switch frequency for the low-noise block converter (LNB) of a Digital Video Broadcasting (DVB)
    ///system, in kHz. This property is read/write.
    HRESULT put_LocalLNBSwitchOverride(int LocalLNBSwitchOverrideVal);
    ///Specifies the spectral inversion state for a Digital Video Broadcasting-Satellite, Second Generation (DVB-S2)
    ///signal. This property is read/write.
    HRESULT get_LocalSpectralInversionOverride(SpectralInversion* LocalSpectralInversionOverrideVal);
    ///Specifies the spectral inversion state for a Digital Video Broadcasting-Satellite, Second Generation (DVB-S2)
    ///signal. This property is read/write.
    HRESULT put_LocalSpectralInversionOverride(SpectralInversion LocalSpectralInversionOverrideVal);
    ///Specifies the roll-off factor for a Digital Video Broadcasting-Satellite, Second Generation (DVB-S2) signal. This
    ///property is read/write.
    HRESULT get_SignalRollOff(RollOff* RollOffVal);
    ///Specifies the roll-off factor for a Digital Video Broadcasting-Satellite, Second Generation (DVB-S2) signal. This
    ///property is read/write.
    HRESULT put_SignalRollOff(RollOff RollOffVal);
    ///Specifies the pilot mode for a Digital Video Broadcasting-Satellite, Second Generation (DVB-S2) signal. This
    ///property is read/write.
    HRESULT get_SignalPilot(Pilot* PilotVal);
    ///Specifies the pilot mode for a Digital Video Broadcasting-Satellite, Second Generation (DVB-S2) signal. This
    ///property is read/write.
    HRESULT put_SignalPilot(Pilot PilotVal);
}

///The <b>IDVBCLocator</b> interface is implemented on DVBCLocator objects, which contain tuning information for DVB-C
///networks.
@GUID("6E42F36E-1DD2-43C4-9F78-69D25AE39034")
interface IDVBCLocator : IDigitalLocator
{
}

@GUID("C9897087-E29C-473F-9E4B-7072123DEA14")
interface IISDBSLocator : IDVBSLocator
{
}

///Gets information from an <b>OpenMMI</b> event. A Protected Broadcast Driver Architecture (PBDA) Media Transform
///Device (MTD) fires an <b>OpenMMI</b> event when the device user tries to open an on-screen display, such as a dialog
///box. For more information about PBDA, download the specification from this document.
@GUID("BA4B6526-1A35-4635-8B56-3EC612746A8C")
interface IESOpenMmiEvent : IESEvent
{
    ///The <b>GetDialogNumber</b> method returns the dialog number generated by the sending device. The dialog number
    ///identifies the dialog to the receiver while the receiver is processing the <b>OpenMMI </b> event.
    ///Params:
    ///    pDialogRequest = Pointer to the value of the dialog request from the operation that generated the <b>OpenMMI</b> request, for
    ///                     example, a call to IBDA::CheckEntitlementToken.
    ///    pDialogNumber = Gets the number generated by the device that is opening the dialog, which identifies the dialog.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDialogNumber(uint* pDialogRequest, uint* pDialogNumber);
    ///The <b>GetDialogType</b> method gets the GUID representing the experience type of the dialog that is being
    ///opened.
    ///Params:
    ///    guidDialogType = Gets the GUID identifying the experience type of the dialog. If the application does not recognize the
    ///                     experience type, it should set the event as complete by returning an ERROR_ INVALID_TYPE result.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDialogType(GUID* guidDialogType);
    ///Gets the data associated with an <b>OpenMMI</b> event, in byte stream format. This data can be the contents of
    ///the dialog that is opened or the Uniform Resource Locator (URL) that contains the dialog.
    ///Params:
    ///    pbData = Pointer to a SAFEARRAY object containing the event data. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDialogData(SAFEARRAY** pbData);
    ///Gets the data associated with an <b>OpenMMI </b> event, in Unicode string format. This data can be the contents
    ///of the dialog that is opened or the Uniform Resource Locator (URL) that contains the dialog.
    ///Params:
    ///    pbstrBaseUrl = Pointer to a string that receives the URL containing the dialog. The caller is responsible for freeing this
    ///                   memory.
    ///    pbstrData = Pointer to the string that receives the dialog contents. The caller is responsible for freeing the memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDialogStringData(BSTR* pbstrBaseUrl, BSTR* pbstrData);
}

///Receives <b>CloseMMI</b> events from a Media Sink Device (MSD) device under the Protected Broadcast Driver
///Architecture (PBDA). The MSD is the device that receives protected content from a Media Transform Device (MTD). This
///event tells the MTD that the MSD trying to close a man-machine interface (MMI) display, such as a dialog box.
@GUID("6B80E96F-55E2-45AA-B754-0C23C8E7D5C1")
interface IESCloseMmiEvent : IESEvent
{
    ///Returns the dialog number generated by Media Sink Device (MSD) under the Protected Broadcast Driver Architecture
    ///(PBDA). The MSD is the device that receives protected content from a Media Transform Device (MTD). The dialog
    ///number identifies the dialog to the MTD while the MTD is processing the <b>CloseMMI </b> event.
    ///Params:
    ///    pDialogNumber = Number generated by the MSD that is closing the dialog, which identifies the dialog.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDialogNumber(uint* pDialogNumber);
}

///Implements an event that Protected Broadcast Driver Architecture (PBDA) Media Transform Devices (MTDs) use to inform
///a Media Sink Device that the MTD has updated the value for a name-value pair or exposed a new name-value pair. The
///pair is implemented as part of the PBDA General Purpose Name-Value Service.
@GUID("8A24C46E-BB63-4664-8602-5D9C718C146D")
interface IESValueUpdatedEvent : IESEvent
{
    ///For a name-value pair in the PBDA General Purpose Name-Value Service, gets the name for the value that has been
    ///updated. PBDA Media Sink Devices (MSDs) get this name from <b>ValueUpdated</b> events fired by Media Transform
    ///Devices (MTDs) that implement the IESValueUpdatedEvent interface.
    ///Params:
    ///    pbstrNames = Pointer to a buffer that gets the name that has been updated. The caller is responsible for freeing this
    ///                 memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetValueNames(SAFEARRAY** pbstrNames);
}

///Contains methods that enable a Protected Broadcast Driver Architecture (PBDA)-supported device to get exclusive
///access to a tuner and its Conditional Access Services (CAS).
@GUID("54C7A5E8-C3BB-4F51-AF14-E0E2C0E34C6D")
interface IESRequestTunerEvent : IESEvent
{
    ///Gets a code that indicates the priority of a device request for exclusive access to a tuner and its Conditional
    ///Access Services (CAS).
    ///Params:
    ///    pbyPriority = Gets a 1-byte code that indicates the priority. The code can be any of the following values. <table> <tr>
    ///                  <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>0x00</b></dt> </dl> </td> <td
    ///                  width="60%"> OPPORTUNISTIC. The device that receives the request should see if the request conflicts with any
    ///                  other tuner usage, including scheduled and live viewing usages. </td> </tr> <tr> <td width="40%"> <dl>
    ///                  <dt><b>0x01</b></dt> </dl> </td> <td width="60%"> NOTIFY. The device that receives the request should check
    ///                  to see if the request conflicts with any other scheduled usage. If the acquisition conflicts with live
    ///                  viewing, the device should prompt the user before relinquishing access. </td> </tr> <tr> <td width="40%">
    ///                  <dl> <dt><b>0x02-0xFE</b></dt> </dl> </td> <td width="60%"> Reserved. </td> </tr> <tr> <td width="40%"> <dl>
    ///                  <dt><b>0xFF</b></dt> </dl> </td> <td width="60%"> IMMEDIATE. The device that receives the request must
    ///                  release the tuner for the requestor ownership within the next 60 seconds. The requestor can forcibly acquire
    ///                  the tuner after 60 seconds. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPriority(ubyte* pbyPriority);
    ///Gets a code that indicates the reason a device is requesting exclusive access to a tuner and its Conditional
    ///Access Services (CAS).
    ///Params:
    ///    pbyReason = Gets a 1-byte code that indicates the reason for the request. The code can be any of the following values.
    ///                <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>0x00</b></dt> </dl>
    ///                </td> <td width="60%"> Unspecified. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>0x01</b></dt> </dl> </td>
    ///                <td width="60%"> The requesting device needs the tuner to download an internal update, such as new firmware.
    ///                </td> </tr> <tr> <td width="40%"> <dl> <dt><b>[Other]</b></dt> </dl> </td> <td width="60%"> Reserved. </td>
    ///                </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetReason(ubyte* pbyReason);
    ///Gets a code that indicates the consequences of a device request for exclusive access to a tuner and its
    ///Conditional Access Services (CAS).
    ///Params:
    ///    pbyConsequences = Gets a 1-byte code indicating the consequences. The code can be any of the following values. <table> <tr>
    ///                      <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>0x00</b></dt> </dl> </td> <td
    ///                      width="60%"> Unspecified. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>0x01</b></dt> </dl> </td> <td
    ///                      width="60%"> Reboot required. The device that is requesting exclusive access must reboot itself after it
    ///                      relinquishes access. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>[Other]</b></dt> </dl> </td> <td
    ///                      width="60%"> Reserved. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetConsequences(ubyte* pbyConsequences);
    ///Gets a value indicating the amount of time that a device estimates it needs exclusive access to a tuner and its
    ///Conditional Access Services (CAS).
    ///Params:
    ///    pdwEstimatedTime = Gets the estimated time that exclusive access is needed, in seconds.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEstimatedTime(uint* pdwEstimatedTime);
}

///Implements methods that get information from a Protected Broadcast Driver Architecture (PBDA) <b>IsdbCasResponse</b>
///event. An Integrated Services Digital Broadcasting (ISDB) PBDA media transform device (MTD) fires an
///<b>IsdbCasResponse</b> event after a media sink device (MSD) calls the IBDA_ISDBConditionalAccess::SetIsdbCasRequest
///method to indicate communication with a conditional access system (CAS) card. The MTD fires the
///<b>IsdbCasResponse</b> event to signal that response data is available.
@GUID("2017CB03-DC0F-4C24-83CA-36307B2CD19F")
interface IESIsdbCasResponseEvent : IESEvent
{
    ///Gets the request identifier returned in an IsdbCasResponse event. The request identifier identifies the request
    ///originated by a PBDA media sink device (MSD).
    ///Params:
    ///    pRequestId = Receives the request identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRequestId(uint* pRequestId);
    ///Gets the response status returned in an IsdbCasResponse event.
    ///Params:
    ///    pStatus = Receives the status code. This can have any of the following values. <table> <tr> <th>Value</th>
    ///              <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x9000</dt> </dl> </td> <td width="60%"> Success. </td>
    ///              </tr> <tr> <td width="40%"> <dl> <dt>0x6400</dt> </dl> </td> <td width="60%"> Memory error. </td> </tr> <tr>
    ///              <td width="40%"> <dl> <dt>0x6581</dt> </dl> </td> <td width="60%"> Write error. </td> </tr> <tr> <td
    ///              width="40%"> <dl> <dt>0x6700</dt> </dl> </td> <td width="60%"> Interconnect command length. </td> </tr> <tr>
    ///              <td width="40%"> <dl> <dt>0x6800</dt> </dl> </td> <td width="60%"> Unsupported class. </td> </tr> <tr> <td
    ///              width="40%"> <dl> <dt>0x6A86</dt> </dl> </td> <td width="60%"> Incorrect parameter. </td> </tr> <tr> <td
    ///              width="40%"> <dl> <dt>0x6D00</dt> </dl> </td> <td width="60%"> Unsupported instruction. </td> </tr> <tr> <td
    ///              width="40%"> <dl> <dt>0x6E00</dt> </dl> </td> <td width="60%"> Unsupported class. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStatus(uint* pStatus);
    ///Gets the length of response data returned in anIsdbCasResponse event.
    ///Params:
    ///    pRequestLength = Receives the length of the response data, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDataLength(uint* pRequestLength);
    ///Gets the response data returned in an IsdbCasResponse event.
    ///Params:
    ///    pbData = Pointer to a buffer that receives the response data. The caller must free this memory after use.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetResponseData(SAFEARRAY** pbData);
}

@GUID("907E0B5C-E42D-4F04-91F0-26F401F36907")
interface IGpnvsCommonBase : IUnknown
{
    HRESULT GetValueUpdateName(BSTR* pbstrName);
}

@GUID("506A09B8-7F86-4E04-AC05-3303BFE8FC49")
interface IESEventFactory : IUnknown
{
    HRESULT CreateESEvent(IUnknown pServiceProvider, uint dwEventId, GUID guidEventType, uint dwEventDataLength, 
                          char* pEventData, BSTR bstrBaseUrl, IUnknown pInitContext, IESEvent* ppESEvent);
}

///Implements methods that get information from a <b>LicenseRenewalResult</b> event. This event contains the results of
///an attempt to renew a license for protected content. If the attempt succeeds, the results contain the license; if the
///attempt fails, the results contain error information.
@GUID("D5A48EF5-A81B-4DF0-ACAA-5E35E7EA45D4")
interface IESLicenseRenewalResultEvent : IESEvent
{
    ///Gets a unique identifier from a <b>LicenseRenewalResult</b> event that identifies the caller. Each client that
    ///attempts to renew a license must specify this identifier to identify the client that is requesting the license
    ///renewal. When the renewal completes, this result is sent out and received by all the clients that are listening
    ///for this event. Clients can use this identifier value to match whether the result belongs to them or is intended
    ///for some other client.
    ///Params:
    ///    pdwCallersId = Receives the caller identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCallersId(uint* pdwCallersId);
    ///Gets the file name for the license to renew from a <b>LicenseRenewalResult</b> event.
    ///Params:
    ///    pbstrFilename = Pointer to a buffer that receives the file name. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFileName(BSTR* pbstrFilename);
    ///Gets a flag from a <b>LicenseRenewalResult</b> event that indicates whether the renewal was successful. In the
    ///event of failure, a client can call the GetRenewalResultCode or GetRenewalHResult method to get information about
    ///the reason for the failure.
    ///Params:
    ///    pfRenewalSuccessful = Receives the renewal success flag: 1 indicates success; 0 indicates failure.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsRenewalSuccessful(int* pfRenewalSuccessful);
    ///Gets a flag from a <b>LicenseRenewalResult</b> event that indicates whether the client should check the
    ///entitlement token from the license. The client can call the IBDA_ConditionalAccessEx::CheckEntitlementToken
    ///method to validate the entitlement token.
    ///Params:
    ///    pfCheckEntTokenCallNeeded = Receives the check entitlement token flag: 1 indicates that a check is needed; 0 indicates that no check is
    ///                                needed.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsCheckEntitlementCallRequired(int* pfCheckEntTokenCallNeeded);
    ///Gets a code from a LicenseRenewalResult event that indicates the result of an attempt to descramble protected
    ///content.
    ///Params:
    ///    pDescrambledStatus = Receives a status code that indicates the descrambling status. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///                         </tr> <tr> <td width="40%"> <dl> <dt>0x00000000 </dt> </dl> </td> <td width="60%"> Free to air content
    ///                         (nonprotected). </td> </tr> <tr> <td width="40%"> <dl> <dt>0x00000001</dt> </dl> </td> <td width="60%">
    ///                         Descrambling possible. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80010000</dt> </dl> </td> <td
    ///                         width="60%"> No technical (other). </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80010001 </dt> </dl> </td>
    ///                         <td width="60%"> (No technical) firmware upgrade required. </td> </tr> <tr> <td width="40%"> <dl>
    ///                         <dt>0x80010002 </dt> </dl> </td> <td width="60%"> (No technical) internal failure. </td> </tr> <tr> <td
    ///                         width="40%"> <dl> <dt>0x80010003 </dt> </dl> </td> <td width="60%"> (No technical) initializing/not ready.
    ///                         </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80010004 </dt> </dl> </td> <td width="60%"> (No technical) setup
    ///                         required. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80010005 </dt> </dl> </td> <td width="60%"> (No
    ///                         technical) no access card. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80010006 </dt> </dl> </td> <td
    ///                         width="60%"> (No technical) access card failure. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80010007 </dt>
    ///                         </dl> </td> <td width="60%"> (No technical) bad access card. </td> </tr> <tr> <td width="40%"> <dl>
    ///                         <dt>0x80010008 </dt> </dl> </td> <td width="60%"> (No technical) wrong access card. </td> </tr> <tr> <td
    ///                         width="40%"> <dl> <dt>0x80010009 </dt> </dl> </td> <td width="60%"> (No technical) expired access card. </td>
    ///                         </tr> <tr> <td width="40%"> <dl> <dt>0x8001000A</dt> </dl> </td> <td width="60%"> (No technical) out of
    ///                         resources, for example, too many streams. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x8001000B </dt> </dl>
    ///                         </td> <td width="60%"> (No technical) not in purchase window. </td> </tr> <tr> <td width="40%"> <dl>
    ///                         <dt>0x8001000C </dt> </dl> </td> <td width="60%"> (No technical) not in purchase window, prior. </td> </tr>
    ///                         <tr> <td width="40%"> <dl> <dt>0x8001000D </dt> </dl> </td> <td width="60%"> (No technical) not in purchase
    ///                         window, after. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80020000 </dt> </dl> </td> <td width="60%"> No
    ///                         entitlement (other). </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80020001</dt> </dl> </td> <td width="60%">
    ///                         (No entitlement) access card not authorized. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80020002</dt> </dl>
    ///                         </td> <td width="60%"> (No entitlement) service not authorized. </td> </tr> <tr> <td width="40%"> <dl>
    ///                         <dt>0x80020003</dt> </dl> </td> <td width="60%"> (No entitlement) service expired. </td> </tr> <tr> <td
    ///                         width="40%"> <dl> <dt>0x80020004</dt> </dl> </td> <td width="60%"> (No entitlement) account not authorized.
    ///                         </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80020005</dt> </dl> </td> <td width="60%"> (No entitlement)
    ///                         account expired. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80020006</dt> </dl> </td> <td width="60%"> (No
    ///                         entitlement) service blacked out. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80020007</dt> </dl> </td> <td
    ///                         width="60%"> (No entitlement) purchase required. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80020008</dt>
    ///                         </dl> </td> <td width="60%"> (No entitlement) insufficient credit. </td> </tr> <tr> <td width="40%"> <dl>
    ///                         <dt>0x80020009</dt> </dl> </td> <td width="60%"> (No entitlement) purchase canceled. </td> </tr> <tr> <td
    ///                         width="40%"> <dl> <dt>0x8002000A</dt> </dl> </td> <td width="60%"> (No entitlement) renewal entitlement
    ///                         expired. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x8002000B</dt> </dl> </td> <td width="60%"> (No
    ///                         entitlement) showing not available. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x8002000C</dt> </dl> </td>
    ///                         <td width="60%"> (No entitlement) showing next. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDescrambledStatus(uint* pDescrambledStatus);
    ///Gets a constant from a Protected Broadcast Driver Architecture (PBDA) <b>LicenseRenewalResult</b> event that
    ///indicates which step in the renewal process caused the renewal to succeed or fail. A client can call the
    ///IsRenewalSuccessful method to determine if the renewal was successful, and then call this method to get
    ///information about the reason for any failure.
    ///Params:
    ///    pdwRenewalResultCode = Receives the result code. The result code indicates the license renewal step that failed and can be any of
    ///                           the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
    ///                           <dt>LBE_RenewalStage_Invalid</dt> </dl> </td> <td width="60%"> Received license was invalid. </td> </tr> <tr>
    ///                           <td width="40%"> <dl> <dt>LRE_RenewalStage_RenewalFailed</dt> </dl> </td> <td width="60%"> Renewal attempt
    ///                           failed. </td> </tr> <tr> <td width="40%"> <dl> <dt>LRE_RenewalStage_CheckForRenewableLicense</dt> </dl> </td>
    ///                           <td width="60%"> Renewal attempt failed during the check for a renewable license. </td> </tr> <tr> <td
    ///                           width="40%"> <dl> <dt>LRE_RenewalStage_RenewLicenseAtTuner</dt> </dl> </td> <td width="60%"> Renewal attempt
    ///                           failed at the tuner. </td> </tr> <tr> <td width="40%"> <dl> <dt>LRE_RenewalStage_StoreLicenseInDRM</dt> </dl>
    ///                           </td> <td width="60%"> Renewal attempt failed during license storage. </td> </tr> <tr> <td width="40%"> <dl>
    ///                           <dt>LRE_RenewalStage_RenewalSuccessful</dt> </dl> </td> <td width="60%"> License renewal was successful.
    ///                           </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRenewalResultCode(uint* pdwRenewalResultCode);
    ///Gets a code from a <b>LicenseRenewalResult</b> event that indicates the reason for the failure in the conditional
    ///access system (CAS).
    ///Params:
    ///    pdwCASFailureCode = Receives the CAS failure code. This code is defined by the CAS that is used.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCASFailureCode(uint* pdwCASFailureCode);
    ///Gets the final <b>HRESULT</b> value from a <b>LicenseRenewalResult</b> event that is returned by a call to a COM
    ///interface method during the renewal process.
    ///Params:
    ///    phr = Receives the <b>HRESULT</b> value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRenewalHResult(int* phr);
    ///Gets the length of the entitlement token in a protected-content license from a <b>LicenseRenewalResult</b> event.
    ///Params:
    ///    pdwLength = Receives the length of the entitlement token, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEntitlementTokenLength(uint* pdwLength);
    ///Gets the entitlement token in a protected-content license from a <b>LicenseRenewalResult</b> event. Clients can
    ///call the GetEntitlementTokenLength method to get the number of bytes to read from this buffer.
    ///Params:
    ///    pbData = Pointer to a buffer that receives the entitlement token.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEntitlementToken(SAFEARRAY** pbData);
    ///Gets the expiry date of a renewed protected-content license from a <b>LicenseRenewalResult</b> event.
    ///Params:
    ///    pqwExpiryDate = Receives the expiry date in number of seconds since epoch.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetExpiryDate(ulong* pqwExpiryDate);
}

///Gets information from a <b>FileExpiryDate</b> event. A Protected Broadcast Driver Architecture (PBDA) media transform
///device (MTD) fires a <b>FileExpiryDate</b> event when it receives a new license for protected content that contains a
///new expiry date for that content.
@GUID("BA9EDCB6-4D36-4CFE-8C56-87A6B0CA48E1")
interface IESFileExpiryDateEvent : IESEvent
{
    ///Gets a globally unique identifier (GUID) from a <b>FileExpiryDate</b> event that identifies the media transform
    ///device (MTD) that originated the event.
    ///Params:
    ///    pguidTunerId = Receives the GUID for the MTD.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTunerId(GUID* pguidTunerId);
    ///Gets the date from a <b>FileExpiryDate</b> event that indicates when a license for protected content expires.
    ///Params:
    ///    pqwExpiryDate = Receives the expiry date from the event.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetExpiryDate(ulong* pqwExpiryDate);
    ///Gets the date from a <b>FileExpiryDate</b> event that indicates when a renewable license for protected content
    ///finally expires.
    ///Params:
    ///    pqwExpiryDate = Receives the final expiry date.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFinalExpiryDate(ulong* pqwExpiryDate);
    ///Gets the maximum number of times that a license for protected content can be renewed from a <b>FileExpiryDate</b>
    ///event.
    ///Params:
    ///    dwMaxRenewalCount = Receives the maximum renewal count.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMaxRenewalCount(uint* dwMaxRenewalCount);
    ///Gets a flag from <b>FileExpiryDate</b> event that indicates whether a license for protected content contains an
    ///entitlement token. Media transform devices and media sink devices in a Protected Broadcast Driver Architecture
    ///(PBDA) filter graph can use entitlement tokens to verify whether users can access protected content.
    ///Params:
    ///    pfEntTokenPresent = Receives the flag, which is true if the license for protected content contains an entitlement token or false
    ///                        otherwise.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsEntitlementTokenPresent(int* pfEntTokenPresent);
    ///Gets a flag from a <b>FileExpiryDate</b> event that indicates whether a license for protected content expires
    ///after its first use.
    ///Params:
    ///    pfExpireAfterFirstUse = Receives the flag, which is true if the license expires after first use or false otherwise.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DoesExpireAfterFirstUse(int* pfExpireAfterFirstUse);
}

///Implements an event service that includes methods that raise events derived from the IESEvent interface. Media
///Transform Devices in a Protected Broadcast Driver Architecture (PBDA) graph can use this interface to send specific
///types of these events to Media Sink Devices that have registered to receive them. The <b>IESEventService</b>
///interface is an outgoing connection point interface.
@GUID("ED89A619-4C06-4B2F-99EB-C7669B13047C")
interface IESEventService : IUnknown
{
    ///Raises an event derived from the IESEvent interface. Media Transform Devices in a Protected Broadcast Driver
    ///Architecture (PBDA) graph can use this method to raise these types of events for Media Sink Devices that have
    ///registered to handle specific event types. The IESEvent object is processed in a multithreaded apartment and
    ///finally sent to clients from this apartment. Make sure the object runs either using the multithreaded threading
    ///model or using the single-threaded with proper marshaling interfaces.
    ///Params:
    ///    pESEvent = Pointer to the IESEvent interface for the event being raised.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT FireESEvent(IESEvent pESEvent);
}

///Contains methods that configure an event service that implements the IESEventService interface. This interface allows
///you to create your own event service and set it up to receive events from a Protected Broadcast Driver Architecture
///(PBDA) event service, then pass those events to your event service's clients.
@GUID("33B9DAAE-9309-491D-A051-BCAD2A70CD66")
interface IESEventServiceConfiguration : IUnknown
{
    ///Sets a parent event service for an event service that implements the IESEventService interface. Once an event
    ///service has set a parent, it can receive advise events from the parent.
    ///Params:
    ///    pEventService = Pointer to the IESEventService interface for the parent event service.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetParent(IESEventService pEventService);
    ///Removes the parent of the current event service. Once an event service has removed a parent, the parent can no
    ///longer pass advise events to the child event service for handling.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveParent();
    ///Adds an owner to an event service, where <i>event service</i> refers to a generic Windows event service that
    ///implements the IESEventService interface. The owner is the IESEvents object that the parent event service uses to
    ///pass advise events to its child event service for handling.
    ///Params:
    ///    pESEvents = Pointer to the IESEvents interface that the parent event service uses to advise its child.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOwner(IESEvents pESEvents);
    ///Removes the owner of an event service, where <i>event service</i> refers to a generic Windows event service that
    ///implements the IESEventService interface. The owner is the IESEvents object that the parent event service uses to
    ///pass advise events to its child for handling.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveOwner();
    ///Attaches an event service that implements the IESEventService interface to a filter graph. This method allows the
    ///processing of events that support the IESEvent interface from devices in the graph.
    ///Params:
    ///    pGraph = Pointer to the IFilterGraph interface that is attached to the IESEventService event service.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetGraph(IFilterGraph pGraph);
    ///Removes an event service that implements the IESEventService interface from a filter graph. This method prevents
    ///the processing of events from Protected Broadcast Driver Architecture (PBDA) devices in the graph.
    ///Params:
    ///    pGraph = Pointer to the IFilterGraph interface for the event service that is removed.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveGraph(IFilterGraph pGraph);
}

///This feature is expected to be available on a future version of the Windows operating system. The
///<b>IRegisterTuner</b> interface registers an apartment-threaded tuner with the tuner marshaller and registers the
///tuner marshaller with the graph service provider. A common scenario that uses the video control involves a physical
///remote control sending infrared commands to a set-top box. The set-top box can be plugged into an auxiliary input or
///into the radio frequency (RF) tuner on the playback device. The analog tuner in the video control must be tuned to
///the input channel to receive the signal, but the content is actually on a different channel. Some filters need the
///actual content channel; they query ITuner to retrieve it. However, an object outside the filter graph and the video
///control may be doing the actual tuning. If the external object is apartment-model threaded, synchronization issues
///may occur because ITuner can be called on any thread. The tuner marshaller is a utility object that simplifies this
///situation by storing the apartment model interface pointer and registering itself instead. Whenever the tuner
///marshaller <b>ITuner</b> interface is called, the tuner marshaller does the correct marshalling and passes the call
///to the external apartment-model object. The tuner marshaller also handles registering with the graph service
///provider.
@GUID("359B3901-572C-4854-BB49-CDEF66606A25")
interface IRegisterTuner : IUnknown
{
    ///This feature is expected to be available on a future version of the Windows operating system. The <b>Register</b>
    ///method registers an apartment-threaded tuner with the tuner marshaller and registers the tuner marshaller with
    ///the graph service provider.
    ///Params:
    ///    pTuner = Pointer to a variable that specifies the tuner.
    ///    pGraph = Pointer to a variable that specifies the graph filter provider.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT Register(ITuner pTuner, IGraphBuilder pGraph);
    ///This feature is expected to be available on a future version of the Windows operating system. The
    ///<b>Unregister</b> method unregisters an apartment-threaded tuner and a tuner marshaller that were registered by
    ///<b>IRegisterTuner::Register</b>.
    ///Returns:
    ///    When the method succeeds, it returns S_OK. Otherwise it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT Unregister();
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IBDAComparable</b> interface compares two objects to determine whether they contain the same or equivalent tuning
///information. DirectShow supports this interface in its implementation of the IComponent, IComponentType,
///ITuneRequest, ILocator, and ITuningSpace base interfaces and in the derived interfaces that inherit from these base
///interfaces. An application can query a component, component-type, tune-request, locator, or tuning-space object for
///an <b>IBDAComparable</b> interface that it can use to compare the tuning properties of the object to those of another
///object of the same type. To support comparisons of the tuning properties of similar objects, two of the methods in
///this interface compare the property values directly. The remaining methods generate 64-bit CRC values from the
///property values for each object that the caller can compare to determine whether the objects have the same or
///equivalent properties.
@GUID("B34505E0-2F0E-497B-80BC-D43F3B24ED7F")
interface IBDAComparable : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>CompareExact</b> method compares two objects to determine whether they contain the same tuning information.
    ///Params:
    ///    CompareTo = Pointer to the <b>IDispatch</b> interface of the object that is to be compared with the object that
    ///                implements the <b>IBDAComparable</b> interface.
    ///    Result = Pointer to a variable that receives the result of the comparison. If the result is 0, the two objects are the
    ///             same. If the result is nonzero, the two objects are not the same.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT CompareExact(IDispatch CompareTo, int* Result);
    ///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center
    ///Edition 2005 and later.</div><div> </div>The <b>CompareEquivalent</b> method compares two objects to determine
    ///whether they contain equivalent tuning information.
    ///Params:
    ///    CompareTo = Pointer to the <b>IDispatch</b> interface of the object that is to be compared with the object that
    ///                implements the IBDAComparable interface.
    ///    dwFlags = Specifies whether to alter the default equivalence comparison. Setting this parameter to 0 invokes the
    ///              default behavior. Setting this parameter to the bitwise OR of one or more BDA_Comp_Flags enumeration values
    ///              overrides the default behavior.
    ///    Result = Receives the result of the comparison. If the result is 0, the two objects are equivalent. If the result is
    ///             nonzero, the two objects are not equivalent.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT CompareEquivalent(IDispatch CompareTo, uint dwFlags, int* Result);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>HashExact</b> method generates a hash code for all of the tuning properties of an object.
    ///Params:
    ///    Result = Receives the result of the hash operation. This result is the hash code for the tuning properties of the
    ///             object and its associated objects that are to be included in comparisons with other objects.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT HashExact(long* Result);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>HashExactIncremental</b> method incrementally generates a hash code for all of the tuning properties of an
    ///object.
    ///Params:
    ///    PartialResult = Specifies the intermediate hash code that is to be combined with the hash code that is generated by the
    ///                    method. Typically, this value was generated by a previous call to either <b>HashExactIncremental</b> or
    ///                    HashExact.
    ///    Result = Receives the result of the hash operation. This result is the hash code for the tuning properties of the
    ///             object and its associated objects that are to be included in comparisons with other objects.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT HashExactIncremental(long PartialResult, long* Result);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>HashEquivalent</b> method generates a hash code for a subset of the tuning properties of an object.
    ///Params:
    ///    dwFlags = Specifies whether to alter the subset of properties that are to be incorporated by default into the hash
    ///              code. Setting this parameter to 0 invokes the default behavior. Setting this parameter to the bitwise
    ///              <b>OR</b> of one or more BDA_Comp_Flags enumeration values overrides the default behavior.
    ///    Result = Pointer to a variable that receives the result of the hash operation. This result is the hash code for the
    ///             subset of the tuning properties of the object and its associated objects that are to be included in
    ///             comparisons with other objects.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT HashEquivalent(uint dwFlags, long* Result);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>HashEquivalentIncremental</b> method incrementally generates a hash code for a subset of the tuning properties
    ///of an object.
    ///Params:
    ///    PartialResult = Specifies the intermediate hash code that is to be combined with the hash code that is generated by the
    ///                    method. Typically, this value was generated by a previous call to either <b>HashEquivalentIncremental</b> or
    ///                    HashEquivalent.
    ///    dwFlags = Specifies whether to alter the subset of properties that are to be incorporated by default into the hash
    ///              code. Setting this parameter to 0 invokes the default behavior. Setting this parameter to the bitwise
    ///              <b>OR</b> of one or more BDA_Comp_Flags enumeration values overrides the default behavior.
    ///    Result = Pointer to a variable that receives the result of the hash operation. This result is the hash code for the
    ///             subset of the tuning properties of the object and its associated objects that are to be included in
    ///             comparisons with other objects.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT HashEquivalentIncremental(long PartialResult, uint dwFlags, long* Result);
}

///Implements methods for serializing tuning model objects. All serializable tuning model objects are required to
///implement this interface.
@GUID("0754CD31-8D15-47A9-8215-D20064157244")
interface IPersistTuneXml : IPersist
{
    ///This method is not implemented in the current release. It was created to make the IPersistTuneXml interface
    ///compatible with the <b>IPersistStreamInit</b> interface and is reserved for future use.
    ///Returns:
    ///    Always returns <b>S_OK</b>.
    ///    
    HRESULT InitNew();
    ///Deserializes a tuning model object from an XML node.
    ///Params:
    ///    varValue = XML node used to deserialize the object. This parameter can be either a <b>BSTR</b> object or an
    ///               <b>IXMLDOMNode</b> object.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Load(VARIANT varValue);
    ///Serializes a tuning model object to an XML node.
    ///Params:
    ///    pvarFragment = Pointer to an <b>IXMLDOMNode</b> object that gets the data for the tuning model object.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Save(VARIANT* pvarFragment);
}

///Defines utility methods for deserializing XML tuning requests to objects that expose their <b>IUnknown</b>
///interfaces.
@GUID("990237AE-AC11-4614-BE8F-DD217A4CB4CB")
interface IPersistTuneXmlUtility : IUnknown
{
    ///Constructs and returns an object that initializes itself by using the XML node passed as a <b>VARIANT</b>
    ///parameter to the method. The returned object exposes its <b>IUnknown</b> interface so that other objects can
    ///query it.
    ///Params:
    ///    varValue = XML node used to construct and initialize the object. This parameter can be either a <b>BSTR</b> object or an
    ///               <b>IXMLDOMNode</b> object.
    ///    ppObject = Pointer to the <b>IUnknown</b> interface of the object being deserialized. This method allocates memory to
    ///               hold the deserialized object and returns the pointer in this parameter. The caller is responsible for freeing
    ///               this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Deserialize(VARIANT varValue, IUnknown* ppObject);
}

///Defines utility methods for serializing tuning requests (objects that implement the ITuneRequest interface) to XML
///tuning request strings.
@GUID("992E165F-EA24-4B2F-9A1D-009D92120451")
interface IPersistTuneXmlUtility2 : IPersistTuneXmlUtility
{
    ///Serializes a tuning request to an XML tuning request string.
    ///Params:
    ///    piTuneRequest = Pointer to the ITuneRequest interface for the tuning request object that is serialized.
    ///    pString = Pointer to a buffer that receives the XML tuning request string. The caller is responsible for releasing this
    ///              memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Serialize(ITuneRequest piTuneRequest, BSTR* pString);
}

///Implements the CreateTuneRequestEx method, which creates a new tuning request for a tuning space.
@GUID("C0A4A1D4-2B3C-491A-BA22-499FBADD4D12")
interface IBDACreateTuneRequestEx : IUnknown
{
    ///Creates a new tuning request for a tuning space. This method enables the caller to specify a particular type of
    ///tuning request.
    ///Params:
    ///    TuneRequestIID = GUID that identifies the type of ITuneRequest object expected by the caller. If this value is <b>NULL</b>,
    ///                     this method behaves the same as ITuningSpace::CreateTuneRequest and creates an empty (uninitialized)
    ///                     <b>ITuneRequest</b> object.
    ///    TuneRequest = Address of a variable that receives a pointer to the ITuneRequest interface of the new tuning request object.
    ///                  The caller must release the interface. If the <i>TuneRequestIID</i> argument is <b>NULL</b>, this address is
    ///                  set to <b>NULL</b> also.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateTuneRequestEx(const(GUID)* TuneRequestIID, ITuneRequest* TuneRequest);
}

///The <b>IETFilterConfig</b> interface configures the Encrypter/Tagger filter. Most applications will not have to use
///this interface.
@GUID("C4C4C4D1-0049-4E2B-98FB-9537F6CE516D")
interface IETFilterConfig : IUnknown
{
    ///The <b>InitLicense</b> method initializes an encryption license.
    ///Params:
    ///    LicenseId = Identifies the license.
    ///Returns:
    ///    Returns an <b>HRESULT</b>.
    ///    
    HRESULT InitLicense(int LicenseId);
    ///This topic applies to Windows XP Service Pack 1 or later. The <b>GetSecureChannelObject</b> method retrieves the
    ///secure channel object used to encrypt the stream.
    ///Params:
    ///    ppUnkDRMSecureChannel = Receives a pointer to the secure channel object's <b>IUnknown</b> interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b>.
    ///    
    HRESULT GetSecureChannelObject(IUnknown* ppUnkDRMSecureChannel);
}

///The <b>IDTFilterConfig</b> interface configures the Decrypter/Detagger filter. Most applications will not have to use
///this interface.
@GUID("C4C4C4D2-0049-4E2B-98FB-9537F6CE516D")
interface IDTFilterConfig : IUnknown
{
    ///The <b>GetSecureChannelObject</b> method retrieves the secure channel object used to decrypt the stream.
    ///Params:
    ///    ppUnkDRMSecureChannel = Receives a pointer to the secure channel object's <b>IUnknown</b> interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b>.
    ///    
    HRESULT GetSecureChannelObject(IUnknown* ppUnkDRMSecureChannel);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>IXDSCodecConfig</b>
///interface configures the XDS Codec filter. Most applications will not have to use this interface.
@GUID("C4C4C4D3-0049-4E2B-98FB-9537F6CE516D")
interface IXDSCodecConfig : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>GetSecureChannelObject</b> method retrieves the secure channel object used to decrypt the stream.
    ///Params:
    ///    ppUnkDRMSecureChannel = Receives a pointer to the secure channel object's <b>IUnknown</b> interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b>.
    ///    
    HRESULT GetSecureChannelObject(IUnknown* ppUnkDRMSecureChannel);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>SetPauseBufferTime</b> method specifies how often the XDS Codec filter attempts to generate a new license for
    ///protected video content.
    ///Params:
    ///    dwPauseBufferTime = Specifies the license generation interval, in seconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b>.
    ///    
    HRESULT SetPauseBufferTime(uint dwPauseBufferTime);
}

@GUID("8A78B317-E405-4A43-994A-620D8F5CE25E")
interface IDTFilterLicenseRenewal : IUnknown
{
    HRESULT GetLicenseRenewalData(ushort** ppwszFileName, ushort** ppwszExpiredKid, ushort** ppwszTunerId);
}

@GUID("26D836A5-0C15-44C7-AC59-B0DA8728F240")
interface IPTFilterLicenseRenewal : IUnknown
{
    HRESULT RenewLicenses(ushort* wszFileName, ushort* wszExpiredKid, uint dwCallersId, BOOL bHighPriority);
    HRESULT CancelLicenseRenewal();
}

@GUID("5A86B91A-E71E-46C1-88A9-9BB338710552")
interface IMceBurnerControl : IUnknown
{
    HRESULT GetBurnerNoDecryption();
}

///The <b>IETFilter</b> interface is exposed by the Encrypter/Tagger filter. Most applications will not have to use this
///interface.
@GUID("C4C4C4B1-0049-4E2B-98FB-9537F6CE516D")
interface IETFilter : IUnknown
{
    ///The <b>get_EvalRatObjOK</b> method queries whether the <b>EvalRat</b> object was created successfully.
    ///Params:
    ///    pHrCoCreateRetVal = Receives an <b>HRESULT</b> value. The <b>HRESULT</b> is the value that was returned when the filter called
    ///                        <b>CoCreateInstance</b> to create the <b>EvalRat</b> object. If it equals S_OK, the <b>EvalRat</b> object was
    ///                        created successfully.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT get_EvalRatObjOK(int* pHrCoCreateRetVal);
    ///The <b>GetCurrRating</b> method retrieves the current rating, based on the most recent media sample.
    ///Params:
    ///    pEnSystem = Receives the rating system, as an EnTvRat_System enumeration type.
    ///    pEnRating = Receives the rating level, as an EnTvRat_GenericLevel enumeration type. The meaning of this value depends on
    ///                the rating system.
    ///    plbfEnAttr = Receives a bitwise combination of flags from the BfEnTvRat_GenericAttributes enumeration. The flags specify
    ///                 content attributes, such as violence or adult language. Content attributes do not apply to all rating
    ///                 systems.
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT GetCurrRating(EnTvRat_System* pEnSystem, EnTvRat_GenericLevel* pEnRating, int* plbfEnAttr);
    ///This method is currently not supported.
    ///Params:
    ///    protType = Reserved.
    ///    lpDateTime = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCurrLicenseExpDate(ProtType* protType, int* lpDateTime);
    ///Not implemented.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented </td> </tr> </table>
    ///    
    HRESULT GetLastErrorCode();
    ///The <b>SetRecordingOn</b> method signals to the Encrypter/Tagger filter that the Video Control is about to start
    ///or stop recording.
    ///Params:
    ///    fRecState = <b>TRUE</b> if recording is about to start, or <b>FALSE</b> if recording is about to stop.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetRecordingOn(BOOL fRecState);
}

@GUID("C4C4C4C1-0049-4E2B-98FB-9537F6CE516D")
interface IETFilterEvents : IDispatch
{
}

///The <b>IDTFilter</b> interface is exposed by the Decrypter/Detagger filter. Applications can use this interface to
///set the ratings permissions.
@GUID("C4C4C4B2-0049-4E2B-98FB-9537F6CE516D")
interface IDTFilter : IUnknown
{
    ///The <b>get_EvalRatObjOK</b> method queries whether the <b>EvalRat</b> object was created successfully.
    ///Params:
    ///    pHrCoCreateRetVal = Receives an <b>HRESULT</b> value. The <b>HRESULT</b> is the value that was returned when the filter called
    ///                        <b>CoCreateInstance</b> to create the <b>EvalRat</b> object. If it equals S_OK, the <b>EvalRat</b> object was
    ///                        created successfully.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT get_EvalRatObjOK(int* pHrCoCreateRetVal);
    ///The <b>GetCurrRating</b> method retrieves the current rating, based on the most recent media sample.
    ///Params:
    ///    pEnSystem = Receives the rating system, as an EnTvRat_System enumeration type.
    ///    pEnRating = Receives the rating level, as an EnTvRat_GenericLevel enumeration type. The meaning of this value depends on
    ///                the rating system.
    ///    plbfEnAttr = Receives a bitwise combination of flags from the BfEnTvRat_GenericAttributes enumeration. The flags specify
    ///                 content attributes, such as violence or adult language. Content attributes do not apply to all rating
    ///                 systems.
    ///Returns:
    ///    Returns S_OK if successful, or an error code otherwise.
    ///    
    HRESULT GetCurrRating(EnTvRat_System* pEnSystem, EnTvRat_GenericLevel* pEnRating, int* plbfEnAttr);
    ///The <b>get_BlockedRatingAttributes</b> method determines whether content is blocked for a given rating system and
    ///rating level.
    ///Params:
    ///    enSystem = Specifies the rating system as an EnTvRat_System enumeration type.
    ///    enLevel = Specifies the rating level as an EnTvRat_GenericLevel enumeration type.
    ///    plbfEnAttr = Receives a bitwise combination of flags from the BfEnTvRat_GenericAttributes enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
    ///    width="60%"> The <b>EvalRat</b> object was not successfully created. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_BlockedRatingAttributes(EnTvRat_System enSystem, EnTvRat_GenericLevel enLevel, int* plbfEnAttr);
    ///The <b>put_BlockedRatingAttributes</b> method specifies whether to block content that has a specified rating.
    ///Params:
    ///    enSystem = Specifies the rating system, as an EnTvRat_System enumeration type.
    ///    enLevel = Specifies the rating level, as an EnTvRat_GenericLevel enumeration type.
    ///    lbfAttrs = Bitwise combination of zero or more flags from the BfEnTvRat_GenericAttributes enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
    ///    width="60%"> The <b>EvalRat</b> object was not successfully created. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT put_BlockedRatingAttributes(EnTvRat_System enSystem, EnTvRat_GenericLevel enLevel, int lbfAttrs);
    ///The <b>get_BlockUnRated</b> method indicates whether a program without rating information is blocked.
    ///Params:
    ///    pfBlockUnRatedShows = Receives a Boolean value. If the value is <b>TRUE</b>, unrated shows are blocked. Otherwise, they are not
    ///                          blocked.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
    ///    width="60%"> The <b>EvalRat</b> object was not successfully created. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_BlockUnRated(int* pfBlockUnRatedShows);
    ///The <b>put_BlockUnRated</b> method specifies whether to block a program for which rating information has not been
    ///obtained.
    ///Params:
    ///    fBlockUnRatedShows = Boolean value. Specify <b>TRUE</b> to block unrated programs, or specify <b>FALSE</b> not to block unrated
    ///                         programs.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
    ///    width="60%"> The <b>EvalRat</b> object was not successfully created. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT put_BlockUnRated(BOOL fBlockUnRatedShows);
    ///The <b>get_BlockUnRatedDelay</b> method retrieves that length of time the filter waits before it blocks unrated
    ///content.
    ///Params:
    ///    pmsecsDelayBeforeBlock = Receives the delay, in milliseconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT get_BlockUnRatedDelay(int* pmsecsDelayBeforeBlock);
    ///The <b>put_BlockUnRatedDelay</b> method sets the length of time the filter waits before it blocks unrated
    ///content.
    ///Params:
    ///    msecsDelayBeforeBlock = Specifies the delay, in milliseconds. The value must be from 0 to 60000 (60 seconds).
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT put_BlockUnRatedDelay(int msecsDelayBeforeBlock);
}

///The <b>IDTFilter2</b> interface extends the IDTFilter interface and is exposed by the Decrypter/Detagger filter.
@GUID("C4C4C4B4-0049-4E2B-98FB-9537F6CE516D")
interface IDTFilter2 : IDTFilter
{
    ///Not implemented in this release.
    ///Params:
    ///    pbstrChallengeUrl = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_ChallengeUrl(BSTR* pbstrChallengeUrl);
    ///Not implemented in this release.
    ///Params:
    ///    protType = Reserved.
    ///    lpDateTime = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCurrLicenseExpDate(ProtType* protType, int* lpDateTime);
    ///The <b>GetLastErrorCode</b> method returns the most recent error code from the Decrypter/Detagger filter.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>NS_E_DRM_APPCERT_REVOKED</b></dt> </dl> </td>
    ///    <td width="60%"> A problem has occurred in the digital rights management (DRM) component. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>NS_E_DRM_CERTIFICATE_REVOKED</b></dt> </dl> </td> <td width="60%"> The client's
    ///    certificate has been revoked. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> No DRM errors have occurred. </td> </tr> </table>
    ///    
    HRESULT GetLastErrorCode();
}

///The <b>IDTFilter3</b> interface extends the IDTFilter2 interface and is exposed by the Decrypter/Detagger filter.
@GUID("513998CC-E929-4CDF-9FBD-BAD1E0314866")
interface IDTFilter3 : IDTFilter2
{
    ///The <b>GetProtectionType</b> method retrieves the type of content protection that is currently in effect.
    ///Params:
    ///    pProtectionType = Receives the current protection type, specified as a member of the ProtType enumeration type.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT GetProtectionType(ProtType* pProtectionType);
    ///The <b>LicenseHasExpirationDate</b> method queries whether the license for the content has an expiration date.
    ///Params:
    ///    pfLicenseHasExpirationDate = Receives a Boolean value. If <b>TRUE</b>, the license has an expiration date. If <b>FALSE</b>, the license
    ///                                 does not expire.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT LicenseHasExpirationDate(int* pfLicenseHasExpirationDate);
    ///Not implemented in this release.
    ///Params:
    ///    bstrRights = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRights(BSTR bstrRights);
}

@GUID("C4C4C4C2-0049-4E2B-98FB-9537F6CE516D")
interface IDTFilterEvents : IDispatch
{
}

///The <b>IXDSCodec</b> interface is exposed by the XDS Codec filter. Most applications will not have to use this
///interface.
@GUID("C4C4C4B3-0049-4E2B-98FB-9537F6CE516D")
interface IXDSCodec : IUnknown
{
    ///The <b>get_XDSToRatObjOK</b> method queries whether the <b>XDSToRat</b> object was created successfully.
    ///Params:
    ///    pHrCoCreateRetVal = Receives an <b>HRESULT</b> value. The <b>HRESULT</b> is the value that was returned when the filter called
    ///                        <b>CoCreateInstance</b> to create the <b>XDSToRat</b> object. If it equals S_OK, the <b>EvalRat</b> object
    ///                        was created successfully.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT get_XDSToRatObjOK(int* pHrCoCreateRetVal);
    ///The <b>put_CCSubstreamService</b> method specifies which line 21 data channels the XDS Codec filter sends to the
    ///<b>XDSToRat</b> object. By default, only the Extended Data Services (XDS) channel is supported.
    ///Params:
    ///    SubstreamMask = Bitwise combination of zero or more KS_CC_SUBSTREAM flags, specifying the line 21 services.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT put_CCSubstreamService(int SubstreamMask);
    ///The <b>get_CCSubstreamService</b> method queries which line 21 data channels the XDS Codec filter sends to the
    ///<b>XDSToRat</b> object. By default, it sends just the Extended Data Services (XDS) channel.
    ///Params:
    ///    pSubstreamMask = Receives a bitwise combination of zero or more KS_CC_SUBSTREAM flags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT get_CCSubstreamService(int* pSubstreamMask);
    ///The <b>GetContentAdvisoryRating</b> method retrieves the most recent ratings information parsed by the
    ///<b>XDSToRat</b> object.
    ///Params:
    ///    pRat = Receives the most recent rating. The rating is packed into a format that is used internally by the XDS Codec
    ///           filter, Encrypter/Tagger filter, and Decrypter/Detagger filter. It is not intended for use by other objects.
    ///    pPktSeqID = Receives the number of ratings packets that have been decoded. This information can be used for diagnostic
    ///                purposes.
    ///    pCallSeqID = Receives the number of times this method has been called for the current ratings packet. This information can
    ///                 be used for diagnostic purposes.
    ///    pTimeStart = Receives the start time of the sample that completed the ratings packet.
    ///    pTimeEnd = Receives the stop time of the sample that completed the ratings packet.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetContentAdvisoryRating(int* pRat, int* pPktSeqID, int* pCallSeqID, long* pTimeStart, long* pTimeEnd);
    ///The <b>GetXDSPacket</b> method retrieves the most recent XDS packet.
    ///Params:
    ///    pXDSClassPkt = Receives the packet class.
    ///    pXDSTypePkt = Receives the class-specific packet type.
    ///    pBstrXDSPkt = Receives the packet as a <b>BSTR</b> value.
    ///    pPktSeqID = Receives the number of ratings packets that have been decoded. This information can be used for diagnostic
    ///                purposes.
    ///    pCallSeqID = Receives the number of times this method has been called for the current ratings packet. This information can
    ///                 be used for diagnostic purposes.
    ///    pTimeStart = Receives the start time of the sample containing the packet.
    ///    pTimeEnd = Receives the stop time of the sample containing the packet.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetXDSPacket(int* pXDSClassPkt, int* pXDSTypePkt, BSTR* pBstrXDSPkt, int* pPktSeqID, int* pCallSeqID, 
                         long* pTimeStart, long* pTimeEnd);
    ///Not implemented in this release.
    ///Params:
    ///    protType = Reserved.
    ///    lpDateTime = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCurrLicenseExpDate(ProtType* protType, int* lpDateTime);
    ///Not implemented in this release.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLastErrorCode();
}

@GUID("C4C4C4C3-0049-4E2B-98FB-9537F6CE516D")
interface IXDSCodecEvents : IDispatch
{
}

///The <b>IXDSToRat</b> interface parses rating information from extended data services (XDS) information in line 21.
///This interface is exposed by the XDSToRat (ratings decoder) object. The XDSToRat object is implemented by third
///parties. The XDS Codec filter uses this interface. Applications do not use this interface.
@GUID("C5C5C5B0-3ABC-11D6-B25B-00C04FA0C026")
interface IXDSToRat : IDispatch
{
    ///The <b>Init</b> method sets the XDSToRat object to its initial state.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Init();
    ///The <b>ParseXDSBytePair</b> method parses a single byte pair from an XDS stream. If the byte pair is the last
    ///pair in a completed ratings packet, the method returns the rating information.
    ///Params:
    ///    byte1 = The first byte of the byte pair.
    ///    byte2 = The second byte of the byte pair.
    ///    pEnSystem = Receives the rating system, as a member of the EnTvRat_System enumeration type.
    ///    pEnLevel = Receives the rating level, as a member of the EnTvRat_GenericLevel enumeration type. The meaning of this
    ///               value depends on the rating system.
    ///    plBfEnAttributes = Receives a bitwise combination of zero or more flags from the BfEnTvRat_GenericAttributes enumeration. These
    ///                       flags specify additional content attributes, such as violence or adult language. They do not apply to every
    ///                       rating system.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> No rating has been detected in the stream yet. </td> </tr> </table>
    ///    
    HRESULT ParseXDSBytePair(ubyte byte1, ubyte byte2, EnTvRat_System* pEnSystem, EnTvRat_GenericLevel* pEnLevel, 
                             int* plBfEnAttributes);
}

///The <b>IEvalRat</b> interface is used to evaluate content ratings carried by a broadcast stream. This interface is
///exposed by the EvalRat (ratings evaluator) object. The EvalRat object is implemented by third parties. The
///Encrypter/Tagger filter and the Decrypter/Detagger filter use this interface. Applications use the interfaces exposed
///by those filters, but typically do not use the <b>IEvalRat</b> interface.
@GUID("C5C5C5B1-3ABC-11D6-B25B-00C04FA0C026")
interface IEvalRat : IDispatch
{
    ///The <b>get_BlockedRatingAttributes</b> method determines whether content is blocked for a given rating system and
    ///rating level.
    ///Params:
    ///    enSystem = Specifies the rating system, as an EnTvRat_System enumeration type.
    ///    enLevel = Specifies the rating level, as an EnTvRat_GenericLevel enumeration type. The meaning of this value depends on
    ///              the rating system.
    ///    plbfAttrs = [out, retval] Receives a bitwise combination of flags from the BfEnTvRat_GenericAttributes enumeration. The
    ///                flags indicate whether the overall rating is blocked, or specific attributes within the rating are blocked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_BlockedRatingAttributes(EnTvRat_System enSystem, EnTvRat_GenericLevel enLevel, int* plbfAttrs);
    ///The <b>put_BlockedRatingAttributes</b> method specifies whether to block content that has a specified rating.
    ///Params:
    ///    enSystem = Specifies the rating system, as an EnTvRat_System enumeration type.
    ///    enLevel = Specifies the rating level, as an EnTvRat_GenericLevel enumeration type. The meaning of this value depends on
    ///              the rating system.
    ///    lbfAttrs = Bitwise combination of zero or more flags from the BfEnTvRat_GenericAttributes enumeration. The flags specify
    ///               whether the overall rating is blocked, or specific attributes within the rating are blocked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_BlockedRatingAttributes(EnTvRat_System enSystem, EnTvRat_GenericLevel enLevel, int lbfAttrs);
    ///The <b>get_BlockUnRated</b> method indicates whether a program without rating information is blocked.
    ///Params:
    ///    pfBlockUnRatedShows = Receives a Boolean value. If the value is <b>TRUE</b>, unrated shows are blocked. Otherwise, they are not
    ///                          blocked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_BlockUnRated(int* pfBlockUnRatedShows);
    ///The <b>put_BlockUnRated</b> method specifies whether to block a program for which rating information has not been
    ///obtained.
    ///Params:
    ///    fBlockUnRatedShows = Boolean value. Specify <b>TRUE</b> to block unrated programs, or specify <b>FALSE</b> not to block unrated
    ///                         programs.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_BlockUnRated(BOOL fBlockUnRatedShows);
    ///The <b>MostRestrictiveRating</b> method compares two ratings and returns the more restrictive of the two.
    ///Params:
    ///    enSystem1 = The rating system of the first rating to compare, specified as a member of the EnTvRat_System enumeration.
    ///    enEnLevel1 = The rating level of the first rating, specified as a member of the EnTvRat_GenericLevel enumeration.
    ///    lbfEnAttr1 = Specifies the content attributes of the first rating, as a bitwise combination of flags from the
    ///                 BfEnTvRat_GenericAttributes enumeration.
    ///    enSystem2 = The rating system of the second rating to compare, specified as a member of the EnTvRat_System enumeration.
    ///    enEnLevel2 = The rating level of the second rating, specified as a member of the EnTvRat_GenericLevel enumeration.
    ///    lbfEnAttr2 = Specifies the content attributes of the second rating, as a bitwise combination of flags from the
    ///                 BfEnTvRat_GenericAttributes enumeration.
    ///    penSystem = Receives the rating system of the more restrictive rating.
    ///    penEnLevel = Receives the rating level of the more restrictive rating.
    ///    plbfEnAttr = Receives a bitwise combination of flags from the BfEnTvRat_GenericAttributes enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt>
    ///    </dl> </td> <td width="60%"> The ratings are from two different rating systems. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT MostRestrictiveRating(EnTvRat_System enSystem1, EnTvRat_GenericLevel enEnLevel1, int lbfEnAttr1, 
                                  EnTvRat_System enSystem2, EnTvRat_GenericLevel enEnLevel2, int lbfEnAttr2, 
                                  EnTvRat_System* penSystem, EnTvRat_GenericLevel* penEnLevel, int* plbfEnAttr);
    ///The <b>TestRating</b> method determines whether a program with the specified rating should be blocked.
    ///Params:
    ///    enShowSystem = Specifies the rating system, as an EnTvRat_System enumeration type.
    ///    enShowLevel = Specifies the rating level, as an EnTvRat_GenericLevel enumeration type. The meaning of this value depends on
    ///                  the rating system.
    ///    lbfEnShowAttributes = Bitwise combination of zero or more flags from the BfEnTvRat_GenericAttributes enumeration. The flags specify
    ///                          content attributes, such as violence or adult language. Content attributes do not apply to all rating
    ///                          systems.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> This program is restricted and should be blocked. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> This program is allowed and should not be blocked.
    ///    </td> </tr> </table>
    ///    
    HRESULT TestRating(EnTvRat_System enShowSystem, EnTvRat_GenericLevel enShowLevel, int lbfEnShowAttributes);
}

///The <b>IMSVidRect</b> interface represents a rectangle with an associated window handle. It contains methods to set
///and retrieve the top and left coordinates, the width, and the height. All values are in pixels. The top and left
///coordinates are relative to the associated window.
@GUID("7F5000A6-A440-47CA-8ACC-C0E75531A2C2")
interface IMSVidRect : IDispatch
{
    ///The <b>get_Top</b> method retrieves the top y-coordinate of the rectangle. This coordinate is relative to the
    ///rectangle's associated window.
    ///Params:
    ///    TopVal = Pointer to a variable that receives the top y-coordinate, in pixels.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Top(int* TopVal);
    ///The <b>put_Top</b> method specifies the top y-coordinate of the rectangle. This coordinate is relative to the
    ///rectangle's associated window.
    ///Params:
    ///    TopVal = Specifies the top y-coordinate, in pixels.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Top(int TopVal);
    ///The <b>get_Left</b> method retrieves the left x-coordinate of the rectangle. This coordinate is relative to the
    ///rectangle's associated window.
    ///Params:
    ///    LeftVal = Pointer to a variable that receives the left x-coordinate, in pixels.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Left(int* LeftVal);
    ///The <b>put_Left</b> method specifies the left x-coordinate of the rectangle. This coordinate is relative to the
    ///rectangle's associated window.
    ///Params:
    ///    LeftVal = Specifies the left x-coordinate, in pixels.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Left(int LeftVal);
    ///The <b>get_Width</b> method retrieves the width of the rectangle.
    ///Params:
    ///    WidthVal = Pointer to a variable that receives the width, in pixels.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Width(int* WidthVal);
    ///The <b>put_Width</b> method specifies the width of the rectangle.
    ///Params:
    ///    WidthVal = Specifies the width, in pixels.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Width(int WidthVal);
    ///The <b>get_Height</b> method retrieves the height of the rectangle.
    ///Params:
    ///    HeightVal = Pointer to a variable that receives the height, in pixels.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Height(int* HeightVal);
    ///The <b>put_Height</b> method specifies the height of the rectangle.
    ///Params:
    ///    HeightVal = Specifies the height, in pixels.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Height(int HeightVal);
    ///The <b>get_HWnd</b> method retrieves the window associated with the rectangle.
    ///Params:
    ///    HWndVal = Pointer to a variable that receives a handle to the window.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_HWnd(HWND* HWndVal);
    ///The <b>put_HWnd</b> method specifies the window associated with the rectangle.
    ///Params:
    ///    HWndVal = Specifies the handle to the window.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_HWnd(HWND HWndVal);
    ///The <b>put_Rect</b> method copies the values of another rectangle to this rectangle.
    ///Params:
    ///    RectVal = Specifies a pointer to the IMSVidRect interface of the rectangle to copy.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Rect(IMSVidRect RectVal);
}

///The <b>IMSVidGraphSegmentContainer</b> interface is exposed by the Video Control and contains one supported method,
///get_Graph, which obtains a pointer to the Filter Graph Manager.
@GUID("3DD2903D-E0AA-11D2-B63A-00C04F79498E")
interface IMSVidGraphSegmentContainer : IUnknown
{
    ///The <b>get_Graph</b> method returns a pointer to the Filter Graph Manager.
    ///Params:
    ///    ppGraph = Address of a variable that receives an IGraphBuilder interface pointer.
    ///Returns:
    ///    Returns S_OK if successful, or an <b>HRESULT</b> error code otherwise.
    ///    
    HRESULT get_Graph(IGraphBuilder* ppGraph);
    HRESULT get_Input(IMSVidGraphSegment* ppInput);
    HRESULT get_Outputs(IEnumMSVidGraphSegment* ppOutputs);
    HRESULT get_VideoRenderer(IMSVidGraphSegment* ppVR);
    HRESULT get_AudioRenderer(IMSVidGraphSegment* ppAR);
    HRESULT get_Features(IEnumMSVidGraphSegment* ppFeatures);
    HRESULT get_Composites(IEnumMSVidGraphSegment* ppComposites);
    HRESULT get_ParentContainer(IUnknown* ppContainer);
    HRESULT Decompose(IMSVidGraphSegment pSegment);
    HRESULT IsWindowless();
    HRESULT GetFocus();
}

@GUID("238DEC54-ADEB-4005-A349-F772B9AFEBC4")
interface IMSVidGraphSegment : IPersist
{
    HRESULT get_Init(IUnknown* pInit);
    HRESULT put_Init(IUnknown pInit);
    HRESULT EnumFilters(IEnumFilters* pNewEnum);
    HRESULT get_Container(IMSVidGraphSegmentContainer* ppCtl);
    HRESULT put_Container(IMSVidGraphSegmentContainer pCtl);
    HRESULT get_Type(MSVidSegmentType* pType);
    HRESULT get_Category(GUID* pGuid);
    HRESULT Build();
    HRESULT PostBuild();
    HRESULT PreRun();
    HRESULT PostRun();
    HRESULT PreStop();
    HRESULT PostStop();
    HRESULT OnEventNotify(int lEventCode, ptrdiff_t lEventParm1, ptrdiff_t lEventParm2);
    HRESULT Decompose();
}

@GUID("301C060E-20D9-4587-9B03-F82ED9A9943C")
interface IMSVidGraphSegmentUserInput : IUnknown
{
    HRESULT Click();
    HRESULT DblClick();
    HRESULT KeyDown(short* KeyCode, short ShiftState);
    HRESULT KeyPress(short* KeyAscii);
    HRESULT KeyUp(short* KeyCode, short ShiftState);
    HRESULT MouseDown(short ButtonState, short ShiftState, int x, int y);
    HRESULT MouseMove(short ButtonState, short ShiftState, int x, int y);
    HRESULT MouseUp(short ButtonState, short ShiftState, int x, int y);
}

@GUID("1C15D483-911D-11D2-B632-00C04F79498E")
interface IMSVidCompositionSegment : IMSVidGraphSegment
{
    HRESULT Compose(IMSVidGraphSegment upstream, IMSVidGraphSegment downstream);
    HRESULT get_Up(IMSVidGraphSegment* upstream);
    HRESULT get_Down(IMSVidGraphSegment* downstream);
}

@GUID("3DD2903E-E0AA-11D2-B63A-00C04F79498E")
interface IEnumMSVidGraphSegment : IUnknown
{
    HRESULT Next(uint celt, IMSVidGraphSegment* rgelt, uint* pceltFetched);
    HRESULT Skip(uint celt);
    HRESULT Reset();
    HRESULT Clone(IEnumMSVidGraphSegment* ppenum);
}

@GUID("DD47DE3F-9874-4F7B-8B22-7CB2688461E7")
interface IMSVidVRGraphSegment : IMSVidGraphSegment
{
    HRESULT put__VMRendererMode(int dwMode);
    HRESULT put_Owner(HWND Window);
    HRESULT get_Owner(HWND* Window);
    HRESULT get_UseOverlay(short* UseOverlayVal);
    HRESULT put_UseOverlay(short UseOverlayVal);
    HRESULT get_Visible(short* Visible);
    HRESULT put_Visible(short Visible);
    HRESULT get_ColorKey(uint* ColorKey);
    HRESULT put_ColorKey(uint ColorKey);
    HRESULT get_Source(RECT* r);
    HRESULT put_Source(RECT r);
    HRESULT get_Destination(RECT* r);
    HRESULT put_Destination(RECT r);
    HRESULT get_NativeSize(SIZE* sizeval, SIZE* aspectratio);
    HRESULT get_BorderColor(uint* color);
    HRESULT put_BorderColor(uint color);
    HRESULT get_MaintainAspectRatio(short* fMaintain);
    HRESULT put_MaintainAspectRatio(short fMaintain);
    HRESULT Refresh();
    HRESULT DisplayChange();
    HRESULT RePaint(HDC hdc);
}

///The <b>IMSVidDevice</b> interface is the base interface for all the devices and features that the Video Control
///supports.
@GUID("1C15D47C-911D-11D2-B632-00C04F79498E")
interface IMSVidDevice : IDispatch
{
    ///The <b>get_Name</b> method retrieves the friendly name of the device.
    ///Params:
    ///    Name = Pointer to a variable that receives the friendly name.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Name(BSTR* Name);
    ///The <b>get_Status</b> method retrieves status information about the device.
    ///Params:
    ///    Status = Pointer to a variable of that receives the current status.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Status(int* Status);
    ///The <b>put_Power</b> method turns the device on or off.
    ///Params:
    ///    Power = Specifies whether to turn the power on or off. Use one of the following values. <table> <tr> <th>Value </th>
    ///            <th>Description </th> </tr> <tr> <td>VARIANT_TRUE</td> <td>Turn the device on.</td> </tr> <tr>
    ///            <td>VARIANT_FALSE</td> <td>Turn the device off.</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> </table>
    ///    
    HRESULT put_Power(short Power);
    ///The <b>get_Power</b> method queries whether the device is off or on.
    ///Params:
    ///    Power = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///            </th> </tr> <tr> <td>VARIANT_TRUE</td> <td>The device is on.</td> </tr> <tr> <td>VARIANT_FALSE</td> <td>The
    ///            device is off.</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Power(short* Power);
    ///The <b>get_Category</b> method retrieves the category of the device as a <b>BSTR</b>.
    ///Params:
    ///    Guid = <b>BSTR</b> that receives the device category.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Category(BSTR* Guid);
    ///The <b>get_ClassID</b> method retrieves the device's class identifier (CLSID) as a <b>BSTR</b>.
    ///Params:
    ///    Clsid = Pointer to a variable that receives a string representation of the CLSID.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_ClassID(BSTR* Clsid);
    ///The <b>get__Category</b> method retrieves the category of the device as a <b>GUID</b>.
    ///Params:
    ///    Guid = Pointer to a variable of type <b>GUID</b> that receives the device category.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get__Category(GUID* Guid);
    ///The <b>get__ClassID</b> method retrieves the device's class identifier (CLSID) as a <b>GUID</b>.
    ///Params:
    ///    Clsid = Pointer to a variable of type <b>GUID</b> that receives the CLSID.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get__ClassID(GUID* Clsid);
    ///The <b>IsEqualDevice</b> method queries whether this device and another device represent the same underlying
    ///hardware.
    ///Params:
    ///    Device = Pointer to the other device's IMSVidDevice interface.
    ///    IsEqual = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///              </th> </tr> <tr> <td>VARIANT_TRUE</td> <td>The two devices represent the same underlying hardware.</td> </tr>
    ///              <tr> <td>VARIANT_FALSE</td> <td>The two devices do not represent the same hardware.</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success; returned VARIANT_TRUE. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td>
    ///    <td width="60%"> Success; returned VARIANT_FALSE. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error occurred. </td>
    ///    </tr> </table>
    ///    
    HRESULT IsEqualDevice(IMSVidDevice Device, short* IsEqual);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 or later. The
///<b>IMSVidDevice2</b> interface is implemented by some Video Control device objects.
@GUID("87BD2783-EBC0-478C-B4A0-E8E7F43AB78E")
interface IMSVidDevice2 : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 or later. The
    ///<b>get_DevicePath</b> method retrieves the device path.
    ///Params:
    ///    DevPath = Pointer to a <b>BSTR</b> that receives the device path. The caller must free the returned string, using the
    ///              <b>SysFreeString</b> function.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_DevicePath(BSTR* DevPath);
}

///The <b>IMSVidInputDevice</b> interface represents any input device that is recognized by the Video Control, such as a
///television tuner card. This is a generic interface that serves as an abstract base class for input devices. Several
///interfaces inherit <b>IMSVidInputDevice</b>, including the following: <ul> <li> IMSVidTuner </li> <li>
///IMSVidAnalogTuner </li> </ul> When a method returns an <b>IMSVidInputDevice</b> pointer, the object that is returned
///typically supports one of the derived interfaces.
@GUID("37B0353D-A4C8-11D2-B634-00C04F79498E")
interface IMSVidInputDevice : IMSVidDevice
{
    ///The <b>IsViewable</b> method determines whether this device can view the specified tune request. Currently this
    ///method is not implemented by any of the supported input devices.
    ///Params:
    ///    v = Specifies the tune request as a <b>VARIANT</b> type.
    ///    pfViewable = Pointer to variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///                 </th> </tr> <tr> <td>VARIANT_TRUE</td> <td>The device can view this tune request.</td> </tr> <tr>
    ///                 <td>VARIANT_FALSE</td> <td>The device cannot view this tune request.</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not
    ///    implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument. </td> </tr> </table>
    ///    
    HRESULT IsViewable(VARIANT* v, short* pfViewable);
    ///The <b>View</b> method configures this input device to view the specified tune request.
    ///Params:
    ///    v = Specifies the tune request as a <b>VARIANT</b> type.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT View(VARIANT* v);
}

///This topic applies to Windows XP or later. The <b>IMSVidDeviceEvent</b> interface is the base interface for device
///events. Do not implement this interface directly. Other event interfaces derive from this interface.
@GUID("1C15D480-911D-11D2-B632-00C04F79498E")
interface IMSVidDeviceEvent : IDispatch
{
    ///This topic applies to Windows XP or later. The <b>StateChange</b> method signals that the state of the device has
    ///changed.
    ///Params:
    ///    lpd = Pointer to the device object that signaled the change.
    ///    oldState = Specifies the old state as an MSVidCtlStateList value.
    ///    newState = Specifies the new state as an MSVidCtlStateList value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT StateChange(IMSVidDevice lpd, int oldState, int newState);
}

///This topic applies to Windows XP or later. The <b>IMSVidInputDeviceEvent</b> interface is the base interface for
///input device events. Do not implement this interface directly. Other event interfaces derive from this interface.
@GUID("37B0353E-A4C8-11D2-B634-00C04F79498E")
interface IMSVidInputDeviceEvent : IDispatch
{
}

///The <b>IMSVidVideoInputDevice</b> interface represents a video input device. This interface inherits from the
///IMSVidInputDevice interface but adds no methods to it. It exists to support polymorphism. The IMSVidTuner interface,
///which represents video tuning devices, inherits from this interface.
@GUID("1C15D47F-911D-11D2-B632-00C04F79498E")
interface IMSVidVideoInputDevice : IMSVidInputDevice
{
}

///The <b>IMSVidPlayback</b> interface controls a Video Control playback device.
@GUID("37B03538-A4C8-11D2-B634-00C04F79498E")
interface IMSVidPlayback : IMSVidInputDevice
{
    ///The <b>get_EnableResetOnStop</b> method indicates how playback will resume if the graph is rebuilt.
    ///Params:
    ///    pVal = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///           </th> </tr> <tr> <td>VARIANT_FALSE</td> <td>The Video Control will not seek to start of the media.</td> </tr>
    ///           <tr> <td>VARIANT_TRUE</td> <td>The Video Control will seek to start of the media.</td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_EnableResetOnStop(short* pVal);
    ///The <b>put_EnableResetOnStop</b> method indicates how playback will resume if the graph is rebuilt.
    ///Params:
    ///    newVal = Specifies one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///             <td><b>VARIANT_FALSE</b></td> <td>The Video Control attempts to start from position where playback was
    ///             interrupted. (Default)</td> </tr> <tr> <td><b>VARIANT_TRUE</b></td> <td>The Video Control seeks back to the
    ///             start before resuming playback.</td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_EnableResetOnStop(short newVal);
    ///The <b>Run</b> method runs the playback device. Applications should call the IMSVidCtl::Run method, rather than
    ///this method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Run();
    ///The <b>Pause</b> method pauses the playback device. Applications should call the IMSVidCtl::Pause method, rather
    ///than this method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Pause();
    ///The <b>Stop</b> method stops the playback device. Applications should call the IMSVidCtl::Stop method, rather
    ///than this method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Stop();
    ///The <b>get_CanStep</b> method queries whether the input source can step frame by frame.
    ///Params:
    ///    fBackwards = Use one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                 <td>VARIANT_FALSE</td> <td>Query whether the input can step forward</td> </tr> <tr> <td>VARIANT_TRUE</td>
    ///                 <td>Query whether the input can step backward.</td> </tr> </table>
    ///    pfCan = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///            </th> </tr> <tr> <td>VARIANT_FALSE</td> <td>The source cannot step in the specified direction.</td> </tr>
    ///            <tr> <td>VARIANT_TRUE</td> <td>The source can step in the specified direction.</td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_INVALID_STATE</b></dt> </dl> </td> <td width="60%"> The graph is not built. Call the Build or
    ///    View method on the Video Control. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table> <div class="alert"><b>Note</b> The value
    ///    ERROR_INVALID_STATE is converted to an <b>HRESULT</b> with the <b>HRESULT_FROM_WIN32</b> macro.</div> <div>
    ///    </div>
    ///    
    HRESULT get_CanStep(short fBackwards, short* pfCan);
    ///The <b>Step</b> method steps through the video stream by a specified number of frames.
    ///Params:
    ///    lStep = Specifies how many frames to step. If <i>lStep</i> is 1, the Video Control steps forward one frame. If
    ///            <i>lStep</i> is a number <i>N</i> greater than 1, the Video Control skips <i>N</i> - 1 frames and shows the
    ///            <i>N</i>th frame.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_STATE</b></dt>
    ///    </dl> </td> <td width="60%"> The graph is not built. Call the Build or View method on the Video Control.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table> <div class="alert"><b>Note</b> The value ERROR_INVALID_STATE is converted to
    ///    an <b>HRESULT</b> with the <b>HRESULT_FROM_WIN32</b> macro.</div> <div> </div>
    ///    
    HRESULT Step(int lStep);
    ///The <b>put_Rate</b> method sets the playback rate.
    ///Params:
    ///    plRate = Specifies the playback rate, as a ratio to the authored rate. For example, 0.5 means half the normal speed,
    ///             1.0 means normal speed, and 2.0 means twice the normal speed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The source filter does not support the specified rate. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_INVALID_STATE</b></dt> </dl> </td> <td width="60%"> The graph is not built. Call the Build or
    ///    View method on the Video Control. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table> <div class="alert"><b>Note</b> The value
    ///    ERROR_INVALID_STATE is converted to an <b>HRESULT</b> with the <b>HRESULT_FROM_WIN32</b> macro.</div> <div>
    ///    </div>
    ///    
    HRESULT put_Rate(double plRate);
    ///The <b>get_Rate</b> method retrieves the playback rate.
    ///Params:
    ///    plRate = Pointer to a variable that receives the playback rate, as a ratio to the authored rate. For example, 0.5
    ///             means half the normal speed, 1.0 means normal speed, and 2.0 means twice the normal speed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_INVALID_STATE</b></dt> </dl> </td> <td width="60%"> The graph is not built. Call the Build or
    ///    View method on the Video Control. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table> <div class="alert"><b>Note</b> The value
    ///    ERROR_INVALID_STATE is converted to an <b>HRESULT</b> with the <b>HRESULT_FROM_WIN32</b> macro.</div> <div>
    ///    </div>
    ///    
    HRESULT get_Rate(double* plRate);
    ///The <b>put_CurrentPosition</b> method seeks to a specified position in the source.
    ///Params:
    ///    lPosition = Specifies the new position. The units for this parameter are determined by the current position mode. <table>
    ///                <tr> <th>Position Mode </th> <th>Returned Value </th> </tr> <tr> <td>FrameMode</td> <td>Frame number</td>
    ///                </tr> <tr> <td>TenthsSecondsMode</td> <td>Hundredths of seconds</td> </tr> </table> To set the position mode,
    ///                call IMSVidPlayback::put_PositionMode.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_STATE</b></dt> </dl>
    ///    </td> <td width="60%"> The graph is not built. Call the Build or View method on the Video Control. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table> <div class="alert"><b>Note</b> The value ERROR_INVALID_STATE is converted to
    ///    an <b>HRESULT</b> with the <b>HRESULT_FROM_WIN32</b> macro.</div> <div> </div>
    ///    
    HRESULT put_CurrentPosition(int lPosition);
    ///The <b>get_CurrentPosition</b> method returns the current playback position of the source.
    ///Params:
    ///    lPosition = Pointer to a variable that receives the playback position. The units for the returned value are determined by
    ///                the current position mode: <table> <tr> <th>Position Mode </th> <th>Returned Value </th> </tr> <tr>
    ///                <td>FrameMode</td> <td>Frame number</td> </tr> <tr> <td>TenthsSecondsMode</td> <td>Hundredths of seconds</td>
    ///                </tr> </table> To set the position mode, call IMSVidPlayback::put_PositionMode.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_INVALID_STATE</b></dt> </dl> </td> <td width="60%"> The graph is not built. Call the Build or
    ///    View method on the Video Control. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table> <div class="alert"><b>Note</b> The value
    ///    ERROR_INVALID_STATE is converted to an <b>HRESULT</b> with the <b>HRESULT_FROM_WIN32</b> macro.</div> <div>
    ///    </div>
    ///    
    HRESULT get_CurrentPosition(int* lPosition);
    ///The <b>put_PositionMode</b> method specifies how position values will be interpreted by this interface.
    ///Params:
    ///    lPositionMode = Specifies one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                    <td>FrameMode</td> <td>Position values are specified as frame numbers.</td> </tr> <tr>
    ///                    <td>TenthsSecondsMode</td> <td>Position values are specified as hundredths of seconds.</td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_STATE</b></dt> </dl>
    ///    </td> <td width="60%"> The graph is not built. Call the Build or View method on the Video Control. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failed. Possibly the
    ///    source does not support this mode. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The method succeeded. </td> </tr> </table> <div class="alert"><b>Note</b> The value
    ///    ERROR_INVALID_STATE is converted to an <b>HRESULT</b> with the <b>HRESULT_FROM_WIN32</b> macro.</div> <div>
    ///    </div>
    ///    
    HRESULT put_PositionMode(PositionModeList lPositionMode);
    ///The <b>get_PositionMode</b> method indicates how position values are interpreted by this interface.
    ///Params:
    ///    lPositionMode = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///                    </th> </tr> <tr> <td>FrameMode</td> <td>Position values are specified as frame numbers.</td> </tr> <tr>
    ///                    <td>TenthsSecondsMode</td> <td>Position values are specified as hundredths of seconds.</td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_INVALID_STATE</b></dt> </dl> </td> <td width="60%"> The graph is not built. Call the Build or
    ///    View method on the Video Control. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table> <div class="alert"><b>Note</b> The value
    ///    ERROR_INVALID_STATE is converted to an <b>HRESULT</b> with the <b>HRESULT_FROM_WIN32</b> macro.</div> <div>
    ///    </div>
    ///    
    HRESULT get_PositionMode(PositionModeList* lPositionMode);
    ///The <b>get_Length</b> method retrieves the length of the playback source.
    ///Params:
    ///    lLength = Pointer to a variable that receives the length. The units for the returned value are determined by the
    ///              current position mode. <table> <tr> <th>Position Mode </th> <th>Returned Value </th> </tr> <tr>
    ///              <td>FrameMode</td> <td>Frame number</td> </tr> <tr> <td>TenthsSecondsMode</td> <td>Hundredths of seconds</td>
    ///              </tr> </table> To set the position mode, call IMSVidPlayback::put_PositionMode.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
    ///    width="60%"> The source does not support getting the length. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>ERROR_INVALID_STATE</b></dt> </dl> </td> <td width="60%"> The graph is not built.
    ///    Call the Build or View method on the Video Control. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table> <div
    ///    class="alert"><b>Note</b> The value ERROR_INVALID_STATE is converted to an <b>HRESULT</b> with the
    ///    <b>HRESULT_FROM_WIN32</b> macro.</div> <div> </div>
    ///    
    HRESULT get_Length(int* lLength);
}

///This topic applies to Windows XP or later. The <b>IMSVidPlaybackEvent</b> interface is used to receive events from
///playback devices, such as the file playback object and the stream buffer source object. This interface is an outgoing
///connection-point interface. To receive events from a playback device, implement this interface and then call the
///<b>IConnectionPoint::Advise</b> method to establish a connection.
@GUID("37B0353B-A4C8-11D2-B634-00C04F79498E")
interface IMSVidPlaybackEvent : IMSVidInputDeviceEvent
{
    ///This topic applies to Windows XP or later. The <b>EndOfMedia</b> method is called when playback reaches the end
    ///of the source media.
    ///Params:
    ///    lpd = Specifies a pointer to the IMSVidPlayback interface of the playback device.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT EndOfMedia(IMSVidPlayback lpd);
}

///The <b>IMSVidTuner</b> interface manages tuning devices. It is exposed by the MSVidBDATunerDevice object, which
///represents Broadcast Driver Architecture (BDA)-compliant tuning devices. Non-BDA analog tuners expose the
///IMSVidAnalogTuner interface, which inherits from this interface.
@GUID("1C15D47D-911D-11D2-B632-00C04F79498E")
interface IMSVidTuner : IMSVidVideoInputDevice
{
    ///The <b>get_Tune</b> method retrieves the current tune request.
    ///Params:
    ///    ppTR = Pointer to a variable that receives an ITuneRequest interface pointer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Tune(ITuneRequest* ppTR);
    ///The put_Tune method specifies the tune request.
    ///Params:
    ///    pTR = Specifies a pointer to the tune request's ITuneRequest interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Tune(ITuneRequest pTR);
    ///The <b>get_TuningSpace</b> method retrieves the current tuning space.
    ///Params:
    ///    plTS = Pointer to a variable that receives an ITuningSpace interface pointer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_TuningSpace(ITuningSpace* plTS);
    ///The <b>put_TuningSpace</b> method specifies the tuning space.
    ///Params:
    ///    plTS = Specifies a pointer to the tuning space's ITuningSpace interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_TuningSpace(ITuningSpace plTS);
}

///This topic applies to Windows XP or later. The <b>IMSVidTunerEvent</b> interface is used to receive events from
///BDA-compliant digital TV tuners. This interface is an outgoing connection-point interface. To receive events from a
///BDA digital tuner, implement this interface in your application. Then call the <b>IConnectionPoint::Advise</b> method
///on the MSVidBDATunerDevice object to establish a connection.
@GUID("1C15D485-911D-11D2-B632-00C04F79498E")
interface IMSVidTunerEvent : IMSVidInputDeviceEvent
{
    ///This topic applies to Windows XP or later. The <b>TuneChanged</b> method signals that the tuner has tuned to a
    ///new frequency.
    ///Params:
    ///    lpd = Pointer to the <b>MSVidTuner</b> object that fired the event.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT TuneChanged(IMSVidTuner lpd);
}

///The <b>IMSVidAnalogTuner</b> interface represents an analog-only tuner card that does not support the Broadcast
///Driver Architecture (BDA). This interface provides Automation access to the IAMTVTuner and IAMTVAudio interfaces.
@GUID("1C15D47E-911D-11D2-B632-00C04F79498E")
interface IMSVidAnalogTuner : IMSVidTuner
{
    ///The <b>get_Channel</b> method retrieves the tuner's current channel.
    ///Params:
    ///    Channel = Pointer to a variable that receives the channel.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Channel(int* Channel);
    ///The <b>put_Channel</b> method specifies the tuner's channel.
    ///Params:
    ///    Channel = Specifies the channel.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Channel(int Channel);
    ///The <b>get_VideoFrequency</b> method retrieves the tuner's video frequency for testing purposes.
    ///Params:
    ///    lcc = Pointer to a variable that receives the video frequency, in hertz (Hz).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_VideoFrequency(int* lcc);
    ///The <b>get_AudioFrequency</b> method retrieves the tuner's audio frequency.
    ///Params:
    ///    lcc = Pointer to a variable that receives the audio frequency, in hertz (Hz).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_AudioFrequency(int* lcc);
    ///The <b>get_CountryCode</b> method retrieves the tuner's country/region code.
    ///Params:
    ///    lcc = Pointer to a variable that receives the country/region code.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_CountryCode(int* lcc);
    ///The <b>put_CountryCode</b> method specifies the tuner's country/region code.
    ///Params:
    ///    lcc = Specifies the international country/region code.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_CountryCode(int lcc);
    ///The <b>get_SAP</b> method retrieves the tuner's SAP setting to enable secondary audio components. This method is
    ///currently not supported.
    ///Params:
    ///    pfSapOn = Pointer to a flag indicating whether SAP is on.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SAP(short* pfSapOn);
    ///The <b>put_SAP</b> method specifies the tuner's SAP setting to enable secondary audio components. This method is
    ///currently not supported.
    ///Params:
    ///    fSapOn = Flag indicating whether to enable or disable SAP.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_SAP(short fSapOn);
    ///The <b>ChannelAvailable</b> method queries whether a specified channel is available for viewing. This method is
    ///currently not supported.
    ///Params:
    ///    nChannel = Integer containing the channel.
    ///    SignalStrength = Pointer to a <b>long</b> value that specifies the signal strength.
    ///    fSignalPresent = Receives a <b>VARIANT_BOOL</b> that indicates whether a signal is present.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT ChannelAvailable(int nChannel, int* SignalStrength, short* fSignalPresent);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IMSVidAnalogTuner2</b> interface represents an analog-only tuner card that does not support the Broadcast Driver
///Architecture (BDA).
@GUID("37647BF7-3DDE-4CC8-A4DC-0D534D3D0037")
interface IMSVidAnalogTuner2 : IMSVidAnalogTuner
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>get_TVFormats</b> method retrieves a flag value that indicates which TV formats the tuner supports, such as
    ///NTSC, PAL, or SECAM.
    ///Params:
    ///    Formats = Pointer to a variable that receives the formats flag. Possible values are the sum of one or more of the
    ///              values in the following table. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///              <td>0x00000000</td> <td>Digital sensor</td> </tr> <tr> <td>0x00000001</td> <td>NTSC (M) standard, 7.5 IRE
    ///              black</td> </tr> <tr> <td>0x00000002</td> <td>NTSC (M) standard, 0 IRE black (Japan)</td> </tr> <tr>
    ///              <td>0x00000004</td> <td>NTSC-433</td> </tr> <tr> <td>0x00000010</td> <td>PAL-B standard</td> </tr> <tr>
    ///              <td>0x00000020</td> <td>PAL (D) standard</td> </tr> <tr> <td>0x00000080</td> <td>PAL (H) standard</td> </tr>
    ///              <tr> <td>0x00000100</td> <td>PAL (I) standard</td> </tr> <tr> <td>0x00000200</td> <td>PAL (M) standard</td>
    ///              </tr> <tr> <td>0x00000400</td> <td>PAL (N) standard</td> </tr> <tr> <td>0x00000800</td> <td>PAL-60
    ///              standard</td> </tr> <tr> <td>0x00001000</td> <td>SECAM (B) standard</td> </tr> <tr> <td>0x00002000</td>
    ///              <td>SECAM (D) standard</td> </tr> <tr> <td>0x00004000</td> <td>SECAM (G) standard</td> </tr> <tr>
    ///              <td>0x00008000</td> <td>SECAM (H) standard</td> </tr> <tr> <td>0x00010000</td> <td>SECAM (K) standard</td>
    ///              </tr> <tr> <td>0x00020000</td> <td>SECAM (K1) standard</td> </tr> <tr> <td>0x00040000</td> <td>SECAM (L)
    ///              standard</td> </tr> <tr> <td>0x00080000</td> <td>SECAM (L1) standard</td> </tr> <tr> <td>0x00100000</td>
    ///              <td>Combination (N) PAL standard (Argentina)</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_TVFormats(int* Formats);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>get_TunerModes</b> method retrieves a flag value that indicates which modes the tuner supports, such as TV or
    ///FM.
    ///Params:
    ///    Modes = Pointer to a variable that receives the modes flag. Possible values are the sum of one or more of the values
    ///            in the following table. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>0x0000</td>
    ///            <td>Default tuner mode.</td> </tr> <tr> <td>0x0001</td> <td>TV tuner mode.</td> </tr> <tr> <td>0x0002</td>
    ///            <td>FM radio tuner mode.</td> </tr> <tr> <td>0x0004</td> <td>AM radio tuner mode.</td> </tr> </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_TunerModes(int* Modes);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>get_NumAuxInputs</b> method retrieves the number of auxiliary inputs that are available. Auxiliary inputs
    ///include S-video and composite inputs.
    ///Params:
    ///    Inputs = Pointer to a variable that receives the number of auxiliary inputs.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_NumAuxInputs(int* Inputs);
}

///This topic applies to Windows XP or later. The <b>IMSVidAnalogTunerEvent</b> interface is used to receive events from
///non-BDA analong tuners. This interface is an outgoing connection-point interface. To receive events related to
///analong tuning, implement this interface in your application. Then call the <b>IConnectionPoint::Advise</b> method on
///the MSVidAnalogTunerDevice object to establish a connection.
@GUID("1C15D486-911D-11D2-B632-00C04F79498E")
interface IMSVidAnalogTunerEvent : IMSVidTunerEvent
{
}

///The <b>IMSVidFilePlayback</b> interface enables the client to specify a local file for playback. It is implemented by
///the MSVidFilePlaybackDevice object.
@GUID("37B03539-A4C8-11D2-B634-00C04F79498E")
interface IMSVidFilePlayback : IMSVidPlayback
{
    ///The <b>get_FileName</b> method retrieves the name of the file to play.
    ///Params:
    ///    FileName = Pointer to a variable that receives the file name.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_FileName(BSTR* FileName);
    ///The <b>put_FileName</b> method sets the name of the file to play.
    ///Params:
    ///    FileName = Specifies the file name.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_FileName(BSTR FileName);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 or later. The
///<b>IMSVidFilePlayback2</b> interface enables the client to specify a DirectShow source filter for playback. It is
///implemented by the MSVidFilePlaybackDevice object.
@GUID("2F7E44AF-6E52-4660-BC08-D8D542587D72")
interface IMSVidFilePlayback2 : IMSVidFilePlayback
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 or later. The
    ///<b>put__SourceFilter</b> method sets the CLSID of a DirectShow source filter to use for this source. The CLSID is
    ///specified as a string.
    ///Params:
    ///    FileName = <b>BSTR</b> that contains the CLSID of the source filter. The <b>BSTR</b> must use the following format:
    ///               <code>{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}</code>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put__SourceFilter(BSTR FileName);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 or later. The
    ///<b>put___SourceFilter</b> method sets the CLSID of a DirectShow source filter to use for this source.
    ///Params:
    ///    FileName = Specifies the CLSID of the source filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put___SourceFilter(GUID FileName);
}

///This topic applies to Windows XP or later. The <b>IMSVidFilePlaybackEvent</b> interface is used to receive events
///from the file playback object. This interface is an outgoing connection-point interface. To receive events related to
///file playback, implement this interface in your application. Then call the <b>IConnectionPoint::Advise</b> method on
///the MSVidFilePlaybackDevice object to establish a connection.
@GUID("37B0353A-A4C8-11D2-B634-00C04F79498E")
interface IMSVidFilePlaybackEvent : IMSVidPlaybackEvent
{
}

@GUID("CF45F88B-AC56-4EE2-A73A-ED04E2885D3C")
interface IMSVidWebDVD : IMSVidPlayback
{
    HRESULT OnDVDEvent(int lEvent, ptrdiff_t lParam1, ptrdiff_t lParam2);
    HRESULT PlayTitle(int lTitle);
    HRESULT PlayChapterInTitle(int lTitle, int lChapter);
    HRESULT PlayChapter(int lChapter);
    HRESULT PlayChaptersAutoStop(int lTitle, int lstrChapter, int lChapterCount);
    HRESULT PlayAtTime(BSTR strTime);
    HRESULT PlayAtTimeInTitle(int lTitle, BSTR strTime);
    HRESULT PlayPeriodInTitleAutoStop(int lTitle, BSTR strStartTime, BSTR strEndTime);
    HRESULT ReplayChapter();
    HRESULT PlayPrevChapter();
    HRESULT PlayNextChapter();
    HRESULT StillOff();
    HRESULT get_AudioLanguage(int lStream, short fFormat, BSTR* strAudioLang);
    HRESULT ShowMenu(DVDMenuIDConstants MenuID);
    HRESULT Resume();
    HRESULT ReturnFromSubmenu();
    HRESULT get_ButtonsAvailable(int* pVal);
    HRESULT get_CurrentButton(int* pVal);
    HRESULT SelectAndActivateButton(int lButton);
    HRESULT ActivateButton();
    HRESULT SelectRightButton();
    HRESULT SelectLeftButton();
    HRESULT SelectLowerButton();
    HRESULT SelectUpperButton();
    HRESULT ActivateAtPosition(int xPos, int yPos);
    HRESULT SelectAtPosition(int xPos, int yPos);
    HRESULT get_ButtonAtPosition(int xPos, int yPos, int* plButton);
    HRESULT get_NumberOfChapters(int lTitle, int* pVal);
    HRESULT get_TotalTitleTime(BSTR* pVal);
    HRESULT get_TitlesAvailable(int* pVal);
    HRESULT get_VolumesAvailable(int* pVal);
    HRESULT get_CurrentVolume(int* pVal);
    HRESULT get_CurrentDiscSide(int* pVal);
    HRESULT get_CurrentDomain(int* pVal);
    HRESULT get_CurrentChapter(int* pVal);
    HRESULT get_CurrentTitle(int* pVal);
    HRESULT get_CurrentTime(BSTR* pVal);
    HRESULT DVDTimeCode2bstr(int timeCode, BSTR* pTimeStr);
    HRESULT get_DVDDirectory(BSTR* pVal);
    HRESULT put_DVDDirectory(BSTR newVal);
    HRESULT IsSubpictureStreamEnabled(int lstream, short* fEnabled);
    HRESULT IsAudioStreamEnabled(int lstream, short* fEnabled);
    HRESULT get_CurrentSubpictureStream(int* pVal);
    HRESULT put_CurrentSubpictureStream(int newVal);
    HRESULT get_SubpictureLanguage(int lStream, BSTR* strLanguage);
    HRESULT get_CurrentAudioStream(int* pVal);
    HRESULT put_CurrentAudioStream(int newVal);
    HRESULT get_AudioStreamsAvailable(int* pVal);
    HRESULT get_AnglesAvailable(int* pVal);
    HRESULT get_CurrentAngle(int* pVal);
    HRESULT put_CurrentAngle(int newVal);
    HRESULT get_SubpictureStreamsAvailable(int* pVal);
    HRESULT get_SubpictureOn(short* pVal);
    HRESULT put_SubpictureOn(short newVal);
    HRESULT get_DVDUniqueID(BSTR* pVal);
    HRESULT AcceptParentalLevelChange(short fAccept, BSTR strUserName, BSTR strPassword);
    HRESULT NotifyParentalLevelChange(short newVal);
    HRESULT SelectParentalCountry(int lCountry, BSTR strUserName, BSTR strPassword);
    HRESULT SelectParentalLevel(int lParentalLevel, BSTR strUserName, BSTR strPassword);
    HRESULT get_TitleParentalLevels(int lTitle, int* plParentalLevels);
    HRESULT get_PlayerParentalCountry(int* plCountryCode);
    HRESULT get_PlayerParentalLevel(int* plParentalLevel);
    HRESULT Eject();
    HRESULT UOPValid(int lUOP, short* pfValid);
    HRESULT get_SPRM(int lIndex, short* psSPRM);
    HRESULT get_GPRM(int lIndex, short* psSPRM);
    HRESULT put_GPRM(int lIndex, short sValue);
    HRESULT get_DVDTextStringType(int lLangIndex, int lStringIndex, DVDTextStringType* pType);
    HRESULT get_DVDTextString(int lLangIndex, int lStringIndex, BSTR* pstrText);
    HRESULT get_DVDTextNumberOfStrings(int lLangIndex, int* plNumOfStrings);
    HRESULT get_DVDTextNumberOfLanguages(int* plNumOfLangs);
    HRESULT get_DVDTextLanguageLCID(int lLangIndex, int* lcid);
    HRESULT RegionChange();
    HRESULT get_DVDAdm(IDispatch* pVal);
    HRESULT DeleteBookmark();
    HRESULT RestoreBookmark();
    HRESULT SaveBookmark();
    HRESULT SelectDefaultAudioLanguage(int lang, int ext);
    HRESULT SelectDefaultSubpictureLanguage(int lang, DVDSPExt ext);
    HRESULT get_PreferredSubpictureStream(int* pVal);
    HRESULT get_DefaultMenuLanguage(int* lang);
    HRESULT put_DefaultMenuLanguage(int lang);
    HRESULT get_DefaultSubpictureLanguage(int* lang);
    HRESULT get_DefaultAudioLanguage(int* lang);
    HRESULT get_DefaultSubpictureLanguageExt(DVDSPExt* ext);
    HRESULT get_DefaultAudioLanguageExt(int* ext);
    HRESULT get_LanguageFromLCID(int lcid, BSTR* lang);
    HRESULT get_KaraokeAudioPresentationMode(int* pVal);
    HRESULT put_KaraokeAudioPresentationMode(int newVal);
    HRESULT get_KaraokeChannelContent(int lStream, int lChan, int* lContent);
    HRESULT get_KaraokeChannelAssignment(int lStream, int* lChannelAssignment);
    HRESULT RestorePreferredSettings();
    HRESULT get_ButtonRect(int lButton, IMSVidRect* pRect);
    HRESULT get_DVDScreenInMouseCoordinates(IMSVidRect* ppRect);
    HRESULT put_DVDScreenInMouseCoordinates(IMSVidRect pRect);
}

///Contains methods that save and load the current location and state for DVD playback.
@GUID("7027212F-EE9A-4A7C-8B67-F023714CDAFF")
interface IMSVidWebDVD2 : IMSVidWebDVD
{
    ///Saves or loads the playback position and state information for a DVD. <ul> <li>To create a DVD bookmark and save
    ///it to a buffer, call <b>get_Bookmark</b>.</li> <li>To load a bookmark from a buffer, call <b>put_Bookmark</b>.
    ///Loading the bookmark restores the DVD playback state to its original state.</li> </ul>This property is
    ///read/write.
    HRESULT get_Bookmark(char* ppData, uint* pDataLength);
    ///Saves or loads the playback position and state information for a DVD. <ul> <li>To create a DVD bookmark and save
    ///it to a buffer, call <b>get_Bookmark</b>.</li> <li>To load a bookmark from a buffer, call <b>put_Bookmark</b>.
    ///Loading the bookmark restores the DVD playback state to its original state.</li> </ul>This property is
    ///read/write.
    HRESULT put_Bookmark(ubyte* pData, uint dwDataLength);
}

@GUID("B4F7A674-9B83-49CB-A357-C63B871BE958")
interface IMSVidWebDVDEvent : IMSVidPlaybackEvent
{
    HRESULT DVDNotify(int lEventCode, VARIANT lParam1, VARIANT lParam2);
    HRESULT PlayForwards(short bEnabled);
    HRESULT PlayBackwards(short bEnabled);
    HRESULT ShowMenu(DVDMenuIDConstants MenuID, short bEnabled);
    HRESULT Resume(short bEnabled);
    HRESULT SelectOrActivateButton(short bEnabled);
    HRESULT StillOff(short bEnabled);
    HRESULT PauseOn(short bEnabled);
    HRESULT ChangeCurrentAudioStream(short bEnabled);
    HRESULT ChangeCurrentSubpictureStream(short bEnabled);
    HRESULT ChangeCurrentAngle(short bEnabled);
    HRESULT PlayAtTimeInTitle(short bEnabled);
    HRESULT PlayAtTime(short bEnabled);
    HRESULT PlayChapterInTitle(short bEnabled);
    HRESULT PlayChapter(short bEnabled);
    HRESULT ReplayChapter(short bEnabled);
    HRESULT PlayNextChapter(short bEnabled);
    HRESULT Stop(short bEnabled);
    HRESULT ReturnFromSubmenu(short bEnabled);
    HRESULT PlayTitle(short bEnabled);
    HRESULT PlayPrevChapter(short bEnabled);
    HRESULT ChangeKaraokePresMode(short bEnabled);
    HRESULT ChangeVideoPresMode(short bEnabled);
}

@GUID("B8BE681A-EB2C-47F0-B415-94D5452F0E05")
interface IMSVidWebDVDAdm : IDispatch
{
    HRESULT ChangePassword(BSTR strUserName, BSTR strOld, BSTR strNew);
    HRESULT SaveParentalLevel(int level, BSTR strUserName, BSTR strPassword);
    HRESULT SaveParentalCountry(int country, BSTR strUserName, BSTR strPassword);
    HRESULT ConfirmPassword(BSTR strUserName, BSTR strPassword, short* pVal);
    HRESULT GetParentalLevel(int* lLevel);
    HRESULT GetParentalCountry(int* lCountry);
    HRESULT get_DefaultAudioLCID(int* pVal);
    HRESULT put_DefaultAudioLCID(int newVal);
    HRESULT get_DefaultSubpictureLCID(int* pVal);
    HRESULT put_DefaultSubpictureLCID(int newVal);
    HRESULT get_DefaultMenuLCID(int* pVal);
    HRESULT put_DefaultMenuLCID(int newVal);
    HRESULT get_BookmarkOnStop(short* pVal);
    HRESULT put_BookmarkOnStop(short newVal);
}

///The <b>IMSVidOutputDevice</b> interface represents an output device. This interface derives from the IMSVidDevice
///interface but adds no methods to it. It exists to support polymorphism. Output devices include audio and video
///renderers, and the Stream Buffer Sink object. Video renderers expose the IMSVidVideoRenderer interface, and audio
///renderers exposes the IMSVidAudioRenderer interface, both of which derive from <b>IMSVidOutputDevice</b>.
@GUID("37B03546-A4C8-11D2-B634-00C04F79498E")
interface IMSVidOutputDevice : IMSVidDevice
{
}

///<div class="alert"><b>Note</b> This topic applies to Windows XP or later.</div> <div> </div> The
///<b>IMSVidOutputDeviceEvent</b> interface is the base interface for output device events.
@GUID("2E6A14E2-571C-11D3-B652-00C04F79498E")
interface IMSVidOutputDeviceEvent : IMSVidDeviceEvent
{
}

///The <b>IMSVidFeature</b> interface represents a feature that is available through the Video Control, such as data
///services or closed captioning.
@GUID("37B03547-A4C8-11D2-B634-00C04F79498E")
interface IMSVidFeature : IMSVidDevice
{
}

///<div class="alert"><b>Note</b> This topic applies to Windows XP or later. </div> <div> </div> The
///<b>IMSVidFeatureEvent</b> interface is the base interface for events from Video Control feature objects. Do not
///implement this interface directly. Other event interfaces derive from this interface.
@GUID("3DD2903C-E0AA-11D2-B63A-00C04F79498E")
interface IMSVidFeatureEvent : IMSVidDeviceEvent
{
}

///The <b>IMSVidEncoder</b> interface represents the MSVidEncoder feature object, which is required for stream buffer
///applications using the Video Control. For more information, see Using the Stream Buffer Engine with the Video
///Control.
@GUID("C0020FD4-BEE7-43D9-A495-9F213117103D")
interface IMSVidEncoder : IMSVidFeature
{
    ///The <b>get_VideoEncoderInterface</b> method retrieves a pointer to the video encoder interface.
    ///Params:
    ///    ppEncInt = Pointer to a variable that receives an <b>IUnknown</b> interface pointer. The caller can query this interface
    ///               for the IEncoderAPI interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_VideoEncoderInterface(IUnknown* ppEncInt);
    ///The <b>get_AudioEncoderInterface</b> method retrieves a pointer to the audio encoder interface.
    ///Params:
    ///    ppEncInt = Pointer to a variable that receives an <b>IUnknown</b> interface pointer. The caller can query this interface
    ///               for the IEncoderAPI interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_AudioEncoderInterface(IUnknown* ppEncInt);
}

///The <b>IMSVidClosedCaptioning</b> interface enables or disables closed captions. The MSVidClosedCaptioning feature
///exposes this interface. To obtain this interface, enumerate the collection of available features on the Video
///Control. To use closed captioning, activate the closed captioning feature before you build the graph. Once the
///feature is active, you can enable or disable the closed captioning display by calling the
///IMSVidClosedCaptioning::put_Enable method.
@GUID("99652EA1-C1F7-414F-BB7B-1C967DE75983")
interface IMSVidClosedCaptioning : IMSVidFeature
{
    ///The <b>get_Enable</b> method queries whether closed captioning is enabled.
    ///Params:
    ///    On = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///         </th> </tr> <tr> <td>VARIANT_TRUE</td> <td>Closed captioning is enabled.</td> </tr> <tr>
    ///         <td>VARIANT_FALSE</td> <td>Closed captioning is disabled.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Enable(short* On);
    ///The <b>put_Enable</b> method enables or disables closed captioning.
    ///Params:
    ///    On = Specifies whether to enable or disable the closed captioning feature. Use one of the following values.
    ///         <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>VARIANT_TRUE</td> <td>Enable closed
    ///         captioning.</td> </tr> <tr> <td>VARIANT_FALSE</td> <td>Disable closed captioning.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Enable(short On);
}

///The <b>IMSVidClosedCaptioning2</b> interface sets the closed captioning service, such as CC1 or CC2. The
///MSVidClosedCaptioning feature exposes this interface.
@GUID("E00CB864-A029-4310-9987-A873F5887D97")
interface IMSVidClosedCaptioning2 : IMSVidClosedCaptioning
{
    ///The <b>get_Service</b> method retrieves the current closed captioning service.
    ///Params:
    ///    On = Pointer to a variable that receives a member of the MSVidCCService enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_Service(MSVidCCService* On);
    ///The <b>get_Service</b> method sets the closed captioning service.
    ///Params:
    ///    On = Specifies the closed captioning service, as a member of the MSVidCCService enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT put_Service(MSVidCCService On);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
///<b>IMSVidClosedCaptioning3</b> interface retrieves the teletext filter. The MSVidClosedCaptioning feature exposes
///this interface.
@GUID("C8638E8A-7625-4C51-9366-2F40A9831FC0")
interface IMSVidClosedCaptioning3 : IMSVidClosedCaptioning2
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_TeleTextFilter</b> method retrieves the filter that handles teletext.
    ///Params:
    ///    punkTTFilter = Pointer to a variable that receives a reference to the teletext filter.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_TeleTextFilter(IUnknown* punkTTFilter);
}

///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition
///2005 or later.</div> <div> </div> The <b>IMSVidXDS</b> interface provides access to the extended data services. The
///MSVidXDS feature exposes this interface.
@GUID("11EBC158-E712-4D1F-8BB3-01ED5274C4CE")
interface IMSVidXDS : IMSVidFeature
{
    ///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center
    ///Edition 2005 or later.</div> <div> </div> The <b>get_ChannelChangeInterface</b> method retrieves a pointer to an
    ///interface that raises an event when the channel is changed.
    ///Params:
    ///    punkCC = Receives a pointer to the <b>IUnknown</b> interface. The caller must release the interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_ChannelChangeInterface(IUnknown* punkCC);
}

///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition
///2005 or later.</div> <div> </div> The <b>IMSVidXDSEvent</b> interface is used to receive events from the MSVidXDS
///object. This interface is an outgoing connection-point interface. To receive events from a playback device, implement
///this interface and then call the <b>IConnectionPoint::Advise</b> method to establish a connection.
@GUID("6DB2317D-3B23-41EC-BA4B-701F407EAF3A")
interface IMSVidXDSEvent : IMSVidFeatureEvent
{
    ///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center
    ///Edition 2005 or later.</div> <div> </div> The <b>RatingChange</b> method is called when the current rating
    ///changes.
    ///Params:
    ///    PrevRatingSystem = The previous rating system, as an EnTvRat_System enumeration type.
    ///    PrevLevel = The previous rating level, as an EnTvRat_GenericLevel enumeration type. The meaning of this value depends on
    ///                the rating system.
    ///    PrevAttributes = The previous rating attributes. This value is a bitwise OR of flags from the BfEnTvRat_GenericAttributes
    ///                     enumeration. These flags specify content attributes, such as violence or adult language. Content attributes
    ///                     do not apply to all rating systems.
    ///    NewRatingSystem = The new rating system, as an <b>EnTvRat_System</b> enumeration type.
    ///    NewLevel = The new rating level, as an <b>EnTvRat_GenericLevel</b> enumeration type.
    ///    NewAttributes = Specifies the new rating attributes. This value is a bitwise OR of flags from the
    ///                    <b>BfEnTvRat_GenericAttributes</b> enumeration.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT RatingChange(EnTvRat_System PrevRatingSystem, EnTvRat_GenericLevel PrevLevel, 
                         BfEnTvRat_GenericAttributes PrevAttributes, EnTvRat_System NewRatingSystem, 
                         EnTvRat_GenericLevel NewLevel, BfEnTvRat_GenericAttributes NewAttributes);
}

///The <b>IMSVidDataServices</b> interface represents the data services feature. The MSVidDataServices feature object
///exposes this interface.
@GUID("334125C1-77E5-11D3-B653-00C04F79498E")
interface IMSVidDataServices : IMSVidFeature
{
}

@GUID("334125C2-77E5-11D3-B653-00C04F79498E")
interface IMSVidDataServicesEvent : IMSVidDeviceEvent
{
}

///The <b>IMSVidVideoRenderer</b> interface represents a video renderer device. The MSVidVideoRenderer object exposes
///this interface. This interface provides access to the Video Mixing Renderer (VMR) filter.
@GUID("37B03540-A4C8-11D2-B634-00C04F79498E")
interface IMSVidVideoRenderer : IMSVidOutputDevice
{
    ///The <b>get_CustomCompositorClass</b> method retrieves the class identifier (CLSID) of the Video Mixing Renderer's
    ///current image compositor, as a <b>BSTR</b>.
    ///Params:
    ///    CompositorCLSID = Receives a string representation of the CLSID.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_CustomCompositorClass(BSTR* CompositorCLSID);
    ///The <b>put_CustomCompositorClass</b> method specifies the class identifier (CLSID) of a custom image compositor,
    ///as a <b>BSTR</b>.
    ///Params:
    ///    CompositorCLSID = Specifies the CLSID as a string.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_CustomCompositorClass(BSTR CompositorCLSID);
    ///The <b>get__CustomCompositorClass</b> method retrieves the class identifier (CLSID) of the Video Mixing
    ///Renderer's current image compositor, as a <b>GUID</b>.
    ///Params:
    ///    CompositorCLSID = Receives the CLSID.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get__CustomCompositorClass(GUID* CompositorCLSID);
    ///The <b>put__CustomCompositorClass</b> method specifies the class identifier (CLSID) of a custom image compositor,
    ///as a <b>GUID</b>.
    ///Params:
    ///    CompositorCLSID = Specifies the CLSID of the custom compositor.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put__CustomCompositorClass(const(GUID)* CompositorCLSID);
    ///The <b>get__CustomCompositor</b> method retrieves the Video Mixing Renderer's current image compositor.
    ///Params:
    ///    Compositor = Receives an IVMRImageCompositor interface pointer .
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get__CustomCompositor(IVMRImageCompositor* Compositor);
    ///The <b>put__CustomCompositor</b> method specifies a custom image compositor for the Video Mixing Renderer (VMR)
    ///to use.
    ///Params:
    ///    Compositor = Pointer to the IVMRImageCompositor interface of the image compositor.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put__CustomCompositor(IVMRImageCompositor Compositor);
    ///The <b>get_MixerBitmap</b> method retrieves the static bitmap image, as an <b>IPictureDisp</b> type.
    ///Params:
    ///    MixerPictureDisp = Receives an <b>IPictureDisp</b> interface pointer. The caller must release the interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_NOTINITIALIZED</b></dt> </dl> </td> <td
    ///    width="60%"> No bitmap was set. </td> </tr> </table>
    ///    
    HRESULT get_MixerBitmap(IPictureDisp* MixerPictureDisp);
    ///The <b>get__MixerBitmap</b> method retrieves the Video Mixing Renderer's IVMRMixerBitmap interface, which
    ///controls how the VMR mixes a static bitmap.
    ///Params:
    ///    MixerPicture = Receives an IVMRMixerBitmap interface pointer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get__MixerBitmap(IVMRMixerBitmap* MixerPicture);
    ///The <b>put_MixerBitmap</b> method specifies the static bitmap image, as an <b>IPictureDisp</b> type.
    ///Params:
    ///    MixerPictureDisp = Specifies a pointer to the <b>IPictureDisp</b> interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_MixerBitmap(IPictureDisp MixerPictureDisp);
    ///The <b>put__MixerBitmap</b> method specifies the static bitmap image.
    ///Params:
    ///    MixerPicture = A pointer to a VMRALPHABITMAP structure that contains information about the bitmap.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put__MixerBitmap(VMRALPHABITMAP* MixerPicture);
    ///The <b>get_MixerBitmapPositionRect</b> method retrieves the position of the static bitmap image, relative to the
    ///video window.
    ///Params:
    ///    rDest = Receives an IMSVidRect interface pointer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_MixerBitmapPositionRect(IMSVidRect* rDest);
    ///The <b>put_MixerBitmapPositionRect</b> method specifies the position of the static bitmap image, relative to the
    ///video window.
    ///Params:
    ///    rDest = Pointer to an IMSVidRect interface, specifying the rectangle.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_MixerBitmapPositionRect(IMSVidRect rDest);
    ///The <b>get_MixerBitmapOpacity</b> method retrieves the opacity of the static bitmap image.
    ///Params:
    ///    opacity = Receives the opacity, expressed as an integer from 0 (transparent) to 100 (opaque).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_MixerBitmapOpacity(int* opacity);
    ///The <b>put_MixerBitmapOpacity</b> method specifies the opacity of the static bitmap image.
    ///Params:
    ///    opacity = Specifies the opacity as an integer from 0 (transparent) to 100 (opaque).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_MixerBitmapOpacity(int opacity);
    ///The <b>SetupMixerBitmap</b> method configures the Video Mixing Renderer (VMR) to display an alpha-blended bitmap
    ///on top of the video.
    ///Params:
    ///    MixerPictureDisp = Pointer to an <b>IPictureDisp</b> interface that specifies the bitmap.
    ///    Opacity = Specifies the opacity of the bitmap, as an integer from 0 (transparent) to 100 (opaque).
    ///    rDest = Pointer to an IMSVidRect interface that specifies the position of the bitmap, relative to the video window.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT SetupMixerBitmap(IPictureDisp MixerPictureDisp, int Opacity, IMSVidRect rDest);
    ///The <b>get_SourceSize</b> method retrieves the type of clipping to apply to the video rectangle, if any.
    ///Params:
    ///    CurrentSize = Receives a member of the SourceSizeList enumeration.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SourceSize(SourceSizeList* CurrentSize);
    ///The <b>put_SourceSize</b> method specifies the type of clipping to apply to the video rectangle, if any.
    ///Params:
    ///    NewSize = Specifies a member of the SourceSizeList enumeration.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_SourceSize(SourceSizeList NewSize);
    ///The <b>get_OverScan</b> method retrieves the amount of clipping to perform on all sides of the video frame, in
    ///order to cut off random video noise.
    ///Params:
    ///    plPercent = Receives the amount to clip, in hundredths of a percent.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_OverScan(int* plPercent);
    ///The <b>put_OverScan</b> method specifies the amount of clipping to perform on all sides of the video frame to cut
    ///off random video noise.
    ///Params:
    ///    lPercent = Specifies the amount to clip, in hundredths of a percent. For example, 175 indicates 1.75%.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_OverScan(int lPercent);
    ///The <b>get_AvailableSourceRect</b> method retrieves the size of the native video.
    ///Params:
    ///    pRect = Receives an IMSVidRect interface pointer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_AvailableSourceRect(IMSVidRect* pRect);
    ///The <b>get_MaxVidRect</b> method retrieves the maximum ideal size of the video rectangle.
    ///Params:
    ///    ppVidRect = Receives an IMSVidRect interface pointer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_MaxVidRect(IMSVidRect* ppVidRect);
    ///The <b>get_MinVidRect</b> method retrieves the minimum ideal size of the video rectangle.
    ///Params:
    ///    ppVidRect = Receives an IMSVidRect interface pointer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_MinVidRect(IMSVidRect* ppVidRect);
    ///The <b>get_ClippedSourceRect</b> method retrieves the clipping rectangle on the video source.
    ///Params:
    ///    pRect = Receives an IMSVidRect interface pointer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_ClippedSourceRect(IMSVidRect* pRect);
    ///The <b>put_ClippedSourceRect</b> method specifies the clipping rectangle on the video source.
    ///Params:
    ///    pRect = Pointer to an IMSVidRect interface that specifies the rectangle.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_ClippedSourceRect(IMSVidRect pRect);
    ///The <b>get_UsingOverlay</b> method queries whether the Video Mixing Renderer (VMR) is using the hardware overlay.
    ///Params:
    ///    UseOverlayVal = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                    <td>VARIANT_TRUE</td> <td>The VMR is using the hardware overlay.</td> </tr> <tr> <td>VARIANT_FALSE</td>
    ///                    <td>The VMR is not using the hardware overlay.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_UsingOverlay(short* UseOverlayVal);
    ///The <b>put_UsingOverlay</b> method specifies whether the Video Mixing Renderer will use the hardware overlay.
    ///Params:
    ///    UseOverlayVal = Flag that specifies whether to use the hardware overlay. Use one of the following values. <table> <tr>
    ///                    <th>Value </th> <th>Description </th> </tr> <tr> <td>VARIANT_TRUE</td> <td>Use the hardware overlay.</td>
    ///                    </tr> <tr> <td>VARIANT_FALSE</td> <td>Do not use the hardware overlay.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_UsingOverlay(short UseOverlayVal);
    ///The <b>Capture</b> method captures the video frame that is currently being rendered by the Video Mixing Renderer
    ///(VMR).
    ///Params:
    ///    currentImage = Receives an <b>IPictureDisp</b> interface pointer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT Capture(IPictureDisp* currentImage);
    ///The <b>get_FramesPerSecond</b> method retrieves the current frame rate.
    ///Params:
    ///    pVal = Receives the frame rate, in frames per second.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_FramesPerSecond(int* pVal);
    ///The <b>get_DecimateInput</b> method queries whether the Video Mixing Renderer (VMR) is currently configured to
    ///decimate the video (that is, reduce the native video size) before processing it. This method is currently not
    ///supported.
    ///Params:
    ///    pDeci = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>VARIANT_TRUE</td> <td>The VMR is configured to decimate the video.</td> </tr> <tr> <td>VARIANT_FALSE</td>
    ///            <td>The VMR is not configured to decimate the video.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_DecimateInput(short* pDeci);
    ///The <b>put_DecimateInput</b> method specifies whether the Video Mixing Renderer (VMR) will decimate the video
    ///(that is, reduce the native video size) before processing it. This method is currently not supported.
    ///Params:
    ///    pDeci = Specifies whether to enable or disable video decimation. Use one of the following values. <table> <tr>
    ///            <th>Value </th> <th>Description </th> </tr> <tr> <td>VARIANT_TRUE</td> <td>Enable video decimation.</td>
    ///            </tr> <tr> <td>VARIANT_FALSE</td> <td>Disable video decimation.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_DecimateInput(short pDeci);
}

///This topic applies to Windows XP or later. The <b>IMSVidVideoRendererEvent</b> interface is used to receive events
///from the video renderer. This interface is an outgoing connection-point interface. To receive events from a playback
///device, implement this interface in your application. Then call the <b>IConnectionPoint::Advise</b> method on the
///MSVidVideoRenderer object to establish a connection.
@GUID("37B03545-A4C8-11D2-B634-00C04F79498E")
interface IMSVidVideoRendererEvent : IMSVidOutputDeviceEvent
{
    ///This topic applies to Windows XP or later. The <b>OverlayUnavailable</b> method is called when the overlay
    ///surface on the graphics card is not available.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OverlayUnavailable();
}

///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition
///2005 or later. </div> <div> </div> The <b>IMSVidGenericSink</b> interface represents a generic output device that
///supports streaming output. It is implemented by the MSVidGenericSink object.
@GUID("6C29B41D-455B-4C33-963A-0D28E5E555EA")
interface IMSVidGenericSink : IMSVidOutputDevice
{
    ///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center
    ///Edition 2005 or later. </div> <div> </div> The <b>SetSinkFilter</b> method sets the filter for the sink.
    ///Params:
    ///    bstrName = <b>BSTR</b> that contains the CLSID of the sink filter. The <b>BSTR</b> must use the following format:
    ///               <code>{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}</code>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT SetSinkFilter(BSTR bstrName);
    ///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center
    ///Edition 2005 or later. </div> <div> </div> The <b>get_SinkStreams</b> method retrieves the streams that are
    ///required to be rendered down to the sink. Not implemented.
    ///Params:
    ///    pStreams = Reserved.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT get_SinkStreams(MSVidSinkStreams* pStreams);
    ///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center
    ///Edition 2005 or later. </div> <div> </div> The <b>put_SinkStreams</b> method sets the streams that are required
    ///to be rendered down to the sink. Not implemented.
    ///Params:
    ///    Streams = Reserved.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT put_SinkStreams(MSVidSinkStreams Streams);
}

///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition
///2005 or later.</div> <div> </div> The <b>IMSVidGenericSink2</b> interface represents a generic output device that
///supports streaming output. It is implemented by the MSVidGenericSink object.
@GUID("6B5A28F3-47F1-4092-B168-60CABEC08F1C")
interface IMSVidGenericSink2 : IMSVidGenericSink
{
    ///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center
    ///Edition 2005 or later.</div> <div> </div> The <b>AddFilter</b> method specifies a DirectShow filter that is added
    ///to the graph when this segment is built.
    ///Params:
    ///    bstrName = <b>BSTR</b> that contains the CLSID of the filter. The <b>BSTR</b> must use the following format:
    ///               <code>{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}</code>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddFilter(BSTR bstrName);
    ///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center
    ///Edition 2005 or later.</div> <div> </div> The <b>ResetFilterList</b> method clears the list of filters that were
    ///added using IMSVidGenericSink2::AddFilter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ResetFilterList();
}

///The <b>IMSVidStreamBufferRecordingControl</b> interface enables an application to manage a stream buffer recording
///object through the Video Control. To obtain this interface, call one of the following methods: <ul> <li>
///IMSVidStreamBufferSink::get_ContentRecorder </li> <li> IMSVidStreamBufferSink::get_ReferenceRecorder </li> </ul>
@GUID("160621AA-BBBC-4326-A824-C395AEBC6E74")
interface IMSVidStreamBufferRecordingControl : IDispatch
{
    ///The <b>get_StartTime</b> method retrieves the start time of the recording.
    ///Params:
    ///    rtStart = Pointer to a variable that receives the start time, in hundredths of seconds.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_StartTime(int* rtStart);
    ///The <b>put_StartTime</b> method sets the start time for the recording.
    ///Params:
    ///    rtStart = Specifies the start time, in hundredths of seconds.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_StartTime(int rtStart);
    ///The <b>get_StopTime</b> method retrieves the stop time of the recording.
    ///Params:
    ///    rtStop = Pointer to a variable that receives the stop time, in hundredths of seconds.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_StopTime(int* rtStop);
    ///The <b>put_StopTime</b> method sets the stop time for the recording.
    ///Params:
    ///    rtStop = Specifies the stop time, in hundredths of seconds.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_StopTime(int rtStop);
    ///The <b>get_RecordingStopped</b> method queries whether the recording has stopped.
    ///Params:
    ///    phResult = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///               </th> </tr> <tr> <td>VARIANT_FALSE</td> <td>The recording has not stopped.</td> </tr> <tr>
    ///               <td>VARIANT_TRUE</td> <td>The recording has stopped.</td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_RecordingStopped(short* phResult);
    ///The <b>get_RecordingStarted</b> method queries whether the recording has started.
    ///Params:
    ///    phResult = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///               </th> </tr> <tr> <td>VARIANT_FALSE</td> <td>The recording has not started.</td> </tr> <tr>
    ///               <td>VARIANT_TRUE</td> <td>The recording has started.</td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_RecordingStarted(short* phResult);
    ///The <b>get_RecordingType</b> method retrieves the type of recording, either content recording or reference
    ///recording.
    ///Params:
    ///    dwType = Pointer to a variable that receives one of the following values. <table> <tr> <th>Value </th> <th>Description
    ///             </th> </tr> <tr> <td>CONTENT</td> <td>Content recording</td> </tr> <tr> <td>REFERENCE</td> <td>Reference
    ///             recording</td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_RecordingType(RecordingType* dwType);
    ///The <b>get_RecordingAttribute</b> method retrieves the stream buffer Recording object that is controlled by this
    ///interface.
    ///Params:
    ///    pRecordingAttribute = Address of a variable that receives a pointer to the Recording object's <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_RecordingAttribute(IUnknown* pRecordingAttribute);
}

///The <b>IMSVidStreamBufferSink</b> interface represents the Stream Buffer Sink filter within the Video Control.
@GUID("159DBB45-CD1B-4DAB-83EA-5CB1F4F21D07")
interface IMSVidStreamBufferSink : IMSVidOutputDevice
{
    ///The <b>get_ContentRecorder</b> method creates a new content recording object.
    ///Params:
    ///    pszFilename = Specifies the name of the file to hold the recording.
    ///    pRecordingIUnknown = Receives a pointer to the recording object's IMSVidStreamBufferRecordingControl interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_ContentRecorder(BSTR pszFilename, IMSVidStreamBufferRecordingControl* pRecordingIUnknown);
    ///The <b>get_ReferenceRecorder</b> method creates a new reference recording object.
    ///Params:
    ///    pszFilename = Specifies the name of the file to hold the recording.
    ///    pRecordingIUnknown = Receives a pointer to the recording object's IMSVidStreamBufferRecordingControl interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_ReferenceRecorder(BSTR pszFilename, IMSVidStreamBufferRecordingControl* pRecordingIUnknown);
    ///The <b>get_SinkName</b> method retrieves the name of the stub file that points to the backing files.
    ///Params:
    ///    pName = Pointer to a variable that receives the file name.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_SinkName(BSTR* pName);
    ///The <b>put_SinkName</b> method sets the name of the stub file that points to the backing files.
    ///Params:
    ///    Name = Specifies the file name.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_SinkName(BSTR Name);
    ///The <b>NameSetLock</b> method locks the stream buffer profile.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT NameSetLock();
    ///The <b>get_SBESink</b> method retrieves a pointer to the Stream Buffer Sink filter.
    ///Params:
    ///    sbeConfig = Receives a pointer to the filter's <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_SBESink(IUnknown* sbeConfig);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
///<b>IMSVidStreamBufferSink2</b> interface represents the Stream Buffer Sink filter within the Video Control.
@GUID("2CA9FC63-C131-4E5A-955A-544A47C67146")
interface IMSVidStreamBufferSink2 : IMSVidStreamBufferSink
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>UnlockProfile</b> method unlocks the stream profile.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT UnlockProfile();
}

///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition
///2005 and later. </div> <div> </div> The <b>IMSVidStreamBufferSink3</b> interface represents the Stream Buffer Sink
///filter within the Video Control.
@GUID("4F8721D7-7D59-4D8B-99F5-A77775586BD5")
interface IMSVidStreamBufferSink3 : IMSVidStreamBufferSink2
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>SetMinSeek</b>
    ///method sets the minimum seek position equal to the current playback position, and retrieves the current position.
    ///Params:
    ///    pdwMin = Receives the current position, in hundredths of seconds.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetMinSeek(int* pdwMin);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_AudioCounter</b> method enables the caller to get performance statistics from the Stream Buffer Sink for
    ///the audio stream.
    ///Params:
    ///    ppUnk = Receives a pointer to the <b>IUnknown</b> interface. Query this pointer for the IStreamBufferDataCounters
    ///            interface. The caller must release the <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_AudioCounter(IUnknown* ppUnk);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_VideoCounter</b> method enables the caller to get performance statistics from the Stream Buffer Sink for
    ///the video stream.
    ///Params:
    ///    ppUnk = Receives a pointer to the <b>IUnknown</b> interface. Query this pointer for the IStreamBufferDataCounters
    ///            interface. The caller must release the <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_VideoCounter(IUnknown* ppUnk);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_CCCounter</b> method enables the caller to get performance statistics from the Stream Buffer Sink for the
    ///closed captioning stream.
    ///Params:
    ///    ppUnk = Receives a pointer to the <b>IUnknown</b> interface. Query this pointer for the IStreamBufferDataCounters
    ///            interface. The caller must release the <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_CCCounter(IUnknown* ppUnk);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_WSTCounter</b> method enables the caller to get performance statistics from the Stream Buffer Sink for the
    ///World Standard Teletext (WST) stream.
    ///Params:
    ///    ppUnk = Receives a pointer to the <b>IUnknown</b> interface. Query this pointer for the IStreamBufferDataCounters
    ///            interface. The caller must release the <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_WSTCounter(IUnknown* ppUnk);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. Not implemented in this
    ///release.
    ///Params:
    ///    szCLSID = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_AudioAnalysisFilter(BSTR szCLSID);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. Not implemented in this
    ///release.
    ///Params:
    ///    pszCLSID = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_AudioAnalysisFilter(BSTR* pszCLSID);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. Not implemented in this
    ///release.
    ///Params:
    ///    guid = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put__AudioAnalysisFilter(GUID guid);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. Not implemented in this
    ///release.
    ///Params:
    ///    pGuid = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get__AudioAnalysisFilter(GUID* pGuid);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. Not implemented in this
    ///release.
    ///Params:
    ///    szCLSID = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_VideoAnalysisFilter(BSTR szCLSID);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. Not implemented in this
    ///release.
    ///Params:
    ///    pszCLSID = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_VideoAnalysisFilter(BSTR* pszCLSID);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. Not implemented in this
    ///release.
    ///Params:
    ///    guid = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put__VideoAnalysisFilter(GUID guid);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. Not implemented in this
    ///release.
    ///Params:
    ///    pGuid = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get__VideoAnalysisFilter(GUID* pGuid);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. Not implemented in this
    ///release.
    ///Params:
    ///    szCLSID = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_DataAnalysisFilter(BSTR szCLSID);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. Not implemented in this
    ///release.
    ///Params:
    ///    pszCLSID = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_DataAnalysisFilter(BSTR* pszCLSID);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. Not implemented in this
    ///release.
    ///Params:
    ///    guid = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put__DataAnalysisFilter(GUID guid);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. Not implemented in this
    ///release.
    ///Params:
    ///    pGuid = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get__DataAnalysisFilter(GUID* pGuid);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_LicenseErrorCode</b> method returns the most recent error code relating to licenses.
    ///Params:
    ///    hres = Receives an <b>HRESULT</b> value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_LicenseErrorCode(int* hres);
}

///This topic applies to Windows XP Service Pack 1 or later. The <b>IMSVidStreamBufferSinkEvent</b> interface is used to
///receive events from the MSVidStreamBufferSink object. This interface is an outgoing connection-point interface. To
///receive events from a playback device, implement this interface and then call the <b>IConnectionPoint::Advise</b>
///method to establish a connection.
@GUID("F798A36B-B05B-4BBE-9703-EAEA7D61CD51")
interface IMSVidStreamBufferSinkEvent : IMSVidOutputDeviceEvent
{
    ///This topic applies to Windows XP Service Pack 1 or later. The <b>CertificateFailure</b> method is called when the
    ///object fails to get an encryption/decryption license.
    ///Returns:
    ///    Returns S_OK or an error code.
    ///    
    HRESULT CertificateFailure();
    ///This topic applies to Windows XP Service Pack 1 or later. The <b>CertificateSuccess</b> method is called when the
    ///object succeeds in getting an encryption/decryption license. The method is called only if an earlier failure
    ///occurred.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT CertificateSuccess();
    ///This topic applies to Windows XP Service Pack 1 or later. The <b>WriteFailure</b> method is called when a write
    ///error occurs in the Stream Buffer Sink filter.
    ///Returns:
    ///    Returns S_OK or an error code.
    ///    
    HRESULT WriteFailure();
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
///<b>IMSVidStreamBufferSinkEvent2</b> interface is used to receive events from the MSVidStreamBufferSink object.
@GUID("3D7A5166-72D7-484B-A06F-286187B80CA1")
interface IMSVidStreamBufferSinkEvent2 : IMSVidStreamBufferSinkEvent
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>EncryptionOn</b>
    ///method is called when the stream changes from not encrypted to encrypted.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT EncryptionOn();
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>EncryptionOff</b> method is called when the stream changes from encrypted to not encrypted.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT EncryptionOff();
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
///<b>IMSVidStreamBufferSinkEvent3</b> interface is used to receive events from the MSVidStreamBufferSink object. This
///interface is an outgoing connection-point interface. To receive events from a playback device, implement this
///interface and then call the <b>IConnectionPoint::Advise</b> method to establish a connection.
@GUID("735AD8D5-C259-48E9-81E7-D27953665B23")
interface IMSVidStreamBufferSinkEvent3 : IMSVidStreamBufferSinkEvent2
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>LicenseChange</b> method is called when the license for the content changes.
    ///Params:
    ///    dwProt = Specifies the new license as a member of the ProtType enumeration.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT LicenseChange(int dwProt);
}

///The IMSVidStreamBufferSinkEvent4 interface receives events from the MSVidStreamBufferSink object. This interface is
///an outgoing connection-point interface. To receive events from a playback device, implement this interface and then
///call the <b>IConnectionPoint::Advise</b> method to establish a connection.
@GUID("1B01DCB0-DAF0-412C-A5D1-590C7F62E2B8")
interface IMSVidStreamBufferSinkEvent4 : IMSVidStreamBufferSinkEvent3
{
    ///The <b>WriteFailureClear</b> method is called when a write error from the Stream Buffer Sink filter has been
    ///cleared.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT WriteFailureClear();
}

///The <b>IMSVidStreamBufferSource</b> interface represents the Stream Buffer Source filter within the Video Control.
@GUID("EB0C8CF9-6950-4772-87B1-47D11CF3A02F")
interface IMSVidStreamBufferSource : IMSVidFilePlayback
{
    ///The <b>get_Start</b> method retrieves the start time.
    ///Params:
    ///    lStart = Pointer to a variable that receives the start time, in hundredths of seconds.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_Start(int* lStart);
    ///The <b>get_RecordingAttribute</b> method retrieves the Stream Buffer Source filter that this object manages.
    ///Params:
    ///    pRecordingAttribute = Receives a pointer to the filter's <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_RecordingAttribute(IUnknown* pRecordingAttribute);
    ///The <b>CurrentRatings</b> method retrieves the current ratings information from the data source.
    ///Params:
    ///    pEnSystem = Pointer to a variable that receives the rating system, as an EnTvRat_System enumeration value.
    ///    pEnRating = Receives the rating level, as an EnTvRat_GenericLevel enumeration value.
    ///    pBfEnAttr = Pointer to a variable that receives the ratings attributes, as a bitwise combination of zero or more flags
    ///                from the BfEnTvRat_GenericAttributes enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CurrentRatings(EnTvRat_System* pEnSystem, EnTvRat_GenericLevel* pEnRating, int* pBfEnAttr);
    ///The <b>MaxRatingsLevel</b> method specifies the maximum ratings level the object is permitted to play.
    ///Params:
    ///    enSystem = Specifies the rating system, as an EnTvRat_System enumeration value.
    ///    enRating = Specifies the maximum rating level, as an EnTvRat_GenericLevel enumeration value.
    ///    lbfEnAttr = Specifies zero or more ratings attributes, as a bitwise combination of flags from the
    ///                BfEnTvRat_GenericAttributes enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT MaxRatingsLevel(EnTvRat_System enSystem, EnTvRat_GenericLevel enRating, int lbfEnAttr);
    ///The <b>put_BlockUnrated</b> method specifies whether to block unrated content.
    ///Params:
    ///    bBlock = Specifies one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///             <td>VARIANT_FALSE</td> <td>Do not block unrated content.</td> </tr> <tr> <td>VARIANT_TRUE</td> <td>Block
    ///             unrated content.</td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_BlockUnrated(short bBlock);
    ///The <b>put_UnratedDelay</b> method specifies how long the Video Control will play unrated content before blocking
    ///it. The value is ignored until the put_BlockUnrated method is called with the value VARIANT_TRUE.
    ///Params:
    ///    dwDelay = Specifies the delay before blocking unrated content, in milliseconds.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_UnratedDelay(int dwDelay);
    ///The <b>get_SBESource</b> method retrieves a pointer to the Stream Buffer Source filter.
    ///Params:
    ///    sbeFilter = Receives a pointer to the filter's <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_SBESource(IUnknown* sbeFilter);
}

///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition
///2005 and later.</div> <div> </div> The <b>IMSVidStreamBufferSource2</b> interface represents the Stream Buffer Source
///filter within the Video Control.
@GUID("E4BA9059-B1CE-40D8-B9A0-D4EA4A9989D3")
interface IMSVidStreamBufferSource2 : IMSVidStreamBufferSource
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>put_RateEx</b>
    ///method sets the playback rate, and sets the frame rate for fast-forward play ("trick mode").
    ///Params:
    ///    dwRate = Playback rate. The valid range is (<i>dRate</i> &gt;= 0.1 || <i>dRate</i> &lt;= –0.1).
    ///    dwFramesPerSecond = Frames per second for fast-forward play. For more information, see IStreamBufferMediaSeeking2::SetRateEx.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_RateEx(double dwRate, uint dwFramesPerSecond);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_AudioCounter</b> method enables the caller to get performance statistics from the Stream Buffer Source for
    ///the audio stream.
    ///Params:
    ///    ppUnk = Receives a pointer to the <b>IUnknown</b> interface. Query this pointer for the IStreamBufferDataCounters
    ///            interface. The caller must release the <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_AudioCounter(IUnknown* ppUnk);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_VideoCounter</b> method enables the caller to get performance statistics from the Stream Buffer Source for
    ///the video stream.
    ///Params:
    ///    ppUnk = Receives a pointer to the <b>IUnknown</b> interface. Query this pointer for the IStreamBufferDataCounters
    ///            interface. The caller must release the <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_VideoCounter(IUnknown* ppUnk);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_CCCounter</b> method enables the caller to get performance statistics from the Stream Buffer Source for
    ///the closed captioning stream.
    ///Params:
    ///    ppUnk = Receives a pointer to the <b>IUnknown</b> interface. Query this pointer for the IStreamBufferDataCounters
    ///            interface. The caller must release the <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_CCCounter(IUnknown* ppUnk);
    ///The <b>get_WSTCounter</b> method enables the caller to get performance statistics from the Stream Buffer Source
    ///for the World Standard Teletext (WST) stream.
    ///Params:
    ///    ppUnk = Receives a pointer to the <b>IUnknown</b> interface. Query this pointer for the IStreamBufferDataCounters
    ///            interface. The caller must release the <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_WSTCounter(IUnknown* ppUnk);
}

///This topic applies to Windows XP Service Pack 1 or later. The <b>IMSVidStreamBufferSourceEvent</b> interface is used
///to receive events from the MSVidStreamBufferSource object. This interface is an outgoing connection-point interface.
///To receive events from a playback device, implement this interface and then call the <b>IConnectionPoint::Advise</b>
///method to establish a connection.
@GUID("50CE8A7D-9C28-4DA8-9042-CDFA7116F979")
interface IMSVidStreamBufferSourceEvent : IMSVidFilePlaybackEvent
{
    ///This topic applies to Windows XP Service Pack 1 or later. The <b>CertificateFailure</b> method is called when the
    ///object fails to get an encryption/decryption license.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT CertificateFailure();
    ///This topic applies to Windows XP Service Pack 1 or later. The <b>CertificateSuccess</b> method is called when the
    ///object succeeds in getting an encryption/decryption license. The method is called only if an earlier failure
    ///occurred.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT CertificateSuccess();
    ///This topic applies to Windows XP Service Pack 1 or later. The <b>RatingsBlocked</b> method is called when the
    ///object blocks the stream, which occurs if the rating is not allowed under the current permissions.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT RatingsBlocked();
    ///This topic applies to Windows XP Service Pack 1 or later. The <b>RatingsUnblocked</b> method is called when the
    ///object unblocks the stream. This event occurs only if a stream that was previously blocked is unblocked.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT RatingsUnblocked();
    ///This topic applies to Windows XP Service Pack 1 or later. The <b>RatingsChanged</b> method is called when the
    ///rating changes.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT RatingsChanged();
    ///This topic applies to Windows XP Service Pack 1 or later. The <b>TimeHole</b> method is called when playback
    ///reaches a gap in the recorded content.
    ///Params:
    ///    StreamOffsetMS = Specifies the start of the gap, in milliseconds, relative to the content start.
    ///    SizeMS = Specifies the length of the gap, in milliseconds.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT TimeHole(int StreamOffsetMS, int SizeMS);
    ///This topic applies to Windows XP Service Pack 1 or later. The <b>TimeHole</b> method is called when the
    ///<b>MSVidStreamBufferSource</b> object reads from a temporary recording file that has been marked for deletion.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT StaleDataRead();
    ///This topic applies to Windows XP Service Pack 1 or later. The <b>CertificateSuccess</b> method is called when the
    ///stream buffer source lags behind the stream buffer sink by more than a preset number of files.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT ContentBecomingStale();
    ///This topic applies to Windows XP Service Pack 1 or later. The <b>StaleFileDeleted</b> method is called when a
    ///temporary recording file is deleted.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT StaleFileDeleted();
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
///<b>IMSVidStreamBufferSourceEvent2</b> interface is used to receive events from the MSVidStreamBufferSource object.
@GUID("7AEF50CE-8E22-4BA8-BC06-A92A458B4EF2")
interface IMSVidStreamBufferSourceEvent2 : IMSVidStreamBufferSourceEvent
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>RateChange</b>
    ///method is called when the playback rate changes.
    ///Params:
    ///    qwNewRate = Specifies the new playback rate.
    ///    qwOldRate = Specifies the previous playback rate.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT RateChange(double qwNewRate, double qwOldRate);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
///<b>IMSVidStreamBufferSourceEvent3</b> interface is used to receive events from the MSVidStreamBufferSource object.
///This interface is an outgoing connection-point interface. To receive events from a playback device, implement this
///interface and then call the <b>IConnectionPoint::Advise</b> method to establish a connection.
@GUID("CEABD6AB-9B90-4570-ADF1-3CE76E00A763")
interface IMSVidStreamBufferSourceEvent3 : IMSVidStreamBufferSourceEvent2
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>BroadcastEvent</b> method is called when the MSVidStreamBufferSource object receives a broadcast event through
    ///the IBroadcastEvent interface.
    ///Params:
    ///    Guid = GUID that specifies the event. For more information, see IBroadcastEvent::Fire.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT BroadcastEvent(BSTR Guid);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>BroadcastEventEx</b> method is called when the MSVidStreamBufferSource object receives a broadcast event
    ///through the IBroadcastEventEx interface.
    ///Params:
    ///    Guid = GUID that specifies the event.
    ///    Param1 = First implementation-dependent parameter.
    ///    Param2 = Second implementation-dependent parameter.
    ///    Param3 = Third implementation-dependent parameter.
    ///    Param4 = Fourth implementation-dependent parameter.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT BroadcastEventEx(BSTR Guid, uint Param1, uint Param2, uint Param3, uint Param4);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>COPPBlocked</b>
    ///method is called when the content is blocked because of the Certified Output Protection Protocol (COPP) status.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT COPPBlocked();
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>COPPUnblocked</b> method is called when the content is unblocked after a <b>COPPBlocked</b> event.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT COPPUnblocked();
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>ContentPrimarilyAudio</b> method is called when the Stream Buffer Engine is processing primarily audio data.
    ///Returns:
    ///    Return S_OK or an error code.
    ///    
    HRESULT ContentPrimarilyAudio();
}

///Implements an event system for the Stream Buffer Engine, version 2 (SBE2) source filter that is wrapped in the Video
///Control. Each event corresponds to an event that the SBE2 source filter receives inside a DirectShow graph.
@GUID("49C771F9-41B2-4CF7-9F9A-A313A8F6027E")
interface IMSVidStreamBufferV2SourceEvent : IMSVidFilePlaybackEvent
{
    ///Fired when the SBE2 source filter receives a STREAMBUFFER_EC_RATE_CHANGED event, which indicates the playback
    ///rate has changed.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RatingsChanged();
    ///Fired when the SBE2 source filter receives a <b>STREAMBUFFER_EC_TIMEHOLE</b> event, which indicates playback has
    ///reached a gap in recorded content.
    ///Params:
    ///    StreamOffsetMS = Time of the start of the gap relative to the content start, in milliseconds.
    ///    SizeMS = Duration of the gap, in milliseconds.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT TimeHole(int StreamOffsetMS, int SizeMS);
    ///Fired when the SBE2 source filter receives a <b>STREAMBUFFER_EC_STALE_DATA_READ</b> event, which indicates an
    ///MSVidStreamBufferSource object has read from a temporary recording file that is marked for deletion.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StaleDataRead();
    ///Fired when the SBE2 source filter receives a <b>STREAMBUFFER_EC_CONTENT_BECOMING_STALE</b> event, which indicates
    ///the stream buffer source lags behind the stream buffer sink by more than a preset number of files. For more
    ///information, see IStreamBufferConfigure::GetBackingFileCount.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ContentBecomingStale();
    ///Fired when the SBE2 source filter receives a <b>STREAMBUFFER_EC_STALE_FILE_DELETED</b> event, which indicates
    ///that a temporary file has been deleted.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StaleFileDeleted();
    ///Fired when the SBE2 source filter receives a <b>STREAMBUFFER_EC_RATE_CHANGED</b> event, which indicates the
    ///playback rate has changed.
    ///Params:
    ///    qwNewRate = New playback rate, multiplied by 1,000.
    ///    qwOldRate = Old playback rate, multiplied by 1,000.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RateChange(double qwNewRate, double qwOldRate);
    ///Fired when the SBE2 source filter receives any event fired through the IBroadcastEvent interface, other than the
    ///<b>EVENTID_DTFilterRatingChange</b> event.
    ///Params:
    ///    Guid = <b>BSTR</b> object that contains the GUID that identifies the event.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BroadcastEvent(BSTR Guid);
    ///Fired when an SBE2 source filter receives any event fired by a call to IBroadcastEventEx::FireEx.
    ///Params:
    ///    Guid = <b>BSTR</b> object that contains the GUID that identifies the event.
    ///    Param1 = Specifies the first implementation-dependent parameter.
    ///    Param2 = Specifies the second implementation-dependent parameter.
    ///    Param3 = Specifies the third implementation-dependent parameter.
    ///    Param4 = Specifies the fourth implementation-dependent parameter.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BroadcastEventEx(BSTR Guid, uint Param1, uint Param2, uint Param3, uint Param4);
    ///Fired when an SBE2 source filter receives a <b>STREAMBUFFER_EC_PRIMARY_AUDIO</b> event, which is fired through
    ///the IMSVidStreamBufferSourceEvent3 interface, and indicates that SBE is processing primarily audio data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ContentPrimarilyAudio();
}

///The <b>IMSVidVideoRenderer2</b> interface represents a video renderer device. The MSVidVideoRenderer object exposes
///this interface. This interface provides access to the Video Mixing Renderer (VMR) filter. It inherits the
///IMSVidVideoRenderer interface and adds support for custom allocator-presenters.
@GUID("6BDD5C1E-2810-4159-94BC-05511AE8549B")
interface IMSVidVideoRenderer2 : IMSVidVideoRenderer
{
    ///The <b>get_Allocator</b> method retrieves the allocator-presenter from the VMR as an <b>IUnknown</b> pointer.
    ///This method is provided for Automation clients. C++ applications can also use the get__Allocator method, which
    ///returns an IVMRSurfaceAllocator pointer.
    ///Params:
    ///    AllocPresent = Receives a pointer to the allocator-presenter's <b>IUnknown</b> interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT get_Allocator(IUnknown* AllocPresent);
    ///The <b>get__Allocator</b> method retrieves the allocator-presenter from the VMR.
    ///Params:
    ///    AllocPresent = Receives an IVMRSurfaceAllocator interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get__Allocator(IVMRSurfaceAllocator* AllocPresent);
    ///The <b>get_Allocator_ID</b> method retrieves an identifier for the VMR filter's allocator-presenter.
    ///Params:
    ///    ID = Receives the identifier. If the returned value is -1, the MSVidVideoRenderer object will assign a default
    ///         identifier when it builds the filter graph.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT get_Allocator_ID(int* ID);
    ///The <b>SetAllocator</b> method specifies an allocator-presenter for the VMR. Applications can use this method to
    ///provide their own custom allocator-presenter objects.
    ///Params:
    ///    AllocPresent = Pointer to the <b>IUnknown</b> interface of the allocator-presenter object.
    ///    ID = Optionally, specifies an identifier (ID) for the allocator-presenter object. The default value of -1
    ///         indicates that the MSVidVideoRenderer object will create an ID when it builds the filter graph. In that case,
    ///         the MSVidVideoRenderer object uses the lower 32 bits of the allocator-presenter's <b>IUnknown</b> interface
    ///         pointer as the ID. Note that the ID is for application use; the VMR does not use it.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT SetAllocator(IUnknown AllocPresent, int ID);
    HRESULT _SetAllocator2(IVMRSurfaceAllocator AllocPresent, int ID);
    ///The <b>put_SuppressEffects</b> method sets preferences for power management and visual effects.
    ///Params:
    ///    bSuppress = Specifies a Boolean value. See Remarks for more information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT put_SuppressEffects(short bSuppress);
    ///The <b>get_SuppressEffects</b> method retrieves settings that control power management and visual effects.
    ///Params:
    ///    bSuppress = Receives the value VARIANT_TRUE or VARIANT_FALSE. For more information, see
    ///                IMSVidVideoRenderer2::put_SuppressEffects.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT get_SuppressEffects(short* bSuppress);
}

///This interface is not implemented.
@GUID("7145ED66-4730-4FDB-8A53-FDE7508D3E5E")
interface IMSVidVideoRendererEvent2 : IMSVidOutputDeviceEvent
{
    ///This method is not implemented.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OverlayUnavailable();
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>IMSVidVMR9</b>
///interface represents the Video Mixing Renderer Filter 9 (VMR-9) within the Video Control filter graph. The MSVidVMR9
///object exposes this interface.
@GUID("D58B0015-EBEF-44BB-BBDD-3F3699D76EA1")
interface IMSVidVMR9 : IMSVidVideoRenderer
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_Allocator_ID</b> method retrieves the identifier of the application's custom allocator-presenter.
    ///Params:
    ///    ID = Receives the identifier. If the application did not set an allocator-presenter, the value is –1.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_Allocator_ID(int* ID);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>SetAllocator</b>
    ///method sets a custom allocator-presenter for the VMR-9.
    ///Params:
    ///    AllocPresent = Pointer to the <b>IUnknown</b> interface of the allocator-presenter. This object must expose the
    ///                   IVMRSurfaceAllocator9 interface. To use the VMR-9 filter's default allocator-presenter, set this parameter to
    ///                   <b>NULL</b>.
    ///    ID = Application-defined identifier for the allocator-presenter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetAllocator(IUnknown AllocPresent, int ID);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>put_SuppressEffects</b> method specifies whether the Video Control configures the system for optimal video
    ///playback.
    ///Params:
    ///    bSuppress = Specifies a Boolean value. See Remarks for more information.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT put_SuppressEffects(short bSuppress);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_SuppressEffects</b> method queries whether the Video Control configures the system for optimal video
    ///playback.
    ///Params:
    ///    bSuppress = Receives a <b>VARIANT_BOOL</b>. For more information, see IMSVidVMR9::put_SuppressEffects. The default value
    ///                is VARIANT_TRUE.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_SuppressEffects(short* bSuppress);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>get_Allocator</b> method retrieves the application's custom allocator-presenter.
    ///Params:
    ///    AllocPresent = Receives a pointer to the <b>IUnknown</b> interface of the allocator-presenter. The caller must release the
    ///                   interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The application did not set a custom
    ///    allocator-presenter. </td> </tr> </table>
    ///    
    HRESULT get_Allocator(IUnknown* AllocPresent);
}

///The <b>IMSVidEVR</b> interface represents the Enhanced Video Renderer (EVR) filter within the Video Control filter
///graph.
@GUID("15E496AE-82A8-4CF9-A6B6-C561DC60398F")
interface IMSVidEVR : IMSVidVideoRenderer
{
    ///The <b>get_Presenter</b> method retrieves the presenter object for the Enhanced Video Renderer (EVR) filter.
    ///Params:
    ///    ppAllocPresent = Receives a pointer to the IMFVideoPresenter interface. This interface is documented in this Media Foundation
    ///                     SDK documentaion. The caller must release the interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Presenter(IMFVideoPresenter* ppAllocPresent);
    ///The <b>put_Presenter</b> method sets the presenter object for the Enhanced Video Renderer (EVR) filter.
    ///Params:
    ///    pAllocPresent = Pointer to a presenter's IMFVideoPresenter interface. This interface is documented in this Media Foundation
    ///                    SDK documentaion.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Presenter(IMFVideoPresenter pAllocPresent);
    ///The <b>put_SuppressEffects</b> method specifies whether the Video Control configures the system for optimal video
    ///playback.
    ///Params:
    ///    bSuppress = Specifies a Boolean value. See Remarks for more information.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_SuppressEffects(short bSuppress);
    ///The <b>get_SuppressEffects</b> method queries whether the Video Control configures the system for optimal video
    ///playback
    ///Params:
    ///    bSuppress = Receives a <b>VARIANT_BOOL</b>. For more information, see IMSVidEVR::put_SuppressEffects. The default value
    ///                is VARIANT_TRUE.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_SuppressEffects(short* bSuppress);
}

///This topic applies to Windows Vista or later. The <b>IMSVidEVREvent</b> interface is used to receive events from the
///Enhanced Video Renderer (EVR) filter. This interface is an outgoing connection-point interface. To receive events
///from a playback device, implement this interface and then call the <b>IConnectionPoint::Advise</b> method to
///establish a connection. Then call the <b>IConnectionPoint::Advise</b> method on the MSVidEVR object to establish a
///connection.
@GUID("349ABB10-883C-4F22-8714-CECAEEE45D62")
interface IMSVidEVREvent : IMSVidOutputDeviceEvent
{
    ///This topic applies to Windows Vista or later. The <b>OnUserEvent</b> method forwards custom events from the
    ///enhanced video renderer (EVR) filter.
    ///Params:
    ///    lEventCode = Event code.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT OnUserEvent(int lEventCode);
}

///The <b>IMSVidAudioRenderer</b> interface represents an audio renderer device. It enables applications to control the
///volume and balance. To retrieve the audio renderer device that is currently active, call the
///IMSVidCtl::get_AudioRendererActive method.
@GUID("37B0353F-A4C8-11D2-B634-00C04F79498E")
interface IMSVidAudioRenderer : IMSVidOutputDevice
{
    ///The <b>put_Volume</b> method specifies the audio renderer's volume level.
    ///Params:
    ///    lVol = Specifies the volume level, in units of .01 decibel (dB).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Volume(int lVol);
    ///The <b>get_Volume</b> method retrieves the audio renderer's volume level.
    ///Params:
    ///    lVol = Pointer to a variable that receives the volume level, in units of .01 decibel (dB).
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Volume(int* lVol);
    ///The <b>put_Balance</b> method specifies the audio renderer's balance level.
    ///Params:
    ///    lBal = Specifies the balance level.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Balance(int lBal);
    ///The <b>get_Balance</b> method retrieves the audio renderer's balance level.
    ///Params:
    ///    lBal = Pointer to a variable that receives the balance level.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Balance(int* lBal);
}

///This topic applies to Windows XP or later. The <b>IMSVidAudioRendererEvent</b> interface is used to receive events
///from the audio renderer. This interface is an outgoing connection-point interface. To receive events related to audio
///rendering, implement this interface in your application. Then call the <b>IConnectionPoint::Advise</b> method on the
///MSVidAudioRenderer object to establish a connection.
@GUID("37B03541-A4C8-11D2-B634-00C04F79498E")
interface IMSVidAudioRendererEvent : IMSVidOutputDeviceEvent
{
}

///Implements an event system for the audio renderer associated with a Video Control. Audio renderer events are
///triggered by events from the audio decoder upstream of the audio renderer in the filter graph. The audio renderer
///subscribes to audio decoder events by using the ICodecAPI::RegisterForEvent method. Each method in
///<b>IMSVidAudioRendererEvent2</b> corresponds to a codec property, as follows: <ol> <li>An audio decoder property
///changes.</li> <li>The decoder fires an ICodecAPI event. The event data includes the GUID that identifies the codec
///property.</li> <li>The audio renderer fires the corresponding <b>IMSVidAudioRendererEvent2</b> event.</li> </ol>For a
///list of codec properties, see Codec API Properties.
@GUID("E3F55729-353B-4C43-A028-50F79AA9A907")
interface IMSVidAudioRendererEvent2 : IMSVidAudioRendererEvent
{
    ///Indicates a change in the AVDecAudioDualMono codec property.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AVDecAudioDualMono();
    ///Indicates a change in the AVAudioSampleRate codec property.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AVAudioSampleRate();
    ///Indicates a change in the AVDecAudioDualMono codec property.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AVAudioChannelConfig();
    ///Indicates a change in the AVAudioChannelCount codec property.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AVAudioChannelCount();
    ///Indicates a change in the <b>AVDecCommonMeanBitRate</b> codec property.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AVDecCommonMeanBitRate();
    ///Indicates a change in the AVDDSurroundMode codec property.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AVDDSurroundMode();
    ///Indicates a change in the AVDecCommonInputFormat codec property.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AVDecCommonInputFormat();
    ///Indicates a change in the AVDecCommonOutput codec property.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AVDecCommonOutputFormat();
}

///The <b>IMSVidInputDevices</b> interface represents a collection of input devices. The MSVidInputDevices object
///exposes this object.
@GUID("C5702CD1-9B79-11D3-B654-00C04F79498E")
interface IMSVidInputDevices : IDispatch
{
    ///The <b>get_Count</b> method retrieves the number of items in the collection.
    ///Params:
    ///    lCount = Pointer to a variable that receives the number of items.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Count(int* lCount);
    ///The <b>get__NewEnum</b> method retrieves an enumerator for the collection.
    ///Params:
    ///    pD = Pointer to a variable that receives an <b>IEnumVARIANT</b> interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> </table>
    ///    
    HRESULT get__NewEnum(IEnumVARIANT* pD);
    ///The <b>get_Item</b> method retrieves the specified item from the collection.
    ///Params:
    ///    v = <b>VARIANT</b> that specifies the index of the item to retrieve.
    ///    pDB = Address of a variable that receives an IMSVidInputDevice interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_BADINDEX</b></dt> </dl> </td> <td width="60%">
    ///    The index is out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_TYPEMISMATCH</b></dt> </dl>
    ///    </td> <td width="60%"> Wrong <b>VARIANT</b> type. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Item(VARIANT v, IMSVidInputDevice* pDB);
    ///The <b>Add</b> method adds an input device to the collection.
    ///Params:
    ///    pDB = Pointer to the device's IMSVidInputDevice interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%">
    ///    This collection is read-only; cannot add any items. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr>
    ///    </table>
    ///    
    HRESULT Add(IMSVidInputDevice pDB);
    ///The <b>Remove</b> method removes an item from the collection.
    ///Params:
    ///    v = <b>VARIANT</b> that specifies the index of the item to remove.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_BADINDEX</b></dt> </dl> </td> <td width="60%">
    ///    Index out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_TYPEMISMATCH</b></dt> </dl> </td>
    ///    <td width="60%"> Wrong <b>VARIANT</b> type. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> This collection is read-only; no items can be
    ///    removed from it </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Unexpected error. </td> </tr> </table>
    ///    
    HRESULT Remove(VARIANT v);
}

///The <b>IMSVidOutputDevices</b> interface represents a collection of output devices. Output devices include video and
///audio renderers, and the Stream Buffer Sink object. To obtain the audio and video renders, you can use the following
///methods: <ul> <li> IMSVidCtl::get_AudioRendererActive </li> <li> IMSVidCtl::get_AudioRenderersAvailable </li> <li>
///IMSVidCtl::get_VideoRendererActive </li> <li> IMSVidCtl::get_VideoRenderersAvailable </li> </ul>
@GUID("C5702CD2-9B79-11D3-B654-00C04F79498E")
interface IMSVidOutputDevices : IDispatch
{
    ///The <b>get_Count</b> method retrieves the number of items in the collection.
    ///Params:
    ///    lCount = Pointer to a variable that receives the number of items.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Count(int* lCount);
    ///The <b>get__NewEnum</b> method retrieves an enumerator for the collection.
    ///Params:
    ///    pD = Pointer to a variable that receives an <b>IEnumVARIANT</b> interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> </table>
    ///    
    HRESULT get__NewEnum(IEnumVARIANT* pD);
    ///The <b>get_Item</b> method retrieves the specified item from the collection.
    ///Params:
    ///    v = <b>VARIANT</b> that specifies the index of the item to retrieve.
    ///    pDB = Address of a variable that receives an IMSVidOutputDevice interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_BADINDEX</b></dt> </dl> </td> <td width="60%">
    ///    The index is out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_TYPEMISMATCH</b></dt> </dl>
    ///    </td> <td width="60%"> Wrong <b>VARIANT</b> type. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Item(VARIANT v, IMSVidOutputDevice* pDB);
    ///The <b>Add</b> method adds an output device to the collection.
    ///Params:
    ///    pDB = Specifies a pointer to the device's IMSVidOutputDevice interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%">
    ///    The collection is read-only; cannot add any items. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr>
    ///    </table>
    ///    
    HRESULT Add(IMSVidOutputDevice pDB);
    ///The <b>Remove</b> method removes an item from the collection.
    ///Params:
    ///    v = <b>VARIANT</b> that specifies the index of the item to remove.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_BADINDEX</b></dt> </dl> </td> <td width="60%">
    ///    The index is out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_TYPEMISMATCH</b></dt> </dl>
    ///    </td> <td width="60%"> Wrong <b>VARIANT</b> type. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> The collection is read-only; cannot remove any
    ///    items. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. </td> </tr> </table>
    ///    
    HRESULT Remove(VARIANT v);
}

///The <b>IMSVidVideoRendererDevices</b> interface represents a collection of video renderers. The
///MSVidVideoRendererDevices object exposes this method. Applications can use this interface to enumerate the
///collection.
@GUID("C5702CD3-9B79-11D3-B654-00C04F79498E")
interface IMSVidVideoRendererDevices : IDispatch
{
    ///The <b>get_Count</b> method retrieves the number of items in the collection.
    ///Params:
    ///    lCount = Pointer to a variable that receives the number of items.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Count(int* lCount);
    ///The <b>get__NewEnum</b> method retrieves an enumerator for the collection.
    ///Params:
    ///    pD = Pointer to a variable that receives an <b>IEnumVARIANT</b> interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> </table>
    ///    
    HRESULT get__NewEnum(IEnumVARIANT* pD);
    ///The <b>get_Item</b> method retrieves the specified item from the collection.
    ///Params:
    ///    v = <b>VARIANT</b> that specifies the index of the item to retrieve.
    ///    pDB = Receives an IMSVidVideoRenderer interface pointer. The caller must release the interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_BADINDEX</b></dt> </dl> </td> <td width="60%">
    ///    The index is out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_TYPEMISMATCH</b></dt> </dl>
    ///    </td> <td width="60%"> Wrong <b>VARIANT</b> type. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Item(VARIANT v, IMSVidVideoRenderer* pDB);
    ///The <b>Add</b> method adds a video renderer to the collection.
    ///Params:
    ///    pDB = Specifies a pointer to the video renderer's IMSVidVideoRenderer interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%">
    ///    The collection is read-only; cannot add any items. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr>
    ///    </table>
    ///    
    HRESULT Add(IMSVidVideoRenderer pDB);
    ///The <b>Remove</b> method removes an item from the collection.
    ///Params:
    ///    v = <b>VARIANT</b> that specifies the index of the item to remove.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_BADINDEX</b></dt> </dl> </td> <td width="60%">
    ///    The index is out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_TYPEMISMATCH</b></dt> </dl>
    ///    </td> <td width="60%"> Wrong <b>VARIANT</b> type. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> The collection is read-only; cannot remove any
    ///    items. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. </td> </tr> </table>
    ///    
    HRESULT Remove(VARIANT v);
}

///The <b>IMSVidAudioRendererDevices</b> interface represents a collection of audio renderers. Applications can use this
///interface to enumerate the collection. The MSVidAudioRendererDevices object exposes this method.
@GUID("C5702CD4-9B79-11D3-B654-00C04F79498E")
interface IMSVidAudioRendererDevices : IDispatch
{
    ///The <b>get_Count</b> method retrieves the number of items in the collection.
    ///Params:
    ///    lCount = Pointer to a variable that receives the number of items.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Count(int* lCount);
    ///The <b>get__NewEnum</b> method retrieves an enumerator for the collection.
    ///Params:
    ///    pD = Pointer to a variable that receives an <b>IEnumVARIANT</b> interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> </table>
    ///    
    HRESULT get__NewEnum(IEnumVARIANT* pD);
    ///The <b>get_Item</b> method retrieves the specified item from the collection.
    ///Params:
    ///    v = <b>VARIANT</b> that specifies the index of the item to retrieve.
    ///    pDB = Address of a variable that receives an IMSVidAudioRenderer interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_BADINDEX</b></dt> </dl> </td> <td width="60%">
    ///    The index is out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_TYPEMISMATCH</b></dt> </dl>
    ///    </td> <td width="60%"> Wrong <b>VARIANT</b> type. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Item(VARIANT v, IMSVidAudioRenderer* pDB);
    ///The <b>Add</b> method adds an audio renderer to the collection.
    ///Params:
    ///    pDB = Pointer to the audio renderer's IMSVidAudioRenderer interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%">
    ///    The collection is read-only; cannot add any items. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr>
    ///    </table>
    ///    
    HRESULT Add(IMSVidAudioRenderer pDB);
    ///The <b>Remove</b> method removes an item from the collection.
    ///Params:
    ///    v = <b>VARIANT</b> that specifies the index of the item to remove.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_BADINDEX</b></dt> </dl> </td> <td width="60%">
    ///    The index is out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_TYPEMISMATCH</b></dt> </dl>
    ///    </td> <td width="60%"> Wrong <b>VARIANT</b> type. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> The collection is read-only; cannot remove any
    ///    items. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. </td> </tr> </table>
    ///    
    HRESULT Remove(VARIANT v);
}

///The <b>IMSVidFeatures</b> interface represents a collection of Video Control features. The MSVidFeatures collection
///object exposes this interface. This interface is used for two purposes: to retrieve a read-only collection of the
///features available on the current system (the <i>available</i> features collection), and to create a read/write list
///of activated features (the <i>active</i> features collection).
@GUID("C5702CD5-9B79-11D3-B654-00C04F79498E")
interface IMSVidFeatures : IDispatch
{
    ///The <b>get_Count</b> method retrieves the number of items in the collection.
    ///Params:
    ///    lCount = Pointer to a variable that receives the number of items.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Count(int* lCount);
    ///The <b>get__NewEnum</b> method retrieves an enumerator for the collection.
    ///Params:
    ///    pD = Pointer to a variable that receives an <b>IEnumVARIANT</b> interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> </table>
    ///    
    HRESULT get__NewEnum(IEnumVARIANT* pD);
    ///The <b>get_Item</b> method retrieves the specified item from the collection.
    ///Params:
    ///    v = <b>VARIANT</b> that specifies the index of the item to retrieve.
    ///    pDB = Address of a variable that receives an IMSVidFeature interface pointer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_BADINDEX</b></dt> </dl> </td> <td width="60%">
    ///    The index is out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_TYPEMISMATCH</b></dt> </dl>
    ///    </td> <td width="60%"> Wrong <b>VARIANT</b> type. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Item(VARIANT v, IMSVidFeature* pDB);
    ///The <b>Add</b> method adds a feature to the collection.
    ///Params:
    ///    pDB = Specifies a pointer to the feature's IMSVidFeature interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%">
    ///    The collection is read-only; cannot add any items. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr>
    ///    </table>
    ///    
    HRESULT Add(IMSVidFeature pDB);
    ///The <b>Remove</b> method removes an item from the collection.
    ///Params:
    ///    v = <b>VARIANT</b> that specifies the index of the item to remove.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_BADINDEX</b></dt> </dl> </td> <td width="60%">
    ///    The index is out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DISP_E_TYPEMISMATCH</b></dt> </dl>
    ///    </td> <td width="60%"> Wrong <b>VARIANT</b> type. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> The collection is read-only; cannot remove any
    ///    items. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. </td> </tr> </table>
    ///    
    HRESULT Remove(VARIANT v);
}

///The <b>IMSVidCtl</b> interface is the main interface for the Video Control. It contains methods to enumerate
///available devices and features, and to select which features and devices will be active. It also contains methods to
///build, stop, start, and pause the filter graph.
@GUID("B0EDF162-910A-11D2-B632-00C04F79498E")
interface IMSVidCtl : IDispatch
{
    ///The <b>get_AutoSize</b> method retrieves a value that determines whether the Video Control is automatically
    ///resized to display its entire contents.
    ///Params:
    ///    pbool = Pointer to a variable of type <b>VARIANT_BOOL</b> that receives the current value of the property.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_AutoSize(short* pbool);
    ///The <b>put_AutoSize</b> method specifies whether the Video Control automatically resizes to display its entire
    ///contents.
    ///Params:
    ///    vbool = Specifies whether the Video Control automatically resizes. Use one of the following values. <table> <tr>
    ///            <th>Value </th> <th>Description </th> </tr> <tr> <td>VARIANT_TRUE</td> <td>The Video Control automatically
    ///            resizes.</td> </tr> <tr> <td>VARIANT_FALSE</td> <td>The Video Control does not automatically resize.</td>
    ///            </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_AutoSize(short vbool);
    ///The <b>get_BackColor</b> method retrieves the background color of the Video Control.
    ///Params:
    ///    backcolor = Receives an <b>OLE_COLOR</b> value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_BackColor(uint* backcolor);
    ///The <b>put_BackColor</b> method specifies the background color of the Video Control.
    ///Params:
    ///    backcolor = Specifies the background color as an <b>OLE_COLOR</b> value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_BackColor(uint backcolor);
    ///The <b>get_Enabled</b> method retrieves a value that determines whether the Video Control can respond to
    ///user-generated events.
    ///Params:
    ///    pbool = Variable of type <b>VARIANT_BOOL</b> that receives the current value of the property.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_Enabled(short* pbool);
    ///The <b>put_Enabled</b> method specifies a value that determines whether the Video Control can respond to
    ///user-generated events.
    ///Params:
    ///    vbool = Specifies the new value of the property.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_Enabled(short vbool);
    ///The <b>get_TabStop</b> method queries whether a user can use the TAB key to give the focus to the Video Control.
    ///Params:
    ///    pbool = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>VARIANT_TRUE</td> <td>The Video Control is in the tabbing order.</td> </tr> <tr> <td>VARIANT_FALSE</td>
    ///            <td>The Video Control is not in the tabbing order.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_TabStop(short* pbool);
    ///The <b>put_TabStop</b> method specifies whether a user can use the TAB key to give the focus to the Video
    ///Control.
    ///Params:
    ///    vbool = Specifies one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///            <td>VARIANT_TRUE</td> <td>Include the Video Control in the tabbing order.</td> </tr> <tr>
    ///            <td>VARIANT_FALSE</td> <td>Do not include the Video Control in the tabbing order.</td> </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_TabStop(short vbool);
    ///The <b>get_Window</b> method retrieves the window associated with the Video Control.
    ///Params:
    ///    phwnd = Receives a handle to the window.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_Window(HWND* phwnd);
    ///The <b>Refresh</b> method immediately updates the Video Control's appearance.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT Refresh();
    ///The <b>get_DisplaySize</b> method retrieves the display size.
    ///Params:
    ///    CurrentValue = Receives a member of the DisplaySizeList enumeration.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_DisplaySize(DisplaySizeList* CurrentValue);
    ///The <b>put_DisplaySize</b> method specifies the display size.
    ///Params:
    ///    NewValue = Specifies the display size as a member of the DisplaySizeList enumeration.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_DisplaySize(DisplaySizeList NewValue);
    ///The <b>get_MaintainAspectRatio</b> method queries whether the Video Control maintains the aspect ratio of the
    ///source video.
    ///Params:
    ///    CurrentValue = Receives one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                   <td>VARIANT_TRUE</td> <td>The Video Control will maintain the aspect ratio of the source video.</td> </tr>
    ///                   <tr> <td>VARIANT_FALSE</td> <td>The Video Control will stretch the video to fill the window.</td> </tr>
    ///                   </table>
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_MaintainAspectRatio(short* CurrentValue);
    ///The <b>put_MaintainAspectRatio</b> method specifies whether the Video Control maintains the aspect ratio of the
    ///source video.
    ///Params:
    ///    NewValue = Specifies one of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///               <td>VARIANT_TRUE</td> <td>The Video Control will maintain the aspect ratio of the source video.</td> </tr>
    ///               <tr> <td>VARIANT_FALSE</td> <td>The Video Control will stretch the video to fill the window. (Default.)</td>
    ///               </tr> </table>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_MaintainAspectRatio(short NewValue);
    ///The <b>get_ColorKey</b> method retrieves the color key that the video renderer is using.
    ///Params:
    ///    CurrentValue = Receives an <b>OLE_COLOR</b> value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_ColorKey(uint* CurrentValue);
    ///The <b>put_ColorKey</b> method specifies the color key.
    ///Params:
    ///    NewValue = Specifies the color key as an <b>OLE_COLOR</b> value.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_ColorKey(uint NewValue);
    ///The <b>get_InputsAvailable</b> method retrieves the input devices that are available within a specified category.
    ///Params:
    ///    CategoryGuid = <b>BSTR</b> that specifies the GUID of the category to enumerate.
    ///    pVal = Receives an IMSVidInputDevices interface pointer. The caller must release the interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_InputsAvailable(BSTR CategoryGuid, IMSVidInputDevices* pVal);
    ///The <b>get_OutputsAvailable</b> method retrieves the output devices that are available in a specified category.
    ///Params:
    ///    CategoryGuid = <b>BSTR</b> that specifies the GUID of the category to enumerate
    ///    pVal = Receives an IMSVidOutputDevices interface pointer. The caller must release the interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_OutputsAvailable(BSTR CategoryGuid, IMSVidOutputDevices* pVal);
    ///The <b>get__InputsAvailable</b> method retrieves the input devices that are available in a specified category.
    ///Params:
    ///    CategoryGuid = Pointer to a GUID that specifies the category to enumerate. Supported categories include the following.
    ///                   <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>KSCATEGORY_BDA_NETWORK_PROVIDER</td>
    ///                   <td>BDA-compatible tuner devices.</td> </tr> <tr> <td>KSCATEGORY_TVTUNER</td> <td>Non-BDA analog tuner
    ///                   devices.</td> </tr> <tr> <td>GUID_NULL</td> <td>Miscellaneous devices (file source, DVD).</td> </tr> </table>
    ///    pVal = Receives an IMSVidInputDevices interface pointer. The caller must release the interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get__InputsAvailable(GUID* CategoryGuid, IMSVidInputDevices* pVal);
    ///The <b>get__OutputsAvailable</b> method retrieves the output devices that are available in a specified category.
    ///This method is currently not supported.
    ///Params:
    ///    CategoryGuid = Pointer to a GUID that specifies the category to enumerate.
    ///    pVal = Receives an IMSVidOutputDevices interface pointer. The caller must release the interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get__OutputsAvailable(GUID* CategoryGuid, IMSVidOutputDevices* pVal);
    ///The <b>get_VideoRenderersAvailable</b> method retrieves a collection of video renderers available on the local
    ///system.
    ///Params:
    ///    pVal = Receives an IMSVidVideoRendererDevices interface pointer. The caller must release the interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_VideoRenderersAvailable(IMSVidVideoRendererDevices* pVal);
    ///The <b>get_AudioRenderersAvailable</b> method retrieves the available audio renderers.
    ///Params:
    ///    pVal = Receives an IMSVidAudioRendererDevices interface pointer. The caller must release the interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_AudioRenderersAvailable(IMSVidAudioRendererDevices* pVal);
    ///The <b>get_FeaturesAvailable</b> method retrieves the features that are available on the local system.
    ///Params:
    ///    pVal = Receives an IMSVidFeatures interface pointer. The caller must release the interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_FeaturesAvailable(IMSVidFeatures* pVal);
    ///The <b>get_InputActive</b> method retrieves the input device that is currently active.
    ///Params:
    ///    pVal = Receives an IMSVidInputDevice interface pointer. The caller must release the interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_InputActive(IMSVidInputDevice* pVal);
    ///The <b>put_InputActive</b> method specifies the input device to use in the filter graph.
    ///Params:
    ///    pVal = Specifies a pointer to the input device's IMSVidInputDevice interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_InputActive(IMSVidInputDevice pVal);
    ///The <b>get_OutputsActive</b> method retrieves the output devices that are currently active.
    ///Params:
    ///    pVal = Receives an IMSVidOutputDevices interface pointer. The caller must release the interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_OutputsActive(IMSVidOutputDevices* pVal);
    ///The <b>put_OutputsActive</b> method specifies the active output devices.
    ///Params:
    ///    pVal = Pointer to the new collection of output devices.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_OutputsActive(IMSVidOutputDevices pVal);
    ///The <b>get_VideoRendererActive</b> method retrieves the currently active video renderer.
    ///Params:
    ///    pVal = Receives an IMSVidVideoRenderer interface pointer. The caller must release the interface. If no video
    ///           renderer is active, this parameter receives the value <b>NULL</b>.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_VideoRendererActive(IMSVidVideoRenderer* pVal);
    ///The <b>put_VideoRendererActive</b> method specifies the active video renderer.
    ///Params:
    ///    pVal = Specifies a pointer to the IMSVidVideoRenderer interface of the video renderer device.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_VideoRendererActive(IMSVidVideoRenderer pVal);
    ///The <b>get_AudioRendererActive</b> method retrieves the audio renderer that is currently active.
    ///Params:
    ///    pVal = Receives an IMSVidAudioRenderer interface pointer. The caller must release the interface. If no audio
    ///           renderer is active, this parameter receives the value <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_AudioRendererActive(IMSVidAudioRenderer* pVal);
    ///The <b>put_AudioRendererActive</b> method specifies the active audio renderer.
    ///Params:
    ///    pVal = Pointer to an IMSVidAudioRenderer interface that specifies the audio renderer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_AudioRendererActive(IMSVidAudioRenderer pVal);
    ///The <b>get_FeaturesActive</b> method retrieves the features that are currently active.
    ///Params:
    ///    pVal = Receives an IMSVidFeatures interface pointer. The caller must release the interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT get_FeaturesActive(IMSVidFeatures* pVal);
    ///The <b>put_FeaturesActive</b> method specifies a collection of features to activate.
    ///Params:
    ///    pVal = Pointer to the IMSVidFeatures interface on a collection of features.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT put_FeaturesActive(IMSVidFeatures pVal);
    ///The <b>get_State</b> method retrieves the state of the filter graph.
    ///Params:
    ///    lState = Receives a member of the MSVidCtlStateList enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_State(MSVidCtlStateList* lState);
    ///The <b>View</b> method configures the Video Control to view an input source, which can be a tune request, a DVD,
    ///or a media file.
    ///Params:
    ///    v = Pointer to the input source as a <b>VARIANT</b> type. This parameter must be one of the following:<ul> <li>A
    ///        pointer to a valid tune request object that supports the ITuneRequest interface. The tune request must be
    ///        initialized with all the tuning information required for the particular network type.</li> <li>The string
    ///        "DVD:" for DVD playback.</li> <li>The name of a media file.</li> </ul>
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT View(VARIANT* v);
    ///The <b>Build</b> method builds the filter graph and connects all the filters.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT Build();
    ///The <b>Pause</b> method pauses the filter graph.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT Pause();
    ///The <b>Run</b> method runs the filter graph.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT Run();
    ///The <b>Stop</b> method stops the filter graph.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT Stop();
    ///The <b>Decompose</b> method tears down the filter graph.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT Decompose();
    ///The <b>DisableVideo</b> method disables the video renderer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT DisableVideo();
    ///The <b>DisableAudio</b> method disables the audio output device.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT DisableAudio();
    ///The <b>ViewNext</b> method finds another input device to view the specified tune request. This method is
    ///supported only for analog tuner devices. It does not work with digital tuners.
    ///Params:
    ///    v = Specifies the tune request as a <b>VARIANT</b> type.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT ViewNext(VARIANT* v);
}

@GUID("C3A9F406-2222-436D-86D5-BA3229279EFB")
interface IMSEventBinder : IDispatch
{
    HRESULT Bind(IDispatch pEventObject, BSTR EventName, BSTR EventHandler, int* CancelID);
    HRESULT Unbind(uint CancelCookie);
}

@GUID("B0EDF164-910A-11D2-B632-00C04F79498E")
interface _IMSVidCtlEvents : IDispatch
{
}

///The <b>IStreamBufferInitialize</b> interface is used to configure the stream buffer filters. The Stream Buffer Source
///filter, Stream Buffer Sink filter, and StreamBufferConfig object all expose this interface.
@GUID("9CE50F2D-6BA7-40FB-A034-50B1A674EC78")
interface IStreamBufferInitialize : IUnknown
{
    ///The <b>SetHKEY</b> method sets the registry key where the stream buffer object stores its configuration
    ///information.
    ///Params:
    ///    hkeyRoot = Handle to the registry key.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> <b>SetHKEY</b> was called on a filter after it initialized internally. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetHKEY(HKEY hkeyRoot);
    ///The <b>SetSIDs</b> method sets the security identifiers (SIDs) that are used to protect access to the backing
    ///files.
    ///Params:
    ///    cSIDs = Specifies the size of the array given in the <i>ppSID</i> parameter.
    ///    ppSID = Pointer to an array of <b>SID</b> structures, of size <i>cSIDs</i>.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> Null pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetSIDs(uint cSIDs, void** ppSID);
}

///The <b>IStreamBufferSink</b> interface is exposed by the Stream Buffer Sink filter. Use this interface to lock the
///filter before capture and to create new recordings.
@GUID("AFD1F242-7EFD-45EE-BA4E-407A25C9A77A")
interface IStreamBufferSink : IUnknown
{
    ///The <b>LockProfile</b> method locks the Stream Buffer Sink filter's profile, thereby fixing the number of streams
    ///and their media types. This method can also specify the name and location of the stub file that points to the
    ///backing files.
    ///Params:
    ///    pszStreamBufferFilename = Pointer to a null-terminated wide-character string that specifies the full path name of the stub file. If the
    ///                              specified file already exists, the method fails. If <i>pszFilename</i> is <b>NULL</b>, the stub file is
    ///                              created in the current directory with a default file name.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The method succeeded. (Multiple calls with the same
    ///    parameter.) </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_UNSUPPORTED_STREAM</b></dt> </dl>
    ///    </td> <td width="60%"> The call failed because there are no streams in the profile. </td> </tr> </table>
    ///    
    HRESULT LockProfile(const(wchar)* pszStreamBufferFilename);
    ///This topic applies only to Windows XP Service Pack 1 or later. The <b>CreateRecorder</b> method creates a new
    ///Recording object. Recording objects are used to create permanent files from the stream buffer.
    ///Params:
    ///    pszFilename = Pointer to a null-terminated wide-character string that contains the file name for the recording.
    ///    dwRecordType = Indicates the type of recording to create, either a reference recording or a content recording. Specify one
    ///                   of the following values. <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr>
    ///                   <td>RECORDING_TYPE_REFERENCE</td> <td>Reference recording. A reference recording is created from temporary
    ///                   backing files that have already been recorded. It uses a stub file to reference the existing files. Because a
    ///                   reference recording refers to existing content, the start time can be in the past.</td> </tr> <tr>
    ///                   <td>RECORDING_TYPE_CONTENT</td> <td>Content recording. A content recording saves content into a new file.
    ///                   Because the content must be new, the start time cannot be in the past.</td> </tr> </table>
    ///    pRecordingIUnknown = Address of a variable that receives a pointer to the Recording object's <b>IUnknown</b> interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CreateRecorder(const(wchar)* pszFilename, uint dwRecordType, IUnknown* pRecordingIUnknown);
    ///This topic applies only to Windows XP Service Pack 1 or later. The <b>IsProfileLocked</b> method queries whether
    ///the Stream Buffer Sink filter's profile is locked.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The profile is locked. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The profile is not locked. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The method failed. </td> </tr> </table>
    ///    
    HRESULT IsProfileLocked();
}

///The <b>IStreamBufferSink2</b> interface is exposed by the Stream Buffer Sink filter.
@GUID("DB94A660-F4FB-4BFA-BCC6-FE159A4EEA93")
interface IStreamBufferSink2 : IStreamBufferSink
{
    ///The <b>UnlockProfile</b> method unlocks the Stream Buffer Sink filter's profile. After the profile is unlocked,
    ///you can change the name of the stub file.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The profile is not currently locked. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT UnlockProfile();
}

///The <b>IStreamBufferSink3</b> interface is exposed by the Stream Buffer Sink filter.
@GUID("974723F2-887A-4452-9366-2CFF3057BC8F")
interface IStreamBufferSink3 : IStreamBufferSink2
{
    ///The <b>SetAvailableFilter</b> method limits how far the Stream Buffer Source filter can seek backward, relative
    ///to the current recording position.
    ///Params:
    ///    prtMin = On input, specifies the earliest seek time, in 100-nanosecond units, relative to the recording position when
    ///             the method is called. The value must be less than or equal to zero. To make the entire backing store
    ///             available, use the value -MAXLONGLONG. On output, this parameter receives the actual minimum seek time. The
    ///             two values may differ if the requested time exceeds the amount of time that is available.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetAvailableFilter(long* prtMin);
}

///The <b>IStreamBufferSource</b> interface is exposed by the Stream Buffer Source filter. Use this interface to play
///live content from the Stream Buffer Sink filter.
@GUID("1C5BD776-6CED-4F44-8164-5EAB0E98DB12")
interface IStreamBufferSource : IUnknown
{
    ///The <b>SetStreamSink</b> method sets a pointer to the Stream Buffer Sink filter, so that the Stream Buffer Source
    ///filter can stream data from the sink filter.
    ///Params:
    ///    pIStreamBufferSink = Pointer to the Stream Buffer Sink filter's IStreamBufferSink Interface interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetStreamSink(IStreamBufferSink pIStreamBufferSink);
}

///The <b>IStreamBufferRecordControl</b> interface is used to control stream buffer Recording objects. Use the
///IStreamBufferSink::CreateRecorder method on the Stream Buffer Sink filter to create new Recording objects. After
///making a recording, stop the <b>Recording</b> object and release it before releasing the Stream Buffer Sink filter.
@GUID("BA9B6C99-F3C7-4FF2-92DB-CFDD4851BF31")
interface IStreamBufferRecordControl : IUnknown
{
    ///The <b>Start</b> method starts the recording.
    ///Params:
    ///    prtStart = Pointer to a variable that contains the start time. The time is relative to the current stream time, in
    ///               100-nanosecond units. The value zero represents now; negative values are in the past; and positive values are
    ///               in the future. For content recordings, the time must be a value between 0 and 5 seconds (50000000),
    ///               inclusive. Negative times are not valid. For reference recordings, negative times are valid if they fall
    ///               within existing content. If the time given in <i>prtStart</i> is earlier than the earliest valid content, the
    ///               actual start time of the content is used instead. This value is returned in <i>prtStart</i> when the method
    ///               returns.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Start(long* prtStart);
    ///The <b>Stop</b> method stops the recording and closes the file.
    ///Params:
    ///    rtStop = Specifies when the recording stops. The time is relative to the current stream time, in 100-nanosecond units.
    ///             The value zero represents now; negative values are in the past; and positive values are in the future. For
    ///             content recordings, the valid range is from 0 to 5 seconds (50000000), inclusive. Negative times are not
    ///             valid. For reference recordings, a negative time is valid if it falls within valid recorded content.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Stop(long rtStop);
    ///The <b>GetRecordingStatus</b> method retrieves the status of the recording.
    ///Params:
    ///    phResult = Pointer to a variable that receives an <b>HRESULT</b> value. The <b>HRESULT</b> value indicates the current
    ///               status of writing or closing the file. This parameter can be <b>NULL</b>.
    ///    pbStarted = Pointer to a variable that receives a Boolean value, indicating whether the recording has started, <table>
    ///                <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td><b>TRUE</b></td> <td>The recording has
    ///                started.</td> </tr> <tr> <td><b>FALSE</b></td> <td>The recording has not started.</td> </tr> </table> This
    ///                parameter can be <b>NULL</b>.
    ///    pbStopped = Pointer to a variable that receives a Boolean value, indicating whether recording has been stopped. <table>
    ///                <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td><b>TRUE</b></td> <td>The recording has
    ///                stopped.</td> </tr> <tr> <td><b>FALSE</b></td> <td>The recording has not stopped, or has not started
    ///                yet.</td> </tr> </table> This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordingStatus(int* phResult, int* pbStarted, int* pbStopped);
}

///The <b>IStreamBufferRecComp</b> interface is used to create new content recordings by concatenating existing
///recordings. The new recording can be created from a mix of reference and content recordings. The Stream Buffer
///RecComp object exposes this interface.
@GUID("9E259A9B-8815-42AE-B09F-221970B154FD")
interface IStreamBufferRecComp : IUnknown
{
    ///The <b>Initialize</b> method sets the file name and the profile for the new recording. Call this method once,
    ///after creating the RecComp object.
    ///Params:
    ///    pszTargetFilename = Null-terminated, wide character string that specifies the file name of the new recording.
    ///    pszSBRecProfileRef = Null-terminated, wide character string that specifies an existing file. This file must be a complete
    ///                         recording, already created by the Stream Buffer Engine.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT Initialize(const(wchar)* pszTargetFilename, const(wchar)* pszSBRecProfileRef);
    ///The <b>Append</b> method appends an entire recording to the target file.
    ///Params:
    ///    pszSBRecording = Null-terminated, wide character string that contains the name of the file to append.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT Append(const(wchar)* pszSBRecording);
    ///The <b>AppendEx</b> method appends part of a recording to the target file.
    ///Params:
    ///    pszSBRecording = Null-terminated, wide character string that contains the name of the file to append.
    ///    rtStart = Specifies the start time of the segment to append, in 100-nanosecond units.
    ///    rtStop = Specifies the stop time of the segment to append, in 100-nanosecond units.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT AppendEx(const(wchar)* pszSBRecording, long rtStart, long rtStop);
    ///The <b>GetCurrentLength</b> method retrieves the length of the target file.
    ///Params:
    ///    pcSeconds = Pointer to a variable that receives the current length, in seconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetCurrentLength(uint* pcSeconds);
    ///The <b>Close</b> method closes the target file.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT Close();
    ///The <b>Cancel</b> method cancels an append operation, if one is in progress. Otherwise, it has no effect.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT Cancel();
}

///The <b>IStreamBufferRecordingAttribute</b> interface sets and retrieves attributes on a stream buffer recording.
///<i>Attributes</i> are metadata that describe the physical file (such as the bitrate and the duration) or the content
///of the file (such as the author or title). This interface is exposed by the Recording object and the
///RecordingAttributes object.
@GUID("16CA4E03-FE69-4705-BD41-5B7DFC0C95F3")
interface IStreamBufferRecordingAttribute : IUnknown
{
    ///The <b>SetAttribute</b> method sets an attribute on the stream buffer file.
    ///Params:
    ///    ulReserved = Reserved. Set this parameter to zero.
    ///    pszAttributeName = Wide-character string that contains the name of the attribute.
    ///    StreamBufferAttributeType = Member of the STREAMBUFFER_ATTR_DATATYPE enumeration that defines the data type of the attribute data.
    ///    pbAttribute = Pointer to a buffer that contains the attribute data.
    ///    cbAttributeLength = The size of the buffer specified in <i>pbAttribute</i>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT SetAttribute(uint ulReserved, const(wchar)* pszAttributeName, 
                         STREAMBUFFER_ATTR_DATATYPE StreamBufferAttributeType, char* pbAttribute, 
                         ushort cbAttributeLength);
    ///The <b>GetAttributeCount</b> method returns the number of attributes that are currently defined for this stream
    ///buffer file.
    ///Params:
    ///    ulReserved = Reserved. Set this parameter to zero.
    ///    pcAttributes = Pointer to a variable that receives the number of attributes.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    NULL pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetAttributeCount(uint ulReserved, ushort* pcAttributes);
    ///The <b>GetAttributeByName</b> method retrieves an attribute, specified by name.
    ///Params:
    ///    pszAttributeName = Wide-character string that contains the name of the attribute.
    ///    pulReserved = Reserved. Set this parameter to zero.
    ///    pStreamBufferAttributeType = Pointer to a variable that receives a member of the STREAMBUFFER_ATTR_DATATYPE enumeration. This value
    ///                                 indicates the data type that you should use to interpret the attribute, which is returned in the
    ///                                 <i>pbAttribute</i> parameter.
    ///    pbAttribute = Pointer to a buffer that receives the attribute, as an array of bytes. Specify the size of the buffer in the
    ///                  <i>pcbLength</i> parameter. To find out the required size for the array, set <i>pbAttribute</i> to
    ///                  <b>NULL</b> and check the value that is returned in <i>pcbLength</i>.
    ///    pcbLength = On input, specifies the size of the buffer given in <i>pbAttribute</i>, in bytes. On output, contains the
    ///                number of bytes that were copied to the buffer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_BUFFER_OVERFLOW</b></dt> </dl> </td> <td
    ///    width="60%"> The buffer given in <i>pbAttribute</i> is too small. </td> </tr> </table>
    ///    
    HRESULT GetAttributeByName(const(wchar)* pszAttributeName, uint* pulReserved, 
                               STREAMBUFFER_ATTR_DATATYPE* pStreamBufferAttributeType, char* pbAttribute, 
                               ushort* pcbLength);
    ///The <b>GetAttributeByIndex</b> method retrieves an attribute, specified by index number.
    ///Params:
    ///    wIndex = Zero-based index of the attribute to retrieve.
    ///    pulReserved = Reserved. Set this parameter to zero.
    ///    pszAttributeName = Pointer to a buffer that receives the name of the attribute, as a null-terminated wide-character string.
    ///                       Specify the size of the buffer in the <i>pcchNameLength</i> parameter. To find out the required size for the
    ///                       array, set <i>pszAttributeName</i> to <b>NULL</b> and check the value that is returned in
    ///                       <i>pcchNameLength</i>.
    ///    pcchNameLength = On input, specifies the size of the buffer given in <i>pszAttributeName</i>, in wide characters. On output,
    ///                     contains the number of characters that were copied to the buffer, including the null terminator. Remember
    ///                     that wide characters are two bytes each.
    ///    pStreamBufferAttributeType = Pointer to a variable that receives a member of the STREAMBUFFER_ATTR_DATATYPE enumeration. This value
    ///                                 indicates the data type that you should use to interpret the attribute, which is returned in the
    ///                                 <i>pbAttribute</i> parameter.
    ///    pbAttribute = Pointer to a buffer that receives the attribute, as an array of bytes. Specify the size of the buffer in the
    ///                  <i>pcbLength</i> parameter. To find out the required size for the array, set <i>pbAttribute</i> to
    ///                  <b>NULL</b> and check the value that is returned in <i>pcbLength</i>.
    ///    pcbLength = On input, specifies the size of the buffer given in <i>pbAttribute</i>, in bytes. On output, contains the
    ///                number of bytes that were copied to the buffer.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_BUFFER_OVERFLOW</b></dt> </dl> </td> <td
    ///    width="60%"> One or both of the buffers is too small. </td> </tr> </table>
    ///    
    HRESULT GetAttributeByIndex(ushort wIndex, uint* pulReserved, ushort* pszAttributeName, ushort* pcchNameLength, 
                                STREAMBUFFER_ATTR_DATATYPE* pStreamBufferAttributeType, char* pbAttribute, 
                                ushort* pcbLength);
    ///The <b>EnumAttributes</b> method enumerates the existing attributes of the stream buffer file. This method
    ///returns an enumerator object, which the caller can then use to enumerate the attributes.
    ///Params:
    ///    ppIEnumStreamBufferAttrib = Receives an IEnumStreamBufferRecordingAttrib interface pointer. The caller must release the interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> NULL pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT EnumAttributes(IEnumStreamBufferRecordingAttrib* ppIEnumStreamBufferAttrib);
}

///The <b>IEnumStreamBufferRecordingAttrib</b> interface enumerates a collection of attributes on a stream buffer file.
///<i>Attributes</i> are metadata that describe the physical file (such as the bit rate and the duration) or the content
///of the file (such as the author or title). To obtain this interface, call the
///IStreamBufferRecordingAttribute::EnumAttributes method. This interface implements a standard Component Object Model
///(COM) collection object. For more information on COM collections, see the <b>IEnumXXXX</b> topic in the Microsoft
///Platform SDK. The collection object represents a snapshot of the attributes when the collection is created; the
///collection is not updated automatically.
@GUID("C18A9162-1E82-4142-8C73-5690FA62FE33")
interface IEnumStreamBufferRecordingAttrib : IUnknown
{
    ///The <b>Next</b> method returns a specified number of attributes in the enumeration sequence.
    ///Params:
    ///    cRequest = The number of attributes to retrieve.
    ///    pStreamBufferAttribute = Pointer to an array of size <i>cRequest</i>. The array is filled with STREAMBUFFER_ATTRIBUTE structures.
    ///    pcReceived = Pointer to a variable that receives the number of attributes that are returned in the
    ///                 <i>pStreamBufferAttribute</i> array. This parameter can be <b>NULL</b> if <i>cRequest</i> is 1.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt>
    ///    </dl> </td> <td width="60%"> Did not retrieve as many attributes as requested (reached the end of the
    ///    enumeration). </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT Next(uint cRequest, char* pStreamBufferAttribute, uint* pcReceived);
    ///The <b>Skip</b> method skips over a specified number of attributes.
    ///Params:
    ///    cRecords = The number of attributes to skip.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Skipped past the end of the sequence. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT Skip(uint cRecords);
    ///The <b>Reset</b> method resets the enumeration sequence to the beginning.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value.
    ///    
    HRESULT Reset();
    ///The <b>Clone</b> method makes a copy of the enumerator object. The returned object starts with the same
    ///enumeration state as the original.
    ///Params:
    ///    ppIEnumStreamBufferAttrib = Address of a variable that receives a pointer to the <b>IEnumStreamBufferRecordingAttrib</b> interface of the
    ///                                new enumerator.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> NULL pointer argument. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumStreamBufferRecordingAttrib* ppIEnumStreamBufferAttrib);
}

///The <b>IStreamBufferConfigure</b> interface configures the location, number, and size of the backing files used by
///the various stream buffer objects. The StreamBufferConfig object exposes this interface. Before calling any of the
///<b>Set</b> methods on this interface, you must specify a registry key to hold the new settings. For more information,
///see IStreamBufferInitialize::SetHKEY.
@GUID("CE14DFAE-4098-4AF7-BBF7-D6511F835414")
interface IStreamBufferConfigure : IUnknown
{
    ///The <b>SetDirectory</b> method sets the directory where backing files are saved.
    ///Params:
    ///    pszDirectoryName = Pointer to a null-terminated string containing the fully qualified directory name. If the specified directory
    ///                       does not exist, it will be created.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The StreamBufferConfig object was not initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetDirectory(const(wchar)* pszDirectoryName);
    ///The <b>GetDirectory</b> method retrieves the directory where backing files are saved.
    ///Params:
    ///    ppszDirectoryName = Pointer to a variable that receives the fully qualified directory name.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDirectory(ushort** ppszDirectoryName);
    ///The <b>SetBackingFileCount</b> method sets the maximum and minimum number of backing files.
    ///Params:
    ///    dwMin = Specifies the backing file minimum. The valid range is from 4 to 100.
    ///    dwMax = Specifies the backing file maximum. The valid range is from 6 to 102, and the value must be at least 2
    ///            greater than <i>dwMin</i>.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The StreamBufferConfig object was not initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetBackingFileCount(uint dwMin, uint dwMax);
    ///The <b>GetBackingFileCount</b> method retrieves the maximum and minimum number of backing files.
    ///Params:
    ///    pdwMin = Pointer to a variable that receives the backing file minimum.
    ///    pdwMax = Pointer to a variable that receives the backing file maximum.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetBackingFileCount(uint* pdwMin, uint* pdwMax);
    ///The <b>SetBackingFileDuration</b> method sets the duration of all backing files.
    ///Params:
    ///    dwSeconds = Specifies the file duration, in seconds. The minimum value is 15.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The StreamBufferConfig object was not initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetBackingFileDuration(uint dwSeconds);
    ///The <b>GetBackingFileDuration</b> method retrieves the duration of each backing file.
    ///Params:
    ///    pdwSeconds = Pointer to a variable that receives the file duration, in seconds.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetBackingFileDuration(uint* pdwSeconds);
}

///The <b>IStreamBufferConfigure2</b> interface is exposed by the StreamBufferConfig object.
@GUID("53E037BF-3992-4282-AE34-2487B4DAE06B")
interface IStreamBufferConfigure2 : IStreamBufferConfigure
{
    ///The <b>SetMultiplexedPacketSize</b> method sets the size of the multiplexed packets in the backing files for the
    ///Stream Buffer Engine.
    ///Params:
    ///    cbBytesPerPacket = Specifies the packet size, in bytes. The value must be between 8192 and 65535, inclusive. The default value
    ///                       is 65535.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetMultiplexedPacketSize(uint cbBytesPerPacket);
    ///The <b>GetMultiplexedPacketSize</b> method returns the size of the multiplexed packets in the backing files for
    ///the Stream Buffer Engine.
    ///Params:
    ///    pcbBytesPerPacket = Receives the packet size, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetMultiplexedPacketSize(uint* pcbBytesPerPacket);
    ///The <b>SetFFTransitionRates</b> method sets the behavior of fast-forward play ("trick mode") in the Stream Buffer
    ///Engine.
    ///Params:
    ///    dwMaxFullFrameRate = Maximum playback rate for full-frame playback. The value must be greater than 1. The default value is 4.
    ///    dwMaxNonSkippingRate = Maximum playback rate for key-frame playback. The value must be greater than <i>dwFullFrameRate</i>. The
    ///                           default value is 6.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetFFTransitionRates(uint dwMaxFullFrameRate, uint dwMaxNonSkippingRate);
    ///The <b>GetFFTransitionRates</b> method returns the maximum full-frame and key-frame playback rates.
    ///Params:
    ///    pdwMaxFullFrameRate = Receives the maximum full-frame playback rate. At higher playback rates, only key frames are sent.
    ///    pdwMaxNonSkippingRate = Receives the maximum key-frame playback rate. At higher playback rates, some key frames are skipped. The
    ///                            number of key frames that are skipped is proportional to the rate.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetFFTransitionRates(uint* pdwMaxFullFrameRate, uint* pdwMaxNonSkippingRate);
}

///The <b>IStreamBufferConfigure3</b> interface is exposed by the StreamBufferConfig object.
@GUID("7E2D2A1E-7192-4BD7-80C1-061FD1D10402")
interface IStreamBufferConfigure3 : IStreamBufferConfigure2
{
    ///The <b>SetStartRecConfig</b> method specifies whether the IStreamBufferRecordControl::Start method automatically
    ///stops the current recording.
    ///Params:
    ///    fStartStopsCur = If <b>TRUE</b>, the <b>Start</b> method automatically stops the current recording. Otherwise, the
    ///                     <b>Start</b> method fails if another recording is in progress. The default value is <b>FALSE</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetStartRecConfig(BOOL fStartStopsCur);
    ///The <b>GetStartRecConfig</b> method queries whether the IStreamBufferRecordControl::Start method automatically
    ///stops the current recording.
    ///Params:
    ///    pfStartStopsCur = Receives a Boolean value. If <b>TRUE</b>, the <b>Start</b> method automatically stops the current recording.
    ///                      Otherwise, the <b>Start</b> method fails if another recording is in progress.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetStartRecConfig(int* pfStartStopsCur);
    ///The <b>SetNamespace</b> method specifies a prefix that is added to the names of the synchronization objects that
    ///the Stream Buffer Engine uses to synchronize the reader and writer.
    ///Params:
    ///    pszNamespace = Pointer to a null-terminated wide character string. If <b>NULL</b>, no prefix is used. Currently, the
    ///                   following values are supported. <ul> <li>L"Global"</li> <li><b>NULL</b></li> </ul>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CO_E_NOT_SUPPORTED</b></dt> </dl> </td> <td width="60%"> The specified prefix is not supported.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetNamespace(const(wchar)* pszNamespace);
    ///The <b>GetNamespace</b> method retrieves the prefix that is added to the names of the synchronization objects
    ///that the Stream Buffer Engine uses to synchronize the reader and writer.
    ///Params:
    ///    ppszNamespace = Receives a pointer to a null-terminated, wide-character string. The caller must free the string by calling
    ///                    <b>CoTaskMemFree</b>. If no prefix is defined, this variable receives a <b>NULL</b> pointer.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetNamespace(ushort** ppszNamespace);
}

///The <b>IStreamBufferMediaSeeking</b> interface controls seeking in a stream buffer source graph. The Stream Buffer
///Source filter exposes this interface. The methods in this interface have exactly the same names and parameters as
///those in the IMediaSeeking interface. To seek within a stream buffer file, use this interface directly on the source
///filter instead of calling <b>IMediaSeeking</b> methods on the filter graph.
@GUID("F61F5C26-863D-4AFA-B0BA-2F81DC978596")
interface IStreamBufferMediaSeeking : IMediaSeeking
{
}

///The <b>IStreamBufferMediaSeeking2</b> interface is exposed by the Stream Buffer Source filter. It provides a method
///to control the frame rate during fast-forward play ("trick mode").
@GUID("3A439AB0-155F-470A-86A6-9EA54AFD6EAF")
interface IStreamBufferMediaSeeking2 : IStreamBufferMediaSeeking
{
    ///The <b>SetRateEx</b> method sets the playback rate, and sets the frame rate for fast-forward play ("trick mode").
    ///Params:
    ///    dRate = Playback rate. Valid range is (<i>dRate</i> &gt;= 0.1 || <i>dRate</i> &lt;= -0.1).
    ///    dwFramesPerSec = Frames per second for fast-forward play. Cannot be zero. See Remarks for more information.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetRateEx(double dRate, uint dwFramesPerSec);
}

///The <b>IStreamBufferDataCounters</b> interface returns performance statistics for the Stream Buffer filters. This
///interface is exposed by the pins on the Stream Buffer Sink filter and the Stream Buffer Source filter.
@GUID("9D2A2563-31AB-402E-9A6B-ADB903489440")
interface IStreamBufferDataCounters : IUnknown
{
    ///The <b>GetData</b> method returns performance data for the Stream Buffer Engine.
    ///Params:
    ///    pPinData = Pointer to an SBE_PIN_DATA structure. The method fills the structure with the current performance data.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetData(SBE_PIN_DATA* pPinData);
    ///The <b>ResetData</b> method resets the Stream Buffer Engine's performance counters to zero.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ResetData();
}

///Offers access to global spanning events and their data from the Stream Buffer Source filters. A <i>global spanning
///event</i> contains state information that applies to all the streams in a pipeline.
@GUID("CAEDE759-B6B1-11DB-A578-0018F3FA24C6")
interface ISBE2GlobalEvent : IUnknown
{
    ///Gets a global spanning event and its data from a Stream Buffer Source filter.
    ///Params:
    ///    idEvt = GUID identifying the event.
    ///    param1 = First event-specific parameter.
    ///    param2 = Second event-specific parameter.
    ///    param3 = Third event-specific parameter.
    ///    param4 = Fourth event-specific parameter.
    ///    pSpanning = Receives a flag indicating whether the event is a spanning event.
    ///    pcb = Pointer to a value specifying the buffer size. If the <i>pb</i> parameter is <b>NULL</b>, this parameter
    ///          returns the required buffer size.
    ///    pb = Pointer to a buffer that receives the event data. If this parameter is <b>NULL</b>, the <i>pcb</i> parameter
    ///         returns the required buffer size. The structure of the event data depends on the event type. For a list of
    ///         event types, see the description of the ISBE2SpanningEvent::GetEvent method.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following: <table> <tr> <th>Return value</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt>ERROR_INSUFFICIENT_BUFFER</dt> </dl> </td> <td width="60%"> Buffer
    ///    was too small to hold event data. </td> </tr> <tr> <td width="40%"> <dl> <dt>ERROR_CONTEXT_EXPIRED</dt> </dl>
    ///    </td> <td width="60%"> Too much time elapsed between the broadcast event and the call to retrieve it. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetEvent(const(GUID)* idEvt, uint param1, uint param2, uint param3, uint param4, int* pSpanning, 
                     uint* pcb, char* pb);
}

///Offers access to global spanning events and their data from the Stream Buffer Source filters. A <i>global spanning
///event</i> contains state information that applies to all the streams in a pipeline. This interface extends the
///ISBE2GlobalEvent interface.
@GUID("6D8309BF-00FE-4506-8B03-F8C65B5C9B39")
interface ISBE2GlobalEvent2 : ISBE2GlobalEvent
{
    ///Gets a global spanning event and its data from a Stream Buffer Source filter.
    ///Params:
    ///    idEvt = GUID identifying the event.
    ///    param1 = First event-specific parameter.
    ///    param2 = Second event-specific parameter.
    ///    param3 = Third event-specific parameter.
    ///    param4 = Fourth event-specific parameter.
    ///    pSpanning = Receives a flag indicating whether the event is a spanning event.
    ///    pcb = Pointer to a value specifying the buffer size. If the <i>pb</i> parameter is <b>NULL</b>, this parameter
    ///          returns the required buffer size.
    ///    pb = Pointer to a buffer that receives the event data. If this parameter is <b>NULL</b>, the <i>pcb</i> parameter
    ///         returns the required buffer size. The structure of the event data depends on the event type. For a list of
    ///         event types, see the description of the ISBE2SpanningEvent::GetEvent method.
    ///    pStreamTime = Stream time of last data sample that was read from the file before the event.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEventEx(const(GUID)* idEvt, uint param1, uint param2, uint param3, uint param4, int* pSpanning, 
                       uint* pcb, char* pb, long* pStreamTime);
}

///Implements in-band spanning events for the Stream Buffer Engine, version 2 (SBE2). An <i>in-band spanning event</i>
///is an in-band event that can be recorded as part of the state information in a stream. Spanning events have a defined
///validity period within a Stream Buffer Interface file and may be recovered after a seek operation, updated, or
///deleted. Spanning events are intended for data with a defined lifespan, such as Digital Rights Management (DRM) keys
///or ratings information.
@GUID("CAEDE760-B6B1-11DB-A578-0018F3FA24C6")
interface ISBE2SpanningEvent : IUnknown
{
    ///Gets an in-band spanning event and event data from the Stream Buffer Engine, version 2 (SBE2). An <i>in-band
    ///spanning event</i> is an event that exists until it is replaced or erased, and is part of the state for events
    ///that appear later in the same stream.
    ///Params:
    ///    idEvt = GUID identifying the spanning event type.
    ///    streamId = Identifies the stream containing the spanning event.
    ///    pcb = Pointer to a value that gets the size of the event data buffer. If the <i>pb</i> parameter is <b>NULL</b>,
    ///          this parameter returns the required buffer size.
    ///    pb = Pointer to a buffer that gets the event data. If this parameter is <b>NULL</b>, the <i>pcb</i> parameter
    ///         returns the required buffer size. The structure of the event data depends on the event type.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEvent(const(GUID)* idEvt, uint streamId, uint* pcb, char* pb);
}

///Defines crossbar functionality for a Stream Buffer Engine (SBE) version 2 (SBE2) Stream Buffer Source filter. A
///<i>crossbar</i> offers the following new features for the Stream Buffer Source filter in Windows 7: <ul> <li>It lets
///you predefine a collection of media streams that reside in a WTV file and map those streams to the filter's output
///pins. One of those collections is known as a <i>profile</i>, and a single mapping between a stream and an output pin
///is known as a <i>stream mapping</i>.</li> <li>It lets you define which profile and which stream mappings to use for
///the filter when the media graph first starts running.</li> <li>It lets you change the profile and stream mappings
///while the graph is running.</li> </ul> The <b>ISBE2Crossbar</b> interface is implemented by the Stream Buffer Source
///filter.
@GUID("547B6D26-3226-487E-8253-8AA168749434")
interface ISBE2Crossbar : IUnknown
{
    ///Enables or disables the profile default mode and stream default mode for a crossbar in a Stream Buffer Source
    ///filter. The <i>profile</i> describes a set of media types that can be used to create out pins, one media type per
    ///output pin. The <i>stream mapping</i> describes the mappings between the streams within a WTV file and filter
    ///output pins. If you do not call the <b>EnableDefaultMode</b> method in your application, the crossbar uses a
    ///default profile and a default stream map. In this case, the crossbar is said to be in <i>profile default mode</i>
    ///and <i>stream default mode</i>, respectively. You can use the <b>EnableDefaultMode</b> method to disable either
    ///mode or both modes, so that you can specify custom profiles or stream mappings. You can also use an
    ///<code>EnableDefaultMode(FALSE)</code> call to disable both default modes.
    ///Params:
    ///    DefaultFlags = Specifies the default modes for the crossbar. This can be any combination of the following values. <table>
    ///                   <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>DEF_MODE_PROFILE</dt> </dl> </td>
    ///                   <td width="60%"> Enables profile default mode. The default profile is used, and you cannot specify custom
    ///                   profiles by calling the SetOutputProfile method. If you omit this flag, profile default mode is disabled so
    ///                   that you can specify a custom output profile. </td> </tr> <tr> <td width="40%"> <dl>
    ///                   <dt>DEF_MODE_STREAMS</dt> </dl> </td> <td width="60%"> Enables stream default mode. The Stream Buffer Enging
    ///                   (SBE) handles the mapping between streams and output pins, and you cannot change these mappings by calling
    ///                   the ISBE2StreamMap::MapStream method. If you omit this flag, stream default mode is disabled, so that you can
    ///                   specify a custom mapping. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnableDefaultMode(uint DefaultFlags);
    ///Gets the initial profile that lists the media types that are present in the currently loaded WTV file. The media
    ///types in the profile correspond to the active pins on a Stream Buffer Source filter at the time the currently
    ///loaded WTV file is created. The profile is fixed per loaded WTV file and does not change while the filter has a
    ///WTV file loaded . However, if the crossbar is not in default profile mode, you can call the SetOutputProfile
    ///method to set a new profile for the crossbar. To disable default profile mode, call the EnableDefaultMode method
    ///without the DEF_MODE_PROFILE flag.
    ///Params:
    ///    ppProfile = Receives a pointer to the ISBE2MediaTypeProfile interface that implements the profile. The caller is
    ///                responsible for releasing this interface. You can use this pointer to create a custom profile that you pass
    ///                to the SetOutputProfile method.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return value</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt>E_POINTER</dt> </dl> </td> <td width="60%"> Null pointer argument.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt>E_FAIL</dt> </dl> </td> <td width="60%"> Empty initial profiles.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetInitialProfile(ISBE2MediaTypeProfile* ppProfile);
    ///Replaces the default or current input profile with the profile specified in this method. You can discover the
    ///current input profile by calling the GetInitialProfile method. This profile can be changed over time as media
    ///types are updated on input to the Stream Buffer Source filter. A custom profile can contain only one stream per
    ///major media type. For example, a custom profile can contain only a single audio stream. By default, the filter
    ///crossbar has profile default mode enabled, which means that you cannot set a custom output profile. Before you
    ///can set a custom output profile, you must disable profile default mode by calling the EnableDefaultMode method
    ///without the DEF_MODE_PROFILE flag.
    ///Params:
    ///    pProfile = Pointer to the ISBE2MediaTypeProfile interface for the profile that replaces the crossbar default profile.
    ///    pcOutputPins = On input, specifies the size of an array allocated to receive IPin pointers for the output pins that
    ///                   correspond to the streams in the new profile. The <i>ppOutputPins</i> parameter points to this array. On
    ///                   output, if the call succeeds, gets the actual number of <b>IPin</b> pointers returned in the
    ///                   <i>ppOutputPins</i> output parameter.
    ///    ppOutputPins = On input, specifies a pointer to an array of uninitialized IPin pointers. On output, if the call succeeds,
    ///                   the <b>IPin</b> pointers in the array are initialized to point to the filter output pins that have the media
    ///                   types listed in the new profile. The <i>pcOutputPins</i> parameter gives the number of elements in the array.
    ///                   The caller is responsible for freeing the <b>IPin</b> interface pointers returned in the array.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return value</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt>E_INVALIDARG</dt> </dl> </td> <td width="60%"> The <i>pProfile</i>
    ///    parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt>E_POINTER</dt> </dl> </td> <td
    ///    width="60%"> The <i>pcOutputPins</i> parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt>E_UNEXPECTED</dt> </dl> </td> <td width="60%"> Cannot set output profile because profile default mode is
    ///    enabled. </td> </tr> </table>
    ///    
    HRESULT SetOutputProfile(ISBE2MediaTypeProfile pProfile, uint* pcOutputPins, IPin* ppOutputPins);
    ///Gets an enumeration object for all streams that are discovered in a WTV file. The filter crossbar, which exposes
    ///the ISBE2Crossbar interface, manages the mappings between the streams in the WTV file and the filter output pins.
    ///The WTV file format supports dynamic creation and deletion of streams within the file. An SBE2_STREAM_DESC global
    ///spanning event in the file signals when a stream is created or deleted.
    ///Params:
    ///    ppStreams = Receives a pointer to the ISBE2EnumStream interface that the crossbar implements. You can use the methods
    ///                that are defined by the <b>ISBE2EnumStream</b> interface to enumerate the streams that can be mapped to
    ///                output pins in the current profile. The caller is responsible for releasing the interface.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return value</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt>E_POINTER</dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt>E_FAIL</dt> </dl> </td> <td width="60%"> No streams
    ///    found. </td> </tr> </table>
    ///    
    HRESULT EnumStreams(ISBE2EnumStream* ppStreams);
}

///Handles the mapping between output pins and streams for the Stream Buffer Source filter. This interface is
///implemented by the output pins of the Stream Buffer Source filter. To get a pointer to the interface, query the
///output pin.
@GUID("667C7745-85B1-4C55-AE55-4E25056159FC")
interface ISBE2StreamMap : IUnknown
{
    ///Maps a stream to an output pin for a Stream Buffer Source filter. By default, the stream mappings cannot be
    ///changed. Before calling this method, disable the default mapping mode by calling the
    ///ISBE2Crossbar::EnableDefaultMode method without the <b>DEF_MODE_STREAMS</b> flag.
    ///Params:
    ///    Stream = Identifier for the stream mapped to an output pin. The major type of the stream must match the major type of
    ///             the pin.
    ///Returns:
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The specified stream has already been mapped to a pin.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Cannot unmap
    ///    the stream, because the default mode is enabled. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>HRESULT_FROM_WIN32 (ERROR_NOT_FOUND)</b></dt> <dt>0x80070490</dt> </dl> </td> <td width="60%"> No
    ///    stream exists with the specified stream identifier. </td> </tr> </table>
    ///    
    HRESULT MapStream(uint Stream);
    ///Removes the mapping between a stream and an output pin for a Stream Buffer Source filter. After a successful call
    ///to this method, the output pin stops sending media samples. To resume sending media samples, the pin must be
    ///mapped to another stream by a call to the MapStream method. By default, the stream mappings cannot be changed.
    ///Before calling this method, disable the default mapping mode by calling the ISBE2Crossbar::EnableDefaultMode
    ///method without the <b>DEF_MODE_STREAMS</b> flag.
    ///Params:
    ///    Stream = Identifier for the stream. This stream will be unmapped from the output pin.
    ///Returns:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The specified stream does not exist or was not
    ///    previously mapped to a pin. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Cannot unmap the stream, because the default mode is enabled. </td> </tr> </table>
    ///    
    HRESULT UnmapStream(uint Stream);
    ///Enumerates streams that are mapped to output pins in a Stream Buffer Source filter.
    ///Params:
    ///    ppStreams = Receives a pointer to the ISBE2EnumStream interface for an enumeration object that lists all streams mapped
    ///                to the filter outputs pin. The caller is responsible for freeing the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnumMappedStreams(ISBE2EnumStream* ppStreams);
}

///Enumerates a collection of streams. This is a utility interface, which you can use to enumerate the streams
///discovered in a WTV file. The Stream Buffer Source filter implements this interface. To get a pointer to this
///interface, <ol> <li>Query the filter to get a pointer to the ISBE2Crossbar interface.</li> <li>Call the
///ISBE2Crossbar::EnumStreams method, and take the value returned in the <i>ppstreams</i> output parameter.</li> </ol>
@GUID("F7611092-9FBC-46EC-A7C7-548EA78B71A4")
interface ISBE2EnumStream : IUnknown
{
    ///Retrieves the next <i>n</i> streams in the collection.
    ///Params:
    ///    cRequest = The number of streams to retrieve.
    ///    pStreamDesc = Pointer to an array of SBE2_STREAM_DESC structures, with at least <i>cRequest</i> elements. The method copies
    ///                  up to <i>cRequest</i> elements into the array.
    ///    pcReceived = Receives the number of elements returned in the <i>pStreamDesc</i> array. This parameter can be <b>NULL</b>
    ///                 if <i>cRequest</i> is 1.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded and
    ///    retrieved <i>cRequest</i> elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_FALSE</b></b></dt>
    ///    </dl> </td> <td width="60%"> The method retrieved fewer elements than requested. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The streams have changed, so the caller
    ///    must enumerate them again. </td> </tr> </table>
    ///    
    HRESULT Next(uint cRequest, char* pStreamDesc, uint* pcReceived);
    ///Skips a specified number of streams in the enumeration sequence.
    ///Params:
    ///    cRecords = The number of streams to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_FALSE</b></b></dt> </dl> </td> <td width="60%"> The end of the
    ///    sequence was reached before skipping the requested number of streams. </td> </tr> </table>
    ///    
    HRESULT Skip(uint cRecords);
    ///Resets the enumeration sequence to the beginning.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Reset();
    ///Creates a copy of the enumerator object. The copy starts with the same enumeration state as the original.
    ///Params:
    ///    ppIEnumStream = Receives a pointer to the ISBE2EnumStream interface of the new enumerator object. This method allocates
    ///                    memory for the stream enumeration object. The caller is responsible for releasing the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_POINTER</b></b></dt> </dl> </td> <td width="60%"> Null pointer
    ///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_OUTOFMEMORY</b></b></dt> </dl> </td> <td
    ///    width="60%"> Out of memory for enumeration object. </td> </tr> </table>
    ///    
    HRESULT Clone(ISBE2EnumStream* ppIEnumStream);
}

///Implements a media type profile. A <i>media type profile</i> describes a set of streams and their media types, which
///are used when output pins for a Stream Buffer Source filter are created to specify the media types supported by those
///pins. The Stream Buffer Source filter implements the ISBE2Crossbar interface, which you can use to set the media type
///profile for the filter. To obtain a pointer to the <b>ISBE2MediaTypeProfile</b> interface, call the
///ISBE2Crossbar::GetInitialProfile method for the crossbar, and then use the value returned in the <i>ppProfile</i>
///output parameter.
@GUID("F238267D-4671-40D7-997E-25DC32CFED2A")
interface ISBE2MediaTypeProfile : IUnknown
{
    ///Gets the number of streams in a media type profile.
    ///Params:
    ///    pCount = Receives the number of streams in the profile.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_POINTER</b></b></dt> </dl> </td> <td width="60%"> Null pointer.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetStreamCount(uint* pCount);
    ///Gets the media type of a stream that appears at a specific index in a media type profile.
    ///Params:
    ///    Index = The index of the stream. To get the number of the streams in the profile, call the
    ///            ISBE2MediaTypeProfile::GetStreamCount method.
    ///    ppMediaType = Receives a pointer to an AM_MEDIA_TYPE structure. The caller must not modify this structure or release the
    ///                  memory allocated for it.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td width="60%"> Invalid
    ///    parameter. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_OUTOFMEMORY</b></b></dt> </dl> </td> <td
    ///    width="60%"> Not enough memory for media type pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>E_POINTER</b></b></dt> </dl> </td> <td width="60%"> Null media type pointer. </td> </tr> </table>
    ///    
    HRESULT GetStream(uint Index, AM_MEDIA_TYPE** ppMediaType);
    ///Adds a stream to a media type profile.
    ///Params:
    ///    pMediaType = Pointer to an AM_MEDIA_TYPE structure that specifies the media type of the stream that is added to the
    ///                 profile.
    ///Returns:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td width="60%"> Invalid parameter. </td>
    ///    </tr> </table>
    ///    
    HRESULT AddStream(AM_MEDIA_TYPE* pMediaType);
    ///Removes a stream from a media type profile.
    ///Params:
    ///    Index = The index of the stream to remove. To get the number of the streams in the profile, call the
    ///            ISBE2MediaTypeProfile::GetStreamCount method.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td width="60%"> Invalid
    ///    parameter. </td> </tr> </table>
    ///    
    HRESULT DeleteStream(uint Index);
}

///Repairs a corrupted .WTV file. The FileScan object implements this interface.
@GUID("3E2BF5A5-4F96-4899-A1A3-75E8BE9A5AC0")
interface ISBE2FileScan : IUnknown
{
    ///Repairs a corrupted .WTV file. You can use this method if you discover possible corruption in a .WTV file and
    ///want to restore the last-known good version of the file. The following situations might result in a corrupted
    ///file: <ul> <li>A process that was creating the file crashed.</li> <li>Another process was writing to the file
    ///(for example, to update metadata) at the same time that the Stream Buffer Engine (SBE) attempted to repair it.
    ///SBE tries to fix corrupted .WTV files automatically every time it loads a .WTV file for playback and discovers
    ///errors in the file.</li> </ul>
    ///Params:
    ///    filename = A pointer to a null-terminated wide-character string that specifies the full path name of the .WTV file.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return value</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt>E_POINTER</dt> </dl> </td> <td width="60%"> Null pointer argument.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt>INVALID_HANDLE_VALUE</dt> </dl> </td> <td width="60%"> Invalid
    ///    .WTV file. </td> </tr> </table>
    ///    
    HRESULT RepairFile(const(wchar)* filename);
}

///The <b>IMpeg2TableFilter</b> interface controls which tables are parsed by the MPEG-2 Sections and Tables filter. The
///BDA MPEG-2 Transport Information filter exposes this interface on its output pins.
@GUID("BDCDD913-9ECD-4FB2-81AE-ADF747EA75A5")
interface IMpeg2TableFilter : IUnknown
{
    ///The <b>AddPID</b> method adds a packet identifier (PID) to the list of PIDs that the filter sends.
    ///Params:
    ///    p = Specifies the PID of the transport stream packets to examine.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT AddPID(ushort p);
    ///The <b>AddTable</b> method adds a table identifier (TID) to the list of MPEG-2 table sections that the filter
    ///sends.
    ///Params:
    ///    p = Specifies the packet identifier (PID) of the transport stream packets to examine.
    ///    t = Specifies the TID of the section to retrieve.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT AddTable(ushort p, ubyte t);
    ///The <b>AddExtension</b> method adds a table extension to the list of MPEG-2 table sections that the filter sends.
    ///Params:
    ///    p = Specifies the packet identifier (PID) of the transport stream packets to examine.
    ///    t = Specifies the table identifier (TID) of the section to retrieve.
    ///    e = Specifies the table_extension identifier of the section to retrieve.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT AddExtension(ushort p, ubyte t, ushort e);
    ///The <b>RemovePID</b> method removes a packet identifier (PID) from the list of PIDs that the filter sends.
    ///Params:
    ///    p = Specifies the PID to remove from the list.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT RemovePID(ushort p);
    ///The <b>RemoveTable</b> method removes a table identifier (TID) from the list of MPEG-2 table sections that the
    ///filter sends.
    ///Params:
    ///    p = Specifies the packet identifier (PID) of the table.
    ///    t = Specifies the TID to remove from the list.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT RemoveTable(ushort p, ubyte t);
    ///The <b>RemoveExtension</b> method removes a table extension from the list of MPEG-2 table sections that the
    ///filter sends.
    ///Params:
    ///    p = Specifies the packet identifier (PID) of the table.
    ///    t = Specifies the table identifier (TID) of the table.
    ///    e = Specifies the table_extension identifier to remove from the list.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an error code.
    ///    
    HRESULT RemoveExtension(ushort p, ubyte t, ushort e);
}

///<p class="CCE_Message">[<b>IMpeg2Data</b> is no longer available for use as of Windows 7. Instead, use the IPSITables
///interface to get program specific information (PSI) tables from an MPEG-2 transport stream.] The <b>IMpeg2Data</b>
///interface is exposed by the MPEG-2 Sections and Tables filter. It enables the client to retrieve unparsed sections or
///tables from an MPEG-2 transport stream.
@GUID("9B396D40-F380-4E3C-A514-1A82BF6EBFE6")
interface IMpeg2Data : IUnknown
{
    ///<p class="CCE_Message">[<b>GetSection</b> is no longer available for use as of Windows 7. Instead, use the
    ///IPSITables interface to get program specific information (PSI) tables from an MPEG-2 transport stream.] The
    ///<b>GetSection</b> method retrieves an MPEG-2 table section. This method blocks until the filter receives a
    ///matching table section, or until the specified time out elapses.
    ///Params:
    ///    pid = Specifies the packet identifier (PID) of the transport stream packets to examine.
    ///    tid = Specifies the table identifier (TID) of the section to retrieve.
    ///    pFilter = Optional pointer to an MPEG2_FILTER structure. The caller can use this parameter to exclude packets based on
    ///              additional MPEG-2 header fields. This parameter can be <b>NULL</b>.
    ///    dwTimeout = Specifies a time-out value, in milliseconds. If the filter does not receive a matching section within the
    ///                time-out period, the method fails.
    ///    ppSectionList = Pointer to a variable that receives an ISectionList interface pointer. Use this interface to retrieve the
    ///                    section data. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive a matching
    ///    table section. </td> </tr> </table>
    ///    
    HRESULT GetSection(ushort pid, ubyte tid, MPEG2_FILTER* pFilter, uint dwTimeout, ISectionList* ppSectionList);
    ///<p class="CCE_Message">[<b>GetTable</b> is no longer available for use as of Windows 7. Instead, use the
    ///IPSITables interface to get program specific information (PSI) tables from an MPEG-2 transport stream.] Retrieves
    ///a complete MPEG-2 PSI table. This method blocks until the filter receives all of the sections that make up the
    ///requested table, or until the specified time out elapses.
    ///Params:
    ///    pid = Specifies the packet identifier (PID) of the transport stream packets to examine.
    ///    tid = Specifies the table identifier (TID) of the section to retrieve.
    ///    pFilter = Optional pointer to an MPEG2_FILTER structure. The caller can use this parameter to exclude packets based on
    ///              additional MPEG-2 header fields. This parameter can be <b>NULL</b>.
    ///    dwTimeout = Specifies a time-out value, in milliseconds. If the filter does not receive a matching section within the
    ///                time-out period, the method fails.
    ///    ppSectionList = Receives an ISectionList interface pointer. Use this interface to retrieve the section data. The caller must
    ///                    release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive a matching
    ///    table section. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTable(ushort pid, ubyte tid, MPEG2_FILTER* pFilter, uint dwTimeout, ISectionList* ppSectionList);
    ///<p class="CCE_Message">[<b>GetStreamOfSections</b> is no longer available for use as of Windows 7. Instead, use
    ///the IPSITables interface to get program specific information (PSI) tables from an MPEG-2 transport stream.] The
    ///<b>GetStreamOfSections</b> method starts an ongoing request for specific MPEG-2 table sections.
    ///Params:
    ///    pid = Specifies the packet identifier (PID) of the transport stream packets to examine.
    ///    tid = Specifies the table identifier (TID) of the section to retrieve.
    ///    pFilter = Optional pointer to an MPEG2_FILTER structure. The caller can use this parameter to exclude packets based on
    ///              additional MPEG-2 header fields. This parameter can be <b>NULL</b>.
    ///    hDataReadyEvent = Handle to an event created by the caller. The filter signals this event whenever it receives new data.
    ///    ppMpegStream = Pointer to a variable that receives an IMpeg2Stream interface pointer. The caller must release the interface.
    ///                   Use this interface to retrieve the data when it arrives.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetStreamOfSections(ushort pid, ubyte tid, MPEG2_FILTER* pFilter, HANDLE hDataReadyEvent, 
                                IMpeg2Stream* ppMpegStream);
}

///The <b>ISectionList</b> interface represents a list of MPEG-2 table sections.
@GUID("AFEC1EB5-2A64-46C6-BF4B-AE3CCB6AFDB0")
interface ISectionList : IUnknown
{
    ///The <b>Initialize</b> method initializes the object. This method should be called once, immediately after
    ///creating the object. The IMpeg2Data::GetSection and IMpeg2Data::GetTable methods call this method internally, so
    ///typically an application will not call it.
    ///Params:
    ///    requestType = Specifies the request type, as an MPEG_REQUEST_TYPE value.
    ///    pMpeg2Data = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///    pContext = Pointer to an MPEG_CONTEXT structure. This structure indicates the MPEG-2 source.
    ///    pid = Specifies a packet identifier (PID), indicating which packets in the transport stream are requested.
    ///    tid = Specifies a table identifier (TID), indicating which table sections to retrieve.
    ///    pFilter = Optional pointer to an MPEG2_FILTER structure. The caller can use this parameter to exclude packets based on
    ///              additional MPEG-2 header fields. This parameter can be <b>NULL</b>.
    ///    timeout = Specifies the maximum length of time that a synchronous request should wait before it times out.
    ///    hDoneEvent = Specifies a handle to an event. The object signals the event when the request completes. This parameter is
    ///                 optional; it should be specified for asynchronous requests.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object has already been
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    method succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(MPEG_REQUEST_TYPE requestType, IMpeg2Data pMpeg2Data, MPEG_CONTEXT* pContext, ushort pid, 
                       ubyte tid, MPEG2_FILTER* pFilter, uint timeout, HANDLE hDoneEvent);
    ///The <b>InitializeWithRawSections</b> method initializes the object with raw section data. This method allows for
    ///custom processing of section data.
    ///Params:
    ///    pmplSections = Pointer to an MPEG_PACKET_LIST structure that contains a list of MPEG-2 sections.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object has already been
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    method succeeded. </td> </tr> </table>
    ///    
    HRESULT InitializeWithRawSections(MPEG_PACKET_LIST* pmplSections);
    ///The <b>CancelPendingRequest</b> method cancels any pending asynchronous request.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CancelPendingRequest();
    ///The <b>GetNumberOfSections</b> method returns the number of MPEG-2 sections that were received.
    ///Params:
    ///    pCount = Receives the number of sections.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> The request has not completed yet. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetNumberOfSections(ushort* pCount);
    ///The <b>GetSectionData</b> method retrieves a section.
    ///Params:
    ///    sectionNumber = Specifies the section number to retrieve, indexed from zero. Call the <b>GetNumberOfSections</b> method to
    ///                    get the number of sections.
    ///    pdwRawPacketLength = Receives the size of the section data, in bytes.
    ///    ppSection = Address of a variable that receives a pointer to a <b>SECTION</b> structure, containing the section data. Do
    ///                not free the memory for the structure; the object frees the memory when the interface is released.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> The request has not completed yet. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> The section number is
    ///    out of range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSectionData(ushort sectionNumber, uint* pdwRawPacketLength, SECTION** ppSection);
    ///The <b>GetProgramIdentifier</b> method retrieves the program identifier (PID) of the packets that this object is
    ///receiving.
    ///Params:
    ///    pPid = Receives the PID.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProgramIdentifier(ushort* pPid);
    ///The <b>GetTableIdentifier</b> method returns the table identifier (TID) of the packets that this object is
    ///receiving.
    ///Params:
    ///    pTableId = Receives the TID.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTableIdentifier(ubyte* pTableId);
}

///The <b>IMpeg2Stream</b> interface represents a stream of MPEG-2 data. The IMpeg2Data::GetStreamOfSections method
///returns a pointer to this interface.
@GUID("400CC286-32A0-4CE4-9041-39571125A635")
interface IMpeg2Stream : IUnknown
{
    ///The <b>Initialize</b> method initializes the <b>MPEG2Stream</b> object. This method should be called once,
    ///immediately after creating the object. The IMpeg2Data::GetStreamOfSections method calls this method internally,
    ///so typically an application will not call it.
    ///Params:
    ///    requestType = Specifies the request type, as an MPEG_REQUEST_TYPE value.
    ///    pMpeg2Data = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///    pContext = Pointer to an MPEG_CONTEXT structure. This structure indicates the MPEG-2 source.
    ///    pid = Specifies a packet identifier (PID), indicating which packets in the transport stream are requested.
    ///    tid = Specifies a table identifier (TID), indicating which table sections to retrieve.
    ///    pFilter = Optional pointer to an MPEG2_FILTER structure. The caller can use this parameter to exclude packets based on
    ///              additional MPEG-2 header fields. This parameter can be <b>NULL</b>.
    ///    hDataReadyEvent = Handle to an event. The filter signals this event whenever it receives new data.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid or <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The method has
    ///    been called on this object already. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(MPEG_REQUEST_TYPE requestType, IMpeg2Data pMpeg2Data, MPEG_CONTEXT* pContext, ushort pid, 
                       ubyte tid, MPEG2_FILTER* pFilter, HANDLE hDataReadyEvent);
    ///The <b>SupplyDataBuffer</b> method provides a buffer for the <b>Mpeg2Stream</b> object to write data.
    ///Params:
    ///    pStreamBuffer = Pointer to an MPEG_STREAM_BUFFER structure allocated by the caller. This structure contains a pointer to the
    ///                    buffer, also allocated by the caller. The buffer must be at least 4096 bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument or <b>NULL</b> parameter. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> </table>
    ///    
    HRESULT SupplyDataBuffer(MPEG_STREAM_BUFFER* pStreamBuffer);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
///<b>IGenericDescriptor</b> enables the client to get an MPEG-2 descriptor in an unparsed format. See ISO/IEC 1318-1
///for the MPEG-2 descriptor specifications. See ETSI EN 300 468 for the DVB descriptor specifications.
@GUID("6A5918F8-A77A-4F61-AED0-5702BDCDA3E6")
interface IGenericDescriptor : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>Initialize</b>
    ///method initializes the object. This method is called internally by the various methods that return
    ///<b>IGenericDescriptor</b> interface pointers, so applications typically should not call it.
    ///Params:
    ///    pbDesc = Pointer to a buffer that contains the raw descriptor data.
    ///    bCount = Specifies the size of the buffer, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td width="60%">
    ///    Invalid or malformed descriptor. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ubyte* pbDesc, int bCount);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>GetTag</b>
    ///method returns the descriptor tag.
    ///Params:
    ///    pbVal = Receives the tag.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>GetLength</b>
    ///method returns the length of the descriptor body.
    ///Params:
    ///    pbVal = Receives the length, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>GetBody</b>
    ///method returns the body of the descriptor.
    ///Params:
    ///    ppbVal = Receives a pointer to a buffer. To get the size of the buffer, call the IGenericDescriptor::GetLength method.
    ///             The buffer contains the body of the descriptor, in network byte order (Big Endian). The caller is responsible
    ///             for converting the data to Little Endian byte order. The caller must free the buffer by calling the
    ///             <b>CoTaskMemFree</b> function.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetBody(ubyte** ppbVal);
}

@GUID("BF02FB7E-9792-4E10-A68D-033A2CC246A5")
interface IGenericDescriptor2 : IGenericDescriptor
{
    HRESULT Initialize(ubyte* pbDesc, ushort wCount);
    HRESULT GetLength(ushort* pwVal);
}

///The <b>IPAT</b> interface enables the client to get information from a Program Association Table (PAT). The
///IAtscPsipParser::GetPAT method returns a pointer to this interface.
@GUID("6623B511-4B5F-43C3-9A01-E8FF84188060")
interface IPAT : IUnknown
{
    ///The <b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IAtscPsipParser::GetPAT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///The <b>GetTransportStreamId</b> method returns the transport stream identifier (TSID) for the PAT.
    ///Params:
    ///    pwVal = Receives the transport_stream_id field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTransportStreamId(ushort* pwVal);
    ///The <b>GetVersionNumber</b> method returns the version number for the PAT.
    ///Params:
    ///    pbVal = Receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///The <b>GetCountOfRecords</b> method returns the number of records in the PAT. Each record corresponds to one
    ///program.
    ///Params:
    ///    pdwVal = Receives the number of records.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///The <b>GetRecordProgramNumber</b> method retrieves a program number from the PAT.
    ///Params:
    ///    dwIndex = Specifies the record to retrieve, indexed from zero. Call the IPAT::GetCountOfRecords method to get the
    ///              number of records in the PAT.
    ///    pwVal = Receives the program number.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordProgramNumber(uint dwIndex, ushort* pwVal);
    ///The <b>GetRecordProgramMapPid</b> method returns the packet identifier (PID) for a given record in the PAT.
    ///Params:
    ///    dwIndex = Specifies the record to retrieve, indexed from zero. Call the IPAT::GetCountOfRecords method to get the
    ///              number of records in the PAT.
    ///    pwVal = Receives the PID. This value identifies the PID for the packets that contain the program map table (PMT) of
    ///            the associated program.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordProgramMapPid(uint dwIndex, ushort* pwVal);
    ///The <b>FindRecordProgramMapPid</b> method returns the packet identifier (PID) for the program map table (PMT)
    ///associated with a given program number.
    ///Params:
    ///    wProgramNumber = Specifies the program number.
    ///    pwVal = Receives the PID.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The table does not contain the specified
    ///    program number. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    method succeeded. </td> </tr> </table>
    ///    
    HRESULT FindRecordProgramMapPid(ushort wProgramNumber, ushort* pwVal);
    ///The <b>RegisterForNextTable</b> method registers the client to be notified when a <i>next</i> table arrives that
    ///will replace the current table.
    ///Params:
    ///    hNextTableAvailable = Handle to an event created by the caller. The object signals the event when the <i>next</i> table arrives.
    ///                          When the event is signaled, call the IPAT::GetNextTable method to retrieve the table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>next</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableAvailable</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForNextTable(HANDLE hNextTableAvailable);
    ///The <b>GetNextTable</b> method retrieves the <i>next</i> table that follows the current table.
    ///Params:
    ///    ppPAT = Address of a variable that receives an <b>IPAT</b> interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is not current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetNextTable(IPAT* ppPAT);
    ///The <b>RegisterForWhenCurrent</b> method registers the client to be notified when the table becomes current.
    ///Params:
    ///    hNextTableIsCurrent = Handle to an event created by the caller. The object signals the event when the table becomes current.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>current</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableIsCurrent</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForWhenCurrent(HANDLE hNextTableIsCurrent);
    ///The <b>ConvertNextToCurrent</b> method converts a <i>next</i> table to a <i>current</i> table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <b>RegisterForWhenCurrent</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The new <i>current</i> table is malformed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ConvertNextToCurrent();
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The <b>ICAT</b>
///interface enables the client to get data from a conditional access table (CAT). The IAtscPsipParser::GetCAT method
///returns a pointer to this interface.
@GUID("7C6995FB-2A31-4BD7-953E-B1AD7FB7D31C")
interface ICAT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IAtscPsipParser::GetCAT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVersionNumber</b> method returns the version number for the CAT.
    ///Params:
    ///    pbVal = Receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfTableDescriptors</b> method returns the number of descriptors in the CAT.
    ///Params:
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfTableDescriptors(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByIndex</b> method retrieves a table descriptor for the CAT.
    ///Params:
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the ICAT::GetCountOfTableDescriptors method
    ///              to get the number of table descriptors in the CAT.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTableDescriptorByIndex(uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByTag</b> method searches the CAT for a descriptor with the specified descriptor tag.
    ///Params:
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTableDescriptorByTag(ubyte bTag, uint* pdwCookie, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>RegisterForNextTable</b> method registers the client to be notified when a <i>next</i> table arrives that will
    ///replace the current table.
    ///Params:
    ///    hNextTableAvailable = Handle to an event created by the caller. The object signals the event when the <i>next</i> table arrives.
    ///                          When the event is signaled, call the ICAT::GetNextTable method to retrieve the table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>next</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableAvailable</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForNextTable(HANDLE hNextTableAvailable);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetNextTable</b> method retrieves the <i>next</i> table that follows the current table.
    ///Params:
    ///    dwTimeout = Specifies a time-out value, in milliseconds. If the filter does not receive the data within the time-out
    ///                period, the method fails.
    ///    ppCAT = Receives a pointer to the <b>ICAT</b> interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is not current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetNextTable(uint dwTimeout, ICAT* ppCAT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>RegisterForWhenCurrent</b> method registers the client to be notified when the table becomes current.
    ///Params:
    ///    hNextTableIsCurrent = Handle to an event created by the caller. The object signals the event when the table becomes current.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>current</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableIsCurrent</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForWhenCurrent(HANDLE hNextTableIsCurrent);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>ConvertNextToCurrent</b> method converts a <i>next</i> table to a <i>current</i> table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <b>RegisterForWhenCurrent</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The new <i>current</i> table is malformed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ConvertNextToCurrent();
}

///The <b>IPMT</b> interface enables the client to get information from a program map table (PMT). The
///IAtscPsipParser::GetPMT method returns a pointer to this interface. The PMT may contain one or more table-wide
///descriptors. In addition, each record in the PMT may have one or more descriptors. To get the table-wide descriptors,
///use the <b>GetTableDescriptorByIndex</b> or <b>GetTableDescriptorByTag</b> method. To get the record descriptors, use
///the <b>GetRecordDescriptorByIndex</b> or <b>GetRecordDescriptorByTag</b> method.
@GUID("01F3B398-9527-4736-94DB-5195878E97A8")
interface IPMT : IUnknown
{
    ///The <b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IAtscPsipParser::GetPMT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///The <b>GetProgramNumber</b> method returns the program number for the PMT.
    ///Params:
    ///    pwVal = Receives the program_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProgramNumber(ushort* pwVal);
    ///The <b>GetVersionNumber</b> method returns the version number for the PMT.
    ///Params:
    ///    pbVal = Receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///The <b>GetPcrPid</b> method returns the packet identifier (PID) of the packets that contain the Program Clock
    ///Reference (PCR) fields for this program.
    ///Params:
    ///    pPidVal = Receives the PCR_PID field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetPcrPid(ushort* pPidVal);
    ///The <b>GetCountOfTableDescriptors</b> method returns the number of table-wide descriptors in the PMT.
    ///Params:
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfTableDescriptors(uint* pdwVal);
    ///The <b>GetTableDescriptorByIndex</b> method retrieves a table-wide descriptor for the PMT.
    ///Params:
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IPMT::GetCountOfTableDescriptors method
    ///              to get the number of table descriptors in the PMT.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTableDescriptorByIndex(uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///The <b>GetTableDescriptorByTag</b> method searches the PMT for a table-wide descriptor with the specified
    ///descriptor tag.
    ///Params:
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTableDescriptorByTag(ubyte bTag, uint* pdwCookie, IGenericDescriptor* ppDescriptor);
    ///The <b>GetCountOfRecords</b> method returns the number of records in the PMT. Each record corresponds to a stream
    ///in the program.
    ///Params:
    ///    pwVal = Receives the number of records.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfRecords(ushort* pwVal);
    ///The <b>GetRecordStreamType</b> method returns the stream type for a given elementary stream in the program.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IPMT::GetCountOfRecords method to get the number of
    ///                    records in the PMT.
    ///    pbVal = Receives the stream_type field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordStreamType(uint dwRecordIndex, ubyte* pbVal);
    ///The <b>GetRecordElementaryPid</b> method returns the packet identifier (PID) for a given elementary stream in the
    ///program.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IPMT::GetCountOfRecords method to get the number of
    ///                    records in the PMT.
    ///    pPidVal = Receives the elementary_PID field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordElementaryPid(uint dwRecordIndex, ushort* pPidVal);
    ///The <b>GetRecordCountOfDescriptors</b> method returns the number of descriptors for a record in the PMT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IPMT::GetCountOfRecords method to get the number of
    ///                    records in the PMT.
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///The <b>GetRecordDescriptorByIndex</b> method retrieves a descriptor for a specified record in the PMT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IPMT::GetCountOfRecords method to get the number of
    ///                    records in the PMT.
    ///    dwDescIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IPMT::GetRecordCountOfDescriptors method
    ///                  to get the number of descriptors for a particular record.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwDescIndex, IGenericDescriptor* ppDescriptor);
    ///The <b>GetRecordDescriptorByTag</b> method searches a record in the PMT for a descriptor with a specified
    ///descriptor tag.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IPMT::GetCountOfRecords method to get the number of
    ///                    records in the PMT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
    ///The <b>QueryServiceGatewayInfo</b> method returns the DSM-CC service gateway information in the PMT, if any.
    ///Params:
    ///    ppDSMCCList = Address of a variable that receives a pointer to an array of DSMCC_ELEMENT structures. The client must free
    ///                  the array by calling the <b>CoTaskMemFree</b> function.
    ///    puiCount = Receives the number of elements returned in <i>ppDSMCCList</i>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td width="60%"> Malformed table. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_SG_INFO_FOUND</b></dt> </dl> </td> <td width="60%"> Service
    ///    gateway information was found in the PMT. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_S_SG_INFO_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Service gateway information was not
    ///    found in the PMT. </td> </tr> </table>
    ///    
    HRESULT QueryServiceGatewayInfo(DSMCC_ELEMENT** ppDSMCCList, uint* puiCount);
    ///The <b>QueryMPEInfo</b> method returns the multi-protocol encapsulation (MPE) information in the PMT, if any.
    ///Params:
    ///    ppMPEList = Address of a variable that receives a pointer to an array of MPE_ELEMENT structures. The client must free the
    ///                array by calling the <b>CoTaskMemFree</b> function.
    ///    puiCount = Receives the number of elements returned in <i>ppMPEList</i>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td width="60%"> Malformed table. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MPE_INFO_FOUND</b></dt> </dl> </td> <td width="60%"> MPE
    ///    information was found in the PMT. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_S_MPE_INFO_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> MPE information was not found in the
    ///    PMT. </td> </tr> </table>
    ///    
    HRESULT QueryMPEInfo(MPE_ELEMENT** ppMPEList, uint* puiCount);
    ///The <b>RegisterForNextTable</b> method registers the client to be notified when a <i>next</i> table arrives that
    ///will replace the current table.
    ///Params:
    ///    hNextTableAvailable = Handle to an event created by the caller. The object signals the event when the <i>next</i> table arrives.
    ///                          When the event is signaled, call the IPMT::GetNextTable method to retrieve the table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>next</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableAvailable</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForNextTable(HANDLE hNextTableAvailable);
    ///The <b>GetNextTable</b> method retrieves the <i>next</i> table that follows the current table.
    ///Params:
    ///    ppPMT = Address of a variable that receives an <b>IPMT</b> interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is not current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetNextTable(IPMT* ppPMT);
    ///The <b>RegisterForWhenCurrent</b> method registers the client to be notified when the table becomes current.
    ///Params:
    ///    hNextTableIsCurrent = Handle to an event created by the caller. The object signals the event when the table becomes current.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>current</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableIsCurrent</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForWhenCurrent(HANDLE hNextTableIsCurrent);
    ///The <b>ConvertNextToCurrent</b> method converts a <i>next</i> table to a <i>current</i> table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <b>RegisterForWhenCurrent</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The new <i>current</i> table is malformed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ConvertNextToCurrent();
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>ITSDT</b> interface
///enables the client to get data from a transport stream description table (TSDT). The IAtscPsipParser::GetTSDT and
///IDvbSiParser::GetTSDT methods return pointers to this interface.
@GUID("D19BDB43-405B-4A7C-A791-C89110C33165")
interface ITSDT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>Initialize</b>
    ///method initializes the object using captured table section data. This method is called internally by the
    ///IAtscPsipParser::GetTSDT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>GetVersionNumber</b> method returns the version number for the TSDT.
    ///Params:
    ///    pbVal = Receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>GetCountOfTableDescriptors</b> method returns the number of descriptors in the TSDT.
    ///Params:
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfTableDescriptors(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>GetTableDescriptorByIndex</b> method retrieves a table descriptor for the TSDT.
    ///Params:
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the ITSDT::GetCountOfTableDescriptors method
    ///              to get the number of table descriptors in the TSDT.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTableDescriptorByIndex(uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>GetTableDescriptorByTag</b> method searches the TSDT for a descriptor with the specified descriptor tag.
    ///Params:
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTableDescriptorByTag(ubyte bTag, uint* pdwCookie, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>RegisterForNextTable</b> method registers the client to be notified when a <i>next</i> table arrives that will
    ///replace the current table.
    ///Params:
    ///    hNextTableAvailable = Handle to an event created by the caller. The object signals the event when the <i>next</i> table arrives.
    ///                          When the event is signaled, call the ITSDT::GetNextTable method to retrieve the table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>next</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableAvailable</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForNextTable(HANDLE hNextTableAvailable);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The <b>GetNextTable</b>
    ///method retrieves the <i>next</i> table that follows the current table.
    ///Params:
    ///    ppTSDT = Address of a variable that receives an <b>ITSDT</b> interface pointer. The caller must release the interface.
    ///Returns:
    ///    <table> <tr> <th>Return code </th> <th>Description </th> </tr> <tr> <td>E_ACCESSDENIED</td> <td>This table is
    ///    not current.</td> </tr> <tr> <td>E_FAIL</td> <td>Failure.</td> </tr> <tr> <td>S_OK</td> <td>The method
    ///    succeeded.</td> </tr> </table>
    ///    
    HRESULT GetNextTable(ITSDT* ppTSDT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>RegisterForWhenCurrent</b> method registers the client to be notified when the table becomes current.
    ///Params:
    ///    hNextTableIsCurrent = Handle to an event created by the caller. The object signals the event when the table becomes current.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>current</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableIsCurrent</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForWhenCurrent(HANDLE hNextTableIsCurrent);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005. The
    ///<b>ConvertNextToCurrent</b> method converts a <i>next</i> table to a <i>current</i> table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <b>RegisterForWhenCurrent</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The new <i>current</i> table is malformed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ConvertNextToCurrent();
}

///Gets an MPEG-2 program specific information (PSI) table from an MPEG-2 transport stream. The BDA MPEG-2 Transport
///Information Filter (TIF) implements this interface.
@GUID("919F24C5-7B14-42AC-A4B0-2AE08DAF00AC")
interface IPSITables : IUnknown
{
    ///Gets an MPEG-2 Program Specific Information (PSI) table from an MPEG-2 transport stream. The table that is
    ///returned and its contents depend on the values of the three input parameters to this method.
    ///Params:
    ///    dwTSID = Transport stream identifier (TSID) for the table that is retrieved (bytes 0 - 15) and the original network ID
    ///             (ONID) for an Event Information Table (EIT) that is retrieved (bytes 16 - 31).
    ///    dwTID_PID = Table identifier (TID) or the program ID (PID) that identifies the transport stream packet.
    ///    dwHashedVer = Hash value that identifies the table contents.
    ///    dwPara4 = PID for a Program Mapping Table or the service ID (SID) for an EIT. Otherwise, not used.
    ///    ppIUnknown = Pointer to the IUnknown interface for the table object that is retrieved. The caller is responsible for
    ///                 freeing the memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTable(uint dwTSID, uint dwTID_PID, uint dwHashedVer, uint dwPara4, IUnknown* ppIUnknown);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IAtscPsipParser</b> interface retrieves ATSC Program and System Information Protocol (PSIP) tables.
@GUID("B2C98995-5EB2-4FB1-B406-F3E8E2026A9A")
interface IAtscPsipParser : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes this object.
    ///Params:
    ///    punkMpeg2Data = Pointer to the <b>IUnknown</b> interface of the MPEG-2 Sections and Tables Filter or another object that
    ///                    implements the IMpeg2Data interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt>
    ///    </dl> </td> <td width="60%"> The <i>punkMpeg2Data</i> pointer does not expose the <b>IMpeg2Data</b>
    ///    interface. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(IUnknown punkMpeg2Data);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetPAT</b> method retrieves the program association table (PAT).
    ///Params:
    ///    ppPAT = Receives an IPAT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not
    ///    receive the table in the allotted time. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The <b>Initialize</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetPAT(IPAT* ppPAT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCAT</b> method retrieves the conditional access table (CAT).
    ///Params:
    ///    dwTimeout = Specifies a time-out value, in milliseconds. If the filter does not receive the data within the time-out
    ///                period, the method fails.
    ///    ppCAT = Receives an ICAT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not
    ///    receive the table in the allotted time. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The <b>Initialize</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCAT(uint dwTimeout, ICAT* ppCAT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetPMT</b> method retrieves the program map table (PMT) for a specified packet identifier (PID).
    ///Params:
    ///    pid = Specifies the PID for the requested PMT.
    ///    pwProgramNumber = Optional pointer to a variable that contains a table program number. You can use this value to filter the
    ///                      request. Otherwise, set this parameter to <b>NULL</b>.
    ///    ppPMT = Receives an IPMT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not
    ///    receive the table in the allotted time. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The <b>Initialize</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetPMT(ushort pid, ushort* pwProgramNumber, IPMT* ppPMT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTSDT</b> method retrieves the transport stream description table (TSDT).
    ///Params:
    ///    ppTSDT = Receives an ITSDT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not
    ///    receive the table in the allotted time. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The <b>Initialize</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTSDT(ITSDT* ppTSDT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetMGT</b> method retrieves the master guide table (MGT).
    ///Params:
    ///    ppMGT = Receives an IATSC_MGT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not
    ///    receive the table in the allotted time. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The <b>Initialize</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetMGT(IATSC_MGT* ppMGT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVCT</b> method retrieves the virtual channel table (VCT).
    ///Params:
    ///    tableId = Specifies the table identifier (TID) of the VCT. Use one of the following values, declared in mpeg2data.h.
    ///              <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>ATSC_VCT_CABL_TID (0xC9)</td>
    ///              <td>Cable</td> </tr> <tr> <td>ATSC_VCT_TERR_TID (0xC8)</td> <td>Terrestrial</td> </tr> </table>
    ///    fGetNextTable = Boolean value that indicates whether to search for the current table or the next table. If the value is
    ///                    <b>TRUE</b>, the method searches for a table with the current_next_indicator flag set to 1. Otherwise, the
    ///                    method searches for a table with the current_next_indicator flag set to 0.
    ///    ppVCT = Receives an IATSC_VCT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not
    ///    receive the table in the allotted time. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The <b>Initialize</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVCT(ubyte tableId, BOOL fGetNextTable, IATSC_VCT* ppVCT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetEIT</b> method retrieves the event information table (EIT).
    ///Params:
    ///    pid = Specifies the packet identifier (PID) for the requested EIT.
    ///    pwSourceId = Optional pointer to a variable that contains a table source identifier. You can use this value to filter the
    ///                 request. Otherwise, set this parameter to <b>NULL</b>.
    ///    dwTimeout = Specifies a time-out value, in milliseconds. If the filter does not receive the data within the time-out
    ///                period, the method fails.
    ///    ppEIT = Receives an IATSC_EIT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not
    ///    receive the table in the allotted time. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The <b>Initialize</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEIT(ushort pid, ushort* pwSourceId, uint dwTimeout, IATSC_EIT* ppEIT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetETT</b> method retrieves the extended text table (ETT).
    ///Params:
    ///    pid = Specifies the packet identifier (PID) for the requested ETT.
    ///    wSourceId = Optional pointer to a variable that contains a table source identifier. You can use this value to filter the
    ///                request. Otherwise, set this parameter to <b>NULL</b>.
    ///    pwEventId = Optional pointer to a variable that contains a table event identifier. You can use this value to filter the
    ///                request. Otherwise, set this parameter to <b>NULL</b>.
    ///    ppETT = Receives an IATSC_ETT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not
    ///    receive the table in the allotted time. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The <b>Initialize</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetETT(ushort pid, ushort* wSourceId, ushort* pwEventId, IATSC_ETT* ppETT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetSTT</b> method retrieves the system time table (STT).
    ///Params:
    ///    ppSTT = Receives an IATSC_STT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not
    ///    receive the table in the allotted time. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The <b>Initialize</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSTT(IATSC_STT* ppSTT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetEAS</b> method retrieves the emergency alert message (EAS) table.
    ///Params:
    ///    pid = Specifies the packet identifier (PID) for the requested EAS. <div class="alert"><b>Note</b> Earlier versions
    ///          of this documentation described this parameter incorrectly as a time-out value.</div> <div> </div>
    ///    ppEAS = Receives an ISCTE_EAS interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not
    ///    receive the table in the allotted time. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The <b>Initialize</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEAS(ushort pid, ISCTE_EAS* ppEAS);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IATSC_MGT</b> interface enables the client to get data from a master guide table (MGT). The MGT describes the
///program guide information and service information that is delivered in a transport stream, including the table types,
///the packet identifiers, and the version numbers. The IAtscPsipParser::GetMGT method returns a pointer to this
///interface. The MGT may contain one or more table-wide descriptors. In addition, each record in the MGT may have one
///or more descriptors. To get the table-wide descriptors, use the <b>GetTableDescriptorByIndex</b> method or the
///<b>GetTableDescriptorByTag</b> method. To get the record descriptors, use the <b>GetRecordDescriptorByIndex</b>
///method or the <b>GetRecordDescriptorByTag</b> method.
@GUID("8877DABD-C137-4073-97E3-779407A5D87A")
interface IATSC_MGT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IAtscPsipParser::GetMGT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVersionNumber</b> method returns the version number for the MGT.
    ///Params:
    ///    pbVal = Receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetProtocolVersion</b> method returns the protocol version of the table.
    ///Params:
    ///    pbVal = Receives the protocol_version field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProtocolVersion(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfRecords</b> method returns the number of records in the MGT.
    ///Params:
    ///    pdwVal = Receives the number of records.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordType</b> method returns the table type for a record in the MGT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_MGT::GetCountOfRecords method to get the
    ///                    number of records in the MGT.
    ///    pwVal = Receives the table_type field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordType(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordTypePid</b> method returns the packet identifier (PID) for the table type described by a record in
    ///the MGT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_MGT::GetCountOfRecords method to get the
    ///                    number of records in the MGT.
    ///    ppidVal = Receives the table_type_PID field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordTypePid(uint dwRecordIndex, ushort* ppidVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordVersionNumber</b> method returns the version number for the table type described by a record in the
    ///MGT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_MGT::GetCountOfRecords method to get the
    ///                    number of records in the MGT.
    ///    pbVal = Receives the table_type_version_number field. This value should match the version_number field in the
    ///            corresponding table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordVersionNumber(uint dwRecordIndex, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordCountOfDescriptors</b> method returns the number of descriptors for a record in the MGT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_MGT::GetCountOfRecords method to get the
    ///                    number of records in the MGT.
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByIndex</b> method returns a descriptor for a specified record in the MGT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_MGT::GetCountOfRecords method to get the
    ///                    number of records in the MGT.
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IATSC_MGT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByTag</b> method searches a record in the MGT for a descriptor with a specified descriptor
    ///tag.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_MGT::GetCountOfRecords method to get the
    ///                    number of records in the MGT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in *<i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfTableDescriptors</b> method returns the number of table-wide descriptors in the MGT.
    ///Params:
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfTableDescriptors(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByIndex</b> method returns a table-wide descriptor for the MGT.
    ///Params:
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IATSC_MGT::GetCountOfTableDescriptors
    ///              method to get the number of table descriptors in the MGT.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTableDescriptorByIndex(uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByTag</b> method searches the MGT for a table-wide descriptor with the specified descriptor
    ///tag.
    ///Params:
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in *<i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Receives an IGenericDescriptor interface pointer. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTableDescriptorByTag(ubyte bTag, uint* pdwCookie, IGenericDescriptor* ppDescriptor);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IATSC_VCT</b> interface enables the client to get data from a virtual channel table (VCT). The
///IAtscPsipParser::GetVCT method returns a pointer to this interface. A <i>record</i> as defined by this interface
///corresponds to a virtual channel in the VCT. For example, the <b>GetCountOfRecords</b> method returns the number of
///virtual channels defined in the VCT. The VCT may contain one or more table-wide descriptors. In addition, each record
///in the VCT may have one or more descriptors. To get the table-wide descriptors, use the
///<b>GetTableDescriptorByIndex</b> method or the <b>GetTableDescriptorByTag</b> method. To get the record descriptors,
///use the <b>GetRecordDescriptorByIndex</b> method or the <b>GetRecordDescriptorByTag</b> method.
@GUID("26879A18-32F9-46C6-91F0-FB6479270E8C")
interface IATSC_VCT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IAtscPsipParser::GetVCT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVersionNumber</b> method returns the version number for the VCT.
    ///Params:
    ///    pbVal = Receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTransportStreamId</b> method returns the transport stream identifier (TSID) for the entire VCT.
    ///Params:
    ///    pwVal = Receives the transport_stream_id field. This value should match the value that appears in the program
    ///            association table (PAT).
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTransportStreamId(ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetProtocolVersion</b> method returns the protocol version of the table.
    ///Params:
    ///    pbVal = Receives the protocol_version field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProtocolVersion(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfRecords</b> method returns the number of records in the VCT.
    ///Params:
    ///    pdwVal = Receives the number of records.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordName</b> method returns the name of a specified channel in the VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pwsName = Receives a pointer to a wide-character string. The method allocates the buffer for the string. The caller
    ///              must release the buffer by calling the <b>CoTaskMemFree</b> function.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordName(uint dwRecordIndex, ushort** pwsName);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordMajorChannelNumber</b> method returns the major channel number for a record in the VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pwVal = Receives the major channel number.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordMajorChannelNumber(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordMinorChannelNumber</b> method returns the minor channel number for a record in the VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pwVal = Receives the minor channel number.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordMinorChannelNumber(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordModulationMode</b> method returns the modulation mode for a record in the VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pbVal = Receives the modulation_mode field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordModulationMode(uint dwRecordIndex, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordCarrierFrequency</b> method returns the carrier frequency for a channel in this VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pdwVal = Receives the carrier frequency, in Hz.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordCarrierFrequency(uint dwRecordIndex, uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordTransportStreamId</b> method returns the transport stream identifier (TSID) for a specified channel.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pwVal = Receives the channel_TSID field. This value represents the TSID associated with the transport stream that
    ///            carries the MPEG-2 program for this virtual channel.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordTransportStreamId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordProgramNumber</b> method returns the program number for a record in the VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pwVal = Receives the program_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordProgramNumber(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordEtmLocation</b> method returns the extended text message (ETM) location for a record in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pbVal = Receives the ETM_location field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordEtmLocation(uint dwRecordIndex, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordIsAccessControlledBitSet</b> method queries whether the access_controlled bit is set for a particular
    ///record in the VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pfVal = Receives a Boolean value. The value is <b>TRUE</b> if the access_controlled bit is set, indicating that this
    ///            virtual channel might be access controlled. Otherwise, the value is <b>FALSE</b>, indicating that access is
    ///            not restricted.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordIsAccessControlledBitSet(uint dwRecordIndex, int* pfVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordIsHiddenBitSet</b> method queries whether the hidden bit is set for a particular record in the VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pfVal = Receives a Boolean value. The value is <b>TRUE</b> if the hidden bit is set. Otherwise, the value is
    ///            <b>FALSE</b>. Hidden channels are not accessed by the user; for example, they might be used for test signals.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordIsHiddenBitSet(uint dwRecordIndex, int* pfVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordIsPathSelectBitSet</b> method queries whether the path_select bit is set for a particular record in
    ///the VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pfVal = Receives a Boolean value. The value is <b>TRUE</b> if the path_select bit is set, or <b>FALSE</b> otherwise.
    ///            The path_select bit indicates which physical input cable carries the transport stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The table does not contain an out_of_band
    ///    bit. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td
    ///    width="60%"> Index out of bounds. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordIsPathSelectBitSet(uint dwRecordIndex, int* pfVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordIsOutOfBandBitSet</b> method queries whether the out_of_band bit is set for a particular record in
    ///the VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pfVal = Receives a Boolean value. The value is <b>TRUE</b> if the out_of_band bit is set, indicating that this
    ///            channel is carried on an out-of-band physical transmission channel. Otherwise, the value is <b>FALSE</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The table does not contain an out_of_band
    ///    bit. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td
    ///    width="60%"> Index out of bounds. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordIsOutOfBandBitSet(uint dwRecordIndex, int* pfVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordIsHideGuideBitSet</b> method queries whether the hide_guide bit is set for a particular record in the
    ///VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pfVal = Receives a Boolean value. The value is <b>TRUE</b> if the hide_guide bit is set, or <b>FALSE</b> otherwise.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordIsHideGuideBitSet(uint dwRecordIndex, int* pfVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordServiceType</b> method returns the service type for a record in the VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pbVal = Receives the service_type field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordServiceType(uint dwRecordIndex, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordSourceId</b> method returns the source identifier for a record in the VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pwVal = Receives the source_id field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordSourceId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordCountOfDescriptors</b> method returns the number of descriptors for a record in the VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByIndex</b> method returns a descriptor for a specified record in the VCT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IATSC_VCT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByTag</b> method searches a record in the VCT for a descriptor with a specified descriptor
    ///tag.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_VCT::GetCountOfRecords method to get the
    ///                    number of records in the VCT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in *<i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfTableDescriptors</b> method returns the number of table-wide descriptors in the VCT.
    ///Params:
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfTableDescriptors(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByIndex</b> method returns a table-wide descriptor for the VCT.
    ///Params:
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IATSC_VCT::GetCountOfTableDescriptors
    ///              method to get the number of table descriptors in the VCT.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTableDescriptorByIndex(uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByTag</b> method searches the VCT for a table-wide descriptor with the specified descriptor
    ///tag.
    ///Params:
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in *<i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTableDescriptorByTag(ubyte bTag, uint* pdwCookie, IGenericDescriptor* ppDescriptor);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IATSC_EIT</b> interface enables the client to get data from an ATSC event information table (EIT). The
///IAtscPsipParser::GetEIT method returns a pointer to this interface.
@GUID("D7C212D7-76A2-4B4B-AA56-846879A80096")
interface IATSC_EIT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IAtscPsipParser::GetEIT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVersionNumber</b> method returns the version number for the EIT.
    ///Params:
    ///    pbVal = Receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetSourceId</b> method returns the source identifier for the EIT.
    ///Params:
    ///    pwVal = Receives the source_id field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSourceId(ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetProtocolVersion</b> method returns the protocol version of the table.
    ///Params:
    ///    pbVal = Receives the protocol_version field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProtocolVersion(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfRecords</b> method returns the number of records in the EIT.
    ///Params:
    ///    pdwVal = Receives the number of records.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordEventId</b> method returns the event identifier for a record in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_EIT::GetCountOfRecords method to get the
    ///                    number of records in the EIT.
    ///    pwVal = Receives the event_id field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordEventId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordStartTime</b> method returns the event start time for a record in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_EIT::GetCountOfRecords method to get the
    ///                    number of records in the EIT.
    ///    pmdtVal = Pointer to an MPEG_DATE_AND_TIME structure allocated by the caller. The method fills the structure with the
    ///              event start time.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordStartTime(uint dwRecordIndex, MPEG_DATE_AND_TIME* pmdtVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordEtmLocation</b> method returns the extended text message (ETM) location for a record in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_EIT::GetCountOfRecords method to get the
    ///                    number of records in the EIT.
    ///    pbVal = Receives the ETM_location field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordEtmLocation(uint dwRecordIndex, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDuration</b> method returns the event duration for a record in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_EIT::GetCountOfRecords method to get the
    ///                    number of records in the EIT.
    ///    pmdVal = Pointer to an MPEG_DURATION structure allocated by the caller. The method fills the structure with the event
    ///             duration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordDuration(uint dwRecordIndex, MPEG_TIME* pmdVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordTitleText</b> method returns the title text for a record in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_EIT::GetCountOfRecords method to get the
    ///                    number of records in the EIT.
    ///    pdwLength = Receives the length of the title text, in bytes.
    ///    ppText = Receives a pointer to the text buffer. The method allocates the buffer and fills it with the title text,
    ///             which is formatted as a Multiple String Structure as defined by ATSC PSIP Standard A/65. The caller must free
    ///             the buffer by calling <b>CoTaskMemFree</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> This record does
    ///    not contain a title. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordTitleText(uint dwRecordIndex, uint* pdwLength, ubyte** ppText);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordCountOfDescriptors</b> method returns the number of descriptors for a record in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_EIT::GetCountOfRecords method to get the
    ///                    number of records in the EIT.
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByIndex</b> method returns a descriptor for a specified record in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_EIT::GetCountOfRecords method to get the
    ///                    number of records in the EIT.
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IATSC_EIT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByTag</b> method searches a record in the EIT for a descriptor with a specified descriptor
    ///tag.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IATSC_EIT::GetCountOfRecords method to get the
    ///                    number of records in the EIT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in *<i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IATSC_ETT</b> interface enables the client to get information from an extended text table (ETT). The
///IAtscPsipParser::GetETT method returns a pointer to this interface. An ETT provides text descriptions for events or
///virtual channels. Each ETT contains a single extended text message (ETM) stream. The ETM stream might contain
///descriptions for multiple languages.
@GUID("5A142CC9-B8CF-4A86-A040-E9CADF3EF3E7")
interface IATSC_ETT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IAtscPsipParser::GetETT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVersionNumber</b> method returns the version number for the ETT.
    ///Params:
    ///    pbVal = Receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetProtocolVersion</b> method returns the protocol version of the table.
    ///Params:
    ///    pbVal = Receives the protocol_version field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProtocolVersion(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetEtmId</b> method returns the ETM identifier, which is a unique 32-bit identifier for the text message.
    ///Params:
    ///    pdwVal = Receives the ETM_id field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEtmId(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetExtendedMessageText</b> method returns the message text.
    ///Params:
    ///    pdwLength = Receives the length of the title text, in bytes.
    ///    ppText = Receives a pointer to the title text buffer. The method allocates the buffer and fills it with the title
    ///             text, which is formatted as a Multiple String Structure as defined by ATSC PSIP Standard A/65. The caller
    ///             must free the buffer by calling <b>CoTaskMemFree</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The length of the text is zero. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetExtendedMessageText(uint* pdwLength, ubyte** ppText);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IATSC_STT</b> interface enables the client to get data from a system time table (STT), which defines the current
///data and time of day. The IAtscPsipParser::GetSTT method returns a pointer to this interface.
@GUID("6BF42423-217D-4D6F-81E1-3A7B360EC896")
interface IATSC_STT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IAtscPsipParser::GetSTT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetProtocolVersion</b> method returns the protocol version of the table.
    ///Params:
    ///    pbVal = Receives the protocol_version field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProtocolVersion(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetSystemTime</b> method returns the current system time.
    ///Params:
    ///    pmdtSystemTime = Pointer to an MPEG_DATE_AND_TIME structure allocated by the caller. The method fills the structure with the
    ///                     system time.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSystemTime(MPEG_DATE_AND_TIME* pmdtSystemTime);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetGpsUtcOffset</b> method returns the current offset between Global Positioning Satellite (GPS) time and
    ///Universal Time Coordinated (UTC), in seconds.
    ///Params:
    ///    pbVal = Receives the GPS_UTC_offset field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetGpsUtcOffset(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetDaylightSavings</b> method returns the Daylight Savings Time Control bytes.
    ///Params:
    ///    pwVal = Receives the daylight_savings field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDaylightSavings(ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfTableDescriptors</b> method returns the number of descriptors in the STT.
    ///Params:
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfTableDescriptors(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByIndex</b> method returns a descriptor for the STT.
    ///Params:
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IATSC_STT::GetCountOfTableDescriptors
    ///              method to get the number of table descriptors in the STT.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTableDescriptorByIndex(uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByTag</b> method searches the STT for a descriptor with the specified descriptor tag.
    ///Params:
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in *<i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTableDescriptorByTag(ubyte bTag, uint* pdwCookie, IGenericDescriptor* ppDescriptor);
}

///The <b>ISCTE_EAS</b> interface enables the client to get data from an ATSC emergency alert message (EAS) table. The
///IAtscPsipParser::GetEAS method returns a pointer to this interface. For more information about EAS tables, see
///ANSI-J-STD-042-A, Emergency Alert Message for Cable.
@GUID("1FF544D6-161D-4FAE-9FAA-4F9F492AE999")
interface ISCTE_EAS : IUnknown
{
    ///The <b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IAtscPsipParser::GetEAS method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td width="60%"> The EAS table is not
    ///    well formed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    method succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///The <b>GetVersionNumber</b> method returns the version number for the EAS table.
    ///Params:
    ///    pbVal = Receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///The <b>GetSequencyNumber</b>method returns the sequence number.
    ///Params:
    ///    pbVal = Receives the sequence_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSequencyNumber(ubyte* pbVal);
    ///The <b>GetProtocolVersion</b> method returns the protocol version of the EAS table.
    ///Params:
    ///    pbVal = Receives the protocol_version field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProtocolVersion(ubyte* pbVal);
    ///The <b>GetEASEventID</b> method returns the identifier of this emergency event.
    ///Params:
    ///    pwVal = Receives the EAS_Event_ID field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEASEventID(ushort* pwVal);
    ///The <b>GetOriginatorCode</b> method returns the EAS originator code.
    ///Params:
    ///    pbVal = Receives the EAS_originator_code field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetOriginatorCode(ubyte* pbVal);
    ///The <b>GetEASEventCodeLen</b> method returns the size of the EAS event code.
    ///Params:
    ///    pbVal = Receives the size of the EAS event code, in bytes. To get the event code, allocate a buffer of this size and
    ///            call ISCTE_EAS::GetEASEventCode.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEASEventCodeLen(ubyte* pbVal);
    ///The <b>GetEASEventCode</b> method returns the EAS event code.
    ///Params:
    ///    pbVal = A pointer to a buffer that receives the EAS_event_code field. The caller must allocate the buffer, which must
    ///            be large enough to hold the event code. To get the required size of the buffer, call
    ///            ISCTE_EAS::GetEASEventCodeLen. The event code consists of ASCII characters.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEASEventCode(ubyte* pbVal);
    ///Gets the length of the nature_of_activation_text field.
    ///Params:
    ///    pbVal = Receives the size of the nature_of_activation_text field, in bytes. To get the value of the field, allocate a
    ///            buffer of this size and call ISCTE_EAS::GetRawNatureOfActivationText.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRawNatureOfActivationTextLen(ubyte* pbVal);
    ///Gets the raw nature_of_activation_text field from the EAS table.
    ///Params:
    ///    pbVal = A pointer to a buffer that receives the nature_of_activation_text field. The caller must allocate the buffer.
    ///            To get the required size of the buffer, call ISCTE_EAS::GetRawNatureOfActivationTextLen. The text is
    ///            formatted as a Multiple String Structure as defined by ATSC PSIP Standard A/65.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRawNatureOfActivationText(ubyte* pbVal);
    ///The <b>GetNatureOfActivationText</b> method gets a textual representation of the alert for a specified ISO 639
    ///language code.
    ///Params:
    ///    bstrIS0639code = The ISO 639 language code.
    ///    pbstrString = Receives the text as a <b>BSTR</b>. The caller must free the string by calling <b>SysFreeString</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The specified language is not present. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetNatureOfActivationText(BSTR bstrIS0639code, BSTR* pbstrString);
    ///The <b>GetTimeRemaining</b> method returns the time that remains in the alert message.
    ///Params:
    ///    pbVal = Receives the alert_message_time_remaining field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTimeRemaining(ubyte* pbVal);
    ///The <b>GetStartTime</b> method returns the starting time of the alert.
    ///Params:
    ///    pdwVal = Receives the event_start_time field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetStartTime(uint* pdwVal);
    ///The <b>GetDuration</b> method returns the expected duration of the alert.
    ///Params:
    ///    pwVal = Receives the event_duration field. The value of the field is the expected duration in minutes, most
    ///            significant bit first.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDuration(ushort* pwVal);
    ///The <b>GetAlertPriority</b> method returns the alert priority.
    ///Params:
    ///    pbVal = Receives the alert_priority field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetAlertPriority(ubyte* pbVal);
    ///The <b>GetDetailsOOBSourceID</b> method returns the source identifier of the virtual details channel for the
    ///emergency alert.
    ///Params:
    ///    pwVal = Receives the details_OOB_source_ID field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDetailsOOBSourceID(ushort* pwVal);
    ///The <b>GetDetailsMajor</b> method returns the major channel number for the details channel.
    ///Params:
    ///    pwVal = Receives the details_major_channel_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDetailsMajor(ushort* pwVal);
    ///The <b>GetDetailsMinor</b> method returns the minor channel number for the details channel.
    ///Params:
    ///    pwVal = Receives the details_minor_channel_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDetailsMinor(ushort* pwVal);
    ///The <b>GetDetailsAudioOOBSourceID</b> method returns the source identifier of the virtual audio channel for the
    ///emergency alert.
    ///Params:
    ///    pwVal = Receives the audio_OOB_source_ID field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDetailsAudioOOBSourceID(ushort* pwVal);
    ///The <b>GetAlertText</b> method gets the alert text for a specified ISO 639 language code.
    ///Params:
    ///    bstrIS0639code = The ISO 639 language code.
    ///    pbstrString = Receives the alert text as a <b>BSTR</b>. The caller must free the string by calling <b>SysFreeString</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The specified language is not present. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAlertText(BSTR bstrIS0639code, BSTR* pbstrString);
    ///Gets the length of the alert_text field.
    ///Params:
    ///    pwVal = Receives the size of the alert_text field, in bytes. To get the value of the field, allocate a buffer of this
    ///            size and call ISCTE_EAS::GetRawAlertText.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRawAlertTextLen(ushort* pwVal);
    ///Gets the raw alert_text field from the EAS table.
    ///Params:
    ///    pbVal = A pointer to a buffer that receives the alert_text field. The caller must allocate the buffer. To get the
    ///            required size of the buffer, call ISCTE_EAS::GetRawAlertTextLen. The text is formatted as a Multiple String
    ///            Structure as defined by ATSC PSIP Standard A/65.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRawAlertText(ubyte* pbVal);
    ///The <b>GetLocationCount</b> method returns the number of locations in the EAS table.
    ///Params:
    ///    pbVal = Receives the location_code_count field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetLocationCount(ubyte* pbVal);
    ///The <b>GetLocationCodes</b> method returns location codes from the EAS table.
    ///Params:
    ///    bIndex = The zero-based index of the location codes to retrieve. Call ISCTE_EAS::GetLocationCount to get the number of
    ///             locations.
    ///    pbState = Receives the state_code field.
    ///    pbCountySubdivision = Receives the county_subdivision field.
    ///    pwCounty = Receives the county_code field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of range. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The
    ///    ISCTE_EAS::Initialize method was not called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetLocationCodes(ubyte bIndex, ubyte* pbState, ubyte* pbCountySubdivision, ushort* pwCounty);
    ///The <b>GetExceptionCount</b> method returns the number of exception services.
    ///Params:
    ///    pbVal = Receives the exception_count field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetExceptionCount(ubyte* pbVal);
    ///The <b>GetExceptionService</b> method returns information about an exception service.
    ///Params:
    ///    bIndex = Zero-based index of the exception service to retrieve. Call ISCTE_EAS::GetExceptionCount to get the number of
    ///             exception services.
    ///    pbIBRef = Receives the in_band_reference flag.
    ///    pwFirst = If the in_band_reference flag is <b>TRUE</b>, receives the exception_major_channel_number field. Otherwise,
    ///              receives the exception_OOB_source_ID field.
    ///    pwSecond = If the in_band_reference flag is <b>TRUE</b>, receives the exception_minor_channel_number field. Otherwise,
    ///               the value is undefined and this parameter should be ignored.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of range. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The
    ///    ISCTE_EAS::Initialize method was not called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetExceptionService(ubyte bIndex, ubyte* pbIBRef, ushort* pwFirst, ushort* pwSecond);
    ///The <b>GetCountOfTableDescriptors</b> method returns the number of descriptors in the EAS table.
    ///Params:
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The ISCTE_EAS::Initialize method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfTableDescriptors(uint* pdwVal);
    ///The <b>GetTableDescriptorByIndex</b> method returns a descriptor for the EAS table.
    ///Params:
    ///    dwIndex = The zero-based index of the descriptor to retrieve. Call the ISCTE_EAS::GetCountOfTableDescriptors method to
    ///              get the number of table descriptors.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The
    ///    ISCTE_EAS::Initialize method was not called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTableDescriptorByIndex(uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///The <b>GetTableDescriptorByTag</b> method searches the EAS table for a descriptor with the specified descriptor
    ///tag.
    ///Params:
    ///    bTag = The descriptor tag to search for.
    ///    pdwCookie = A pointer to a variable that specifies the start position in the descriptor list. This parameter can be
    ///                <b>NULL</b>. If the value is <b>NULL</b>, the search starts from the first descriptor in the list. Otherwise,
    ///                the search starts from the position given in *<i>pdwCookie</i>. When the method returns, the <i>pdwCookie</i>
    ///                parameter contains the position of the next matching descriptor, if any. You can use this parameter to
    ///                iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not found. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of
    ///    bounds. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td
    ///    width="60%"> The ISCTE_EAS::Initialize method was not called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record contains at least one
    ///    more descriptor with this tag. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does not contain any
    ///    more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTableDescriptorByTag(ubyte bTag, uint* pdwCookie, IGenericDescriptor* ppDescriptor);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IAtscContentAdvisoryDescriptor</b> interface enables the client to get a content advisory descriptor from a
///Program and System Information Protocol (PSIP) table in an ATSC stream. The content advisor descriptor may be present
///in the event information table (EIT). For more information, refer to ATSC Standard A/65B, Program and System
///Information Protocol for Terrestrial Broadcast and Cable (Revision B).
@GUID("FF76E60C-0283-43EA-BA32-B422238547EE")
interface IAtscContentAdvisoryDescriptor : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTag</b> method returns the descriptor tag.
    ///Params:
    ///    pbVal = Receives the descriptor tag.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetLength</b> method returns the length of the descriptor body.
    ///Params:
    ///    pbVal = Receives the length of the descriptor body, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRatingRegionCount</b> method returns the number of rating regions.
    ///Params:
    ///    pbVal = Receives the rating_region_count field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRatingRegionCount(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordRatingRegion</b> method returns the rating region at a specified index.
    ///Params:
    ///    bIndex = Zero-based index of the rating region. To get the number of rating regions, call
    ///             IAtscContentAdvisoryDescriptor::GetRatingRegionCount.
    ///    pbVal = Receives the rating_region field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> The <i>bIndex</i> parameter is out of
    ///    bounds. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordRatingRegion(ubyte bIndex, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordRatedDimensions</b> method returns the number of rating dimensions for a specified rating region.
    ///Params:
    ///    bIndex = Zero-based index of the rating region. To get the number of rating regions, call
    ///             IAtscContentAdvisoryDescriptor::GetRatingRegionCount.
    ///    pbVal = Receives the rated_dimensions field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> The <i>bIndex</i> parameter is out of
    ///    bounds. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordRatedDimensions(ubyte bIndex, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordRatingDimension</b> method returns the dimension index into the rating region table (RRT) for a
    ///specified region.
    ///Params:
    ///    bIndexOuter = Zero-based index of the rating region. To get the number of rating regions, call
    ///                  IAtscContentAdvisoryDescriptor::GetRatingRegionCount.
    ///    bIndexInner = Zero-based index of the rating dimension. To get the number of rating dimensions, call
    ///                  IAtscContentAdvisoryDescriptor::GetRecordRatedDimensions.
    ///    pbVal = Receives the rating_dimension_j field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> The <i>bIndexOuter</i> or
    ///    <i>bIndexInner</i> parameter is out of bounds. </td> </tr> </table>
    ///    
    HRESULT GetRecordRatingDimension(ubyte bIndexOuter, ubyte bIndexInner, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordRatingValue</b> method returns the rating value of a specified rating dimension.
    ///Params:
    ///    bIndexOuter = Zero-based index of the rating region. To get the number of rating regions, call
    ///                  IAtscContentAdvisoryDescriptor::GetRatingRegionCount.
    ///    bIndexInner = Zero-based index of the rating dimension. To get the number of rating dimensions, call
    ///                  IAtscContentAdvisoryDescriptor::GetRecordRatedDimensions.
    ///    pbVal = Receives the rating_value field
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> The <i>bIndexOuter</i> or
    ///    <i>bIndexInner</i> parameter is out of bounds. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordRatingValue(ubyte bIndexOuter, ubyte bIndexInner, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordRatingDescriptionText</b> method returns the rating description for a specified rating region.
    ///Params:
    ///    bIndex = Zero-based index of the rating region. To get the number of rating regions, call
    ///             IAtscContentAdvisoryDescriptor::GetRatingRegionCount.
    ///    pbLength = Receives the rating_description_length field.
    ///    ppText = Receives a pointer to a buffer that contains the rating_description_text field. The text is formatted as a
    ///             Multiple String Structure as defined by ATSC PSIP Standard A/65. The caller must free the buffer by calling
    ///             the <b>CoTaskMemFree</b> function.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> The <i>bIndex</i> parameter is out of
    ///    bounds. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordRatingDescriptionText(ubyte bIndex, ubyte* pbLength, ubyte** ppText);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>ICaptionServiceDescriptor</b> interface enables the client to get caption service descriptors from a Program and
///System Information Protocol (PSIP) table in an ATSC stream. The content advisor descriptor may be present in the
///event information table (EIT). For more information, refer to ATSC Standard A/65B, Program and System Information
///Protocol for Terrestrial Broadcast and Cable (Revision B).
@GUID("40834007-6834-46F0-BD45-D5F6A6BE258C")
interface ICaptionServiceDescriptor : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetNumberOfServices</b> method returns the number of caption services.
    ///Params:
    ///    pbVal = Receives the number of caption services.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MPEG2_E_INCORRECT_DESCRIPTOR_TAG</b></dt> </dl> </td> <td width="60%"> The table descriptor tag
    ///    is incorrect. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The PSIP table is not well formed. </td> </tr> </table>
    ///    
    HRESULT GetNumberOfServices(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetLanguageCode</b> method returns the language code for a specified caption service.
    ///Params:
    ///    bIndex = Zero-based index of the caption service. To get the number of caption services, call
    ///             ICaptionServiceDescriptor::GetNumberOfServices.
    ///    LangCode = Address of a 3-byte array that receives the ISO-639 language code.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MPEG2_E_INCORRECT_DESCRIPTOR_TAG</b></dt> </dl> </td> <td width="60%"> The table descriptor tag
    ///    is incorrect. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The PSIP table is not well formed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> The <i>bIndex</i> parameter is out of
    ///    range. </td> </tr> </table>
    ///    
    HRESULT GetLanguageCode(ubyte bIndex, char* LangCode);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCaptionServiceNumber</b> method returns the service number within the closed captioning stream for a
    ///specified caption service.
    ///Params:
    ///    bIndex = Zero-based index of the caption service. To get the number of caption services, call
    ///             ICaptionServiceDescriptor::GetNumberOfServices.
    ///    pbVal = Receives the caption_service_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MPEG2_E_INCORRECT_DESCRIPTOR_TAG</b></dt> </dl> </td> <td width="60%"> The table descriptor tag
    ///    is incorrect. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The PSIP table is not well formed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> The <i>bIndex</i> parameter is out of
    ///    range. </td> </tr> </table>
    ///    
    HRESULT GetCaptionServiceNumber(ubyte bIndex, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCCType</b> method queries whether a caption service contains Digital Television Closed Captioning (DTVCC)
    ///or line-21 closed captioning.
    ///Params:
    ///    bIndex = Zero-based index of the caption service. To get the number of caption services, call
    ///             ICaptionServiceDescriptor::GetNumberOfServices.
    ///    pbVal = Receives the cc_type flag: <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>0</td> <td>The
    ///            caption service contains line-21 captions.</td> </tr> <tr> <td>1</td> <td>The caption service contains DTVCC
    ///            captions.</td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MPEG2_E_INCORRECT_DESCRIPTOR_TAG</b></dt> </dl> </td> <td width="60%"> The table descriptor tag
    ///    is incorrect. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The PSIP table is not well formed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> The <i>bIndex</i> parameter is out of
    ///    range. </td> </tr> </table>
    ///    
    HRESULT GetCCType(ubyte bIndex, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetEasyReader</b> method queries whether a caption service contains "Easy Reader" captions.
    ///Params:
    ///    bIndex = Zero-based index of the caption service. To get the number of caption services, call
    ///             ICaptionServiceDescriptor::GetNumberOfServices.
    ///    pbVal = Receives the easy_reader flag: <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>0</td>
    ///            <td>The caption service does not contain "Easy Reader" captions.</td> </tr> <tr> <td>1</td> <td>The caption
    ///            service contains "Easy Reader" captions.</td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MPEG2_E_INCORRECT_DESCRIPTOR_TAG</b></dt> </dl> </td> <td width="60%"> The table descriptor tag
    ///    is incorrect. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The PSIP table is not well formed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> The <i>bIndex</i> parameter is out of
    ///    range. </td> </tr> </table>
    ///    
    HRESULT GetEasyReader(ubyte bIndex, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetWideAspectRatio</b> method queries whether a caption service is formatted for wide-screen displays.
    ///Params:
    ///    bIndex = Zero-based index of the caption service. To get the number of caption services, call
    ///             ICaptionServiceDescriptor::GetNumberOfServices.
    ///    pbVal = Receives the wide_aspect_ratio: <table> <tr> <th>Value </th> <th>Description </th> </tr> <tr> <td>0</td>
    ///            <td>The caption service is formatted for a 4:3 aspect ratio.</td> </tr> <tr> <td>1</td> <td>The caption
    ///            service is formatted for a 16:9 aspect ratio.</td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MPEG2_E_INCORRECT_DESCRIPTOR_TAG</b></dt> </dl> </td> <td width="60%"> The table descriptor tag
    ///    is incorrect. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The PSIP table is not well formed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> The <i>bIndex</i> parameter is out of
    ///    range. </td> </tr> </table>
    ///    
    HRESULT GetWideAspectRatio(ubyte bIndex, ubyte* pbVal);
}

///Gets information from the Service Location Descriptor in an Advanced Television Systems Committee (ATSC) Virtual
///Channel Table (VCT). The Service Location Descriptor lists the program IDs (PIDs) in an ATSC transport stream. The
///VCT is a Program and System Information Protocol (PSIP) table that describes the elementary streams for the virtual
///channels in an ATSC transport stream.
@GUID("58C3C827-9D91-4215-BFF3-820A49F0904C")
interface IServiceLocationDescriptor : IUnknown
{
    ///Gets the program ID (PID) for the packets that contain the Program Clock Reference (PCR) in the transport stream
    ///from an Advanced Television Systems Committee (ATSC) Service Location Descriptor.
    ///Params:
    ///    pwVal = Receives the PID value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPCR_PID(ushort* pwVal);
    ///Gets the number of elementary streams for an Advanced Television Systems Committee (ATSC) service location
    ///descriptor.
    ///Params:
    ///    pbVal = Receives the number of elementary streams.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetNumberOfElements(ubyte* pbVal);
    ///Gets a code identifying the type of an elementary stream from an Advanced Television Systems Committee (ATSC)
    ///Service Location Descriptor.
    ///Params:
    ///    bIndex = Specifies the elementary stream, indexed from zero. Call the
    ///             IServiceLocationDescriptor::GetNumberOfElementsmethod to get the number of elementary streams in the
    ///             descriptor.
    ///    pbVal = Receives the element stream type code. This can be any of the following values: <table> <tr> <th>Value</th>
    ///            <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x00</dt> </dl> </td> <td width="60%"> ITU-T | ISO/IEC
    ///            Reserved. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x01-0x7F</dt> </dl> </td> <td width="60%"> As specified
    ///            in Table 2.29 (Stream type assignments) of <i>ITU-T Rec. H.222.0 | ISO/IEC 13818-1:1996, Information
    ///            Technology — Generic coding of moving pictures and associated audio — Part 1: Systems (normative)</i>.
    ///            </td> </tr> <tr> <td width="40%"> <dl> <dt>0x80</dt> </dl> </td> <td width="60%"> [Used in other systems.]
    ///            </td> </tr> <tr> <td width="40%"> <dl> <dt>0x81</dt> </dl> </td> <td width="60%"> ATSC A/53 audio. </td>
    ///            </tr> <tr> <td width="40%"> <dl> <dt>0x82-0x84</dt> </dl> </td> <td width="60%"> [Used in other systems.]
    ///            </td> </tr> <tr> <td width="40%"> <dl> <dt>0x85</dt> </dl> </td> <td width="60%"> UPID that is defined in
    ///            <i>ATSC Standard A/57 (1996), Program/Episode/Version Identification (normative).</i> </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0x86-0xBF</dt> </dl> </td> <td width="60%"> Reserved. </td> </tr> <tr> <td width="40%">
    ///            <dl> <dt>0xC0-0xFF</dt> </dl> </td> <td width="60%"> User Private. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetElementStreamType(ubyte bIndex, ubyte* pbVal);
    ///Gets the program ID (PID) that identifies an elementary stream from an Advanced Television Systems Committee
    ///(ATSC) Service Location Descriptor.
    ///Params:
    ///    bIndex = Specifies the elementary stream, indexed from zero. Call the
    ///             IServiceLocationDescriptor::GetNumberOfElementsmethod to get the number of elementary streams in the
    ///             descriptor.
    ///    pwVal = Receives the PID value for the elementary stream.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetElementPID(ubyte bIndex, ushort* pwVal);
    ///Gets the three-character ISO 639 language code for an Advanced Television Systems Committee (ATSC) service
    ///location descriptor.
    ///Params:
    ///    bIndex = Specifies the elementary stream, indexed from zero. Call the
    ///             IServiceLocationDescriptor::GetNumberOfElementsmethod to get the number of elementary streams in the
    ///             descriptor.
    ///    LangCode = Pointer to a buffer that receives the language code. For a list of language codes, refer to ISO 639 Code
    ///               Tables.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetElementLanguageCode(ubyte bIndex, char* LangCode);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IAttributeSet</b> interface sets key/value pairs on an object, where the key is a <b>GUID</b> and the value is any
///binary data.
@GUID("583EC3CC-4960-4857-982B-41A33EA0A006")
interface IAttributeSet : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>SetAttrib</b> method sets an attribute on the object.
    ///Params:
    ///    guidAttribute = <b>GUID</b> that identifies the attribute.
    ///    pbAttribute = Pointer to a buffer that contains the attribute value.
    ///    dwAttributeLength = Size of the <i>pbAttribute</i> buffer, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>__HRESULT_FROM_WIN32(ERROR_DUPLICATE_TAG)</b></dt> </dl> </td> <td width="60%"> An attribute with this
    ///    <b>GUID</b> already exists on this object. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetAttrib(GUID guidAttribute, ubyte* pbAttribute, uint dwAttributeLength);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IAttributeGet</b> interface gets key/value pairs from an object, where the key is a <b>GUID</b> and the value is
///any binary data.
@GUID("52DBD1EC-E48F-4528-9232-F442A68F0AE1")
interface IAttributeGet : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCount</b> method returns the number of attributes on this object.
    ///Params:
    ///    plCount = Receives the number of attributes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCount(int* plCount);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetAttribIndexed</b> method returns an attribute value, specified by index.
    ///Params:
    ///    lIndex = Zero-based index of the attribute. To get the number of attributes, call IAttributeGet::GetCount.
    ///    pguidAttribute = Receives the <b>GUID</b> for this attribute.
    ///    pbAttribute = Pointer to a buffer that receives the attribute value. This parameter can be <b>NULL</b>.
    ///    pdwAttributeLength = If <i>pbAttribute</i> is <b>NULL</b>, this parameter receives the size of the attribute data, in bytes. If
    ///                         <i>pbAttribute</i> is non-<b>NULL</b>, this parameter specifies the size of the <i>pbAttribute</i> buffer, in
    ///                         bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>lIndex</i> parameter is out of range. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetAttribIndexed(int lIndex, GUID* pguidAttribute, ubyte* pbAttribute, uint* pdwAttributeLength);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetAttrib</b> method returns an attribute value, specified by <b>GUID</b>.
    ///Params:
    ///    guidAttribute = <b>GUID</b> that specifies the attribute to retrieve.
    ///    pbAttribute = Pointer to a buffer that receives the attribute value. This parameter can be <b>NULL</b>.
    ///    pdwAttributeLength = If <i>pbAttribute</i> is <b>NULL</b>, this parameter receives the size of the attribute data, in bytes. If
    ///                         <i>pbAttribute</i> is non-<b>NULL</b>, this parameter specifies the size of the <i>pbAttribute</i> buffer, in
    ///                         bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer value. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>NS_E_UNSUPPORTED_PROPERTY</b></dt> </dl> </td> <td width="60%"> The specified
    ///    <b>GUID</b> does not match any attribute on this object. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetAttrib(GUID guidAttribute, ubyte* pbAttribute, uint* pdwAttributeLength);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDvbSiParser</b> retrieves program specific information (PSI) and service information (SI) tables from a DVB
///transport stream.
@GUID("B758A7BD-14DC-449D-B828-35909ACB3B1E")
interface IDvbSiParser : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes this object.
    ///Params:
    ///    punkMpeg2Data = Pointer to the <b>IUnknown</b> interface of the MPEG-2 Sections and Tables Filter or another object that
    ///                    implements the IMpeg2Data interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt>
    ///    </dl> </td> <td width="60%"> The <i>punkMpeg2Data</i> pointer does not expose the <b>IMpeg2Data</b>
    ///    interface. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(IUnknown punkMpeg2Data);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetPAT</b> method retrieves the program association table (PAT).
    ///Params:
    ///    ppPAT = Address of a variable that receives an IPAT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetPAT(IPAT* ppPAT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCAT</b> method retrieves the conditional access table (CAT).
    ///Params:
    ///    dwTimeout = Specifies a time-out value, in milliseconds. If the filter does not receive the data within the time-out
    ///                period, the method fails.
    ///    ppCAT = Address of a variable that receives an ICAT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCAT(uint dwTimeout, ICAT* ppCAT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetPMT</b> method retrieves the program map table (PMT) for a specified packet identifier (PID).
    ///Params:
    ///    pid = Specifies the PID for the requested PMT.
    ///    pwProgramNumber = Optional pointer to a variable that contains a table program number. You can use this value to filter the
    ///                      request. Otherwise, set this parameter to <b>NULL</b>.
    ///    ppPMT = Address of a variable that receives an IPMT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetPMT(ushort pid, ushort* pwProgramNumber, IPMT* ppPMT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTSDT</b> method retrieves the transport stream description table (TSDT).
    ///Params:
    ///    ppTSDT = Address of a variable that receives an ITSDT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTSDT(ITSDT* ppTSDT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetNIT</b> method retrieves the network information table (NIT).
    ///Params:
    ///    tableId = Specifies the table identifier of the NIT. Use one of the values in the following table. <table> <tr>
    ///              <th>Value </th> <th>Description </th> </tr> <tr> <td>DVB_NIT_ACTUAL_TID (0x40)</td> <td>NIT for the network
    ///              that carries this transport stream.</td> </tr> <tr> <td>DVB_NIT_OTHER_TID (0x41)</td> <td>NIT for another
    ///              network.</td> </tr> </table>
    ///    pwNetworkId = Optional parameter that contains a network identifier. You can use this value to filter the request.
    ///                  Otherwise, set this parameter to <b>NULL</b>.
    ///    ppNIT = Address of a variable that receives an IDVB_NIT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetNIT(ubyte tableId, ushort* pwNetworkId, IDVB_NIT* ppNIT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetSDT</b> method retrieves the service description table (SDT).
    ///Params:
    ///    tableId = Specifies the table identifier of the SDT. Use one of the values in the following table. <table> <tr>
    ///              <th>Value </th> <th>Description </th> </tr> <tr> <td>DVB_SDT_ACTUAL_TID (0x42)</td> <td>SDT for the current
    ///              transport stream.</td> </tr> <tr> <td>DVB_SDT_OTHER_TID (0x46)</td> <td>SDT for another transport
    ///              stream.</td> </tr> </table>
    ///    pwTransportStreamId = Optional parameter that contains a transport stream identifier (TSID). You can use this value to filter the
    ///                          request. Otherwise, set this parameter to <b>NULL</b>.
    ///    ppSDT = Address of a variable that receives an IDVB_SDT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSDT(ubyte tableId, ushort* pwTransportStreamId, IDVB_SDT* ppSDT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetEIT</b> method retrieves the event information table (EIT).
    ///Params:
    ///    tableId = Specifies the table identifier of the EIT. Use one of the values in the following table. <table> <tr>
    ///              <th>Value </th> <th>Description </th> </tr> <tr> <td>DVB_EIT_ACTUAL_TID (0x4E)</td> <td>Present/following EIT
    ///              for this transport stream.</td> </tr> <tr> <td>DVB_EIT_OTHER_TID (0x4F)</td> <td>Present/following EIT for
    ///              another transport stream.</td> </tr> <tr> <td>0x50 – 0x5F</td> <td>Schedule EIT for this transport
    ///              stream.</td> </tr> <tr> <td>0x60 – 0x6F</td> <td>Schedule EIT for another transport stream.</td> </tr>
    ///              </table>
    ///    pwServiceId = Optional parameter that contains a service identifier. You can use this value to filter the request.
    ///                  Otherwise, set this parameter to <b>NULL</b>.
    ///    ppEIT = Address of a variable that receives an IDVB_EIT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEIT(ubyte tableId, ushort* pwServiceId, IDVB_EIT* ppEIT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetBAT</b> method retrieves the bouquet association table (BAT).
    ///Params:
    ///    pwBouquetId = Optional parameter that contains a bouquet identifier. You can use this value to filter the request.
    ///                  Otherwise, set this parameter to <b>NULL</b>.
    ///    ppBAT = Address of a variable that receives an IDVB_BAT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetBAT(ushort* pwBouquetId, IDVB_BAT* ppBAT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRST</b> method retrieves the running status table (RST).
    ///Params:
    ///    dwTimeout = Specifies a time-out value, in milliseconds. If the filter does not receive the data within the time-out
    ///                period, the method fails.
    ///    ppRST = Address of a variable that receives an IDVB_RST interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRST(uint dwTimeout, IDVB_RST* ppRST);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetST</b> method retrieves the stuffing table (ST).
    ///Params:
    ///    pid = Specifies the packet identifier (PID) for the ST. Valid PIDs are in the range 0x10 through 0x14, inclusive.
    ///    dwTimeout = Specifies a time-out value, in milliseconds. If the filter does not receive the data within the time-out
    ///                period, the method fails.
    ///    ppST = Address of a variable that receives an IDVB_ST interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetST(ushort pid, uint dwTimeout, IDVB_ST* ppST);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTDT</b> method retrieves the time and date table (TDT).
    ///Params:
    ///    ppTDT = Address of a variable that receives an IDVB_TDT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTDT(IDVB_TDT* ppTDT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTOT</b> method retrieves the time offset table (TOT).
    ///Params:
    ///    ppTOT = Address of a variable that receives an IDVB_TOT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTOT(IDVB_TOT* ppTOT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetDIT</b> method retrieves the discontinuity information table (DIT).
    ///Params:
    ///    dwTimeout = Specifies a time-out value, in milliseconds. If the filter does not receive the data within the time-out
    ///                period, the method fails.
    ///    ppDIT = Address of a variable that receives an IDVB_DIT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDIT(uint dwTimeout, IDVB_DIT* ppDIT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetSIT</b> method retrieves the selection information table (SIT).
    ///Params:
    ///    dwTimeout = Specifies a time-out value, in milliseconds. If the filter does not receive the data within the time-out
    ///                period, the method fails.
    ///    ppSIT = Address of a variable that receives an IDVB_SIT interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSIT(uint dwTimeout, IDVB_SIT* ppSIT);
}

///The <b>IDvbSiParser2</b> interface retrieves program specific information (PSI) and service information (SI) tables
///from a DVB transport stream.
@GUID("0AC5525F-F816-42F4-93BA-4C0F32F46E54")
interface IDvbSiParser2 : IDvbSiParser
{
    ///The <b>GetEIT2</b> method gets the event information table (EIT).
    ///Params:
    ///    tableId = Specifies the table identifier of the EIT. Use one of the following values. <table> <tr> <th>Value</th>
    ///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DVB_EIT_ACTUAL_TID"></a><a
    ///              id="dvb_eit_actual_tid"></a><dl> <dt><b>DVB_EIT_ACTUAL_TID</b></dt> <dt> 0x4E</dt> </dl> </td> <td
    ///              width="60%"> Present/following EIT for this transport stream. </td> </tr> <tr> <td width="40%"><a
    ///              id="DVB_EIT_OTHER_TID_"></a><a id="dvb_eit_other_tid_"></a><dl> <dt><b>DVB_EIT_OTHER_TID </b></dt>
    ///              <dt>0x4F</dt> </dl> </td> <td width="60%"> Present/following EIT for another transport stream. </td> </tr>
    ///              <tr> <td width="40%"> <dl> <dt>0x50 – 0x5F</dt> </dl> </td> <td width="60%"> Schedule EIT for this
    ///              transport stream. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x60 – 0x6F</dt> </dl> </td> <td width="60%">
    ///              Schedule EIT for another transport stream. </td> </tr> </table>
    ///    pwServiceId = An optional parameter that contains a service identifier. You can use this value to filter the request.
    ///                  Otherwise, set this parameter to <b>NULL</b>.
    ///    pbSegment = An optional parameter that contains a segment number. You can use this value to filter the request.
    ///                Otherwise, set this parameter to <b>NULL</b>.
    ///    ppEIT = Receives a pointer to the IDVB_EIT2 interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_SECTION_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The filter did not receive the table
    ///    in the allotted time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEIT2(ubyte tableId, ushort* pwServiceId, ubyte* pbSegment, IDVB_EIT2* ppEIT);
}

///Implements methods that retrieve program specific information (PSI) tables and service information tables from an
///Integrated Services Digital Broadcast (ISDB) transport stream.
@GUID("900E4BB7-18CD-453F-98BE-3BE6AA211772")
interface IIsdbSiParser2 : IDvbSiParser2
{
    ///Gets a service description table (SDT) from an Integrated Services Digital Broadcast (ISDB) transport stream. An
    ///SDT lists the names and other parameters of the services in an MPEG-2 transport stream.
    ///Params:
    ///    tableId = Table identifier for the type of table to retrieve. For an SDT, this value is 0x42 for an actual transport
    ///              stream, or 0x46 for another stream.
    ///    pwTransportStreamId = Pointer to the transport_stream_id field. This field value uniquely identifies the transport stream that
    ///                          contains the SDT.
    ///    ppSDT = Receives a pointer to the IISDB_SDTinterface. Use this interface to retrieve the information in the table.
    ///            The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSDT(ubyte tableId, ushort* pwTransportStreamId, IISDB_SDT* ppSDT);
    ///Gets the broadcaster information table (BIT) from an Integrated Services Digital Broadcasting (ISDB) transport
    ///stream. A BIT contains a broadcaster unit and the service information transmission parameter for each broadcaster
    ///unit.
    ///Params:
    ///    tableId = Table identifier for the type of table to retrieve. For a BIT, this value is 0xC4.
    ///    pwOriginalNetworkId = Pointer to the original_network_id field for the BIT. This field contains an identifier for the broadcaster
    ///                          that originates the MPEG-2 transport stream
    ///    ppBIT = Receives a pointer to the IISDB_BITinterface. Use this interface to retrieve the information in the table.
    ///            The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBIT(ubyte tableId, ushort* pwOriginalNetworkId, IISDB_BIT* ppBIT);
    ///Gets the network board information table (NBIT) from an Integrated Services Digital Broadcast (ISDB) transport
    ///stream. The NBIT describes the programs included in a multiplexed transport stream.
    ///Params:
    ///    tableId = Table identifier for the type of table to retrieve. For an NBIT, this value is 0xC5 if the table contains the
    ///              network board information body, or 0xC6 if the table contains reference information for retrieving the
    ///              network board information.
    ///    pwOriginalNetworkId = Pointer to the original_network_id field for the NBIT. This field contains an identifier for the broadcaster
    ///                          that originates the MPEG-2 transport stream
    ///    ppNBIT = Receives a pointer to the IISDB_NBITinterface. Use this interface to retrieve the information in the table.
    ///             The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetNBIT(ubyte tableId, ushort* pwOriginalNetworkId, IISDB_NBIT* ppNBIT);
    ///Gets a linked description table (LDT) from an Integrated Services Digital Broadcast (ISDB) transport stream. An
    ///LDT contains data that is used to collect reference information from other tables.
    ///Params:
    ///    tableId = Table identifier for the type of table to retrieve. For an LDT, this value is 0xC7.
    ///    pwOriginalServiceId = Pointer to the original_service_id field for the LDT. This field contains an identifier for the service for
    ///                          this transport stream.
    ///    ppLDT = Receives a pointer to the IISDB_LDTinterface. Use this interface to retrieve the information in the table.
    ///            The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLDT(ubyte tableId, ushort* pwOriginalServiceId, IISDB_LDT* ppLDT);
    ///Gets the software download trigger table (SDTT) from an Integrated Services Digital Broadcast (ISDB) transport
    ///stream. An SDTT contains download information such as the service identifier, schedule, and receiver types for
    ///revision.
    ///Params:
    ///    tableId = Table identifier for the type of table to retrieve. For an SDTT, this value is 0xC34.
    ///    pwTableIdExt = Value of the table_id_extension field for the SDTT. This field value identifies a specific instance of the
    ///                   SDTT.
    ///    ppSDTT = Receives a pointer to the IISDB_SDTTinterface. Use this interface to retrieve the information in the table.
    ///             The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSDTT(ubyte tableId, ushort* pwTableIdExt, IISDB_SDTT* ppSDTT);
    ///Gets the common data table (CDT) from an Integrated Services Digital Broadcasting (ISDB) transport stream. A CDT
    ///contains data that is needed for receivers and stored in nonvolatile memory, such as company logos.
    ///Params:
    ///    tableId = Table identifier for the type of table to retrieve. For a CDT, this value is 0xC8.
    ///    bSectionNumber = Specifies the value of the section_number field for the CDT.
    ///    pwDownloadDataId = Pointer to the download_data_id field value for the CDT.
    ///    ppCDT = Receives a pointer to the IISDB_CDTinterface. Use this interface to retrieve the information in the table.
    ///            The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCDT(ubyte tableId, ubyte bSectionNumber, ushort* pwDownloadDataId, IISDB_CDT* ppCDT);
    ///Gets the entitlement management message (EMM) table from an Integrated Services Digital Broadcast (ISDB)
    ///transport stream. An EMM contains conditional access data, such as contract information for subscribers, keys to
    ///decrypt common information, and the authorization levels or services of specific decoders.
    ///Params:
    ///    pid = Specifies the packet identifier (PID) of the transport stream packet that transmits the EMM.
    ///    wTableIdExt = Value of the table_id field for the EMM. This field value identifies a subtable in the EMM.
    ///    ppEMM = Receives a pointer to the IISDB_EMMinterface. Use this interface to retrieve the information in the table.
    ///            The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEMM(ushort pid, ushort wTableIdExt, IISDB_EMM* ppEMM);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDVB_NIT</b> interface enables the client to get information from a network information table (NIT). The
///IDvbSiParser::GetNIT method returns a pointer to this interface. A NIT contains information about the network and the
///physical organization of the transport streams. Because a network typically carries more than one transport stream,
///the NIT can provide information for tuning and for locating particular transport streams. A NIT carried on one
///network may contain information about another network. The original_network_id and transport_stream_id fields
///together uniquely define a transport stream within the network. The NIT may contain one or more table-wide
///descriptors. In addition, each record in the NIT may have one or more descriptors. To get the table-wide descriptors,
///use the <b>GetTableDescriptorByIndex</b> or <b>GetTableDescriptorByTag</b> method. To get the record descriptors, use
///the <b>GetRecordDescriptorByIndex</b> or <b>GetRecordDescriptorByTag</b> method.
@GUID("C64935F4-29E4-4E22-911A-63F7F55CB097")
interface IDVB_NIT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IDvbSiParser::GetNIT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td width="60%">
    ///    Malformed table. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    method succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVersionNumber</b> method returns the version number for the NIT.
    ///Params:
    ///    pbVal = Pointer to a variable that receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetNetworkId</b> method returns the network identifier for the NIT.
    ///Params:
    ///    pwVal = Pointer to a variable that receives the network_id field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetNetworkId(ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfTableDescriptors</b> method returns the number of table-wide descriptors in the NIT.
    ///Params:
    ///    pdwVal = Pointer to a variable that receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfTableDescriptors(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByIndex</b> method retrieves a table-wide descriptor for the NIT.
    ///Params:
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IDVB_NIT::GetCountOfTableDescriptors
    ///              method to get the number of table descriptors in the NIT.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTableDescriptorByIndex(uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByTag</b> method searches the NIT for a table-wide descriptor with the specified descriptor
    ///tag.
    ///Params:
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTableDescriptorByTag(ubyte bTag, uint* pdwCookie, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfRecords</b> method returns the number of records in the NIT.
    ///Params:
    ///    pdwVal = Pointer to a variable that receives the number of records.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordTransportStreamId</b> method returns the transport stream identifier (TSID) for a record in the NIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_NIT::GetCountOfRecords method to get the number
    ///                    of records in the NIT.
    ///    pwVal = Pointer to a variable that receives the transport_stream_id field. This value identifies the transport stream
    ///            from other transport streams in the multiplex.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordTransportStreamId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordOriginalNetworkId</b> method returns the original network identifier for a record in the NIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_NIT::GetCountOfRecords method to get the number
    ///                    of records in the NIT.
    ///    pwVal = Pointer to a variable that receives the original_network_id field. This value identifies the network_id of
    ///            the originating delivery system.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordOriginalNetworkId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordCountOfDescriptors</b> method returns the number of descriptors for a record in the NIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_NIT::GetCountOfRecords method to get the number
    ///                    of records in the NIT.
    ///    pdwVal = Pointer to a variable that receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByIndex</b> method retrieves a descriptor for a specified record in the NIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_NIT::GetCountOfRecords method to get the number
    ///                    of records in the NIT.
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IDVB_NIT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByTag</b> method searches a record in the NIT for a descriptor with a specified descriptor
    ///tag.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_NIT::GetCountOfRecords method to get the number
    ///                    of records in the NIT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>RegisterForNextTable</b> method registers the client to be notified when a <i>next</i> table arrives that will
    ///replace the current table.
    ///Params:
    ///    hNextTableAvailable = Handle to an event created by the caller. The object signals the event when the <i>next</i> table arrives.
    ///                          When the event is signaled, call the IDVB_NIT::GetNextTable method to retrieve the table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>next</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableAvailable</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForNextTable(HANDLE hNextTableAvailable);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetNextTable</b> method retrieves the <i>next</i> table that follows the current table.
    ///Params:
    ///    ppNIT = Address of a variable that receives an <b>IDVB_NIT</b> interface pointer. The caller must release the
    ///            interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is not current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetNextTable(IDVB_NIT* ppNIT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>RegisterForWhenCurrent</b> method registers the client to be notified when the table becomes current.
    ///Params:
    ///    hNextTableIsCurrent = Handle to an event created by the caller. The object signals the event when the table becomes current.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>current</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableIsCurrent</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForWhenCurrent(HANDLE hNextTableIsCurrent);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>ConvertNextToCurrent</b> method converts a <i>next</i> table to a <i>current</i> table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <b>RegisterForWhenCurrent</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The new <i>current</i> table is malformed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ConvertNextToCurrent();
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVersionHash</b> method returns a hash value for this table instance. The hash value has the property that
    ///tables referring to the same content, but with different version_number and table_id fields, will return the same
    ///hash value. You can use this hash value to identify when two tables carry the same information, even if the
    ///tables are carried on different transport streams.
    ///Params:
    ///    pdwVersionHash = Receives the hash value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionHash(uint* pdwVersionHash);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDVB_SDT</b> interface enables the client to get information from a service description table (SDT). The
///IDvbSiParser::GetSDT method returns a pointer to this interface. An SDT describes one or more services that are
///carried in a particular transport stream. The services may be carried in the same transport stream that carries the
///SDT, or a different transport stream.
@GUID("02CAD8D3-FE43-48E2-90BD-450ED9A8A5FD")
interface IDVB_SDT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IDvbSiParser::GetSDT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVersionNumber</b> method returns the version number for the SDT.
    ///Params:
    ///    pbVal = Pointer to a variable that receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTransportStreamId</b> method returns the transport stream identifier (TSID) for the SDT.
    ///Params:
    ///    pwVal = Pointer to a variable that receives the transport_stream_id field. This value identifies the transport stream
    ///            from other transport streams in the multiplex.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTransportStreamId(ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetOriginalNetworkId</b> method returns the original network identifier.
    ///Params:
    ///    pwVal = Pointer to a variable that receives the original_network_id field. This value identifies the network_id of
    ///            the originating delivery system.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetOriginalNetworkId(ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfRecords</b> method returns the number of records in the SDT.
    ///Params:
    ///    pdwVal = Pointer to a variable that receives the number of records.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordServiceId</b> method returns the service identifier for a record in the SDT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_SDT::GetCountOfRecords to get the number of records
    ///                    in the SDT.
    ///    pwVal = Pointer to a variable that receives the service_id field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordServiceId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordEITScheduleFlag</b> method queries whether the current transport stream contains schedule EIT
    ///information for a particular service.
    ///Params:
    ///    dwRecordIndex = Specifies the record number for the service, indexed from zero. Call IDVB_SDT::GetCountOfRecords to get the
    ///                    number of records in the SDT.
    ///    pfVal = Pointer to a variable that receives a Boolean value. The value is <b>TRUE</b> if the EIT_schedule_flag bit is
    ///            set, or <b>FALSE</b> otherwise. The value <b>TRUE</b> indicates that the current transport stream contains
    ///            schedule EIT information for the service.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordEITScheduleFlag(uint dwRecordIndex, int* pfVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordEITPresentFollowingFlag</b> method queries whether the current transport stream contains
    ///present/following EIT information for a particular service.
    ///Params:
    ///    dwRecordIndex = Specifies the record number for the service, indexed from zero. Call IDVB_SDT::GetCountOfRecords to get the
    ///                    number of records in the SDT.
    ///    pfVal = Pointer to a variable that receives a Boolean value. The value is <b>TRUE</b> if the
    ///            EIT_present_following_flag bit is set, or <b>FALSE</b> otherwise. The value <b>TRUE</b> indicates that the
    ///            current transport stream contains present/following EIT information for the service.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordEITPresentFollowingFlag(uint dwRecordIndex, int* pfVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordRunningStatus</b> method returns the running status of a particular service in the SDT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number for the service, indexed from zero. Call IDVB_SDT::GetCountOfRecords to get the
    ///                    number of records in the SDT.
    ///    pbVal = Pointer to a variable that receives the running_status field. See the Remarks section in the
    ///            IDVB_RST::GetRecordRunningStatus method for more information.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordRunningStatus(uint dwRecordIndex, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordFreeCAMode</b> method queries whether any of the component streams for a particular service are
    ///scrambled.
    ///Params:
    ///    dwRecordIndex = Specifies the record number for the service, indexed from zero. Call IDVB_SDT::GetCountOfRecords to get the
    ///                    number of records in the SDT.
    ///    pfVal = Pointer to a variable that receives a Boolean value. The value is <b>TRUE</b> if the free_CA_mode bit is set,
    ///            which indicates that one or more streams are scrambled. Otherwise, the value is <b>FALSE</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordFreeCAMode(uint dwRecordIndex, int* pfVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordCountOfDescriptors</b> method returns the number of descriptors for a record in the SDT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_SDT::GetCountOfRecords to get the number of records
    ///                    in the SDT.
    ///    pdwVal = Pointer to a variable that receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByIndex</b> method retrieves a descriptor for a specified record in the SDT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_SDT::GetCountOfRecords to get the number of records
    ///                    in the SDT.
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IDVB_SDT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByTag</b> method searches a record in the SDT for a descriptor with a specified descriptor
    ///tag.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_SDT::GetCountOfRecords to get the number of records
    ///                    in the SDT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>RegisterForNextTable</b> method registers the client to be notified when a <i>next</i> table arrives that will
    ///replace the current table.
    ///Params:
    ///    hNextTableAvailable = Handle to an event created by the caller. The object signals the event when the <i>next</i> table arrives.
    ///                          When the event is signaled, call IDVB_SDT::GetNextTable to retrieve the table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>next</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableAvailable</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForNextTable(HANDLE hNextTableAvailable);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetNextTable</b> method retrieves the <i>next</i> table that follows the current table.
    ///Params:
    ///    ppSDT = Address of a variable that receives an <b>IDVB_SDT</b> interface pointer. The caller must release the
    ///            interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is not current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetNextTable(IDVB_SDT* ppSDT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>RegisterForWhenCurrent</b> method registers the client to be notified when the table becomes current.
    ///Params:
    ///    hNextTableIsCurrent = Handle to an event created by the caller. The object signals the event when the table becomes current.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>current</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableIsCurrent</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForWhenCurrent(HANDLE hNextTableIsCurrent);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>ConvertNextToCurrent</b> method converts a <i>next</i> table to a <i>current</i> table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <b>RegisterForWhenCurrent</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The new <i>current</i> table is malformed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ConvertNextToCurrent();
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVersionHash</b> method returns a hash value for this table instance. The hash value has the property that
    ///tables referring to the same content, but with different version_number and table_id fields, will return the same
    ///hash value. You can use this hash value to identify when two tables carry the same information, even if the
    ///tables are carried on different transport streams.
    ///Params:
    ///    pdwVersionHash = Receives the hash value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionHash(uint* pdwVersionHash);
}

///Implements methods that get information from an Integrated Services Digital Broadcasting (ISDB) service description
///table (SDT). An SDT lists the names and other parameters of the services in an MPEG-2 transport stream. To obtain a
///pointer to this interface, first make sure that the media graph is in a running state and that the stream you are
///tuned to contains an SDT. Then: <ol> <li>Query the BDA MPEG-2 Transport Information Filter to obtain a pointer to the
///IPSITables interface. (You can also go through the graph and query each filter until you find one that supports
///<b>IPSITables</b>.)</li> <li>Call the IPSITables::GetTable method. The interface pointer for the desired table is
///returned in the <i>ppIUnknown</i> output parameter. </li> </ol>
@GUID("3F3DC9A2-BB32-4FB9-AE9E-D856848927A3")
interface IISDB_SDT : IDVB_SDT
{
    ///Returns the EIT_user_defined_flags field value from a service descriptor in an Integrated Services Digital
    ///Broadcasting (ISDB) service description table (SDT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_SDT::GetCountOfRecordsmethod to get the number
    ///                    of records in the SDT.
    ///    pbVal = Receives the EIT_user_defined_flags field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordEITUserDefinedFlags(uint dwRecordIndex, ubyte* pbVal);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDVB_EIT</b> interface enables the client to get information from a DVB event information table (EIT). The
///IDvbSiParser::GetEIT method returns a pointer to this interface. An EIT provides information about events in each
///service, such as the event name, the start time, and the duration. An EIT can hold information about the transport
///stream that carries it, or it can hold information about other transport streams. There are two types of EITs: <ul>
///<li><i>Present/following</i> EITs contain information about the current event and the next chronological event. This
///type of EIT can be used to create a simple user interface at the receiver.</li> <li><i>Schedule</i> EITs contain a
///list of events that occur after the next event. This type of event can be used to create an electronic program guide
///(EPG).</li> </ul>EIT sections are given the following table identifiers (TIDs). <table> <tr> <th>TID</th>
///<th>Description</th> </tr> <tr> <td>0x4E</td> <td>Present/following EIT for this transport stream.</td> </tr> <tr>
///<td>0x4F</td> <td>Present/following EIT for another transport stream. </td> </tr> <tr> <td>0x50 – 0x5F</td>
///<td>Schedule EIT for this transport stream.</td> </tr> <tr> <td>0x60 – 0x6F</td> <td>Schedule EIT for another
///transport stream.</td> </tr> </table>
@GUID("442DB029-02CB-4495-8B92-1C13375BCE99")
interface IDVB_EIT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IDvbSiParser::GetEIT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVersionNumber</b> method returns the version number for the EIT.
    ///Params:
    ///    pbVal = Pointer to a variable that receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetServiceId</b> method returns the service identifier, which distinguishes the service from other services
    ///carried in the transport stream.
    ///Params:
    ///    pwVal = Pointer to a variable that receives the service_id field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetServiceId(ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTransportStreamId</b> method returns the transport stream identifier (TSID) for the EIT.
    ///Params:
    ///    pwVal = Pointer to a variable that receives the transport_stream_id field. This value identifies the transport stream
    ///            from other transport streams in the multiplex.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTransportStreamId(ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetOriginalNetworkId</b> method returns the original network identifier.
    ///Params:
    ///    pwVal = Pointer to a variable that receives the original_network_id field. This value identifies the network_id of
    ///            the originating delivery system.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetOriginalNetworkId(ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetSegmentLastSectionNumber</b> method returns the section number of the last section in the subtable that
    ///contains this section.
    ///Params:
    ///    pbVal = Pointer to a variable that receives the last_section_number field
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSegmentLastSectionNumber(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetLastTableId</b> method returns the last table identifier used. If there are multiple EITs, the event
    ///information is chronological across successive table identifiers.
    ///Params:
    ///    pbVal = Pointer to a variable that receives the last_table_id field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetLastTableId(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfRecords</b> method returns the number of records in the EIT.
    ///Params:
    ///    pdwVal = Pointer to a variable that receives the number of records.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordEventId</b> method returns the event identifier for a record in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_EIT::GetCountOfRecords to get the number of records
    ///                    in the EIT.
    ///    pwVal = Pointer to a variable that receives the event_id field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordEventId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordStartTime</b> method returns the event start time for a record in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_EIT::GetCountOfRecords to get the number of records
    ///                    in the EIT.
    ///    pmdtVal = Pointer to an MPEG_DATE_AND_TIME structure allocated by the caller. The method fills the structure with the
    ///              event start time.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordStartTime(uint dwRecordIndex, MPEG_DATE_AND_TIME* pmdtVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDuration</b> method returns the event duration for a record in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_EIT::GetCountOfRecords to get the number of records
    ///                    in the EIT.
    ///    pmdVal = Pointer to an MPEG_DURATION structure allocated by the caller. The method fills the structure with the event
    ///             duration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordDuration(uint dwRecordIndex, MPEG_TIME* pmdVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordRunningStatus</b> method returns the running status of a particular event in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number for the event, indexed from zero. Call IDVB_EIT::GetCountOfRecords to get the
    ///                    number of records in the EIT.
    ///    pbVal = Pointer to a variable that receives the running_status field. See the Remarks section in the
    ///            IDVB_RST::GetRecordRunningStatus method for more information.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordRunningStatus(uint dwRecordIndex, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordFreeCAMode</b> method queries whether any of the component streams for an event are scrambled.
    ///Params:
    ///    dwRecordIndex = Specifies the record number for the event, indexed from zero. Call IDVB_EIT::GetCountOfRecords to get the
    ///                    number of records in the EIT.
    ///    pfVal = Pointer to a variable that receives a Boolean value. The value is <b>TRUE</b> if the free_CA_mode bit is set,
    ///            which indicates that one or more streams are scrambled. Otherwise, the value is <b>FALSE</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordFreeCAMode(uint dwRecordIndex, int* pfVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordCountOfDescriptors</b> method returns the number of descriptors for a record in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_EIT::GetCountOfRecords to get the number of records
    ///                    in the EIT.
    ///    pdwVal = Pointer to a variable that receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByIndex</b> method retrieves a descriptor for a specified record in the EIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_EIT::GetCountOfRecords to get the number of records
    ///                    in the EIT.
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IDVB_EIT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByTag</b> method searches a record in the EIT for a descriptor with a specified descriptor
    ///tag.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_EIT::GetCountOfRecords to get the number of records
    ///                    in the EIT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>RegisterForNextTable</b> method registers the client to be notified when a <i>next</i> table arrives that will
    ///replace the current table.
    ///Params:
    ///    hNextTableAvailable = Handle to an event created by the caller. The object signals the event when the next table arrives. When the
    ///                          event is signaled, call the IDVB_EIT::GetNextTable method to retrieve the table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>next</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableAvailable</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForNextTable(HANDLE hNextTableAvailable);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetNextTable</b> method retrieves the <i>next</i> table that follows the current table.
    ///Params:
    ///    ppEIT = Address of a variable that receives an <b>IDVB_EIT</b> interface pointer. The caller must release the
    ///            interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is not current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetNextTable(IDVB_EIT* ppEIT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>RegisterForWhenCurrent</b> method registers the client to be notified when the table becomes current.
    ///Params:
    ///    hNextTableIsCurrent = Handle to an event created by the caller. The object signals the event when the table becomes current.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>current</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableIsCurrent</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForWhenCurrent(HANDLE hNextTableIsCurrent);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>ConvertNextToCurrent</b> method converts a <i>next</i> table to a <i>current</i> table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <b>RegisterForWhenCurrent</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The new <i>current</i> table is malformed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ConvertNextToCurrent();
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVersionHash</b> method returns a hash value for this table instance. The hash value has the property that
    ///tables referring to the same content, but with different version_number and table_id fields, will return the same
    ///hash value. You can use this hash value to identify when two tables carry the same information, even if the
    ///tables are carried on different transport streams.
    ///Params:
    ///    pdwVersionHash = Receives the hash value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionHash(uint* pdwVersionHash);
}

///The <b>IDVB_EIT2</b> interface enables an application to get information from a Digital Video Broadcasting (DVB)
///event information table (EIT). The IDvbSiParser2::GetEIT2 method returns a pointer to this interface. This interface
///extends the IDVB_EIT interface. An EIT provides information about events in each service, such as the event name, the
///start time, and the duration. An EIT can hold information about the transport stream that carries it, or it can hold
///information about other transport streams. There are two types of EITs: <ul> <li><i>Present/following</i> EITs
///contain information about the current event and the next chronological event. This type of EIT can be used to create
///a simple user interface at the receiver.</li> <li><i>Schedule</i> EITs contain a list of events that occur after the
///next event. This type of event can be used to create an electronic program guide (EPG).</li> </ul>EIT sections are
///given the following table identifiers (TIDs). <table> <tr> <th>TID</th> <th>Description</th> </tr> <tr> <td>0x4E</td>
///<td>Present/following EIT for this transport stream.</td> </tr> <tr> <td>0x4F</td> <td>Present/following EIT for
///another transport stream. </td> </tr> <tr> <td>0x50 – 0x5F</td> <td>Schedule EIT for this transport stream.</td>
///</tr> <tr> <td>0x60 – 0x6F</td> <td>Schedule EIT for another transport stream.</td> </tr> </table>
@GUID("61A389E0-9B9E-4BA0-AEEA-5DDD159820EA")
interface IDVB_EIT2 : IDVB_EIT
{
    ///Gets the table identifier and segment number for the current EIT segment.
    ///Params:
    ///    pbTid = Receives the table identifier.
    ///    pbSegment = Receives the segment number.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The Initialize method was not called.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetSegmentInfo(ubyte* pbTid, ubyte* pbSegment);
    ///Gets the number of a section containing an event information table (EIT) record.
    ///Params:
    ///    dwRecordIndex = The record number, indexed from 0. Call IDVB_EIT::GetCountOfRecords to get the number of records in the EIT.
    ///    pbVal = Receives the number of the section containing the specified record. A value of 0 indicates the present
    ///            section; a value of 1 indicates the following section.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_UNINITIALIZED</b></dt> </dl> </td> <td width="60%"> The Initialize method
    ///    was not called. </td> </tr> </table>
    ///    
    HRESULT GetRecordSection(uint dwRecordIndex, ubyte* pbVal);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDVB_BAT</b> interface enables the client to get data from a bouquet association table (BAT). The
///IDvbSiParser::GetBAT method returns a pointer to this interface. A bouquet is a collection of services that are
///marketed as one entity. A single bouquet may contain several transport streams that are delivered across different
///distribution media (satellite, cable, or terrestrial). The BAT may contain one or more table-wide descriptors. In
///addition, each record in the BAT may have one or more descriptors. To get the table-wide descriptors, use the
///<b>GetTableDescriptorByIndex</b> or <b>GetTableDescriptorByTag</b> method. To get the record descriptors, use the
///<b>GetRecordDescriptorByIndex</b> or <b>GetRecordDescriptorByTag</b> method.
@GUID("ECE9BB0C-43B6-4558-A0EC-1812C34CD6CA")
interface IDVB_BAT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IDvbSiParser::GetBAT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVersionNumber</b> method returns the version number for the BAT.
    ///Params:
    ///    pbVal = Pointer to a variable that receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetBouquetId</b> method returns the bouquet identifier for the BAT.
    ///Params:
    ///    pwVal = Pointer to a variable that receives the bouquet_id field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_UNDEFINED</b></dt> </dl> </td> <td width="60%"> The table does not contain
    ///    this field. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetBouquetId(ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfTableDescriptors</b> method returns the number of table-wide descriptors in the BAT.
    ///Params:
    ///    pdwVal = Pointer to a variable that receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCountOfTableDescriptors(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByIndex</b> method retrieves a table-wide descriptor for the BAT.
    ///Params:
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IDVB_BAT::GetCountOfTableDescriptors
    ///              method to get the number of table descriptors in the BAT.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTableDescriptorByIndex(uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByTag</b> method searches the BAT for a table-wide descriptor with the specified descriptor
    ///tag.
    ///Params:
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTableDescriptorByTag(ubyte bTag, uint* pdwCookie, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfRecords</b> method returns the number of records in the BAT. Each record contains information about
    ///a particular transport stream in the bouquet.
    ///Params:
    ///    pdwVal = Pointer to a variable that receives the number of records.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordTransportStreamId</b> method returns the transport stream identifier (TSID) for a record in the BAT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_BAT::GetCountOfRecords method to get the number
    ///                    of records in the BAT.
    ///    pwVal = Pointer to a variable that receives the transport_stream_id field. This value identifies the transport stream
    ///            from other transport streams in the multiplex.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordTransportStreamId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordOriginalNetworkId</b> method returns the original network identifier for a record in the BAT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_BAT::GetCountOfRecords method to get the number
    ///                    of records in the BAT.
    ///    pwVal = Pointer to a variable that receives the original_network_id field. This value identifies the network_id of
    ///            the originating delivery system.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordOriginalNetworkId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordCountOfDescriptors</b> method returns the number of descriptors for a record in the BAT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_BAT::GetCountOfRecords method to get the number
    ///                    of records in the BAT.
    ///    pdwVal = Pointer to a variable that receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByIndex</b> method retrieves a descriptor for a specified record in the BAT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_BAT::GetCountOfRecords method to get the number
    ///                    of records in the BAT.
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IDVB_BAT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByTag</b> method searches a record in the BAT for a descriptor with a specified descriptor
    ///tag.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_BAT::GetCountOfRecords method to get the number
    ///                    of records in the BAT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>RegisterForNextTable</b> method registers the client to be notified when a <i>next</i> table arrives that will
    ///replace the current table.
    ///Params:
    ///    hNextTableAvailable = Handle to an event created by the caller. The object signals the event when the next table arrives. When the
    ///                          event is signaled, call the IDVB_BAT::GetNextTable method to retrieve the table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>next</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableAvailable</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForNextTable(HANDLE hNextTableAvailable);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetNextTable</b> method retrieves the <i>next</i> table that follows the current table.
    ///Params:
    ///    ppBAT = Address of a variable that receives an <b>IDVB_BAT</b> interface pointer. The caller must release the
    ///            interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> This table is not current. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetNextTable(IDVB_BAT* ppBAT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>RegisterForWhenCurrent</b> method registers the client to be notified when the table becomes current.
    ///Params:
    ///    hNextTableIsCurrent = Handle to an event created by the caller. The object signals the event when the table becomes current.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>current</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableIsCurrent</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForWhenCurrent(HANDLE hNextTableIsCurrent);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>ConvertNextToCurrent</b> method converts a <i>next</i> table to a <i>current</i> table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> This table is already current. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The
    ///    <b>RegisterForWhenCurrent</b> method was not called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td width="60%"> The new <i>current</i> table is
    ///    malformed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    method succeeded. </td> </tr> </table>
    ///    
    HRESULT ConvertNextToCurrent();
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDVB_RST</b> interface enables the client to get information from a running status table (RST). The
///IDvbSiParser::GetRST method returns a pointer to this interface. The RST enables the provider to update the timing
///status for one or more events, which may be needed if the schedule changes.
@GUID("F47DCD04-1E23-4FB7-9F96-B40EEAD10B2B")
interface IDVB_RST : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IDvbSiParser::GetRST method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfRecords</b> method returns the number of records in the RST.
    ///Params:
    ///    pdwVal = Pointer to a variable that receives the number of records.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordTransportStreamId</b> method returns the transport stream identifier (TSID) for a record in the RST.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_RST::GetCountOfRecords method to get the number
    ///                    of records in the RST.
    ///    pwVal = Pointer to a variable that receives the transport_stream_id field. This value identifies the transport stream
    ///            from other transport streams in the multiplex.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordTransportStreamId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordOriginalNetworkId</b> method returns the original network identifier for a record in the RST.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_RST::GetCountOfRecords method to get the number
    ///                    of records in the RST.
    ///    pwVal = Pointer to a variable that receives the original_network_id field. This value identifies the network_id of
    ///            the originating delivery system.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordOriginalNetworkId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordServiceId</b> method returns the service identifier for a record in the RST.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_RST::GetCountOfRecords method to get the number
    ///                    of records in the RST.
    ///    pwVal = Pointer to a variable that receives the service_id field. This value distinguishes the service from other
    ///            services carried in the transport stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordServiceId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordEventId</b> method returns the event identifier for a record in the RST.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_RST::GetCountOfRecords method to get the number
    ///                    of records in the RST.
    ///    pwVal = Pointer to a variable that receives the event_id field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordEventId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordRunningStatus</b> method returns the running status for a record in the RST.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IDVB_RST::GetCountOfRecords method to get the number
    ///                    of records in the RST.
    ///    pbVal = Pointer to a variable that receives the running_status field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordRunningStatus(uint dwRecordIndex, ubyte* pbVal);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDVB_ST</b> interface enables the client to get information from a stuffing table (ST). The IDvbSiParser::GetST
///method returns a pointer to this interface. The purpose of an ST is to invalidate existing table sections when the
///transport stream crosses the boundary between delivery systems. To invalidate a table section, the section is
///overwritten with an ST.
@GUID("4D5B9F23-2A02-45DE-BCDA-5D5DBFBFBE62")
interface IDVB_ST : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IDvbSiParser::GetST method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetDataLength</b> method returns the length of the data in the ST.
    ///Params:
    ///    pwVal = Pointer to a variable that receives the length, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDataLength(ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetData</b> method returns the data in the ST.
    ///Params:
    ///    ppData = Address of a variable that receives a pointer to a buffer, which contains all of the data_byte fields in the
    ///             ST. To get the size of the buffer, call the IDVB_ST::GetDataLength method. The caller must release the buffer
    ///             by calling the <b>CoTaskMemFree</b> function.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The ST does not contain any data.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT GetData(ubyte** ppData);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDVB_TDT</b> interface enables the client to get information from a time and date table (TDT). The
///IDvbSiParser::GetTDT method returns a pointer to this interface. The TDT provides the current time and date, in
///Universal Time Coordinated (UTC) format.
@GUID("0780DC7D-D55C-4AEF-97E6-6B75906E2796")
interface IDVB_TDT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IDvbSiParser::GetTDT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td width="60%">
    ///    Malformed table. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    method succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetUTCTime</b> method returns the current UTC time and date.
    ///Params:
    ///    pmdtVal = Pointer to an MPEG_DATE_AND_TIME structure allocated by the caller. The method fills the structure with the
    ///              UTC time and date.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetUTCTime(MPEG_DATE_AND_TIME* pmdtVal);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDVB_TOT</b> interface enables the client to get information from a time offset table (TOT). The
///IDvbSiParser::GetTOT method returns a pointer to this information. A TOT contains the current UTC time, plus the
///offset from UTC for local time in one or more regions. The offsets are contained in a <i>local offset time
///descriptor</i>, as specified by ETSI EN 300 468.
@GUID("83295D6A-FABA-4EE1-9B15-8067696910AE")
interface IDVB_TOT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IDvbSiParser::GetTOT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td width="60%">
    ///    Malformed table. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    method succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetUTCTime</b> method returns the current UTC time and date.
    ///Params:
    ///    pmdtVal = Pointer to an MPEG_DATE_AND_TIME structure allocated by the caller. The method fills the structure with the
    ///              UTC time and date.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetUTCTime(MPEG_DATE_AND_TIME* pmdtVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfTableDescriptors</b> method returns the number of descriptors in the TOT.
    ///Params:
    ///    pdwVal = Pointer to a variable that receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfTableDescriptors(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByIndex</b> method retrieves a descriptor for the TOT.
    ///Params:
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IDVB_TOT::GetCountOfTableDescriptors
    ///              method to get the number of table descriptors in the TOT.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTableDescriptorByIndex(uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByTag</b> method searches the TOT for a descriptor with the specified descriptor tag.
    ///Params:
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTableDescriptorByTag(ubyte bTag, uint* pdwCookie, IGenericDescriptor* ppDescriptor);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDVB_DIT</b> interface enables the client to get information from a discontinuity information table (DIT). The
///IDvbSiParser::GetDIT method returns a pointer to this interface. The presence of a DIT in the stream indicates a
///transition point where the Service Information (SI) may be discontinuous.
@GUID("91BFFDF9-9432-410F-86EF-1C228ED0AD70")
interface IDVB_DIT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IDvbSiParser::GetDIT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td width="60%">
    ///    Malformed table. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    method succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTransitionFlag</b> method queries whether the transition_flag bit is set.
    ///Params:
    ///    pfVal = Pointer to a variable that receives a Boolean value. The value is <b>TRUE</b> if the transition_flag bit is
    ///            set, or <b>FALSE</b> otherwise.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTransitionFlag(int* pfVal);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDVB_SIT</b> interface enables the client to get information from a selection information table (SIT). The
///IDvbSiParser::GetSIT method returns a pointer to this interface. The presence of a SIT in a transport stream
///indicates that the transport stream is <i>partial</i>, meaning the stream contains a subset of a complete broadcast
///stream. A partial transport stream does not carry any service information (SI) tables other than SITs and
///discontinuity information tables (DITs). The SIT contains a summary of the full SI information for the stream. The
///SIT may contain one or more table-wide descriptors. In addition, each record in the SIT may have one or more
///descriptors. To get the table-wide descriptors, use the <b>GetTableDescriptorByIndex</b> or
///<b>GetTableDescriptorByTag</b> method. To get the record descriptors, use the <b>GetRecordDescriptorByIndex</b> or
///<b>GetRecordDescriptorByTag</b> method.
@GUID("68CDCE53-8BEA-45C2-9D9D-ACF575A089B5")
interface IDVB_SIT : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>Initialize</b> method initializes the object using captured table section data. This method is called
    ///internally by the IDvbSiParser::GetSIT method, so applications typically should not call it.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The object is already initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetVersionNumber</b> method returns the version number for the SIT.
    ///Params:
    ///    pbVal = Pointer to a variable that receives the version_number field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfTableDescriptors</b> method returns the number of table-wide descriptors in the SIT.
    ///Params:
    ///    pdwVal = Pointer to a variable that receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfTableDescriptors(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByIndex</b> method retrieves a table-wide descriptor for the SIT.
    ///Params:
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IDVB_SIT::GetCountOfTableDescriptors
    ///              method to get the number of table descriptors in the SIT.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTableDescriptorByIndex(uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTableDescriptorByTag</b> method searches the SIT for a table-wide descriptor with the specified descriptor
    ///tag.
    ///Params:
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTableDescriptorByTag(ubyte bTag, uint* pdwCookie, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfRecords</b> method returns the number of records in the SIT.
    ///Params:
    ///    pdwVal = Pointer to a variable that receives the number of records.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordServiceId</b> method returns the service identifier for a record in the SIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_SIT::GetCountOfRecords to get the number of records
    ///                    in the SIT.
    ///    pwVal = Pointer to a variable that receives the service_id field. This value distinguishes the service from other
    ///            services carried in the transport stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordServiceId(uint dwRecordIndex, ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordRunningStatus</b> method returns the running status of a particular event in the SIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number for the event, indexed from zero. Call IDVB_SIT::GetCountOfRecords to get the
    ///                    number of records in the SIT.
    ///    pbVal = Pointer to a variable that receives the running_status field. See the Remarks section in the
    ///            IDVB_RST::GetRecordRunningStatus method for more information.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordRunningStatus(uint dwRecordIndex, ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordCountOfDescriptors</b> method returns the number of descriptors for a record in the SIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_SIT::GetCountOfRecords to get the number of records
    ///                    in the SIT.
    ///    pdwVal = Pointer to a variable that receives the number of descriptors.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByIndex</b> method retrieves a descriptor for a specified record in the SIT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_SIT::GetCountOfRecords to get the number of records
    ///                    in the SIT.
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IDVB_SIT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordDescriptorByTag</b> method searches a record in the SIT for a descriptor with a specified descriptor
    ///tag.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call IDVB_SIT::GetCountOfRecords to get the number of records
    ///                    in the SIT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MPEG2_E_OUT_OF_BOUNDS</b></dt> </dl> </td> <td width="60%"> Index out of bounds. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_E_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> The specified tag was not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_S_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The record contains at least one more descriptor with this tag. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MPEG2_S_NO_MORE_DATA_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The record does
    ///    not contain any more descriptors with this tag. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>RegisterForNextTable</b> method registers the client to be notified when a <i>next</i> table arrives that will
    ///replace the current table.
    ///Params:
    ///    hNextTableAvailable = Handle to an event created by the caller. The object signals the event when the <i>next</i> table arrives.
    ///                          When the event is signaled, call the IDVB_SIT::GetNextTable method to retrieve the table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>next</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableAvailable</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForNextTable(HANDLE hNextTableAvailable);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetNextTable</b> method retrieves the <i>next</i> table that follows the current table.
    ///Params:
    ///    dwTimeout = Specifies a time-out value, in milliseconds. If the filter does not receive the data within the time-out
    ///                period, the method fails.
    ///    ppSIT = Address of a variable that receives an <b>IDVB_SIT</b> interface pointer. The caller must release the
    ///            interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is not current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetNextTable(uint dwTimeout, IDVB_SIT* ppSIT);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>RegisterForWhenCurrent</b> method registers the client to be notified when the table becomes current.
    ///Params:
    ///    hNextTableIsCurrent = Handle to an event created by the caller. The object signals the event when the table becomes current.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already a <i>current</i> table. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument; <i>hNextTableIsCurrent</i>
    ///    cannot be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_ALREADY_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The method has already been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterForWhenCurrent(HANDLE hNextTableIsCurrent);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>ConvertNextToCurrent</b> method converts a <i>next</i> table to a <i>current</i> table.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> This table is already current. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <b>RegisterForWhenCurrent</b> method was not
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MPEG2_E_MALFORMED_TABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The new <i>current</i> table is malformed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ConvertNextToCurrent();
}

///Implements methods that get information from an Integrated Services Digital Broadcasting (ISDB) broadcaster
///information table (BIT). A BIT contains a broadcaster unit and the service information transmission parameter for
///each broadcaster unit. To obtain a pointer to this interface, first make sure that the media graph is in a running
///state and that the stream you are tuned to contains an BIT. Then: <ol> <li>Query the BDA MPEG-2 Transport Information
///Filter to obtain a pointer to the IPSITables interface. (You can also go through the graph and query each filter
///until you find one that supports <b>IPSITables</b>.)</li> <li>Call the IPSITables::GetTable method. The interface
///pointer for the desired table is returned in the <i>ppIUnknown</i> output parameter. </li> </ol>
@GUID("537CD71E-0E46-4173-9001-BA043F3E49E2")
interface IISDB_BIT : IUnknown
{
    ///Initializes the object by using captured table section data for an Integrated Services Digital Broadcasting
    ///(ISDB) broadcaster information table (BIT).
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///Gets the version number for an Integrated Services Digital Broadcasting (ISDB) broadcaster information table
    ///(BIT).
    ///Params:
    ///    pbVal = Receives the version_number field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///Gets an identifier that identifies the broadcaster that originated the MPEG-2 transport stream from an Integrated
    ///Services Digital Broadcasting (ISDB) broadcaster information table (BIT).
    ///Params:
    ///    pwVal = Receives the original network ID.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOriginalNetworkId(ushort* pwVal);
    ///Returns the broadcast_view_propriety flag from a record in an Integrated Services Digital Broadcasting (ISDB)
    ///broadcaster information table (BIT). The broadcast_view_propriety flag indicates whether the content associated
    ///with the broadcaster unit is appropriate for the age-based category of user.
    ///Params:
    ///    pbVal = Receives the broadcast_view_propriety flag.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBroadcastViewPropriety(ubyte* pbVal);
    ///Gets the broadcaster_descriptors_length field value from an Integrated Services Digital Broadcasting (ISDB)
    ///broadcaster information table (BIT).
    ///Params:
    ///    pdwVal = Receives the broadcaster_descriptors_length field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfTableDescriptors(uint* pdwVal);
    ///Returns a descriptor for a specified table in an Integrated Services Digital Broadcasting (ISDB) broadcaster
    ///information table (BIT).
    ///Params:
    ///    dwIndex = Specifies the record number, indexed from zero. Call the IISDB_BIT::GetCountOfRecords method to get the
    ///              number of records in the BIT.
    ///    ppDescriptor = Specifies which descriptor to retrieve, indexed from zero. Call the IISDB_BIT::GetRecordCountOfDescriptors
    ///                   method to get the number of descriptors for a particular record.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTableDescriptorByIndex(uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///Searches a subtable in for an Integrated Services Digital Broadcasting (ISDB) broadcaster information table
    ///(BIT).
    ///Params:
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i>parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an <a
    ///                   href="/windows/desktop/api/mpeg2psiparser/nn-mpeg2psiparser-igenericdescriptor">IGenericDescriptor
    ///                   </a>interface pointer. Use this interface to retrieve the information in the descriptor. The caller must
    ///                   release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTableDescriptorByTag(ubyte bTag, uint* pdwCookie, IGenericDescriptor* ppDescriptor);
    ///Gets the number of records in an Integrated Services Digital Broadcasting (ISDB) broadcaster information table
    ///(BIT).
    ///Params:
    ///    pdwVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///Gets the broadcaster_id field from a record in an Integrated Services Digital Broadcasting (ISDB) broadcaster
    ///information table (BIT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_BIT::GetCountOfRecords method to get the
    ///                    number of records in the BIT.
    ///    pbVal = Receives the broadcaster_id field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordBroadcasterId(uint dwRecordIndex, ubyte* pbVal);
    ///Returns the number of descriptors for subtables in an Integrated Services Digital Broadcasting (ISDB) broadcaster
    ///information table (BIT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_BIT::GetCountOfRecords method to get the
    ///                    number of records in the BIT.
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///Returns a descriptor for a specified record in an Integrated Services Digital Broadcasting (ISDB) broadcaster
    ///information table (BIT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_BIT::GetCountOfRecords method to get the
    ///                    number of records in the BIT.
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IISDB_BIT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    ppDescriptor = Pointer to the IGenericDescriptor interface implemented by the descriptor.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///Searches a record in an Integrated Services Digital Broadcasting (ISDB) broadcaster information table (BIT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_BIT::GetCountOfRecords method to get the
    ///                    number of records in the BIT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i>parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an <a
    ///                   href="/windows/desktop/api/mpeg2psiparser/nn-mpeg2psiparser-igenericdescriptor">IGenericDescriptor </a>
    ///                   interface pointer. Use this interface to retrieve the information in the descriptor. The caller must release
    ///                   the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
    ///Returns a hash value for this instance of an Integrated Services Digital Broadcasting (ISDB) broadcaster
    ///information table (BIT). Tables that refer to the same content will return the same hash value, even though the
    ///tables have different version_number and table_id fields. You can use this hash value to identify when two tables
    ///carry the same information, even if the tables are carried on different transport streams.
    ///Params:
    ///    pdwVersionHash = Receives the hash value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVersionHash(uint* pdwVersionHash);
}

///Implements methods that get information from an Integrated Services Digital Broadcasting (ISDB) network broadcaster
///information table (NBIT). The NBIT describes the programs included in a multiplexed transport stream for an ISDB
///broadcast. To obtain a pointer to this interface, first make sure that the media graph is in a running state and that
///the stream you are tuned to contains an NBIT. Then: <ol> <li>Query the BDA MPEG-2 Transport Information Filter to
///obtain a pointer to the IPSITables interface. (You can also go through the graph and query each filter until you find
///one that supports <b>IPSITables</b>.)</li> <li>Call the IPSITables::GetTable method. The interface pointer for the
///desired table is returned in the <i>ppIUnknown</i> output parameter. </li> </ol>
@GUID("1B1863EF-08F1-40B7-A559-3B1EFF8CAFA6")
interface IISDB_NBIT : IUnknown
{
    ///Initializes the object by using captured table section data from an Integrated Services Digital Broadcasting
    ///(ISDB) network broadcaster information table (NBIT).
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///Gets the version number of a subtable within an Integrated Services Digital Broadcasting (ISDB) network
    ///broadcaster Information Table (NBIT).
    ///Params:
    ///    pbVal = Receives the version number.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///Gets an identifier that identifies the broadcaster that originated the MPEG-2 transport stream from an Integrated
    ///Services Digital Broadcasting (ISDB) network broadcaster information table (NBIT).
    ///Params:
    ///    pwVal = Receives the original network ID.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOriginalNetworkId(ushort* pwVal);
    ///Gets the number of records in an Integrated Services Digital Broadcasting (ISDB) network broadcaster information
    ///table (NBIT).
    ///Params:
    ///    pdwVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///an Integrated Services Digital Broadcasting (ISDB) network broadcaster information table (NBIT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_NBIT::GetCountOfRecords method to get the
    ///                    number of records in the NBIT.
    ///    pwVal = Receives the information_type field for the record.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordInformationId(uint dwRecordIndex, ushort* pwVal);
    ///Gets an information_type field from a record in an Integrated Services Digital Broadcasting (ISDB) network
    ///broadcaster information table (NBIT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_NBIT::GetCountOfRecords method to get the
    ///                    number of records in the NBIT.
    ///    pbVal = Receives the information_type field. This field can contain any of the following values: <table> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x0</dt> </dl> </td> <td width="60%">
    ///            Undefined </td> </tr> <tr> <td width="40%"> <dl> <dt>0x1</dt> </dl> </td> <td width="60%"> Information (key
    ///            ID: none) </td> </tr> <tr> <td width="40%"> <dl> <dt>0x2</dt> </dl> </td> <td width="60%"> Information with
    ///            service identifier (key ID: service identifier) </td> </tr> <tr> <td width="40%"> <dl> <dt>0x3</dt> </dl>
    ///            </td> <td width="60%"> Information with genre (key ID: content_nibble, user_nibble) </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0x4 - 0xF</dt> </dl> </td> <td width="60%"> Reserved for future use </td> </tr>
    ///            </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordInformationType(uint dwRecordIndex, ubyte* pbVal);
    ///Receives the value of the description_body_location field from a record in an Integrated Services Digital
    ///Broadcasting (ISDB) network broadcaster information table (NBIT). This field value indicates the location of the
    ///table where the information contents are described.
    ///Params:
    ///    dwRecordIndex = Index of a record containing descriptors in the NBIT.
    ///    pbVal = Receives a 2-bit code that indicates the location of the descriptors. This can be any of the following
    ///            values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>00</dt> </dl> </td>
    ///            <td width="60%"> Undefined </td> </tr> <tr> <td width="40%"> <dl> <dt>01</dt> </dl> </td> <td width="60%">
    ///            Detailed information is provided in the actual transport stream (TS) table </td> </tr> <tr> <td width="40%">
    ///            <dl> <dt>10</dt> </dl> </td> <td width="60%"> Detailed information is provided in the service information
    ///            (SI) prime transport stream (TS) table </td> </tr> <tr> <td width="40%"> <dl> <dt>11</dt> </dl> </td> <td
    ///            width="60%"> Reserved for future use </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDescriptionBodyLocation(uint dwRecordIndex, ubyte* pbVal);
    ///Gets the section_number field from a record in Integrated Services Digital Broadcasting (ISDB) network
    ///broadcaster information table (NBIT). The section_ number field identifies the section so that the demultiplexer
    ///can successfully reconstruct the sections in their original order.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_NBIT::GetCountOfRecords method to get the
    ///                    number of records in the NBIT.
    ///    pbVal = Gets the section_number field value from the NBIT record.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordMessageSectionNumber(uint dwRecordIndex, ubyte* pbVal);
    ///Gets the user_defined field from an Integrated Services Digital Broadcasting (ISDB) network broadcaster
    ///information table (NBIT).
    ///Params:
    ///    dwRecordIndex = Record containing the user-defined field, indexed from zero. Call the IISDB_NBIT::GetCountOfRecords method to
    ///                    get the number of records in the NBIT.
    ///    pbVal = Receives the user_defined field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordUserDefined(uint dwRecordIndex, ubyte* pbVal);
    ///Returns the number_of_keys field value for a section in an for an Integrated Services Digital Broadcasting (ISDB)
    ///network broadcaster information table (NBIT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_NBIT::GetCountOfRecordsmethod to get the
    ///                    number of records in the NBIT.
    ///    pbVal = Receives the number_of_keys field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordNumberOfKeys(uint dwRecordIndex, ubyte* pbVal);
    ///Gets the number_of_keys field from a record in an Integrated Services Digital Broadcasting (ISDB) network
    ///broadcaster information table (NBIT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_NBIT::GetCountOfRecords method to get the
    ///                    number of records in the NBIT.
    ///    pbKeys = Gets the number_of_keys field from the NBIT record.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordKeys(uint dwRecordIndex, ubyte** pbKeys);
    ///Returns the number of descriptors for a record in an Integrated Services Digital Broadcasting (ISDB) network
    ///broadcaster information table (NBIT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_NBIT::GetCountOfRecords method to get the
    ///                    number of records in the NBIT.
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///Retrieves a descriptor for a specified record in an Integrated Services Digital Broadcasting (ISDB) network
    ///broadcaster information table (NBIT) based on the descriptor index.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_NBIT::GetCountOfRecords method to get the
    ///                    number of records in the NBIT.
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IISDB_NBIT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    ppDescriptor = Pointer to the IGenericDescriptor interface implemented by the descriptor. The caller is responsible for
    ///                   freeing the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///Gets a descriptor from a record in an Integrated Services Digital Broadcasting (ISDB) network broadcaster
    ///information table (NBIT) by using the standard tag for the descriptor.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_NBIT::GetCountOfRecords method to get the
    ///                    number of records in the NBIT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Receives the start position in the descriptor list. This parameter is optional. If the value of
    ///                <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list. Otherwise, the
    ///                search starts from the position given in <i>pdwCookie</i>. When the method returns, the <i>pdwCookie</i>
    ///                parameter contains the position of the next matching descriptor, if any. You can use this parameter to
    ///                iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
    ///Returns a hash value for this instance of an Integrated Services Digital Broadcasting (ISDB) network broadcaster
    ///information table (NBIT). Tables that refer to the same content will return the same hash value, even though the
    ///tables have different version_number and table_id fields. You can use this hash value to identify when two tables
    ///carry the same information, even if the tables are carried on different transport streams.
    ///Params:
    ///    pdwVersionHash = Receives the hash value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVersionHash(uint* pdwVersionHash);
}

///Implements methods that get information from an Integrated Services Digital Broadcasting (ISDB) linked description
///table (LDT). An LDT contains data used to collect reference information from other tables. To obtain a pointer to
///this interface, first make sure that the media graph is in a running state and that the stream you are tuned to
///contains an LDT. Then: <ol> <li>Query the BDA MPEG-2 Transport Information Filter to obtain a pointer to the
///IPSITables interface. (You can also go through the graph and query each filter until you find one that supports
///<b>IPSITables</b>.)</li> <li>Call the IPSITables::GetTable method. The interface pointer for the desired table is
///returned in the <i>ppIUnknown</i> output parameter. </li> </ol>
@GUID("141A546B-02FF-4FB9-A3A3-2F074B74A9A9")
interface IISDB_LDT : IUnknown
{
    ///Initializes the object using captured table section data for an Integrated Services Digital Broadcasting (ISDB)
    ///linked description table (LDT).
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the <b>SectionList</b> object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///Gets the version number for an Integrated Services Digital Broadcasting (ISDB) linked description table (LDT).
    ///Params:
    ///    pbVal = Receives the version_number field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///Gets the original_service_id field from an Integrated Services Digital Broadcasting (ISDB) linked description
    ///table (LDT).
    ///Params:
    ///    pwVal = Receives the original_service_id value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOriginalServiceId(ushort* pwVal);
    ///Returns the transport stream identifier (TSID) for an Integrated Services Digital Broadcasting (ISDB) linked
    ///description table (LDT).
    ///Params:
    ///    pwVal = Receives the transport_stream_id field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTransportStreamId(ushort* pwVal);
    ///Gets an identifier that identifies the broadcaster that originated the MPEG-2 transport stream from an Integrated
    ///Services Digital Broadcasting (ISDB) linked description table (LDT).
    ///Params:
    ///    pwVal = Receives the original network ID.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOriginalNetworkId(ushort* pwVal);
    ///Gets the number of records in an Integrated Services Digital Broadcasting (ISDB) linked description table (LDT).
    ///An LDT contains data used to collect reference information from other tables.
    ///Params:
    ///    pdwVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///Gets the record description ID from an Integrated services Digital Broadcasting System (IDBS) linked description
    ///table (LDT). The description ID field identifies a collected description in the LDT.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_LDT::GetCountOfRecords method to get the
    ///                    number of records in the LDT.
    ///    pwVal = Receives the description_id field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDescriptionId(uint dwRecordIndex, ushort* pwVal);
    ///Returns the number of descriptors for a record in an Integrated Services Digital Broadcasting (ISDB) linked
    ///description table (LDT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_LDT::GetCountOfRecordsmethod to get the number
    ///                    of records in the LDT.
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///Returns a descriptor for a specified record in an Integrated Services Digital Broadcasting (ISDB) linked
    ///description table (LDT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_LDT::GetCountOfRecords method to get the
    ///                    number of records in the LDT.
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IISDB_LDT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    ppDescriptor = Pointer to the IGenericDescriptorinterface for the object that contains the LDT. Use this interface to
    ///                   retrieve the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///Searches a record in an Integrated Services Digital Broadcasting (ISDB) linked description table (LDT) for a
    ///specific descriptor tag.
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_LDT::GetCountOfRecords method to get the
    ///                    number of records in the LDT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i>parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptorinterface of the object that contains the LDT. Use this interface
    ///                   to retrieve the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
    ///Returns a hash value for this instance of an Integrated Services Digital Broadcasting (ISDB) linked description
    ///table (LDT). Tables that refer to the same content will return the same hash value, even though the tables have
    ///different version_number and table_id fields. You can use this hash value to identify when two tables carry the
    ///same information, even if the tables are carried on different transport streams.
    ///Params:
    ///    pdwVersionHash = Receives the hash value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVersionHash(uint* pdwVersionHash);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) software download trigger
///table (SDTT). An SDTT contains download information such as service ID, schedule, and receiver types for revision. To
///obtain a pointer to this interface, first make sure that the media graph is in a running state and that the stream
///you are tuned to contains an SDTT. Then: <ol> <li>Query the BDA MPEG-2 Transport Information Filter to obtain a
///pointer to the IPSITables interface. (You can also go through the graph and query each filter until you find one that
///supports <b>IPSITables</b>.)</li> <li>Call the IPSITables::GetTable method. The interface pointer for the desired
///table is returned in the <i>ppIUnknown</i> output parameter. </li> </ol>
@GUID("EE60EF2D-813A-4DC7-BF92-EA13DAC85313")
interface IISDB_SDTT : IUnknown
{
    ///Initializes the object by using captured table section data from an Integrated Services Digital Broadcasting
    ///(ISDB) software download trigger table (SDTT).
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///Gets the version number for an Integrated Services Digital Broadcasting (ISDB) software download trigger table
    ///(SDTT).
    ///Params:
    ///    pbVal = Receives the version number.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///Gets the table_id_extension field value from an Integrated Services Digital Broadcasting (ISDB) software download
    ///trigger table (SDTT). This field value identifies a specific instance of an SDTT.
    ///Params:
    ///    pwVal = Receives the table_id_extension field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTableIdExt(ushort* pwVal);
    ///Returns the transport stream identifier (TSID) for an Integrated Services Digital Broadcasting (ISDB) software
    ///download trigger table (SDTT).
    ///Params:
    ///    pwVal = Receives the transport_stream_id field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTransportStreamId(ushort* pwVal);
    ///Gets an identifier that identifies the broadcaster that originated the MPEG-2 transport stream from an Integrated
    ///Services Digital Broadcasting (ISDB) software download trigger table (SDTT).
    ///Params:
    ///    pwVal = Receives the original network ID.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOriginalNetworkId(ushort* pwVal);
    ///Receives the service_id field that uniquely identifies a service from an Integrated Services Digital Broadcasting
    ///System (ISDB) software download trigger table (SDTT).
    ///Params:
    ///    pwVal = Receives the service_id value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceId(ushort* pwVal);
    ///Gets the number of records in an Integrated Services Digital Broadcasting (ISDB) software download trigger table
    ///(SDTT).
    ///Params:
    ///    pdwVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///Receives the recording download level from a record in an Integrated services Digital Broadcasting (ISDB)
    ///software download trigger table (SDTT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_SDTT::GetCountOfRecordsmethod to get the
    ///                    number of records in the SDTT.
    ///    pbVal = Receives the recording download level.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordGroup(uint dwRecordIndex, ubyte* pbVal);
    ///Receives the target version from a record in an Integrated Services Digital Broadcasting (ISDB) Software Download
    ///Trigger Table (SDTT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_SDTT::GetCountOfRecords method to get the
    ///                    number of records in the SDTT.
    ///    pwVal = Receives the target version.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordTargetVersion(uint dwRecordIndex, ushort* pwVal);
    ///Returns a new version_number field value from a subtable within an Integrated Services Digital Broadcasting
    ///(ISDB) software download trigger table (SDTT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_SDTT::GetCountOfRecordsmethod to get the
    ///                    number of records in the SDTT.
    ///    pwVal = Receives the new version_number field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordNewVersion(uint dwRecordIndex, ushort* pwVal);
    ///Gets the download level from an Integrated Services Digital Broadcasting (ISDB) software download trigger table
    ///(SDTT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_SDTT::GetCountOfRecordsmethod to get the
    ///                    number of records in the SDTT.
    ///    pbVal = Receives the download level.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDownloadLevel(uint dwRecordIndex, ubyte* pbVal);
    ///Receives the version indicator from a record in an Integrated Services Digital Broadcasting (ISDB) software
    ///download trigger table (SDTT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_SDTT::GetCountOfRecords method to get the
    ///                    number of records in the SDTT.
    ///    pbVal = Receives the version indicator.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordVersionIndicator(uint dwRecordIndex, ubyte* pbVal);
    ///Receives event time shift information from a schedule record in an Integrated Services Digital Broadcasting
    ///(ISDB) software download trigger table (SDTT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. IISDB_SDTT::GetCountOfRecordsmethod to get the number of
    ///                    records in the SDTT.
    ///    pbVal = Receives the event time shift data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordScheduleTimeShiftInformation(uint dwRecordIndex, ubyte* pbVal);
    ///Returns the number of schedules from a record in an Information for Digital Broadcasting System (IDBS) software
    ///download trigger table (SDTT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_SDTT::GetCountOfRecords method to get the
    ///                    number of records in the SDTT.
    ///    pdwVal = Receives the number of schedules.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordCountOfSchedules(uint dwRecordIndex, uint* pdwVal);
    ///Gets an event start time from a schedule record in in an Integrated Services Digital Broadcasting (ISDB) software
    ///download trigger table (SDTT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_SDTT::GetCountOfRecordsmethod to get the
    ///                    number of records in the SDTT.
    ///    dwIndex = Index to the schedules for the selected content.
    ///    pmdtVal = Receives the event start time.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordStartTimeByIndex(uint dwRecordIndex, uint dwIndex, MPEG_DATE_AND_TIME* pmdtVal);
    ///Receives the event duration from a schedule record in an Integrated Services Digital Broadcasting (ISDB) Software
    ///Download Trigger Table (SDTT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_SDTT::GetCountOfRecordsmethod to get the
    ///                    number of records in the SDTT.
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IISDB_SDTT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    pmdVal = Receives the record duration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDurationByIndex(uint dwRecordIndex, uint dwIndex, MPEG_TIME* pmdVal);
    ///Returns the number of descriptors for a record in an Integrated Services Digital Broadcasting (ISDB) software
    ///download trigger table (SDTT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_SDTT::GetCountOfRecordsmethod to get the
    ///                    number of records in the SDTT.
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///Returns a descriptor for a specified record in an Integrated Services Digital Broadcasting (ISDB) software
    ///download trigger table (SDTT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_SDTT::GetCountOfRecords method to get the
    ///                    number of records in the SDTT.
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IISDB_SDTT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    ppDescriptor = Pointer to the IGenericDescriptor interface for the descriptor being retrieved. The caller is responsible for
    ///                   freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///Searches a record in an Integrated Services Digital Broadcasting (ISDB) software download trigger table (SDTT).
    ///Params:
    ///    dwRecordIndex = Specifies the record number, indexed from zero. Call the IISDB_SDTT::GetCountOfRecords method to get the
    ///                    number of records in the SDTT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i>parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptorinterface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
    ///Returns a hash value for this instance of an Integrated Services Digital Broadcasting (ISDB) software download
    ///trigger table (SDTT). Tables that refer to the same content will return the same hash value, even though the
    ///tables have different version_number and table_id fields. You can use this hash value to identify when two tables
    ///carry the same information, even if the tables are carried on different transport streams.
    ///Params:
    ///    pdwVersionHash = Receives the hash value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVersionHash(uint* pdwVersionHash);
}

///Implements methods that get information from an Integrated Services Digital Broadcasting (ISDB) common data table
///(CDT). A CDT contains data, such as company logos, that is needed for receivers and stored in nonvolatile memory. To
///obtain a pointer to this interface, first make sure that the media graph is in a running state and that the stream
///you are tuned to contains a CDT. Then: <ol> <li>Query the BDA MPEG-2 Transport Information Filter to obtain a pointer
///to the IPSITables interface. (You can also go through the graph and query each filter until you find one that
///supports <b>IPSITables</b>.)</li> <li>Call the IPSITables::GetTable method. The interface pointer for the desired
///table is returned in the <i>ppIUnknown</i> output parameter. </li> </ol>
@GUID("25FA92C2-8B80-4787-A841-3A0E8F17984B")
interface IISDB_CDT : IUnknown
{
    ///Initializes the object by using captured table section data from an Integrated Services Digital Broadcasting
    ///System (ISDB) common data table (CDT).
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface of the object that contains the section data.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///    bSectionNumber = Specifies a value for the section_number field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData, ubyte bSectionNumber);
    ///Gets the version number for an Integrated Services Digital Broadcasting (ISDB) common data table (CDT).
    ///Params:
    ///    pbVal = Receives the version_number field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///Receives the download_data_id field value for a logo transmission descriptor from an Integrated Services Digital
    ///Broadcasting (ISDB) common data table (CDT). The download_data_id field identifies the data to be downloaded.
    ///Params:
    ///    pwVal = Receives the download_data_id field value. This value is the same as the value of the table_id_extension
    ///            field for the CDT containing the logo data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDownloadDataId(ushort* pwVal);
    ///Gets the section_number field value from an Integrated Services Digital Broadcasting (ISDB) common data table
    ///(CDT). The section_number field identifies the position of a subtable within the CDT so that the CDT can be
    ///reassembled with its subtables in the proper order.
    ///Params:
    ///    pbVal = Receives the section_number field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSectionNumber(ubyte* pbVal);
    ///Gets an identifier that identifies the broadcaster that originated the MPEG-2 transport stream from an Integrated
    ///Services Digital Broadcasting (ISDB) common data table (CDT).
    ///Params:
    ///    pwVal = Receives the original network ID.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOriginalNetworkId(ushort* pwVal);
    ///Receives the data type value from an Integrated Services Digital Broadcasting (ISDB) common data table (CDT).
    ///Params:
    ///    pbVal = Receives the data type value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDataType(ubyte* pbVal);
    ///Returns the number of descriptors for logos in an Integrated Services Digital Broadcasting (ISDB) common data
    ///table (CDT).
    ///Params:
    ///    pdwVal = Receives the count of logo descriptors.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfTableDescriptors(uint* pdwVal);
    ///Returns a specified logo transmission descriptor from an Integrated Services Digital Broadcasting (ISDB) common
    ///data table (CDT).
    ///Params:
    ///    dwIndex = Specifies which descriptor to retrieve, indexed from zero. Call the IISDB_CDT::GetCountOfTableDescriptors
    ///              method to get the number of table descriptors.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface implemented by the descriptor. The caller must release
    ///                   the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTableDescriptorByIndex(uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///Searches a subtable in an Integrated Services Digital Broadcasting (ISDB) common data table (CDT).
    ///Params:
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of <i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in <i>pdwCookie</i>. When the method returns, the
    ///                <i>pdwCookie</i>parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Receives an IGenericDescriptorinterface pointer. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTableDescriptorByTag(ubyte bTag, uint* pdwCookie, IGenericDescriptor* ppDescriptor);
    ///Gets the size of a data module from an Integrated Services Digital Broadcasting (ISDB) common data table (CDT).
    ///Params:
    ///    pdwVal = Receives the size of the data module.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSizeOfDataModule(uint* pdwVal);
    ///Receives the data module from an Integrated Services Digital Broadcasting (ISDB) common data table (CDT).
    ///Params:
    ///    pbData = Pointer to a memory block allocated to receive the data module. The caller is responsible for freeing this
    ///             memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDataModule(ubyte** pbData);
    ///Returns a hash value for this instance of an Integrated Services Digital Broadcasting (ISDB) common data table
    ///(CDT). Tables that refer to the same content will return the same hash value, even though the tables have
    ///different version_number and table_id fields. You can use this hash value to identify when two tables carry the
    ///same information, even if the tables are carried on different transport streams.
    ///Params:
    ///    pdwVersionHash = Receives the hash value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVersionHash(uint* pdwVersionHash);
}

///Gets data from an Integrated Services Digital Broadcasting (ISDB) entitlement management message (EMM) table. An EMM
///table contains conditional access data, including contract information for subscribers, keys to decrypt common
///information, and the authorization levels or services of specific decoders. To obtain a pointer to this interface,
///first make sure that the media graph is in a running state and that the stream you are tuned to contains an EMM.
///Then: <ol> <li>Query the BDA MPEG-2 Transport Information Filter to obtain a pointer to the IPSITables interface.
///(You can also go through the graph and query each filter until you find one that supports <b>IPSITables</b>.)</li>
///<li>Call the IPSITables::GetTable method. The interface pointer for the desired table is returned in the
///<i>ppIUnknown</i> output parameter. </li> </ol>
@GUID("0EDB556D-43AD-4938-9668-321B2FFECFD3")
interface IISDB_EMM : IUnknown
{
    ///Initializes the data elements of an Integrated Services Digital Broadcasting (ISDB) entitlement management
    ///message (EMM) table by using the list of MPEG-2 EMM sections.
    ///Params:
    ///    pSectionList = Pointer to the ISectionList interface for the MPEG-2 ISDB EMM section list.
    ///    pMPEGData = Pointer to the IMpeg2Data interface of the MPEG-2 Sections and Tables filter.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(ISectionList pSectionList, IMpeg2Data pMPEGData);
    ///Gets the version number for an Integrated Services Digital Broadcasting (ISDB) entitlement management message
    ///(EMM) table.
    ///Params:
    ///    pbVal = Receives the version_number field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVersionNumber(ubyte* pbVal);
    ///Gets a table_id_extension field identifying a subtable within an Integrated Services Digital Broadcasting (ISDB)
    ///entitlement management message (EMM) table.
    ///Params:
    ///    pwVal = Receives the table_id field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTableIdExtension(ushort* pwVal);
    ///Gets the data from an Integrated Services Digital Broadcasting (ISDB) entitlement management message (EMM) table.
    ///Params:
    ///    pwBufferLength = On input, specifies the length in bytes of the buffer (specified in the <i>pbBuffer</i> parameter) that
    ///                     receives the EMM table data. On output, gets the actual length of the data returned in <i>pbBuffer</i>.
    ///    pbBuffer = Receives the data from the EMM table. The allocated size of this buffer must be greater than or equal to the
    ///               value that the <i>pwBufferLength</i> parameter points to.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDataBytes(ushort* pwBufferLength, ubyte* pbBuffer);
    ///Gets a shared message from an Integrated Services Digital Broadcasting (ISDB) entitlement management message
    ///(EMM) table.
    ///Params:
    ///    pwLength = Receives the length of the buffer required to hold the message.
    ///    ppbMessage = Pointer to a memory block allocated to receive the shared message object. The caller is responsible for
    ///                 freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSharedEmmMessage(ushort* pwLength, ubyte** ppbMessage);
    ///Gets an individual message from an Integrated Services Digital Broadcasting (ISDB) entitlement management message
    ///(EMM) table.
    ///Params:
    ///    pUnknown = Pointer to the <b>IUnknown</b> interface for the object that contains the EMM table.
    ///    pwLength = Receives the length of the buffer required to hold the message.
    ///    ppbMessage = Pointer to a memory block allocated to receive the message object. The caller is responsible for freeing this
    ///                 memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetIndividualEmmMessage(IUnknown pUnknown, ushort* pwLength, ubyte** ppbMessage);
    ///Returns a hash value for this instance of an Integrated Services Digital Broadcasting (ISDB) entitlement
    ///management message (EMM) table. Tables that refer to the same content will return the same hash value, even
    ///though the tables have different version_number and table_id fields. You can use this hash value to identify when
    ///two tables carry the same information, even if the tables are carried on different transport streams.
    ///Params:
    ///    pdwVersionHash = Receives the hash value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVersionHash(uint* pdwVersionHash);
}

@GUID("0F37BD92-D6A1-4854-B950-3A969D27F30E")
interface IDvbServiceAttributeDescriptor : IUnknown
{
    HRESULT GetTag(ubyte* pbVal);
    HRESULT GetLength(ubyte* pbVal);
    HRESULT GetCountOfRecords(ubyte* pbVal);
    HRESULT GetRecordServiceId(ubyte bRecordIndex, ushort* pwVal);
    HRESULT GetRecordNumericSelectionFlag(ubyte bRecordIndex, int* pfVal);
    HRESULT GetRecordVisibleServiceFlag(ubyte bRecordIndex, int* pfVal);
}

///Implements methods that get information from a Digital Video Broadcast (DVB) content identifier descriptor. Content
///identifier descriptors uniquely identify a unit of content in a DVB broadcast stream. Content identifier descriptors
///appear in the DVB service information as part of the event information table (EIT), which provides information about
///the events in each service.
@GUID("05E0C1EA-F661-4053-9FBF-D93B28359838")
interface IDvbContentIdentifierDescriptor : IUnknown
{
    ///Gets the tag for a Digital Video Broadcast (DVB) content identifier descriptor.
    ///Params:
    ///    pbVal = Receives the content identifier descriptor tag. For content identifier descriptors, this tag value is "0x76".
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a Digital Video Broadcast (DVB) content identifier descriptor.
    ///Params:
    ///    pbVal = Gets the descriptor body length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the number of service records in a Digital Video Broadcast (DVB) content identifier descriptor.
    ///Params:
    ///    pbVal = Receives the number of service records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets the content reference identifier (CRID) from a Digital Video Broadcast (DVB) content identifier descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the service record to return. To get the number of service records in the descriptor,
    ///                   call the IDvbContentIdentifierDescriptor::GetCountOfRecords method.
    ///    pbType = Receives the type of the CRID.
    ///    pbLocation = Gets the location of the CRID.
    ///    pbLength = Gets the number of bytes required to return the CRID.
    ///    ppbBytes = Pointer to a buffer that receives the CRID. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordCrid(ubyte bRecordIndex, ubyte* pbType, ubyte* pbLocation, ubyte* pbLength, ubyte** ppbBytes);
}

///Implements methods that get data from the default authority descriptor for a content reference identifier (CRID). The
///default authority descriptor is the first part of the CRID and identifies the body that created the CRID.
@GUID("05EC24D1-3A31-44E7-B408-67C60A352276")
interface IDvbDefaultAuthorityDescriptor : IUnknown
{
    ///Gets the tag from the default authority descriptor for a Digital Video Broadcast (DVB) content reference
    ///identifier (CRID).
    ///Params:
    ///    pbVal = Receives the content descriptor tag. For default authority descriptors, this tag value is "0x73".
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a default authority descriptor from a Digital Video Broadcast (DVB) content reference
    ///identifier (CRID).
    ///Params:
    ///    pbVal = Receives the number of bytes in the descriptor.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the string identifying the default authority from a Digital Video Broadcast (DVB) content reference
    ///identifier (CRID).
    ///Params:
    ///    pbLength = Receives the length of the default authority string in bytes.
    ///    ppbBytes = Pointer to a buffer that receives the default authority string. The caller is responsible for releasing this
    ///               memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDefaultAuthority(ubyte* pbLength, ubyte** ppbBytes);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDvbSatelliteDeliverySystemDescriptor</b> interface enables the client to get a satellite delivery system
///descriptor from a DVB stream. The satellite delivery system descriptor may be present in the network information
///table (NIT). For more information, refer to ETSI EN 300 468.
@GUID("02F2225A-805B-4EC5-A9A6-F9B5913CD470")
interface IDvbSatelliteDeliverySystemDescriptor : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTag</b> method returns the descriptor tag.
    ///Params:
    ///    pbVal = Receives the descriptor tag.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetLength</b> method returns the length of the descriptor body.
    ///Params:
    ///    pbVal = Receives the length of the descriptor body, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetFrequency</b> method returns the frequency.
    ///Params:
    ///    pdwVal = Receives the frequency field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetFrequency(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetOrbitalPosition</b> method returns the orbital position.
    ///Params:
    ///    pwVal = Receives the orbital_position field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetOrbitalPosition(ushort* pwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetWestEastFlag</b> method returns a flag that specifies whether the satellite is in the western or eastern
    ///part of the orbit.
    ///Params:
    ///    pbVal = Receives the west_east_flag field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetWestEastFlag(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetPolarization</b> method returns the polarization of the transmitted signal.
    ///Params:
    ///    pbVal = Receives the polarization field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetPolarization(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetModulation</b> method returns the modulation scheme.
    ///Params:
    ///    pbVal = Receives the modulation field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetModulation(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetSymbolRate</b> method returns the symbol rate.
    ///Params:
    ///    pdwVal = Receives the symbol_rate field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSymbolRate(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetFECInner</b> method returns the inner forward error correction (FEC) scheme.
    ///Params:
    ///    pbVal = Receives the FEC_inner field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetFECInner(ubyte* pbVal);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDvbCableDeliverySystemDescriptor</b> interface enables the client to get a cable delivery system descriptor from
///a DVB stream. The cable delivery system descriptor may be present in the network information table (NIT). For more
///information, refer to ETSI EN 300 468.
@GUID("DFB98E36-9E1A-4862-9946-993A4E59017B")
interface IDvbCableDeliverySystemDescriptor : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTag</b> method returns the descriptor tag.
    ///Params:
    ///    pbVal = Receives the descriptor tag.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetLength</b> method returns the length of the descriptor body.
    ///Params:
    ///    pbVal = Receives the length of the descriptor body, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetFrequency</b> method returns the frequency.
    ///Params:
    ///    pdwVal = Receives the frequency field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetFrequency(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetFECOuter</b> method returns the output forward error correction (FEC) scheme.
    ///Params:
    ///    pbVal = Receives the FEC_outer field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetFECOuter(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetModulation</b> method returns the modulation scheme.
    ///Params:
    ///    pbVal = Receives the modulation field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetModulation(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetSymbolRate</b> method returns the symbol rate.
    ///Params:
    ///    pdwVal = Receives the symbol_rate field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSymbolRate(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetFECInner</b> method returns the inner forward error correction (FEC) scheme.
    ///Params:
    ///    pbVal = Receives the FEC_inner field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetFECInner(ubyte* pbVal);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDvbTerrestrialDeliverySystemDescriptor</b> interface enables the client to get a terrestrial delivery system
///descriptor from a DVB stream. The terrestrial delivery system descriptor may be present in the network information
///table (NIT). For more information, refer to ETSI EN 300 468.
@GUID("ED7E1B91-D12E-420C-B41D-A49D84FE1823")
interface IDvbTerrestrialDeliverySystemDescriptor : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTag</b> method returns the descriptor tag.
    ///Params:
    ///    pbVal = Receives the descriptor tag.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetLength</b> method returns the length of the descriptor body.
    ///Params:
    ///    pbVal = Receives the length of the descriptor body, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCentreFrequency</b> method returns the center frequency.
    ///Params:
    ///    pdwVal = Receives the centre_frequency field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCentreFrequency(uint* pdwVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetBandwidth</b> method returns the bandwidth in use.
    ///Params:
    ///    pbVal = Receives the bandwidth field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetBandwidth(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetConstellation</b> method returns the constellation pattern.
    ///Params:
    ///    pbVal = Receives the constellation field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetConstellation(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetHierarchyInformation</b> method returns the hierarchy alpha information.
    ///Params:
    ///    pbVal = Receives the hierarchy_information field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetHierarchyInformation(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCodeRateHPStream</b> method returns the code rate for the high-priority (HP) stream.
    ///Params:
    ///    pbVal = Receives the code_rate-HP_stream field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCodeRateHPStream(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCodeRateLPStream</b> method returns the code rate for the low-priority (LP) stream.
    ///Params:
    ///    pbVal = Receives the code_rate-LP_stream field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCodeRateLPStream(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetGuardInterval</b> method returns the guard interval.
    ///Params:
    ///    pbVal = Receives the guard_interval field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetGuardInterval(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTransmissionMode</b> method returns the transmission mode.
    ///Params:
    ///    pbVal = Receives the transmission_mode field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTransmissionMode(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetOtherFrequencyFlag</b> method returns a flag that specifies whether other frequencies are in use.
    ///Params:
    ///    pbVal = Receives the other_frequency_flag field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetOtherFrequencyFlag(ubyte* pbVal);
}

@GUID("20EE9BE9-CD57-49AB-8F6E-1D07AEB8E482")
interface IDvbTerrestrial2DeliverySystemDescriptor : IUnknown
{
    HRESULT GetTag(ubyte* pbVal);
    HRESULT GetLength(ubyte* pbVal);
    HRESULT GetTagExtension(ubyte* pbVal);
    HRESULT GetCentreFrequency(uint* pdwVal);
    HRESULT GetPLPId(ubyte* pbVal);
    HRESULT GetT2SystemId(ushort* pwVal);
    HRESULT GetMultipleInputMode(ubyte* pbVal);
    HRESULT GetBandwidth(ubyte* pbVal);
    HRESULT GetGuardInterval(ubyte* pbVal);
    HRESULT GetTransmissionMode(ubyte* pbVal);
    HRESULT GetCellId(ushort* pwVal);
    HRESULT GetOtherFrequencyFlag(ubyte* pbVal);
    HRESULT GetTFSFlag(ubyte* pbVal);
}

///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
///<b>IDvbFrequencyListDescriptor</b> interface enables the client to get a frequency list descriptor from a DVB stream.
///The frequency list descriptor may be present in the network information table (NIT). For more information, refer to
///ETSI EN 300 468.
@GUID("1CADB613-E1DD-4512-AFA8-BB7A007EF8B1")
interface IDvbFrequencyListDescriptor : IUnknown
{
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetTag</b> method returns the descriptor tag.
    ///Params:
    ///    pbVal = Receives the descriptor tag.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetLength</b> method returns the length of the descriptor body.
    ///Params:
    ///    pbVal = Receives the length of the descriptor body, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCodingType</b> method returns a flag that specifies how the frequency is coded.
    ///Params:
    ///    pbVal = Receives the coding_type flag.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCodingType(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetCountOfRecords</b> method returns the number of records in the frequency list descriptor.
    ///Params:
    ///    pbVal = Receives the number of records.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition 2005 and later. The
    ///<b>GetRecordCentreFrequency</b> method returns the frequency at a specified index in the frequency list.
    ///Params:
    ///    bRecordIndex = Zero-based index of the frequency to return. To get the number of frequencies in the descriptor, call
    ///                   IDvbFrequencyListDescriptor::GetCountOfRecords.
    ///    pdwVal = Receives the centre_frequency field.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordCentreFrequency(ubyte bRecordIndex, uint* pdwVal);
}

///Implements methods that get data from a Digital Video Broadcast (DVB) private data descriptor. The private data
///descriptor describes broadcaster-specific data that is not part of the official MPEG-2 standard for broadcast
///streams.
@GUID("5660A019-E75A-4B82-9B4C-ED2256D165A2")
interface IDvbPrivateDataSpecifierDescriptor : IUnknown
{
    ///Gets the tag that identifies a Digital Video Broadcast (DVB) private data descriptor.
    ///Params:
    ///    pbVal = Receives the private descriptor identifier tag. For private data descriptors, this value is 0x5F.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a Digital Video Broadcast (DVB) private data descriptor.
    ///Params:
    ///    pbVal = Receives the private data descriptor length, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the data from a Digital Video Broadcast (DVB) private data descriptor.
    ///Params:
    ///    pdwVal = Receives the private descriptor specifier data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPrivateDataSpecifier(uint* pdwVal);
}

///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center Edition
///2005 and later. </div> <div> </div> The <b>IDvbLogicalChannelDescriptor</b> interface enables the client to get a
///logical channel descriptor from a DVB stream. The logical channel descriptor may be present in the network
///information table (NIT).
@GUID("CF1EDAFF-3FFD-4CF7-8201-35756ACBF85F")
interface IDvbLogicalChannelDescriptor : IUnknown
{
    ///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center
    ///Edition 2005 and later. </div> <div> </div> The <b>GetTag</b> method returns the descriptor tag.
    ///Params:
    ///    pbVal = Receives the descriptor tag.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center
    ///Edition 2005 and later.</div> <div> </div> The <b>GetLength</b> method returns the length of the descriptor body.
    ///Params:
    ///    pbVal = Receives the length of the descriptor body, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center
    ///Edition 2005 and later.</div> <div> </div> The <b>GetCountOfRecords</b> method returns the number of records in
    ///the logical channel descriptor.
    ///Params:
    ///    pbVal = Receives the number of records in the descriptor.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center
    ///Edition 2005 and later. </div> <div> </div> The <b>GetRecordServiceId</b> method returns the service identifier
    ///at a specified index in the channel list.
    ///Params:
    ///    bRecordIndex = Zero-based index of the service identifier to return. To get the number of service identifiers in the
    ///                   descriptor, call IDvbLogicalChannelDescriptor::GetCountOfRecords.
    ///    pwVal = Receives the service_id field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordServiceId(ubyte bRecordIndex, ushort* pwVal);
    ///<div class="alert"><b>Note</b> This topic applies to Update Rollup 2 for Microsoft Windows XP Media Center
    ///Edition 2005 and later.</div> <div> </div> The <b>GetRecordLogicalChannelNumber</b> method returns the logical
    ///channel number at a specified index in the channel list.
    ///Params:
    ///    bRecordIndex = Zero-based index of the logical channel number to return. To get the number of logical channel numbers in the
    ///                   descriptor, call IDvbLogicalChannelDescriptor::GetCountOfRecords.
    ///    pwVal = Receives the logical_channel_number field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordLogicalChannelNumber(ubyte bRecordIndex, ushort* pwVal);
}

///The <b>IDvbLogicalChannelDescriptor2</b> interface enables the client to get a logical channel descriptor from a DVB
///stream. The logical channel descriptor may be present in the network information table (NIT).
@GUID("43ACA974-4BE8-4B98-BC17-9EAFD788B1D7")
interface IDvbLogicalChannelDescriptor2 : IDvbLogicalChannelDescriptor
{
    HRESULT GetRecordLogicalChannelAndVisibility(ubyte bRecordIndex, ushort* pwVal);
}

///Implements methods that get data from a logical channel descriptor (LCD) in a Digital Video Broadcast (DVB) MPEG-2
///stream that uses the format defined in the Nordig specification used in Scandinavian countries. The logical channel
///descriptor may be present in the network information table (NIT). By default, all methods in the base interface
///IDvbLogicalChannelDescriptor act on the first item in a list. Once any call to a <b>IDvbLogicalChannel2Descriptor</b>
///method completes successfully, the item that the method returns remains selected so that subsequent calls to
///<b>IDvbLogicalChannelDescriptor</b> methods act on the selected item.
@GUID("F69C3747-8A30-4980-998C-01FE7F0BA35A")
interface IDvbLogicalChannel2Descriptor : IDvbLogicalChannelDescriptor2
{
    ///Gets the number of channel lists in a Digital Video Broadcast (DVB) logical channel descriptor.
    ///Params:
    ///    pbVal = Receives the number of channel lists.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfLists(ubyte* pbVal);
    ///Gets the identifier for a channel list from a Digital Video Broadcast (DVB) logical channel descriptor.
    ///Params:
    ///    bListIndex = Specifies the channel list record number, indexed from zero. Call the
    ///                 IDvbLogicalChannel2Descriptor::GetListCountOfRecordsmethod to get the number of channel list records in the
    ///                 logical channel descriptor.
    ///    pbVal = Pointer to a byte that receives the channel list identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetListId(ubyte bListIndex, ubyte* pbVal);
    ///Gets the name of a channel list from a Digital Video Broadcast (DVB) logical channel descriptor.
    ///Params:
    ///    bListIndex = Specifies the channel list record number, indexed from zero. Call the
    ///                 IDvbLogicalChannel2Descriptor::GetListCountOfRecordsmethod to get the number of channel list records in the
    ///                 logical channel descriptor.
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrName = Pointer to the memory block that receives the channel name. The caller is responsible for freeing this
    ///                memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetListNameW(ubyte bListIndex, __MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrName);
    ///Gets the three-character ISO 3166 country code for a channel list in a Digital Video Broadcast (DVB) logical
    ///channel descriptor.
    ///Params:
    ///    bListIndex = Specifies the channel list record number, indexed from zero. Call the
    ///                 IDvbLogicalChannel2Descriptor::GetListCountOfRecordsmethod to get the number of channel list records in the
    ///                 logical channel descriptor.
    ///    pszCode = Pointer to a buffer that receives the country code. This code is a 3-character, null-terminated string, so
    ///              the buffer must be at least four bytes long. The caller is responsible for releasing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetListCountryCode(ubyte bListIndex, char* pszCode);
    ///Gets an indexed count of records for a channel list in a Digital Video Broadcast (DVB) logical channel
    ///descriptor.
    ///Params:
    ///    bChannelListIndex = Specifies the channel list number, indexed from zero. Call the
    ///                        IDvbLogicalChannel2Descriptor::GetCountOfListsmethod to get the number of channel lists in the logical
    ///                        channel descriptor.
    ///    pbVal = Receives the number of channels in the list.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetListCountOfRecords(ubyte bChannelListIndex, ubyte* pbVal);
    ///Gets the service identifier from a Digital Video Broadcast (DVB) logical channel descriptor.
    ///getlistcountofrecords
    ///Params:
    ///    bListIndex = Specifies the channel list record number, indexed from zero. Call the
    ///                 IDvbLogicalChannel2Descriptor::GetCountOfListsmethod to get the number of channel list records in the logical
    ///                 channel descriptor.
    ///    bRecordIndex = Specifies the service record number, indexed from zero. Call the
    ///                   IDvbLogicalChannel2Descriptor::GetListCountOfRecordsmethod to get the number of service records in the
    ///                   logical channel descriptor.
    ///    pwVal = Receives the service identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetListRecordServiceId(ubyte bListIndex, ubyte bRecordIndex, ushort* pwVal);
    ///Gets the value of the logical_channel_number field from a Digital Video Broadcast (DVB) logical channel
    ///descriptor. The logical_channel_number field gives the ordinal position of the service record in the descriptor.
    ///Params:
    ///    bListIndex = Specifies the channel list record number, indexed from zero. Call the
    ///                 IDvbLogicalChannel2Descriptor::GetCountOfListsmethod to get the number of channel list records in the logical
    ///                 channel descriptor.
    ///    bRecordIndex = Specifies the service record number, indexed from zero. Call the
    ///                   IDvbLogicalChannel2Descriptor::GetListCountOfRecordsmethod to get the number of service records in the
    ///                   logical channel descriptor.
    ///    pwVal = Receives the logical channel number. This can be any of the following values: <table> <tr> <th>Value</th>
    ///            <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Service not
    ///            suitable for user selection </td> </tr> <tr> <td width="40%"> <dl> <dt>1 - 999</dt> </dl> </td> <td
    ///            width="60%"> Logical channel number </td> </tr> <tr> <td width="40%"> <dl> <dt>1000 - 1023</dt> </dl> </td>
    ///            <td width="60%"> Reserved for future use </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetListRecordLogicalChannelNumber(ubyte bListIndex, ubyte bRecordIndex, ushort* pwVal);
    ///Gets the visible_service_flag and logical_channel_number fields from a Digital Video Broadcast (DVB) logical
    ///channel descriptor. The visible_service_flag indicates whether a service record in the DVB logical channel
    ///descriptor is visible through the receiver service list and can be selected. The logical_channel_number field
    ///contains a broadcaster-defined channel number that is used to order services.
    ///Params:
    ///    bListIndex = Specifies the channel list record number, indexed from zero. Call the GetCountOfListsmethod to get the number
    ///                 of channel list records in the logical channel descriptor.
    ///    bRecordIndex = Specifies the service record number, indexed from zero. Call the GetListCountOfRecordsmethod to get the
    ///                   number of service records in the logical channel descriptor.
    ///    pwVal = Receives the visible_service_flag (defined by bit 15) and logical_channel_number (defined by bits 0 - 9)
    ///            field values.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetListRecordLogicalChannelAndVisibility(ubyte bListIndex, ubyte bRecordIndex, ushort* pwVal);
}

///Implements the IDvbLogicalChannelDescriptor interface for Digital Video Broadcast (DVB) streams based on Motion
///Picture Experts Group Version 4 Advanced Video Coding (MPEG-4AVC) that support high-definition (HD) simulcasting.
@GUID("1EA8B738-A307-4680-9E26-D0A908C824F4")
interface IDvbHDSimulcastLogicalChannelDescriptor : IDvbLogicalChannelDescriptor2
{
}

///Implements methods that get data from a Digital Video Broadcast (DVB) data broadcast ID descriptor. The data
///broadcast ID descriptor is a short form of the digital broadcast descriptor that can appear in a DVB program map
///table (PMT) and that describes the type of a data component.
@GUID("5F26F518-65C8-4048-91F2-9290F59F7B90")
interface IDvbDataBroadcastIDDescriptor : IUnknown
{
    ///Gets the tag that identifies a Digital Video Broadcast (DVB) data broadcast ID descriptor.
    ///Params:
    ///    pbVal = Receives the descriptor tag. For data broadcast ID descriptors, this value is 0x66.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the length (in bytes) of a Digital Video Broadcast (DVB) data broadcast ID descriptor.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the identifier that identifies the network broadcast from a Digital Video Broadcast (DVB) data broadcast
    ///descriptor.
    ///Params:
    ///    pwVal = Receives the broadcaster ID.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDataBroadcastID(ushort* pwVal);
    ///Gets the data from the selector in a Digital Video Broadcast (DVB) data broadcast ID descriptor. The selector is
    ///defined by the broadcast standard for the network.
    ///Params:
    ///    pbLen = Specifies or gets the number of selector bytes for this descriptor.
    ///    pbVal = Receives the selector bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetIDSelectorBytes(ubyte* pbLen, ubyte* pbVal);
}

///Implements methods that get data from a Digital Video Broadcast (DVB) data broadcast descriptor. The data broadcast
///descriptor appears in the DVB service information as part of the service description table (SDT) or event information
///table (EIT) and identifies the type of the data component.
@GUID("D1EBC1D6-8B60-4C20-9CAF-E59382E7C400")
interface IDvbDataBroadcastDescriptor : IUnknown
{
    ///Gets the tag that identifies a Digital Video Broadcast (DVB) data broadcast descriptor.
    ///Params:
    ///    pbVal = Receives the descriptor tag. For data broadcast descriptors, this value is 0x64.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the length of a Digital Video Broadcast (DVB) data broadcast descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the identifier that identifies the network broadcast from a Digital Video Broadcast (DVB) data broadcast
    ///descriptor.
    ///Params:
    ///    pwVal = Receives the broadcaster ID.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDataBroadcastID(ushort* pwVal);
    ///Gets the component tag from a Digital Video Broadcast (DVB) data broadcast descriptor. The component tag
    ///identifies a compoment stream within the service.
    ///Params:
    ///    pbVal = Receives the component tag.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetComponentTag(ubyte* pbVal);
    ///Gets the length of the selector in a DVB data broadcast descriptor, in bytes. The selector is defined by the data
    ///broadcast specification for the network.
    ///Params:
    ///    pbVal = Receives the selector length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSelectorLength(ubyte* pbVal);
    ///Gets the data from the selector in a Digital Video Broadcast (DVB) data broadcast descriptor. The selector is
    ///defined by the broadcast standard for the network.
    ///Params:
    ///    pbLen = On input, specifies the size of the buffer (pointed to by the <i>pbVal</i> parameter) allocated for the
    ///            selector data, in bytes. On output, gets the actual length of the selector data.
    ///    pbVal = Receives the selector bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSelectorBytes(ubyte* pbLen, ubyte* pbVal);
    ///Gets the three-character ISO 639 language code from a Digital Video Broadcast (DVB) data broadcast descriptor.
    ///This language code identifies the language used for the text description field.
    ///Params:
    ///    pulVal = Receives the language code. For a list of language codes, refer to the ISO 639 Code Tables.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLangID(uint* pulVal);
    ///Gets length of the text description, in bytes, from a Digital Video Broadcast (DVB) data broadcast descriptor.
    ///Params:
    ///    pbVal = Receives the text description length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTextLength(ubyte* pbVal);
    ///Gets the text that describes the data from a Digital Video Broadcast (DVB) data broadcast descriptor.
    ///Params:
    ///    pbLen = Specifies or receives the length of the description, in bytes.
    ///    pbVal = Receives the description text.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetText(ubyte* pbLen, ubyte* pbVal);
}

///Defines methods that get data from a Digital Video Broadcast (DVB) linkage descriptor. The linkage descriptor appears
///as part of the DVB service information in the network information table (NIT), bouquet association table (BAT),
///service description table (SDT), event information table (EIT), or service information table (SIT). The linkage
///descriptor identifies a service that can be presented if the consumer requests additional information related to a
///service. The table that contains the linkage descriptor indicates the entity for which additional information is
///available. For example, a linkage descriptor in the NIT points to a service that provides additional information on
///the network, while a linkage descriptor in the BAT links to a service that provides information about the bouquet.
@GUID("1CDF8B31-994A-46FC-ACFD-6A6BE8934DD5")
interface IDvbLinkageDescriptor : IUnknown
{
    ///Gets the tag that identifies a Digital Video Broadcast (DVB) linkage descriptor.
    ///Params:
    ///    pbVal = Receives the identifier tag. For DVB linkage descriptors, this value is "0x4A".
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a Digital Video Broadcast (DVB) linkage descriptor.
    ///Params:
    ///    pbVal = Receives the descriptor length, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the identifier of the transport stream containing the information service from a DVB linkage descriptor.
    ///Params:
    ///    pwVal = Receives the transport stream identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTSId(ushort* pwVal);
    ///Gets the network identifier of the broadcast system that originated an information service from a Digital Video
    ///Broadcast (DVB) linkage descriptor.
    ///Params:
    ///    pwVal = Receives the network identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetONId(ushort* pwVal);
    ///Gets the identifier that identifies an information service in a Digital Video Broadcast (DVB) linkage descriptor.
    ///Params:
    ///    pwVal = Receives the service identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceId(ushort* pwVal);
    ///Gets a code that uniquely identifies the linkage type from a Digital Video Broadcast (DVB) linkage descriptor.
    ///Params:
    ///    pbVal = Receives the linkage type code. For a list of linkage type codes, see Table 58 in Section 6.2.19 of the
    ///            <i>DVB Specification for Service Information (SI) in DVB systems DVB (Document A038 Rev. 4)</i>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLinkageType(ubyte* pbVal);
    ///Gets the length of the private data field from a Digital Video Broadcast (DVB) linkage descriptor.
    ///Params:
    ///    pbVal = Receives the length of the private data field, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPrivateDataLength(ubyte* pbVal);
    ///Gets the private data from a Digital Video Broadcast (DVB) linkage descriptor.
    ///Params:
    ///    pbLen = On input, specifies the size of the buffer (pointed to by the <i>pbData</i> parameter) allocated for the
    ///            private data, in bytes. On output, gets the actual length of the private data that is received.
    ///    pbData = Receives private data from the DVB linkage descriptor.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPrivateData(ubyte* pbLen, ubyte* pbData);
}

///Implements methods that get data from a Digital Video Broadcast (DVB) teletext descriptor. The teletext descriptor is
///the part of the DVB program map table (PMT) that identifies European Broadcasting Union (EBU) teletext streams.
@GUID("9CD29D47-69C6-4F92-98A9-210AF1B7303A")
interface IDvbTeletextDescriptor : IUnknown
{
    ///Gets the tag that idenfities a Digital Video Broadcast (DVB) teletext descriptor.
    ///Params:
    ///    pbVal = Gets the tag for the teletext descriptor. For teletext descriptors, this value is 0x56.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a Digital Video Broadcast (DVB) teletext descriptor.
    ///Params:
    ///    pbVal = Receives the length of the teletext descriptor, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the number of service records in a Digital Video Broadcast (DVB) teletext descriptor.
    ///Params:
    ///    pbVal = Receives the number of records in the teletext descriptor.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets the three-character ISO 639 language code from a Digital Video Broadcast (DVB) teletext descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IDvbTeletextDescriptor::GetCountOfRecords.
    ///    pulVal = Pointer to a 24-bit buffer that receives the language code. For a list of language codes, refer to this
    ///             document.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordLangId(ubyte bRecordIndex, uint* pulVal);
    ///Gets the teletext type code from from a Digital Video Broadcast (DVB) teletext descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IDvbTeletextDescriptor::GetCountOfRecords
    ///    pbVal = Receives the teletext type code. This can have any of the following values: <table> <tr> <th>Value</th>
    ///            <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x00</dt> </dl> </td> <td width="60%"> Reserved for
    ///            future use </td> </tr> <tr> <td width="40%"> <dl> <dt>0x01</dt> </dl> </td> <td width="60%"> Initial teletext
    ///            page </td> </tr> <tr> <td width="40%"> <dl> <dt>0x02</dt> </dl> </td> <td width="60%"> Teletext subtitle page
    ///            </td> </tr> <tr> <td width="40%"> <dl> <dt>0x03</dt> </dl> </td> <td width="60%"> Additional information page
    ///            </td> </tr> <tr> <td width="40%"> <dl> <dt>0x04</dt> </dl> </td> <td width="60%"> Program schedule page </td>
    ///            </tr> <tr> <td width="40%"> <dl> <dt>0x05</dt> </dl> </td> <td width="60%"> Teletext subtitle page for
    ///            hearing-impaired people </td> </tr> <tr> <td width="40%"> <dl> <dt>0x06 - 0x1F</dt> </dl> </td> <td
    ///            width="60%"> Reserved for future use </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordTeletextType(ubyte bRecordIndex, ubyte* pbVal);
    ///Gets the magazine number from a Digital Video Broadcast (DVB) teletext descriptor. A <i>magazine</i> is a
    ///sequence of one or more pages in an enhanced-teletext packet that are normally repeatedly transmitted in
    ///numerical sequence
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call <a
    ///                   href="/previous-versions/windows/desktop/api/dvbsiparser/nf-dvbsiparser-idvbteletextdescriptor-getcountofrecords">IDvbTeletextDescriptor::GetCountOfRecords
    ///                   </a>.
    ///    pbVal = Receives the magazine number.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordMagazineNumber(ubyte bRecordIndex, ubyte* pbVal);
    ///Gets the page number a Digital Video Broadcast (DVB) teletext descriptor. The page number identifies the page of
    ///teletext that is broadcast.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IDvbTeletextDescriptor::GetCountOfRecords
    ///    pbVal = Receives the page number.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordPageNumber(ubyte bRecordIndex, ubyte* pbVal);
}

///Implements methods that get data from a Digital Video Broadcast (DVB) subtitling descriptor. The subtitling
///descriptor appears in the DVB service information as part of the the program map table (PMT) and defines the
///language, text, and formatting that is used for subtitling data in a DVB broadcast.
@GUID("9B25FE1D-FA23-4E50-9784-6DF8B26F8A49")
interface IDvbSubtitlingDescriptor : IUnknown
{
    ///Gets the tag for a Digital Video Broadcast (DVB) subtitling descriptor.
    ///Params:
    ///    pbVal = Receives the subtitling descriptor tag. For subtitling descriptors, this tag value is "0x59".
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a Digital Video Broadcast (DVB) subtitling descriptor.
    ///Params:
    ///    pbVal = Receives the number of bytes in the descriptor.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the number of subtitling records in a Digital Video Broadcast (DVB) subtitling descriptor.
    ///Params:
    ///    pbVal = Returns the number of subtitling records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets the three-character ISO 639 language code from a Digital Video Broadcast (DVB) subtitling descriptor. This
    ///code identifies the language used for subtitles.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IDvbSubtitlingDescriptor::GetCountOfRecords
    ///    pulVal = Pointer to a buffer that receives the language code. For a list of language codes, refer to this document.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordLangId(ubyte bRecordIndex, uint* pulVal);
    ///Gets the subtitling component type from a DVB subtitling descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IDvbSubtitlingDescriptor::GetCountOfRecords
    ///    pbVal = Receives the subtitling component type code. This can be any of the following values: <table> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x00</dt> </dl> </td> <td width="60%">
    ///            Reserved for future use </td> </tr> <tr> <td width="40%"> <dl> <dt>0x01</dt> </dl> </td> <td width="60%">
    ///            European Broadcasting Union (EBU) teletext subtitles </td> </tr> <tr> <td width="40%"> <dl> <dt>0x02</dt>
    ///            </dl> </td> <td width="60%"> Associated EBU teletext </td> </tr> <tr> <td width="40%"> <dl> <dt>0x03</dt>
    ///            </dl> </td> <td width="60%"> Vertical blanking interval (VBI) data </td> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>0x04 - 0x0F</dt> </dl> </td> <td width="60%"> Reserved for future use </td> </tr> <tr> <td width="40%">
    ///            <dl> <dt>0x10</dt> </dl> </td> <td width="60%"> DVB subtitles (normal) with no monitor aspect ratio
    ///            criticality </td> </tr> <tr> <td width="40%"> <dl> <dt>0x11</dt> </dl> </td> <td width="60%"> DVB subtitles
    ///            (normal) for display on 4:3 aspect ratio monitor </td> </tr> <tr> <td width="40%"> <dl> <dt>0x12</dt> </dl>
    ///            </td> <td width="60%"> DVB subtitles (normal) for display on 16:9 aspect ratio monitor </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0x13</dt> </dl> </td> <td width="60%"> DVB subtitles (normal) for display on 2.21:1
    ///            aspect ratio monitor </td> </tr> <tr> <td width="40%"> <dl> <dt>0x14 - 0x1F</dt> </dl> </td> <td width="60%">
    ///            Reserved for future use </td> </tr> <tr> <td width="40%"> <dl> <dt>0x20</dt> </dl> </td> <td width="60%"> DVB
    ///            subtitles (for the hard-of-hearing) with no monitor aspect ratio criticality </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0x21</dt> </dl> </td> <td width="60%"> DVB subtitles (for the hard-of-hearing) for
    ///            display on 4:3 aspect ratio monitor </td> </tr> <tr> <td width="40%"> <dl> <dt>0x22</dt> </dl> </td> <td
    ///            width="60%"> DVB subtitles (for the hard-of-hearing) for display on 16:9 aspect ratio monitor </td> </tr>
    ///            <tr> <td width="40%"> <dl> <dt>0x23</dt> </dl> </td> <td width="60%"> DVB subtitles (for the hard-of-hearing)
    ///            for display on 2.21:1 aspect ratio monitor </td> </tr> <tr> <td width="40%"> <dl> <dt>0x24 - 0xAF</dt> </dl>
    ///            </td> <td width="60%"> Reserved for future use </td> </tr> <tr> <td width="40%"> <dl> <dt>0xB0 - 0xFE</dt>
    ///            </dl> </td> <td width="60%"> User-defined </td> </tr> <tr> <td width="40%"> <dl> <dt>0xFF</dt> </dl> </td>
    ///            <td width="60%"> Reserved for future use </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordSubtitlingType(ubyte bRecordIndex, ubyte* pbVal);
    ///Gets the composition page identifier for a Digital Video Broadcast (DVB) subtitling descriptor. DVB subtitling
    ///segments that signal a composition page identifier are decoded if the previous data in the subtitling descriptor
    ///matches the user's selection criteria.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IDvbSubtitlingDescriptor::GetCountOfRecords
    ///    pwVal = Receives the composition page identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordCompositionPageID(ubyte bRecordIndex, ushort* pwVal);
    ///Gets the ancillary page identifier for a Digital Video Broadcast (DVB) subtitling descriptor. The DVB subtitling
    ///segments signalling the ancillary page identifier are decoded if the previous data in the subtitling descriptor
    ///matches the user's selection criteria.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IDvbSubtitlingDescriptor::GetCountOfRecords
    ///    pwVal = Receives the ancillary page identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordAncillaryPageID(ubyte bRecordIndex, ushort* pwVal);
}

///Implements methods that get data from a Digital Video Broadcast (DVB) service descriptor. The service descriptor
///appears in the DVB service information as part of the service description table (SDT) or selection information table
///(SIT). It describes the service type and provides the names of the service provider and the service in text form.
@GUID("F9C7FBCF-E2D6-464D-B32D-2EF526E49290")
interface IDvbServiceDescriptor : IUnknown
{
    ///Gets the tag identifying a Digital Video Broadcast (DVB) service descriptor.
    ///Params:
    ///    pbVal = Receives the service descriptor tag. This value is 0x48 for service descriptors.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the length of a Digital Video Broadcast (DVB) service descriptor.
    ///Params:
    ///    pbVal = Receives the descriptor length, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the service_type field value from a Digital Video Broadcast (DVB) service descriptor.
    ///Params:
    ///    pbVal = Receives the service type. This can be any of the following values. <table> <tr> <th>Value</th>
    ///            <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x00</dt> </dl> </td> <td width="60%"> Reserved for
    ///            future use. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x01</dt> </dl> </td> <td width="60%"> Digital
    ///            television service. (MPEG-2 standard-definition [SD] material should use this type.) </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0x02</dt> </dl> </td> <td width="60%"> Digital radio sound service. (MPEG-1 Layer 2
    ///            audio material should use this type.) </td> </tr> <tr> <td width="40%"> <dl> <dt>0x03</dt> </dl> </td> <td
    ///            width="60%"> Teletext service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x04</dt> </dl> </td> <td
    ///            width="60%"> Near-video-on-demand (NVOD) reference service. (MPEG-2 SD material should use this type.) </td>
    ///            </tr> <tr> <td width="40%"> <dl> <dt>0x05</dt> </dl> </td> <td width="60%"> NVOD time-shifted service.
    ///            (MPEG-2 SD material should use this type.) </td> </tr> <tr> <td width="40%"> <dl> <dt>0x06</dt> </dl> </td>
    ///            <td width="60%"> Mosaic service </td> </tr> <tr> <td width="40%"> <dl> <dt>0x07-0x09</dt> </dl> </td> <td
    ///            width="60%"> Reserved for future use. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x0A</dt> </dl> </td> <td
    ///            width="60%"> Advanced codec digital radio sound service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x0B</dt>
    ///            </dl> </td> <td width="60%"> Advanced codec mosaic service. </td> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>0x0C</dt> </dl> </td> <td width="60%"> Data broadcast service. </td> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>0x0D</dt> </dl> </td> <td width="60%"> Reserved for Common Interface Usage (see <a
    ///            href="http://broadcasting.ru/pdf-standard-specifications/interfacing/dvb-ci/en50221.pdf">CENELEC EN 50221:
    ///            "Common interface specification for conditional access and other digital video broadcasting decoder
    ///            applications"</a> ) </td> </tr> <tr> <td width="40%"> <dl> <dt>0x0E</dt> </dl> </td> <td width="60%"> Return
    ///            Channel Satellite (RCS) Map (see <a
    ///            href="http://www.dvb.org/technology/standards/a054r4.1.dEn301790.V1.5.1.pdf">Digital Video Broadcasting
    ///            (DVB); Interaction channel for satellite distribution systems, ETSI EN 301 790</a> ). </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0x0F</dt> </dl> </td> <td width="60%"> RCS Forward Link Signalling (FLS) (see EN 301
    ///            790). </td> </tr> <tr> <td width="40%"> <dl> <dt>0x10</dt> </dl> </td> <td width="60%"> DVB Multimedia Home
    ///            Platform (MHP) service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x11</dt> </dl> </td> <td width="60%">
    ///            MPEG-2 high-definition (HD) digital television service </td> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>0x12-0x15</dt> </dl> </td> <td width="60%"> Reserved for future use. </td> </tr> <tr> <td width="40%">
    ///            <dl> <dt>0x16</dt> </dl> </td> <td width="60%"> Advanced codec SD digital television service. </td> </tr>
    ///            <tr> <td width="40%"> <dl> <dt>0x17</dt> </dl> </td> <td width="60%"> Advanced codec SD NVOD time-shifted
    ///            service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x18</dt> </dl> </td> <td width="60%"> Advanced codec SD
    ///            NVOD reference service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x19</dt> </dl> </td> <td width="60%">
    ///            Advanced codec HD digital television service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x1A</dt> </dl>
    ///            </td> <td width="60%"> Advanced codec HD NVOD time-shifted service. </td> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>0x1B</dt> </dl> </td> <td width="60%"> Advanced codec HD NVOD time-shifted service. </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0x1C - 0x7F</dt> </dl> </td> <td width="60%"> Reserved for future use </td> </tr> <tr>
    ///            <td width="40%"> <dl> <dt>0x80 - 0xFE</dt> </dl> </td> <td width="60%"> User-defined </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0xFF</dt> </dl> </td> <td width="60%"> Reserved for future use </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceType(ubyte* pbVal);
    ///Gets the service provider name from a Digital Video Broadcast (DVB) service descriptor.
    ///Params:
    ///    pszName = Pointer to a buffer that receives the service provider name. The caller is responsible for freeing this
    ///              memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceProviderName(byte** pszName);
    ///Gets the service provider name string from a Digital Video Broadcast (DVB) service descriptor.
    ///Params:
    ///    pbstrName = Pointer to a buffer that receives the service provider name string. The caller is responsible for freeing
    ///                this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceProviderNameW(BSTR* pbstrName);
    ///Gets the service_name field from a Digital Video Broadcast (DVB) service descriptor.
    ///Params:
    ///    pszName = Pointer to a memory block that receives the service name. The caller is responsible for releasing this
    ///              memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceName(byte** pszName);
    ///Gets the processed service name from a Digital Video Broadcast (DVB) service descriptor.
    ///Params:
    ///    pbstrName = Pointer to a buffer that receives the service name. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetProcessedServiceName(BSTR* pbstrName);
    ///Gets the emphasized service name from a Digital Video Broadcast (DVB) service descriptor.
    ///Params:
    ///    pbstrName = Pointer to a buffer that receives the service name. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceNameEmphasized(BSTR* pbstrName);
}

///Implements methods that get the string values from fields in a Digital Video Broadcast (DVB) service descriptor. The
///service descriptor describes the service type, and provides the names of the service provider and the service in text
///form.
@GUID("D6C76506-85AB-487C-9B2B-36416511E4A2")
interface IDvbServiceDescriptor2 : IDvbServiceDescriptor
{
    ///Gets a string containing the service provider name from a Digital Video Broadcast (DVB) service descriptor.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrName = Receives the service provider name string as a <b>BSTR</b>. The caller must free the string by calling
    ///                <b>SysFreeString</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceProviderNameW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrName);
    ///Gets a string containing the service name from a Digital Video Broadcast (DVB) service descriptor.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrName = Receives the service name string as a <b>BSTR</b>. The caller must free the string by calling
    ///                <b>SysFreeString</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceNameW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrName);
}

///Implements methods that get data from a Digital Video Broadcast (DVB) service list descriptor. A service list
///descriptor is part of the DVB network information table (NIT) or bouquet association table (BAT) that lists services
///by service ID and type.
@GUID("05DB0D8F-6008-491A-ACD3-7090952707D0")
interface IDvbServiceListDescriptor : IUnknown
{
    ///Gets the tag identifying a Digital Video Broadcast (DVB) service list descriptor.
    ///Params:
    ///    pbVal = Receives the service list descriptor tag. Typically, this value is 0x41 for service list descriptors.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the descriptor_length field value from a Digital Video Broadcast (DVB) service descriptor.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets an indexed count of service records for a Digital Video Broadcast (DVB) service list descriptor.
    ///Params:
    ///    pbVal = Receives the number of service records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets the value of the service_id field from a Digital Video Broadcast (DVB) service list descriptor.The
    ///service_id field value uniquely identifies the service within the MPEG-2 transport stream.
    ///Params:
    ///    bRecordIndex = Specifies the service record number, indexed from zero. Call the
    ///                   IDvbServiceListDescriptor::GetCountOfRecordsmethod to get the number of records in the logical channel
    ///                   descriptor.
    ///    pwVal = Receives the service_id field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordServiceId(ubyte bRecordIndex, ushort* pwVal);
    ///Gets the service_type field value from a Digital Video Broadcast (DVB) service descriptor.
    ///Params:
    ///    bRecordIndex = Specifies the service record number, indexed from zero. Call the
    ///                   IDvbServiceListDescriptor::GetCountOfRecordsmethod to get the number of records in the logical channel
    ///                   descriptor.
    ///    pbVal = Receives the service type. This can be any of the following values. <table> <tr> <th>Value</th>
    ///            <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x00</dt> </dl> </td> <td width="60%"> Reserved for
    ///            future use. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x01</dt> </dl> </td> <td width="60%"> Digital
    ///            television service. (MPEG-2 SD material should use this type.) </td> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>0x02</dt> </dl> </td> <td width="60%"> Digital radio sound service. (MPEG-1 Layer 2 audio material should
    ///            use this type.) </td> </tr> <tr> <td width="40%"> <dl> <dt>0x03</dt> </dl> </td> <td width="60%"> Teletext
    ///            service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x04</dt> </dl> </td> <td width="60%"> NVOD reference
    ///            service. (MPEG-2 SD material should use this type.) </td> </tr> <tr> <td width="40%"> <dl> <dt>0x05</dt>
    ///            </dl> </td> <td width="60%"> NVOD time-shifted service. (MPEG-2 SD material should use this type.) </td>
    ///            </tr> <tr> <td width="40%"> <dl> <dt>0x06</dt> </dl> </td> <td width="60%"> Mosaic service. </td> </tr> <tr>
    ///            <td width="40%"> <dl> <dt>0x07 - 0x09</dt> </dl> </td> <td width="60%"> Reserved for future use. </td> </tr>
    ///            <tr> <td width="40%"> <dl> <dt>0x0A</dt> </dl> </td> <td width="60%"> Advanced codec digital radio sound
    ///            service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x0B</dt> </dl> </td> <td width="60%"> Advanced codec
    ///            mosaic service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x0C</dt> </dl> </td> <td width="60%"> Data
    ///            broadcast service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x0D</dt> </dl> </td> <td width="60%"> Reserved
    ///            for Common Interface Usage (EN 5022). </td> </tr> <tr> <td width="40%"> <dl> <dt>0x0E</dt> </dl> </td> <td
    ///            width="60%"> RCS Map (see EN 301 790 [7]). </td> </tr> <tr> <td width="40%"> <dl> <dt>0x0F</dt> </dl> </td>
    ///            <td width="60%"> RCS FLS (see EN 301 790 [7]). </td> </tr> <tr> <td width="40%"> <dl> <dt>0x10</dt> </dl>
    ///            </td> <td width="60%"> DVB MHP service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x11</dt> </dl> </td> <td
    ///            width="60%"> MPEG-2 HD digital television service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x12 -
    ///            0x15</dt> </dl> </td> <td width="60%"> Reserved for future use. </td> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>0x16</dt> </dl> </td> <td width="60%"> Advanced codec SD digital television service. </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0x17</dt> </dl> </td> <td width="60%"> Advanced codec SD NVOD time-shifted service.
    ///            </td> </tr> <tr> <td width="40%"> <dl> <dt>0x18</dt> </dl> </td> <td width="60%"> Advanced codec SD NVOD
    ///            reference service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x19</dt> </dl> </td> <td width="60%"> Advanced
    ///            codec HD digital television service. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x1A</dt> </dl> </td> <td
    ///            width="60%"> Advanced codec HD NVOD time-shifted service. </td> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>0x1B</dt> </dl> </td> <td width="60%"> Advanced codec HD NVOD reference service. </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0x1C - 0x7F</dt> </dl> </td> <td width="60%"> Reserved for future use. </td> </tr> <tr>
    ///            <td width="40%"> <dl> <dt>0x80 - 0xFE</dt> </dl> </td> <td width="60%"> User-defined. </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0xFF</dt> </dl> </td> <td width="60%"> Reserved for future use. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordServiceType(ubyte bRecordIndex, ubyte* pbVal);
}

///Implements methods that get data from a Digital Video Broadcast (DVB) multilingual service name descriptor. A
///multilingual service name descriptor provides the names of the service provider and service in text form in one or
///more languages.
@GUID("2D80433B-B32C-47EF-987F-E78EBB773E34")
interface IDvbMultilingualServiceNameDescriptor : IUnknown
{
    ///Gets the tag identifying a Digital Video Broadcast (DVB) multilingual service name descriptor.
    ///Params:
    ///    pbVal = Receives the service list descriptor tag. Typically, this value is 0x5D for multilingual service name
    ///            descriptors.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the descriptor_length field value from a from a Digital Video Broadcast (DVB) multilingual service name
    ///descriptor.
    ///Params:
    ///    pbVal = Receives the descriptor_length field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the number of service records in a Digital Video Broadcast (DVB) multilingual service name descriptor.
    ///Params:
    ///    pbVal = Receives the number of service records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets the three-character ISO 639 language code from a Digital Video Broadcast (DVB) multilingual service name
    ///descriptor. The language code identifies the language used for text in the descriptor.
    ///Params:
    ///    bRecordIndex = Specifies the service record number, indexed from zero. Call the
    ///                   IDvbMultilingualServiceNameDescriptor::GetCountOfRecordsmethod to get the number of records in the
    ///                   multilingual service name descriptor.
    ///    ulVal = Pointer to a buffer that receives the language code. For a list of language codes, refer to this document.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordLangId(ubyte bRecordIndex, uint* ulVal);
    ///Gets the service provider name in string format from a Digital Video Broadcast (DVB) multilingual service name
    ///descriptor.
    ///Params:
    ///    bRecordIndex = Specifies the service record number, indexed from zero. Call the
    ///                   IDvbMultilingualServiceNameDescriptor::GetCountOfRecordsmethod to get the number of records in the logical
    ///                   channel descriptor.
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrName = Pointer to a memory block that receives the service provider name string. The caller is responsible for
    ///                freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordServiceProviderNameW(ubyte bRecordIndex, 
                                          __MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrName);
    ///Gets the service name in string format from a Digital Video Broadcast (DVB) multilingual service name descriptor.
    ///Params:
    ///    bRecordIndex = Specifies the service record number, indexed from zero. Call the
    ///                   IDvbMultilingualServiceNameDescriptor::GetCountOfRecordsmethod to get the number of records in the logical
    ///                   channel descriptor.
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrName = Pointer to a buffer that receives the service name string. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordServiceNameW(ubyte bRecordIndex, __MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, 
                                  BSTR* pbstrName);
}

///Implements methods that get data from a Digital Video Broadcast (DVB) network name descriptor. The network name
///descriptor gets text format information about the network that originated the broadcast.
@GUID("5B2A80CF-35B9-446C-B3E4-048B761DBC51")
interface IDvbNetworkNameDescriptor : IUnknown
{
    ///Gets the tag that identifies a Digital Video Broadcast (DVB) network name descriptor.
    ///Params:
    ///    pbVal = Receives the identifier tag. For DVB network name descriptors, this value is "0x40".
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a Digital Video Broadcast (DVB) network name descriptor.
    ///Params:
    ///    pbVal = Receives the descriptor length, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the network name, in ASCII string format, from a Digital Video Broadcast (DVB) network name descriptor.
    ///Params:
    ///    pszName = Pointer to a buffer that receives the network name. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetNetworkName(byte** pszName);
    ///Gets the network name, in Unicode string format, from a Digital Video Broadcast (DVB) network name descriptor.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrName = Pointer to a string buffer that receives the network name. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetNetworkNameW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrName);
}

///Implements methods that get data from a Digital Video Broadcast (DVB) short event descriptor. A short event
///descriptor appears as part of the DVB service information in the event information table (EIT) and service
///information table (SIT) and provides the name and a description of the event in text format.
@GUID("B170BE92-5B75-458E-9C6E-B0008231491A")
interface IDvbShortEventDescriptor : IUnknown
{
    ///Gets the tag that identifies a Digital Video Broadcast (DVB) short event descriptor.
    ///Params:
    ///    pbVal = Receives the identifier tag. For DVB short event descriptors, this value is "0x4D".
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a Digital Video Broadcast (DVB) short event descriptor.
    ///Params:
    ///    pbVal = Receives the descriptor length, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the three-character ISO 639 language code from a Digital Video Broadcast (DVB) short event descriptor.
    ///Params:
    ///    pszCode = Receives the language code. For a list of language codes, refer to this document. The caller is responsible
    ///              for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLanguageCode(char* pszCode);
    ///Gets the event name in Unicode string format from a Digital Video Broadcast (DVB) short event descriptor.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrName = Pointer to a buffer that receives the event name. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEventNameW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrName);
    ///Gets the text that describes the event in Unicode string format from a Digital Video Broadcast (DVB) short event
    ///descriptor.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrText = Pointer to a buffer that receives the event description text. The caller is responsible for freeing this
    ///                memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTextW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrText);
}

///Implements methods that get data from a Digital Video Broadcast (DVB) extended event descriptor. An extended event
///descriptor appears as part of the DVB service information in the event information table (EIT) and service
///information table (SIT). The descriptor provides a detailed text description of an event that may be used in addition
///to the short event descriptor. More than one extended event descriptor can be associated to allow more than 256 bytes
///of information about one event to be conveyed. Text information can be structured into two columns, one that provides
///an item description field, and one that provides the item text, for example, to include a cast list in a movie or
///show description.
@GUID("C9B22ECA-85F4-499F-B1DB-EFA93A91EE57")
interface IDvbExtendedEventDescriptor : IUnknown
{
    ///Gets the tag that identifies a Digital Video Broadcast (DVB) extended event descriptor.
    ///Params:
    ///    pbVal = Receives the identifier tag. For DVB extended event descriptors, this value is "0x4E".
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a Digital Video Broadcast (DVB) extended event descriptor.
    ///Params:
    ///    pbVal = Receives the event descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the descriptor number from a Digital Video Broadcast (DVB) extended event descriptor.
    ///Params:
    ///    pbVal = Receives the descriptor number.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDescriptorNumber(ubyte* pbVal);
    ///Gets the number of the last descriptor associated with this descriptor from a Digital Video Broadcast (DVB)
    ///extended event descriptor.
    ///Params:
    ///    pbVal = Receives the last descriptor number.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLastDescriptorNumber(ubyte* pbVal);
    ///Gets the three-character ISO 639 language code from a Digital Video Broadcast (DVB) extended event descriptor.
    ///Params:
    ///    pszCode = Pointer to the buffer that receives the language code. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLanguageCode(char* pszCode);
    ///Gets the number of item records in a Digital Video Broadcast (DVB) extended event descriptor.
    ///Params:
    ///    pbVal = Receives the number of item records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets the item and descriptor from a Digital Videl Broadcast (DVB) extended event descriptor, in Unicode string
    ///format.
    ///Params:
    ///    bRecordIndex = Specifies the item record number, indexed from zero. Call the
    ///                   IDvbExtendedEventDescriptor::GetCountOfRecordsmethod to get the number of records in the extended event
    ///                   descriptor.
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrDesc = Pointer to a buffer that receives the item description. The caller is responsible for freeing this memory.
    ///    pbstrItem = Pointer to a buffer that receives the item text. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordItemW(ubyte bRecordIndex, __MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, 
                           BSTR* pbstrDesc, BSTR* pbstrItem);
    ///Concatenates the bytes from the item in the current Digital Video Broadcast (DVB) extended event descriptor with
    ///the bytes from the item in the next DVB extended event descriptor and returns the concatenated data as a Unicode
    ///string.
    ///Params:
    ///    pFollowingDescriptor = Pointer to the IDvbExtendedEventDescriptor interface for the next DVB extended event descriptor associated
    ///                           with the current one.
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrDesc = Pointer to a buffer that receives the concatenated item descriptor. The caller is responsible for freeing
    ///                this memory.
    ///    pbstrItem = Pointer to a buffer that receives the concatenated item string. The caller is responsible for freeing this
    ///                memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetConcatenatedItemW(IDvbExtendedEventDescriptor pFollowingDescriptor, 
                                 __MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrDesc, 
                                 BSTR* pbstrItem);
    ///Gets the text describing an itemfrom a Digital Video Broadcast (DVB) extended event descriptor, in string format.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrText = Pointer to a buffer that receives the event description. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTextW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrText);
    ///Gets the concatenation of the text description in the current item with the text description in the next item
    ///(both in Unicode format) of a Digital Video Broadcast (DVB) extended event descriptor.
    ///Params:
    ///    FollowingDescriptor = Pointer to the IDvbExtendedEventDescriptor interface for the next extended event descriptor that is
    ///                          associated with the current event descriptor.
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrText = Pointer to the buffer that receives the concatenated item text. The caller is responsible for freeing this
    ///                memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetConcatenatedTextW(IDvbExtendedEventDescriptor FollowingDescriptor, 
                                 __MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrText);
    ///Gets the raw data from the current item in a Digital Video Broadcast (DVB) extended event descriptor.
    ///Params:
    ///    bRecordIndex = Specifies the item record number, indexed from zero. Call the
    ///                   IDvbExtendedEventDescriptor::GetCountOfRecordsmethod to get the number of records in the extended event
    ///                   descriptor.
    ///    ppbRawItem = Pointer to a buffer that gets the item data. The caller is responsible for freeing this memory.
    ///    pbItemLength = Receives the number of bytes in the item description.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordItemRawBytes(ubyte bRecordIndex, ubyte** ppbRawItem, ubyte* pbItemLength);
}

///Identifies the type of a Digital Video Broadcast (DVB) component stream and provides a text description of the
///component stream.
@GUID("91E405CF-80E7-457F-9096-1B9D1CE32141")
interface IDvbComponentDescriptor : IUnknown
{
    ///Gets the tag that identifies a Digital Video Broadcast (DVB) component descriptor.
    ///Params:
    ///    pbVal = Receives the identifier tag. For DVB component descriptors, this value is "0x50".
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a Digital Video Broadcast (DVB) component descriptor
    ///Params:
    ///    pbVal = Receives the descriptor length, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the stream content code for a Digital Video Broadcast (DVB) component descriptor.
    ///Params:
    ///    pbVal = Receives the stream content code.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamContent(ubyte* pbVal);
    ///Gets the component type code for a Digital Video Broadcast (DVB) component descriptor.
    ///Params:
    ///    pbVal = Receives the component type code.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetComponentType(ubyte* pbVal);
    ///Gets the component tag from a DVB component descriptor. The component tag has the same value as the component_tag
    ///field in the stream identifier descriptor in the Program Specific Information (PSI) program map section for the
    ///component stream.
    ///Params:
    ///    pbVal = Receives the component tag.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetComponentTag(ubyte* pbVal);
    ///Gets the three-character ISO 639 language code from a Digital Video Broadcast (DVB) component descriptor.
    ///Params:
    ///    pszCode = Pointer to the buffer that receives the language code. For a list of language codes, refer to the ISO 639
    ///              Code Tables. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLanguageCode(char* pszCode);
    ///Gets the text describing the elementary stream, in Unicode string format, from a Digital Video Broadcast (DVB)
    ///component descriptor.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrText = Receives the event description text. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTextW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrText);
}

///Implements methods that get information from a Digital Video Broadcast (DVB) content descriptor. Content descriptors
///appear in the DVB Service Information as part of the Event Information Table (EIT), which provides information about
///the events in each service.
@GUID("2E883881-A467-412A-9D63-6F2B6DA05BF0")
interface IDvbContentDescriptor : IUnknown
{
    ///Gets the tag for a Digital Video Broadcast (DVB) content descriptor.
    ///Params:
    ///    pbVal = Receives the content descriptor tag. For content descriptors, this tag value is "0x54".
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a Digital Video Broadcast (DVB) content descriptor.
    ///Params:
    ///    pbVal = Receives the content descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the number of content elements within a Digital Video Broadcast (DVB) content descriptor.
    ///Params:
    ///    pbVal = Receives the number of content elements.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets the two 4-bit fields that make up a DVB-defined identifier for a content descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IDvbContentDescriptor::GetCountOfRecords
    ///    pbValLevel1 = Gets the most-significant four bits of the content identifier.
    ///    pbValLevel2 = Gets the least-significant four bits of the content identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordContentNibbles(ubyte bRecordIndex, ubyte* pbValLevel1, ubyte* pbValLevel2);
    ///Gets the two 4-bit fields that make up a broadcaster-defined identifier for a content descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IDvbContentDescriptor::GetCountOfRecords
    ///    pbVal1 = Gets the most-significant four bits of the broadcaster-defined content identifier. These bits are returned in
    ///             the right-most four bits of the byte.
    ///    pbVal2 = Gets the least-significant four bits of the broadcaster-defined content identifier. These bits are returned
    ///             in the left-most four bits of the byte.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordUserNibbles(ubyte bRecordIndex, ubyte* pbVal1, ubyte* pbVal2);
}

///Implements methods that get data from a Digital Video Broadcast (DVB) parental rating descriptor. The parental rating
///descriptor appears in the DVB service information as part of the event information table (EIT) or selection
///information table (SIT) and includes a rating based on age. The descriptor may include extensions based on other
///rating criteria.
@GUID("3AD9DDE1-FB1B-4186-937F-22E6B5A72A10")
interface IDvbParentalRatingDescriptor : IUnknown
{
    ///Gets the tag that describes a Digital Video Broadcast (DVB) parental rating descriptor.
    ///Params:
    ///    pbVal = Receives the parental rating descriptor tag. This value is "0x55" for parental rating descriptors.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a Digital Video Broadcast (DVB) parental rating descriptor, in bytes,.
    ///Params:
    ///    pbVal = Receives the descriptor length, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the number of records in a Digital Video Broadcast (DVB) parental rating descriptor.
    ///Params:
    ///    pbVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets a code that indicates the age-based rating for a Digital Video Broadcast (DVB) broadcast from a DVB parental
    ///rating descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IDvbParentalRatingDescriptor::GetCountOfRecords.
    ///    pszCountryCode = Receives the ISO 3166 country code from the parental rating descriptor.
    ///    pbVal = Gets the rating code. This can be any of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///            </tr> <tr> <td width="40%"> <dl> <dt>0x00</dt> </dl> </td> <td width="60%"> Undefined. </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0x01-0x0F</dt> </dl> </td> <td width="60%"> Minimum age is 3 years. For example, 0x0A
    ///            implies that end users should be at least 13 years old. </td> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>0x10-0xFF</dt> </dl> </td> <td width="60%"> Broadcaster defined. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordRating(ubyte bRecordIndex, char* pszCountryCode, ubyte* pbVal);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) terrestrial delivery system
///descriptor. The terrestrial delivery system descriptor appears in the network information table (NIT) as part of the
///ISDB service information and indicates the physical characteristics of the terrestrial transmission path. This
///descriptor is required for all ISDB terrestrial broadcasting.
@GUID("39FAE0A6-D151-44DD-A28A-765DE5991670")
interface IIsdbTerrestrialDeliverySystemDescriptor : IUnknown
{
    ///Gets the tag that identifies an Integrated Digital Services Broadcasting (ISDB) terrestrial delivery system
    ///descriptor.
    ///Params:
    ///    pbVal = Receives the terrestrial delivery system descriptor tag. For terrestrial delivery system descriptors, this
    ///            value is 0xFA.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of an Integrated Services Digital Broadcasting (ISDB) terrestrial delivery system
    ///descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the service area code from an Integrated Services Digital Broadcasting (ISDB) terrestrial delivery system
    ///descriptor.
    ///Params:
    ///    pwVal = Receives the area code.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAreaCode(ushort* pwVal);
    ///Gets the guard interval from an Integrated Services Digital Broadcasting (ISDB) terrestrial delivery system
    ///descriptor. The guard interval specifies the fraction of an orthogonal frequency division multiplexing (OFDM)
    ///symbol period that separates each pair of OFDM symbols.
    ///Params:
    ///    pbVal = Receives the code indicating the guard value. This code can be any of the following values. <table> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>00</dt> </dl> </td> <td width="60%">
    ///            1/32 </td> </tr> </table> <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>01</dt> </dl> </td> <td width="60%"> 1/16 </td> </tr> </table> <table> <tr> <th>Value</th>
    ///            <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>10</dt> </dl> </td> <td width="60%"> 1/8 </td> </tr>
    ///            </table> <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>11</dt> </dl>
    ///            </td> <td width="60%"> 1/4 </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetGuardInterval(ubyte* pbVal);
    ///Gets the transmission mode from an Integrated Services Digital Broadcasting (ISDB) terrestrial delivery system
    ///descriptor.
    ///Params:
    ///    pbVal = Receives a code indicating the transmission mode. This code can be any of the following values. <table> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>00</dt> </dl> </td> <td width="60%">
    ///            Mode 1. </td> </tr> <tr> <td width="40%"> <dl> <dt>01</dt> </dl> </td> <td width="60%"> Mode 2. </td> </tr>
    ///            <tr> <td width="40%"> <dl> <dt>10</dt> </dl> </td> <td width="60%"> Mode 3. </td> </tr> <tr> <td width="40%">
    ///            <dl> <dt>11</dt> </dl> </td> <td width="60%"> Undefined. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTransmissionMode(ubyte* pbVal);
    ///Gets the number of records in an Integrated Services Digital Broadcasting (ISDB) terrestrial delivery system
    ///descriptor.
    ///Params:
    ///    pbVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets the center frequency from an Integrated Services Digital Broadcasting (ISDB) terrestrial delivery system
    ///descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IIsdbTerrestrialDeliverySystemDescriptor::GetCountOfRecords
    ///    pdwVal = Receives the center frequency, in units of 1/7 MHz.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordFrequency(ubyte bRecordIndex, uint* pdwVal);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) transport stream (TS)
///information descriptor. The TS information descriptor appears in the ISDB Service Information as part of the event
///information table (EIT). This descriptor specifies the remote control key identifier assigned to the applicable
///transport stream. It indicates the relationship between the service identifier and the transmission layer during
///hierarchical transmission.
@GUID("D7AD183E-38F5-4210-B55F-EC8D601BBD47")
interface IIsdbTSInformationDescriptor : IUnknown
{
    ///Receives the tag that identifies an Integrated Services Digital Broadcasting (ISDB) transport stream (TS)
    ///information descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For ISDB TS information descriptors, this value is 0xCD.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of an Integrated Services Digital Broadcasting (ISDB) transport stream (TS) information
    ///descriptor.
    ///Params:
    ///    pbVal = Receives the body length of the descriptor, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the remote_control_key_id field value from an Integrated Services Digital Broadcasting (ISDB) transport
    ///stream (TS) information descriptor. This field indicates the recommended remote control key number to which the
    ///applicable transport stream is assigned.
    ///Params:
    ///    pbVal = Receives the remote_control_key_id field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRemoteControlKeyId(ubyte* pbVal);
    ///Gets the transport stream name from an Integrated Services Digital Broadcasting (ISDB) transport stream (TS)
    ///information descriptor, in Unicode string format.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrName = Pointer to a buffer that receives the transport stream name. The caller is responsible for freeing this
    ///                memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTSNameW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrName);
    ///Gets the number of records in an Integrated Services Digital Broadcasting (ISDB) transport stream (TS)
    ///information descriptor.
    ///Params:
    ///    pbVal = Receives the number of descriptor records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets the transmission_type_info field from an Integrated Services Digital Broadcasting (ISDB) transport stream
    ///(TS) information descriptor. This field is used to select hierarchical layers within the service information and
    ///is defined by each service provider.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IIsdbTSInformationDescriptor::GetCountOfRecords
    ///    pbVal = Receives the transmission_type_info field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordTransmissionTypeInfo(ubyte bRecordIndex, ubyte* pbVal);
    ///Gets the number of service records from an Integrated Services Digital Broadcasting (ISDB) transport stream (TS)
    ///information descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IIsdbTSInformationDescriptor::GetCountOfRecords.
    ///    pbVal = Receives the number of service records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordNumberOfServices(ubyte bRecordIndex, ubyte* pbVal);
    ///Gets a service identifier from a specified service record in an Integrated Services Digital Broadcasting (ISDB)
    ///transport stream (TS) information descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the descriptor to return. To get the number of descriptors, call
    ///                   IIsdbTSInformationDescriptor::GetCountOfRecords.
    ///    bServiceIndex = Zero-based index of the service identifier to return. To get the number of identifiers, call
    ///                    IIsdbTSInformationDescriptor::GetRecordNumberOfServices.
    ///    pdwVal = Receives the service identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordServiceIdByIndex(ubyte bRecordIndex, ubyte bServiceIndex, ushort* pdwVal);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) digital copy control
///descriptor. The digital copy control descriptor appears in the ISDB Service Information as part of the event
///information table (EIT). Broadcasting service providers who hold copyrights can use this descriptor to provide data
///that controls the recording of digital broadcasts and provides copyright data for digital recording equipment. This
///descriptor also identifies the maximum transmission rate for each event.
@GUID("1A28417E-266A-4BB8-A4BD-D782BCFB8161")
interface IIsdbDigitalCopyControlDescriptor : IUnknown
{
    ///Gets the tag that identifies an Integrated Services Digital Broadcasting (ISDB) digital copy control descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For a digital copy control descriptor, this value is 0xC1.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of an Integrated Services Digital Broadcasting (ISDB) digital copy control descriptor, in
    ///bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets copy control data from an Integrated Services Digital Broadcasting (ISDB) digital copy control descriptor.
    ///Params:
    ///    pbDigitalRecordingControlData = Receives the two-bit code that indicates the type of copy control. This code can have any of the following
    ///                                    values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>00</dt> </dl> </td>
    ///                                    <td width="60%"> Unrestricted copies allowed. </td> </tr> <tr> <td width="40%"> <dl> <dt>01</dt> </dl> </td>
    ///                                    <td width="60%"> When <i>pbCopyControlType</i> parameter is 11, not used; when <i>pbCopyControlType</i> is
    ///                                    01, copying forbidden. </td> </tr> <tr> <td width="40%"> <dl> <dt>10</dt> </dl> </td> <td width="60%"> Can be
    ///                                    copied only once. </td> </tr> <tr> <td width="40%"> <dl> <dt>11</dt> </dl> </td> <td width="60%"> Copying
    ///                                    forbidden. </td> </tr> </table>
    ///    pbCopyControlType = Receives data that defines output control options for digital copying. <table> <tr> <th>Value</th>
    ///                        <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>00</dt> </dl> </td> <td width="60%"> Undefined. </td>
    ///                        </tr> <tr> <td width="40%"> <dl> <dt>01</dt> </dl> </td> <td width="60%"> Output by encoding to serial
    ///                        interface. </td> </tr> <tr> <td width="40%"> <dl> <dt>10</dt> </dl> </td> <td width="60%"> Undefined. </td>
    ///                        </tr> <tr> <td width="40%"> <dl> <dt>11</dt> </dl> </td> <td width="60%"> Output by not encoding to serial
    ///                        interface. </td> </tr> </table>
    ///    pbAPSControlData = Receives data that defines output control options for analog copying when the value of the
    ///                       <i>pbCopyControlType</i> parameter is 01. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///                       width="40%"> <dl> <dt>00</dt> </dl> </td> <td width="60%"> Undefined. </td> </tr> <tr> <td width="40%"> <dl>
    ///                       <dt>01</dt> </dl> </td> <td width="60%"> Output with pseudosync pulse. </td> </tr> <tr> <td width="40%"> <dl>
    ///                       <dt>10</dt> </dl> </td> <td width="60%"> Output with pseudosync pulse + two-line reversed division burst
    ///                       insertion. </td> </tr> <tr> <td width="40%"> <dl> <dt>11</dt> </dl> </td> <td width="60%"> Output with
    ///                       pseudosync pulse + four-line reversed division burst insertion. </td> </tr> </table>
    ///    pbMaximumBitrate = Receives the maximum trasmission rate for transport stream packets, in units of 250 kbps.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCopyControl(ubyte* pbDigitalRecordingControlData, ubyte* pbCopyControlType, ubyte* pbAPSControlData, 
                           ubyte* pbMaximumBitrate);
    ///Gets the number of records in an Integrated Services Digital Broadcasting (ISDB) digital copy control descriptor.
    ///Params:
    ///    pbVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets copy control data from a specified component in an Integrated Services Digital Broadcasting (ISDB) digital
    ///copy control descriptor. When the component_control_flag field in the descriptor is set to 1, the control
    ///information is specified in each component of the descriptor.
    ///Params:
    ///    bRecordIndex = Specifies the record number for the component, indexed from zero. Call the
    ///                   IIsdbDigitalCompyControlDescriptor::GetCountOfRecordsmethod to get the number of records in the digital copy
    ///                   control descriptor.
    ///    pbComponentTag = Receives the tag identifying the component. This value is the same as the component tag in the stream
    ///                     identifier descriptor and the component descriptor.
    ///    pbDigitalRecordingControlData = Receives the two-bit code that indicates the type of copy control. This code can have any of the following
    ///                                    values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>00</dt> </dl> </td>
    ///                                    <td width="60%"> Unrestricted copies allowed. </td> </tr> <tr> <td width="40%"> <dl> <dt>01</dt> </dl> </td>
    ///                                    <td width="60%"> When <i>pbCopyControlType</i> parameter is 11, not used; when <i>pbCopyControlType</i> is
    ///                                    01, copying forbidden. </td> </tr> <tr> <td width="40%"> <dl> <dt>10</dt> </dl> </td> <td width="60%"> Can be
    ///                                    copied only once. </td> </tr> <tr> <td width="40%"> <dl> <dt>11</dt> </dl> </td> <td width="60%"> Copying
    ///                                    forbidden. </td> </tr> </table>
    ///    pbCopyControlType = Receives data that defines output control options for digital copying. <table> <tr> <th>Value</th>
    ///                        <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>00</dt> </dl> </td> <td width="60%"> Undefined. </td>
    ///                        </tr> <tr> <td width="40%"> <dl> <dt>01</dt> </dl> </td> <td width="60%"> Output by encoding to serial
    ///                        interface. </td> </tr> <tr> <td width="40%"> <dl> <dt>10</dt> </dl> </td> <td width="60%"> Undefined. </td>
    ///                        </tr> <tr> <td width="40%"> <dl> <dt>11</dt> </dl> </td> <td width="60%"> Output by not encoding to serial
    ///                        interface. </td> </tr> </table>
    ///    pbAPSControlData = Receives data that defines output control options for analog copying when the value of the
    ///                       <i>pbCopyControlType</i> parameter is 01. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///                       width="40%"> <dl> <dt>00</dt> </dl> </td> <td width="60%"> Undefined. </td> </tr> <tr> <td width="40%"> <dl>
    ///                       <dt>01</dt> </dl> </td> <td width="60%"> Output with pseudosync pulse </td> </tr> <tr> <td width="40%"> <dl>
    ///                       <dt>10</dt> </dl> </td> <td width="60%"> Output with pseudosync pulse + two-line reversed division burst
    ///                       insertion. </td> </tr> <tr> <td width="40%"> <dl> <dt>11</dt> </dl> </td> <td width="60%"> Output with
    ///                       pseudosync pulse + four-line reversed division burst insertion. </td> </tr> </table>
    ///    pbMaximumBitrate = Receives the maximum trasmission rate for transport stream packets, in units of 250 kbps.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordCopyControl(ubyte bRecordIndex, ubyte* pbComponentTag, ubyte* pbDigitalRecordingControlData, 
                                 ubyte* pbCopyControlType, ubyte* pbAPSControlData, ubyte* pbMaximumBitrate);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) audio component descriptor.
///The audio component descriptor appears in the ISDB service information as part of the event information table (EIT)
///and provides information about the audio.
@GUID("679D2002-2425-4BE4-A4C7-D6632A574F4D")
interface IIsdbAudioComponentDescriptor : IUnknown
{
    ///Gets the tag that identifies an Integrated Services Digital Broadcasting (ISDB) audio component descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For ISDB audio component descriptors, this value is 0xC4.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of an Integrated Services Digital Broadcasting (ISDB) audio component descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the value of the stream_content field from an Integrated Services Digital Broadcasting (ISDB) audio
    ///component descriptor. This field contains a code that identifies the descriptor as an ISDB audio component
    ///descriptor.
    ///Params:
    ///    pbVal = Receives the stream_content field value. For audio streams, this value is 0x02.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamContent(ubyte* pbVal);
    ///Gets the value of the component_type field from an Integrated Services Digital Broadcasting (ISDB) audio
    ///component descriptor. This field identifies the audio component type.
    ///Params:
    ///    pbVal = Receives the component_type field value. See Table 6-43 in Section 6.2.26, <i>SERVICE INFORMATION FOR DIGITAL
    ///            BROADCASTING SYSTEM ARIB STANDARD, ARIB STD-B10, Version 4.6</i> for a list of valid component type codes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetComponentType(ubyte* pbVal);
    ///Gets the value of the component_tag field from an Integrated Services Digital Broadcasting (ISDB) audio component
    ///descriptor. This field identifies the component stream and has the same value as the component_tag field in the
    ///stream identifier descriptor in the Program Specific Information (PSI) program map section for the component
    ///stream.
    ///Params:
    ///    pbVal = Receives the component tag.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetComponentTag(ubyte* pbVal);
    ///Gets a code that indicates the stream type from an Integrated Services Digital Broadcasting (ISDB) audio
    ///component descriptor. See Annex E, Table E-4 <i>SERVICE INFORMATION FOR DIGITAL BROADCASTING SYSTEM ARIB
    ///STANDARD, ARIB STD-B10, Version 4.6</i> for a list of valid stream type codes. .
    ///Params:
    ///    pbVal = Receives the stream type code.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamType(ubyte* pbVal);
    ///Gets the value of the simulcast_group_tag field from an Integrated Services Digital Broadcasting (ISDB) audio
    ///component descriptor. For simulcast components, this field contains the tag that identifies all simulcast
    ///components.
    ///Params:
    ///    pbVal = Receives the simulcast group tag. For non-simulcast component, receives 0xFF.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSimulcastGroupTag(ubyte* pbVal);
    ///Gets a flag from an Integrated Services Digital Broadcasting (ISDB) audio component descriptor that indicates
    ///whether the stream uses ES multilingual mode.
    ///Params:
    ///    pfVal = Receives 1 if the stream uses ES multilingual mode.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetESMultiLingualFlag(int* pfVal);
    ///Gets a flag from an Integrated Services Digital Broadcasting (ISDB) audio component descriptor that indicates
    ///whether the audio component is the main audio.
    ///Params:
    ///    pfVal = Receives 1 if the audio component is the main audio or 0 if it is not. In ES simulcast mode, receives 1 if
    ///            the first audio component is the main audio or 0 if it is not.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMainComponentFlag(int* pfVal);
    ///Gets the value of the quality_indicator field from an Integrated Services Digital Broadcasting (ISDB) audio
    ///component descriptor. This two-bit field indicates the tone quality mode.
    ///Params:
    ///    pbVal = Receives one of the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>00</dt> </dl> </td> <td width="60%"> Reserved for future use. </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>01</dt> </dl> </td> <td width="60%"> Mode 1. </td> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>10</dt> </dl> </td> <td width="60%"> Mode 2. </td> </tr> <tr> <td width="40%"> <dl> <dt>11</dt> </dl>
    ///            </td> <td width="60%"> Mode 3. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetQualityIndicator(ubyte* pbVal);
    ///Gets the value of the sampling_rate field from a an Integrated Services Digital Broadcasting (ISDB) audio
    ///component descriptor. This three-bit field contains a code that indicates the sampling frequency.
    ///Params:
    ///    pbVal = Receives one of the following codes: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%">
    ///            <dl> <dt>000</dt> </dl> </td> <td width="60%"> Reserved for future use. </td> </tr> <tr> <td width="40%">
    ///            <dl> <dt>001</dt> </dl> </td> <td width="60%"> 16 kHz. </td> </tr> <tr> <td width="40%"> <dl> <dt>010</dt>
    ///            </dl> </td> <td width="60%"> 22.05 kHz. </td> </tr> <tr> <td width="40%"> <dl> <dt>011</dt> </dl> </td> <td
    ///            width="60%"> 24 kHz. </td> </tr> <tr> <td width="40%"> <dl> <dt>101</dt> </dl> </td> <td width="60%"> 32 kHz.
    ///            </td> </tr> <tr> <td width="40%"> <dl> <dt>110</dt> </dl> </td> <td width="60%"> 44.1 kHz. </td> </tr> <tr>
    ///            <td width="40%"> <dl> <dt>111</dt> </dl> </td> <td width="60%"> 48 kHz. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSamplingRate(ubyte* pbVal);
    ///Gets the three-character ISO 639 language code from an Integrated Services Digital Broadcasting (ISDB) audio
    ///component descriptor. If the stream uses ES multilingual mode, this method returns the first language code.
    ///Params:
    ///    pszCode = Pointer to the buffer that receives the language code. For a list of language codes, refer to ISO 639 Code
    ///              Tables.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLanguageCode(char* pszCode);
    ///In ES multilingual mode, gets the second three-character ISO 639 language code from an ISDB audio component
    ///descriptor.
    ///Params:
    ///    pszCode = Pointer to the buffer that receives the language code. For a list of language codes, refer to ISO 639 Code
    ///              Tables.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLanguageCode2(char* pszCode);
    ///Gets the component stream description from an Integrated Services Digital Broadcasting (ISDB) audio component
    ///descriptor, in Unicode text format,.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrText = Pointer to a buffer that receives the component stream description. The caller is responsible for freeing
    ///                this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTextW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrText);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) data content descriptor. The
///data content descriptor appears in the ISDB Service Information as part of the event information table (EIT) and
///provides details about the content of a data broadcasting event.
@GUID("A428100A-E646-4BD6-AA14-6087BDC08CD5")
interface IIsdbDataContentDescriptor : IUnknown
{
    ///Gets the tag that identifies an Integrated Services Digital Broadcasting (ISDB) data content descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For ISDB data content descriptors, this value is 0xC7.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of an Integrated Services Digital Broadcasting (ISDB) data content descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets a data component identifier from an Integrated Services Digital Broadcasting (ISDB) data content descriptor.
    ///This identifier identifies a component in the descriptor and appears in the data component descriptor for the
    ///component.
    ///Params:
    ///    pwVal = Receives the data component identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDataComponentId(ushort* pwVal);
    ///Gets the value of the entry_component field from an Integrated Services Digital Broadcasting (ISDB) data content
    ///descriptor. This field indicates the first component stream that is referenced in the descriptor.
    ///Params:
    ///    pbVal = Returns the entry_component field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEntryComponent(ubyte* pbVal);
    ///Gets the length of the selector part of an Integrated Services Digital Broadcasting (ISDB) data content
    ///descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the selector length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSelectorLength(ubyte* pbVal);
    ///Gets the selector data from an Integrated Services Digital Broadcasting (ISDB) data content descriptor. The
    ///contents of the selector depend on the type of data transmitted in the data component.
    ///Params:
    ///    bBufLength = Specifies the length of the buffer that receives the selector data.
    ///    pbBuf = Receives the selector data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSelectorBytes(ubyte bBufLength, ubyte* pbBuf);
    ///Gets the number of records in an Integrated Services Digital Broadcasting (ISDB) data content descriptor.
    ///Params:
    ///    pbVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets the value of the component_ref field from a specified component record in an Integrated Services Digital
    ///Broadcasting (ISDB) data content descriptor. This field contains the broadcaster-defined component tag that
    ///identifies a component stream.
    ///Params:
    ///    bRecordIndex = Zero-based index of the component record containing the tag. To get the number of components, call
    ///                   IIsdbDataContentDescriptor::GetCountOfRecords.
    ///    pbVal = Receives the component tag.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordComponentRef(ubyte bRecordIndex, ubyte* pbVal);
    ///Gets the three-character ISO 639 language code from an Integrated Services Digital Broadcasting (ISDB) data
    ///content descriptor.
    ///Params:
    ///    pszCode = Pointer to the buffer that receives the language code. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLanguageCode(char* pszCode);
    ///Gets the text from an Integrated Services Digital Broadcasting (ISDB) data content descriptor that describes the
    ///contents of the descriptor, in Unicode text format.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrText = Pointer to a buffer that receives the description text. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTextW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrText);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) conditional access (CA)
///contract information descriptor. The conditional access contract information descriptor appears in the ISDB Service
///Information as part of the event information iable (EIT) or service description table (SDT). The
///<b>IIsdbaCAContractInformationDescriptor</b> Interface is used to check whether a program scheduled for broadcast is
///a flator tiered-type service or event, or a pay-per-view event, and to check whether the program can be reserved for
///viewing or recording in advance.
@GUID("08E18B25-A28F-4E92-821E-4FCED5CC2291")
interface IIsdbCAContractInformationDescriptor : IUnknown
{
    ///Gets the tag that identifies an Integrated Services Digital Broadcasting (ISDB) conditional access (CA)contract
    ///information descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For ISDB CA contract information descriptors, this value is 0xCB.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of an Integrated Services Digital Broadcasting (ISDB) conditional access (CA) contract
    ///information descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the value of the CA_system_id field from an Integrated Services Digital Broadcasting (ISDB) conditional
    ///access (CA) contract information descriptor. This field identifies the conditional access system associated with
    ///the contract information.
    ///Params:
    ///    pwVal = Receives the conditional access system identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCASystemId(ushort* pwVal);
    ///Gets the value of the CA_unit_id field from an Integrated Services Digital Broadcasting (ISDB) conditional access
    ///(CA) contract information descriptor. This field identifies the billing or nonbilling unit to which the component
    ///belongs.
    ///Params:
    ///    pbVal = Receives the conditional access unit identifier. This can be any of the following values. <table> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x0</dt> </dl> </td> <td width="60%">
    ///            Nonbilling unit group. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x1</dt> </dl> </td> <td width="60%">
    ///            Billing unit group including default event ES group. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x2 -
    ///            0xF</dt> </dl> </td> <td width="60%"> Billing unit group other than the default event ES group. </td> </tr>
    ///            </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCAUnitId(ubyte* pbVal);
    ///Gets the number of records in an Integrated Services Digital Broadcasting (ISDB) conditional access (CA) contract
    ///information descriptor.
    ///Params:
    ///    pbVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets the broadcaster-defined tag that identifies a component record from an Integrated Services Digital
    ///Broadcasting (ISDB) conditional access (CA) contract information descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the component record that contains the tag. To get the number of components, call
    ///                   IIsdbCAContractInformationDescriptor::GetCountOfRecords.
    ///    pbVal = Receives the component record ID tag.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordComponentTag(ubyte bRecordIndex, ubyte* pbVal);
    ///Gets the length of the contract_verification_info field from an Integrated Services Digital Broadcasting (ISDB)
    ///conditional access (CA) contract information descriptor.
    ///Params:
    ///    pbVal = Receives the field length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetContractVerificationInfoLength(ubyte* pbVal);
    ///Gets data from the contract_verification_info field in an Integrated Services Digital Broadcasting (ISDB)
    ///conditional access (CA) contract information descriptor. This field is used to determine allowable uses of the
    ///conditional access service.
    ///Params:
    ///    bBufLength = Specifies the length of the buffer that holds the contract verification data.
    ///    pbBuf = Pointer to a buffer that receives the contract verification data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetContractVerificationInfo(ubyte bBufLength, ubyte* pbBuf);
    ///Gets, in Unicode-text format, the value of the fee_name field from an Integrated Services Digital Broadcasting
    ///(ISDB) conditional access (CA) contract information descriptor. This field describes the fee for the ES group
    ///being described.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrName = Pointer to a buffer that receives the fee name. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFeeNameW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrName);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) event group descriptor. The
///event group descriptor appears in the ISDB service information as part of the event information table (EIT) and
///describes a group of related events.
@GUID("94B06780-2E2A-44DC-A966-CC56FDABC6C2")
interface IIsdbEventGroupDescriptor : IUnknown
{
    ///Gets the tag that identifies an Integrated Services Digital Broadcasting (ISDB) event group descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For ISDB event group descriptors, this value is 0xD6.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of an Integrated Services Digital Broadcasting (ISDB) event group descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets a code that describes the event group type from an Integrated Services Digital Broadcasting (ISDB) event
    ///group descriptor.
    ///Params:
    ///    pbVal = Receives the event group type. This can be any of the following values. <table> <tr> <th>Value</th>
    ///            <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x1</dt> </dl> </td> <td width="60%"> Event common.
    ///            </td> </tr> <tr> <td width="40%"> <dl> <dt>0x2</dt> </dl> </td> <td width="60%"> Event relay. </td> </tr>
    ///            <tr> <td width="40%"> <dl> <dt>0x3</dt> </dl> </td> <td width="60%"> Event movement. </td> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0x4</dt> </dl> </td> <td width="60%"> Event relay to other networks. </td> </tr> <tr>
    ///            <td width="40%"> <dl> <dt>0x5</dt> </dl> </td> <td width="60%"> Event movement from other networks. </td>
    ///            </tr> <tr> <td width="40%"> <dl> <dt>0x0, 0x6-0xF</dt> </dl> </td> <td width="60%"> Undefined. </td> </tr>
    ///            </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetGroupType(ubyte* pbVal);
    ///Gets the number of event records from an Integrated Services Digital Broadcasting (ISDB) event group descriptor.
    ///Params:
    ///    pbVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets data from an event record in an Integrated Services Digital Broadcasting (ISDB) event group descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the event record containing the data. To get the number of components, call
    ///                   IIsdbEventGrouptDescriptor::GetCountOfRecords.
    ///    pwServiceId = Receives the value of the sevice_id field from the event record. This value identifies the information
    ///                  service and appears in the program_number field of the corresponding program map section.
    ///    pwEventId = Receives the value of the event_id field from the related event record. This value identifies the event.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordEvent(ubyte bRecordIndex, ushort* pwServiceId, ushort* pwEventId);
    ///Gets the number of related event records from an Integrated Services Digital Broadcasting (ISDB) event group
    ///descriptor.
    ///Params:
    ///    pbVal = Receives the number of related event records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRefRecords(ubyte* pbVal);
    ///Gets data from a related event record in an Integrated Services Digital Broadcasting (ISDB) event group
    ///descriptor. The descriptor contains records for related events if the group_type field of the descriptor has a
    ///value of 4 or 5. If this field has a value of 4, it indicates an event relay to other networks. If this field has
    ///a value of 5, it indicates an event movement from other networks.
    ///Params:
    ///    bRecordIndex = Zero-based index of the related event record containing the data. To get the number of components, call
    ///                   IIsdbEventGrouptDescriptor::GetCountOfRecords.
    ///    pwOriginalNetworkId = Receives the value of the original_network_id field from the related event record. This value is transmitted
    ///                          at the time of event relay or event move across networks.
    ///    pwTransportStreamId = Receives the value of the transport_stream_id field from the related event record. This value that is
    ///                          transmitted at the time of event relay or event move across networks.
    ///    pwServiceId = Receives the value of the sevice_id field from the related event record. This value identifies the related
    ///                  information service and appears in the program_number field of the corresponding program map section.
    ///    pwEventId = Receives the value of the event_id field from the related event record. This value identifies the related
    ///                event.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRefRecordEvent(ubyte bRecordIndex, ushort* pwOriginalNetworkId, ushort* pwTransportStreamId, 
                              ushort* pwServiceId, ushort* pwEventId);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) component group descriptor.
///The component group descriptor appears in the ISDB service information as part of the event information table (EIT)
///and describes component grouping in an event.
@GUID("A494F17F-C592-47D8-8943-64C9A34BE7B9")
interface IIsdbComponentGroupDescriptor : IUnknown
{
    ///Gets the tag that identifies an Integrated Services Digital Broadcasting (ISDB) component group descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For ISDB component group descriptors, this value is 0xD9.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of an Integrated Services Digital Broadcasting (ISDB) component group descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the value of the component_group_type field from an Integrated Services Digital Broadcasting (ISDB)
    ///component group descriptor. This three-bit field indicates the group type to which the components in the
    ///descriptor belong.
    ///Params:
    ///    pbVal = Receives the group type. This can have any of the following values. <table> <tr> <th>Value</th>
    ///            <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>000</dt> </dl> </td> <td width="60%"> Multiview
    ///            television service. </td> </tr> <tr> <td width="40%"> <dl> <dt>001-111</dt> </dl> </td> <td width="60%">
    ///            Undefined. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetComponentGroupType(ubyte* pbVal);
    ///Gets the number of component records in an Integrated Services Digital Broadcasting (ISDB) component group
    ///descriptor.
    ///Params:
    ///    pbVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets the component group identifier from an Integrated Services Digital Broadcasting (ISDB) component group
    ///descriptor.
    ///Params:
    ///    bRecordIndex = Specifies the component group record number, indexed from zero. Call the
    ///                   IIsdbComponentGroupDescriptor::GetCountOfRecordsmethod to get the number of records in the extended event
    ///                   descriptor.
    ///    pbVal = Receives the component group record number.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordGroupId(ubyte bRecordIndex, ubyte* pbVal);
    ///Gets the number of conditional access unit records in a component group from an Integrated Services Digital
    ///Broadcasting (ISDB) component group descriptor.
    ///Params:
    ///    bRecordIndex = Specifies the component group record number, indexed from zero. Call the
    ///                   IIsdbComponentGroupDescriptor::GetCountOfRecordsmethod to get the number of records in the extended event
    ///                   descriptor.
    ///    pbVal = Receives the number of conditional access unit records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordNumberOfCAUnit(ubyte bRecordIndex, ubyte* pbVal);
    ///Gets a conditional access unit identifier from a specified component group record in an Integrated Services
    ///Digital Broadcasting (ISDB) component group descriptor. This identifier specifies the type of conditional access
    ///unit group to which the component belongs.
    ///Params:
    ///    bRecordIndex = Specifies the component group record number, indexed from zero. Call the
    ///                   IIsdbComponentGroupDescriptor::GetCountOfRecordsmethod to get the number of records in the descriptor.
    ///    bCAUnitIndex = Specifies the conditional access unit record number, indexed from zero. Call the
    ///                   IIsdbComponentGroupDescriptor::GetRecordCAUnitNumberOfComponentsmethod to get the number of conditional
    ///                   access records in the descriptor.
    ///    pbVal = Receives the conditional access unit identifier. This can be any of the following values. <table> <tr>
    ///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x0</dt> </dl> </td> <td width="60%">
    ///            Non-conditional access unit group. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x1</dt> </dl> </td> <td
    ///            width="60%"> Conditional access unit group that includes the default elementary stream group. </td> </tr>
    ///            <tr> <td width="40%"> <dl> <dt>0x2-0xF</dt> </dl> </td> <td width="60%"> Conditional access unit group other
    ///            than that including the default elementary stream group. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordCAUnitCAUnitId(ubyte bRecordIndex, ubyte bCAUnitIndex, ubyte* pbVal);
    ///Gets the number of components corresponding to a conditional access unit from an Integrated Services Digital
    ///Broadcasting (ISDB) component group descriptor.
    ///Params:
    ///    bRecordIndex = Specifies the component record number, indexed from zero. Call the
    ///                   IIsdbComponentGroupDescriptor::GetCountOfRecordsmethod to get the number of component records in the
    ///                   component group descriptor.
    ///    bCAUnitIndex = Specifies the conditional access unit record number, indexed from zero. Call the
    ///                   IIsdbComponentGroupDescriptor::GetRecordNumberOfCAUnitmethod to get the number of conditional access unit
    ///                   records in the component group descriptor.
    ///    pbVal = Receives the number of components.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordCAUnitNumberOfComponents(ubyte bRecordIndex, ubyte bCAUnitIndex, ubyte* pbVal);
    ///Gets the tag that identifies a component record in an Integrated Services Digital Broadcasting (ISDB) component
    ///group descriptor.
    ///Params:
    ///    bRecordIndex = Specifies the component record number, indexed from zero. Call the
    ///                   IIsdbComponentGroupDescriptor::GetCountOfRecordsmethod to get the number of records in the extended event
    ///                   descriptor.
    ///    bCAUnitIndex = Specifies the conditional access unit number within the component group, indexed from zero. Call the
    ///                   IIsdbComponentGroupDescriptor::GetRecordNumberOfCAUnitmethod to get the number of records in the extended
    ///                   event descriptor.
    ///    bComponentIndex = Specifies the component within the component group, indexed from zero. Call the
    ///                      IIsdbComponentGroupDescriptor::GetRecordCAUnitNumberOfComponentsmethod to get the number of components for
    ///                      the conditional access unit given by the <i>bCAUnitIndex</i> parameter.
    ///    pbVal = Receives the component tag value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordCAUnitComponentTag(ubyte bRecordIndex, ubyte bCAUnitIndex, ubyte bComponentIndex, 
                                        ubyte* pbVal);
    ///Gets the total bit rate from a component within a component group in an Integrated Services Digital Broadcasting
    ///(ISDB) component group descriptor.
    ///Params:
    ///    bRecordIndex = Specifies the component group record number, indexed from zero. Call the
    ///                   IIsdbComponentGroupDescriptor::GetCountOfRecordsmethod to get the number of records in the extended event
    ///                   descriptor.
    ///    pbVal = Receives the total bit rate for the component, in units of 250 Kbps.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordTotalBitRate(ubyte bRecordIndex, ubyte* pbVal);
    ///Gets the text that describes a component group from an Integrated Services Digital Broadcasting (ISDB) component
    ///group descriptor.
    ///Params:
    ///    bRecordIndex = Specifies the component group record number, indexed from zero. Call the
    ///                   IIsdbComponentGroupDescriptor::GetCountOfRecordsmethod to get the number of records in the extended event
    ///                   descriptor.
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrText = Receives the text that describes the component group, as a <b>BSTR</b>. The caller must free the <b>BSTR</b>
    ///                by calling <b>SysFreeString</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordTextW(ubyte bRecordIndex, __MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, 
                           BSTR* pbstrText);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) series descriptor. The
///series descriptor appears in the ISDB Service Information as part of the event information table (EIT) and defines
///series information among multiple events.
@GUID("07EF6370-1660-4F26-87FC-614ADAB24B11")
interface IIsdbSeriesDescriptor : IUnknown
{
    ///Gets the tag that identifies an Integrated Services Digital Broadcasting (ISDB) series descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For ISDB series descriptors, this value is 0xD5.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of an Integrated Services Digital Broadcasting (ISDB) series descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets a unique series identifier from an Integrated Services Digital Broadcasting (ISDB) series descriptor.
    ///Params:
    ///    pwVal = Receives the series identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSeriesId(ushort* pwVal);
    ///Gets a label that identifies a series repeat from an Integrated Services Digital Broadcasting (ISDB) series
    ///descriptor.
    ///Params:
    ///    pbVal = Receives the repeat label. If this label is zero, the series is an original broadcast.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRepeatLabel(ubyte* pbVal);
    ///Gets a code that indicates how often a series is programmed from an Integrated Services Digital Broadcasting
    ///(ISDB) series descriptor.
    ///Params:
    ///    pbVal = Receives the program pattern code. This can be any of the following values. <table> <tr> <th>Value</th>
    ///            <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x0</dt> </dl> </td> <td width="60%"> Unscheduled.
    ///            </td> </tr> <tr> <td width="40%"> <dl> <dt>0x1</dt> </dl> </td> <td width="60%"> Programmed several times
    ///            weekly. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x2</dt> </dl> </td> <td width="60%"> Programmed once
    ///            weekly. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x3</dt> </dl> </td> <td width="60%"> Programmed once
    ///            monthly. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x4</dt> </dl> </td> <td width="60%"> Programmed several
    ///            times in a single day. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x5</dt> </dl> </td> <td width="60%">
    ///            Division of a long program. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x6</dt> </dl> </td> <td width="60%">
    ///            Program for regular or irregular accumulation. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x7</dt> </dl>
    ///            </td> <td width="60%"> Undefined. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetProgramPattern(ubyte* pbVal);
    ///Gets a series expiration date from an Integrated Services Digital Broadcasting (ISDB) series descriptor.
    ///Params:
    ///    pfValid = Receives a flag that indicates whether the series expiration date in the descriptor expire_date field is
    ///              valid.
    ///    pmdtVal = Receives the date and time when the series expires.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetExpireDate(int* pfValid, MPEG_DATE_AND_TIME* pmdtVal);
    ///Gets the episode number from an Integrated Services Digital Broadcasting (ISDB) series descriptor.
    ///Params:
    ///    pwVal = Receives the episode number.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEpisodeNumber(ushort* pwVal);
    ///Gets the number of the last episode of a series from an Integrated Services Digital Broadcasting (ISDB) series
    ///descriptor.
    ///Params:
    ///    pwVal = Receives the last episode number.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLastEpisodeNumber(ushort* pwVal);
    ///Gets the series name from an Integrated Services Digital Broadcasting (ISDB) series descriptor.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrName = Pointer to a buffer that receives the series name. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSeriesNameW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrName);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) download content descriptor.
///The download content descriptor appears in the ISDB Service Information as part of the software download trigger
///table (SDTT) and provides details about content and scheduling related to downloading.
@GUID("5298661E-CB88-4F5F-A1DE-5F440C185B92")
interface IIsdbDownloadContentDescriptor : IUnknown
{
    ///Gets the tag that identifies an Integrated Services Digital Broadcasting (ISDB) download content descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For ISDB download content descriptors, this value is 0xC9.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of an Integrated Services Digital Broadcasting (ISDB) download content descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets flag values from an Integrated Services Digital Broadcasting (ISDB) download content descriptor.
    ///Params:
    ///    pfReboot = Receives the value of the reboot flag. This flag is 1 if a reboot is required after the download, or 0 if it
    ///               is not.
    ///    pfAddOn = Receives the value of the add_on flag. This flag is 1 if the download is added to an existing file, or 0 if
    ///              the download overwrites the existing file.
    ///    pfCompatibility = Receives the value of the compatibility_flag field. This flag is 1 if the descriptor has a compatibility
    ///                      descriptor, or 0 if it does not.
    ///    pfModuleInfo = Receives the value of the module_info flag. This flag is 1 if the descriptor information for each module, or
    ///                   0 if it does not.
    ///    pfTextInfo = Receives the value of the text_info_flag field. This flag is 1 if the descriptor includes a text description
    ///                 in its last field, or 0 if it does not.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFlags(int* pfReboot, int* pfAddOn, int* pfCompatibility, int* pfModuleInfo, int* pfTextInfo);
    ///Gets the total size of components transmitted within the same carousel from an Integrated Services Digital
    ///Broadcasting (ISDB) download content descriptor, in bytes.
    ///Params:
    ///    pdwVal = Receives the component size.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetComponentSize(uint* pdwVal);
    ///Gets the download identifier from an Integrated Services Digital Broadcasting (ISDB) download content descriptor.
    ///The download identifier identifies an application number for the download.
    ///Params:
    ///    pdwVal = Receives the download identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDownloadId(uint* pdwVal);
    ///Gets the value of the time_out_value_DII field from an Integrated Services Digital Broadcasting (ISDB) download
    ///content descriptor. The time_out_value_DII field indicates the recommended timeout value for receiving all
    ///sections of the corresponding carousel, in milliseconds.
    ///Params:
    ///    pdwVal = Receives the recommended timeout value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTimeOutValueDII(uint* pdwVal);
    ///Gets the leak rate of the transport buffer from an Integrated Services Digital Broadcasting (ISDB) download
    ///content descriptor, in bytes per second.
    ///Params:
    ///    pdwVal = Receives the leak rate.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLeakRate(uint* pdwVal);
    ///Gets the tag that identifies a stream component from an Integrated Services Digital Broadcasting (ISDB) download
    ///content descriptor. This tag also identifies the stream in the program map table (PMT).
    ///Params:
    ///    pbVal = Receives the component tag.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetComponentTag(ubyte* pbVal);
    ///Gets the length of the compatibility descriptor from an Integrated Services Digital Broadcasting (ISDB) download
    ///content descriptor.
    ///Params:
    ///    pwLength = Receives the length of the compatibility descriptor.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCompatiblityDescriptorLength(ushort* pwLength);
    ///Gets data from the compatibility descriptor in an Integrated Services Digital Broadcasting (ISDB) download
    ///content descriptor. The compatibility descriptor specifies a target to be updated by the download.
    ///Params:
    ///    ppbData = Pointer to a buffer that receives the compatibility descriptor. The caller is responsible for freeing this
    ///              memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCompatiblityDescriptor(ubyte** ppbData);
    ///Gets the body length of an Integrated Services Digital Broadcasting (ISDB) download content descriptor, in bytes.
    ///Params:
    ///    pwVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ushort* pwVal);
    ///Gets the identifier from an Integrated Services Digital Broadcasting (ISDB) download content descriptor that
    ///specifies the carousel used for downloading.
    ///Params:
    ///    wRecordIndex = Specifies the module record number, indexed from zero. Call the
    ///                   IIsdbDownloadContentDescriptor::GetCountOfRecordsmethod to get the number of records in the extended event
    ///                   descriptor.
    ///    pwVal = Receives the module ID.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordModuleId(ushort wRecordIndex, ushort* pwVal);
    ///Gets the size of a module from an Integrated Services Digital Broadcasting (ISDB) download content descriptor, in
    ///bytes.
    ///Params:
    ///    wRecordIndex = Specifies the record number for the module containing the module_info_byte field, indexed from zero. Call the
    ///                   IIsdbDownloadContentDescriptor::GetCountOfRecordsmethod to get the number of records in the download content
    ///                   descriptor.
    ///    pdwVal = Receives the module size.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordModuleSize(ushort wRecordIndex, uint* pdwVal);
    ///Gets the value of the module_info_length field from an Integrated Services Digital Broadcasting (ISDB) download
    ///content descriptor. The module_info_length field gives the length of the module_info_byte field in the
    ///descriptor.
    ///Params:
    ///    wRecordIndex = Specifies the record number for the module containing the module_info_byte field, indexed from zero. Call the
    ///                   IIsdbDownloadContentDescriptor::GetCountOfRecordsmethod to get the number of records in the extended event
    ///                   descriptor.
    ///    pbVal = Receives the length of the module_info_byte field. Call the
    ///            IIsdbDownloadContentDescriptor::GetRecordModuleInfo method to get the contents of this field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordModuleInfoLength(ushort wRecordIndex, ubyte* pbVal);
    ///Gets the value of a module_info_byte field from a module record in an Integrated Services Digital Broadcasting
    ///(ISDB) download content descriptor. This field can include the type, name, information, or control descriptor
    ///from the download information indication (DII) message.
    ///Params:
    ///    wRecordIndex = Specifies the record number for the module containing the module_info_byte field, indexed from zero. Call the
    ///                   IIsdbDownloadContentDescriptor::GetCountOfRecordsmethod to get the number of records in the extended event
    ///                   descriptor.
    ///    ppbData = Pointer to a buffer that receives the field value. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordModuleInfo(ushort wRecordIndex, ubyte** ppbData);
    ///Gets the three-character ISO 639 language code from an Integrated Services Digital Broadcasting (ISDB) download
    ///content descriptor.
    ///Params:
    ///    szCode = Receives the language code.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTextLanguageCode(char* szCode);
    ///Gets the text from an Integrated Services Digital Broadcasting (ISDB) download content descriptor that describes
    ///the descriptor contents, in Unicode text format.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrName = Pointer to a buffer that receives the description text. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTextW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrName);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) logo transmission
///descriptor. The logo transmission descriptor appears in the ISDB Service Information as part of the service
///description table (SDT) and contains information required for transmission of logos.
@GUID("E0103F49-4AE1-4F07-9098-756DB1FA88CD")
interface IIsdbLogoTransmissionDescriptor : IUnknown
{
    ///Gets the tag that identifies an Integrated Services Digital Broadcasting (ISDB) logo transmission descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For ISDB logo transmission descriptors, this value is 0xCF.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of an Integrated Services Digital Broadcasting (ISDB) logo transmission descriptor, in
    ///bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the value of the logo_transmission_type field from an Integrated Services Digital Broadcasting (ISDB) logo
    ///transmission descriptor. This field contains a code that indicates the logo transmission type.
    ///Params:
    ///    pbVal = Receives the logo transmission type. This can be any of the following values. <table> <tr> <th>Value</th>
    ///            <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x01</dt> </dl> </td> <td width="60%"> Common data
    ///            table (CDT) transmission scheme 1, which refers to CDT directly using download data identification. </td>
    ///            </tr> <tr> <td width="40%"> <dl> <dt>0x02</dt> </dl> </td> <td width="60%"> CDT transmission scheme 2, which
    ///            refers to CDT indirectly using download data identification. </td> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>0x03</dt> </dl> </td> <td width="60%"> Simple logo system. </td> </tr> <tr> <td width="40%"> <dl>
    ///            <dt>0x04-0xFF</dt> </dl> </td> <td width="60%"> Reserved for future use. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLogoTransmissionType(ubyte* pbVal);
    ///Gets the logo identifier from an Integrated Services Digital Broadcasting (ISDB) logo transmission descriptor.
    ///Params:
    ///    pwVal = Receives the logo identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLogoId(ushort* pwVal);
    ///Gets the value of the logo_version field from an Integrated Services Digital Broadcasting (ISDB) logo
    ///transmission descriptor. This field contains the version number of the logo specified in the descriptor logo_id
    ///field.
    ///Params:
    ///    pwVal = Receives the logo version number. Call the IIsdbLogoTransmissionDescriptor::GetLogoId method to get the value
    ///            of the logo_id field.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLogoVersion(ushort* pwVal);
    ///Gets the value of the download_data_id field from an Integrated Services Digital Broadcasting (ISDB) logo
    ///transmission descriptor. This field identifies the downloaded data and has the same value as the
    ///table_id_extensions field in the common data table that contains the logo data.
    ///Params:
    ///    pwVal = Receives the download data identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDownloadDataId(ushort* pwVal);
    ///Gets the character string for a simple logo from an Integrated Services Digital Broadcasting (ISDB) logo
    ///transmission descriptor.
    ///Params:
    ///    convMode = Specifies the string conversion mode to use. This parameter can have any of the following values.<ul>
    ///               <li><b>STRCONV_MODE_DVB</b></li> <li><b>STRCONV_MODE_DVB_EMPHASIS</b></li>
    ///               <li><b>STRCONV_MODE_DVB_WITHOUT_EMPHASIS</b></li> <li><b>STRCONV_MODE_ISDB</b></li> </ul>
    ///    pbstrChar = Pointer to a buffer that receives the logo text. The caller is responsible for freeing this memory.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLogoCharW(__MIDL___MIDL_itf_dvbsiparser_0000_0000_0001 convMode, BSTR* pbstrChar);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) service information (SI)
///parameter descriptor. The SI parameter descriptor appears in the program map table (PMT) or network information table
///(NIT).
@GUID("F837DC36-867C-426A-9111-F62093951A45")
interface IIsdbSIParameterDescriptor : IUnknown
{
    ///Gets the tag that identifies a service information (SI) parameter descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For SI parameter descriptors, this value is 0xD7.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a service information (SI) parameter descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the version number of a parameter from a service information (SI) parameter descriptor. This version number
    ///is incremented by one each time the parameter is updated.
    ///Params:
    ///    pbVal = Receives the version number.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetParameterVersion(ubyte* pbVal);
    ///Gets the time at which a parameter becomes valid from a service information (SI) parameter descriptor.
    ///Params:
    ///    pVal = Receives the date/time value that indicates when the parameter becomes valid.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetUpdateTime(MPEG_DATE* pVal);
    ///Gets the number of table descriptors in a service information (SI) parameter descriptor.
    ///Params:
    ///    pbVal = Receives the number of table descriptors.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordNumberOfTable(ubyte* pbVal);
    ///Gets an identifier for a table descriptor in a service information (SI) parameter descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the SI table descriptor. To get the number of table descriptors, call the
    ///                   IIsdbSIParameterDescriptor::GetRecordNumberOfTable method.
    ///    pbVal = Receives the table descriptor identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTableId(ubyte bRecordIndex, ubyte* pbVal);
    ///Gets the body length of a table descriptor in a service information (SI) parameter descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the SI table descriptor. To get the number of table descriptors, call the
    ///                   IIsdbSIParameterDescriptor::GetRecordNumberOfTable method.
    ///    pbVal = Receives the length of the table descriptor, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTableDescriptionLength(ubyte bRecordIndex, ubyte* pbVal);
    ///Gets description data from a table descriptor in a service information (SI) parameter descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the SI table descriptor. To get the number of table descriptors, call the
    ///                   IIsdbSIParameterDescriptor::GetRecordNumberOfTable method.
    ///    pbBufferLength = On input specifies the length of the table descriptor data that is retrieved, in bytes. On output returns the
    ///                     actual data length.
    ///    pbBuffer = Receives the table descriptor data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTableDescriptionBytes(ubyte bRecordIndex, ubyte* pbBufferLength, ubyte* pbBuffer);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) emergency information
///descriptor. The emergency information descriptor appears as part of the service information (SI) in the program map
///table (PMT) or network information table (NIT). It is transmitted when an emergency warning is broadcast and includes
///all information required for the warning signal.
@GUID("BA6FA681-B973-4DA1-9207-AC3E7F0341EB")
interface IIsdbEmergencyInformationDescriptor : IUnknown
{
    ///Gets the tag that identifies an emergency information descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For emergency information descriptors, this value is 0xFC.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of an emergency information descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the number of records in an emergency information descriptor.
    ///Params:
    ///    pbVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(ubyte* pbVal);
    ///Gets the identifier for a broadcasting event from an emergency information descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the emergency information descriptor that contains the event identifiers. To get the
    ///                   number of emergency information descriptors, call IIsdbEmergencyInformationDescriptor::GetCountOfRecords
    ///    pwVal = Receives the broadcasting event identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceId(ubyte bRecordIndex, ushort* pwVal);
    ///Gets the value of the start_end_flag field from an emergency information descriptor. This field indicates whether
    ///the emergency alarm signal has started or finished broadcasting.
    ///Params:
    ///    bRecordIndex = Zero-based index of the service information (SI) descriptor containing the table descriptor. To get the
    ///                   number of SI descriptors, call IIsdbEmergencyInformationDescriptor::GetCountOfRecords
    ///    pVal = Gets the start/end flag from the descriptor. If this value is 1, the emergency signal has started or is being
    ///           broadcast. If it is 0, the emergency signal broadcast has ended.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStartEndFlag(ubyte bRecordIndex, ubyte* pVal);
    ///Gets a flag that indicates the emergency alarm signal type from an emergency information descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the emergency information descriptor that contains the emergency alarm signal. To get the
    ///                   number of emergency information descriptors, call IIsdbEmergencyInformationDescriptor::GetCountOfRecords.
    ///    pbVal = Receives a boolean value that indicates whether the emergency alarm signal is the first (0) or second (1)
    ///            type of start signal. Annex D of the document titled <i>SERVICE INFORMATION FOR DIGITAL BROADCASTING SYSTEM,
    ///            ARIB STANDARD, ARIB STD-B10, Version 4.4</i> describes the two start signal types.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSignalLevel(ubyte bRecordIndex, ubyte* pbVal);
    ///Gets the area codes from an emergency information descriptor.
    ///Params:
    ///    bRecordIndex = Zero-based index of the emergency information descriptor that contains the area code records. To get the
    ///                   number of area code records, call IIsdbEmergencyInformationDescriptor::GetCountOfRecords.
    ///    ppwVal = Pointer to a buffer allocated to hold the area codes. The caller is responsible for freeing this memory.
    ///    pbNumAreaCodes = Receives the number of area codes in the descriptor.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAreaCode(ubyte bRecordIndex, ushort** ppwVal, ubyte* pbNumAreaCodes);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) conditional access (CA)
///descriptor. The CA descriptor appears in the ISDB service information as part of the conditional access table (CAT)
///or program map table (PMT) and indicates the program identifiers (PIDs) of transport stream packets that contain
///entitlement control message (ECM) data or entitlement management message (EMM) data.
@GUID("0570AA47-52BC-42AE-8CA5-969F41E81AEA")
interface IIsdbCADescriptor : IUnknown
{
    ///Gets the tag that identifies a conditional access (CA) descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For conditional access descriptors, this value is 0x09.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of a conditional access (CA) descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the conditional access (CA) system identifier from a conditional access descriptor.
    ///Params:
    ///    pwVal = Receives the conditional access system identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCASystemId(ushort* pwVal);
    ///Gets the reserved bits from a conditional access (CA) descriptor.
    ///Params:
    ///    pbVal = Receives the reserved bits.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetReservedBits(ubyte* pbVal);
    ///Gets the conditional access (CA) program identifier (PID) from a conditional access descriptor.
    ///Params:
    ///    pwVal = Receives the conditional access PID value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCAPID(ushort* pwVal);
    ///Gets the private data bytes from a conditional access (CA) descriptor.
    ///Params:
    ///    pbBufferLength = On input, specifies the length of the private data being retrieved, in bytes. On output, returns the actual
    ///                     data length.
    ///    pbBuffer = Receives the conditional access private data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPrivateDataBytes(ubyte* pbBufferLength, ubyte* pbBuffer);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) conditional access (CA)
///service descriptor. The conditional access service descriptor appears in the ISDB service information as part of the
///conditional access table (CAT). It facilitates the display of entitlement management message (EMM) automatic display
///messages by indicating the broadcaster group that provides the service, the EMM automatic display message, and the
///delay time for displaying the "EMM automatic display message" .
@GUID("39CBEB97-FF0B-42A7-9AB9-7B9CFE70A77A")
interface IIsdbCAServiceDescriptor : IUnknown
{
    ///Gets the tag that identifies a conditional access (CA) service descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For conditional access service descriptors, this value is 0xCC.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of conditional access (CA) service descriptor, in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the conditional access (CA) system identifier from a CA service descriptor.
    ///Params:
    ///    pwVal = Receives the conditional access system identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCASystemId(ushort* pwVal);
    ///Gets the conditional access (CA) broadcaster group identifier from a CA service descriptor.
    ///Params:
    ///    pbVal = Receives the conditional access broadcaster group identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCABroadcasterGroupId(ubyte* pbVal);
    ///Gets the delay time, in days, before the automatic entitlement management message (EMM) is displayed from a
    ///conditional access (CA) service descriptor.
    ///Params:
    ///    pbVal = Receives the number of days before the EMM message is displayed. A value of 0xFF indicates that the delay
    ///            time is disabled (that the start of the delay time has been put on hold).
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMessageControl(ubyte* pbVal);
    ///Gets the service identifier (ID) records from a conditional access (CA) service descriptor.
    ///Params:
    ///    pbNumServiceIds = On input specifies the expected number of service ID records. On output returns the actual number of records.
    ///    pwServiceIds = Receives the service ID records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceIds(ubyte* pbNumServiceIds, ushort* pwServiceIds);
}

///Implements methods that get data from an Integrated Services Digital Broadcasting (ISDB) hierarchical transmission
///descriptor. The hierarchical transmission descriptor appears as part of the ISDB service information in the program
///map table (PMT) and describes the relationship between hierarchical streams when events are transmitted
///hierarchically.
@GUID("B7B3AE90-EE0B-446D-8769-F7E2AA266AA6")
interface IIsdbHierarchicalTransmissionDescriptor : IUnknown
{
    ///Gets the tag that identifies a hierarchical transmission descriptor.
    ///Params:
    ///    pbVal = Receives the tag value. For hierarchical transmission descriptors, this value is 0xC0.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the body length of an Integrated Services Digital Broadcasting (ISDB) hierarchical transmission descriptor,
    ///in bytes.
    ///Params:
    ///    pbVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ubyte* pbVal);
    ///Gets the value of the 7-bit reserved_future_use field from an Integrated Services Digital Broadcasting (ISDB)
    ///hierarchical transmission descriptor.
    ///Params:
    ///    pbVal = Receives the 7-bit reserved_future_use field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFutureUse1(ubyte* pbVal);
    ///Gets the value of the quality_flag field from an Integrated Services Digital Broadcasting (ISDB) hierarchical
    ///transmission descriptor. This field indicates the quality level of the hierarchical stream construction.
    ///Params:
    ///    pbVal = Receives the quality_flag field value. A value of 1 indicates a high-quality stream; a value of 0 indicates a
    ///            low-quality stream.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetQualityLevel(ubyte* pbVal);
    ///Gets the value of the 3-bit reserved_future_use field from an Integrated Services Digital Broadcasting (ISDB)
    ///hierarchical transmission descriptor.
    ///Params:
    ///    pbVal = Receives the 3-bit reserved_future_use field value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFutureUse2(ubyte* pbVal);
    ///Gets the program ID (PID) of the primary hierarchical stream from a hierarchical transmission descriptor.
    ///Params:
    ///    pwVal = Receives the PID value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetReferencePid(ushort* pwVal);
}

///Implements methods that retrieve program and system information protocol (PSIP) and service information (SI) tables
///from a Protected Broadcast Driver Architecture (PBDA) transport stream.
@GUID("9DE49A74-ABA2-4A18-93E1-21F17F95C3C3")
interface IPBDASiParser : IUnknown
{
    ///Initializes a program and system information protocol (PSIP) parser for a Protected Broadcast Driver Architecture
    ///(PBDA) transport stream.
    ///Params:
    ///    punk = Pointer to the IUnknown interface for the new object.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(IUnknown punk);
    ///Gets the event information table (EIT) from the program and system information protocol (PSIP) tables in a
    ///Protected Broadcast Device Architecture (PBDA) transport stream.
    ///Params:
    ///    dwSize = Reserved. Set to zero.
    ///    pBuffer = Reserved. Set to <b>NULL</b>.
    ///    ppEIT = Receives a pointer to the IPBDA_EIT interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEIT(uint dwSize, ubyte* pBuffer, IPBDA_EIT* ppEIT);
    ///Retrieves a list of services from the program and system information protocol (PSIP) tables in a Protected
    ///Broadcast Device Architecture (PBDA) transport stream.
    ///Params:
    ///    dwSize = Size of the buffer that receives the service list, in bytes.
    ///    pBuffer = Receives the buffer for services.
    ///    ppServices = Receives an IPBDA_Services interface pointer. The caller must release this interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServices(uint dwSize, const(ubyte)* pBuffer, IPBDA_Services* ppServices);
}

///Implements methods that enable the client to get information from an event information table (EIT) in a Protected
///Broadcast Device Architecture (PBDA) transport stream. The IPBDASiParser::GetEIT method returns a pointer to this
///interface. An EIT provides information about events in each service, such as the event name, the start time, and the
///duration. An EIT can hold information about the transport stream that carries it, or it can hold information about
///other transport streams. There are two types of EITs: <ul> <li>Present/Following EITs contain information about the
///current event and the next chronological event. This type of EIT can be used to create a simple UI at the
///receiver.</li> <li>Schedule EITs contain a list of events that occur after the next event. This type of event can be
///used to create an electronic program guide.</li> </ul>EIT sections are given the following table identifiers. <table>
///<tr> <th>Table identifier</th> <th>Description</th> </tr> <tr> <td>0x80</td> <td>Present/Following EIT for this
///transport stream.</td> </tr> <tr> <td>0x81</td> <td>Schedule EIT for this transport stream. </td> </tr> </table>
@GUID("A35F2DEA-098F-4EBD-984C-2BD4C3C8CE0A")
interface IPBDA_EIT : IUnknown
{
    ///Initializes an object that gets data from an event information table (EIT) in a Protected Broadcast Device
    ///Architecture (PBDA) transport stream. This method is called internally by the IPBDASiParser::GetEIT method, so
    ///applications typically should not call it.
    ///Params:
    ///    size = Specifies the buffer size for data used to initialize each section.
    ///    pBuffer = Specifies the buffer used to initialize each section.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(uint size, const(ubyte)* pBuffer);
    ///Gets the table identifier from an event information table (EIT) in a Protected Broadcast Device Architecture
    ///(PBDA) transport stream.
    ///Params:
    ///    pbVal = Receives the table identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTableId(ubyte* pbVal);
    ///Gets the version number from an event information table (EIT) in a Protected Broadcast Device Architecture (PBDA)
    ///transport stream.
    ///Params:
    ///    pwVal = Receives the version number.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVersionNumber(ushort* pwVal);
    ///Gets the service identifier from an event information table (EIT) in a Protected Broadcast Device Architecture
    ///(PBDA) transport stream. The service identifier identifies the service that contains the events.
    ///Params:
    ///    plwVal = Receives the service identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceIdx(ulong* plwVal);
    ///Receives the number of event records from an event information table (EIT) in a Protected Broadcast Device
    ///Architecture (PBDA) transport stream.
    ///Params:
    ///    pdwVal = Receives the number of records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///Receives the unique identifier from an event record in an event information table (EIT) in a Protected Broadcast
    ///Device Architecture (PBDA) transport stream.
    ///Params:
    ///    dwRecordIndex = Specifies the service record number, indexed from zero. Call the IPBDA_EIT::GetCountOfRecords method to get
    ///                    the number of records in the EIT.
    ///    plwVal = Receives the event identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordEventId(uint dwRecordIndex, ulong* plwVal);
    ///Gets the start time from an event record in an event information table (EIT) in a Protected Broadcast Device
    ///Architecture (PBDA) transport stream.
    ///Params:
    ///    dwRecordIndex = Specifies the service record number, indexed from zero. Call the IPBDA_EIT::GetCountOfRecords method to get
    ///                    the number of records in the EIT.
    ///    pmdtVal = Pointer to an MPEG_DATE_AND_TIME structure that receives the start time from the event record.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordStartTime(uint dwRecordIndex, MPEG_DATE_AND_TIME* pmdtVal);
    ///Gets the duration from an event record in an event information table (EIT) in a Protected Broadcast Device
    ///Architecture (PBDA) transport stream.
    ///Params:
    ///    dwRecordIndex = Specifies the service record number, indexed from zero. Call the IPBDA_EIT::GetCountOfRecords method to get
    ///                    the number of records in the EIT.
    ///    pmdVal = Receives the event duration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDuration(uint dwRecordIndex, MPEG_TIME* pmdVal);
    ///Gets the number of event records from an event information table (EIT) in a Protected Broadcast Device
    ///Architecture (PBDA) transport stream.
    ///Params:
    ///    dwRecordIndex = Specifies the service record number, indexed from zero. Call the IPBDA_EIT::GetCountOfRecords method to get
    ///                    the number of records in the EIT.
    ///    pdwVal = Receives the number of descriptors.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordCountOfDescriptors(uint dwRecordIndex, uint* pdwVal);
    ///Retrieves a descriptor for a specified record in an event information table (EIT) in a Protected Broadcast Device
    ///Architecture (PBDA) transport stream.
    ///Params:
    ///    dwRecordIndex = Specifies the service record number, indexed from zero. Call the IPBDA_EIT::GetCountOfRecords method to get
    ///                    the number of records in the EIT.
    ///    dwIndex = Specifies the descriptor to retrieve, indexed from zero. Call the IPBDA_EIT::GetRecordCountOfDescriptors
    ///              method to get the number of descriptors for a particular record.
    ///    ppDescriptor = Address of a variable that receives an IGenericDescriptor interface pointer. Use this interface to retrieve
    ///                   the information in the descriptor. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDescriptorByIndex(uint dwRecordIndex, uint dwIndex, IGenericDescriptor* ppDescriptor);
    ///Searches a record in an event information table (EIT) from a Protected Broadcast Device Architecture (PBDA)
    ///transport stream for a descriptor with a specified descriptor tag.
    ///Params:
    ///    dwRecordIndex = Specifies the service record number, indexed from zero. Call the IPBDA_EIT::GetCountOfRecords method to get
    ///                    the number of records in the EIT.
    ///    bTag = Specifies the descriptor tag for which to search.
    ///    pdwCookie = Pointer to a variable that specifies the start position in the descriptor list. This parameter is optional.
    ///                If the value of *<i>pdwCookie</i> is <b>NULL</b>, the search starts from the first descriptor in the list.
    ///                Otherwise, the search starts from the position given in *<i>pdwCookie</i>. When the method returns, the
    ///                *<i>pdwCookie</i> parameter contains the position of the next matching descriptor, if any. You can use this
    ///                parameter to iterate through the descriptor list, looking for every instance of a particular descriptor tag.
    ///    ppDescriptor = Receives a pointer to the IGenericDescriptor interface. Use this interface to retrieve the information in the
    ///                   descriptor. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordDescriptorByTag(uint dwRecordIndex, ubyte bTag, uint* pdwCookie, 
                                     IGenericDescriptor* ppDescriptor);
}

///Implements methods that initialize or retrieve Protected Broadcast Driver Architecture (PBDA) service records from a
///Program and System Information Protocol (PSIP) table in a Protected Broadcast Device Architecture (PBDA) transport
///stream.
@GUID("944EAB37-EED4-4850-AFD2-77E7EFEB4427")
interface IPBDA_Services : IUnknown
{
    ///Initializes an object that retrieves service records from a Program and System Information Protocol (PSIP) table
    ///in a Protected Broadcast Device Architecture (PBDA) transport stream.
    ///Params:
    ///    size = Specifies the size of the buffer used to initialize the object.
    ///    pBuffer = Pointer to the buffer containing the service data used for initialization.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Initialize(uint size, ubyte* pBuffer);
    ///Gets the number of service records from a Program and System Information Protocol (PSIP) table in a Protected
    ///Broadcast Device Architecture (PBDA) transport stream.
    ///Params:
    ///    pdwVal = Receives the number of service records.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCountOfRecords(uint* pdwVal);
    ///Gets a service record at a given position from a Program and System Information Protocol (PSIP) table in a
    ///Protected Broadcast Device Architecture (PBDA) transport stream.
    ///Params:
    ///    dwRecordIndex = Specifies the service record number, indexed from zero. Call the IPBDA_Services::GetCountOfRecords method to
    ///                    get the number of records in the PSIP table.
    ///    pul64ServiceIdx = Receives the service record at the position given by <i>dwRecordIndex</i>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRecordByIndex(uint dwRecordIndex, ulong* pul64ServiceIdx);
}

///Implements methods that retrieve data from the entitlement descriptor in a Protected Broadcast Driver Architecture
///(PBDA) transport stream.
@GUID("22632497-0DE3-4587-AADC-D8D99017E760")
interface IPBDAEntitlementDescriptor : IUnknown
{
    ///Gets the tag that uniquely identifies an entitlement descriptor in a Protected Broadcast Driver Architecture
    ///(PBDA) transport stream.
    ///Params:
    ///    pbVal = Receives the tag value. For PBDA entitlement descriptors, this value is 0x80.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the length of the entitlement descriptor in a Protected Broadcast Driver Architecture (PBDA) transport
    ///stream, in bytes.
    ///Params:
    ///    pwVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ushort* pwVal);
    ///Gets the entitlement token from the entitlement descriptor in a Protected Broadcast Driver Architecture (PBDA)
    ///transport stream.
    ///Params:
    ///    ppbTokenBuffer = Pointer to a buffer that receives the entitlement token. The caller must free this memory after use.
    ///    pdwTokenLength = Receives the entitlement token length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetToken(ubyte** ppbTokenBuffer, uint* pdwTokenLength);
}

///Implements methods that get data from anattributes descriptor in a Protected Broadcast Device Architecture (PBDA)
///transport stream.
@GUID("313B3620-3263-45A6-9533-968BEFBEAC03")
interface IPBDAAttributesDescriptor : IUnknown
{
    ///Gets the tag that uniquely identifies an attributes descriptor in a Protected Broadcast Driver Architecture
    ///(PBDA) transport stream.
    ///Params:
    ///    pbVal = Gets the tag value. For PBDA attributes descriptors, this value is 0x81.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTag(ubyte* pbVal);
    ///Gets the length of a Protected Broadcast Driver Architecture (PBDA) attributes descriptor from a Protected
    ///Broadcast Device Architecture (PBDA) transport stream, in bytes.
    ///Params:
    ///    pwVal = Receives the descriptor length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ushort* pwVal);
    ///Gets the descriptor body from an attributes descriptor in a Protected Broadcast Device Architecture (PBDA)
    ///transport stream.
    ///Params:
    ///    ppbAttributeBuffer = Pointer to a buffer that receives the descriptor body. The caller must free this memory after use.
    ///    pdwAttributeLength = Receives the descriptor body length.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAttributePayload(ubyte** ppbAttributeBuffer, uint* pdwAttributeLength);
}

///The <b>IBDA_TIF_REGISTRATION</b> interface is exposed by the BDA Network Provider. It enables a Transport Information
///Filter (TIF) to register itself with the Network Provider. This interface supersedes the IMPEG2_TIF_CONTROL
///interface. Applications do not use this interface.
@GUID("DFEF4A68-EE61-415F-9CCB-CD95F2F98A3A")
interface IBDA_TIF_REGISTRATION : IUnknown
{
    ///The <b>RegisterTIFEx</b> method registers a Transport Information Filter (TIF) with the Network Provider.
    ///Params:
    ///    pTIFInputPin = Pointer to the IPin interface of the input pin on the TIF.
    ///    ppvRegistrationContext = Receives a token identifying the connection. Pass this token in the <b>UnregisterTIF</b> method when the TIF
    ///                             unregisters itself.
    ///    ppMpeg2DataControl = Receives a pointer to an <b>IUnknown</b> interface, which the TIF queries for the IMPEG2PIDMap interface. It
    ///                         uses the <b>IMPEG2PIDMap</b> to map and unmap PID values.
    ///Returns:
    ///    The method returns an <b>HRESULT</b> value.
    ///    
    HRESULT RegisterTIFEx(IPin pTIFInputPin, uint* ppvRegistrationContext, IUnknown* ppMpeg2DataControl);
    ///The <b>UnregisterTIF</b> method unregisters a Transport Information Filter (TIF) with the Network Provider.
    ///Params:
    ///    pvRegistrationContext = Specifies the token that the <b>RegisterTIFEx</b> method returned in the <i>ppvRegistrationContext</i>
    ///                            parameter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b> value.
    ///    
    HRESULT UnregisterTIF(uint pvRegistrationContext);
}

///<p class="CCE_Message">[<b>IMPEG2_TIF_CONTROL</b> is no longer available for use. Instead, use the
///IBDA_TIF_REGISTRATION interface to register the TIF with the Network Provider, and use the IMPEG2PIDMap interface to
///map or unmap PIDs.] The <b>IMPEG2_TIF_CONTROL</b> interface is implemented by the BDA Network Provider. A Transport
///Information Filter (TIF) can use this interface to register itself and request table sections carried on specific
///PIDs within the transport stream. The Network Provider Filter instructs the MPEG-2 Demultiplexer (Demux) to send or
///stop sending the specified packets to the TIF's input pin. All sections are delivered by the Demux to the TIF as
///complete MPEG-2 table sections.
@GUID("F9BAC2F9-4149-4916-B2EF-FAA202326862")
interface IMPEG2_TIF_CONTROL : IUnknown
{
    ///The <b>RegisterTIF</b> method is called by the Transport Information Filter (TIF) to register itself with the
    ///Network Provider.
    ///Params:
    ///    pUnkTIF = Pointer to the TIF's <b>IUnknown</b> interface.
    ///    ppvRegistrationContext = Pointer to a variable that receives an identifier. Use this value as the parameter to the
    ///                             IMPEG2_TIF_CONTROL::UnregisterTIF method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> Could not find a necessary interface on the TIF.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_ALREADY_CONNECTED</b></dt> </dl> </td> <td width="60%"> A
    ///    TIF is already registered with the Network Provider. </td> </tr> </table>
    ///    
    HRESULT RegisterTIF(IUnknown pUnkTIF, uint* ppvRegistrationContext);
    ///The <b>UnregisterTIF</b> method unregisters the TIF with the Network Provider.
    ///Params:
    ///    pvRegistrationContext = Identifier returned by the IMPEG2_TIF_CONTROL::RegisterTIF method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT UnregisterTIF(uint pvRegistrationContext);
    ///The <b>AddPIDs</b> method tells the Network Provider which PIDs the TIF should receive.
    ///Params:
    ///    ulcPIDs = Specifies the number of PIDs to add. This value must be equal to the number of elements in the array
    ///              specified by <i>pulPIDs</i>.
    ///    pulPIDs = Specifies an array of PID values to add. The array must contain <i>ulcPIDs</i> elements.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddPIDs(uint ulcPIDs, uint* pulPIDs);
    ///The <b>DeletePIDs</b> method informs the Network Provider that the TIF no longer requires the specified PID.
    ///Params:
    ///    ulcPIDs = Specifies the number of PIDs to delete. This value must equal the number of elements in the array specified
    ///              by <i>pulPIDs</i>.
    ///    pulPIDs = Specifies an array of PID values containing <i>ulcPIDs</i> elements.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT DeletePIDs(uint ulcPIDs, uint* pulPIDs);
    ///The <b>GetPIDCount</b> method retrieves the number of MPEG-2 Packet IDs being filtered by the MPEG-2
    ///Demultiplexer into the TIF's input data.
    ///Params:
    ///    pulcPIDs = Pointer to a variable that receives the number of PIDs currently being filtered to the Demux.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetPIDCount(uint* pulcPIDs);
    ///The <b>GetPIDs</b> method retrieves the list of MPEG-2 Packet IDs being filtered into the TIF's input data.
    ///Params:
    ///    pulcPIDs = Pointer to a variable that receives the number of PIDs that were retrieved.
    ///    pulPIDs = Pointer to a variable that receives an array of returned <b>ULONG</b> values representing the PID values. The
    ///              number of elements in the array is equal to the value of <i>pulcPIDs</i>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetPIDs(uint* pulcPIDs, uint* pulPIDs);
}

///The <b>ITuneRequestInfo</b> interface is implemented on the BDA MPEG2 Transport Information Filter (TIF) and is used
///by the Network Provider. When the Network Provider receives a tune request, it is not guaranteed that all the
///necessary locator information will be present in the locator object associated with the tune request. If information
///is missing, the Network Provider uses this interface to instruct the TIF to fill in the locator data. Similarly, a
///tune request might not contain a complete list of all the components (substreams) available on the service at a given
///time. After the Network Provider has tuned to a service, it can ask the TIF to fill in the component information
///associated with the tune request. An application can then re-examine the tune request after it has been submitted,
///and compare it to the list of default preferred component types to determine whether to tune to a particular audio
///stream, or inform the user of any substreams that were not mentioned in the EPG data. For more information, see
///ITuningSpace::get_DefaultPreferredComponentTypes. If the TIF is not able to provide the locator data for the
///transport stream, it must provide the default locator for the tuning space associated with the tune request.
@GUID("A3B152DF-7A90-4218-AC54-9830BEE8C0B6")
interface ITuneRequestInfo : IUnknown
{
    ///The <b>GetLocatorData</b> method fills in channel or program locator information for the specified tune request.
    ///Params:
    ///    Request = Pointer to the ITuneRequest interface on the tune request.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded and new locator data was acquired. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The method succeeded but no new locator data was
    ///    acquired. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    <i>Request</i> is not valid. </td> </tr> </table>
    ///    
    HRESULT GetLocatorData(ITuneRequest Request);
    ///The <b>GetComponentData</b> method fills in all network-specific component data for the existing Components
    ///collection on the specified tune request.
    ///Params:
    ///    CurrentRequest = Pointer to the ITuneRequest interface on the tune request.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded and new data was added. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The method succeeded but no new data was added. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetComponentData(ITuneRequest CurrentRequest);
    ///The <b>CreateComponentList</b> method creates a new Components collection for the tune request, and fills it in
    ///with all network-specific data after the receiver has tuned to the service.
    ///Params:
    ///    CurrentRequest = Pointer to the ITuneRequest interface on the tune request.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded and new data was added. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The method succeeded but no new data was added. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> No data could be
    ///    acquired. </td> </tr> </table>
    ///    
    HRESULT CreateComponentList(ITuneRequest CurrentRequest);
    ///The <b>GetNextProgram</b> method creates a new tune request with channel or program locator information for the
    ///next service.
    ///Params:
    ///    CurrentRequest = Specifies the ITuneRequest interface of the current request.
    ///    TuneRequest = Pointer to a variable that will receive a tune request for the next service on the transport stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>CurrentRequest</i> is not valid, or <i>TuneRequest</i> is <b>NULL</b>. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetNextProgram(ITuneRequest CurrentRequest, ITuneRequest* TuneRequest);
    ///The <b>GetPreviousProgram</b> method creates a new tune request with channel or program locator information for
    ///the previous service.
    ///Params:
    ///    CurrentRequest = Specifies the current request.
    ///    TuneRequest = Pointer to a variable that receives a tune request for the previous service in the current transport stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>CurrentRequest</i> is not valid, or <i>TuneRequest</i> is <b>NULL</b>. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetPreviousProgram(ITuneRequest CurrentRequest, ITuneRequest* TuneRequest);
    ///The <b>GetNextLocator</b> method creates a new tune request with locator information for the next transport
    ///stream on the network.
    ///Params:
    ///    CurrentRequest = Specifies the ITuneRequest interface of the current tune request. <b>NULL</b> means to return information for
    ///                     the first stream.
    ///    TuneRequest = Pointer to a variable that receives a tune request for the next transport stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>CurrentRequest</i> is not valid, or <i>TuneRequest</i> is <b>NULL</b>. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetNextLocator(ITuneRequest CurrentRequest, ITuneRequest* TuneRequest);
    ///The <b>GetPreviousLocator</b> method creates a new tune request with locator information for the previous
    ///transport stream.
    ///Params:
    ///    CurrentRequest = Specifies current request.
    ///    TuneRequest = Pointer to a variable that receives the tune request for the previous transport stream in the network.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <i>CurrentRequest</i> is not valid, or <i>TuneRequest</i> is <b>NULL</b>. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetPreviousLocator(ITuneRequest CurrentRequest, ITuneRequest* TuneRequest);
}

@GUID("EE957C52-B0D0-4E78-8DD1-B87A08BFD893")
interface ITuneRequestInfoEx : ITuneRequestInfo
{
    HRESULT CreateComponentListEx(ITuneRequest CurrentRequest, IUnknown* ppCurPMT);
}

@GUID("7E47913A-5A89-423D-9A2B-E15168858934")
interface ISIInbandEPGEvent : IUnknown
{
    HRESULT SIObjectEvent(IDVB_EIT2 pIDVB_EIT, uint dwTable_ID, uint dwService_ID);
}

@GUID("F90AD9D0-B854-4B68-9CC1-B2CC96119D85")
interface ISIInbandEPG : IUnknown
{
    HRESULT StartSIEPGScan();
    HRESULT StopSIEPGScan();
    HRESULT IsSIEPGScanRunning(int* bRunning);
}

///The <b>IGuideDataEvent</b> interface is used to receive events from the BDA MPEG-2 Transport Information Filter
///(TIF). This interface is an outgoing connection-point interface. To receive events from a playback device, implement
///this interface and then call the <b>IConnectionPoint::Advise</b> method to establish a connection. The event sink
///must not block the calling thread. If the client requires additional information about the event, it should make
///calls on a separate thread.
@GUID("EFDA0C80-F395-42C3-9B3C-56B37DEC7BB7")
interface IGuideDataEvent : IUnknown
{
    ///The <b>GuideDataAcquired</b> method is called when a complete set of guide data has been acquired from the
    ///current transport stream. Currently the BDA MPEG-2 Transport Information Filter (TIF) does not support this
    ///event, so this method is not called.
    ///Returns:
    ///    Return S_OK if successful, or an error code.
    ///    
    HRESULT GuideDataAcquired();
    ///The <b>ProgramChanged</b> method is called when information about one or more programs has changed.
    ///Params:
    ///    varProgramDescriptionID = Specifies the unique identifier of the program that has changed. Call IGuideData::GetProgramProperties to get
    ///                              information about the program. The value of this parameter may be an empty <b>VARIANT</b> type (VT_EMPTY); if
    ///                              so, examine all of the programs to determine which ones have changed.
    ///Returns:
    ///    Return S_OK if successful, or an error code.
    ///    
    HRESULT ProgramChanged(VARIANT varProgramDescriptionID);
    ///The <b>ServiceChanged</b> method is called when a service has been changed.
    ///Params:
    ///    varServiceDescriptionID = Specifies the unique identifier of the service that has changed.
    ///Returns:
    ///    Return S_OK if successful, or an error code.
    ///    
    HRESULT ServiceChanged(VARIANT varServiceDescriptionID);
    ///The <b>ScheduleEntryChanged</b> method is called by the TIF when information about one or more schedule entries
    ///has changed.
    ///Params:
    ///    varScheduleEntryDescriptionID = Specifies the unique identifier of the program that has changed. Call IGuideData::GetScheduleEntryProperties
    ///                                    to get information about the program. The value of this parameter may be an empty <b>VARIANT</b> type
    ///                                    (VT_EMPTY); if so, examine all of the programs to determine which ones have changed.
    ///Returns:
    ///    Return S_OK if successful, or an error code.
    ///    
    HRESULT ScheduleEntryChanged(VARIANT varScheduleEntryDescriptionID);
    ///The <b>ProgramDeleted</b> method is called when a program has been deleted. Currently the BDA MPEG-2 Transport
    ///Information Filter (TIF) does not support this event, so this method is not called.
    ///Params:
    ///    varProgramDescriptionID = Specifies the unique identifier of the program that was deleted.
    ///Returns:
    ///    Return S_OK if successful, or an error code.
    ///    
    HRESULT ProgramDeleted(VARIANT varProgramDescriptionID);
    ///The <b>ServiceDeleted</b> method is called when a service has been deleted. Currently the BDA MPEG-2 Transport
    ///Information Filter (TIF) does not support this event, so this method is not called.
    ///Params:
    ///    varServiceDescriptionID = Specifies the unique identifier of the service that was deleted.
    ///Returns:
    ///    Return S_OK if successful, or an error code.
    ///    
    HRESULT ServiceDeleted(VARIANT varServiceDescriptionID);
    ///The <b>ScheduleDeleted</b> method is called when a schedule entry has been deleted. Currently the BDA MPEG-2
    ///Transport Information Filter (TIF) does not support this event, so this method is not called.
    ///Params:
    ///    varScheduleEntryDescriptionID = Specifies the unique identifier of the schedule entry that was deleted.
    ///Returns:
    ///    Return S_OK if successful, or an error code.
    ///    
    HRESULT ScheduleDeleted(VARIANT varScheduleEntryDescriptionID);
}

///The <b>IGuideDataProperty</b> interface represents the name, value, and language of a property associated with a
///service, program or schedule entry object.
@GUID("88EC5E58-BB73-41D6-99CE-66C524B8B591")
interface IGuideDataProperty : IUnknown
{
    ///The <b>get_Name</b> method retrieves the name of the property.
    ///Params:
    ///    pbstrName = Pointer to a variable that receives a string containing the property name, for example "Description.ID" or
    ///                "Description.Title".
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_Name(BSTR* pbstrName);
    ///The <b>get_Language</b> method retrieves the language associated with the property.
    ///Params:
    ///    idLang = Pointer to a variable that receives the language identifier.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_Language(int* idLang);
    ///The <b>get_Value</b> method retrieves the value associated with the property.
    ///Params:
    ///    pvar = Pointer to a variable that receives the value of the property as a <b>VARIANT</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT get_Value(VARIANT* pvar);
}

///The <b>IEnumGuideDataProperties</b> interface represents a collection of guide data properties that has been
///generated by the TIF. Separate collections are created for programs, services, and schedule entries. This interface
///is obtained from the TIF using the following methods. <ul> <li> IGuideData::GetProgramProperties.</li> <li>
///IGuideData::GetScheduleEntryProperties </li> <li> IGuideData::GetServiceProperties </li> </ul>
@GUID("AE44423B-4571-475C-AD2C-F40A771D80EF")
interface IEnumGuideDataProperties : IUnknown
{
    ///The <b>Next</b> method retrieves the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = Specifies the number of items to retrieve.
    ///    ppprop = Address of an array of size <i>celt</i>, allocated by the caller. The array is filled with IGuideDataProperty
    ///             interface pointers.
    ///    pcelt = Receives the number of items received.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The collection is at the end of the enumeration sequence. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr>
    ///    </table>
    ///    
    HRESULT Next(uint celt, IGuideDataProperty* ppprop, uint* pcelt);
    ///Not implemented for this release. The <b>Skip</b> method skips over a specified number of items in the
    ///collection.
    ///Params:
    ///    celt = Specifies the number of items to skip.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Reset</b> method resets the enumerator to the first item in the collection.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///Not implemented for this release. The <b>Clone</b> method creates a copy of the collection.
    ///Params:
    ///    ppenum = Receives a pointer to the new collection's <b>IEnumGuideDataProperties</b> interface.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT Clone(IEnumGuideDataProperties* ppenum);
}

///The <b>IEnumTuneRequests</b> interface provides access to a collection of tune requests returned from a call to
///IGuideData::GetServices. This collection of tune requests represents all the services available in the tuning space.
@GUID("1993299C-CED6-4788-87A3-420067DCE0C7")
interface IEnumTuneRequests : IUnknown
{
    ///The <b>Next</b> method retrieves the specified number of items in the collection.
    ///Params:
    ///    celt = Specifies the number of items to retrieve.
    ///    ppprop = Array of size <i>celt</i> that is filled with ITuneRequest interface pointers.
    ///    pcelt = Receives the number of items retrieved.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The collection is at the end of the enumeration sequence. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, ITuneRequest* ppprop, uint* pcelt);
    ///The <b>Skip</b> method skips over the specified number of items in the collection.
    ///Params:
    ///    celt = Specifies the number of items to skip.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Reset</b> method sets the enumerator to the first item in the collection.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Clone</b> method creates a copy of the collection.
    ///Params:
    ///    ppenum = Receives the new collection.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumTuneRequests* ppenum);
}

///The <b>IGuideData</b> interface is exposed by the BDA MPEG-2 Transport Information Filter (TIF). It enables the
///client to get service information from the MPEG-2 transport stream. Use this interface if you are writing a guide
///store loader.
@GUID("61571138-5B01-43CD-AEAF-60B784A0BF93")
interface IGuideData : IUnknown
{
    ///The <b>GetServices</b> method retrieves a collection of tune requests representing all the services available in
    ///the tuning space.
    ///Params:
    ///    ppEnumTuneRequests = Pointer to a variable that receives an IEnumTuneRequests interface pointer. Use this interface to enumerate
    ///                         the properties. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetServices(IEnumTuneRequests* ppEnumTuneRequests);
    ///The <b>GetServiceProperties</b> method retrieves the properties for a specified service.
    ///Params:
    ///    pTuneRequest = Pointer to the ITuneRequest interface of a valid tune request. Call the IGuideData::GetServices method to get
    ///                   a list of tune requests.
    ///    ppEnumProperties = Pointer to a variable that receives an IEnumGuideDataProperties interface pointer. Use this interface to
    ///                       enumerate the properties. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetServiceProperties(ITuneRequest pTuneRequest, IEnumGuideDataProperties* ppEnumProperties);
    ///The <b>GetGuideProgramIDs</b> method returns a list of unique identifiers for all of the programs contained in
    ///all transport streams.
    ///Params:
    ///    pEnumPrograms = Receives a pointer to the <b>IEnumVARIANT</b> interface. Use this interface to enumerate the collection. The
    ///                    caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetGuideProgramIDs(IEnumVARIANT* pEnumPrograms);
    ///The <b>GetProgramProperties</b> method retrieves the properties for a specified program.
    ///Params:
    ///    varProgramDescriptionID = Specifies the unique identifier for the program. Call the IGuideData::GetGuideProgramIDs method to get a list
    ///                              of program identifiers.
    ///    ppEnumProperties = Pointer to a variable that receives an IEnumGuideDataProperties interface pointer. Use this interface to
    ///                       enumerate the properties. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProgramProperties(VARIANT varProgramDescriptionID, IEnumGuideDataProperties* ppEnumProperties);
    ///The <b>GetScheduleEntryIDs</b> method returns a list of unique identifiers for all of the schedule entries
    ///contained in all transport streams.
    ///Params:
    ///    pEnumScheduleEntries = Receives a pointer to the <b>IEnumVARIANT</b> interface. Use this interface to enumerate the collection. The
    ///                           caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetScheduleEntryIDs(IEnumVARIANT* pEnumScheduleEntries);
    ///The <b>GetScheduleEntryProperties</b> method retrieves the properties for a specified schedule entry.
    ///Params:
    ///    varScheduleEntryDescriptionID = Specifies the unique identifier for the schedule entry. Call the IGuideData::GetScheduleEntryIDs method to
    ///                                    get a list of schedule entry identifiers.
    ///    ppEnumProperties = Pointer to a variable that receives an IEnumGuideDataProperties interface pointer. Use this interface to
    ///                       enumerate the properties. The caller must release the interface
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetScheduleEntryProperties(VARIANT varScheduleEntryDescriptionID, 
                                       IEnumGuideDataProperties* ppEnumProperties);
}

@GUID("4764FF7C-FA95-4525-AF4D-D32236DB9E38")
interface IGuideDataLoader : IUnknown
{
    HRESULT Init(IGuideData pGuideStore);
    HRESULT Terminate();
}

///The <code>IMediaBuffer</code> interface provides methods for manipulating a data buffer. Buffers passed to the
///<b>IMediaObject::ProcessInput</b> and <b>ProcessOutput</b> methods must implement this interface.
@GUID("59EFF8B9-938C-4A26-82F2-95CB84CDC837")
interface IMediaBuffer : IUnknown
{
    ///The <code>SetLength</code> method specifies the length of the data currently in the buffer.
    ///Params:
    ///    cbLength = Size of the data, in bytes. The value must not exceed the buffer's maximum size. Call the
    ///               IMediaBuffer::GetMaxLength method to obtain the maximum size.
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT SetLength(uint cbLength);
    ///The <code>GetMaxLength</code> method retrieves the maximum number of bytes this buffer can hold.
    ///Params:
    ///    pcbMaxLength = Pointer to a variable that receives the buffer's maximum size, in bytes.
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT GetMaxLength(uint* pcbMaxLength);
    ///The <code>GetBufferAndLength</code> method retrieves the buffer and the size of the valid data in the buffer.
    ///Params:
    ///    ppBuffer = Address of a pointer that receives the buffer array. Can be <b>NULL</b> if <i>pcbLength</i> is not
    ///               <b>NULL</b>.
    ///    pcbLength = Pointer to a variable that receives the size of the valid data, in bytes. Can be <b>NULL</b> if
    ///                <i>ppBuffer</i> is not <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetBufferAndLength(ubyte** ppBuffer, uint* pcbLength);
}

///The <code>IMediaObject</code> interface provides methods for manipulating a Microsoft DirectX Media Object (DMO).
@GUID("D8AD0F58-5494-4102-97C5-EC798E59BCF4")
interface IMediaObject : IUnknown
{
    ///The <code>GetStreamCount</code> method retrieves the number of input and output streams.
    ///Params:
    ///    pcInputStreams = Pointer to a variable that receives the number of input streams. Cannot be <b>NULL</b>.
    ///    pcOutputStreams = Pointer to a variable that receives the number of output streams. Cannot be <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetStreamCount(uint* pcInputStreams, uint* pcOutputStreams);
    ///The <code>GetInputStreamInfo</code> method retrieves information about an input stream, such as any restrictions
    ///on the number of samples per buffer, and whether the stream performs lookahead on the input data. This
    ///information never changes.
    ///Params:
    ///    dwInputStreamIndex = Zero-based index of an input stream on the DMO.
    ///    pdwFlags = Pointer to a variable that receives a bitwise combination of zero or more DMO_INPUT_STREAM_INFO_FLAGS flags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr>
    ///    </table>
    ///    
    HRESULT GetInputStreamInfo(uint dwInputStreamIndex, uint* pdwFlags);
    ///The <code>GetOutputStreamInfo</code> method retrieves information about an output stream; for example, whether
    ///the stream is discardable, and whether it uses a fixed sample size. This information never changes.
    ///Params:
    ///    dwOutputStreamIndex = Zero-based index of an output stream on the DMO.
    ///    pdwFlags = Pointer to a variable that receives a bitwise combination of zero or more DMO_OUTPUT_STREAM_INFO_FLAGS flags.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr>
    ///    </table>
    ///    
    HRESULT GetOutputStreamInfo(uint dwOutputStreamIndex, uint* pdwFlags);
    ///The <code>GetInputType</code> method retrieves a preferred media type for a specified input stream.
    ///Params:
    ///    dwInputStreamIndex = Zero-based index of an input stream on the DMO.
    ///    dwTypeIndex = Zero-based index on the set of acceptable media types.
    ///    pmt = Pointer to a DMO_MEDIA_TYPE structure allocated by the caller, or <b>NULL</b>. If this parameter is
    ///          non-<b>NULL</b>, the method fills the structure with the media type. You can use the value <b>NULL</b> to
    ///          test whether the type index is in range, by checking the return code.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>DMO_E_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> Type index is out of
    ///    range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetInputType(uint dwInputStreamIndex, uint dwTypeIndex, DMO_MEDIA_TYPE* pmt);
    ///The <code>GetOutputType</code> method retrieves a preferred media type for a specified output stream.
    ///Params:
    ///    dwOutputStreamIndex = Zero-based index of an output stream on the DMO.
    ///    dwTypeIndex = Zero-based index on the set of acceptable media types.
    ///    pmt = Pointer to a DMO_MEDIA_TYPE structure allocated by the caller, or <b>NULL</b>. If this parameter is
    ///          non-<b>NULL</b>, the method fills the structure with the media type. You can use the value <b>NULL</b> to
    ///          test whether the type index is in range, by checking the return code.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>DMO_E_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> Type index is out of
    ///    range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success. </td> </tr> </table>
    ///    
    HRESULT GetOutputType(uint dwOutputStreamIndex, uint dwTypeIndex, DMO_MEDIA_TYPE* pmt);
    ///The <code>SetInputType</code> method sets the media type on an input stream, or tests whether a media type is
    ///acceptable.
    ///Params:
    ///    dwInputStreamIndex = Zero-based index of an input stream on the DMO.
    ///    pmt = Pointer to a DMO_MEDIA_TYPE structure that specifies the media type.
    ///    dwFlags = Bitwise combination of zero or more flags from the DMO_SET_TYPE_FLAGS enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>DMO_E_TYPE_NOT_ACCEPTED</b></dt> </dl> </td> <td width="60%"> Media type was not
    ///    accepted </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Media
    ///    type is not acceptable </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Media type was set successfully, or is acceptable </td> </tr> </table>
    ///    
    HRESULT SetInputType(uint dwInputStreamIndex, const(DMO_MEDIA_TYPE)* pmt, uint dwFlags);
    ///The <code>SetOutputType</code> method sets the media type on an output stream, or tests whether a media type is
    ///acceptable.
    ///Params:
    ///    dwOutputStreamIndex = Zero-based index of an output stream on the DMO.
    ///    pmt = Pointer to a DMO_MEDIA_TYPE structure that specifies the media type.
    ///    dwFlags = Bitwise combination of zero or more flags from the DMO_SET_TYPE_FLAGS enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>DMO_E_TYPE_NOT_ACCEPTED</b></dt> </dl> </td> <td width="60%"> Media type was not
    ///    accepted </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Media
    ///    type is not acceptable </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Media type was set successfully, or is acceptable </td> </tr> </table>
    ///    
    HRESULT SetOutputType(uint dwOutputStreamIndex, const(DMO_MEDIA_TYPE)* pmt, uint dwFlags);
    ///The <code>GetInputCurrentType</code> method retrieves the media type that was set for an input stream, if any.
    ///Params:
    ///    dwInputStreamIndex = Zero-based index of an input stream on the DMO.
    ///    pmt = Pointer to a DMO_MEDIA_TYPE structure allocated by the caller. The method fills the structure with the media
    ///          type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>DMO_E_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> Media type was not set.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT GetInputCurrentType(uint dwInputStreamIndex, DMO_MEDIA_TYPE* pmt);
    ///The <code>GetOutputCurrentType</code> method retrieves the media type that was set for an output stream, if any.
    ///Params:
    ///    dwOutputStreamIndex = Zero-based index of an output stream on the DMO.
    ///    pmt = Pointer to a DMO_MEDIA_TYPE structure allocated by the caller. The method fills the structure with the media
    ///          type.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>DMO_E_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> Media type was not set.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT GetOutputCurrentType(uint dwOutputStreamIndex, DMO_MEDIA_TYPE* pmt);
    ///The <code>GetInputSizeInfo</code> method retrieves the buffer requirements for a specified input stream.
    ///Params:
    ///    dwInputStreamIndex = Zero-based index of an input stream on the DMO.
    ///    pcbSize = Pointer to a variable that receives the minimum size of an input buffer for this stream, in bytes.
    ///    pcbMaxLookahead = Pointer to a variable that receives the maximum amount of data that the DMO will hold for lookahead, in
    ///                      bytes. If the DMO does not perform lookahead on the stream, the value is zero.
    ///    pcbAlignment = Pointer to a variable that receives the required buffer alignment, in bytes. If the input stream has no
    ///                   alignment requirement, the value is 1.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>DMO_E_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> Media type was not set.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetInputSizeInfo(uint dwInputStreamIndex, uint* pcbSize, uint* pcbMaxLookahead, uint* pcbAlignment);
    ///The <code>GetOutputSizeInfo</code> method retrieves the buffer requirements for a specified output stream.
    ///Params:
    ///    dwOutputStreamIndex = Zero-based index of an output stream on the DMO.
    ///    pcbSize = Pointer to a variable that receives the minimum size of an output buffer for this stream, in bytes.
    ///    pcbAlignment = Pointer to a variable that receives the required buffer alignment, in bytes. If the output stream has no
    ///                   alignment requirement, the value is 1.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>DMO_E_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> Media type was not set.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetOutputSizeInfo(uint dwOutputStreamIndex, uint* pcbSize, uint* pcbAlignment);
    ///The <code>GetInputMaxLatency</code> method retrieves the maximum latency on a specified input stream.
    ///Params:
    ///    dwInputStreamIndex = Zero-based index of an input stream on the DMO.
    ///    prtMaxLatency = Pointer to a variable that receives the maximum latency.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. Assume zero
    ///    latency. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetInputMaxLatency(uint dwInputStreamIndex, long* prtMaxLatency);
    ///The <code>SetInputMaxLatency</code> method sets the maximum latency on a specified input stream. For the
    ///definition of maximum latency, see IMediaObject::GetInputMaxLatency.
    ///Params:
    ///    dwInputStreamIndex = Zero-based index of an input stream on the DMO.
    ///    rtMaxLatency = Maximum latency.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Failure </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT SetInputMaxLatency(uint dwInputStreamIndex, long rtMaxLatency);
    ///The <code>Flush</code> method flushes all internally buffered data.
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT Flush();
    ///The <code>Discontinuity</code> method signals a discontinuity on the specified input stream.
    ///Params:
    ///    dwInputStreamIndex = Zero-based index of an input stream on the DMO.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>DMO_E_NOTACCEPTING</b></dt> </dl> </td> <td width="60%"> The DMO is not
    ///    accepting input. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DMO_E_TYPE_NOT_SET</b></dt> </dl> </td> <td
    ///    width="60%"> The input and output types have not been set. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT Discontinuity(uint dwInputStreamIndex);
    ///The <code>AllocateStreamingResources</code> method allocates any resources needed by the DMO. Calling this method
    ///is always optional.
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT AllocateStreamingResources();
    ///The <code>FreeStreamingResources</code> method frees resources allocated by the DMO. Calling this method is
    ///always optional.
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT FreeStreamingResources();
    ///The <code>GetInputStatus</code> method queries whether an input stream can accept more input data.
    ///Params:
    ///    dwInputStreamIndex = Zero-based index of an input stream on the DMO.
    ///    dwFlags = Pointer to a variable that receives either zero or DMO_INPUT_STATUSF_ACCEPT_DATA.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetInputStatus(uint dwInputStreamIndex, uint* dwFlags);
    ///The <code>ProcessInput</code> method delivers a buffer to the specified input stream.
    ///Params:
    ///    dwInputStreamIndex = Zero-based index of an input stream on the DMO.
    ///    pBuffer = Pointer to the buffer's IMediaBuffer interface.
    ///    dwFlags = Bitwise combination of zero or more flags from the DMO_INPUT_DATA_BUFFER_FLAGS enumeration.
    ///    rtTimestamp = Time stamp that specifies the start time of the data in the buffer. If the buffer has a valid time stamp, set
    ///                  the DMO_INPUT_DATA_BUFFERF_TIME flag in the <i>dwFlags</i> parameter. Otherwise, the DMO ignores this value.
    ///    rtTimelength = Reference time specifying the duration of the data in the buffer. If this value is valid, set the
    ///                   DMO_INPUT_DATA_BUFFERF_TIMELENGTH flag in the <i>dwFlags</i> parameter. Otherwise, the DMO ignores this
    ///                   value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>DMO_E_NOTACCEPTING</b></dt> </dl> </td> <td width="60%"> Data cannot be
    ///    accepted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No
    ///    output to process. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> </table>
    ///    
    HRESULT ProcessInput(uint dwInputStreamIndex, IMediaBuffer pBuffer, uint dwFlags, long rtTimestamp, 
                         long rtTimelength);
    ///The <code>ProcessOutput</code> method generates output from the current input data.
    ///Params:
    ///    dwFlags = Bitwise combination of zero or more flags from the DMO_PROCESS_OUTPUT_FLAGS enumeration.
    ///    cOutputBufferCount = Number of output buffers.
    ///    pOutputBuffers = Pointer to an array of DMO_OUTPUT_DATA_BUFFER structures containing the output buffers. Specify the size of
    ///                     the array in the <i>cOutputBufferCount</i> parameter.
    ///    pdwStatus = Pointer to a variable that receives a reserved value (zero). The application should ignore this value.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> Failure </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> <b>NULL</b> pointer argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt>
    ///    </dl> </td> <td width="60%"> No output was generated </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT ProcessOutput(uint dwFlags, uint cOutputBufferCount, char* pOutputBuffers, uint* pdwStatus);
    ///The <code>Lock</code> method acquires or releases a lock on the DMO. Call this method to keep the DMO serialized
    ///when performing multiple operations.
    ///Params:
    ///    bLock = Value that specifies whether to acquire or release the lock. If the value is non-zero, a lock is acquired. If
    ///            the value is zero, the lock is released.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> Failure </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT Lock(int bLock);
}

///The <code>IEnumDMO</code> interface provides methods for enumerating Microsoft DirectX Media Objects (DMOs). It is
///based on the OLE enumeration interfaces. For more information, see the <i>IEnumXXXX</i> topic in the Platform SDK. To
///enumerate registered DMOs, call the DMOEnum function.
@GUID("2C3CD98A-2BFA-4A53-9C27-5249BA64BA0F")
interface IEnumDMO : IUnknown
{
    ///The <code>Next</code> method retrieves a specified number of items in the enumeration sequence.
    ///Params:
    ///    cItemsToFetch = Number of items to retrieve.
    ///    pCLSID = Array of size <i>cItemsToFetch</i> that is filled with the CLSIDs of the enumerated DMOs.
    ///    Names = Array of size <i>cItemsToFetch</i> that is filled with the friendly names of the enumerated DMOs.
    ///    pcItemsFetched = Pointer to a variable that receives the actual number of items retrieved. Can be <b>NULL</b> if
    ///                     <i>cItemsToFetch</i> equals 1.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Retrieved fewer items than requested.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Retrieved the
    ///    requested number of items. </td> </tr> </table>
    ///    
    HRESULT Next(uint cItemsToFetch, char* pCLSID, char* Names, uint* pcItemsFetched);
    ///The <code>Skip</code> method skips over a specified number of items in the enumeration sequence.
    ///Params:
    ///    cItemsToSkip = Number of items to skip.
    ///Returns:
    ///    Returns S_OK if the number items skipped equals <i>cItemsToSkip</i>. Otherwise, returns S_FALSE.
    ///    
    HRESULT Skip(uint cItemsToSkip);
    ///The <code>Reset</code> method resets the enumeration sequence to the beginning.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT Reset();
    ///This method is not implemented.
    ///Params:
    ///    ppEnum = Reserved.
    ///Returns:
    ///    Returns E_NOTIMPL.
    ///    
    HRESULT Clone(IEnumDMO* ppEnum);
}

///The <code>IMediaObjectInPlace</code> interface provides methods for processing data in place. A Microsoft DirectX
///Media Object (DMO) can expose this interface if it meets the following conditions: <ul> <li>It has one input stream
///and one output stream.</li> <li>Both streams use the same media type.</li> <li>The output is produced in place on the
///buffer; that is, without copying data.</li> </ul>This interface provides an optimized way to process data. The
///application calls a single IMediaObjectInPlace::Process method instead of the IMediaObject::ProcessInput and
///IMediaObject::ProcessOutput methods. However, any DMO that implements this interface must also implement the
///IMediaObject interface. Therefore, an application is never obligated to use this interface, and a DMO is never
///guaranteed to implement it.
@GUID("651B9AD0-0FC7-4AA9-9538-D89931010741")
interface IMediaObjectInPlace : IUnknown
{
    ///The <code>Process</code> method processes a block of data. The application supplies a pointer to a block of input
    ///data. The DMO processes the data in place.
    ///Params:
    ///    ulSize = Size of the data, in bytes.
    ///    pData = Pointer to a buffer of size <i>ulSize</i>. On input, the buffer holds the input data. If the method returns
    ///            successfully, the buffer contains the output data.
    ///    refTimeStart = Start time of the data.
    ///    dwFlags = Either DMO_INPLACE_NORMAL or DMO_INPLACE_ZERO. See Remarks for more information.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> Failure </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> Success. There is still data to process. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. There is no remaining data to process. </td> </tr>
    ///    </table>
    ///    
    HRESULT Process(uint ulSize, char* pData, long refTimeStart, uint dwFlags);
    ///The <code>Clone</code> method creates a copy of the DMO in its current state.
    ///Params:
    ///    ppMediaObject = Address of a pointer to receive the new DMO's IMediaObjectInPlace interface.
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT Clone(IMediaObjectInPlace* ppMediaObject);
    ///The <code>GetLatency</code> method retrieves the latency introduced by this DMO.
    ///Params:
    ///    pLatencyTime = Pointer to a variable that receives the latency, in 100-nanosecond units.
    ///Returns:
    ///    Returns S_OK if successful. Otherwise, returns an <b>HRESULT</b> value indicating the cause of the error.
    ///    
    HRESULT GetLatency(long* pLatencyTime);
}

///The <code>IDMOQualityControl</code> interface supports quality control on a Microsoft DirectX Media Object (DMO). A
///DMO exposes this interface if it can respond to late samples. When quality control is enabled, the DMO attempts to
///process samples on time, discarding late samples if necessary. When quality control is disabled, the DMO processes
///every sample. By default, quality control is disabled. Applications use this interface to enable or disable quality
///control. Using quality control is appropriate when you are viewing media data in real time. If you are capturing data
///to a file, do not enable quality control, because the DMO might discard samples. It does not matter in file capture
///whether samples arrive late, and you do not want to lose the data. To use quality control, perform the following
///steps: <ol> <li>Call the IDMOQualityControl::SetNow method with the reference time of the earliest sample to be
///processed.</li> <li>Call the IDMOQualityControl::SetStatus method with the DMO_QUALITY_STATUS_ENABLED flag.</li>
///</ol>To disable quality control, call <b>SetStatus</b> with no flag.
@GUID("65ABEA96-CF36-453F-AF8A-705E98F16260")
interface IDMOQualityControl : IUnknown
{
    ///The <code>SetNow</code> method specifies the earliest time stamp that the DMO will deliver.
    ///Params:
    ///    rtNow = Reference time specifying the earliest time stamp to deliver.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> Failure </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT SetNow(long rtNow);
    ///The <code>SetStatus</code> method enables or disables quality control.
    ///Params:
    ///    dwFlags = Value that specifies whether to enable or disable quality control. Use DMO_QUALITY_STATUS_ENABLED to enable
    ///              quality control, or zero to disable quality control.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT SetStatus(uint dwFlags);
    ///The <code>GetStatus</code> method determines whether quality control is active.
    ///Params:
    ///    pdwFlags = Pointer to a variable that receives the quality control status. If quality control is disabled, the value is
    ///               zero. If quality control is enabled, the value is DMO_QUALITY_STATUS_ENABLED.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> <b>NULL</b> pointer value </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT GetStatus(uint* pdwFlags);
}

///The <code>IDMOVideoOutputOptimizations</code> interface supports video optimizations on a Microsoft DirectX Media
///Object (DMO).
@GUID("BE8F4F4E-5B16-4D29-B350-7F6B5D9298AC")
interface IDMOVideoOutputOptimizations : IUnknown
{
    ///The <code>QueryOperationModePreferences</code> method retrieves the DMO's preferred optimization features.
    ///Params:
    ///    ulOutputStreamIndex = Zero-based index of an output stream on the DMO.
    ///    pdwRequestedCapabilities = Pointer to a variable that receives the DMO's requested features. The returned value is a bitwise combination
    ///                               of zero or more flags from the DMO_VIDEO_OUTPUT_STREAM_FLAGS enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr>
    ///    </table>
    ///    
    HRESULT QueryOperationModePreferences(uint ulOutputStreamIndex, uint* pdwRequestedCapabilities);
    ///The <code>SetOperationMode</code> method notifies the DMO of the optimization features that are in effect.
    ///Params:
    ///    ulOutputStreamIndex = Zero-based index of an output stream on the DMO.
    ///    dwEnabledFeatures = Bitwise combination of zero or more flags from the DMO_VIDEO_OUTPUT_STREAM_FLAGS enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr> </table>
    ///    
    HRESULT SetOperationMode(uint ulOutputStreamIndex, uint dwEnabledFeatures);
    ///The <code>GetCurrentOperationMode</code> method retrieves the optimization features in effect.
    ///Params:
    ///    ulOutputStreamIndex = Zero-based index of an output stream on the DMO.
    ///    pdwEnabledFeatures = Pointer to a variable that receives the current features. The returned value is a bitwise combination of zero
    ///                         or more flags from the DMO_VIDEO_OUTPUT_STREAM_FLAGS enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentOperationMode(uint ulOutputStreamIndex, uint* pdwEnabledFeatures);
    ///The <code>GetCurrentSampleRequirements</code> method retrieves the optimization features required to process the
    ///next sample, given the features already agreed to by the application.
    ///Params:
    ///    ulOutputStreamIndex = Zero-based index of an output stream on the DMO.
    ///    pdwRequestedFeatures = Pointer to a variable that receives the required features. The returned value is a bitwise combination of
    ///                           zero or more flags from the DMO_VIDEO_OUTPUT_STREAM_FLAGS enumeration.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Possible values include those in the following table. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DMO_E_INVALIDSTREAMINDEX</b></dt> </dl> </td> <td width="60%"> Invalid stream index </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentSampleRequirements(uint ulOutputStreamIndex, uint* pdwRequestedFeatures);
}


// GUIDs

const GUID CLSID_ANALOG_AUXIN_NETWORK_TYPE                   = GUIDOF!ANALOG_AUXIN_NETWORK_TYPE;
const GUID CLSID_ANALOG_FM_NETWORK_TYPE                      = GUIDOF!ANALOG_FM_NETWORK_TYPE;
const GUID CLSID_ANALOG_TV_NETWORK_TYPE                      = GUIDOF!ANALOG_TV_NETWORK_TYPE;
const GUID CLSID_ATSCChannelTuneRequest                      = GUIDOF!ATSCChannelTuneRequest;
const GUID CLSID_ATSCComponentType                           = GUIDOF!ATSCComponentType;
const GUID CLSID_ATSCLocator                                 = GUIDOF!ATSCLocator;
const GUID CLSID_ATSCTuningSpace                             = GUIDOF!ATSCTuningSpace;
const GUID CLSID_ATSC_TERRESTRIAL_TV_NETWORK_TYPE            = GUIDOF!ATSC_TERRESTRIAL_TV_NETWORK_TYPE;
const GUID CLSID_AnalogAudioComponentType                    = GUIDOF!AnalogAudioComponentType;
const GUID CLSID_AnalogLocator                               = GUIDOF!AnalogLocator;
const GUID CLSID_AnalogRadioTuningSpace                      = GUIDOF!AnalogRadioTuningSpace;
const GUID CLSID_AnalogTVTuningSpace                         = GUIDOF!AnalogTVTuningSpace;
const GUID CLSID_AuxInTuningSpace                            = GUIDOF!AuxInTuningSpace;
const GUID CLSID_BDA_DEBUG_DATA_AVAILABLE                    = GUIDOF!BDA_DEBUG_DATA_AVAILABLE;
const GUID CLSID_BDA_DEBUG_DATA_TYPE_STRING                  = GUIDOF!BDA_DEBUG_DATA_TYPE_STRING;
const GUID CLSID_BSKYB_TERRESTRIAL_TV_NETWORK_TYPE           = GUIDOF!BSKYB_TERRESTRIAL_TV_NETWORK_TYPE;
const GUID CLSID_BroadcastEventService                       = GUIDOF!BroadcastEventService;
const GUID CLSID_CLSID_Proxy                                 = GUIDOF!CLSID_Proxy;
const GUID CLSID_CXDSData                                    = GUIDOF!CXDSData;
const GUID CLSID_ChannelIDTuneRequest                        = GUIDOF!ChannelIDTuneRequest;
const GUID CLSID_ChannelIDTuningSpace                        = GUIDOF!ChannelIDTuningSpace;
const GUID CLSID_ChannelTuneRequest                          = GUIDOF!ChannelTuneRequest;
const GUID CLSID_Component                                   = GUIDOF!Component;
const GUID CLSID_ComponentType                               = GUIDOF!ComponentType;
const GUID CLSID_ComponentTypes                              = GUIDOF!ComponentTypes;
const GUID CLSID_Components                                  = GUIDOF!Components;
const GUID CLSID_CreatePropBagOnRegKey                       = GUIDOF!CreatePropBagOnRegKey;
const GUID CLSID_DIGITAL_CABLE_NETWORK_TYPE                  = GUIDOF!DIGITAL_CABLE_NETWORK_TYPE;
const GUID CLSID_DIRECT_TV_SATELLITE_TV_NETWORK_TYPE         = GUIDOF!DIRECT_TV_SATELLITE_TV_NETWORK_TYPE;
const GUID CLSID_DTFilter                                    = GUIDOF!DTFilter;
const GUID CLSID_DVBCLocator                                 = GUIDOF!DVBCLocator;
const GUID CLSID_DVBSLocator                                 = GUIDOF!DVBSLocator;
const GUID CLSID_DVBSTuningSpace                             = GUIDOF!DVBSTuningSpace;
const GUID CLSID_DVBTLocator                                 = GUIDOF!DVBTLocator;
const GUID CLSID_DVBTLocator2                                = GUIDOF!DVBTLocator2;
const GUID CLSID_DVBTuneRequest                              = GUIDOF!DVBTuneRequest;
const GUID CLSID_DVBTuningSpace                              = GUIDOF!DVBTuningSpace;
const GUID CLSID_DVB_CABLE_TV_NETWORK_TYPE                   = GUIDOF!DVB_CABLE_TV_NETWORK_TYPE;
const GUID CLSID_DVB_SATELLITE_TV_NETWORK_TYPE               = GUIDOF!DVB_SATELLITE_TV_NETWORK_TYPE;
const GUID CLSID_DVB_TERRESTRIAL_TV_NETWORK_TYPE             = GUIDOF!DVB_TERRESTRIAL_TV_NETWORK_TYPE;
const GUID CLSID_DigitalCableLocator                         = GUIDOF!DigitalCableLocator;
const GUID CLSID_DigitalCableTuneRequest                     = GUIDOF!DigitalCableTuneRequest;
const GUID CLSID_DigitalCableTuningSpace                     = GUIDOF!DigitalCableTuningSpace;
const GUID CLSID_DigitalLocator                              = GUIDOF!DigitalLocator;
const GUID CLSID_ECHOSTAR_SATELLITE_TV_NETWORK_TYPE          = GUIDOF!ECHOSTAR_SATELLITE_TV_NETWORK_TYPE;
const GUID CLSID_ESEventFactory                              = GUIDOF!ESEventFactory;
const GUID CLSID_ESEventService                              = GUIDOF!ESEventService;
const GUID CLSID_ETFilter                                    = GUIDOF!ETFilter;
const GUID CLSID_EVENTID_ARIBcontentSpanningEvent            = GUIDOF!EVENTID_ARIBcontentSpanningEvent;
const GUID CLSID_EVENTID_AudioDescriptorSpanningEvent        = GUIDOF!EVENTID_AudioDescriptorSpanningEvent;
const GUID CLSID_EVENTID_AudioTypeSpanningEvent              = GUIDOF!EVENTID_AudioTypeSpanningEvent;
const GUID CLSID_EVENTID_BDAConditionalAccessTAG             = GUIDOF!EVENTID_BDAConditionalAccessTAG;
const GUID CLSID_EVENTID_BDAEventingServicePendingEvent      = GUIDOF!EVENTID_BDAEventingServicePendingEvent;
const GUID CLSID_EVENTID_BDA_CASBroadcastMMI                 = GUIDOF!EVENTID_BDA_CASBroadcastMMI;
const GUID CLSID_EVENTID_BDA_CASCloseMMI                     = GUIDOF!EVENTID_BDA_CASCloseMMI;
const GUID CLSID_EVENTID_BDA_CASOpenMMI                      = GUIDOF!EVENTID_BDA_CASOpenMMI;
const GUID CLSID_EVENTID_BDA_CASReleaseTuner                 = GUIDOF!EVENTID_BDA_CASReleaseTuner;
const GUID CLSID_EVENTID_BDA_CASRequestTuner                 = GUIDOF!EVENTID_BDA_CASRequestTuner;
const GUID CLSID_EVENTID_BDA_DiseqCResponseAvailable         = GUIDOF!EVENTID_BDA_DiseqCResponseAvailable;
const GUID CLSID_EVENTID_BDA_EncoderSignalLock               = GUIDOF!EVENTID_BDA_EncoderSignalLock;
const GUID CLSID_EVENTID_BDA_FdcStatus                       = GUIDOF!EVENTID_BDA_FdcStatus;
const GUID CLSID_EVENTID_BDA_FdcTableSection                 = GUIDOF!EVENTID_BDA_FdcTableSection;
const GUID CLSID_EVENTID_BDA_GPNVValueUpdate                 = GUIDOF!EVENTID_BDA_GPNVValueUpdate;
const GUID CLSID_EVENTID_BDA_GuideDataAvailable              = GUIDOF!EVENTID_BDA_GuideDataAvailable;
const GUID CLSID_EVENTID_BDA_GuideDataError                  = GUIDOF!EVENTID_BDA_GuideDataError;
const GUID CLSID_EVENTID_BDA_GuideServiceInformationUpdated  = GUIDOF!EVENTID_BDA_GuideServiceInformationUpdated;
const GUID CLSID_EVENTID_BDA_IsdbCASResponse                 = GUIDOF!EVENTID_BDA_IsdbCASResponse;
const GUID CLSID_EVENTID_BDA_LbigsCloseConnectionHandle      = GUIDOF!EVENTID_BDA_LbigsCloseConnectionHandle;
const GUID CLSID_EVENTID_BDA_LbigsOpenConnection             = GUIDOF!EVENTID_BDA_LbigsOpenConnection;
const GUID CLSID_EVENTID_BDA_LbigsSendData                   = GUIDOF!EVENTID_BDA_LbigsSendData;
const GUID CLSID_EVENTID_BDA_RatingPinReset                  = GUIDOF!EVENTID_BDA_RatingPinReset;
const GUID CLSID_EVENTID_BDA_TransprtStreamSelectorInfo      = GUIDOF!EVENTID_BDA_TransprtStreamSelectorInfo;
const GUID CLSID_EVENTID_BDA_TunerNoSignal                   = GUIDOF!EVENTID_BDA_TunerNoSignal;
const GUID CLSID_EVENTID_BDA_TunerSignalLock                 = GUIDOF!EVENTID_BDA_TunerSignalLock;
const GUID CLSID_EVENTID_BDA_UpdateDrmStatus                 = GUIDOF!EVENTID_BDA_UpdateDrmStatus;
const GUID CLSID_EVENTID_BDA_UpdateScanState                 = GUIDOF!EVENTID_BDA_UpdateScanState;
const GUID CLSID_EVENTID_CADenialCountChanged                = GUIDOF!EVENTID_CADenialCountChanged;
const GUID CLSID_EVENTID_CASFailureSpanningEvent             = GUIDOF!EVENTID_CASFailureSpanningEvent;
const GUID CLSID_EVENTID_CSDescriptorSpanningEvent           = GUIDOF!EVENTID_CSDescriptorSpanningEvent;
const GUID CLSID_EVENTID_CandidatePostTuneData               = GUIDOF!EVENTID_CandidatePostTuneData;
const GUID CLSID_EVENTID_CardStatusChanged                   = GUIDOF!EVENTID_CardStatusChanged;
const GUID CLSID_EVENTID_ChannelChangeSpanningEvent          = GUIDOF!EVENTID_ChannelChangeSpanningEvent;
const GUID CLSID_EVENTID_ChannelInfoSpanningEvent            = GUIDOF!EVENTID_ChannelInfoSpanningEvent;
const GUID CLSID_EVENTID_ChannelTypeSpanningEvent            = GUIDOF!EVENTID_ChannelTypeSpanningEvent;
const GUID CLSID_EVENTID_CtxADescriptorSpanningEvent         = GUIDOF!EVENTID_CtxADescriptorSpanningEvent;
const GUID CLSID_EVENTID_DFNWithNoActualAVData               = GUIDOF!EVENTID_DFNWithNoActualAVData;
const GUID CLSID_EVENTID_DRMParingStatusChanged              = GUIDOF!EVENTID_DRMParingStatusChanged;
const GUID CLSID_EVENTID_DRMParingStepComplete               = GUIDOF!EVENTID_DRMParingStepComplete;
const GUID CLSID_EVENTID_DVBScramblingControlSpanningEvent   = GUIDOF!EVENTID_DVBScramblingControlSpanningEvent;
const GUID CLSID_EVENTID_DualMonoSpanningEvent               = GUIDOF!EVENTID_DualMonoSpanningEvent;
const GUID CLSID_EVENTID_DvbParentalRatingDescriptor         = GUIDOF!EVENTID_DvbParentalRatingDescriptor;
const GUID CLSID_EVENTID_EASMessageReceived                  = GUIDOF!EVENTID_EASMessageReceived;
const GUID CLSID_EVENTID_EmmMessageSpanningEvent             = GUIDOF!EVENTID_EmmMessageSpanningEvent;
const GUID CLSID_EVENTID_EntitlementChanged                  = GUIDOF!EVENTID_EntitlementChanged;
const GUID CLSID_EVENTID_LanguageSpanningEvent               = GUIDOF!EVENTID_LanguageSpanningEvent;
const GUID CLSID_EVENTID_MMIMessage                          = GUIDOF!EVENTID_MMIMessage;
const GUID CLSID_EVENTID_NewSignalAcquired                   = GUIDOF!EVENTID_NewSignalAcquired;
const GUID CLSID_EVENTID_PBDAParentalControlEvent            = GUIDOF!EVENTID_PBDAParentalControlEvent;
const GUID CLSID_EVENTID_PIDListSpanningEvent                = GUIDOF!EVENTID_PIDListSpanningEvent;
const GUID CLSID_EVENTID_PSITable                            = GUIDOF!EVENTID_PSITable;
const GUID CLSID_EVENTID_RRTSpanningEvent                    = GUIDOF!EVENTID_RRTSpanningEvent;
const GUID CLSID_EVENTID_STBChannelNumber                    = GUIDOF!EVENTID_STBChannelNumber;
const GUID CLSID_EVENTID_ServiceTerminated                   = GUIDOF!EVENTID_ServiceTerminated;
const GUID CLSID_EVENTID_SignalAndServiceStatusSpanningEvent = GUIDOF!EVENTID_SignalAndServiceStatusSpanningEvent;
const GUID CLSID_EVENTID_SignalStatusChanged                 = GUIDOF!EVENTID_SignalStatusChanged;
const GUID CLSID_EVENTID_StreamIDSpanningEvent               = GUIDOF!EVENTID_StreamIDSpanningEvent;
const GUID CLSID_EVENTID_StreamTypeSpanningEvent             = GUIDOF!EVENTID_StreamTypeSpanningEvent;
const GUID CLSID_EVENTID_SubtitleSpanningEvent               = GUIDOF!EVENTID_SubtitleSpanningEvent;
const GUID CLSID_EVENTID_TeletextSpanningEvent               = GUIDOF!EVENTID_TeletextSpanningEvent;
const GUID CLSID_EVENTID_TuneFailureEvent                    = GUIDOF!EVENTID_TuneFailureEvent;
const GUID CLSID_EVENTID_TuneFailureSpanningEvent            = GUIDOF!EVENTID_TuneFailureSpanningEvent;
const GUID CLSID_EVENTID_TuningChanged                       = GUIDOF!EVENTID_TuningChanged;
const GUID CLSID_EVENTID_TuningChanging                      = GUIDOF!EVENTID_TuningChanging;
const GUID CLSID_EVENTTYPE_CASDescrambleFailureEvent         = GUIDOF!EVENTTYPE_CASDescrambleFailureEvent;
const GUID CLSID_EvalRat                                     = GUIDOF!EvalRat;
const GUID CLSID_FilgraphManager                             = GUIDOF!FilgraphManager;
const GUID CLSID_ISDBSLocator                                = GUIDOF!ISDBSLocator;
const GUID CLSID_ISDB_CABLE_TV_NETWORK_TYPE                  = GUIDOF!ISDB_CABLE_TV_NETWORK_TYPE;
const GUID CLSID_ISDB_SATELLITE_TV_NETWORK_TYPE              = GUIDOF!ISDB_SATELLITE_TV_NETWORK_TYPE;
const GUID CLSID_ISDB_S_NETWORK_TYPE                         = GUIDOF!ISDB_S_NETWORK_TYPE;
const GUID CLSID_ISDB_TERRESTRIAL_TV_NETWORK_TYPE            = GUIDOF!ISDB_TERRESTRIAL_TV_NETWORK_TYPE;
const GUID CLSID_ISDB_T_NETWORK_TYPE                         = GUIDOF!ISDB_T_NETWORK_TYPE;
const GUID CLSID_KSCATEGORY_BDA_IP_SINK                      = GUIDOF!KSCATEGORY_BDA_IP_SINK;
const GUID CLSID_KSCATEGORY_BDA_NETWORK_EPG                  = GUIDOF!KSCATEGORY_BDA_NETWORK_EPG;
const GUID CLSID_KSCATEGORY_BDA_NETWORK_PROVIDER             = GUIDOF!KSCATEGORY_BDA_NETWORK_PROVIDER;
const GUID CLSID_KSCATEGORY_BDA_NETWORK_TUNER                = GUIDOF!KSCATEGORY_BDA_NETWORK_TUNER;
const GUID CLSID_KSCATEGORY_BDA_RECEIVER_COMPONENT           = GUIDOF!KSCATEGORY_BDA_RECEIVER_COMPONENT;
const GUID CLSID_KSCATEGORY_BDA_TRANSPORT_INFORMATION        = GUIDOF!KSCATEGORY_BDA_TRANSPORT_INFORMATION;
const GUID CLSID_KSDATAFORMAT_SPECIFIER_BDA_IP               = GUIDOF!KSDATAFORMAT_SPECIFIER_BDA_IP;
const GUID CLSID_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT        = GUIDOF!KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT;
const GUID CLSID_KSDATAFORMAT_SUBTYPE_ATSC_SI                = GUIDOF!KSDATAFORMAT_SUBTYPE_ATSC_SI;
const GUID CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP                 = GUIDOF!KSDATAFORMAT_SUBTYPE_BDA_IP;
const GUID CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL         = GUIDOF!KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL;
const GUID CLSID_KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT    = GUIDOF!KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT;
const GUID CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP = GUIDOF!KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP;
const GUID CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP     = GUIDOF!KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP;
const GUID CLSID_KSDATAFORMAT_SUBTYPE_DVB_SI                 = GUIDOF!KSDATAFORMAT_SUBTYPE_DVB_SI;
const GUID CLSID_KSDATAFORMAT_SUBTYPE_ISDB_SI                = GUIDOF!KSDATAFORMAT_SUBTYPE_ISDB_SI;
const GUID CLSID_KSDATAFORMAT_SUBTYPE_PBDA_TRANSPORT_RAW     = GUIDOF!KSDATAFORMAT_SUBTYPE_PBDA_TRANSPORT_RAW;
const GUID CLSID_KSDATAFORMAT_TYPE_BDA_ANTENNA               = GUIDOF!KSDATAFORMAT_TYPE_BDA_ANTENNA;
const GUID CLSID_KSDATAFORMAT_TYPE_BDA_IF_SIGNAL             = GUIDOF!KSDATAFORMAT_TYPE_BDA_IF_SIGNAL;
const GUID CLSID_KSDATAFORMAT_TYPE_BDA_IP                    = GUIDOF!KSDATAFORMAT_TYPE_BDA_IP;
const GUID CLSID_KSDATAFORMAT_TYPE_BDA_IP_CONTROL            = GUIDOF!KSDATAFORMAT_TYPE_BDA_IP_CONTROL;
const GUID CLSID_KSDATAFORMAT_TYPE_MPE                       = GUIDOF!KSDATAFORMAT_TYPE_MPE;
const GUID CLSID_KSDATAFORMAT_TYPE_MPEG2_SECTIONS            = GUIDOF!KSDATAFORMAT_TYPE_MPEG2_SECTIONS;
const GUID CLSID_KSEVENTSETID_BdaCAEvent                     = GUIDOF!KSEVENTSETID_BdaCAEvent;
const GUID CLSID_KSEVENTSETID_BdaDiseqCEvent                 = GUIDOF!KSEVENTSETID_BdaDiseqCEvent;
const GUID CLSID_KSEVENTSETID_BdaEvent                       = GUIDOF!KSEVENTSETID_BdaEvent;
const GUID CLSID_KSEVENTSETID_BdaPinEvent                    = GUIDOF!KSEVENTSETID_BdaPinEvent;
const GUID CLSID_KSEVENTSETID_BdaTunerEvent                  = GUIDOF!KSEVENTSETID_BdaTunerEvent;
const GUID CLSID_KSMETHODSETID_BdaChangeSync                 = GUIDOF!KSMETHODSETID_BdaChangeSync;
const GUID CLSID_KSMETHODSETID_BdaConditionalAccessService   = GUIDOF!KSMETHODSETID_BdaConditionalAccessService;
const GUID CLSID_KSMETHODSETID_BdaDebug                      = GUIDOF!KSMETHODSETID_BdaDebug;
const GUID CLSID_KSMETHODSETID_BdaDeviceConfiguration        = GUIDOF!KSMETHODSETID_BdaDeviceConfiguration;
const GUID CLSID_KSMETHODSETID_BdaDrmService                 = GUIDOF!KSMETHODSETID_BdaDrmService;
const GUID CLSID_KSMETHODSETID_BdaEventing                   = GUIDOF!KSMETHODSETID_BdaEventing;
const GUID CLSID_KSMETHODSETID_BdaGuideDataDeliveryService   = GUIDOF!KSMETHODSETID_BdaGuideDataDeliveryService;
const GUID CLSID_KSMETHODSETID_BdaIsdbConditionalAccess      = GUIDOF!KSMETHODSETID_BdaIsdbConditionalAccess;
const GUID CLSID_KSMETHODSETID_BdaMux                        = GUIDOF!KSMETHODSETID_BdaMux;
const GUID CLSID_KSMETHODSETID_BdaNameValue                  = GUIDOF!KSMETHODSETID_BdaNameValue;
const GUID CLSID_KSMETHODSETID_BdaNameValueA                 = GUIDOF!KSMETHODSETID_BdaNameValueA;
const GUID CLSID_KSMETHODSETID_BdaScanning                   = GUIDOF!KSMETHODSETID_BdaScanning;
const GUID CLSID_KSMETHODSETID_BdaTSSelector                 = GUIDOF!KSMETHODSETID_BdaTSSelector;
const GUID CLSID_KSMETHODSETID_BdaTuner                      = GUIDOF!KSMETHODSETID_BdaTuner;
const GUID CLSID_KSMETHODSETID_BdaUserActivity               = GUIDOF!KSMETHODSETID_BdaUserActivity;
const GUID CLSID_KSMETHODSETID_BdaWmdrmSession               = GUIDOF!KSMETHODSETID_BdaWmdrmSession;
const GUID CLSID_KSMETHODSETID_BdaWmdrmTuner                 = GUIDOF!KSMETHODSETID_BdaWmdrmTuner;
const GUID CLSID_KSNODE_BDA_8PSK_DEMODULATOR                 = GUIDOF!KSNODE_BDA_8PSK_DEMODULATOR;
const GUID CLSID_KSNODE_BDA_8VSB_DEMODULATOR                 = GUIDOF!KSNODE_BDA_8VSB_DEMODULATOR;
const GUID CLSID_KSNODE_BDA_ANALOG_DEMODULATOR               = GUIDOF!KSNODE_BDA_ANALOG_DEMODULATOR;
const GUID CLSID_KSNODE_BDA_COFDM_DEMODULATOR                = GUIDOF!KSNODE_BDA_COFDM_DEMODULATOR;
const GUID CLSID_KSNODE_BDA_COMMON_CA_POD                    = GUIDOF!KSNODE_BDA_COMMON_CA_POD;
const GUID CLSID_KSNODE_BDA_DRI_DRM                          = GUIDOF!KSNODE_BDA_DRI_DRM;
const GUID CLSID_KSNODE_BDA_IP_SINK                          = GUIDOF!KSNODE_BDA_IP_SINK;
const GUID CLSID_KSNODE_BDA_ISDB_S_DEMODULATOR               = GUIDOF!KSNODE_BDA_ISDB_S_DEMODULATOR;
const GUID CLSID_KSNODE_BDA_ISDB_T_DEMODULATOR               = GUIDOF!KSNODE_BDA_ISDB_T_DEMODULATOR;
const GUID CLSID_KSNODE_BDA_OPENCABLE_POD                    = GUIDOF!KSNODE_BDA_OPENCABLE_POD;
const GUID CLSID_KSNODE_BDA_PBDA_CAS                         = GUIDOF!KSNODE_BDA_PBDA_CAS;
const GUID CLSID_KSNODE_BDA_PBDA_DRM                         = GUIDOF!KSNODE_BDA_PBDA_DRM;
const GUID CLSID_KSNODE_BDA_PBDA_ISDBCAS                     = GUIDOF!KSNODE_BDA_PBDA_ISDBCAS;
const GUID CLSID_KSNODE_BDA_PBDA_MUX                         = GUIDOF!KSNODE_BDA_PBDA_MUX;
const GUID CLSID_KSNODE_BDA_PBDA_TUNER                       = GUIDOF!KSNODE_BDA_PBDA_TUNER;
const GUID CLSID_KSNODE_BDA_PID_FILTER                       = GUIDOF!KSNODE_BDA_PID_FILTER;
const GUID CLSID_KSNODE_BDA_QAM_DEMODULATOR                  = GUIDOF!KSNODE_BDA_QAM_DEMODULATOR;
const GUID CLSID_KSNODE_BDA_QPSK_DEMODULATOR                 = GUIDOF!KSNODE_BDA_QPSK_DEMODULATOR;
const GUID CLSID_KSNODE_BDA_RF_TUNER                         = GUIDOF!KSNODE_BDA_RF_TUNER;
const GUID CLSID_KSNODE_BDA_TS_SELECTOR                      = GUIDOF!KSNODE_BDA_TS_SELECTOR;
const GUID CLSID_KSNODE_BDA_VIDEO_ENCODER                    = GUIDOF!KSNODE_BDA_VIDEO_ENCODER;
const GUID CLSID_KSPROPSETID_BdaAutodemodulate               = GUIDOF!KSPROPSETID_BdaAutodemodulate;
const GUID CLSID_KSPROPSETID_BdaCA                           = GUIDOF!KSPROPSETID_BdaCA;
const GUID CLSID_KSPROPSETID_BdaDigitalDemodulator           = GUIDOF!KSPROPSETID_BdaDigitalDemodulator;
const GUID CLSID_KSPROPSETID_BdaDiseqCommand                 = GUIDOF!KSPROPSETID_BdaDiseqCommand;
const GUID CLSID_KSPROPSETID_BdaEthernetFilter               = GUIDOF!KSPROPSETID_BdaEthernetFilter;
const GUID CLSID_KSPROPSETID_BdaFrequencyFilter              = GUIDOF!KSPROPSETID_BdaFrequencyFilter;
const GUID CLSID_KSPROPSETID_BdaIPv4Filter                   = GUIDOF!KSPROPSETID_BdaIPv4Filter;
const GUID CLSID_KSPROPSETID_BdaIPv6Filter                   = GUIDOF!KSPROPSETID_BdaIPv6Filter;
const GUID CLSID_KSPROPSETID_BdaLNBInfo                      = GUIDOF!KSPROPSETID_BdaLNBInfo;
const GUID CLSID_KSPROPSETID_BdaNullTransform                = GUIDOF!KSPROPSETID_BdaNullTransform;
const GUID CLSID_KSPROPSETID_BdaPIDFilter                    = GUIDOF!KSPROPSETID_BdaPIDFilter;
const GUID CLSID_KSPROPSETID_BdaPinControl                   = GUIDOF!KSPROPSETID_BdaPinControl;
const GUID CLSID_KSPROPSETID_BdaSignalStats                  = GUIDOF!KSPROPSETID_BdaSignalStats;
const GUID CLSID_KSPROPSETID_BdaTableSection                 = GUIDOF!KSPROPSETID_BdaTableSection;
const GUID CLSID_KSPROPSETID_BdaTopology                     = GUIDOF!KSPROPSETID_BdaTopology;
const GUID CLSID_KSPROPSETID_BdaVoidTransform                = GUIDOF!KSPROPSETID_BdaVoidTransform;
const GUID CLSID_LanguageComponentType                       = GUIDOF!LanguageComponentType;
const GUID CLSID_Locator                                     = GUIDOF!Locator;
const GUID CLSID_MPEG2Component                              = GUIDOF!MPEG2Component;
const GUID CLSID_MPEG2ComponentType                          = GUIDOF!MPEG2ComponentType;
const GUID CLSID_MPEG2TuneRequest                            = GUIDOF!MPEG2TuneRequest;
const GUID CLSID_MPEG2TuneRequestFactory                     = GUIDOF!MPEG2TuneRequestFactory;
const GUID CLSID_MSEventBinder                               = GUIDOF!MSEventBinder;
const GUID CLSID_MSVidAnalogCaptureToCCA                     = GUIDOF!MSVidAnalogCaptureToCCA;
const GUID CLSID_MSVidAnalogCaptureToDataServices            = GUIDOF!MSVidAnalogCaptureToDataServices;
const GUID CLSID_MSVidAnalogCaptureToOverlayMixer            = GUIDOF!MSVidAnalogCaptureToOverlayMixer;
const GUID CLSID_MSVidAnalogCaptureToStreamBufferSink        = GUIDOF!MSVidAnalogCaptureToStreamBufferSink;
const GUID CLSID_MSVidAnalogCaptureToXDS                     = GUIDOF!MSVidAnalogCaptureToXDS;
const GUID CLSID_MSVidAnalogTVToEncoder                      = GUIDOF!MSVidAnalogTVToEncoder;
const GUID CLSID_MSVidAnalogTunerDevice                      = GUIDOF!MSVidAnalogTunerDevice;
const GUID CLSID_MSVidAudioRenderer                          = GUIDOF!MSVidAudioRenderer;
const GUID CLSID_MSVidAudioRendererDevices                   = GUIDOF!MSVidAudioRendererDevices;
const GUID CLSID_MSVidBDATunerDevice                         = GUIDOF!MSVidBDATunerDevice;
const GUID CLSID_MSVidCCA                                    = GUIDOF!MSVidCCA;
const GUID CLSID_MSVidCCAToStreamBufferSink                  = GUIDOF!MSVidCCAToStreamBufferSink;
const GUID CLSID_MSVidCCToAR                                 = GUIDOF!MSVidCCToAR;
const GUID CLSID_MSVidCCToVMR                                = GUIDOF!MSVidCCToVMR;
const GUID CLSID_MSVidClosedCaptioning                       = GUIDOF!MSVidClosedCaptioning;
const GUID CLSID_MSVidClosedCaptioningSI                     = GUIDOF!MSVidClosedCaptioningSI;
const GUID CLSID_MSVidCtl                                    = GUIDOF!MSVidCtl;
const GUID CLSID_MSVidDataServices                           = GUIDOF!MSVidDataServices;
const GUID CLSID_MSVidDataServicesToStreamBufferSink         = GUIDOF!MSVidDataServicesToStreamBufferSink;
const GUID CLSID_MSVidDataServicesToXDS                      = GUIDOF!MSVidDataServicesToXDS;
const GUID CLSID_MSVidDevice                                 = GUIDOF!MSVidDevice;
const GUID CLSID_MSVidDevice2                                = GUIDOF!MSVidDevice2;
const GUID CLSID_MSVidDigitalCaptureToCCA                    = GUIDOF!MSVidDigitalCaptureToCCA;
const GUID CLSID_MSVidDigitalCaptureToITV                    = GUIDOF!MSVidDigitalCaptureToITV;
const GUID CLSID_MSVidDigitalCaptureToStreamBufferSink       = GUIDOF!MSVidDigitalCaptureToStreamBufferSink;
const GUID CLSID_MSVidEVR                                    = GUIDOF!MSVidEVR;
const GUID CLSID_MSVidEncoder                                = GUIDOF!MSVidEncoder;
const GUID CLSID_MSVidEncoderToStreamBufferSink              = GUIDOF!MSVidEncoderToStreamBufferSink;
const GUID CLSID_MSVidFeature                                = GUIDOF!MSVidFeature;
const GUID CLSID_MSVidFeatures                               = GUIDOF!MSVidFeatures;
const GUID CLSID_MSVidFilePlaybackDevice                     = GUIDOF!MSVidFilePlaybackDevice;
const GUID CLSID_MSVidFilePlaybackToAudioRenderer            = GUIDOF!MSVidFilePlaybackToAudioRenderer;
const GUID CLSID_MSVidFilePlaybackToVideoRenderer            = GUIDOF!MSVidFilePlaybackToVideoRenderer;
const GUID CLSID_MSVidGenericComposite                       = GUIDOF!MSVidGenericComposite;
const GUID CLSID_MSVidGenericSink                            = GUIDOF!MSVidGenericSink;
const GUID CLSID_MSVidITVCapture                             = GUIDOF!MSVidITVCapture;
const GUID CLSID_MSVidITVPlayback                            = GUIDOF!MSVidITVPlayback;
const GUID CLSID_MSVidITVToStreamBufferSink                  = GUIDOF!MSVidITVToStreamBufferSink;
const GUID CLSID_MSVidInputDevice                            = GUIDOF!MSVidInputDevice;
const GUID CLSID_MSVidInputDevices                           = GUIDOF!MSVidInputDevices;
const GUID CLSID_MSVidMPEG2DecoderToClosedCaptioning         = GUIDOF!MSVidMPEG2DecoderToClosedCaptioning;
const GUID CLSID_MSVidOutput                                 = GUIDOF!MSVidOutput;
const GUID CLSID_MSVidOutputDevices                          = GUIDOF!MSVidOutputDevices;
const GUID CLSID_MSVidRect                                   = GUIDOF!MSVidRect;
const GUID CLSID_MSVidSBESourceToCC                          = GUIDOF!MSVidSBESourceToCC;
const GUID CLSID_MSVidSBESourceToGenericSink                 = GUIDOF!MSVidSBESourceToGenericSink;
const GUID CLSID_MSVidSBESourceToITV                         = GUIDOF!MSVidSBESourceToITV;
const GUID CLSID_MSVidStreamBufferRecordingControl           = GUIDOF!MSVidStreamBufferRecordingControl;
const GUID CLSID_MSVidStreamBufferSink                       = GUIDOF!MSVidStreamBufferSink;
const GUID CLSID_MSVidStreamBufferSource                     = GUIDOF!MSVidStreamBufferSource;
const GUID CLSID_MSVidStreamBufferSourceToVideoRenderer      = GUIDOF!MSVidStreamBufferSourceToVideoRenderer;
const GUID CLSID_MSVidStreamBufferV2Source                   = GUIDOF!MSVidStreamBufferV2Source;
const GUID CLSID_MSVidVMR9                                   = GUIDOF!MSVidVMR9;
const GUID CLSID_MSVidVideoInputDevice                       = GUIDOF!MSVidVideoInputDevice;
const GUID CLSID_MSVidVideoPlaybackDevice                    = GUIDOF!MSVidVideoPlaybackDevice;
const GUID CLSID_MSVidVideoRenderer                          = GUIDOF!MSVidVideoRenderer;
const GUID CLSID_MSVidVideoRendererDevices                   = GUIDOF!MSVidVideoRendererDevices;
const GUID CLSID_MSVidWebDVD                                 = GUIDOF!MSVidWebDVD;
const GUID CLSID_MSVidWebDVDAdm                              = GUIDOF!MSVidWebDVDAdm;
const GUID CLSID_MSVidWebDVDToAudioRenderer                  = GUIDOF!MSVidWebDVDToAudioRenderer;
const GUID CLSID_MSVidWebDVDToVideoRenderer                  = GUIDOF!MSVidWebDVDToVideoRenderer;
const GUID CLSID_MSVidXDS                                    = GUIDOF!MSVidXDS;
const GUID CLSID_Mpeg2Data                                   = GUIDOF!Mpeg2Data;
const GUID CLSID_Mpeg2DataLib                                = GUIDOF!Mpeg2DataLib;
const GUID CLSID_Mpeg2Stream                                 = GUIDOF!Mpeg2Stream;
const GUID CLSID_PBDA_ALWAYS_TUNE_IN_MUX                     = GUIDOF!PBDA_ALWAYS_TUNE_IN_MUX;
const GUID CLSID_PINNAME_BDA_ANALOG_AUDIO                    = GUIDOF!PINNAME_BDA_ANALOG_AUDIO;
const GUID CLSID_PINNAME_BDA_ANALOG_VIDEO                    = GUIDOF!PINNAME_BDA_ANALOG_VIDEO;
const GUID CLSID_PINNAME_BDA_FM_RADIO                        = GUIDOF!PINNAME_BDA_FM_RADIO;
const GUID CLSID_PINNAME_BDA_IF_PIN                          = GUIDOF!PINNAME_BDA_IF_PIN;
const GUID CLSID_PINNAME_BDA_OPENCABLE_PSIP_PIN              = GUIDOF!PINNAME_BDA_OPENCABLE_PSIP_PIN;
const GUID CLSID_PINNAME_BDA_TRANSPORT                       = GUIDOF!PINNAME_BDA_TRANSPORT;
const GUID CLSID_PINNAME_IPSINK_INPUT                        = GUIDOF!PINNAME_IPSINK_INPUT;
const GUID CLSID_PINNAME_MPE                                 = GUIDOF!PINNAME_MPE;
const GUID CLSID_PersistTuneXmlUtility                       = GUIDOF!PersistTuneXmlUtility;
const GUID CLSID_SectionList                                 = GUIDOF!SectionList;
const GUID CLSID_SystemTuningSpaces                          = GUIDOF!SystemTuningSpaces;
const GUID CLSID_TIFLoad                                     = GUIDOF!TIFLoad;
const GUID CLSID_TuneRequest                                 = GUIDOF!TuneRequest;
const GUID CLSID_TunerMarshaler                              = GUIDOF!TunerMarshaler;
const GUID CLSID_TuningSpace                                 = GUIDOF!TuningSpace;
const GUID CLSID_XDSCodec                                    = GUIDOF!XDSCodec;
const GUID CLSID_XDSToRat                                    = GUIDOF!XDSToRat;

const GUID IID_IAMAnalogVideoDecoder                    = GUIDOF!IAMAnalogVideoDecoder;
const GUID IID_IAMAnalogVideoEncoder                    = GUIDOF!IAMAnalogVideoEncoder;
const GUID IID_IAMAsyncReaderTimestampScaling           = GUIDOF!IAMAsyncReaderTimestampScaling;
const GUID IID_IAMAudioInputMixer                       = GUIDOF!IAMAudioInputMixer;
const GUID IID_IAMAudioRendererStats                    = GUIDOF!IAMAudioRendererStats;
const GUID IID_IAMBufferNegotiation                     = GUIDOF!IAMBufferNegotiation;
const GUID IID_IAMCameraControl                         = GUIDOF!IAMCameraControl;
const GUID IID_IAMCertifiedOutputProtection             = GUIDOF!IAMCertifiedOutputProtection;
const GUID IID_IAMClockAdjust                           = GUIDOF!IAMClockAdjust;
const GUID IID_IAMClockSlave                            = GUIDOF!IAMClockSlave;
const GUID IID_IAMCollection                            = GUIDOF!IAMCollection;
const GUID IID_IAMCopyCaptureFileProgress               = GUIDOF!IAMCopyCaptureFileProgress;
const GUID IID_IAMCrossbar                              = GUIDOF!IAMCrossbar;
const GUID IID_IAMDecoderCaps                           = GUIDOF!IAMDecoderCaps;
const GUID IID_IAMDevMemoryAllocator                    = GUIDOF!IAMDevMemoryAllocator;
const GUID IID_IAMDevMemoryControl                      = GUIDOF!IAMDevMemoryControl;
const GUID IID_IAMDeviceRemoval                         = GUIDOF!IAMDeviceRemoval;
const GUID IID_IAMDroppedFrames                         = GUIDOF!IAMDroppedFrames;
const GUID IID_IAMExtDevice                             = GUIDOF!IAMExtDevice;
const GUID IID_IAMExtTransport                          = GUIDOF!IAMExtTransport;
const GUID IID_IAMFilterMiscFlags                       = GUIDOF!IAMFilterMiscFlags;
const GUID IID_IAMGraphBuilderCallback                  = GUIDOF!IAMGraphBuilderCallback;
const GUID IID_IAMGraphStreams                          = GUIDOF!IAMGraphStreams;
const GUID IID_IAMLatency                               = GUIDOF!IAMLatency;
const GUID IID_IAMMediaStream                           = GUIDOF!IAMMediaStream;
const GUID IID_IAMMediaTypeSample                       = GUIDOF!IAMMediaTypeSample;
const GUID IID_IAMMediaTypeStream                       = GUIDOF!IAMMediaTypeStream;
const GUID IID_IAMMultiMediaStream                      = GUIDOF!IAMMultiMediaStream;
const GUID IID_IAMOpenProgress                          = GUIDOF!IAMOpenProgress;
const GUID IID_IAMOverlayFX                             = GUIDOF!IAMOverlayFX;
const GUID IID_IAMPhysicalPinInfo                       = GUIDOF!IAMPhysicalPinInfo;
const GUID IID_IAMPluginControl                         = GUIDOF!IAMPluginControl;
const GUID IID_IAMPushSource                            = GUIDOF!IAMPushSource;
const GUID IID_IAMResourceControl                       = GUIDOF!IAMResourceControl;
const GUID IID_IAMStats                                 = GUIDOF!IAMStats;
const GUID IID_IAMStreamConfig                          = GUIDOF!IAMStreamConfig;
const GUID IID_IAMStreamControl                         = GUIDOF!IAMStreamControl;
const GUID IID_IAMStreamSelect                          = GUIDOF!IAMStreamSelect;
const GUID IID_IAMTVAudio                               = GUIDOF!IAMTVAudio;
const GUID IID_IAMTVAudioNotification                   = GUIDOF!IAMTVAudioNotification;
const GUID IID_IAMTVTuner                               = GUIDOF!IAMTVTuner;
const GUID IID_IAMTimecodeDisplay                       = GUIDOF!IAMTimecodeDisplay;
const GUID IID_IAMTimecodeGenerator                     = GUIDOF!IAMTimecodeGenerator;
const GUID IID_IAMTimecodeReader                        = GUIDOF!IAMTimecodeReader;
const GUID IID_IAMTuner                                 = GUIDOF!IAMTuner;
const GUID IID_IAMTunerNotification                     = GUIDOF!IAMTunerNotification;
const GUID IID_IAMVfwCaptureDialogs                     = GUIDOF!IAMVfwCaptureDialogs;
const GUID IID_IAMVfwCompressDialogs                    = GUIDOF!IAMVfwCompressDialogs;
const GUID IID_IAMVideoAccelerator                      = GUIDOF!IAMVideoAccelerator;
const GUID IID_IAMVideoAcceleratorNotify                = GUIDOF!IAMVideoAcceleratorNotify;
const GUID IID_IAMVideoCompression                      = GUIDOF!IAMVideoCompression;
const GUID IID_IAMVideoControl                          = GUIDOF!IAMVideoControl;
const GUID IID_IAMVideoDecimationProperties             = GUIDOF!IAMVideoDecimationProperties;
const GUID IID_IAMVideoProcAmp                          = GUIDOF!IAMVideoProcAmp;
const GUID IID_IAMovieSetup                             = GUIDOF!IAMovieSetup;
const GUID IID_IATSCChannelTuneRequest                  = GUIDOF!IATSCChannelTuneRequest;
const GUID IID_IATSCComponentType                       = GUIDOF!IATSCComponentType;
const GUID IID_IATSCLocator                             = GUIDOF!IATSCLocator;
const GUID IID_IATSCLocator2                            = GUIDOF!IATSCLocator2;
const GUID IID_IATSCTuningSpace                         = GUIDOF!IATSCTuningSpace;
const GUID IID_IATSC_EIT                                = GUIDOF!IATSC_EIT;
const GUID IID_IATSC_ETT                                = GUIDOF!IATSC_ETT;
const GUID IID_IATSC_MGT                                = GUIDOF!IATSC_MGT;
const GUID IID_IATSC_STT                                = GUIDOF!IATSC_STT;
const GUID IID_IATSC_VCT                                = GUIDOF!IATSC_VCT;
const GUID IID_IAnalogAudioComponentType                = GUIDOF!IAnalogAudioComponentType;
const GUID IID_IAnalogLocator                           = GUIDOF!IAnalogLocator;
const GUID IID_IAnalogRadioTuningSpace                  = GUIDOF!IAnalogRadioTuningSpace;
const GUID IID_IAnalogRadioTuningSpace2                 = GUIDOF!IAnalogRadioTuningSpace2;
const GUID IID_IAnalogTVTuningSpace                     = GUIDOF!IAnalogTVTuningSpace;
const GUID IID_IAsyncReader                             = GUIDOF!IAsyncReader;
const GUID IID_IAtscContentAdvisoryDescriptor           = GUIDOF!IAtscContentAdvisoryDescriptor;
const GUID IID_IAtscPsipParser                          = GUIDOF!IAtscPsipParser;
const GUID IID_IAttributeGet                            = GUIDOF!IAttributeGet;
const GUID IID_IAttributeSet                            = GUIDOF!IAttributeSet;
const GUID IID_IAudioData                               = GUIDOF!IAudioData;
const GUID IID_IAudioMediaStream                        = GUIDOF!IAudioMediaStream;
const GUID IID_IAudioStreamSample                       = GUIDOF!IAudioStreamSample;
const GUID IID_IAuxInTuningSpace                        = GUIDOF!IAuxInTuningSpace;
const GUID IID_IAuxInTuningSpace2                       = GUIDOF!IAuxInTuningSpace2;
const GUID IID_IBDAComparable                           = GUIDOF!IBDAComparable;
const GUID IID_IBDACreateTuneRequestEx                  = GUIDOF!IBDACreateTuneRequestEx;
const GUID IID_IBDA_AUX                                 = GUIDOF!IBDA_AUX;
const GUID IID_IBDA_AutoDemodulate                      = GUIDOF!IBDA_AutoDemodulate;
const GUID IID_IBDA_AutoDemodulateEx                    = GUIDOF!IBDA_AutoDemodulateEx;
const GUID IID_IBDA_ConditionalAccess                   = GUIDOF!IBDA_ConditionalAccess;
const GUID IID_IBDA_ConditionalAccessEx                 = GUIDOF!IBDA_ConditionalAccessEx;
const GUID IID_IBDA_DRIDRMService                       = GUIDOF!IBDA_DRIDRMService;
const GUID IID_IBDA_DRIWMDRMSession                     = GUIDOF!IBDA_DRIWMDRMSession;
const GUID IID_IBDA_DRM                                 = GUIDOF!IBDA_DRM;
const GUID IID_IBDA_DRMService                          = GUIDOF!IBDA_DRMService;
const GUID IID_IBDA_DeviceControl                       = GUIDOF!IBDA_DeviceControl;
const GUID IID_IBDA_DiagnosticProperties                = GUIDOF!IBDA_DiagnosticProperties;
const GUID IID_IBDA_DigitalDemodulator                  = GUIDOF!IBDA_DigitalDemodulator;
const GUID IID_IBDA_DigitalDemodulator2                 = GUIDOF!IBDA_DigitalDemodulator2;
const GUID IID_IBDA_DigitalDemodulator3                 = GUIDOF!IBDA_DigitalDemodulator3;
const GUID IID_IBDA_DiseqCommand                        = GUIDOF!IBDA_DiseqCommand;
const GUID IID_IBDA_EasMessage                          = GUIDOF!IBDA_EasMessage;
const GUID IID_IBDA_Encoder                             = GUIDOF!IBDA_Encoder;
const GUID IID_IBDA_EthernetFilter                      = GUIDOF!IBDA_EthernetFilter;
const GUID IID_IBDA_EventingService                     = GUIDOF!IBDA_EventingService;
const GUID IID_IBDA_FDC                                 = GUIDOF!IBDA_FDC;
const GUID IID_IBDA_FrequencyFilter                     = GUIDOF!IBDA_FrequencyFilter;
const GUID IID_IBDA_GuideDataDeliveryService            = GUIDOF!IBDA_GuideDataDeliveryService;
const GUID IID_IBDA_IPSinkControl                       = GUIDOF!IBDA_IPSinkControl;
const GUID IID_IBDA_IPSinkInfo                          = GUIDOF!IBDA_IPSinkInfo;
const GUID IID_IBDA_IPV4Filter                          = GUIDOF!IBDA_IPV4Filter;
const GUID IID_IBDA_IPV6Filter                          = GUIDOF!IBDA_IPV6Filter;
const GUID IID_IBDA_ISDBConditionalAccess               = GUIDOF!IBDA_ISDBConditionalAccess;
const GUID IID_IBDA_LNBInfo                             = GUIDOF!IBDA_LNBInfo;
const GUID IID_IBDA_MUX                                 = GUIDOF!IBDA_MUX;
const GUID IID_IBDA_NameValueService                    = GUIDOF!IBDA_NameValueService;
const GUID IID_IBDA_NetworkProvider                     = GUIDOF!IBDA_NetworkProvider;
const GUID IID_IBDA_NullTransform                       = GUIDOF!IBDA_NullTransform;
const GUID IID_IBDA_PinControl                          = GUIDOF!IBDA_PinControl;
const GUID IID_IBDA_SignalProperties                    = GUIDOF!IBDA_SignalProperties;
const GUID IID_IBDA_SignalStatistics                    = GUIDOF!IBDA_SignalStatistics;
const GUID IID_IBDA_TIF_REGISTRATION                    = GUIDOF!IBDA_TIF_REGISTRATION;
const GUID IID_IBDA_Topology                            = GUIDOF!IBDA_Topology;
const GUID IID_IBDA_TransportStreamInfo                 = GUIDOF!IBDA_TransportStreamInfo;
const GUID IID_IBDA_TransportStreamSelector             = GUIDOF!IBDA_TransportStreamSelector;
const GUID IID_IBDA_UserActivityService                 = GUIDOF!IBDA_UserActivityService;
const GUID IID_IBDA_VoidTransform                       = GUIDOF!IBDA_VoidTransform;
const GUID IID_IBDA_WMDRMSession                        = GUIDOF!IBDA_WMDRMSession;
const GUID IID_IBDA_WMDRMTuner                          = GUIDOF!IBDA_WMDRMTuner;
const GUID IID_IBPCSatelliteTuner                       = GUIDOF!IBPCSatelliteTuner;
const GUID IID_IBaseFilter                              = GUIDOF!IBaseFilter;
const GUID IID_IBasicAudio                              = GUIDOF!IBasicAudio;
const GUID IID_IBasicVideo                              = GUIDOF!IBasicVideo;
const GUID IID_IBasicVideo2                             = GUIDOF!IBasicVideo2;
const GUID IID_IBroadcastEvent                          = GUIDOF!IBroadcastEvent;
const GUID IID_IBroadcastEventEx                        = GUIDOF!IBroadcastEventEx;
const GUID IID_ICAT                                     = GUIDOF!ICAT;
const GUID IID_ICCSubStreamFiltering                    = GUIDOF!ICCSubStreamFiltering;
const GUID IID_ICameraControl                           = GUIDOF!ICameraControl;
const GUID IID_ICaptionServiceDescriptor                = GUIDOF!ICaptionServiceDescriptor;
const GUID IID_ICaptureGraphBuilder                     = GUIDOF!ICaptureGraphBuilder;
const GUID IID_ICaptureGraphBuilder2                    = GUIDOF!ICaptureGraphBuilder2;
const GUID IID_IChannelIDTuneRequest                    = GUIDOF!IChannelIDTuneRequest;
const GUID IID_IChannelTuneRequest                      = GUIDOF!IChannelTuneRequest;
const GUID IID_IComponent                               = GUIDOF!IComponent;
const GUID IID_IComponentType                           = GUIDOF!IComponentType;
const GUID IID_IComponentTypes                          = GUIDOF!IComponentTypes;
const GUID IID_IComponents                              = GUIDOF!IComponents;
const GUID IID_IComponentsOld                           = GUIDOF!IComponentsOld;
const GUID IID_IConfigAsfWriter                         = GUIDOF!IConfigAsfWriter;
const GUID IID_IConfigAsfWriter2                        = GUIDOF!IConfigAsfWriter2;
const GUID IID_IConfigAviMux                            = GUIDOF!IConfigAviMux;
const GUID IID_IConfigInterleaving                      = GUIDOF!IConfigInterleaving;
const GUID IID_ICreateDevEnum                           = GUIDOF!ICreateDevEnum;
const GUID IID_ICreatePropBagOnRegKey                   = GUIDOF!ICreatePropBagOnRegKey;
const GUID IID_IDDrawExclModeVideo                      = GUIDOF!IDDrawExclModeVideo;
const GUID IID_IDDrawExclModeVideoCallback              = GUIDOF!IDDrawExclModeVideoCallback;
const GUID IID_IDMOQualityControl                       = GUIDOF!IDMOQualityControl;
const GUID IID_IDMOVideoOutputOptimizations             = GUIDOF!IDMOVideoOutputOptimizations;
const GUID IID_IDMOWrapperFilter                        = GUIDOF!IDMOWrapperFilter;
const GUID IID_IDTFilter                                = GUIDOF!IDTFilter;
const GUID IID_IDTFilter2                               = GUIDOF!IDTFilter2;
const GUID IID_IDTFilter3                               = GUIDOF!IDTFilter3;
const GUID IID_IDTFilterConfig                          = GUIDOF!IDTFilterConfig;
const GUID IID_IDTFilterEvents                          = GUIDOF!IDTFilterEvents;
const GUID IID_IDTFilterLicenseRenewal                  = GUIDOF!IDTFilterLicenseRenewal;
const GUID IID_IDVBCLocator                             = GUIDOF!IDVBCLocator;
const GUID IID_IDVBSLocator                             = GUIDOF!IDVBSLocator;
const GUID IID_IDVBSLocator2                            = GUIDOF!IDVBSLocator2;
const GUID IID_IDVBSTuningSpace                         = GUIDOF!IDVBSTuningSpace;
const GUID IID_IDVBTLocator                             = GUIDOF!IDVBTLocator;
const GUID IID_IDVBTLocator2                            = GUIDOF!IDVBTLocator2;
const GUID IID_IDVBTuneRequest                          = GUIDOF!IDVBTuneRequest;
const GUID IID_IDVBTuningSpace                          = GUIDOF!IDVBTuningSpace;
const GUID IID_IDVBTuningSpace2                         = GUIDOF!IDVBTuningSpace2;
const GUID IID_IDVB_BAT                                 = GUIDOF!IDVB_BAT;
const GUID IID_IDVB_DIT                                 = GUIDOF!IDVB_DIT;
const GUID IID_IDVB_EIT                                 = GUIDOF!IDVB_EIT;
const GUID IID_IDVB_EIT2                                = GUIDOF!IDVB_EIT2;
const GUID IID_IDVB_NIT                                 = GUIDOF!IDVB_NIT;
const GUID IID_IDVB_RST                                 = GUIDOF!IDVB_RST;
const GUID IID_IDVB_SDT                                 = GUIDOF!IDVB_SDT;
const GUID IID_IDVB_SIT                                 = GUIDOF!IDVB_SIT;
const GUID IID_IDVB_ST                                  = GUIDOF!IDVB_ST;
const GUID IID_IDVB_TDT                                 = GUIDOF!IDVB_TDT;
const GUID IID_IDVB_TOT                                 = GUIDOF!IDVB_TOT;
const GUID IID_IDVEnc                                   = GUIDOF!IDVEnc;
const GUID IID_IDVRGB219                                = GUIDOF!IDVRGB219;
const GUID IID_IDVSplitter                              = GUIDOF!IDVSplitter;
const GUID IID_IDecimateVideoImage                      = GUIDOF!IDecimateVideoImage;
const GUID IID_IDeferredCommand                         = GUIDOF!IDeferredCommand;
const GUID IID_IDigitalCableLocator                     = GUIDOF!IDigitalCableLocator;
const GUID IID_IDigitalCableTuneRequest                 = GUIDOF!IDigitalCableTuneRequest;
const GUID IID_IDigitalCableTuningSpace                 = GUIDOF!IDigitalCableTuningSpace;
const GUID IID_IDigitalLocator                          = GUIDOF!IDigitalLocator;
const GUID IID_IDirectDrawMediaSample                   = GUIDOF!IDirectDrawMediaSample;
const GUID IID_IDirectDrawMediaSampleAllocator          = GUIDOF!IDirectDrawMediaSampleAllocator;
const GUID IID_IDirectDrawMediaStream                   = GUIDOF!IDirectDrawMediaStream;
const GUID IID_IDirectDrawStreamSample                  = GUIDOF!IDirectDrawStreamSample;
const GUID IID_IDistributorNotify                       = GUIDOF!IDistributorNotify;
const GUID IID_IDrawVideoImage                          = GUIDOF!IDrawVideoImage;
const GUID IID_IDvbCableDeliverySystemDescriptor        = GUIDOF!IDvbCableDeliverySystemDescriptor;
const GUID IID_IDvbComponentDescriptor                  = GUIDOF!IDvbComponentDescriptor;
const GUID IID_IDvbContentDescriptor                    = GUIDOF!IDvbContentDescriptor;
const GUID IID_IDvbContentIdentifierDescriptor          = GUIDOF!IDvbContentIdentifierDescriptor;
const GUID IID_IDvbDataBroadcastDescriptor              = GUIDOF!IDvbDataBroadcastDescriptor;
const GUID IID_IDvbDataBroadcastIDDescriptor            = GUIDOF!IDvbDataBroadcastIDDescriptor;
const GUID IID_IDvbDefaultAuthorityDescriptor           = GUIDOF!IDvbDefaultAuthorityDescriptor;
const GUID IID_IDvbExtendedEventDescriptor              = GUIDOF!IDvbExtendedEventDescriptor;
const GUID IID_IDvbFrequencyListDescriptor              = GUIDOF!IDvbFrequencyListDescriptor;
const GUID IID_IDvbHDSimulcastLogicalChannelDescriptor  = GUIDOF!IDvbHDSimulcastLogicalChannelDescriptor;
const GUID IID_IDvbLinkageDescriptor                    = GUIDOF!IDvbLinkageDescriptor;
const GUID IID_IDvbLogicalChannel2Descriptor            = GUIDOF!IDvbLogicalChannel2Descriptor;
const GUID IID_IDvbLogicalChannelDescriptor             = GUIDOF!IDvbLogicalChannelDescriptor;
const GUID IID_IDvbLogicalChannelDescriptor2            = GUIDOF!IDvbLogicalChannelDescriptor2;
const GUID IID_IDvbMultilingualServiceNameDescriptor    = GUIDOF!IDvbMultilingualServiceNameDescriptor;
const GUID IID_IDvbNetworkNameDescriptor                = GUIDOF!IDvbNetworkNameDescriptor;
const GUID IID_IDvbParentalRatingDescriptor             = GUIDOF!IDvbParentalRatingDescriptor;
const GUID IID_IDvbPrivateDataSpecifierDescriptor       = GUIDOF!IDvbPrivateDataSpecifierDescriptor;
const GUID IID_IDvbSatelliteDeliverySystemDescriptor    = GUIDOF!IDvbSatelliteDeliverySystemDescriptor;
const GUID IID_IDvbServiceAttributeDescriptor           = GUIDOF!IDvbServiceAttributeDescriptor;
const GUID IID_IDvbServiceDescriptor                    = GUIDOF!IDvbServiceDescriptor;
const GUID IID_IDvbServiceDescriptor2                   = GUIDOF!IDvbServiceDescriptor2;
const GUID IID_IDvbServiceListDescriptor                = GUIDOF!IDvbServiceListDescriptor;
const GUID IID_IDvbShortEventDescriptor                 = GUIDOF!IDvbShortEventDescriptor;
const GUID IID_IDvbSiParser                             = GUIDOF!IDvbSiParser;
const GUID IID_IDvbSiParser2                            = GUIDOF!IDvbSiParser2;
const GUID IID_IDvbSubtitlingDescriptor                 = GUIDOF!IDvbSubtitlingDescriptor;
const GUID IID_IDvbTeletextDescriptor                   = GUIDOF!IDvbTeletextDescriptor;
const GUID IID_IDvbTerrestrial2DeliverySystemDescriptor = GUIDOF!IDvbTerrestrial2DeliverySystemDescriptor;
const GUID IID_IDvbTerrestrialDeliverySystemDescriptor  = GUIDOF!IDvbTerrestrialDeliverySystemDescriptor;
const GUID IID_IDvdCmd                                  = GUIDOF!IDvdCmd;
const GUID IID_IDvdControl                              = GUIDOF!IDvdControl;
const GUID IID_IDvdControl2                             = GUIDOF!IDvdControl2;
const GUID IID_IDvdGraphBuilder                         = GUIDOF!IDvdGraphBuilder;
const GUID IID_IDvdInfo                                 = GUIDOF!IDvdInfo;
const GUID IID_IDvdInfo2                                = GUIDOF!IDvdInfo2;
const GUID IID_IDvdState                                = GUIDOF!IDvdState;
const GUID IID_IESCloseMmiEvent                         = GUIDOF!IESCloseMmiEvent;
const GUID IID_IESEvent                                 = GUIDOF!IESEvent;
const GUID IID_IESEventFactory                          = GUIDOF!IESEventFactory;
const GUID IID_IESEventService                          = GUIDOF!IESEventService;
const GUID IID_IESEventServiceConfiguration             = GUIDOF!IESEventServiceConfiguration;
const GUID IID_IESEvents                                = GUIDOF!IESEvents;
const GUID IID_IESFileExpiryDateEvent                   = GUIDOF!IESFileExpiryDateEvent;
const GUID IID_IESIsdbCasResponseEvent                  = GUIDOF!IESIsdbCasResponseEvent;
const GUID IID_IESLicenseRenewalResultEvent             = GUIDOF!IESLicenseRenewalResultEvent;
const GUID IID_IESOpenMmiEvent                          = GUIDOF!IESOpenMmiEvent;
const GUID IID_IESRequestTunerEvent                     = GUIDOF!IESRequestTunerEvent;
const GUID IID_IESValueUpdatedEvent                     = GUIDOF!IESValueUpdatedEvent;
const GUID IID_IETFilter                                = GUIDOF!IETFilter;
const GUID IID_IETFilterConfig                          = GUIDOF!IETFilterConfig;
const GUID IID_IETFilterEvents                          = GUIDOF!IETFilterEvents;
const GUID IID_IEncoderAPI                              = GUIDOF!IEncoderAPI;
const GUID IID_IEnumComponentTypes                      = GUIDOF!IEnumComponentTypes;
const GUID IID_IEnumComponents                          = GUIDOF!IEnumComponents;
const GUID IID_IEnumDMO                                 = GUIDOF!IEnumDMO;
const GUID IID_IEnumFilters                             = GUIDOF!IEnumFilters;
const GUID IID_IEnumGuideDataProperties                 = GUIDOF!IEnumGuideDataProperties;
const GUID IID_IEnumMSVidGraphSegment                   = GUIDOF!IEnumMSVidGraphSegment;
const GUID IID_IEnumMediaTypes                          = GUIDOF!IEnumMediaTypes;
const GUID IID_IEnumPIDMap                              = GUIDOF!IEnumPIDMap;
const GUID IID_IEnumPins                                = GUIDOF!IEnumPins;
const GUID IID_IEnumRegFilters                          = GUIDOF!IEnumRegFilters;
const GUID IID_IEnumStreamBufferRecordingAttrib         = GUIDOF!IEnumStreamBufferRecordingAttrib;
const GUID IID_IEnumStreamIdMap                         = GUIDOF!IEnumStreamIdMap;
const GUID IID_IEnumTuneRequests                        = GUIDOF!IEnumTuneRequests;
const GUID IID_IEnumTuningSpaces                        = GUIDOF!IEnumTuningSpaces;
const GUID IID_IEvalRat                                 = GUIDOF!IEvalRat;
const GUID IID_IFileSinkFilter                          = GUIDOF!IFileSinkFilter;
const GUID IID_IFileSinkFilter2                         = GUIDOF!IFileSinkFilter2;
const GUID IID_IFileSourceFilter                        = GUIDOF!IFileSourceFilter;
const GUID IID_IFilterChain                             = GUIDOF!IFilterChain;
const GUID IID_IFilterGraph                             = GUIDOF!IFilterGraph;
const GUID IID_IFilterGraph2                            = GUIDOF!IFilterGraph2;
const GUID IID_IFilterGraph3                            = GUIDOF!IFilterGraph3;
const GUID IID_IFilterInfo                              = GUIDOF!IFilterInfo;
const GUID IID_IFilterMapper                            = GUIDOF!IFilterMapper;
const GUID IID_IFilterMapper2                           = GUIDOF!IFilterMapper2;
const GUID IID_IFilterMapper3                           = GUIDOF!IFilterMapper3;
const GUID IID_IFrequencyMap                            = GUIDOF!IFrequencyMap;
const GUID IID_IGenericDescriptor                       = GUIDOF!IGenericDescriptor;
const GUID IID_IGenericDescriptor2                      = GUIDOF!IGenericDescriptor2;
const GUID IID_IGetCapabilitiesKey                      = GUIDOF!IGetCapabilitiesKey;
const GUID IID_IGpnvsCommonBase                         = GUIDOF!IGpnvsCommonBase;
const GUID IID_IGraphBuilder                            = GUIDOF!IGraphBuilder;
const GUID IID_IGraphConfig                             = GUIDOF!IGraphConfig;
const GUID IID_IGraphConfigCallback                     = GUIDOF!IGraphConfigCallback;
const GUID IID_IGraphVersion                            = GUIDOF!IGraphVersion;
const GUID IID_IGuideData                               = GUIDOF!IGuideData;
const GUID IID_IGuideDataEvent                          = GUIDOF!IGuideDataEvent;
const GUID IID_IGuideDataLoader                         = GUIDOF!IGuideDataLoader;
const GUID IID_IGuideDataProperty                       = GUIDOF!IGuideDataProperty;
const GUID IID_IIPDVDec                                 = GUIDOF!IIPDVDec;
const GUID IID_IISDBSLocator                            = GUIDOF!IISDBSLocator;
const GUID IID_IISDB_BIT                                = GUIDOF!IISDB_BIT;
const GUID IID_IISDB_CDT                                = GUIDOF!IISDB_CDT;
const GUID IID_IISDB_EMM                                = GUIDOF!IISDB_EMM;
const GUID IID_IISDB_LDT                                = GUIDOF!IISDB_LDT;
const GUID IID_IISDB_NBIT                               = GUIDOF!IISDB_NBIT;
const GUID IID_IISDB_SDT                                = GUIDOF!IISDB_SDT;
const GUID IID_IISDB_SDTT                               = GUIDOF!IISDB_SDTT;
const GUID IID_IIsdbAudioComponentDescriptor            = GUIDOF!IIsdbAudioComponentDescriptor;
const GUID IID_IIsdbCAContractInformationDescriptor     = GUIDOF!IIsdbCAContractInformationDescriptor;
const GUID IID_IIsdbCADescriptor                        = GUIDOF!IIsdbCADescriptor;
const GUID IID_IIsdbCAServiceDescriptor                 = GUIDOF!IIsdbCAServiceDescriptor;
const GUID IID_IIsdbComponentGroupDescriptor            = GUIDOF!IIsdbComponentGroupDescriptor;
const GUID IID_IIsdbDataContentDescriptor               = GUIDOF!IIsdbDataContentDescriptor;
const GUID IID_IIsdbDigitalCopyControlDescriptor        = GUIDOF!IIsdbDigitalCopyControlDescriptor;
const GUID IID_IIsdbDownloadContentDescriptor           = GUIDOF!IIsdbDownloadContentDescriptor;
const GUID IID_IIsdbEmergencyInformationDescriptor      = GUIDOF!IIsdbEmergencyInformationDescriptor;
const GUID IID_IIsdbEventGroupDescriptor                = GUIDOF!IIsdbEventGroupDescriptor;
const GUID IID_IIsdbHierarchicalTransmissionDescriptor  = GUIDOF!IIsdbHierarchicalTransmissionDescriptor;
const GUID IID_IIsdbLogoTransmissionDescriptor          = GUIDOF!IIsdbLogoTransmissionDescriptor;
const GUID IID_IIsdbSIParameterDescriptor               = GUIDOF!IIsdbSIParameterDescriptor;
const GUID IID_IIsdbSeriesDescriptor                    = GUIDOF!IIsdbSeriesDescriptor;
const GUID IID_IIsdbSiParser2                           = GUIDOF!IIsdbSiParser2;
const GUID IID_IIsdbTSInformationDescriptor             = GUIDOF!IIsdbTSInformationDescriptor;
const GUID IID_IIsdbTerrestrialDeliverySystemDescriptor = GUIDOF!IIsdbTerrestrialDeliverySystemDescriptor;
const GUID IID_IKsAggregateControl                      = GUIDOF!IKsAggregateControl;
const GUID IID_IKsControl                               = GUIDOF!IKsControl;
const GUID IID_IKsNodeControl                           = GUIDOF!IKsNodeControl;
const GUID IID_IKsPropertySet                           = GUIDOF!IKsPropertySet;
const GUID IID_IKsTopology                              = GUIDOF!IKsTopology;
const GUID IID_IKsTopologyInfo                          = GUIDOF!IKsTopologyInfo;
const GUID IID_ILanguageComponentType                   = GUIDOF!ILanguageComponentType;
const GUID IID_ILocator                                 = GUIDOF!ILocator;
const GUID IID_IMPEG2Component                          = GUIDOF!IMPEG2Component;
const GUID IID_IMPEG2ComponentType                      = GUIDOF!IMPEG2ComponentType;
const GUID IID_IMPEG2PIDMap                             = GUIDOF!IMPEG2PIDMap;
const GUID IID_IMPEG2StreamIdMap                        = GUIDOF!IMPEG2StreamIdMap;
const GUID IID_IMPEG2TuneRequest                        = GUIDOF!IMPEG2TuneRequest;
const GUID IID_IMPEG2TuneRequestFactory                 = GUIDOF!IMPEG2TuneRequestFactory;
const GUID IID_IMPEG2TuneRequestSupport                 = GUIDOF!IMPEG2TuneRequestSupport;
const GUID IID_IMPEG2_TIF_CONTROL                       = GUIDOF!IMPEG2_TIF_CONTROL;
const GUID IID_IMSEventBinder                           = GUIDOF!IMSEventBinder;
const GUID IID_IMSVidAnalogTuner                        = GUIDOF!IMSVidAnalogTuner;
const GUID IID_IMSVidAnalogTuner2                       = GUIDOF!IMSVidAnalogTuner2;
const GUID IID_IMSVidAnalogTunerEvent                   = GUIDOF!IMSVidAnalogTunerEvent;
const GUID IID_IMSVidAudioRenderer                      = GUIDOF!IMSVidAudioRenderer;
const GUID IID_IMSVidAudioRendererDevices               = GUIDOF!IMSVidAudioRendererDevices;
const GUID IID_IMSVidAudioRendererEvent                 = GUIDOF!IMSVidAudioRendererEvent;
const GUID IID_IMSVidAudioRendererEvent2                = GUIDOF!IMSVidAudioRendererEvent2;
const GUID IID_IMSVidClosedCaptioning                   = GUIDOF!IMSVidClosedCaptioning;
const GUID IID_IMSVidClosedCaptioning2                  = GUIDOF!IMSVidClosedCaptioning2;
const GUID IID_IMSVidClosedCaptioning3                  = GUIDOF!IMSVidClosedCaptioning3;
const GUID IID_IMSVidCompositionSegment                 = GUIDOF!IMSVidCompositionSegment;
const GUID IID_IMSVidCtl                                = GUIDOF!IMSVidCtl;
const GUID IID_IMSVidDataServices                       = GUIDOF!IMSVidDataServices;
const GUID IID_IMSVidDataServicesEvent                  = GUIDOF!IMSVidDataServicesEvent;
const GUID IID_IMSVidDevice                             = GUIDOF!IMSVidDevice;
const GUID IID_IMSVidDevice2                            = GUIDOF!IMSVidDevice2;
const GUID IID_IMSVidDeviceEvent                        = GUIDOF!IMSVidDeviceEvent;
const GUID IID_IMSVidEVR                                = GUIDOF!IMSVidEVR;
const GUID IID_IMSVidEVREvent                           = GUIDOF!IMSVidEVREvent;
const GUID IID_IMSVidEncoder                            = GUIDOF!IMSVidEncoder;
const GUID IID_IMSVidFeature                            = GUIDOF!IMSVidFeature;
const GUID IID_IMSVidFeatureEvent                       = GUIDOF!IMSVidFeatureEvent;
const GUID IID_IMSVidFeatures                           = GUIDOF!IMSVidFeatures;
const GUID IID_IMSVidFilePlayback                       = GUIDOF!IMSVidFilePlayback;
const GUID IID_IMSVidFilePlayback2                      = GUIDOF!IMSVidFilePlayback2;
const GUID IID_IMSVidFilePlaybackEvent                  = GUIDOF!IMSVidFilePlaybackEvent;
const GUID IID_IMSVidGenericSink                        = GUIDOF!IMSVidGenericSink;
const GUID IID_IMSVidGenericSink2                       = GUIDOF!IMSVidGenericSink2;
const GUID IID_IMSVidGraphSegment                       = GUIDOF!IMSVidGraphSegment;
const GUID IID_IMSVidGraphSegmentContainer              = GUIDOF!IMSVidGraphSegmentContainer;
const GUID IID_IMSVidGraphSegmentUserInput              = GUIDOF!IMSVidGraphSegmentUserInput;
const GUID IID_IMSVidInputDevice                        = GUIDOF!IMSVidInputDevice;
const GUID IID_IMSVidInputDeviceEvent                   = GUIDOF!IMSVidInputDeviceEvent;
const GUID IID_IMSVidInputDevices                       = GUIDOF!IMSVidInputDevices;
const GUID IID_IMSVidOutputDevice                       = GUIDOF!IMSVidOutputDevice;
const GUID IID_IMSVidOutputDeviceEvent                  = GUIDOF!IMSVidOutputDeviceEvent;
const GUID IID_IMSVidOutputDevices                      = GUIDOF!IMSVidOutputDevices;
const GUID IID_IMSVidPlayback                           = GUIDOF!IMSVidPlayback;
const GUID IID_IMSVidPlaybackEvent                      = GUIDOF!IMSVidPlaybackEvent;
const GUID IID_IMSVidRect                               = GUIDOF!IMSVidRect;
const GUID IID_IMSVidStreamBufferRecordingControl       = GUIDOF!IMSVidStreamBufferRecordingControl;
const GUID IID_IMSVidStreamBufferSink                   = GUIDOF!IMSVidStreamBufferSink;
const GUID IID_IMSVidStreamBufferSink2                  = GUIDOF!IMSVidStreamBufferSink2;
const GUID IID_IMSVidStreamBufferSink3                  = GUIDOF!IMSVidStreamBufferSink3;
const GUID IID_IMSVidStreamBufferSinkEvent              = GUIDOF!IMSVidStreamBufferSinkEvent;
const GUID IID_IMSVidStreamBufferSinkEvent2             = GUIDOF!IMSVidStreamBufferSinkEvent2;
const GUID IID_IMSVidStreamBufferSinkEvent3             = GUIDOF!IMSVidStreamBufferSinkEvent3;
const GUID IID_IMSVidStreamBufferSinkEvent4             = GUIDOF!IMSVidStreamBufferSinkEvent4;
const GUID IID_IMSVidStreamBufferSource                 = GUIDOF!IMSVidStreamBufferSource;
const GUID IID_IMSVidStreamBufferSource2                = GUIDOF!IMSVidStreamBufferSource2;
const GUID IID_IMSVidStreamBufferSourceEvent            = GUIDOF!IMSVidStreamBufferSourceEvent;
const GUID IID_IMSVidStreamBufferSourceEvent2           = GUIDOF!IMSVidStreamBufferSourceEvent2;
const GUID IID_IMSVidStreamBufferSourceEvent3           = GUIDOF!IMSVidStreamBufferSourceEvent3;
const GUID IID_IMSVidStreamBufferV2SourceEvent          = GUIDOF!IMSVidStreamBufferV2SourceEvent;
const GUID IID_IMSVidTuner                              = GUIDOF!IMSVidTuner;
const GUID IID_IMSVidTunerEvent                         = GUIDOF!IMSVidTunerEvent;
const GUID IID_IMSVidVMR9                               = GUIDOF!IMSVidVMR9;
const GUID IID_IMSVidVRGraphSegment                     = GUIDOF!IMSVidVRGraphSegment;
const GUID IID_IMSVidVideoInputDevice                   = GUIDOF!IMSVidVideoInputDevice;
const GUID IID_IMSVidVideoRenderer                      = GUIDOF!IMSVidVideoRenderer;
const GUID IID_IMSVidVideoRenderer2                     = GUIDOF!IMSVidVideoRenderer2;
const GUID IID_IMSVidVideoRendererDevices               = GUIDOF!IMSVidVideoRendererDevices;
const GUID IID_IMSVidVideoRendererEvent                 = GUIDOF!IMSVidVideoRendererEvent;
const GUID IID_IMSVidVideoRendererEvent2                = GUIDOF!IMSVidVideoRendererEvent2;
const GUID IID_IMSVidWebDVD                             = GUIDOF!IMSVidWebDVD;
const GUID IID_IMSVidWebDVD2                            = GUIDOF!IMSVidWebDVD2;
const GUID IID_IMSVidWebDVDAdm                          = GUIDOF!IMSVidWebDVDAdm;
const GUID IID_IMSVidWebDVDEvent                        = GUIDOF!IMSVidWebDVDEvent;
const GUID IID_IMSVidXDS                                = GUIDOF!IMSVidXDS;
const GUID IID_IMSVidXDSEvent                           = GUIDOF!IMSVidXDSEvent;
const GUID IID_IMceBurnerControl                        = GUIDOF!IMceBurnerControl;
const GUID IID_IMediaBuffer                             = GUIDOF!IMediaBuffer;
const GUID IID_IMediaControl                            = GUIDOF!IMediaControl;
const GUID IID_IMediaEvent                              = GUIDOF!IMediaEvent;
const GUID IID_IMediaEventEx                            = GUIDOF!IMediaEventEx;
const GUID IID_IMediaEventSink                          = GUIDOF!IMediaEventSink;
const GUID IID_IMediaFilter                             = GUIDOF!IMediaFilter;
const GUID IID_IMediaObject                             = GUIDOF!IMediaObject;
const GUID IID_IMediaObjectInPlace                      = GUIDOF!IMediaObjectInPlace;
const GUID IID_IMediaParamInfo                          = GUIDOF!IMediaParamInfo;
const GUID IID_IMediaParams                             = GUIDOF!IMediaParams;
const GUID IID_IMediaPosition                           = GUIDOF!IMediaPosition;
const GUID IID_IMediaPropertyBag                        = GUIDOF!IMediaPropertyBag;
const GUID IID_IMediaSample                             = GUIDOF!IMediaSample;
const GUID IID_IMediaSample2                            = GUIDOF!IMediaSample2;
const GUID IID_IMediaSample2Config                      = GUIDOF!IMediaSample2Config;
const GUID IID_IMediaSeeking                            = GUIDOF!IMediaSeeking;
const GUID IID_IMediaStream                             = GUIDOF!IMediaStream;
const GUID IID_IMediaStreamFilter                       = GUIDOF!IMediaStreamFilter;
const GUID IID_IMediaTypeInfo                           = GUIDOF!IMediaTypeInfo;
const GUID IID_IMemAllocator                            = GUIDOF!IMemAllocator;
const GUID IID_IMemAllocatorCallbackTemp                = GUIDOF!IMemAllocatorCallbackTemp;
const GUID IID_IMemAllocatorNotifyCallbackTemp          = GUIDOF!IMemAllocatorNotifyCallbackTemp;
const GUID IID_IMemInputPin                             = GUIDOF!IMemInputPin;
const GUID IID_IMemoryData                              = GUIDOF!IMemoryData;
const GUID IID_IMixerOCX                                = GUIDOF!IMixerOCX;
const GUID IID_IMixerOCXNotify                          = GUIDOF!IMixerOCXNotify;
const GUID IID_IMpeg2Data                               = GUIDOF!IMpeg2Data;
const GUID IID_IMpeg2Demultiplexer                      = GUIDOF!IMpeg2Demultiplexer;
const GUID IID_IMpeg2Stream                             = GUIDOF!IMpeg2Stream;
const GUID IID_IMpeg2TableFilter                        = GUIDOF!IMpeg2TableFilter;
const GUID IID_IMultiMediaStream                        = GUIDOF!IMultiMediaStream;
const GUID IID_IOverlay                                 = GUIDOF!IOverlay;
const GUID IID_IOverlayNotify                           = GUIDOF!IOverlayNotify;
const GUID IID_IOverlayNotify2                          = GUIDOF!IOverlayNotify2;
const GUID IID_IPAT                                     = GUIDOF!IPAT;
const GUID IID_IPBDAAttributesDescriptor                = GUIDOF!IPBDAAttributesDescriptor;
const GUID IID_IPBDAEntitlementDescriptor               = GUIDOF!IPBDAEntitlementDescriptor;
const GUID IID_IPBDASiParser                            = GUIDOF!IPBDASiParser;
const GUID IID_IPBDA_EIT                                = GUIDOF!IPBDA_EIT;
const GUID IID_IPBDA_Services                           = GUIDOF!IPBDA_Services;
const GUID IID_IPMT                                     = GUIDOF!IPMT;
const GUID IID_IPSITables                               = GUIDOF!IPSITables;
const GUID IID_IPTFilterLicenseRenewal                  = GUIDOF!IPTFilterLicenseRenewal;
const GUID IID_IPersistMediaPropertyBag                 = GUIDOF!IPersistMediaPropertyBag;
const GUID IID_IPersistTuneXml                          = GUIDOF!IPersistTuneXml;
const GUID IID_IPersistTuneXmlUtility                   = GUIDOF!IPersistTuneXmlUtility;
const GUID IID_IPersistTuneXmlUtility2                  = GUIDOF!IPersistTuneXmlUtility2;
const GUID IID_IPin                                     = GUIDOF!IPin;
const GUID IID_IPinConnection                           = GUIDOF!IPinConnection;
const GUID IID_IPinFlowControl                          = GUIDOF!IPinFlowControl;
const GUID IID_IPinInfo                                 = GUIDOF!IPinInfo;
const GUID IID_IQualityControl                          = GUIDOF!IQualityControl;
const GUID IID_IQueueCommand                            = GUIDOF!IQueueCommand;
const GUID IID_IReferenceClock                          = GUIDOF!IReferenceClock;
const GUID IID_IReferenceClock2                         = GUIDOF!IReferenceClock2;
const GUID IID_IReferenceClockTimerControl              = GUIDOF!IReferenceClockTimerControl;
const GUID IID_IRegFilterInfo                           = GUIDOF!IRegFilterInfo;
const GUID IID_IRegisterServiceProvider                 = GUIDOF!IRegisterServiceProvider;
const GUID IID_IRegisterTuner                           = GUIDOF!IRegisterTuner;
const GUID IID_IResourceConsumer                        = GUIDOF!IResourceConsumer;
const GUID IID_IResourceManager                         = GUIDOF!IResourceManager;
const GUID IID_ISBE2Crossbar                            = GUIDOF!ISBE2Crossbar;
const GUID IID_ISBE2EnumStream                          = GUIDOF!ISBE2EnumStream;
const GUID IID_ISBE2FileScan                            = GUIDOF!ISBE2FileScan;
const GUID IID_ISBE2GlobalEvent                         = GUIDOF!ISBE2GlobalEvent;
const GUID IID_ISBE2GlobalEvent2                        = GUIDOF!ISBE2GlobalEvent2;
const GUID IID_ISBE2MediaTypeProfile                    = GUIDOF!ISBE2MediaTypeProfile;
const GUID IID_ISBE2SpanningEvent                       = GUIDOF!ISBE2SpanningEvent;
const GUID IID_ISBE2StreamMap                           = GUIDOF!ISBE2StreamMap;
const GUID IID_ISCTE_EAS                                = GUIDOF!ISCTE_EAS;
const GUID IID_ISIInbandEPG                             = GUIDOF!ISIInbandEPG;
const GUID IID_ISIInbandEPGEvent                        = GUIDOF!ISIInbandEPGEvent;
const GUID IID_IScanningTuner                           = GUIDOF!IScanningTuner;
const GUID IID_IScanningTunerEx                         = GUIDOF!IScanningTunerEx;
const GUID IID_ISectionList                             = GUIDOF!ISectionList;
const GUID IID_ISeekingPassThru                         = GUIDOF!ISeekingPassThru;
const GUID IID_ISelector                                = GUIDOF!ISelector;
const GUID IID_IServiceLocationDescriptor               = GUIDOF!IServiceLocationDescriptor;
const GUID IID_IStreamBufferConfigure                   = GUIDOF!IStreamBufferConfigure;
const GUID IID_IStreamBufferConfigure2                  = GUIDOF!IStreamBufferConfigure2;
const GUID IID_IStreamBufferConfigure3                  = GUIDOF!IStreamBufferConfigure3;
const GUID IID_IStreamBufferDataCounters                = GUIDOF!IStreamBufferDataCounters;
const GUID IID_IStreamBufferInitialize                  = GUIDOF!IStreamBufferInitialize;
const GUID IID_IStreamBufferMediaSeeking                = GUIDOF!IStreamBufferMediaSeeking;
const GUID IID_IStreamBufferMediaSeeking2               = GUIDOF!IStreamBufferMediaSeeking2;
const GUID IID_IStreamBufferRecComp                     = GUIDOF!IStreamBufferRecComp;
const GUID IID_IStreamBufferRecordControl               = GUIDOF!IStreamBufferRecordControl;
const GUID IID_IStreamBufferRecordingAttribute          = GUIDOF!IStreamBufferRecordingAttribute;
const GUID IID_IStreamBufferSink                        = GUIDOF!IStreamBufferSink;
const GUID IID_IStreamBufferSink2                       = GUIDOF!IStreamBufferSink2;
const GUID IID_IStreamBufferSink3                       = GUIDOF!IStreamBufferSink3;
const GUID IID_IStreamBufferSource                      = GUIDOF!IStreamBufferSource;
const GUID IID_IStreamBuilder                           = GUIDOF!IStreamBuilder;
const GUID IID_IStreamSample                            = GUIDOF!IStreamSample;
const GUID IID_ITSDT                                    = GUIDOF!ITSDT;
const GUID IID_ITuneRequest                             = GUIDOF!ITuneRequest;
const GUID IID_ITuneRequestInfo                         = GUIDOF!ITuneRequestInfo;
const GUID IID_ITuneRequestInfoEx                       = GUIDOF!ITuneRequestInfoEx;
const GUID IID_ITuner                                   = GUIDOF!ITuner;
const GUID IID_ITunerCap                                = GUIDOF!ITunerCap;
const GUID IID_ITunerCapEx                              = GUIDOF!ITunerCapEx;
const GUID IID_ITuningSpace                             = GUIDOF!ITuningSpace;
const GUID IID_ITuningSpaceContainer                    = GUIDOF!ITuningSpaceContainer;
const GUID IID_ITuningSpaces                            = GUIDOF!ITuningSpaces;
const GUID IID_IVMRAspectRatioControl                   = GUIDOF!IVMRAspectRatioControl;
const GUID IID_IVMRAspectRatioControl9                  = GUIDOF!IVMRAspectRatioControl9;
const GUID IID_IVMRDeinterlaceControl                   = GUIDOF!IVMRDeinterlaceControl;
const GUID IID_IVMRDeinterlaceControl9                  = GUIDOF!IVMRDeinterlaceControl9;
const GUID IID_IVMRFilterConfig                         = GUIDOF!IVMRFilterConfig;
const GUID IID_IVMRFilterConfig9                        = GUIDOF!IVMRFilterConfig9;
const GUID IID_IVMRImageCompositor                      = GUIDOF!IVMRImageCompositor;
const GUID IID_IVMRImageCompositor9                     = GUIDOF!IVMRImageCompositor9;
const GUID IID_IVMRImagePresenter                       = GUIDOF!IVMRImagePresenter;
const GUID IID_IVMRImagePresenter9                      = GUIDOF!IVMRImagePresenter9;
const GUID IID_IVMRImagePresenterConfig                 = GUIDOF!IVMRImagePresenterConfig;
const GUID IID_IVMRImagePresenterConfig9                = GUIDOF!IVMRImagePresenterConfig9;
const GUID IID_IVMRImagePresenterExclModeConfig         = GUIDOF!IVMRImagePresenterExclModeConfig;
const GUID IID_IVMRMixerBitmap                          = GUIDOF!IVMRMixerBitmap;
const GUID IID_IVMRMixerBitmap9                         = GUIDOF!IVMRMixerBitmap9;
const GUID IID_IVMRMixerControl                         = GUIDOF!IVMRMixerControl;
const GUID IID_IVMRMixerControl9                        = GUIDOF!IVMRMixerControl9;
const GUID IID_IVMRMonitorConfig                        = GUIDOF!IVMRMonitorConfig;
const GUID IID_IVMRMonitorConfig9                       = GUIDOF!IVMRMonitorConfig9;
const GUID IID_IVMRSurface                              = GUIDOF!IVMRSurface;
const GUID IID_IVMRSurface9                             = GUIDOF!IVMRSurface9;
const GUID IID_IVMRSurfaceAllocator                     = GUIDOF!IVMRSurfaceAllocator;
const GUID IID_IVMRSurfaceAllocator9                    = GUIDOF!IVMRSurfaceAllocator9;
const GUID IID_IVMRSurfaceAllocatorEx9                  = GUIDOF!IVMRSurfaceAllocatorEx9;
const GUID IID_IVMRSurfaceAllocatorNotify               = GUIDOF!IVMRSurfaceAllocatorNotify;
const GUID IID_IVMRSurfaceAllocatorNotify9              = GUIDOF!IVMRSurfaceAllocatorNotify9;
const GUID IID_IVMRVideoStreamControl                   = GUIDOF!IVMRVideoStreamControl;
const GUID IID_IVMRVideoStreamControl9                  = GUIDOF!IVMRVideoStreamControl9;
const GUID IID_IVMRWindowlessControl                    = GUIDOF!IVMRWindowlessControl;
const GUID IID_IVMRWindowlessControl9                   = GUIDOF!IVMRWindowlessControl9;
const GUID IID_IVPManager                               = GUIDOF!IVPManager;
const GUID IID_IVideoEncoder                            = GUIDOF!IVideoEncoder;
const GUID IID_IVideoFrameStep                          = GUIDOF!IVideoFrameStep;
const GUID IID_IVideoProcAmp                            = GUIDOF!IVideoProcAmp;
const GUID IID_IVideoWindow                             = GUIDOF!IVideoWindow;
const GUID IID_IXDSCodec                                = GUIDOF!IXDSCodec;
const GUID IID_IXDSCodecConfig                          = GUIDOF!IXDSCodecConfig;
const GUID IID_IXDSCodecEvents                          = GUIDOF!IXDSCodecEvents;
const GUID IID_IXDSToRat                                = GUIDOF!IXDSToRat;
const GUID IID__IMSVidCtlEvents                         = GUIDOF!_IMSVidCtlEvents;
