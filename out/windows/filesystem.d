// Written in the D programming language.

module windows.filesystem;

public import windows.core;
public import windows.com : HRESULT, IConnectionPointContainer, IUnknown;
public import windows.security : SID;
public import windows.systemservices : BOOL, DETECTION_TYPE, DISK_CACHE_RETENTION_PRIORITY,
                                       FILE_SEGMENT_ELEMENT, FILE_STORAGE_TIER_CLASS,
                                       HANDLE, LARGE_INTEGER, OVERLAPPED,
                                       SECURITY_ATTRIBUTES, SHRINK_VOLUME_REQUEST_TYPES,
                                       STORAGE_BUS_TYPE, ULARGE_INTEGER;
public import windows.windowsprogramming : FILETIME, SYSTEMTIME;

extern(Windows):


// Enums


alias FIND_FIRST_EX_FLAGS = int;
enum : int
{
    FIND_FIRST_EX_CASE_SENSITIVE       = 0x00000001,
    FIND_FIRST_EX_LARGE_FETCH          = 0x00000002,
    FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY = 0x00000004,
}

alias FILE_NOTIFY_CHANGE = int;
enum : int
{
    FILE_NOTIFY_CHANGE_FILE_NAME   = 0x00000001,
    FILE_NOTIFY_CHANGE_DIR_NAME    = 0x00000002,
    FILE_NOTIFY_CHANGE_ATTRIBUTES  = 0x00000004,
    FILE_NOTIFY_CHANGE_SIZE        = 0x00000008,
    FILE_NOTIFY_CHANGE_LAST_WRITE  = 0x00000010,
    FILE_NOTIFY_CHANGE_LAST_ACCESS = 0x00000020,
    FILE_NOTIFY_CHANGE_CREATION    = 0x00000040,
    FILE_NOTIFY_CHANGE_SECURITY    = 0x00000100,
}

alias DEFINE_DOS_DEVICE_FLAGS = int;
enum : int
{
    DDD_RAW_TARGET_PATH       = 0x00000001,
    DDD_REMOVE_DEFINITION     = 0x00000002,
    DDD_EXACT_MATCH_ON_REMOVE = 0x00000004,
    DDD_NO_BROADCAST_SYSTEM   = 0x00000008,
    DDD_LUID_BROADCAST_DRIVE  = 0x00000010,
}

alias FILE_CREATE_FLAGS = int;
enum : int
{
    CREATE_NEW        = 0x00000001,
    CREATE_ALWAYS     = 0x00000002,
    OPEN_EXISTING     = 0x00000003,
    OPEN_ALWAYS       = 0x00000004,
    TRUNCATE_EXISTING = 0x00000005,
}

alias FILE_SHARE_FLAGS = int;
enum : int
{
    FILE_SHARE_NONE   = 0x00000000,
    FILE_SHARE_DELETE = 0x00000004,
    FILE_SHARE_READ   = 0x00000001,
    FILE_SHARE_WRITE  = 0x00000002,
}

alias FILE_FLAGS_AND_ATTRIBUTES = int;
enum : int
{
    FILE_ATTRIBUTE_READONLY              = 0x00000001,
    FILE_ATTRIBUTE_HIDDEN                = 0x00000002,
    FILE_ATTRIBUTE_SYSTEM                = 0x00000004,
    FILE_ATTRIBUTE_DIRECTORY             = 0x00000010,
    FILE_ATTRIBUTE_ARCHIVE               = 0x00000020,
    FILE_ATTRIBUTE_DEVICE                = 0x00000040,
    FILE_ATTRIBUTE_NORMAL                = 0x00000080,
    FILE_ATTRIBUTE_TEMPORARY             = 0x00000100,
    FILE_ATTRIBUTE_SPARSE_FILE           = 0x00000200,
    FILE_ATTRIBUTE_REPARSE_POINT         = 0x00000400,
    FILE_ATTRIBUTE_COMPRESSED            = 0x00000800,
    FILE_ATTRIBUTE_OFFLINE               = 0x00001000,
    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED   = 0x00002000,
    FILE_ATTRIBUTE_ENCRYPTED             = 0x00004000,
    FILE_ATTRIBUTE_INTEGRITY_STREAM      = 0x00008000,
    FILE_ATTRIBUTE_VIRTUAL               = 0x00010000,
    FILE_ATTRIBUTE_NO_SCRUB_DATA         = 0x00020000,
    FILE_ATTRIBUTE_EA                    = 0x00040000,
    FILE_ATTRIBUTE_PINNED                = 0x00080000,
    FILE_ATTRIBUTE_UNPINNED              = 0x00100000,
    FILE_ATTRIBUTE_RECALL_ON_OPEN        = 0x00040000,
    FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS = 0x00400000,
}

alias FILE_ACCESS_FLAGS = int;
enum : int
{
    FILE_READ_DATA            = 0x00000001,
    FILE_LIST_DIRECTORY       = 0x00000001,
    FILE_WRITE_DATA           = 0x00000002,
    FILE_ADD_FILE             = 0x00000002,
    FILE_APPEND_DATA          = 0x00000004,
    FILE_ADD_SUBDIRECTORY     = 0x00000004,
    FILE_CREATE_PIPE_INSTANCE = 0x00000004,
    FILE_READ_EA              = 0x00000008,
    FILE_WRITE_EA             = 0x00000010,
    FILE_EXECUTE              = 0x00000020,
    FILE_TRAVERSE             = 0x00000020,
    FILE_DELETE_CHILD         = 0x00000040,
    FILE_READ_ATTRIBUTES      = 0x00000080,
    FILE_WRITE_ATTRIBUTES     = 0x00000100,
    READ_CONTROL              = 0x00020000,
    SYNCHRONIZE               = 0x00100000,
    STANDARD_RIGHTS_REQUIRED  = 0x000f0000,
    STANDARD_RIGHTS_READ      = 0x00020000,
    STANDARD_RIGHTS_WRITE     = 0x00020000,
    STANDARD_RIGHTS_EXECUTE   = 0x00020000,
    STANDARD_RIGHTS_ALL       = 0x001f0000,
    SPECIFIC_RIGHTS_ALL       = 0x0000ffff,
    FILE_ALL_ACCESS           = 0x001f01ff,
    FILE_GENERIC_READ         = 0x00120089,
    FILE_GENERIC_WRITE        = 0x00120116,
    FILE_GENERIC_EXECUTE      = 0x001200a0,
}

///Defines the outcomes (results) that KTM can assign to a transaction.
alias TRANSACTION_OUTCOME = int;
enum : int
{
    ///The transaction has not yet been committed or rolled back.
    TransactionOutcomeUndetermined = 0x00000001,
    ///The transaction has been committed.
    TransactionOutcomeCommitted    = 0x00000002,
    ///The transaction has been rolled back.
    TransactionOutcomeAborted      = 0x00000003,
}

///Defines values that are used with the FindFirstFileEx function to specify the information level of the returned data.
alias FINDEX_INFO_LEVELS = int;
enum : int
{
    ///The FindFirstFileEx function retrieves a standard set of attribute information. The data is returned in a
    ///WIN32_FIND_DATA structure.
    FindExInfoStandard     = 0x00000000,
    ///The FindFirstFileEx function does not query the short file name, improving overall enumeration speed. The data is
    ///returned in a WIN32_FIND_DATA structure, and the <b>cAlternateFileName</b> member is always a <b>NULL</b> string.
    ///<b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported until
    ///Windows Server 2008 R2 and Windows 7.
    FindExInfoBasic        = 0x00000001,
    ///This value is used for validation. Supported values are less than this value.
    FindExInfoMaxInfoLevel = 0x00000002,
}

///Defines values that are used with the FindFirstFileEx function to specify the type of filtering to perform.
alias FINDEX_SEARCH_OPS = int;
enum : int
{
    ///The search for a file that matches a specified file name. The <i>lpSearchFilter</i> parameter of FindFirstFileEx
    ///must be <b>NULL</b> when this search operation is used.
    FindExSearchNameMatch          = 0x00000000,
    ///This is an advisory flag. If the file system supports directory filtering, the function searches for a file that
    ///matches the specified name and is also a directory. If the file system does not support directory filtering, this
    ///flag is silently ignored. The <i>lpSearchFilter</i> parameter of the FindFirstFileEx function must be <b>NULL</b>
    ///when this search value is used. If directory filtering is desired, this flag can be used on all file systems, but
    ///because it is an advisory flag and only affects file systems that support it, the application must examine the
    ///file attribute data stored in the <i>lpFindFileData</i> parameter of the FindFirstFileEx function to determine
    ///whether the function has returned a handle to a directory.
    FindExSearchLimitToDirectories = 0x00000001,
    ///This filtering type is not available. For more information, see Device Interface Classes.
    FindExSearchLimitToDevices     = 0x00000002,
    FindExSearchMaxSearchOp        = 0x00000003,
}

///Indicates the possible types of information that an application that calls the ReadDirectoryChangesExW function can
///request.
alias READ_DIRECTORY_NOTIFY_INFORMATION_CLASS = int;
enum : int
{
    ///The ReadDirectoryChangesExW function should provide information that describes the changes within the specified
    ///directory, and return this information in the output buffer in the form of FILE_NOTIFY_INFORMATION structures.
    ReadDirectoryNotifyInformation         = 0x00000001,
    ///The ReadDirectoryChangesExW function should provide extended information that describes the changes within the
    ///specified directory, and return this information in the output buffer in the form of
    ///FILE_NOTIFY_EXTENDED_INFORMATION structures.
    ReadDirectoryNotifyExtendedInformation = 0x00000002,
}

///Defines values that are used with the GetFileAttributesEx and GetFileAttributesTransacted functions to specify the
///information level of the returned data.
alias GET_FILEEX_INFO_LEVELS = int;
enum : int
{
    ///The GetFileAttributesEx or GetFileAttributesTransacted function retrieves a standard set of attribute
    ///information. The data is returned in a WIN32_FILE_ATTRIBUTE_DATA structure.
    GetFileExInfoStandard = 0x00000000,
    ///One greater than the maximum value. Valid values for this enumeration will be less than this value.
    GetFileExMaxInfoLevel = 0x00000001,
}

///Identifies the type of file information that GetFileInformationByHandleEx should retrieve or
///SetFileInformationByHandle should set.
alias FILE_INFO_BY_HANDLE_CLASS = int;
enum : int
{
    ///Minimal information for the file should be retrieved or set. Used for file handles. See FILE_BASIC_INFO.
    FileBasicInfo                  = 0x00000000,
    ///Extended information for the file should be retrieved. Used for file handles. Use only when calling
    ///GetFileInformationByHandleEx. See FILE_STANDARD_INFO.
    FileStandardInfo               = 0x00000001,
    ///The file name should be retrieved. Used for any handles. Use only when calling GetFileInformationByHandleEx. See
    ///FILE_NAME_INFO.
    FileNameInfo                   = 0x00000002,
    ///The file name should be changed. Used for file handles. Use only when calling SetFileInformationByHandle. See
    ///FILE_RENAME_INFO.
    FileRenameInfo                 = 0x00000003,
    ///The file should be deleted. Used for any handles. Use only when calling SetFileInformationByHandle. See
    ///FILE_DISPOSITION_INFO.
    FileDispositionInfo            = 0x00000004,
    ///The file allocation information should be changed. Used for file handles. Use only when calling
    ///SetFileInformationByHandle. See FILE ALLOCATION INFO.
    FileAllocationInfo             = 0x00000005,
    ///The end of the file should be set. Use only when calling SetFileInformationByHandle. See FILE_END_OF_FILE_INFO.
    FileEndOfFileInfo              = 0x00000006,
    ///File stream information for the specified file should be retrieved. Used for any handles. Use only when calling
    ///GetFileInformationByHandleEx. See FILE_STREAM_INFO.
    FileStreamInfo                 = 0x00000007,
    ///File compression information should be retrieved. Used for any handles. Use only when calling
    ///GetFileInformationByHandleEx. See FILE_COMPRESSION_INFO.
    FileCompressionInfo            = 0x00000008,
    ///File attribute information should be retrieved. Used for any handles. Use only when calling
    ///GetFileInformationByHandleEx. See FILE_ATTRIBUTE_TAG_INFO.
    FileAttributeTagInfo           = 0x00000009,
    ///Files in the specified directory should be retrieved. Used for directory handles. Use only when calling
    ///GetFileInformationByHandleEx. The number of files returned for each call to <b>GetFileInformationByHandleEx</b>
    ///depends on the size of the buffer that is passed to the function. Any subsequent calls to
    ///<b>GetFileInformationByHandleEx</b> on the same handle will resume the enumeration operation after the last file
    ///is returned. See FILE_ID_BOTH_DIR_INFO.
    FileIdBothDirectoryInfo        = 0x0000000a,
    ///Identical to <b>FileIdBothDirectoryInfo</b>, but forces the enumeration operation to start again from the
    ///beginning. See FILE_ID_BOTH_DIR_INFO.
    FileIdBothDirectoryRestartInfo = 0x0000000b,
    ///Priority hint information should be set. Use only when calling SetFileInformationByHandle. See
    ///FILE_IO_PRIORITY_HINT_INFO.
    FileIoPriorityHintInfo         = 0x0000000c,
    ///File remote protocol information should be retrieved. Use for any handles. Use only when calling
    ///GetFileInformationByHandleEx. See FILE_REMOTE_PROTOCOL_INFO.
    FileRemoteProtocolInfo         = 0x0000000d,
    ///Files in the specified directory should be retrieved. Used for directory handles. Use only when calling
    ///GetFileInformationByHandleEx. See FILE_FULL_DIR_INFO. <b>Windows Server 2008 R2, Windows 7, Windows Server 2008,
    ///Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported before Windows 8 and Windows
    ///Server 2012
    FileFullDirectoryInfo          = 0x0000000e,
    ///Identical to <b>FileFullDirectoryInfo</b>, but forces the enumeration operation to start again from the
    ///beginning. Use only when calling GetFileInformationByHandleEx. See FILE_FULL_DIR_INFO. <b>Windows Server 2008 R2,
    ///Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not
    ///supported before Windows 8 and Windows Server 2012
    FileFullDirectoryRestartInfo   = 0x0000000f,
    ///File storage information should be retrieved. Use for any handles. Use only when calling
    ///GetFileInformationByHandleEx. See FILE_STORAGE_INFO. <b>Windows Server 2008 R2, Windows 7, Windows Server 2008,
    ///Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported before Windows 8 and Windows
    ///Server 2012
    FileStorageInfo                = 0x00000010,
    ///File alignment information should be retrieved. Use for any handles. Use only when calling
    ///GetFileInformationByHandleEx. See FILE_ALIGNMENT_INFO. <b>Windows Server 2008 R2, Windows 7, Windows Server 2008,
    ///Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported before Windows 8 and Windows
    ///Server 2012
    FileAlignmentInfo              = 0x00000011,
    ///File information should be retrieved. Use for any handles. Use only when calling GetFileInformationByHandleEx.
    ///See FILE_ID_INFO. <b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003
    ///and Windows XP: </b>This value is not supported before Windows 8 and Windows Server 2012
    FileIdInfo                     = 0x00000012,
    ///Files in the specified directory should be retrieved. Used for directory handles. Use only when calling
    ///GetFileInformationByHandleEx. See FILE_ID_EXTD_DIR_INFO. <b>Windows Server 2008 R2, Windows 7, Windows Server
    ///2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported before Windows 8 and
    ///Windows Server 2012
    FileIdExtdDirectoryInfo        = 0x00000013,
    ///Identical to <b>FileIdExtdDirectoryInfo</b>, but forces the enumeration operation to start again from the
    ///beginning. Use only when calling GetFileInformationByHandleEx. See FILE_ID_EXTD_DIR_INFO. <b>Windows Server 2008
    ///R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not
    ///supported before Windows 8 and Windows Server 2012
    FileIdExtdDirectoryRestartInfo = 0x00000014,
    FileDispositionInfoEx          = 0x00000015,
    FileRenameInfoEx               = 0x00000016,
    FileCaseSensitiveInfo          = 0x00000017,
    FileNormalizedNameInfo         = 0x00000018,
    ///This value is used for validation. Supported values are less than this value.
    MaximumFileInfoByHandleClass   = 0x00000019,
}

///Used by the [STORAGE_PROPERTY_QUERY](ns-winioctl-storage_property_query.md) structure passed to the
///[IOCTL_STORAGE_QUERY_PROPERTY](ni-winioctl-ioctl_storage_query_property.md) control code to indicate what information
///is returned about a property of a storage device or adapter.
alias STORAGE_QUERY_TYPE = int;
enum : int
{
    ///Instructs the driver to return an appropriate descriptor.
    PropertyStandardQuery   = 0x00000000,
    ///Instructs the driver to report whether the descriptor is supported.
    PropertyExistsQuery     = 0x00000001,
    ///Not currently supported. Do not use.
    PropertyMaskQuery       = 0x00000002,
    ///Specifies the upper limit of the list of query types. This is used to validate the query type.
    PropertyQueryMaxDefined = 0x00000003,
}

///Enumerates the possible values of the **PropertyId** member of the
///[STORAGE_PROPERTY_QUERY](ns-winioctl-storage_property_query.md) structure passed as input to the
///[IOCTL_STORAGE_QUERY_PROPERTY](ni-winioctl-ioctl_storage_query_property.md) request to retrieve the properties of a
///storage device or adapter.
alias STORAGE_PROPERTY_ID = int;
enum : int
{
    ///Indicates that the caller is querying for the device descriptor,
    ///[STORAGE_DEVICE_DESCRIPTOR](ns-winioctl-storage_device_descriptor.md).
    StorageDeviceProperty                  = 0x00000000,
    ///Indicates that the caller is querying for the adapter descriptor,
    ///[STORAGE_ADAPTER_DESCRIPTOR](ns-winioctl-storage_adapter_descriptor.md).
    StorageAdapterProperty                 = 0x00000001,
    ///Indicates that the caller is querying for the device identifiers provided with the SCSI vital product data pages.
    ///Data is returned using the [STORAGE_DEVICE_ID_DESCRIPTOR](ns-winioctl-storage_device_id_descriptor.md) structure.
    StorageDeviceIdProperty                = 0x00000002,
    ///**Intended for driver usage.** Indicates that the caller is querying for the unique device identifiers. Data is
    ///returned using the **STORAGE_DEVICE_UNIQUE_IDENTIFIER** structure (see the storduid.h header in the DDK).
    ///**Windows Server 2003 and Windows XP:** This value is not supported before Windows Vista and Windows Server 2008.
    StorageDeviceUniqueIdProperty          = 0x00000003,
    ///Indicates that the caller is querying for the write cache property. Data is returned using the
    ///[STORAGE_WRITE_CACHE_PROPERTY](ns-winioctl-storage_write_cache_property.md) structure. **Windows Server 2003 and
    ///Windows XP:** This value is not supported before Windows Vista and Windows Server 2008.
    StorageDeviceWriteCacheProperty        = 0x00000004,
    ///Reserved for system use.
    StorageMiniportProperty                = 0x00000005,
    ///Indicates that the caller is querying for the access alignment descriptor,
    ///[STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR](ns-winioctl-storage_access_alignment_descriptor.md). **Windows Server 2003
    ///and Windows XP:** This value is not supported before Windows Vista and Windows Server 2008.
    StorageAccessAlignmentProperty         = 0x00000006,
    ///Indicates that the caller is querying for the seek penalty descriptor,
    ///[DEVICE_SEEK_PENALTY_DESCRIPTOR](ns-winioctl-device_seek_penalty_descriptor.md). **Windows Server 2008, Windows
    ///Vista, Windows Server 2003 and Windows XP:** This value is not supported before Windows 7 and Windows Server 2008
    ///R2.
    StorageDeviceSeekPenaltyProperty       = 0x00000007,
    ///Indicates that the caller is querying for the trim descriptor,
    ///[DEVICE_TRIM_DESCRIPTOR](ns-winioctl-device_trim_descriptor.md). **Windows Server 2008, Windows Vista, Windows
    ///Server 2003 and Windows XP:** This value is not supported before Windows 7 and Windows Server 2008 R2.
    StorageDeviceTrimProperty              = 0x00000008,
    ///Reserved for system use.
    StorageDeviceWriteAggregationProperty  = 0x00000009,
    ///Reserved for system use.
    StorageDeviceDeviceTelemetryProperty   = 0x0000000a,
    ///Indicates that the caller is querying for the logical block provisioning property. Data is returned using the
    ///[DEVICE_LB_PROVISIONING_DESCRIPTOR](ns-winioctl-device_lb_provisioning_descriptor.md) structure. **Windows 7,
    ///Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:** This value is
    ///not supported before Windows 8 and Windows Server 2012.
    StorageDeviceLBProvisioningProperty    = 0x0000000b,
    ///Indicates that the caller is querying for the device power descriptor. Data is returned using the
    ///[DEVICE_POWER_DESCRIPTOR](ns-winioctl-device_power_descriptor.md) structure. **Windows 7, Windows Server 2008 R2,
    ///Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:** This value is not supported before
    ///Windows 8 and Windows Server 2012.
    StorageDevicePowerProperty             = 0x0000000c,
    ///Indicates that the caller is querying for the copy offload parameters property. Data is returned using the
    ///[DEVICE_COPY_OFFLOAD_DESCRIPTOR](ns-winioctl-device_copy_offload_descriptor.md) structure. **Windows 7, Windows
    ///Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:** This value is not
    ///supported before Windows 8 and Windows Server 2012.
    StorageDeviceCopyOffloadProperty       = 0x0000000d,
    ///Reserved for system use.
    StorageDeviceResiliencyProperty        = 0x0000000e,
    ///Indicates that the caller is querying for the medium product type. Data is returned using the
    ///[STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR](./ns-winioctl-storage_medium_product_type_descriptor.md) structure.
    StorageDeviceMediumProductType         = 0x0000000f,
    ///Indicates that the caller is querying for RPMB support and properties. Data is returned using the
    ///[STORAGE_RPMB_DESCRIPTOR](ns-winioctl-storage_rpmb_descriptor.md) structure.
    StorageAdapterRpmbProperty             = 0x00000010,
    ///Provides info on the storage adapter encryption capabilities. This is currently supported on UFS (Universal Flash
    ///Storage) adapters.
    StorageAdapterCryptoProperty           = 0x00000011,
    ///Indicates that the caller is querying for the device I/O capability property. Data is returned using the
    ///[DEVICE_IO_CAPABILITY_DESCRIPTOR](ns-winioctl-storage_device_io_capability_descriptor.md) structure.
    StorageDeviceIoCapabilityProperty      = 0x00000030,
    ///Indicates that the caller is querying for protocol-specific data from the adapter. Data is returned using the
    ///[STORAGE_PROTOCOL_DATA_DESCRIPTOR](ns-winioctl-storage_protocol_data_descriptor.md) structure. See the remarks
    ///for more info.
    StorageAdapterProtocolSpecificProperty = 0x00000031,
    ///Indicates that the caller is querying for protocol-specific data from the device. Data is returned using the
    ///[STORAGE_PROTOCOL_DATA_DESCRIPTOR](ns-winioctl-storage_protocol_data_descriptor.md) structure. See the remarks
    ///for more info.
    StorageDeviceProtocolSpecificProperty  = 0x00000032,
    ///Indicates that the caller is querying temperature data from the adapter. Data is returned using the
    ///[STORAGE_TEMPERATURE_DATA_DESCRIPTOR](ns-winioctl-storage_temperature_data_descriptor.md) structure.
    StorageAdapterTemperatureProperty      = 0x00000033,
    ///Indicates that the caller is querying for temperature data from the device. Data is returned using the
    ///[STORAGE_TEMPERATURE_DATA_DESCRIPTOR](ns-winioctl-storage_temperature_data_descriptor.md) structure.
    StorageDeviceTemperatureProperty       = 0x00000034,
    ///Indicates that the caller is querying for topology information from the adapter. Data is returned using the
    ///[STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR](ns-winioctl-storage_physical_topology_descriptor.md) structure.
    StorageAdapterPhysicalTopologyProperty = 0x00000035,
    ///Indicates that the caller is querying for topology information from the device. Data is returned using the
    ///[STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR](ns-winioctl-storage_physical_topology_descriptor.md) structure.
    StorageDevicePhysicalTopologyProperty  = 0x00000036,
    ///Reserved for future use.
    StorageDeviceAttributesProperty        = 0x00000037,
    ///Provides health information about the storage device (specifically for the persistent memory stack).
    StorageDeviceManagementStatus          = 0x00000038,
    ///Indicates that the caller is querying for the adapter serial number. Data is returned using the
    ///[STORAGE_ADAPTER_SERIAL_NUMBER](ns-winioctl-storage_adapter_serial_number.md) structure.
    StorageAdapterSerialNumberProperty     = 0x00000039,
    ///Reserved for system use.
    StorageDeviceLocationProperty          = 0x0000003a,
    ///Provides the non-uniform memory access (NUMA) node of the storage device.
    StorageDeviceNumaProperty              = 0x0000003b,
    ///Reserved for system use.
    StorageDeviceZonedDeviceProperty       = 0x0000003c,
    ///Provides the unsafe shutdown count value used to determine if the device data might have been lost during a power
    ///loss event (specifically for the persistent memory stack).
    StorageDeviceUnsafeShutdownCount       = 0x0000003d,
    ///Provides info on how many bytes have been read/write from a solid-state drive (SSD). This property is supported
    ///only for Non-Volatile Memory Express (NVMe) devices that implement a certain NVMe feature.
    StorageDeviceEnduranceProperty         = 0x0000003e,
}

///Reserved for system use.
alias STORAGE_PORT_CODE_SET = int;
enum : int
{
    ///Indicates an unknown storage adapter driver type.
    StoragePortCodeSetReserved  = 0x00000000,
    ///Storage adapter driver is a Storport-miniport driver.
    StoragePortCodeSetStorport  = 0x00000001,
    ///Storage adapter driver is a SCSI Port-miniport driver.
    StoragePortCodeSetSCSIport  = 0x00000002,
    ///Storage adapter driver is the Spaceport driver.
    StoragePortCodeSetSpaceport = 0x00000003,
    ///Storage adapter driver is an ATA-port miniport driver.
    StoragePortCodeSetATAport   = 0x00000004,
    ///Storage adapter driver is the USB-storage port driver.
    StoragePortCodeSetUSBport   = 0x00000005,
    ///Storage adapter driver is the SBP2 port driver.
    StoragePortCodeSetSBP2port  = 0x00000006,
    ///Storage adapter driver is an SD-port miniport driver.
    StoragePortCodeSetSDport    = 0x00000007,
}

///Specifies the protocol of a storage device.
alias STORAGE_PROTOCOL_TYPE = int;
enum : int
{
    ///Unknown protocol type.
    ProtocolTypeUnknown     = 0x00000000,
    ///SCSI protocol type.
    ProtocolTypeScsi        = 0x00000001,
    ///ATA protocol type.
    ProtocolTypeAta         = 0x00000002,
    ///NVMe protocol type.
    ProtocolTypeNvme        = 0x00000003,
    ///SD protocol type.
    ProtocolTypeSd          = 0x00000004,
    ProtocolTypeUfs         = 0x00000005,
    ///Vendor-specific protocol type.
    ProtocolTypeProprietary = 0x0000007e,
    ProtocolTypeMaxReserved = 0x0000007f,
}

///Describes the type of NVMe protocol-specific data that's to be queried during an
///[IOCTL_STORAGE_QUERY_PROPERTY](ni-winioctl-ioctl_storage_query_property.md) request.
alias STORAGE_PROTOCOL_NVME_DATA_TYPE = int;
enum : int
{
    ///Unknown data type.
    NVMeDataTypeUnknown  = 0x00000000,
    ///Identify data type. This can be either Identify Controller data or Identify Namespace data. When this type of
    ///data is being queried, the ProtocolDataRequestValue field of
    ///[STORAGE_PROTOCOL_SPECIFIC_DATA](ns-winioctl-storage_protocol_specific_data.md) will have a value of
    ///**NVME_IDENTIFY_CNS_CONTROLLER** for adapter or **NVME_IDENTIFY_CNS_SPECIFIC_NAMESPACE** for namespace. If the
    ///ProtocolDataRequestValue is **NVME_IDENTIFY_CNS_SPECIFIC_NAMESPACE**, the ProtocolDataRequestSubValue field from
    ///the **STORAGE_PROTOCOL_SPECIFIC_DATA** structure will have a value of the namespace ID.
    NVMeDataTypeIdentify = 0x00000001,
    ///Log page data type.
    NVMeDataTypeLogPage  = 0x00000002,
    ///Feature data type.
    NVMeDataTypeFeature  = 0x00000003,
}

///<p class="CCE_Message">[Some information relates to pre-released product which may be substantially modified before
///it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information
///provided here.] The ATA protocol data type.
alias STORAGE_PROTOCOL_ATA_DATA_TYPE = int;
enum : int
{
    ///Unknown data type.
    AtaDataTypeUnknown  = 0x00000000,
    ///Identify device data type.
    AtaDataTypeIdentify = 0x00000001,
    ///Log page data type.
    AtaDataTypeLogPage  = 0x00000002,
}

///Specifies the form factor of a device.
alias STORAGE_DEVICE_FORM_FACTOR = int;
enum : int
{
    FormFactorUnknown    = 0x00000000,
    ///3.5-inch nominal form factor.
    FormFactor3_5        = 0x00000001,
    ///2.5-inch nominal form factor.
    FormFactor2_5        = 0x00000002,
    ///1.8-inch nominal form factor.
    FormFactor1_8        = 0x00000003,
    ///Less than 1.8-inch nominal form factor.
    FormFactor1_8Less    = 0x00000004,
    ///Embedded on board.
    FormFactorEmbedded   = 0x00000005,
    ///Memory card such as SD, CF.
    FormFactorMemoryCard = 0x00000006,
    ///mSATA
    FormFactormSata      = 0x00000007,
    ///M.2
    FormFactorM_2        = 0x00000008,
    ///PCIe card plug into slot.
    FormFactorPCIeBoard  = 0x00000009,
    FormFactorDimm       = 0x0000000a,
}

///Specifies the health status of a storage component.
alias STORAGE_COMPONENT_HEALTH_STATUS = int;
enum : int
{
    HealthStatusUnknown   = 0x00000000,
    HealthStatusNormal    = 0x00000001,
    HealthStatusThrottled = 0x00000002,
    HealthStatusWarning   = 0x00000003,
    HealthStatusDisabled  = 0x00000004,
    HealthStatusFailed    = 0x00000005,
}

///Specifies the cache type.
alias WRITE_CACHE_TYPE = int;
enum : int
{
    ///The system cannot report the type of the write cache.
    WriteCacheTypeUnknown      = 0x00000000,
    ///The device does not have a write cache.
    WriteCacheTypeNone         = 0x00000001,
    ///The device has a write-back cache.
    WriteCacheTypeWriteBack    = 0x00000002,
    ///The device has a write-through cache.
    WriteCacheTypeWriteThrough = 0x00000003,
}

///Indicates whether the write cache is enabled or disabled.
alias WRITE_CACHE_ENABLE = int;
enum : int
{
    ///The system cannot report whether the device's write cache is enabled or disabled.
    WriteCacheEnableUnknown = 0x00000000,
    ///The device's write cache is disabled.
    WriteCacheDisabled      = 0x00000001,
    ///The device's write cache is enabled.
    WriteCacheEnabled       = 0x00000002,
}

///Indicates whether the write cache features of a device are changeable.
alias WRITE_CACHE_CHANGE = int;
enum : int
{
    ///The system cannot report the write cache change capability of the device.
    WriteCacheChangeUnknown = 0x00000000,
    ///Host software cannot change the characteristics of the device's write cache.
    WriteCacheNotChangeable = 0x00000001,
    ///Host software can change the characteristics of the device's write cache.
    WriteCacheChangeable    = 0x00000002,
}

///Specifies whether a storage device supports write-through caching.
alias WRITE_THROUGH = int;
enum : int
{
    ///Indicates that no information is available about the write-through capabilities of the device.
    WriteThroughUnknown      = 0x00000000,
    ///Indicates that the device does not support write-through caching.
    WriteThroughNotSupported = 0x00000001,
    ///Indicates that the device supports write-through caching.
    WriteThroughSupported    = 0x00000002,
}

///The units of the maximum power threshold.
alias STORAGE_DEVICE_POWER_CAP_UNITS = int;
enum : int
{
    ///Units in percent.
    StorageDevicePowerCapUnitsPercent    = 0x00000000,
    ///Units in milliwatts.
    StorageDevicePowerCapUnitsMilliwatts = 0x00000001,
}

///Represents the various forms of device media.
alias MEDIA_TYPE = int;
enum : int
{
    ///Format is unknown
    Unknown        = 0x00000000,
    ///A 5.25" floppy, with 1.2MB and 512 bytes/sector.
    F5_1Pt2_512    = 0x00000001,
    ///A 3.5" floppy, with 1.44MB and 512 bytes/sector.
    F3_1Pt44_512   = 0x00000002,
    ///A 3.5" floppy, with 2.88MB and 512 bytes/sector.
    F3_2Pt88_512   = 0x00000003,
    ///A 3.5" floppy, with 20.8MB and 512 bytes/sector.
    F3_20Pt8_512   = 0x00000004,
    ///A 3.5" floppy, with 720KB and 512 bytes/sector.
    F3_720_512     = 0x00000005,
    ///A 5.25" floppy, with 360KB and 512 bytes/sector.
    F5_360_512     = 0x00000006,
    ///A 5.25" floppy, with 320KB and 512 bytes/sector.
    F5_320_512     = 0x00000007,
    ///A 5.25" floppy, with 320KB and 1024 bytes/sector.
    F5_320_1024    = 0x00000008,
    ///A 5.25" floppy, with 180KB and 512 bytes/sector.
    F5_180_512     = 0x00000009,
    ///A 5.25" floppy, with 160KB and 512 bytes/sector.
    F5_160_512     = 0x0000000a,
    ///Removable media other than floppy.
    RemovableMedia = 0x0000000b,
    ///Fixed hard disk media.
    FixedMedia     = 0x0000000c,
    ///A 3.5" floppy, with 120MB and 512 bytes/sector.
    F3_120M_512    = 0x0000000d,
    ///A 3.5" floppy, with 640KB and 512 bytes/sector.
    F3_640_512     = 0x0000000e,
    ///A 5.25" floppy, with 640KB and 512 bytes/sector.
    F5_640_512     = 0x0000000f,
    ///A 5.25" floppy, with 720KB and 512 bytes/sector.
    F5_720_512     = 0x00000010,
    ///A 3.5" floppy, with 1.2MB and 512 bytes/sector.
    F3_1Pt2_512    = 0x00000011,
    ///A 3.5" floppy, with 1.23MB and 1024 bytes/sector.
    F3_1Pt23_1024  = 0x00000012,
    ///A 5.25" floppy, with 1.23MB and 1024 bytes/sector.
    F5_1Pt23_1024  = 0x00000013,
    ///A 3.5" floppy, with 128MB and 512 bytes/sector.
    F3_128Mb_512   = 0x00000014,
    ///A 3.5" floppy, with 230MB and 512 bytes/sector.
    F3_230Mb_512   = 0x00000015,
    ///An 8" floppy, with 256KB and 128 bytes/sector.
    F8_256_128     = 0x00000016,
    ///A 3.5" floppy, with 200MB and 512 bytes/sector. (HiFD).
    F3_200Mb_512   = 0x00000017,
    ///A 3.5" floppy, with 240MB and 512 bytes/sector. (HiFD).
    F3_240M_512    = 0x00000018,
    ///A 3.5" floppy, with 32MB and 512 bytes/sector.
    F3_32M_512     = 0x00000019,
}

///Represents the format of a partition.
alias PARTITION_STYLE = int;
enum : int
{
    ///Master boot record (MBR) format. This corresponds to standard *AT-style* MBR partitions.
    PARTITION_STYLE_MBR = 0x00000000,
    ///GUID Partition Table (GPT) format.
    PARTITION_STYLE_GPT = 0x00000001,
    ///Partition not formatted in either of the recognized formats—MBR or GPT.
    PARTITION_STYLE_RAW = 0x00000002,
}

///Specifies the type of CSV control operation to use with the [FSCTL_CSV_CONTROL](ni-winioctl-fsctl_csv_control.md)
///control code.
alias CSV_CONTROL_OP = int;
enum : int
{
    ///Start file redirection.
    CsvControlStartRedirectFile                  = 0x00000002,
    ///Stop file redirection.
    CsvControlStopRedirectFile                   = 0x00000003,
    ///Search for state redirection. When this value is specified, the
    ///[CSV_QUERY_REDIRECT_STATE](ns-winioctl-csv_query_redirect_state.md) structure must also be used.
    CsvControlQueryRedirectState                 = 0x00000004,
    ///Search for file revision. When this value is specified, the
    ///[CSV_QUERY_FILE_REVISION](ns-winioctl-csv_query_file_revision.md) structure must also be used.
    CsvControlQueryFileRevision                  = 0x00000006,
    CsvControlQueryMdsPath                       = 0x00000008,
    CsvControlQueryFileRevisionFileId128         = 0x00000009,
    CsvControlQueryVolumeRedirectState           = 0x0000000a,
    CsvControlEnableUSNRangeModificationTracking = 0x0000000d,
    CsvControlMarkHandleLocalVolumeMount         = 0x0000000e,
    CsvControlUnmarkHandleLocalVolumeMount       = 0x0000000f,
    CsvControlGetCsvFsMdsPathV2                  = 0x00000012,
    CsvControlDisableCaching                     = 0x00000013,
    CsvControlEnableCaching                      = 0x00000014,
    CsvControlStartForceDFO                      = 0x00000015,
    CsvControlStopForceDFO                       = 0x00000016,
}

///Specifies the storage media type.
alias FILE_STORAGE_TIER_MEDIA_TYPE = int;
enum : int
{
    ///Media type is unspecified.
    FileStorageTierMediaTypeUnspecified = 0x00000000,
    ///Media type is an HDD (hard disk drive).
    FileStorageTierMediaTypeDisk        = 0x00000001,
    ///Media type is an SSD (solid state drive).
    FileStorageTierMediaTypeSsd         = 0x00000002,
    FileStorageTierMediaTypeScm         = 0x00000004,
    FileStorageTierMediaTypeMax         = 0x00000005,
}

///Defines values that are used with the FindFirstStreamW function to specify the information level of the returned
///data.
alias STREAM_INFO_LEVELS = int;
enum : int
{
    ///The FindFirstStreamW function retrieves standard stream information. The data is returned in a
    ///WIN32_FIND_STREAM_DATA structure.
    FindStreamInfoStandard     = 0x00000000,
    ///Used to determine valid enumeration values. All supported enumeration values are less than
    ///<b>FindStreamInfoMaxInfoLevel</b>.
    FindStreamInfoMaxInfoLevel = 0x00000001,
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NtmsObjectsTypes</b> enumeration type specifies the types of RSM objects.
enum NtmsObjectsTypes : int
{
    ///Unknown object.
    NTMS_UNKNOWN                = 0x00000000,
    ///Used internally when initializing an object.
    NTMS_OBJECT                 = 0x00000001,
    ///Changer.
    NTMS_CHANGER                = 0x00000002,
    ///Changer type.
    NTMS_CHANGER_TYPE           = 0x00000003,
    ///Computer.
    NTMS_COMPUTER               = 0x00000004,
    ///Drive.
    NTMS_DRIVE                  = 0x00000005,
    ///Drive type.
    NTMS_DRIVE_TYPE             = 0x00000006,
    ///Insert/eject door.
    NTMS_IEDOOR                 = 0x00000007,
    ///Insert/eject port.
    NTMS_IEPORT                 = 0x00000008,
    ///Library (including the offline library).
    NTMS_LIBRARY                = 0x00000009,
    ///Library request.
    NTMS_LIBREQUEST             = 0x0000000a,
    ///Logical media.
    NTMS_LOGICAL_MEDIA          = 0x0000000b,
    ///Media pool.
    NTMS_MEDIA_POOL             = 0x0000000c,
    ///Media type.
    NTMS_MEDIA_TYPE             = 0x0000000d,
    ///Side of a piece of physical media.
    NTMS_PARTITION              = 0x0000000e,
    ///Physical media.
    NTMS_PHYSICAL_MEDIA         = 0x0000000f,
    ///Storage slot.
    NTMS_STORAGESLOT            = 0x00000010,
    ///Operator request.
    NTMS_OPREQUEST              = 0x00000011,
    ///User interface destination.
    NTMS_UI_DESTINATION         = 0x00000012,
    NTMS_NUMBER_OF_OBJECT_TYPES = 0x00000013,
}

enum NtmsAsyncStatus : int
{
    NTMS_ASYNCSTATE_QUEUED        = 0x00000000,
    NTMS_ASYNCSTATE_WAIT_RESOURCE = 0x00000001,
    NTMS_ASYNCSTATE_WAIT_OPERATOR = 0x00000002,
    NTMS_ASYNCSTATE_INPROCESS     = 0x00000003,
    NTMS_ASYNCSTATE_COMPLETE      = 0x00000004,
}

enum NtmsAsyncOperations : int
{
    NTMS_ASYNCOP_MOUNT = 0x00000001,
}

enum NtmsSessionOptions : int
{
    NTMS_SESSION_QUERYEXPEDITE = 0x00000001,
}

enum NtmsMountOptions : int
{
    NTMS_MOUNT_READ                 = 0x00000001,
    NTMS_MOUNT_WRITE                = 0x00000002,
    NTMS_MOUNT_ERROR_NOT_AVAILABLE  = 0x00000004,
    NTMS_MOUNT_ERROR_IF_UNAVAILABLE = 0x00000004,
    NTMS_MOUNT_ERROR_OFFLINE        = 0x00000008,
    NTMS_MOUNT_ERROR_IF_OFFLINE     = 0x00000008,
    NTMS_MOUNT_SPECIFIC_DRIVE       = 0x00000010,
    NTMS_MOUNT_NOWAIT               = 0x00000020,
}

enum NtmsDismountOptions : int
{
    NTMS_DISMOUNT_DEFERRED  = 0x00000001,
    NTMS_DISMOUNT_IMMEDIATE = 0x00000002,
}

enum NtmsMountPriority : int
{
    NTMS_PRIORITY_DEFAULT = 0x00000000,
    NTMS_PRIORITY_HIGHEST = 0x0000000f,
    NTMS_PRIORITY_HIGH    = 0x00000007,
    NTMS_PRIORITY_NORMAL  = 0x00000000,
    NTMS_PRIORITY_LOW     = 0xfffffff9,
    NTMS_PRIORITY_LOWEST  = 0xfffffff1,
}

enum NtmsAllocateOptions : int
{
    NTMS_ALLOCATE_NEW                  = 0x00000001,
    NTMS_ALLOCATE_NEXT                 = 0x00000002,
    NTMS_ALLOCATE_ERROR_IF_UNAVAILABLE = 0x00000004,
}

enum NtmsCreateOptions : int
{
    NTMS_OPEN_EXISTING = 0x00000001,
    NTMS_CREATE_NEW    = 0x00000002,
    NTMS_OPEN_ALWAYS   = 0x00000003,
}

enum NtmsDriveState : int
{
    NTMS_DRIVESTATE_DISMOUNTED    = 0x00000000,
    NTMS_DRIVESTATE_MOUNTED       = 0x00000001,
    NTMS_DRIVESTATE_LOADED        = 0x00000002,
    NTMS_DRIVESTATE_UNLOADED      = 0x00000005,
    NTMS_DRIVESTATE_BEING_CLEANED = 0x00000006,
    NTMS_DRIVESTATE_DISMOUNTABLE  = 0x00000007,
}

enum NtmsLibraryType : int
{
    NTMS_LIBRARYTYPE_UNKNOWN    = 0x00000000,
    NTMS_LIBRARYTYPE_OFFLINE    = 0x00000001,
    NTMS_LIBRARYTYPE_ONLINE     = 0x00000002,
    NTMS_LIBRARYTYPE_STANDALONE = 0x00000003,
}

enum NtmsLibraryFlags : int
{
    NTMS_LIBRARYFLAG_FIXEDOFFLINE               = 0x00000001,
    NTMS_LIBRARYFLAG_CLEANERPRESENT             = 0x00000002,
    NTMS_LIBRARYFLAG_AUTODETECTCHANGE           = 0x00000004,
    NTMS_LIBRARYFLAG_IGNORECLEANERUSESREMAINING = 0x00000008,
    NTMS_LIBRARYFLAG_RECOGNIZECLEANERBARCODE    = 0x00000010,
}

enum NtmsInventoryMethod : int
{
    NTMS_INVENTORY_NONE    = 0x00000000,
    NTMS_INVENTORY_FAST    = 0x00000001,
    NTMS_INVENTORY_OMID    = 0x00000002,
    NTMS_INVENTORY_DEFAULT = 0x00000003,
    NTMS_INVENTORY_SLOT    = 0x00000004,
    NTMS_INVENTORY_STOP    = 0x00000005,
    NTMS_INVENTORY_MAX     = 0x00000006,
}

enum NtmsSlotState : int
{
    NTMS_SLOTSTATE_UNKNOWN        = 0x00000000,
    NTMS_SLOTSTATE_FULL           = 0x00000001,
    NTMS_SLOTSTATE_EMPTY          = 0x00000002,
    NTMS_SLOTSTATE_NOTPRESENT     = 0x00000003,
    NTMS_SLOTSTATE_NEEDSINVENTORY = 0x00000004,
}

enum NtmsDoorState : int
{
    NTMS_DOORSTATE_UNKNOWN = 0x00000000,
    NTMS_DOORSTATE_CLOSED  = 0x00000001,
    NTMS_DOORSTATE_OPEN    = 0x00000002,
}

enum NtmsPortPosition : int
{
    NTMS_PORTPOSITION_UNKNOWN   = 0x00000000,
    NTMS_PORTPOSITION_EXTENDED  = 0x00000001,
    NTMS_PORTPOSITION_RETRACTED = 0x00000002,
}

enum NtmsPortContent : int
{
    NTMS_PORTCONTENT_UNKNOWN = 0x00000000,
    NTMS_PORTCONTENT_FULL    = 0x00000001,
    NTMS_PORTCONTENT_EMPTY   = 0x00000002,
}

enum NtmsBarCodeState : int
{
    NTMS_BARCODESTATE_OK         = 0x00000001,
    NTMS_BARCODESTATE_UNREADABLE = 0x00000002,
}

enum NtmsMediaState : int
{
    NTMS_MEDIASTATE_IDLE     = 0x00000000,
    NTMS_MEDIASTATE_INUSE    = 0x00000001,
    NTMS_MEDIASTATE_MOUNTED  = 0x00000002,
    NTMS_MEDIASTATE_LOADED   = 0x00000003,
    NTMS_MEDIASTATE_UNLOADED = 0x00000004,
    NTMS_MEDIASTATE_OPERROR  = 0x00000005,
    NTMS_MEDIASTATE_OPREQ    = 0x00000006,
}

enum NtmsPartitionState : int
{
    NTMS_PARTSTATE_UNKNOWN        = 0x00000000,
    NTMS_PARTSTATE_UNPREPARED     = 0x00000001,
    NTMS_PARTSTATE_INCOMPATIBLE   = 0x00000002,
    NTMS_PARTSTATE_DECOMMISSIONED = 0x00000003,
    NTMS_PARTSTATE_AVAILABLE      = 0x00000004,
    NTMS_PARTSTATE_ALLOCATED      = 0x00000005,
    NTMS_PARTSTATE_COMPLETE       = 0x00000006,
    NTMS_PARTSTATE_FOREIGN        = 0x00000007,
    NTMS_PARTSTATE_IMPORT         = 0x00000008,
    NTMS_PARTSTATE_RESERVED       = 0x00000009,
}

enum NtmsPoolType : int
{
    NTMS_POOLTYPE_UNKNOWN     = 0x00000000,
    NTMS_POOLTYPE_SCRATCH     = 0x00000001,
    NTMS_POOLTYPE_FOREIGN     = 0x00000002,
    NTMS_POOLTYPE_IMPORT      = 0x00000003,
    NTMS_POOLTYPE_APPLICATION = 0x000003e8,
}

enum NtmsAllocationPolicy : int
{
    NTMS_ALLOCATE_FROMSCRATCH = 0x00000001,
}

enum NtmsDeallocationPolicy : int
{
    NTMS_DEALLOCATE_TOSCRATCH = 0x00000001,
}

enum NtmsReadWriteCharacteristics : int
{
    NTMS_MEDIARW_UNKNOWN    = 0x00000000,
    NTMS_MEDIARW_REWRITABLE = 0x00000001,
    NTMS_MEDIARW_WRITEONCE  = 0x00000002,
    NTMS_MEDIARW_READONLY   = 0x00000003,
}

enum NtmsLmOperation : int
{
    NTMS_LM_REMOVE         = 0x00000000,
    NTMS_LM_DISABLECHANGER = 0x00000001,
    NTMS_LM_DISABLELIBRARY = 0x00000001,
    NTMS_LM_ENABLECHANGER  = 0x00000002,
    NTMS_LM_ENABLELIBRARY  = 0x00000002,
    NTMS_LM_DISABLEDRIVE   = 0x00000003,
    NTMS_LM_ENABLEDRIVE    = 0x00000004,
    NTMS_LM_DISABLEMEDIA   = 0x00000005,
    NTMS_LM_ENABLEMEDIA    = 0x00000006,
    NTMS_LM_UPDATEOMID     = 0x00000007,
    NTMS_LM_INVENTORY      = 0x00000008,
    NTMS_LM_DOORACCESS     = 0x00000009,
    NTMS_LM_EJECT          = 0x0000000a,
    NTMS_LM_EJECTCLEANER   = 0x0000000b,
    NTMS_LM_INJECT         = 0x0000000c,
    NTMS_LM_INJECTCLEANER  = 0x0000000d,
    NTMS_LM_PROCESSOMID    = 0x0000000e,
    NTMS_LM_CLEANDRIVE     = 0x0000000f,
    NTMS_LM_DISMOUNT       = 0x00000010,
    NTMS_LM_MOUNT          = 0x00000011,
    NTMS_LM_WRITESCRATCH   = 0x00000012,
    NTMS_LM_CLASSIFY       = 0x00000013,
    NTMS_LM_RESERVECLEANER = 0x00000014,
    NTMS_LM_RELEASECLEANER = 0x00000015,
    NTMS_LM_MAXWORKITEM    = 0x00000016,
}

enum NtmsLmState : int
{
    NTMS_LM_QUEUED    = 0x00000000,
    NTMS_LM_INPROCESS = 0x00000001,
    NTMS_LM_PASSED    = 0x00000002,
    NTMS_LM_FAILED    = 0x00000003,
    NTMS_LM_INVALID   = 0x00000004,
    NTMS_LM_WAITING   = 0x00000005,
    NTMS_LM_DEFERRED  = 0x00000006,
    NTMS_LM_DEFFERED  = 0x00000006,
    NTMS_LM_CANCELLED = 0x00000007,
    NTMS_LM_STOPPED   = 0x00000008,
}

enum NtmsOpreqCommand : int
{
    NTMS_OPREQ_UNKNOWN       = 0x00000000,
    NTMS_OPREQ_NEWMEDIA      = 0x00000001,
    NTMS_OPREQ_CLEANER       = 0x00000002,
    NTMS_OPREQ_DEVICESERVICE = 0x00000003,
    NTMS_OPREQ_MOVEMEDIA     = 0x00000004,
    NTMS_OPREQ_MESSAGE       = 0x00000005,
}

enum NtmsOpreqState : int
{
    NTMS_OPSTATE_UNKNOWN    = 0x00000000,
    NTMS_OPSTATE_SUBMITTED  = 0x00000001,
    NTMS_OPSTATE_ACTIVE     = 0x00000002,
    NTMS_OPSTATE_INPROGRESS = 0x00000003,
    NTMS_OPSTATE_REFUSED    = 0x00000004,
    NTMS_OPSTATE_COMPLETE   = 0x00000005,
}

enum NtmsLibRequestFlags : int
{
    NTMS_LIBREQFLAGS_NOAUTOPURGE   = 0x00000001,
    NTMS_LIBREQFLAGS_NOFAILEDPURGE = 0x00000002,
}

enum NtmsOpRequestFlags : int
{
    NTMS_OPREQFLAGS_NOAUTOPURGE   = 0x00000001,
    NTMS_OPREQFLAGS_NOFAILEDPURGE = 0x00000002,
    NTMS_OPREQFLAGS_NOALERTS      = 0x00000010,
    NTMS_OPREQFLAGS_NOTRAYICON    = 0x00000020,
}

enum NtmsMediaPoolPolicy : int
{
    NTMS_POOLPOLICY_PURGEOFFLINESCRATCH = 0x00000001,
    NTMS_POOLPOLICY_KEEPOFFLINEIMPORT   = 0x00000002,
}

enum NtmsOperationalState : int
{
    NTMS_READY         = 0x00000000,
    NTMS_INITIALIZING  = 0x0000000a,
    NTMS_NEEDS_SERVICE = 0x00000014,
    NTMS_NOT_PRESENT   = 0x00000015,
}

enum NtmsCreateNtmsMediaOptions : int
{
    NTMS_ERROR_ON_DUPLICATE = 0x00000001,
}

enum NtmsEnumerateOption : int
{
    NTMS_ENUM_DEFAULT  = 0x00000000,
    NTMS_ENUM_ROOTPOOL = 0x00000001,
}

enum NtmsEjectOperation : int
{
    NTMS_EJECT_START     = 0x00000000,
    NTMS_EJECT_STOP      = 0x00000001,
    NTMS_EJECT_QUEUE     = 0x00000002,
    NTMS_EJECT_FORCE     = 0x00000003,
    NTMS_EJECT_IMMEDIATE = 0x00000004,
    NTMS_EJECT_ASK_USER  = 0x00000005,
}

enum NtmsInjectOperation : int
{
    NTMS_INJECT_START     = 0x00000000,
    NTMS_INJECT_STOP      = 0x00000001,
    NTMS_INJECT_RETRACT   = 0x00000002,
    NTMS_INJECT_STARTMANY = 0x00000003,
}

enum NtmsDriveType : int
{
    NTMS_UNKNOWN_DRIVE = 0x00000000,
}

enum NtmsAccessMask : int
{
    NTMS_USE_ACCESS     = 0x00000001,
    NTMS_MODIFY_ACCESS  = 0x00000002,
    NTMS_CONTROL_ACCESS = 0x00000004,
}

enum NtmsUITypes : int
{
    NTMS_UITYPE_INVALID = 0x00000000,
    NTMS_UITYPE_INFO    = 0x00000001,
    NTMS_UITYPE_REQ     = 0x00000002,
    NTMS_UITYPE_ERR     = 0x00000003,
    NTMS_UITYPE_MAX     = 0x00000004,
}

enum NtmsUIOperations : int
{
    NTMS_UIDEST_ADD       = 0x00000001,
    NTMS_UIDEST_DELETE    = 0x00000002,
    NTMS_UIDEST_DELETEALL = 0x00000003,
    NTMS_UIOPERATION_MAX  = 0x00000004,
}

enum NtmsNotificationOperations : int
{
    NTMS_OBJ_UPDATE     = 0x00000001,
    NTMS_OBJ_INSERT     = 0x00000002,
    NTMS_OBJ_DELETE     = 0x00000003,
    NTMS_EVENT_SIGNAL   = 0x00000004,
    NTMS_EVENT_COMPLETE = 0x00000005,
}

alias CLS_CONTEXT_MODE = int;
enum : int
{
    ClsContextNone     = 0x00000000,
    ClsContextUndoNext = 0x00000001,
    ClsContextPrevious = 0x00000002,
    ClsContextForward  = 0x00000003,
}

///Specifies a context mode type that indicates the direction and access methods that a client uses to scan a log. The
///context mode is set by using ReadLogRecord, and is embedded in the read context that these two functions return.
alias CLFS_CONTEXT_MODE = int;
enum : int
{
    ///Do not move the cursor.
    ClfsContextNone     = 0x00000000,
    ///Move the cursor backward to the next undo record.
    ClfsContextUndoNext = 0x00000001,
    ///Move the cursor to the previous log record from the current read context.
    ClfsContextPrevious = 0x00000002,
    ///Move the cursor to the next client log record from the current read context.
    ClfsContextForward  = 0x00000003,
}

alias CLS_LOG_INFORMATION_CLASS = int;
enum : int
{
    ClfsLogBasicInformation            = 0x00000000,
    ClfsLogBasicInformationPhysical    = 0x00000001,
    ClfsLogPhysicalNameInformation     = 0x00000002,
    ClfsLogStreamIdentifierInformation = 0x00000003,
    ClfsLogSystemMarkingInformation    = 0x00000004,
    ClfsLogPhysicalLsnInformation      = 0x00000005,
}

alias CLS_IOSTATS_CLASS = int;
enum : int
{
    ClsIoStatsDefault = 0x00000000,
    ClsIoStatsMax     = 0x0000ffff,
}

///Defines types of I/O statistics reported by CLFS and is used when a client calls GetLogIoStatistics. Currently, log
///flush rates are the only type of statistic reported, but this enumeration will reflect more types of statistics in
///the future.
alias CLFS_IOSTATS_CLASS = int;
enum : int
{
    ///The default I/O statistics exported.
    ClfsIoStatsDefault = 0x00000000,
    ///The log flush rate.
    ClfsIoStatsMax     = 0x0000ffff,
}

///Specifies whether a log is ephemeral.
alias CLFS_LOG_ARCHIVE_MODE = int;
enum : int
{
    ///Enables log archive (ephemeral logs) support.
    ClfsLogArchiveEnabled  = 0x00000001,
    ///Disables ephemeral logs.
    ClfsLogArchiveDisabled = 0x00000002,
}

///The <b>CLFS_MGMT_POLICY_TYPE</b> enumeration lists the valid policy types.
alias CLFS_MGMT_POLICY_TYPE = int;
enum : int
{
    ///Specifies the maximum size of the log.
    ClfsMgmtPolicyMaximumSize           = 0x00000000,
    ///Specifies the minimum size of the log.
    ClfsMgmtPolicyMinimumSize           = 0x00000001,
    ///Specifies the size of a new container.
    ClfsMgmtPolicyNewContainerSize      = 0x00000002,
    ///Controls the rate of growth of the log.
    ClfsMgmtPolicyGrowthRate            = 0x00000003,
    ///Controls the amount of space that LOG_TAIL_ADVANCE_CALLBACK requests.
    ClfsMgmtPolicyLogTail               = 0x00000004,
    ///Controls the percentage of containers that are removed if the log is set to autogrow.
    ClfsMgmtPolicyAutoShrink            = 0x00000005,
    ///Indicates if the log should automatically shrink or grow.
    ClfsMgmtPolicyAutoGrow              = 0x00000006,
    ///Controls the prefix given to a new container.
    ClfsMgmtPolicyNewContainerPrefix    = 0x00000007,
    ///Controls the suffix given to a new container.
    ClfsMgmtPolicyNewContainerSuffix    = 0x00000008,
    ///Controls the extension given to a new container.
    ClfsMgmtPolicyNewContainerExtension = 0x00000009,
    ClfsMgmtPolicyInvalid               = 0x0000000a,
}

alias CLFS_MGMT_NOTIFICATION_TYPE = int;
enum : int
{
    ClfsMgmtAdvanceTailNotification    = 0x00000000,
    ClfsMgmtLogFullHandlerNotification = 0x00000001,
    ClfsMgmtLogUnpinnedNotification    = 0x00000002,
    ClfsMgmtLogWriteNotification       = 0x00000003,
}

alias SERVER_CERTIFICATE_TYPE = int;
enum : int
{
    QUIC    = 0x00000000,
}

///Indicates the type of message passed in the COPYFILE2_MESSAGE structure to the CopyFile2ProgressRoutine callback
///function.
alias COPYFILE2_MESSAGE_TYPE = int;
enum : int
{
    ///Not a valid value.
    COPYFILE2_CALLBACK_NONE            = 0x00000000,
    ///Indicates a single chunk of a stream has started to be copied.
    COPYFILE2_CALLBACK_CHUNK_STARTED   = 0x00000001,
    ///Indicates the copy of a single chunk of a stream has completed.
    COPYFILE2_CALLBACK_CHUNK_FINISHED  = 0x00000002,
    ///Indicates both source and destination handles for a stream have been opened and the copy of the stream is about
    ///to be started.
    COPYFILE2_CALLBACK_STREAM_STARTED  = 0x00000003,
    ///Indicates the copy operation for a stream have started to be completed.
    COPYFILE2_CALLBACK_STREAM_FINISHED = 0x00000004,
    ///May be sent periodically.
    COPYFILE2_CALLBACK_POLL_CONTINUE   = 0x00000005,
    COPYFILE2_CALLBACK_ERROR           = 0x00000006,
    ///An error was encountered during the copy operation.
    COPYFILE2_CALLBACK_MAX             = 0x00000007,
}

///Returned by the CopyFile2ProgressRoutine callback function to indicate what action should be taken for the pending
///copy operation.
alias COPYFILE2_MESSAGE_ACTION = int;
enum : int
{
    ///Continue the copy operation.
    COPYFILE2_PROGRESS_CONTINUE = 0x00000000,
    ///Cancel the copy operation. The CopyFile2 call will fail and return
    ///<code>HRESULT_FROM_WIN32(ERROR_REQUEST_ABORTED)</code> and any partially copied fragments will be deleted.
    COPYFILE2_PROGRESS_CANCEL   = 0x00000001,
    ///Stop the copy operation. The CopyFile2 call will fail and return
    ///<code>HRESULT_FROM_WIN32(ERROR_REQUEST_ABORTED)</code> and any partially copied fragments will be left intact.
    ///The operation can be restarted using the <b>COPY_FILE_RESUME_FROM_PAUSE</b> flag only if the
    ///<b>COPY_FILE_RESTARTABLE</b> flag was set in the <b>dwCopyFlags</b> member of the COPYFILE2_EXTENDED_PARAMETERS
    ///structure passed to the <b>CopyFile2</b> function.
    COPYFILE2_PROGRESS_STOP     = 0x00000002,
    ///Continue the copy operation but do not call the CopyFile2ProgressRoutine callback function again for this
    ///operation.
    COPYFILE2_PROGRESS_QUIET    = 0x00000003,
    ///Pause the copy operation and write a restart header. This value is not compatible with the
    ///<b>COPY_FILE_RESTARTABLE</b> flag for the <b>dwCopyFlags</b> member of the COPYFILE2_EXTENDED_PARAMETERS
    ///structure. In most cases the CopyFile2 call will fail and return
    ///<code>HRESULT_FROM_WIN32(ERROR_REQUEST_PAUSED)</code> and any partially copied fragments will be left intact
    ///(except for the header written that is used to resume the copy operation later.) In case the copy operation was
    ///complete at the time the pause request is processed the <b>CopyFile2</b> call will complete successfully and no
    ///resume header will be written. After this value is processed one more callback will be made to the
    ///CopyFile2ProgressRoutine with the message specifying a <b>COPYFILE2_CALLBACK_STREAM_FINISHED</b> (4) value in the
    ///<b>Type</b> member of the COPYFILE2_MESSAGE structure. After the callback has returned CopyFile2 will fail with
    ///<code>HRESULT_FROM_WIN32(ERROR_REQUEST_PAUSED)</code>.
    COPYFILE2_PROGRESS_PAUSE    = 0x00000004,
}

///Indicates the phase of a copy at the time of an error. This is used in the <b>Error</b> structure embedded in the
///COPYFILE2_MESSAGE structure.
alias COPYFILE2_COPY_PHASE = int;
enum : int
{
    ///The copy had not yet started processing.
    COPYFILE2_PHASE_NONE              = 0x00000000,
    ///The source was being prepared including opening a handle to the source. This phase happens once per stream copy
    ///operation.
    COPYFILE2_PHASE_PREPARE_SOURCE    = 0x00000001,
    ///The destination was being prepared including opening a handle to the destination. This phase happens once per
    ///stream copy operation.
    COPYFILE2_PHASE_PREPARE_DEST      = 0x00000002,
    ///The source file was being read. This phase happens one or more times per stream copy operation.
    COPYFILE2_PHASE_READ_SOURCE       = 0x00000003,
    ///The destination file was being written. This phase happens one or more times per stream copy operation.
    COPYFILE2_PHASE_WRITE_DESTINATION = 0x00000004,
    ///Both the source and destination were on the same remote server and the copy was being processed remotely. This
    ///phase happens once per stream copy operation.
    COPYFILE2_PHASE_SERVER_COPY       = 0x00000005,
    ///The copy operation was processing symbolic links and/or reparse points. This phase happens once per file copy
    ///operation.
    COPYFILE2_PHASE_NAMEGRAFT_COPY    = 0x00000006,
    ///One greater than the maximum value. Valid values for this enumeration will be less than this value.
    COPYFILE2_PHASE_MAX               = 0x00000007,
}

///Defines values that are used with the FILE_IO_PRIORITY_HINT_INFO structure to specify the priority hint for a file
///I/O operation.
alias PRIORITY_HINT = int;
enum : int
{
    ///The lowest possible priority hint level. The system uses this value for background I/O operations.
    IoPriorityHintVeryLow     = 0x00000000,
    ///A low-priority hint level.
    IoPriorityHintLow         = 0x00000001,
    ///A normal-priority hint level. This value is the default setting for an I/O operation.
    IoPriorityHintNormal      = 0x00000002,
    ///This value is used for validation. Supported values are less than this value.
    MaximumIoPriorityHintType = 0x00000003,
}

///Discriminator for the union in the FILE_ID_DESCRIPTOR structure.
alias FILE_ID_TYPE = int;
enum : int
{
    ///Use the <b>FileId</b> member of the union.
    FileIdType         = 0x00000000,
    ///Use the <b>ObjectId</b> member of the union.
    ObjectIdType       = 0x00000001,
    ///Use the <b>ExtendedFileId</b> member of the union. <b>Windows XP, Windows Server 2003, Windows Vista, Windows
    ///Server 2008, Windows 7 and Windows Server 2008 R2: </b>This value is not supported before Windows 8 and Windows
    ///Server 2012.
    ExtendedFileIdType = 0x00000002,
    ///This value is used for comparison only. All valid values are less than this value.
    MaximumFileIdType  = 0x00000003,
}

// Constants


enum ubyte ClfsNullRecord = 0x00;
enum ubyte ClfsRestartRecord = 0x02;

enum : uint
{
    ClsContainerInitializing        = 0x00000001,
    ClsContainerInactive            = 0x00000002,
    ClsContainerActive              = 0x00000004,
    ClsContainerActivePendingDelete = 0x00000008,
}

enum uint ClsContainerPendingArchiveAndDelete = 0x00000020;

enum : uint
{
    ClfsContainerInactive                = 0x00000002,
    ClfsContainerActive                  = 0x00000004,
    ClfsContainerActivePendingDelete     = 0x00000008,
    ClfsContainerPendingArchive          = 0x00000010,
    ClfsContainerPendingArchiveAndDelete = 0x00000020,
}

enum : ubyte
{
    CLFS_SCAN_INIT        = 0x01,
    CLFS_SCAN_FORWARD     = 0x02,
    CLFS_SCAN_BACKWARD    = 0x04,
    CLFS_SCAN_CLOSE       = 0x08,
    CLFS_SCAN_INITIALIZED = 0x10,
    CLFS_SCAN_BUFFERED    = 0x20,
}

// Callbacks

///An application-defined callback function used with the ReadFileEx and WriteFileEx functions. It is called when the
///asynchronous input and output (I/O) operation is completed or canceled and the calling thread is in an alertable
///state (by using the SleepEx, MsgWaitForMultipleObjectsEx, WaitForSingleObjectEx, or WaitForMultipleObjectsEx function
///with the <i>fAlertable</i> parameter set to <b>TRUE</b>). The <b>LPOVERLAPPED_COMPLETION_ROUTINE</b> type defines a
///pointer to this callback function. <b>FileIOCompletionRoutine</b> is a placeholder for the application-defined
///function name.
///Params:
///    dwErrorCode = The I/O completion status. This parameter can be one of the system error codes.
///    dwNumberOfBytesTransfered = The number of bytes transferred. If an error occurs, this parameter is zero.
///    lpOverlapped = A pointer to the OVERLAPPED structure specified by the asynchronous I/O function. The system does not use the
///                   OVERLAPPED structure after the completion routine is called, so the completion routine can deallocate the memory
///                   used by the overlapped structure.
alias LPOVERLAPPED_COMPLETION_ROUTINE = void function(uint dwErrorCode, uint dwNumberOfBytesTransfered, 
                                                      OVERLAPPED* lpOverlapped);
///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <i>MaxMediaLabel</i> callback function determines the maximum size of the media label for the applications
///supported by the media label library.
///Params:
///    pMaxSize = Pointer to a buffer that receives the maximum size of the buffer sent to the ClaimMediaLabel function.
///Returns:
///    This function returns the following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>NO_ERROR</b></dt> </dl> </td> <td width="60%"> The function was successful. </td> </tr>
///    </table>
///    
alias MAXMEDIALABEL = uint function(uint* pMaxSize);
///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <i>ClaimMediaLabel</i> callback function determines whether a specified media label was created by the media's
///associated application.
///Params:
///    pBuffer = Pointer to a buffer that contains the media label.
///    nBufferSize = Size of the buffer, in bytes.
///    pLabelInfo = Pointer to a MediaLabelInfo structure. The media label library fills in this structure if the library recognizes
///                 the media label.
///Returns:
///    This function returns one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>NO_ERROR</b></dt> </dl> </td> <td width="60%"> The media label library filled in the
///    MediaLabelInfo structure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_FORMAT</b></dt> </dl> </td> <td
///    width="60%"> The media label library does not recognize the media label. </td> </tr> </table>
///    
alias CLAIMMEDIALABEL = uint function(const(ubyte)* pBuffer, const(uint) nBufferSize, MediaLabelInfo* pLabelInfo);
alias CLAIMMEDIALABELEX = uint function(const(ubyte)* pBuffer, const(uint) nBufferSize, MediaLabelInfo* pLabelInfo, 
                                        GUID* LabelGuid);
alias CLFS_BLOCK_ALLOCATION = void* function(uint cbBufferLength, void* pvUserContext);
alias CLFS_BLOCK_DEALLOCATION = void function(void* pvBuffer, void* pvUserContext);
alias PCLFS_COMPLETION_ROUTINE = void function(void* pvOverlapped, uint ulReserved);
///The <b>LOG_TAIL_ADVANCE_CALLBACK</b> function is an application-defined callback function that advances the log tail.
///The callback is invoked in the context of an asynchronous procedure call (APC) on the thread that registers for log
///management.
///Params:
///    hLogFile = The handle to the log.
///    lsnTarget = Specifies the log sequence number (LSN) to which the client is advised to advance to or beyond. The
///                <i>lsnTarget</i> may not refer to an actual record in the log.
///    pvClientContext = A pointer to the client context.
alias PLOG_TAIL_ADVANCE_CALLBACK = void function(HANDLE hLogFile, CLS_LSN lsnTarget, void* pvClientContext);
///The <b>LOG_FULL_HANDLER_CALLBACK</b> function is an application-defined callback function that receives notification
///that the call to HandleLogFull is complete. The callback is invoked in the context of an asynchronous procedure call
///(APC) on the thread that registered for log management.
///Params:
///    hLogFile = The handle to the log.
///    dwError = The status of the operation.
///    fLogIsPinned = Specifies if the log is considered "pinned". If <i>fLogIsPinned</i> is <b>TRUE</b> and the log is then unpinned,
///                   the LOG_UNPINNED_CALLBACK is invoked.
///    pvClientContext = A pointer to the client context.
alias PLOG_FULL_HANDLER_CALLBACK = void function(HANDLE hLogFile, uint dwError, BOOL fLogIsPinned, 
                                                 void* pvClientContext);
///The <b>LOG_UNPINNED_CALLBACK</b> function is an application-defined callback function that receives notification that
///the log has become unpinned. The callback is invoked in the context of an asynchronous procedure call (APC) on the
///thread that registers for log management.
///Params:
///    hLogFile = The handle to the log.
///    pvClientContext = A pointer to the client context. This is the same context specified when registering the client, which is a
///                      member of LOG_MANAGEMENT_CALLBACKS.
alias PLOG_UNPINNED_CALLBACK = void function(HANDLE hLogFile, void* pvClientContext);
///Callback function that gets called for each data source in response to a call to WofEnumEntries.
///Params:
///    EntryInfo = The structure that contains specific provider info. The Type of <i>EntryInfo</i> is provider-specific. For
///                WOF_PROVIDER_WIM, it will be PWIM_ENTRY_INFO.
///    UserData = Optional user defined data specified in the call to WofEnumEntries.
alias WofEnumEntryProc = BOOL function(const(void)* EntryInfo, void* UserData);
///Callback function that gets called for each file backed by an external data source, such as a WIM file.
///Params:
///    FilePath = Specifies the path to the file which is backed by an external data source.
///    ExternalFileInfo = Points to a buffer containing information about the data source backing the file. The type of this buffer depends
///                       on the provider; data structures for each provider are: <table> <tr> <td>WOF_PROVIDER_WIM</td>
///                       <td>WIM_EXTERNAL_FILE_INFO</td> </tr> <tr> <td>WOF_PROVIDER_FILE</td> <td>WOF_FILE_COMPRESSION_INFO</td> </tr>
///                       </table>
///    UserData = Optional user defined data.
alias WofEnumFilesProc = BOOL function(const(wchar)* FilePath, void* ExternalFileInfo, void* UserData);
///An application-defined callback function used with ReadEncryptedFileRaw. The system calls <b>ExportCallback</b> one
///or more times, each time with a block of the encrypted file's data, until it has received all of the file data.
///<b>ExportCallback</b> writes the encrypted file's data to another storage media, usually for purposes of backing up
///the file. The <b>PFE_EXPORT_FUNC</b> type defines a pointer to the callback function. <b>ExportCallback</b> is a
///placeholder for the application-defined function name.
///Params:
///    pbData = A pointer to a block of the encrypted file's data to be backed up. This block of data is allocated by the system.
///    pvCallbackContext = A pointer to an application-defined and allocated context block. The application passes this pointer to
///                        ReadEncryptedFileRaw, and <b>ReadEncryptedFileRaw</b> passes this pointer to the callback function so that it can
///                        have access to application-specific data. This data can be a structure and can contain any data the application
///                        needs, such as the handle to the file that contains the backup copy of the encrypted file.
///    ulLength = The size of the data pointed to by the <i>pbData</i> parameter, in bytes.
///Returns:
///    If the function succeeds, it must set the return value to <b>ERROR_SUCCESS</b>. If the function fails, set the
///    return value to a nonzero error code defined in WinError.h. For example, if this function fails because an API
///    that it calls fails, you can set the return value to the value returned by GetLastError for the failed API.
///    
alias PFE_EXPORT_FUNC = uint function(char* pbData, void* pvCallbackContext, uint ulLength);
///An application-defined callback function used with WriteEncryptedFileRaw. The system calls <b>ImportCallback</b> one
///or more times, each time to retrieve a portion of a backup file's data. <b>ImportCallback</b> reads the data from a
///backup file sequentially and restores the data, and the system continues calling it until it has read all of the
///backup file data. The <b>PFE_IMPORT_FUNC</b> type defines a pointer to this callback function. <b>ImportCallback</b>
///is a placeholder for the application-defined function name.
///Params:
///    pbData = A pointer to a system-supplied buffer that will receive a block of data to be restored.
///    pvCallbackContext = A pointer to an application-defined and allocated context block. The application passes this pointer to
///                        WriteEncryptedFileRaw, and it passes this pointer to the callback function so that the callback function can have
///                        access to application-specific data. This data can be a structure and can contain any data the application needs,
///                        such as the handle to the file that contains the backup copy of the encrypted file.
///    ulLength = On function entry, this parameter specifies the length of the buffer the system has supplied. The callback
///               function must write no more than this many bytes to the buffer pointed to by the <i>pbData</i> parameter. On
///               exit, the function must set this to the number of bytes of data written into the <i>pbData</i>.
///Returns:
///    If the function succeeds, it must set the return value to <b>ERROR_SUCCESS</b>, and set the value pointed to by
///    the <i>ulLength</i> parameter to the number of bytes copied into <i>pbData</i>. When the end of the backup file
///    is reached, set <i>ulLength</i> to zero to tell the system that the entire file has been processed. If the
///    function fails, set the return value to a nonzero error code defined in WinError.h. For example, if this function
///    fails because an API that it calls fails, you can set the return value to the value returned by GetLastError for
///    the failed API.
///    
alias PFE_IMPORT_FUNC = uint function(char* pbData, void* pvCallbackContext, uint* ulLength);
///An application-defined callback function used with the CopyFileEx, MoveFileTransacted, and MoveFileWithProgress
///functions. It is called when a portion of a copy or move operation is completed. The <b>LPPROGRESS_ROUTINE</b> type
///defines a pointer to this callback function. <b>CopyProgressRoutine</b> is a placeholder for the application-defined
///function name.
///Params:
///    TotalFileSize = The total size of the file, in bytes.
///    TotalBytesTransferred = The total number of bytes transferred from the source file to the destination file since the copy operation
///                            began.
///    StreamSize = The total size of the current file stream, in bytes.
///    StreamBytesTransferred = The total number of bytes in the current stream that have been transferred from the source file to the
///                             destination file since the copy operation began.
///    dwStreamNumber = A handle to the current stream. The first time <b>CopyProgressRoutine</b> is called, the stream number is 1.
///    dwCallbackReason = The reason that <b>CopyProgressRoutine</b> was called. This parameter can be one of the following values. <table>
///                       <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CALLBACK_CHUNK_FINISHED"></a><a
///                       id="callback_chunk_finished"></a><dl> <dt><b>CALLBACK_CHUNK_FINISHED</b></dt> <dt>0x00000000</dt> </dl> </td> <td
///                       width="60%"> Another part of the data file was copied. </td> </tr> <tr> <td width="40%"><a
///                       id="CALLBACK_STREAM_SWITCH"></a><a id="callback_stream_switch"></a><dl> <dt><b>CALLBACK_STREAM_SWITCH</b></dt>
///                       <dt>0x00000001</dt> </dl> </td> <td width="60%"> Another stream was created and is about to be copied. This is
///                       the callback reason given when the callback routine is first invoked. </td> </tr> </table>
///    hSourceFile = A handle to the source file.
///    hDestinationFile = A handle to the destination file
///    lpData = Argument passed to <b>CopyProgressRoutine</b> by CopyFileEx, MoveFileTransacted, or MoveFileWithProgress.
///Returns:
///    The <b>CopyProgressRoutine</b> function should return one of the following values. <table> <tr> <th>Return
///    code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>PROGRESS_CANCEL</b></dt> <dt>1</dt>
///    </dl> </td> <td width="60%"> Cancel the copy operation and delete the destination file. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>PROGRESS_CONTINUE</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Continue the copy
///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>PROGRESS_QUIET</b></dt> <dt>3</dt> </dl> </td> <td
///    width="60%"> Continue the copy operation, but stop invoking CopyProgressRoutine to report progress. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>PROGRESS_STOP</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Stop the copy
///    operation. It can be restarted at a later time. </td> </tr> </table>
///    
alias LPPROGRESS_ROUTINE = uint function(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, 
                                         LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, 
                                         uint dwStreamNumber, uint dwCallbackReason, HANDLE hSourceFile, 
                                         HANDLE hDestinationFile, void* lpData);
///An application-defined callback function used with the CopyFile2 function. It is called when a portion of a copy or
///move operation is completed. The <b>PCOPYFILE2_PROGRESS_ROUTINE</b> type defines a pointer to this callback function.
///<b>CopyFile2ProgressRoutine</b> is a placeholder for the application-defined function name.
///Params:
///    pMessage = Pointer to a COPYFILE2_MESSAGE structure.
///    pvCallbackContext = Copy of value passed in the <b>pvCallbackContext</b> member of the COPYFILE2_EXTENDED_PARAMETERS structure passed
///                        to CopyFile2.
///Returns:
///    Value from the COPYFILE2_MESSAGE_ACTION enumeration indicating what action should be taken. <table> <tr>
///    <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>COPYFILE2_PROGRESS_CONTINUE</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Continue the copy operation.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>COPYFILE2_PROGRESS_CANCEL</b></dt> <dt>1</dt> </dl> </td> <td
///    width="60%"> Cancel the copy operation. The CopyFile2 function will fail, return
///    <code>HRESULT_FROM_WIN32(ERROR_REQUEST_ABORTED)</code> and any partially copied fragments will be deleted. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>COPYFILE2_PROGRESS_STOP</b></dt> <dt>2</dt> </dl> </td> <td width="60%">
///    Stop the copy operation. The CopyFile2 function will fail, return
///    <code>HRESULT_FROM_WIN32(ERROR_REQUEST_ABORTED)</code> and any partially copied fragments will be left intact.
///    The operation can be restarted using the <b>COPY_FILE_RESUME_FROM_PAUSE</b> flag only if
///    <b>COPY_FILE_RESTARTABLE</b> was set in the <b>dwCopyFlags</b> member of the COPYFILE2_EXTENDED_PARAMETERS
///    structure passed to the <b>CopyFile2</b> function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>COPYFILE2_PROGRESS_QUIET</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> Continue the copy operation but
///    do not call the CopyFile2ProgressRoutine callback function again for this operation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>COPYFILE2_PROGRESS_PAUSE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Pause the copy
///    operation. In most cases the CopyFile2 function will fail and return
///    <code>HRESULT_FROM_WIN32(ERROR_REQUEST_PAUSED)</code> and any partially copied fragments will be left intact
///    (except for the header written that is used to resume the copy operation later.) In case the copy operation was
///    complete at the time the pause request is processed the <b>CopyFile2</b> call will complete successfully and no
///    resume header will be written. </td> </tr> </table>
///    
alias PCOPYFILE2_PROGRESS_ROUTINE = COPYFILE2_MESSAGE_ACTION function(const(COPYFILE2_MESSAGE)* pMessage, 
                                                                      void* pvCallbackContext);

// Structs


alias FindChangeNotifcationHandle = ptrdiff_t;

alias FindFileHandle = ptrdiff_t;

alias FindFileNameHandle = ptrdiff_t;

alias FindStreamHandle = ptrdiff_t;

alias FindVolumeHandle = ptrdiff_t;

alias FindVolumeMointPointHandle = ptrdiff_t;

///Defines a 128-bit file identifier.
struct FILE_ID_128
{
    ///A byte array containing the 128 bit identifier.
    ubyte[16] Identifier;
}

///Describes the changes found by the ReadDirectoryChangesW function.
struct FILE_NOTIFY_INFORMATION
{
    ///The number of bytes that must be skipped to get to the next record. A value of zero indicates that this is the
    ///last record.
    uint      NextEntryOffset;
    ///The type of change that has occurred. This member can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_ACTION_ADDED"></a><a id="file_action_added"></a><dl>
    ///<dt><b>FILE_ACTION_ADDED</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The file was added to the
    ///directory. </td> </tr> <tr> <td width="40%"><a id="FILE_ACTION_REMOVED"></a><a id="file_action_removed"></a><dl>
    ///<dt><b>FILE_ACTION_REMOVED</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The file was removed from
    ///the directory. </td> </tr> <tr> <td width="40%"><a id="FILE_ACTION_MODIFIED"></a><a
    ///id="file_action_modified"></a><dl> <dt><b>FILE_ACTION_MODIFIED</b></dt> <dt>0x00000003</dt> </dl> </td> <td
    ///width="60%"> The file was modified. This can be a change in the time stamp or attributes. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_ACTION_RENAMED_OLD_NAME"></a><a id="file_action_renamed_old_name"></a><dl>
    ///<dt><b>FILE_ACTION_RENAMED_OLD_NAME</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The file was
    ///renamed and this is the old name. </td> </tr> <tr> <td width="40%"><a id="FILE_ACTION_RENAMED_NEW_NAME"></a><a
    ///id="file_action_renamed_new_name"></a><dl> <dt><b>FILE_ACTION_RENAMED_NEW_NAME</b></dt> <dt>0x00000005</dt> </dl>
    ///</td> <td width="60%"> The file was renamed and this is the new name. </td> </tr> </table>
    uint      Action;
    ///The size of the file name portion of the record, in bytes. Note that this value does not include the terminating
    ///null character.
    uint      FileNameLength;
    ///A variable-length field that contains the file name relative to the directory handle. The file name is in the
    ///Unicode character format and is not null-terminated. If there is both a short and long name for the file, the
    ///function will return one of these names, but it is unspecified which one.
    ushort[1] FileName;
}

///Describes the changes found by the ReadDirectoryChangesExW function.
struct FILE_NOTIFY_EXTENDED_INFORMATION
{
    ///The number of bytes that must be skipped to get to the next record. A value of zero indicates that this is the
    ///last record.
    uint          NextEntryOffset;
    ///The type of change that has occurred. This member can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_ACTION_ADDED"></a><a id="file_action_added"></a><dl>
    ///<dt><b>FILE_ACTION_ADDED</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The file was added to the
    ///directory. </td> </tr> <tr> <td width="40%"><a id="FILE_ACTION_REMOVED"></a><a id="file_action_removed"></a><dl>
    ///<dt><b>FILE_ACTION_REMOVED</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The file was removed from
    ///the directory. </td> </tr> <tr> <td width="40%"><a id="FILE_ACTION_MODIFIED"></a><a
    ///id="file_action_modified"></a><dl> <dt><b>FILE_ACTION_MODIFIED</b></dt> <dt>0x00000003</dt> </dl> </td> <td
    ///width="60%"> The file was modified. This can be a change in the time stamp or attributes. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_ACTION_RENAMED_OLD_NAME"></a><a id="file_action_renamed_old_name"></a><dl>
    ///<dt><b>FILE_ACTION_RENAMED_OLD_NAME</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The file was
    ///renamed and this is the old name. </td> </tr> <tr> <td width="40%"><a id="FILE_ACTION_RENAMED_NEW_NAME"></a><a
    ///id="file_action_renamed_new_name"></a><dl> <dt><b>FILE_ACTION_RENAMED_NEW_NAME</b></dt> <dt>0x00000005</dt> </dl>
    ///</td> <td width="60%"> The file was renamed and this is the new name. </td> </tr> </table>
    uint          Action;
    ///The date and time that the directory or file was created and added to the file system.
    LARGE_INTEGER CreationTime;
    ///The date and time that the content of the directory or file was last modified in the file system.
    LARGE_INTEGER LastModificationTime;
    ///The date and time that the metadata or content of the directory or file was last changed in the file system.
    LARGE_INTEGER LastChangeTime;
    ///The date and time the directory or file was last accessed in the file system.
    LARGE_INTEGER LastAccessTime;
    ///The allocated size of the file, in bytes.
    LARGE_INTEGER AllocatedLength;
    ///The new size of the directory or file in bytes, or the old size if the size is unchanged.
    LARGE_INTEGER FileSize;
    ///The attributes of the directory or file.
    uint          FileAttributes;
    ///The identifier tag of a reparse point for the directory or file.
    uint          ReparsePointTag;
    ///The identifier of the directory or file.
    LARGE_INTEGER FileId;
    ///The identifier of the parent directory for the file.
    LARGE_INTEGER ParentFileId;
    ///The size of the file name portion of the record, in bytes. This value does not include a terminating null
    ///character.
    uint          FileNameLength;
    ///A variable-length field that contains the file name relative to the directory handle. The file name is in the
    ///Unicode character format and is not null-terminated. If there is both a short and long name for the file, the
    ///function will return one of these names, but it is unspecified which one.
    ushort[1]     FileName;
}

///Contains information about a reparse point. It is used by the FSCTL_GET_REPARSE_POINT control code.
struct REPARSE_GUID_DATA_BUFFER
{
    ///The reparse point tag. This member identifies the structure of the user-defined reparse data. For more
    ///information, see Reparse Point Tags.
    uint   ReparseTag;
    ///The size of the reparse data in the <b>DataBuffer</b> member, in bytes. This value may vary with different tags
    ///and may vary between two uses of the same tag.
    ushort ReparseDataLength;
    ///Reserved; do not use.
    ushort Reserved;
    ///A <b>GUID</b> that uniquely identifies the reparse point. When setting a reparse point, the application must
    ///provide a non-NULL <b>GUID</b> in the <b>ReparseGuid</b> member. When retrieving a reparse point from the file
    ///system, <b>ReparseGuid</b> is the <b>GUID</b> assigned when the reparse point was set.
    GUID   ReparseGuid;
    struct GenericReparseBuffer
    {
        ubyte[1] DataBuffer;
    }
}

///Contains the information returned by a call to the GetQueuedCompletionStatusEx function.
struct OVERLAPPED_ENTRY
{
    ///Receives the completion key value associated with the file handle whose I/O operation has completed. A completion
    ///key is a per-file key that is specified in a call to CreateIoCompletionPort.
    size_t      lpCompletionKey;
    ///Receives the address of the OVERLAPPED structure that was specified when the completed I/O operation was started.
    OVERLAPPED* lpOverlapped;
    ///Reserved.
    size_t      Internal;
    ///Receives the number of bytes transferred during the I/O operation that has completed.
    uint        dwNumberOfBytesTransferred;
}

///Contains information about the file that is found by the FindFirstFile, FindFirstFileEx, or FindNextFile function.
struct WIN32_FIND_DATAA
{
    ///The file attributes of a file. For possible values and their descriptions, see File Attribute Constants. The
    ///<b>FILE_ATTRIBUTE_SPARSE_FILE</b> attribute on the file is set if any of the streams of the file have ever been
    ///sparse.
    uint      dwFileAttributes;
    ///A FILETIME structure that specifies when a file or directory was created. If the underlying file system does not
    ///support creation time, this member is zero.
    FILETIME  ftCreationTime;
    ///A FILETIME structure. For a file, the structure specifies when the file was last read from, written to, or for
    ///executable files, run. For a directory, the structure specifies when the directory is created. If the underlying
    ///file system does not support last access time, this member is zero. On the FAT file system, the specified date
    ///for both files and directories is correct, but the time of day is always set to midnight.
    FILETIME  ftLastAccessTime;
    ///A FILETIME structure. For a file, the structure specifies when the file was last written to, truncated, or
    ///overwritten, for example, when WriteFile or SetEndOfFile are used. The date and time are not updated when file
    ///attributes or security descriptors are changed. For a directory, the structure specifies when the directory is
    ///created. If the underlying file system does not support last write time, this member is zero.
    FILETIME  ftLastWriteTime;
    ///The high-order <b>DWORD</b> value of the file size, in bytes. This value is zero unless the file size is greater
    ///than <b>MAXDWORD</b>. The size of the file is equal to (<b>nFileSizeHigh</b> * (<b>MAXDWORD</b>+1)) +
    ///<b>nFileSizeLow</b>.
    uint      nFileSizeHigh;
    ///The low-order <b>DWORD</b> value of the file size, in bytes.
    uint      nFileSizeLow;
    ///If the <b>dwFileAttributes</b> member includes the <b>FILE_ATTRIBUTE_REPARSE_POINT</b> attribute, this member
    ///specifies the reparse point tag. Otherwise, this value is undefined and should not be used. For more information
    ///see Reparse Point Tags.
    uint      dwReserved0;
    ///Reserved for future use.
    uint      dwReserved1;
    ///The name of the file.
    byte[260] cFileName;
    ///An alternative name for the file. This name is in the classic 8.3 file name format.
    byte[14]  cAlternateFileName;
}

///Contains information about the file that is found by the FindFirstFile, FindFirstFileEx, or FindNextFile function.
struct WIN32_FIND_DATAW
{
    ///The file attributes of a file. For possible values and their descriptions, see File Attribute Constants. The
    ///<b>FILE_ATTRIBUTE_SPARSE_FILE</b> attribute on the file is set if any of the streams of the file have ever been
    ///sparse.
    uint        dwFileAttributes;
    ///A FILETIME structure that specifies when a file or directory was created. If the underlying file system does not
    ///support creation time, this member is zero.
    FILETIME    ftCreationTime;
    ///A FILETIME structure. For a file, the structure specifies when the file was last read from, written to, or for
    ///executable files, run. For a directory, the structure specifies when the directory is created. If the underlying
    ///file system does not support last access time, this member is zero. On the FAT file system, the specified date
    ///for both files and directories is correct, but the time of day is always set to midnight.
    FILETIME    ftLastAccessTime;
    ///A FILETIME structure. For a file, the structure specifies when the file was last written to, truncated, or
    ///overwritten, for example, when WriteFile or SetEndOfFile are used. The date and time are not updated when file
    ///attributes or security descriptors are changed. For a directory, the structure specifies when the directory is
    ///created. If the underlying file system does not support last write time, this member is zero.
    FILETIME    ftLastWriteTime;
    ///The high-order <b>DWORD</b> value of the file size, in bytes. This value is zero unless the file size is greater
    ///than <b>MAXDWORD</b>. The size of the file is equal to (<b>nFileSizeHigh</b> * (<b>MAXDWORD</b>+1)) +
    ///<b>nFileSizeLow</b>.
    uint        nFileSizeHigh;
    ///The low-order <b>DWORD</b> value of the file size, in bytes.
    uint        nFileSizeLow;
    ///If the <b>dwFileAttributes</b> member includes the <b>FILE_ATTRIBUTE_REPARSE_POINT</b> attribute, this member
    ///specifies the reparse point tag. Otherwise, this value is undefined and should not be used. For more information
    ///see Reparse Point Tags.
    uint        dwReserved0;
    ///Reserved for future use.
    uint        dwReserved1;
    ///The name of the file.
    ushort[260] cFileName;
    ///An alternative name for the file. This name is in the classic 8.3 file name format.
    ushort[14]  cAlternateFileName;
}

///Indicates the properties of a storage device or adapter to retrieve as the input buffer passed to the
///IOCTL_STORAGE_QUERY_PROPERTY control code.
struct STORAGE_PROPERTY_QUERY
{
    ///Indicates whether the caller is requesting a device descriptor, an adapter descriptor, a write cache property, a
    ///device unique ID (DUID), or the device identifiers provided in the device's SCSI vital product data (VPD) page.
    ///For a list of the property IDs that can be assigned to this member, see STORAGE_PROPERTY_ID.
    STORAGE_PROPERTY_ID PropertyId;
    ///Contains flags indicating the type of query to be performed as enumerated by the STORAGE_QUERY_TYPE enumeration.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PropertyStandardQuery"></a><a
    ///id="propertystandardquery"></a><a id="PROPERTYSTANDARDQUERY"></a><dl> <dt><b>PropertyStandardQuery</b></dt>
    ///<dt>0</dt> </dl> </td> <td width="60%"> Instructs the port driver to report a device descriptor, an adapter
    ///descriptor or a unique hardware device ID (DUID). </td> </tr> <tr> <td width="40%"><a
    ///id="PropertyExistsQuery"></a><a id="propertyexistsquery"></a><a id="PROPERTYEXISTSQUERY"></a><dl>
    ///<dt><b>PropertyExistsQuery</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Instructs the port driver to report
    ///whether the descriptor is supported. </td> </tr> </table>
    STORAGE_QUERY_TYPE  QueryType;
    ///Contains an array of bytes that can be used to retrieve additional parameters for specific queries.
    ubyte[1]            AdditionalParameters;
}

///Used in conjunction with the IOCTL_STORAGE_QUERY_PROPERTY control code to retrieve the properties of a storage device
///or adapter.
struct STORAGE_DESCRIPTOR_HEADER
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure.
    uint Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint Size;
}

///Used in conjunction with the IOCTL_STORAGE_QUERY_PROPERTY control code to retrieve the storage device descriptor data
///for a device.
struct STORAGE_DEVICE_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure.
    uint             Version;
    ///Specifies the total size of the descriptor, in bytes, which may include vendor ID, product ID, product revision,
    ///device serial number strings and bus-specific data which are appended to the structure.
    uint             Size;
    ///Specifies the device type as defined by the Small Computer Systems Interface (SCSI) specification.
    ubyte            DeviceType;
    ///Specifies the device type modifier, if any, as defined by the SCSI specification. If no device type modifier
    ///exists, this member is zero.
    ubyte            DeviceTypeModifier;
    ///Indicates when <b>TRUE</b> that the device's media (if any) is removable. If the device has no media, this member
    ///should be ignored. When <b>FALSE</b> the device's media is not removable.
    ubyte            RemovableMedia;
    ///Indicates when <b>TRUE</b> that the device supports multiple outstanding commands (SCSI tagged queuing or
    ///equivalent). When <b>FALSE</b>, the device does not support SCSI-tagged queuing or the equivalent.
    ubyte            CommandQueueing;
    ///Specifies the byte offset from the beginning of the structure to a null-terminated ASCII string that contains the
    ///device's vendor ID. If the device has no vendor ID, this member is zero.
    uint             VendorIdOffset;
    ///Specifies the byte offset from the beginning of the structure to a null-terminated ASCII string that contains the
    ///device's product ID. If the device has no product ID, this member is zero.
    uint             ProductIdOffset;
    ///Specifies the byte offset from the beginning of the structure to a null-terminated ASCII string that contains the
    ///device's product revision string. If the device has no product revision string, this member is zero.
    uint             ProductRevisionOffset;
    ///Specifies the byte offset from the beginning of the structure to a null-terminated ASCII string that contains the
    ///device's serial number. If the device has no serial number, this member is zero.
    uint             SerialNumberOffset;
    ///Specifies an enumerator value of type STORAGE_BUS_TYPE that indicates the type of bus to which the device is
    ///connected. This should be used to interpret the raw device properties at the end of this structure (if any).
    STORAGE_BUS_TYPE BusType;
    ///Indicates the number of bytes of bus-specific data that have been appended to this descriptor.
    uint             RawPropertiesLength;
    ///Contains an array of length one that serves as a place holder for the first byte of the bus specific property
    ///data.
    ubyte[1]         RawDeviceProperties;
}

///Used with the IOCTL_STORAGE_QUERY_PROPERTY control code to retrieve the storage adapter descriptor data for a device.
struct STORAGE_ADAPTER_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure.
    uint   Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint   Size;
    ///Specifies the maximum number of bytes the storage adapter can transfer in a single operation.
    uint   MaximumTransferLength;
    ///Specifies the maximum number of discontinuous physical pages the storage adapter can manage in a single transfer
    ///(in other words, the extent of its scatter/gather support).
    uint   MaximumPhysicalPages;
    ///Specifies the storage adapter's alignment requirements for transfers. The alignment mask indicates alignment
    ///restrictions for buffers required by the storage adapter for transfer operations. Valid mask values are also
    ///restricted by characteristics of the memory managers on different versions of Windows. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Buffers
    ///must be aligned on <b>BYTE</b> boundaries. </td> </tr> <tr> <td width="40%"> <dl> <dt>1</dt> </dl> </td> <td
    ///width="60%"> Buffers must be aligned on <b>WORD</b> boundaries. </td> </tr> <tr> <td width="40%"> <dl> <dt>3</dt>
    ///</dl> </td> <td width="60%"> Buffers must be aligned on <b>DWORD32</b> boundaries. </td> </tr> <tr> <td
    ///width="40%"> <dl> <dt>7</dt> </dl> </td> <td width="60%"> Buffers must be aligned on <b>DWORD64</b> boundaries.
    ///</td> </tr> </table>
    uint   AlignmentMask;
    ///If this member is <b>TRUE</b>, the storage adapter uses programmed I/O (PIO) and requires the use of system-space
    ///virtual addresses mapped to physical memory for data buffers. When this member is <b>FALSE</b>, the storage
    ///adapter does not use PIO.
    ubyte  AdapterUsesPio;
    ///If this member is <b>TRUE</b>, the storage adapter scans down for BIOS devices, that is, the storage adapter
    ///begins scanning with the highest device number rather than the lowest. When this member is <b>FALSE</b>, the
    ///storage adapter begins scanning with the lowest device number. This member is reserved for legacy miniport
    ///drivers.
    ubyte  AdapterScansDown;
    ///If this member is <b>TRUE</b>, the storage adapter supports SCSI tagged queuing and/or per-logical-unit internal
    ///queues, or the non-SCSI equivalent. When this member is <b>FALSE</b>, the storage adapter neither supports
    ///SCSI-tagged queuing nor per-logical-unit internal queues.
    ubyte  CommandQueueing;
    ///If this member is <b>TRUE</b>, the storage adapter supports synchronous transfers as a way of speeding up I/O.
    ///When this member is <b>FALSE</b>, the storage adapter does not support synchronous transfers as a way of speeding
    ///up I/O.
    ubyte  AcceleratedTransfer;
    ///Specifies a value of type STORAGE_BUS_TYPE that indicates the type of the bus to which the device is connected.
    ubyte  BusType;
    ///Specifies the major version number, if any, of the storage adapter.
    ushort BusMajorVersion;
    ///Specifies the minor version number, if any, of the storage adapter.
    ushort BusMinorVersion;
    ///Specifies the SCSI request block (SRB) type used by the HBA. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="SRB_TYPE_SCSI_REQUEST_BLOCK"></a><a id="srb_type_scsi_request_block"></a><dl>
    ///<dt><b>SRB_TYPE_SCSI_REQUEST_BLOCK</b></dt> </dl> </td> <td width="60%"> The HBA uses SCSI request blocks. </td>
    ///</tr> <tr> <td width="40%"><a id="SRB_TYPE_STORAGE_REQUEST_BLOCK"></a><a
    ///id="srb_type_storage_request_block"></a><dl> <dt><b>SRB_TYPE_STORAGE_REQUEST_BLOCK</b></dt> </dl> </td> <td
    ///width="60%"> The HBA uses extended SCSI request blocks. </td> </tr> </table> This member is valid starting with
    ///Windows 8.
    ubyte  SrbType;
    ///Specifies the address type of the HBA. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="STORAGE_ADDRESS_TYPE_BTL8"></a><a id="storage_address_type_btl8"></a><dl>
    ///<dt><b>STORAGE_ADDRESS_TYPE_BTL8</b></dt> </dl> </td> <td width="60%"> The HBA uses 8-bit bus, target, and LUN
    ///addressing. </td> </tr> </table> This member is valid starting with Windows 8.
    ubyte  AddressType;
}

///Used in conjunction with the IOCTL_STORAGE_QUERY_PROPERTY control code to retrieve the storage access alignment
///descriptor data for a device.
struct STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure.
    uint Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint Size;
    ///The number of bytes in a cache line of the device.
    uint BytesPerCacheLine;
    ///The address offset necessary for proper cache access alignment, in bytes.
    uint BytesOffsetForCacheAlignment;
    ///The number of bytes in a logical sector of the device.
    uint BytesPerLogicalSector;
    ///The number of bytes in a physical sector of the device.
    uint BytesPerPhysicalSector;
    ///The logical sector offset within the first physical sector where the first logical sector is placed, in bytes.
    ///Example: Offset = 3 Logical sectors <pre class="syntax"
    ///xml:space="preserve"><code>+---------+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |LBA |
    uint BytesOffsetForSectorAlignment;
}

///Used in conjunction with the IOCTL_STORAGE_QUERY_PROPERTY request to describe the product type of a storage device.
struct STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes, as defined by
    ///<code>Sizeof(STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR)</code>. The value of this member will change as members are
    ///added to the structure.
    uint Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint Size;
    ///Specifies the product type of the storage device. <table> <tr> <th><b>MediumProductType</b> value</th>
    ///<th>Description</th> </tr> <tr> <td><code>00h</code></td> <td>Not indicated</td> </tr> <tr>
    ///<td><code>01h</code></td> <td>CFast</td> </tr> <tr> <td><code>02h</code></td> <td>CompactFlash</td> </tr> <tr>
    ///<td><code>03h</code></td> <td>Memory Stick</td> </tr> <tr> <td><code>04h</code></td> <td>MultiMediaCard</td>
    ///</tr> <tr> <td><code>05h</code></td> <td>Secure Digital Card (SD Card)</td> </tr> <tr> <td><code>06h</code></td>
    ///<td>QXD</td> </tr> <tr> <td><code>07h</code></td> <td>Universal Flash Storage</td> </tr> <tr>
    ///<td><code>08h</code> to <code>EFh</code></td> <td>Reserved</td> </tr> <tr> <td><code>F0h</code> to
    ///<code>FFh</code></td> <td>Vendor-specific</td> </tr> </table>
    uint MediumProductType;
}

///Reserved for system use.
struct STORAGE_MINIPORT_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure.
    uint     Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint     Size;
    ///Type of port driver as enumerated by the STORAGE_PORT_CODE_SET enumeration. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="StoragePortCodeSetReserved"></a><a
    ///id="storageportcodesetreserved"></a><a id="STORAGEPORTCODESETRESERVED"></a><dl>
    ///<dt><b>StoragePortCodeSetReserved</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Indicates an unknown storage
    ///adapter driver type. </td> </tr> <tr> <td width="40%"><a id="StoragePortCodeSetStorport"></a><a
    ///id="storageportcodesetstorport"></a><a id="STORAGEPORTCODESETSTORPORT"></a><dl>
    ///<dt><b>StoragePortCodeSetStorport</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Storage adapter driver is a
    ///Storport-miniport driver. </td> </tr> <tr> <td width="40%"><a id="StoragePortCodeSetSCSIport"></a><a
    ///id="storageportcodesetscsiport"></a><a id="STORAGEPORTCODESETSCSIPORT"></a><dl>
    ///<dt><b>StoragePortCodeSetSCSIport</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Storage adapter driver is a
    ///SCSI Port-miniport driver. </td> </tr> </table>
    STORAGE_PORT_CODE_SET Portdriver;
    ///Indicates whether a LUN reset is supported.
    ubyte    LUNResetSupported;
    ///Indicates whether a target reset is supported.
    ubyte    TargetResetSupported;
    ushort   IoTimeoutValue;
    ubyte    ExtraIoInfoSupported;
    ubyte[3] Reserved0;
    uint     Reserved1;
}

///Used with the IOCTL_STORAGE_QUERY_PROPERTY control code request to retrieve the device ID descriptor data for a
///device.
struct STORAGE_DEVICE_ID_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure.
    uint     Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint     Size;
    ///Contains the number of identifiers reported by the device in the <b>Identifiers</b> array.
    uint     NumberOfIdentifiers;
    ///Contains a variable-length array of identification descriptors.
    ubyte[1] Identifiers;
}

///Used in conjunction with the IOCTL_STORAGE_QUERY_PROPERTY request to retrieve the seek penalty descriptor data for a
///device.
struct DEVICE_SEEK_PENALTY_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure.
    uint  Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint  Size;
    ///Specifies whether the device incurs a seek penalty.
    ubyte IncursSeekPenalty;
}

///Reserved for system use.
struct DEVICE_WRITE_AGGREGATION_DESCRIPTOR
{
    ///Contains the size, in bytes, of this structure. The value of this member will change as members are added to the
    ///structure.
    uint  Version;
    ///Specifies the total size of the descriptor, in bytes.
    uint  Size;
    ///<b>TRUE</b> if the device benefits from write aggregation.
    ubyte BenefitsFromWriteAggregation;
}

///Used in conjunction with the IOCTL_STORAGE_QUERY_PROPERTY request to retrieve the trim descriptor data for a device.
struct DEVICE_TRIM_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure.
    uint  Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint  Size;
    ///Specifies whether trim is enabled for the device.
    ubyte TrimEnabled;
}

///The <b>DEVICE_LB_PROVISIONING_DESCRIPTOR</b> structure is one of the query result structures returned from an
///IOCTL_STORAGE_QUERY_PROPERTY request. This structure contains the thin provisioning capabilities for a storage
///device.
struct DEVICE_LB_PROVISIONING_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure.
    uint     Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint     Size;
    ubyte    _bitfield41;
    ///Reserved.
    ubyte[7] Reserved1;
    ///The optimal number of logical sectors for unmap granularity for the device.
    ulong    OptimalUnmapGranularity;
    ///The current value, in logical sectors, set for unmap granularity alignment on the device.
    ulong    UnmapGranularityAlignment;
    ///<b>Starting in Windows 10: </b>The maximum number of LBAs that can be unmapped in a single unmap command, in
    ///logical blocks.
    uint     MaxUnmapLbaCount;
    ///<b>Starting in Windows 10: </b>The maximum number of descriptors allowed in a single unmap command.
    uint     MaxUnmapBlockDescriptorCount;
}

///The <b>DEVICE_POWER_DESCRIPTOR</b> structure describes the power capabilities of a storage device.
struct DEVICE_POWER_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure.
    uint     Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint     Size;
    ///True if device attention is supported. Otherwise, false.
    ubyte    DeviceAttentionSupported;
    ///True if the device supports asynchronous notifications, delivered via <b>IOCTL_STORAGE_EVENT_NOTIFICATION</b>.
    ///Otherwise, false.
    ubyte    AsynchronousNotificationSupported;
    ///True if the device has been registered for runtime idle power management. Otherwise, false.
    ubyte    IdlePowerManagementEnabled;
    ///True if the device will be powered off when put into D3 power state. Otherwise, false.
    ubyte    D3ColdEnabled;
    ///True if the platform supports <b>D3ColdEnabled</b> for this device. Otherwise, false.
    ubyte    D3ColdSupported;
    ubyte    NoVerifyDuringIdlePower;
    ///Reserved.
    ubyte[2] Reserved;
    ///The idle timeout value in milliseconds. This member is ignored unless <b>IdlePowerManagementEnabled</b> is true.
    uint     IdleTimeoutInMS;
}

///The <b>DEVICE_COPY_OFFLOAD_DESCRIPTOR</b> structure is one of the query result structures returned from an
///IOCTL_STORAGE_QUERY_PROPERTY request. This structure contains the copy offload capabilities for a storage device.
struct DEVICE_COPY_OFFLOAD_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure.
    uint     Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint     Size;
    ///The maximum lifetime of the token, in seconds.
    uint     MaximumTokenLifetime;
    ///The default lifetime of the token, in seconds.
    uint     DefaultTokenLifetime;
    ///The maximum transfer size, in bytes.
    ulong    MaximumTransferSize;
    ///The optimal transfer size, in bytes.
    ulong    OptimalTransferCount;
    ///The maximum number of data descriptors.
    uint     MaximumDataDescriptors;
    ///The maximum transfer length, in blocks, per descriptor.
    uint     MaximumTransferLengthPerDescriptor;
    ///The optimal transfer length per descriptor.
    uint     OptimalTransferLengthPerDescriptor;
    ///The granularity of the optimal transfer length, in blocks. Transfer lengths that are not an even multiple of this
    ///length may be delayed.
    ushort   OptimalTransferLengthGranularity;
    ///Reserved.
    ubyte[2] Reserved;
}

///Reserved for system use.
struct STORAGE_DEVICE_RESILIENCY_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure. Set to <code>sizeof(STORAGE_DEVICE_RESILIENCY_DESCRIPTOR)</code>.
    uint Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint Size;
    ///Byte offset to the null-terminated ASCII string containing the resiliency properties Name. For devices with no
    ///Name property, this will be zero.
    uint NameOffset;
    ///Number of logical copies of data that are available.
    uint NumberOfLogicalCopies;
    ///Number of complete copies of data that are stored.
    uint NumberOfPhysicalCopies;
    ///Number of disks that can fail without leading to data loss.
    uint PhysicalDiskRedundancy;
    ///Number of columns in the storage device.
    uint NumberOfColumns;
    ///Size of a stripe unit of the storage device, in bytes. This is also referred to as the stripe width or interleave
    ///of the storage device.
    uint Interleave;
}

///Describes protocol-specific device data, provided in the input and output buffer of an IOCTL_STORAGE_QUERY_PROPERTY
///request.
struct STORAGE_PROTOCOL_SPECIFIC_DATA
{
    ///The protocol type. Values for this member are defined in the STORAGE_PROTOCOL_TYPE enumeration.
    STORAGE_PROTOCOL_TYPE ProtocolType;
    ///The protocol data type. Data types are defined in the STORAGE_PROTOCOL_NVME_DATA_TYPE and
    ///STORAGE_PROTOCOL_ATA_DATA_TYPE enumerations.
    uint DataType;
    ///The protocol data request value.
    uint ProtocolDataRequestValue;
    ///The sub value of the protocol data request.
    uint ProtocolDataRequestSubValue;
    ///The offset of the data buffer that is from the beginning of this structure. The typical value can be
    ///sizeof(<b>STORAGE_PROTOCOL_SPECIFIC_DATA</b>).
    uint ProtocolDataOffset;
    ///The length of the protocol data.
    uint ProtocolDataLength;
    ///The returned data.
    uint FixedProtocolReturnData;
    uint ProtocolDataRequestSubValue2;
    uint ProtocolDataRequestSubValue3;
    ///Reserved for future use.
    uint Reserved;
}

///This structure is used in conjunction with IOCTL_STORAGE_QUERY_PROPERTY to return protocol-specific data from a
///storage device or adapter. .
struct STORAGE_PROTOCOL_DATA_DESCRIPTOR
{
    ///The version of this structure.
    uint Version;
    ///The total size of the descriptor, including the space for all protocol data.
    uint Size;
    ///The protocol-specific data, of type STORAGE_PROTOCOL_SPECIFIC_DATA.
    STORAGE_PROTOCOL_SPECIFIC_DATA ProtocolSpecificData;
}

///Describes device temperature data. Returned as part of STORAGE_TEMPERATURE_DATA_DESCRIPTOR when querying for
///temperature data with an IOCTL_STORAGE_QUERY_PROPERTY request.
struct STORAGE_TEMPERATURE_INFO
{
    ///Identifies the instance of temperature information. Starts from 0. Index 0 may indicate a composite value.
    ushort Index;
    ///A signed value that indicates the current temperature, in degrees Celsius.
    short  Temperature;
    ///A signed value that specifies the maximum temperature within the desired threshold, in degrees Celsius.
    short  OverThreshold;
    ///A signed value that specifies the minimum temperature within the desired threshold, in degrees Celsius.
    short  UnderThreshold;
    ///Indicates if <i>OverThreshold</i> can be changed by using IOCTL_STORAGE_SET_TEMPERATURE_THRESHOLD.
    ubyte  OverThresholdChangable;
    ///Indicates if <i>UnderThreshold</i> can be changed by using IOCTL_STORAGE_SET_TEMPERATURE_THRESHOLD.
    ubyte  UnderThresholdChangable;
    ///Indicates if a notification will be generated when the current temperature crosses a threshold.
    ubyte  EventGenerated;
    ///Reserved for future use.
    ubyte  Reserved0;
    ///Reserved for future use.
    uint   Reserved1;
}

///This structure is used in conjunction with IOCTL_STORAGE_QUERY_PROPERTY to return temperature data from a storage
///device or adapter.
struct STORAGE_TEMPERATURE_DATA_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure.
    uint     Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint     Size;
    ///Indicates the minimum temperature in degrees Celsius that may prevent normal operation. Exceeding this
    ///temperature may result in possible data loss, automatic device shutdown, extreme performance throttling, or
    ///permanent damage.
    short    CriticalTemperature;
    ///Indicates the maximum temperature in degrees Celsius at which the device is capable of operating continuously
    ///without degrading operation or reliability.
    short    WarningTemperature;
    ///Specifies the number of STORAGE_TEMPERATURE_INFO structures reported in <b>TemperatureInfo</b>. More than one set
    ///of temperature data may be returned when there are multiple sensors in the drive.
    ushort   InfoCount;
    ///Reserved for future use.
    ubyte[2] Reserved0;
    ///Reserved for future use.
    uint[2]  Reserved1;
    ///Device temperature data, of type STORAGE_TEMPERATURE_INFO.
    STORAGE_TEMPERATURE_INFO[1] TemperatureInfo;
}

///This structure is used to set the over or under temperature threshold of a storage device (via
///IOCTL_STORAGE_SET_TEMPERATURE_THRESHOLD).
struct STORAGE_TEMPERATURE_THRESHOLD
{
    ///The version of the structure.
    uint   Version;
    ///The size of this structure. This should be set to sizeof(<b>STORAGE_TEMPERATURE_THRESHOLD</b>).
    uint   Size;
    ///Flags set for this request. The following are valid flags. <table> <tr> <th>Flag</th> <th>Description</th> </tr>
    ///<tr> <td><b>STORAGE_PROTOCOL_COMMAND_FLAG_ADAPTER_REQUEST</b></td> <td>This flag indicates the request to target
    ///an adapter instead of device.</td> </tr> </table>
    ushort Flags;
    ///Identifies the instance of temperature information. Starts from 0. Index 0 may indicate a composite value.
    ushort Index;
    ///A signed value that indicates the temperature of the threshold, in degrees Celsius.
    short  Threshold;
    ///Indicates if the <i>Threshold</i> specifies the over or under temperature threshold. If <b>true</b>, set the
    ///<b>OverThreshold</b> temperature value of the device; otherwise, set the <b>UnderThreshold</b> temperature value.
    ubyte  OverThreshold;
    ///Reserved for future use.
    ubyte  Reserved;
}

///Storage specification version.
union STORAGE_SPEC_VERSION
{
    struct
    {
        union MinorVersion
        {
            struct
            {
                ubyte SubMinor;
                ubyte Minor;
            }
            ushort AsUshort;
        }
        ushort MajorVersion;
    }
    uint AsUlong;
}

///Describes a physical storage device.
struct STORAGE_PHYSICAL_DEVICE_DATA
{
    ///Specifies the device ID.
    uint                 DeviceId;
    ///Value(s) of bitmask from STORAGE_COMPONENT_ROLE_xxx
    uint                 Role;
    ///A STORAGE_COMPONENT_HEALTH_STATUS enumeration.
    STORAGE_COMPONENT_HEALTH_STATUS HealthStatus;
    ///A STORAGE_PROTOCOL_TYPE enumeration.
    STORAGE_PROTOCOL_TYPE CommandProtocol;
    ///A STORAGE_SPEC_VERSION structure that specifies the supported storage spec version. For example: SBC 3, SATA 3.2,
    ///NVMe 1.2
    STORAGE_SPEC_VERSION SpecVersion;
    ///A STORAGE_DEVICE_FORM_FACTOR enumeration.
    STORAGE_DEVICE_FORM_FACTOR FormFactor;
    ///Specifies the device vendor.
    ubyte[8]             Vendor;
    ///Specifies the device model.
    ubyte[40]            Model;
    ///Specifies the firmware revision of the device.
    ubyte[16]            FirmwareRevision;
    ///In units of kilobytes (1024 bytes).
    ulong                Capacity;
    ///Reserved for future use.
    ubyte[32]            PhysicalLocation;
    uint[2]              Reserved;
}

///Describes a physical storage adapter.
struct STORAGE_PHYSICAL_ADAPTER_DATA
{
    ///Specifies the adapter ID.
    uint                 AdapterId;
    ///A STORAGE_COMPONENT_HEALTH_STATUS-typed value.
    STORAGE_COMPONENT_HEALTH_STATUS HealthStatus;
    ///A STORAGE_PROTOCOL_TYPE-typed value.
    STORAGE_PROTOCOL_TYPE CommandProtocol;
    ///A STORAGE_SPEC_VERSION-typed value that specifies the supported storage spec version (for example, AHCI 1.3.1).
    STORAGE_SPEC_VERSION SpecVersion;
    ubyte[8]             Vendor;
    ///Specifies the adapter model.
    ubyte[40]            Model;
    ///Specifies the firmware revision.
    ubyte[16]            FirmwareRevision;
    ///Reserved for future use.
    ubyte[32]            PhysicalLocation;
    ///Indicates whether an expander is connected.
    ubyte                ExpanderConnected;
    ///Reserved.
    ubyte[3]             Reserved0;
    ///Reserved.
    uint[3]              Reserved1;
}

///Specifies the physical device data of a storage node.
struct STORAGE_PHYSICAL_NODE_DATA
{
    ///The hardware ID of the storage node.
    uint    NodeId;
    ///A value of 0 or 1 that indicates the adapter count in the storage node.
    uint    AdapterCount;
    ///The data length of the storage adapter in the storage node, in units of kilobytes (1024 bytes).
    uint    AdapterDataLength;
    ///The data offset from the beginning of the data structure. The buffer contains an array of
    ///STORAGE_PHYSICAL_ADAPTER_DATA.
    uint    AdapterDataOffset;
    ///A value less than or equal to 1.
    uint    DeviceCount;
    ///The data length of the storage device in the storage node, in units of kilobytes (1024 bytes).
    uint    DeviceDataLength;
    ///The data offset from the beginning of the data structure. The buffer contains an array of
    ///STORAGE_PHYSICAL_DEVICE_DATA.
    uint    DeviceDataOffset;
    uint[3] Reserved;
}

///The <b>STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR</b> structure is one of the query result structures returned from an
///IOCTL_STORAGE_QUERY_PROPERTY request. This structure describes storage device physical topology.
struct STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR
{
    ///Contains the size of this structure, in bytes. Set to <code>sizeof(STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR)</code>.
    uint Version;
    ///Specifies the total size of the data, in bytes. Should be &gt;=
    ///<code>sizeof(STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR)</code>.
    uint Size;
    ///Specifies the number of nodes.
    uint NodeCount;
    ///Reserved.
    uint Reserved;
    STORAGE_PHYSICAL_NODE_DATA[1] Node;
}

///The output buffer for the StorageDeviceIoCapabilityProperty as defined in STORAGE_PROPERTY_ID.
struct STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR
{
    ///The version of this structure. The Size serves as the version.
    uint Version;
    ///The size of this structure.
    uint Size;
    ///The logical unit number (LUN) max outstanding I/O count.
    uint LunMaxIoCount;
    uint AdapterMaxIoCount;
}

///Reserved for future use.
struct STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR
{
    ///Contains the version of the data reported.
    uint  Version;
    ///Indicates the quantity of data reported, in bytes. This is the
    ///<code>sizeof(STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR)</code>.
    uint  Size;
    ulong Attributes;
}

///The NULL-terminated Unicode string of the adapter serial number for the StorageAdapterSerialNumberProperty as defined
///in [STORAGE_PROPERTY_ID](ne-winioctl-storage_property_id.md).
struct STORAGE_ADAPTER_SERIAL_NUMBER
{
    ///The version of this structure. The Size serves as the version.
    uint        Version;
    ///The size of this structure.
    uint        Size;
    ushort[128] SerialNumber;
}

///Used with the IOCTL_STORAGE_QUERY_PROPERTY control code to retrieve information about a device's write cache
///property.
struct STORAGE_WRITE_CACHE_PROPERTY
{
    ///Contains the size of this structure, in bytes. The value of this member will change as members are added to the
    ///structure.
    uint               Version;
    ///Specifies the total size of the data returned, in bytes. This may include data that follows this structure.
    uint               Size;
    ///A value from the WRITE_CACHE_TYPE enumeration that indicates the current write cache type. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="WriteCacheTypeUnknown"></a><a
    ///id="writecachetypeunknown"></a><a id="WRITECACHETYPEUNKNOWN"></a><dl> <dt><b>WriteCacheTypeUnknown</b></dt>
    ///<dt>0</dt> </dl> </td> <td width="60%"> The system cannot report the type of the write cache. </td> </tr> <tr>
    ///<td width="40%"><a id="WriteCacheTypeNone"></a><a id="writecachetypenone"></a><a id="WRITECACHETYPENONE"></a><dl>
    ///<dt><b>WriteCacheTypeNone</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The device does not have a write
    ///cache. </td> </tr> <tr> <td width="40%"><a id="WriteCacheTypeWriteBack"></a><a
    ///id="writecachetypewriteback"></a><a id="WRITECACHETYPEWRITEBACK"></a><dl> <dt><b>WriteCacheTypeWriteBack</b></dt>
    ///<dt>2</dt> </dl> </td> <td width="60%"> The device has a write-back cache. </td> </tr> <tr> <td width="40%"><a
    ///id="WriteCacheTypeWriteThrough"></a><a id="writecachetypewritethrough"></a><a
    ///id="WRITECACHETYPEWRITETHROUGH"></a><dl> <dt><b>WriteCacheTypeWriteThrough</b></dt> <dt>3</dt> </dl> </td> <td
    ///width="60%"> The device has a write-through cache. </td> </tr> </table>
    WRITE_CACHE_TYPE   WriteCacheType;
    ///A value from the WRITE_CACHE_ENABLE enumeration that indicates whether the write cache is enabled. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="WriteCacheEnableUnknown"></a><a
    ///id="writecacheenableunknown"></a><a id="WRITECACHEENABLEUNKNOWN"></a><dl> <dt><b>WriteCacheEnableUnknown</b></dt>
    ///<dt>0</dt> </dl> </td> <td width="60%"> The system cannot report whether the device's write cache is enabled or
    ///disabled. </td> </tr> <tr> <td width="40%"><a id="WriteCacheDisabled"></a><a id="writecachedisabled"></a><a
    ///id="WRITECACHEDISABLED"></a><dl> <dt><b>WriteCacheDisabled</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The
    ///device's write cache is disabled. </td> </tr> <tr> <td width="40%"><a id="WriteCacheEnabled"></a><a
    ///id="writecacheenabled"></a><a id="WRITECACHEENABLED"></a><dl> <dt><b>WriteCacheEnabled</b></dt> <dt>2</dt> </dl>
    ///</td> <td width="60%"> The device's write cache is enabled. </td> </tr> </table>
    WRITE_CACHE_ENABLE WriteCacheEnabled;
    ///A value from the WRITE_CACHE_CHANGE enumeration that indicates whether if the host can change the write cache
    ///characteristics. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="WriteCacheChangeUnknown"></a><a id="writecachechangeunknown"></a><a id="WRITECACHECHANGEUNKNOWN"></a><dl>
    ///<dt><b>WriteCacheChangeUnknown</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> The system cannot report the
    ///write cache change capability of the device. </td> </tr> <tr> <td width="40%"><a
    ///id="WriteCacheNotChangeable"></a><a id="writecachenotchangeable"></a><a id="WRITECACHENOTCHANGEABLE"></a><dl>
    ///<dt><b>WriteCacheNotChangeable</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Host software cannot change the
    ///characteristics of the device's write cache </td> </tr> <tr> <td width="40%"><a id="WriteCacheChangeable"></a><a
    ///id="writecachechangeable"></a><a id="WRITECACHECHANGEABLE"></a><dl> <dt><b>WriteCacheChangeable</b></dt>
    ///<dt>2</dt> </dl> </td> <td width="60%"> Host software can change the characteristics of the device's write cache
    ///</td> </tr> </table>
    WRITE_CACHE_CHANGE WriteCacheChangeable;
    ///A value from the WRITE_THROUGH enumeration that indicates whether the device supports write-through caching.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="WriteThroughUnknown"></a><a
    ///id="writethroughunknown"></a><a id="WRITETHROUGHUNKNOWN"></a><dl> <dt><b>WriteThroughUnknown</b></dt> <dt>0</dt>
    ///</dl> </td> <td width="60%"> Indicates that no information is available concerning the write-through capabilities
    ///of the device. </td> </tr> <tr> <td width="40%"><a id="WriteThroughNotSupported"></a><a
    ///id="writethroughnotsupported"></a><a id="WRITETHROUGHNOTSUPPORTED"></a><dl>
    ///<dt><b>WriteThroughNotSupported</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Indicates that the device does
    ///not support write-through operations. </td> </tr> <tr> <td width="40%"><a id="WriteThroughSupported"></a><a
    ///id="writethroughsupported"></a><a id="WRITETHROUGHSUPPORTED"></a><dl> <dt><b>WriteThroughSupported</b></dt>
    ///<dt>2</dt> </dl> </td> <td width="60%"> Indicates that the device supports write-through operations. </td> </tr>
    ///</table>
    WRITE_THROUGH      WriteThroughSupported;
    ///A <b>BOOLEAN</b> value that indicates whether the device allows host software to flush the device cache. If
    ///<b>TRUE</b>, the device allows host software to flush the device cache. If <b>FALSE</b>, host software cannot
    ///flush the device cache.
    ubyte              FlushCacheSupported;
    ///A <b>BOOLEAN</b> value that indicates whether a user can configure the device's power protection characteristics
    ///in the registry. If <b>TRUE</b>, a user can configure the device's power protection characteristics in the
    ///registry. If <b>FALSE</b>, the user cannot configure the device's power protection characteristics in the
    ///registry.
    ubyte              UserDefinedPowerProtection;
    ///A <b>BOOLEAN</b> value that indicates whether the device has a battery backup for the write cache. If
    ///<b>TRUE</b>, the device has a battery backup for the write cache. If <b>FALSE</b>, the device does not have a
    ///battery backup for the writer cache.
    ubyte              NVCacheEnabled;
}

///This structure is used as an input and output buffer for the IOCTL_STORAGE_DEVICE_POWER_CAP.
struct STORAGE_DEVICE_POWER_CAP
{
    ///The version of this structure. This should be set to STORAGE_DEVICE_POWER_CAP_VERSION_V1.
    uint  Version;
    ///The size of this structure.
    uint  Size;
    ///The units of the <i>MaxPower</i> value, of type STORAGE_DEVICE_POWER_CAP_UNITS.
    STORAGE_DEVICE_POWER_CAP_UNITS Units;
    ulong MaxPower;
}

///This structure contains a firmware image payload to be downloaded to the target.
struct STORAGE_HW_FIRMWARE_DOWNLOAD
{
    ///The version of this structure. This should be set to sizeof(STORAGE_HW_FIRMWARE_DOWNLOAD).
    uint     Version;
    ///The size of this structure and the download image buffer.
    uint     Size;
    ///Flags associated with this download. The following are valid flags that this member can hold. <table> <tr>
    ///<th>Flag</th> <th>Description</th> </tr> <tr> <td>STORAGE_HW_FIRMWARE_REQUEST_FLAG_CONTROLLER</td> <td>Indicates
    ///that the target of the request is a controller or adapter, different than the device handler or object itself
    ///(e.g. NVMe SSD or HBA).</td> </tr> <tr> <td>STORAGE_HW_FIRMWARE_REQUEST_FLAG_LAST_SEGMENT</td> <td>Indicates that
    ///the current firmware image segment is the last one.</td> </tr> </table>
    uint     Flags;
    ///The slot number that the firmware image will be downloaded to.
    ubyte    Slot;
    ///Reserved for future use.
    ubyte[3] Reserved;
    ///The offset in this buffer of where the Image file begins. This should be aligned to <b>ImagePayloadAlignment</b>
    ///from STORAGE_HW_FIRMWARE_INFO.
    ulong    Offset;
    ///The buffer size of the ImageBuffer. This should be a multiple of <b>ImagePayloadAlignment</b> from
    ///STORAGE_HW_FIRMWARE_INFO.
    ulong    BufferSize;
    ///The firmware image file.
    ubyte[1] ImageBuffer;
}

///This structure contains information about the downloaded firmware to activate.
struct STORAGE_HW_FIRMWARE_ACTIVATE
{
    ///The version of this structure. This should be set to sizeof(STORAGE_HW_FIRMWARE_ACTIVATE).
    uint     Version;
    ///The size of this structure. This should be set to sizeof(STORAGE_HW_FIRMWARE_ACTIVATE).
    uint     Size;
    ///The flags associated with the activation request. The following are valid flags that can be set in this member.
    ///<table> <tr> <th>Flag</th> <th>Description</th> </tr> <tr> <td>STORAGE_HW_FIRMWARE_REQUEST_FLAG_CONTROLLER</td>
    ///<td>Indicates that the target of the request is a controller or adapter, different than the device handle or
    ///object itself (e.g. NVMe SSD or HBA).</td> </tr> <tr>
    ///<td>STORAGE_HW_FIRMWARE_REQUEST_FLAG_SWITCH_TO_EXISTING_FIRMWARE</td> <td>Indicates that the existing firmware
    ///image in the specified slot should be activated.</td> </tr> </table>
    uint     Flags;
    ///The slot with the firmware image that is to be activated.
    ubyte    Slot;
    ///Reserved for future use.
    ubyte[3] Reserved0;
}

///This structure is used as an input buffer when using the pass-through mechanism to issue a vendor-specific command to
///a storage device (via IOCTL_STORAGE_PROTOCOL_COMMAND).
struct STORAGE_PROTOCOL_COMMAND
{
    ///The version of this structure. This should be set to <b>STORAGE_PROTOCOL_STRUCTURE_VERSION</b>.
    uint     Version;
    ///The size of this structure. This should be set to sizeof(<b>STORAGE_PROTOCOL_COMMAND</b>).
    uint     Length;
    ///The protocol type, of type STORAGE_PROTOCOL_TYPE.
    STORAGE_PROTOCOL_TYPE ProtocolType;
    ///Flags set for this request. The following are valid flags. <table> <tr> <th>Flag</th> <th>Description</th> </tr>
    ///<tr> <td><b>STORAGE_PROTOCOL_COMMAND_FLAG_ADAPTER_REQUEST</b></td> <td>This flag indicates the request to target
    ///an adapter instead of device.</td> </tr> </table>
    uint     Flags;
    ///The status of the request made to the storage device. In Windows 10, possible values include: <table> <tr>
    ///<th>Status value</th> <th>Description</th> </tr> <tr> <td><b>STORAGE_PROTOCOL_STATUS_PENDING</b></td> <td>The
    ///request is pending.</td> </tr> <tr> <td><b>STORAGE_PROTOCOL_STATUS_SUCCESS</b></td> <td>The request has completed
    ///successfully.</td> </tr> <tr> <td><b>STORAGE_PROTOCOL_STATUS_ERROR</b></td> <td>The request has encountered an
    ///error.</td> </tr> <tr> <td><b>STORAGE_PROTOCOL_STATUS_INVALID_REQUEST</b></td> <td>The request is not valid.</td>
    ///</tr> <tr> <td><b>STORAGE_PROTOCOL_STATUS_NO_DEVICE</b></td> <td>A device is not available to make a request
    ///to.</td> </tr> <tr> <td><b>STORAGE_PROTOCOL_STATUS_BUSY</b></td> <td>The device is busy acting on the
    ///request.</td> </tr> <tr> <td><b>STORAGE_PROTOCOL_STATUS_DATA_OVERRUN</b></td> <td>The device encountered a data
    ///overrun while acting on the request.</td> </tr> <tr>
    ///<td><b>STORAGE_PROTOCOL_STATUS_INSUFFICIENT_RESOURCES</b></td> <td>The device cannot complete the request due to
    ///insufficient resources.</td> </tr> <tr> <td><b>STORAGE_PROTOCOL_STATUS_NOT_SUPPORTED</b></td> <td>The request is
    ///not supported.</td> </tr> </table>
    uint     ReturnStatus;
    ///The error code for this request. This is optionally set.
    uint     ErrorCode;
    ///The length of the command. A non-zero value must be set by the caller.
    uint     CommandLength;
    ///The length of the error buffer. This is optionally set and can be set to 0.
    uint     ErrorInfoLength;
    ///The size of the buffer that is to be transferred to the device. This is only used with a WRITE request.
    uint     DataToDeviceTransferLength;
    ///The size of the buffer this is to be transferred from the device. This is only used with a READ request.
    uint     DataFromDeviceTransferLength;
    ///How long to wait for the device until timing out. This is set in units of seconds.
    uint     TimeOutValue;
    ///The offset of the error buffer. This must be pointer-aligned.
    uint     ErrorInfoOffset;
    ///The offset of the buffer that is to be transferred to the device. This must be pointer-aligned and is only used
    ///with a WRITE request.
    uint     DataToDeviceBufferOffset;
    ///The offset of the buffer that is to be transferred from the device. This must be pointer-aligned and is only used
    ///with a READ request.
    uint     DataFromDeviceBufferOffset;
    ///Command-specific data passed along with the command. This depends on the command from the driver, and is
    ///optionally set.
    uint     CommandSpecific;
    ///Reserved for future use.
    uint     Reserved0;
    ///The return data. This is optionally set. Some protocols such as NVMe, may return a small amount of data (DWORD0
    ///from completion queue entry) without the need of a separate device data transfer.
    uint     FixedProtocolReturnData;
    ///Reserved for future use.
    uint[3]  Reserved1;
    ///The vendor-specific command that is to be passed-through to the device.
    ubyte[1] Command;
}

///Contains information used in formatting a contiguous set of disk tracks. It is used by the IOCTL_DISK_FORMAT_TRACKS
///control code.
struct FORMAT_PARAMETERS
{
    ///The media type. For a list of values, see MEDIA_TYPE.
    MEDIA_TYPE MediaType;
    ///The cylinder number at which to begin the format.
    uint       StartCylinderNumber;
    ///The cylinder number at which to end the format.
    uint       EndCylinderNumber;
    ///The beginning head location.
    uint       StartHeadNumber;
    ///The ending head location.
    uint       EndHeadNumber;
}

///Contains information used in formatting a contiguous set of disk tracks. It is used by the
///IOCTL_DISK_FORMAT_TRACKS_EX control code.
struct FORMAT_EX_PARAMETERS
{
    ///The media type. For a list of values, see MEDIA_TYPE.
    MEDIA_TYPE MediaType;
    ///The cylinder number at which to begin the format.
    uint       StartCylinderNumber;
    ///The cylinder number at which to end the format.
    uint       EndCylinderNumber;
    ///The beginning head location.
    uint       StartHeadNumber;
    ///The ending head location.
    uint       EndHeadNumber;
    ///The length of the gap between two successive sectors on a track.
    ushort     FormatGapLength;
    ///The number of sectors in each track.
    ushort     SectorsPerTrack;
    ///An array of values specifying the sector numbers of the sectors to be included in the track to be formatted.
    ushort[1]  SectorNumber;
}

///Describes the geometry of disk devices and media.
struct DISK_GEOMETRY
{
    ///The number of cylinders. See [**LARGE_INTEGER**](../winnt/ns-winnt-large_integer-r1.md).
    LARGE_INTEGER Cylinders;
    ///The type of media. For a list of values, see [MEDIA_TYPE](ne-winioctl-media_type.md).
    MEDIA_TYPE    MediaType;
    ///The number of tracks per cylinder.
    uint          TracksPerCylinder;
    ///The number of sectors per track.
    uint          SectorsPerTrack;
    ///The number of bytes per sector.
    uint          BytesPerSector;
}

///Contains information about a disk partition. <div class="alert"><b>Note</b> <b>PARTITION_INFORMATION</b> has been
///superseded by the PARTITION_INFORMATION_EX structure.</div><div> </div>
struct PARTITION_INFORMATION
{
    ///The starting offset of the partition.
    LARGE_INTEGER StartingOffset;
    ///The length of the partition, in bytes.
    LARGE_INTEGER PartitionLength;
    ///The number of hidden sectors in the partition.
    uint          HiddenSectors;
    ///The number of the partition (1-based).
    uint          PartitionNumber;
    ///The type of partition. For a list of values, see Disk Partition Types.
    ubyte         PartitionType;
    ///If this member is <b>TRUE</b>, the partition is bootable.
    ubyte         BootIndicator;
    ///If this member is <b>TRUE</b>, the partition is of a recognized type.
    ubyte         RecognizedPartition;
    ///If this member is <b>TRUE</b>, the partition information has changed. When you change a partition (with
    ///IOCTL_DISK_SET_DRIVE_LAYOUT), the system uses this member to determine which partitions have changed and need
    ///their information rewritten.
    ubyte         RewritePartition;
}

///Contains information used to set a disk partition's type. <div class="alert"><b>Note</b>
///<b>SET_PARTITION_INFORMATION</b> has been superseded by the PARTITION_INFORMATION_EX structure.</div><div> </div>
struct SET_PARTITION_INFORMATION
{
    ///The type of partition. For a list of values, see Disk Partition Types.
    ubyte PartitionType;
}

///Contains information about the partitions of a drive. > [!NOTE] > **DRIVE_LAYOUT_INFORMATION** is superseded
///[**DRIVE_LAYOUT_INFORMATION_EX**](ns-winioctl-drive_layout_information_ex.md) structure.
struct DRIVE_LAYOUT_INFORMATION
{
    ///The number of partitions on a drive. On disks with the MBR layout, this value is always a multiple of 4. Any
    ///partitions that are unused have a partition type of **PARTITION_ENTRY_UNUSED** (0).
    uint PartitionCount;
    ///The drive signature value.
    uint Signature;
    ///A variable-sized array of [**PARTITION_INFORMATION**](ns-winioctl-partition_information.md) structures, one
    ///structure for each partition on a drive.
    PARTITION_INFORMATION[1] PartitionEntry;
}

///Contains information used to verify a disk extent. It is the output buffer for the IOCTL_DISK_VERIFY control code.
struct VERIFY_INFORMATION
{
    ///The starting offset of the disk extent.
    LARGE_INTEGER StartingOffset;
    ///The length of the disk extent, in bytes.
    uint          Length;
}

///Contains disk block reassignment data. This is a variable length structure where the last member is an array of block
///numbers to be reassigned. It is used by the IOCTL_DISK_REASSIGN_BLOCKS control code.
struct REASSIGN_BLOCKS
{
    ///This member is reserved. Do not use it. Set it to zero.
    ushort  Reserved;
    ///The number of blocks to be reassigned. This is the number of elements that are in the <b>BlockNumber</b> member
    ///array.
    ushort  Count;
    ///An array of <b>Count</b> block numbers, one for each block to be reassigned.
    uint[1] BlockNumber;
}

///Contains disk block reassignment data. This is a variable length structure where the last member is an array of block
///numbers to be reassigned. It is used by the IOCTL_DISK_REASSIGN_BLOCKS_EX control code.
struct REASSIGN_BLOCKS_EX
{
align (1):
    ///This member is reserved. Do not use it. Set it to 0 (zero).
    ushort           Reserved;
    ///The number of blocks to be reassigned. This is the number of elements that are in the <b>BlockNumber</b> member
    ///array.
    ushort           Count;
    ///An array of <b>Count</b> block numbers, one for each block to be reassigned.
    LARGE_INTEGER[1] BlockNumber;
}

///Contains <b>GUID</b> partition table (GPT) partition information.
struct PARTITION_INFORMATION_GPT
{
    ///A <b>GUID</b> that identifies the partition type. Each partition type that the EFI specification supports is
    ///identified by its own <b>GUID</b>, which is published by the developer of the partition. This member can be one
    ///of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="PARTITION_BASIC_DATA_GUID"></a><a id="partition_basic_data_guid"></a><dl>
    ///<dt><b>PARTITION_BASIC_DATA_GUID</b></dt> <dt>ebd0a0a2-b9e5-4433-87c0-68b6b72699c7</dt> </dl> </td> <td
    ///width="60%"> The data partition type that is created and recognized by Windows. Only partitions of this type can
    ///be assigned drive letters, receive volume <b>GUID</b> paths, host mounted folders (also called volume mount
    ///points), and be enumerated by calls to FindFirstVolume and FindNextVolume. This value can be set only for basic
    ///disks, with one exception. If both <b>PARTITION_BASIC_DATA_GUID</b> and <b>GPT_ATTRIBUTE_PLATFORM_REQUIRED</b>
    ///are set for a partition on a basic disk that is subsequently converted to a dynamic disk, the partition remains a
    ///basic partition, even though the rest of the disk is a dynamic disk. This is because the partition is considered
    ///to be an OEM partition on a GPT disk. </td> </tr> <tr> <td width="40%"><a id="PARTITION_ENTRY_UNUSED_GUID"></a><a
    ///id="partition_entry_unused_guid"></a><dl> <dt><b>PARTITION_ENTRY_UNUSED_GUID</b></dt>
    ///<dt>00000000-0000-0000-0000-000000000000</dt> </dl> </td> <td width="60%"> There is no partition. This value can
    ///be set for basic and dynamic disks. </td> </tr> <tr> <td width="40%"><a id="PARTITION_SYSTEM_GUID"></a><a
    ///id="partition_system_guid"></a><dl> <dt><b>PARTITION_SYSTEM_GUID</b></dt>
    ///<dt>c12a7328-f81f-11d2-ba4b-00a0c93ec93b</dt> </dl> </td> <td width="60%"> The partition is an EFI system
    ///partition. This value can be set for basic and dynamic disks. </td> </tr> <tr> <td width="40%"><a
    ///id="PARTITION_MSFT_RESERVED_GUID"></a><a id="partition_msft_reserved_guid"></a><dl>
    ///<dt><b>PARTITION_MSFT_RESERVED_GUID</b></dt> <dt>e3c9e316-0b5c-4db8-817d-f92df00215ae</dt> </dl> </td> <td
    ///width="60%"> The partition is a Microsoft reserved partition. This value can be set for basic and dynamic disks.
    ///</td> </tr> <tr> <td width="40%"><a id="PARTITION_LDM_METADATA_GUID"></a><a
    ///id="partition_ldm_metadata_guid"></a><dl> <dt><b>PARTITION_LDM_METADATA_GUID</b></dt>
    ///<dt>5808c8aa-7e8f-42e0-85d2-e1e90434cfb3</dt> </dl> </td> <td width="60%"> The partition is a Logical Disk
    ///Manager (LDM) metadata partition on a dynamic disk. This value can be set only for dynamic disks. </td> </tr>
    ///<tr> <td width="40%"><a id="PARTITION_LDM_DATA_GUID"></a><a id="partition_ldm_data_guid"></a><dl>
    ///<dt><b>PARTITION_LDM_DATA_GUID</b></dt> <dt>af9b60a0-1431-4f62-bc68-3311714a69ad</dt> </dl> </td> <td
    ///width="60%"> The partition is an LDM data partition on a dynamic disk. This value can be set only for dynamic
    ///disks. </td> </tr> <tr> <td width="40%"><a id="PARTITION_MSFT_RECOVERY_GUID"></a><a
    ///id="partition_msft_recovery_guid"></a><dl> <dt><b>PARTITION_MSFT_RECOVERY_GUID</b></dt>
    ///<dt>de94bba4-06d1-4d40-a16a-bfd50179d6ac</dt> </dl> </td> <td width="60%"> The partition is a Microsoft recovery
    ///partition. This value can be set for basic and dynamic disks. </td> </tr> </table>
    GUID       PartitionType;
    ///The GUID of the partition.
    GUID       PartitionId;
    ///The Extensible Firmware Interface (EFI) attributes of the partition. This member can be one or more of the
    ///following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="GPT_ATTRIBUTE_PLATFORM_REQUIRED"></a><a id="gpt_attribute_platform_required"></a><dl>
    ///<dt><b>GPT_ATTRIBUTE_PLATFORM_REQUIRED</b></dt> <dt>0x0000000000000001</dt> </dl> </td> <td width="60%"> If this
    ///attribute is set, the partition is required by a computer to function properly. For example, this attribute must
    ///be set for OEM partitions. Note that if this attribute is set, you can use the DiskPart.exe utility to perform
    ///partition operations such as deleting the partition. However, because the partition is not a volume, you cannot
    ///use the DiskPart.exe utility to perform volume operations on the partition. This attribute can be set for basic
    ///and dynamic disks. If it is set for a partition on a basic disk and the disk is converted to a dynamic disk, the
    ///partition remains a basic partition, even though the rest of the disk is a dynamic disk. This is because the
    ///partition is considered to be an OEM partition on a GPT disk. </td> </tr> <tr> <td width="40%"><a
    ///id="GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER"></a><a id="gpt_basic_data_attribute_no_drive_letter"></a><dl>
    ///<dt><b>GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER</b></dt> <dt>0x8000000000000000</dt> </dl> </td> <td width="60%">
    ///If this attribute is set, the partition does not receive a drive letter by default when the disk is moved to
    ///another computer or when the disk is seen for the first time by a computer. This attribute is useful in storage
    ///area network (SAN) environments. Despite its name, this attribute can be set for basic and dynamic disks. </td>
    ///</tr> <tr> <td width="40%"><a id="GPT_BASIC_DATA_ATTRIBUTE_HIDDEN"></a><a
    ///id="gpt_basic_data_attribute_hidden"></a><dl> <dt><b>GPT_BASIC_DATA_ATTRIBUTE_HIDDEN</b></dt>
    ///<dt>0x4000000000000000</dt> </dl> </td> <td width="60%"> If this attribute is set, the partition is not detected
    ///by the Mount Manager. As a result, the partition does not receive a drive letter, does not receive a volume
    ///<b>GUID</b> path, does not host mounted folders (also called volume mount points), and is not enumerated by calls
    ///to FindFirstVolume and FindNextVolume. This ensures that applications such as Disk Defragmenter do not access the
    ///partition. The Volume Shadow Copy Service (VSS) uses this attribute. Despite its name, this attribute can be set
    ///for basic and dynamic disks. </td> </tr> <tr> <td width="40%"><a id="GPT_BASIC_DATA_ATTRIBUTE_SHADOW_COPY"></a><a
    ///id="gpt_basic_data_attribute_shadow_copy"></a><dl> <dt><b>GPT_BASIC_DATA_ATTRIBUTE_SHADOW_COPY</b></dt>
    ///<dt>0x2000000000000000</dt> </dl> </td> <td width="60%"> If this attribute is set, the partition is a shadow copy
    ///of another partition. VSS uses this attribute. This attribute is an indication for file system filter
    ///driver-based software (such as antivirus programs) to avoid attaching to the volume. An application can use the
    ///attribute to differentiate a shadow copy volume from a production volume. An application that does a fast
    ///recovery, for example, will break a shadow copy LUN and clear the read-only and hidden attributes and this
    ///attribute. This attribute is set when the shadow copy is created and cleared when the shadow copy is broken.
    ///Despite its name, this attribute can be set for basic and dynamic disks. <b>Windows Server 2003: </b>This
    ///attribute is not supported before Windows Server 2003 with SP1. </td> </tr> <tr> <td width="40%"><a
    ///id="GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY"></a><a id="gpt_basic_data_attribute_read_only"></a><dl>
    ///<dt><b>GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY</b></dt> <dt>0x1000000000000000</dt> </dl> </td> <td width="60%"> If
    ///this attribute is set, the partition is read-only. Writes to the partition will fail. IOCTL_DISK_IS_WRITABLE will
    ///fail with the <b>ERROR_WRITE_PROTECT</b> Win32 error code, which causes the file system to mount as read only, if
    ///a file system is present. VSS uses this attribute. Do not set this attribute for dynamic disks. Setting it can
    ///cause I/O errors and prevent the file system from mounting properly. </td> </tr> </table>
    ulong      Attributes;
    ///A wide-character string that describes the partition.
    ushort[36] Name;
}

///Contains partition information specific to master boot record (MBR) disks.
struct PARTITION_INFORMATION_MBR
{
    ///The type of partition. For a list of values, see Disk Partition Types.
    ubyte PartitionType;
    ///If the member is <b>TRUE</b>, the partition is a boot partition. When this structure is used with the
    ///IOCTL_DISK_SET_PARTITION_INFO_EX control code, the value of this parameter is ignored.
    ubyte BootIndicator;
    ///If this member is <b>TRUE</b>, the partition is of a recognized type. When this structure is used with the
    ///IOCTL_DISK_SET_PARTITION_INFO_EX control code, the value of this parameter is ignored.
    ubyte RecognizedPartition;
    ///The number of hidden sectors to be allocated when the partition table is created.
    uint  HiddenSectors;
    GUID  PartitionId;
}

///Contains information used by the IOCTL_DISK_CREATE_DISK control code to initialize GUID partition table (GPT) disks.
struct CREATE_DISK_GPT
{
    ///The disk identifier (GUID) of the GPT disk to be initialized.
    GUID DiskId;
    ///The maximum number of partitions allowed on the GPT disk to be initialized without repartitioning the disk.
    uint MaxPartitionCount;
}

///Contains information that the IOCTL_DISK_CREATE_DISK control code uses to initialize master boot record (MBR) disks.
struct CREATE_DISK_MBR
{
    ///The disk signature of the MBR disk to be initialized.
    uint Signature;
}

///Contains information that the IOCTL_DISK_CREATE_DISK control code uses to initialize GUID partition table (GPT),
///master boot record (MBR), or raw disks.
struct CREATE_DISK
{
    ///The format of a partition. For more information, see PARTITION_STYLE.
    PARTITION_STYLE PartitionStyle;
    union
    {
        CREATE_DISK_MBR Mbr;
        CREATE_DISK_GPT Gpt;
    }
}

///Contains disk, volume, or partition length information used by the IOCTL_DISK_GET_LENGTH_INFO control code.
struct GET_LENGTH_INFORMATION
{
    ///The length of the disk, volume, or partition, in bytes.
    LARGE_INTEGER Length;
}

///Contains partition information for standard <i>AT-style</i> master boot record (MBR) and Extensible Firmware
///Interface (EFI) disks.
struct PARTITION_INFORMATION_EX
{
    ///The format of the partition. For a list of values, see PARTITION_STYLE.
    PARTITION_STYLE PartitionStyle;
    ///The starting offset of the partition.
    LARGE_INTEGER   StartingOffset;
    ///The size of the partition, in bytes.
    LARGE_INTEGER   PartitionLength;
    ///The number of the partition (1-based).
    uint            PartitionNumber;
    ///If this member is <b>TRUE</b>, the partition is rewritable. The value of this parameter should be set to
    ///<b>TRUE</b>.
    ubyte           RewritePartition;
    ubyte           IsServicePartition;
    union
    {
        PARTITION_INFORMATION_MBR Mbr;
        PARTITION_INFORMATION_GPT Gpt;
    }
}

///Contains information about a drive's GUID partition table (GPT) partitions.
struct DRIVE_LAYOUT_INFORMATION_GPT
{
    ///The <b>GUID</b> of the disk.
    GUID          DiskId;
    ///The starting byte offset of the first usable block.
    LARGE_INTEGER StartingUsableOffset;
    ///The size of the usable blocks on the disk, in bytes.
    LARGE_INTEGER UsableLength;
    ///The maximum number of partitions that can be defined in the usable block.
    uint          MaxPartitionCount;
}

///Provides information about a drive's master boot record (MBR) partitions.
struct DRIVE_LAYOUT_INFORMATION_MBR
{
    ///The signature of the drive.
    uint Signature;
    uint CheckSum;
}

///Contains extended information about a drive's partitions.
struct DRIVE_LAYOUT_INFORMATION_EX
{
    ///The style of the partitions on the drive enumerated by the [**PARTITION_STYLE**](ne-winioctl-partition_style.md)
    ///enumeration. | Value | | Meaning | | --- | --- | --- | | **PARTITION_STYLE_MBR** | 0 | Master boot record (MBR)
    ///format.| | **PARTITION_STYLE_GPT** | 1 | GUID Partition Table (GPT) format. | | **PARTITION_STYLE_RAW** | 2 |
    ///Partition not formatted in either of the recognized formats—MBR or GPT. |
    uint PartitionStyle;
    ///The number of partitions on the drive. On hard disks with the MBR layout, this value will always be a multiple of
    ///4. Any partitions that are actually unused will have a partition type of **PARTITION_ENTRY_UNUSED** (0) set in
    ///the **PartitionType** member of the [**PARTITION_INFORMATION_MBR**](ns-winioctl-partition_information_mbr.md)
    ///structure of the **Mbr** member of the [**PARTITION_INFORMATION_EX**](ns-winioctl-partition_information_ex.md)
    ///structure of the **PartitionEntry** member of this structure.
    uint PartitionCount;
    union
    {
        DRIVE_LAYOUT_INFORMATION_MBR Mbr;
        DRIVE_LAYOUT_INFORMATION_GPT Gpt;
    }
    ///A variable-sized array of [**PARTITION_INFORMATION_EX**](ns-winioctl-partition_information_ex.md) structures, one
    ///structure for each partition on the drive.
    PARTITION_INFORMATION_EX[1] PartitionEntry;
}

///Contains standard Int13 drive geometry parameters.
struct DISK_INT13_INFO
{
    ///The letter that is related to the specified partition or hard disk. For valid values, see the BIOS documentation.
    ushort DriveSelect;
    ///The maximum number of cylinders per head. For valid values, see the BIOS documentation.
    uint   MaxCylinders;
    ///The number of sectors per track. For valid values, see the BIOS documentation.
    ushort SectorsPerTrack;
    ///The maximum number of heads for this hard disk. For valid values, see the BIOS documentation.
    ushort MaxHeads;
    ///The number of drives. For valid values, see the BIOS documentation.
    ushort NumberDrives;
}

///Contains extended Int13 drive parameters.
struct DISK_EX_INT13_INFO
{
    ///The size of the extended drive parameter buffer for this partition or disk. For valid values, see the BIOS
    ///documentation.
    ushort ExBufferSize;
    ///The information flags for this partition or disk. For valid values, see the BIOS documentation.
    ushort ExFlags;
    ///The number of cylinders per head. For valid values, see the BIOS documentation.
    uint   ExCylinders;
    ///The maximum number of heads for this hard disk. For valid values, see the BIOS documentation.
    uint   ExHeads;
    ///The number of sectors per track. For valid values, see the BIOS documentation.
    uint   ExSectorsPerTrack;
    ///The total number of sectors for this disk. For valid values, see the BIOS documentation.
    ulong  ExSectorsPerDrive;
    ///The sector size for this disk. For valid values, see the BIOS documentation.
    ushort ExSectorSize;
    ///Reserved for future use.
    ushort ExReserved;
}

///Contains detected drive parameters.
struct DISK_DETECTION_INFO
{
    ///The size of the structure, in bytes.
    uint           SizeOfDetectInfo;
    ///The detected partition type. This member can be one of the following values from the **DETECTION_TYPE**
    ///enumeration. | Value | | Meaning | | --- | --- | --- | | **DetectExInt13** | 2 | The disk has an extended Int13
    ///partition. | | **DetectInt13** | 1 | The disk has a standard Int13 partition. | | **DetectNone** | 0 | The disk
    ///does not have an Int13 or an extended Int13 partition. |
    DETECTION_TYPE DetectionType;
    union
    {
        struct
        {
            DISK_INT13_INFO    Int13;
            DISK_EX_INT13_INFO ExInt13;
        }
    }
}

///Contains the disk partition information.
struct DISK_PARTITION_INFO
{
    ///The size of this structure, in bytes.
    uint            SizeOfPartitionInfo;
    ///The format of a partition. For more information, see [PARTITION_STYLE](ne-winioctl-partition_style.md).
    PARTITION_STYLE PartitionStyle;
    union
    {
        struct Mbr
        {
            uint Signature;
            uint CheckSum;
        }
        struct Gpt
        {
            GUID DiskId;
        }
    }
}

///Describes the extended geometry of disk devices and media.
struct DISK_GEOMETRY_EX
{
    ///A [**DISK_GEOMETRY**](ns-winioctl-disk_geometry.md) structure.
    DISK_GEOMETRY Geometry;
    ///The disk size, in bytes. See [**LARGE_INTEGER**](../winnt/ns-winnt-large_integer-r1.md).
    LARGE_INTEGER DiskSize;
    ///Any additional data. For more information, see Remarks.
    ubyte[1]      Data;
}

///Provides information about the disk cache.This structure is used by the IOCTL_DISK_GET_CACHE_INFORMATION and
///IOCTL_DISK_SET_CACHE_INFORMATION control codes.
struct DISK_CACHE_INFORMATION
{
    ///Indicates whether the device is capable of saving any parameters in nonvolatile storage.
    ubyte  ParametersSavable;
    ///Indicates whether the read cache is enabled.
    ubyte  ReadCacheEnabled;
    ///Indicates whether the write cache is enabled.
    ubyte  WriteCacheEnabled;
    ///Determines the likelihood of data cached from a read operation remaining in the cache. This data might be given a
    ///different priority than data cached under other circumstances, such as from a prefetch operation. This member can
    ///be one of the following values from the <b>DISK_CACHE_RETENTION_PRIORITY</b> enumeration type. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="EqualPriority"></a><a id="equalpriority"></a><a
    ///id="EQUALPRIORITY"></a><dl> <dt><b>EqualPriority</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> No data is held
    ///in the cache on a preferential basis. </td> </tr> <tr> <td width="40%"><a id="KeepPrefetchedData"></a><a
    ///id="keepprefetcheddata"></a><a id="KEEPPREFETCHEDDATA"></a><dl> <dt><b>KeepPrefetchedData</b></dt> <dt>1</dt>
    ///</dl> </td> <td width="60%"> A preference is to be given to prefetched data. </td> </tr> <tr> <td width="40%"><a
    ///id="KeepReadData"></a><a id="keepreaddata"></a><a id="KEEPREADDATA"></a><dl> <dt><b>KeepReadData</b></dt>
    ///<dt>2</dt> </dl> </td> <td width="60%"> A preference is to be given to data cached from a read operation. </td>
    ///</tr> </table>
    DISK_CACHE_RETENTION_PRIORITY ReadRetentionPriority;
    ///Determines the likelihood of data cached from a write operation remaining in the cache. This data might be given
    ///a different priority than data cached under other circumstances, such as from a prefetch operation.
    DISK_CACHE_RETENTION_PRIORITY WriteRetentionPriority;
    ///Disables prefetching. Prefetching might be disabled whenever the number of blocks requested exceeds the value in
    ///<i>DisablePrefetchTransferLength</i>. When zero, prefetching is disabled no matter what the size of the block
    ///request.
    ushort DisablePrefetchTransferLength;
    ///If this member is <b>TRUE</b>, the union is a <b>ScalarPrefetch</b> structure. Otherwise, the union is a
    ///<b>BlockPrefetch</b> structure.
    ubyte  PrefetchScalar;
    union
    {
        struct ScalarPrefetch
        {
            ushort Minimum;
            ushort Maximum;
            ushort MaximumBlocks;
        }
        struct BlockPrefetch
        {
            ushort Minimum;
            ushort Maximum;
        }
    }
}

///Contains information used to increase the size of a partition.This structure is used by the IOCTL_DISK_GROW_PARTITION
///control code.
struct DISK_GROW_PARTITION
{
    ///The identifier of the partition to be enlarged.
    uint          PartitionNumber;
    ///The number of bytes by which the partition is to be enlarged (positive value) or reduced (negative value). Note
    ///that this value is not the new size of the partition.
    LARGE_INTEGER BytesToGrow;
}

///Provides disk performance information. It is used by the IOCTL_DISK_PERFORMANCE control code.
struct DISK_PERFORMANCE
{
    ///The number of bytes read.
    LARGE_INTEGER BytesRead;
    ///The number of bytes written.
    LARGE_INTEGER BytesWritten;
    ///The time it takes to complete a read.
    LARGE_INTEGER ReadTime;
    ///The time it takes to complete a write.
    LARGE_INTEGER WriteTime;
    ///The idle time.
    LARGE_INTEGER IdleTime;
    ///The number of read operations.
    uint          ReadCount;
    ///The number of write operations.
    uint          WriteCount;
    ///The depth of the queue.
    uint          QueueDepth;
    ///The cumulative count of I/Os that are associated I/Os. An associated I/O is a fragmented I/O, where multiple I/Os
    ///to a disk are required to fulfill the original logical I/O request. The most common example of this scenario is a
    ///file that is fragmented on a disk. The multiple I/Os are counted as split I/O counts.
    uint          SplitCount;
    ///The system time stamp when a query for this structure is returned. Use this member to synchronize between the
    ///file system driver and a caller.
    LARGE_INTEGER QueryTime;
    ///The unique number for a device that identifies it to the storage manager that is indicated in the
    ///<b>StorageManagerName</b> member.
    uint          StorageDeviceNumber;
    ///The name of the storage manager that controls this device. Examples of storage managers are "PhysDisk," "FTDISK,"
    ///and "DMIO".
    ushort[8]     StorageManagerName;
}

///Contains the attributes of a disk device. Returned as the output buffer from the IOCTL_DISK_GET_DISK_ATTRIBUTES
///control code.
struct GET_DISK_ATTRIBUTES
{
    ///Set to <code>sizeof(GET_DISK_ATTRIBUTES)</code>.
    uint  Version;
    ///Reserved.
    uint  Reserved1;
    ///Contains attributes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="DISK_ATTRIBUTE_OFFLINE"></a><a id="disk_attribute_offline"></a><dl> <dt><b>DISK_ATTRIBUTE_OFFLINE</b></dt>
    ///<dt>0x0000000000000001</dt> </dl> </td> <td width="60%"> The disk is offline. </td> </tr> <tr> <td width="40%"><a
    ///id="DISK_ATTRIBUTE_READ_ONLY"></a><a id="disk_attribute_read_only"></a><dl>
    ///<dt><b>DISK_ATTRIBUTE_READ_ONLY</b></dt> <dt>0x0000000000000002</dt> </dl> </td> <td width="60%"> The disk is
    ///read-only. </td> </tr> </table>
    ulong Attributes;
}

///Specifies the attributes to be set on a disk device. Passed as the input buffer to the IOCTL_DISK_SET_DISK_ATTRIBUTES
///control code.
struct SET_DISK_ATTRIBUTES
{
    ///Set to <code>sizeof(GET_DISK_ATTRIBUTES)</code>.
    uint     Version;
    ///If <b>TRUE</b>, these settings are persisted across reboots.
    ubyte    Persist;
    ///Reserved. Must be set to <b>FALSE</b> (0).
    ubyte[3] Reserved1;
    ///Specifies attributes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="DISK_ATTRIBUTE_OFFLINE"></a><a id="disk_attribute_offline"></a><dl> <dt><b>DISK_ATTRIBUTE_OFFLINE</b></dt>
    ///<dt>0x0000000000000001</dt> </dl> </td> <td width="60%"> The disk is offline. </td> </tr> <tr> <td width="40%"><a
    ///id="DISK_ATTRIBUTE_READ_ONLY"></a><a id="disk_attribute_read_only"></a><dl>
    ///<dt><b>DISK_ATTRIBUTE_READ_ONLY</b></dt> <dt>0x0000000000000002</dt> </dl> </td> <td width="60%"> The disk is
    ///read-only. </td> </tr> </table>
    ulong    Attributes;
    ///Indicates which attributes are being changed. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="DISK_ATTRIBUTE_OFFLINE"></a><a id="disk_attribute_offline"></a><dl>
    ///<dt><b>DISK_ATTRIBUTE_OFFLINE</b></dt> <dt>0x0000000000000001</dt> </dl> </td> <td width="60%"> The offline
    ///attribute is being changed. </td> </tr> <tr> <td width="40%"><a id="DISK_ATTRIBUTE_READ_ONLY"></a><a
    ///id="disk_attribute_read_only"></a><dl> <dt><b>DISK_ATTRIBUTE_READ_ONLY</b></dt> <dt>0x0000000000000002</dt> </dl>
    ///</td> <td width="60%"> The read-only attribute is being changed. </td> </tr> </table>
    ulong    AttributesMask;
    ///Reserved. Must be set to 0.
    uint[4]  Reserved2;
}

///Represents volume data. This structure is passed to the FSCTL_GET_NTFS_VOLUME_DATA control code.
struct NTFS_VOLUME_DATA_BUFFER
{
    ///The serial number of the volume. This is a unique number assigned to the volume media by the operating system.
    LARGE_INTEGER VolumeSerialNumber;
    ///The number of sectors in the specified volume.
    LARGE_INTEGER NumberSectors;
    ///The number of used and free clusters in the specified volume.
    LARGE_INTEGER TotalClusters;
    ///The number of free clusters in the specified volume.
    LARGE_INTEGER FreeClusters;
    ///The number of reserved clusters in the specified volume.
    LARGE_INTEGER TotalReserved;
    ///The number of bytes in a sector on the specified volume.
    uint          BytesPerSector;
    ///The number of bytes in a cluster on the specified volume. This value is also known as the cluster factor.
    uint          BytesPerCluster;
    ///The number of bytes in a file record segment.
    uint          BytesPerFileRecordSegment;
    ///The number of clusters in a file record segment.
    uint          ClustersPerFileRecordSegment;
    ///The length of the master file table, in bytes.
    LARGE_INTEGER MftValidDataLength;
    ///The starting logical cluster number of the master file table.
    LARGE_INTEGER MftStartLcn;
    ///The starting logical cluster number of the master file table mirror.
    LARGE_INTEGER Mft2StartLcn;
    ///The starting logical cluster number of the master file table zone.
    LARGE_INTEGER MftZoneStart;
    ///The ending logical cluster number of the master file table zone.
    LARGE_INTEGER MftZoneEnd;
}

///Represents volume data. This structure is passed to the FSCTL_GET_NTFS_VOLUME_DATA control code.
struct NTFS_EXTENDED_VOLUME_DATA
{
    uint   ByteCount;
    ushort MajorVersion;
    ushort MinorVersion;
    uint   BytesPerPhysicalSector;
    ushort LfsMajorVersion;
    ushort LfsMinorVersion;
    uint   MaxDeviceTrimExtentCount;
    uint   MaxDeviceTrimByteCount;
    uint   MaxVolumeTrimExtentCount;
    uint   MaxVolumeTrimByteCount;
}

///Contains the starting LCN to the FSCTL_GET_VOLUME_BITMAP control code.
struct STARTING_LCN_INPUT_BUFFER
{
    ///The LCN from which the operation should start when describing a bitmap. This member will be rounded down to a
    ///file-system-dependent rounding boundary, and that value will be returned. Its value should be an integral
    ///multiple of eight.
    LARGE_INTEGER StartingLcn;
}

///Represents the occupied and available clusters on a disk. This structure is the output buffer for the
///FSCTL_GET_VOLUME_BITMAP control code.
struct VOLUME_BITMAP_BUFFER
{
    ///Starting LCN requested as an input to the operation.
    LARGE_INTEGER StartingLcn;
    ///The number of clusters on the volume, starting from the starting LCN returned in the <b>StartingLcn</b> member of
    ///this structure. See the following Remarks section for details.
    LARGE_INTEGER BitmapSize;
    ///Array of bytes containing the bitmap that the operation returns. The bitmap is bitwise from bit zero of the
    ///bitmap to the end. Thus, starting at the requested cluster, the bitmap goes from bit 0 of byte 0, bit 1 of byte 0
    ///... bit 7 of byte 0, bit 0 of byte 1, and so on. The value 1 indicates that the cluster is allocated (in use).
    ///The value 0 indicates that the cluster is not allocated (free).
    ubyte[1]      Buffer;
}

///Contains the starting VCN to the FSCTL_GET_RETRIEVAL_POINTERS control code.
struct STARTING_VCN_INPUT_BUFFER
{
    ///The VCN at which the operation will begin enumerating extents in the file. This value may be rounded down to the
    ///first VCN of the extent in which the specified extent is found.
    LARGE_INTEGER StartingVcn;
}

///Contains the output for the FSCTL_GET_RETRIEVAL_POINTERS control code.
struct RETRIEVAL_POINTERS_BUFFER
{
    ///The count of elements in the <b>Extents</b> array.
    uint          ExtentCount;
    ///The starting VCN returned by the function call. This is not necessarily the VCN requested by the function call,
    ///as the file system driver may round down to the first VCN of the extent in which the requested starting VCN is
    ///found.
    LARGE_INTEGER StartingVcn;
    struct
    {
        LARGE_INTEGER NextVcn;
        LARGE_INTEGER Lcn;
    }
}

///Contains data for the FSCTL_GET_NTFS_FILE_RECORD control code.
struct NTFS_FILE_RECORD_INPUT_BUFFER
{
    ///The file identifier of the file record to be retrieved. This is not necessarily the file identifier returned in
    ///the <b>FileReferenceNumber</b> member of the NTFS_FILE_RECORD_OUTPUT_BUFFER structure. Refer to the Remarks
    ///section of the reference page for FSCTL_GET_NTFS_FILE_RECORD for more information.
    LARGE_INTEGER FileReferenceNumber;
}

///Receives output data from the FSCTL_GET_NTFS_FILE_RECORD control code.
struct NTFS_FILE_RECORD_OUTPUT_BUFFER
{
    ///The file identifier of the returned file record. This is not necessarily the file identifier specified in the
    ///<b>FileReferenceNumber</b> member of the NTFS_FILE_RECORD_INPUT_BUFFER structure. Refer to the Remarks section of
    ///the reference page for FSCTL_GET_NTFS_FILE_RECORD for more information.
    LARGE_INTEGER FileReferenceNumber;
    ///The length of the returned file record, in bytes.
    uint          FileRecordLength;
    ///The starting location of the buffer for the returned file record.
    ubyte[1]      FileRecordBuffer;
}

///Contains input data for the FSCTL_MOVE_FILE control code.
struct MOVE_FILE_DATA
{
    ///A handle to the file to be moved. To retrieve a handle to a file, use CreateFile. If the file is encrypted, the
    ///handle must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_APPEND_DATA</b>, or
    ///<b>FILE_EXECUTE</b> access right. For more information, see File Security and Access Rights.
    HANDLE        FileHandle;
    ///A VCN (cluster number relative to the beginning of a file) of the first cluster to be moved.
    LARGE_INTEGER StartingVcn;
    ///An LCN (cluster number on a volume) to which the VCN is to be moved.
    LARGE_INTEGER StartingLcn;
    ///The count of clusters to be moved.
    uint          ClusterCount;
}

///Contains data for the FSCTL_FIND_FILES_BY_SID control code.
struct FIND_BY_SID_DATA
{
    ///Indicates whether to restart the search. This member should be 1 on first call, so the search will start from the
    ///root. For subsequent calls, this member should be zero so the search will resume at the point where it stopped.
    uint Restart;
    ///A SID structure that specifies the desired creator owner.
    SID  Sid;
}

///Represents a file name.
struct FIND_BY_SID_OUTPUT
{
    uint      NextEntryOffset;
    uint      FileIndex;
    ///The size of the file name, in bytes. This size does not include the NULL character.
    uint      FileNameLength;
    ///A pointer to a null-terminated string that specifies the file name.
    ushort[1] FileName;
}

///Contains information defining the boundaries for and starting place of an enumeration of update sequence number (USN)
///change journal records. It is used as the input buffer for the FSCTL_ENUM_USN_DATA control code. Prior to Windows
///Server 2012 this structure was named <b>MFT_ENUM_DATA</b>. Use that name to compile with older SDKs and compilers.
struct MFT_ENUM_DATA_V0
{
    ///The ordinal position within the files on the current volume at which the enumeration is to begin. The first call
    ///to FSCTL_ENUM_USN_DATA during an enumeration must have the <b>StartFileReferenceNumber</b> member set to
    ///<code>(DWORDLONG)0</code>. Each call to <b>FSCTL_ENUM_USN_DATA</b> retrieves the starting point for the
    ///subsequent call as the first entry in the output buffer. Subsequent calls must be made with
    ///<b>StartFileReferenceNumber</b> set to this value. For more information, see <b>FSCTL_ENUM_USN_DATA</b>.
    ulong StartFileReferenceNumber;
    ///The lower boundary of the range of USN values used to filter which records are returned. Only records whose last
    ///change journal USN is between or equal to the <b>LowUsn</b> and <b>HighUsn</b> member values are returned.
    long  LowUsn;
    ///The upper boundary of the range of USN values used to filter which files are returned.
    long  HighUsn;
}

///Contains information defining the boundaries for and starting place of an enumeration of update sequence number (USN)
///change journal records for ReFS volumes. It is used as the input buffer for the FSCTL_ENUM_USN_DATA control code.
struct MFT_ENUM_DATA_V1
{
    ///The ordinal position within the files on the current volume at which the enumeration is to begin. The first call
    ///to FSCTL_ENUM_USN_DATA during an enumeration must have the <b>StartFileReferenceNumber</b> member set to
    ///<code>(DWORDLONG)0</code>. Each call to <b>FSCTL_ENUM_USN_DATA</b> retrieves the starting point for the
    ///subsequent call as the first entry in the output buffer. Subsequent calls must be made with
    ///<b>StartFileReferenceNumber</b> set to this value. For more information, see <b>FSCTL_ENUM_USN_DATA</b>.
    ulong  StartFileReferenceNumber;
    ///The lower boundary of the range of USN values used to filter which records are returned. Only records whose last
    ///change journal USN is between or equal to the <b>LowUsn</b> and <b>HighUsn</b> member values are returned.
    long   LowUsn;
    ///The upper boundary of the range of USN values used to filter which files are returned.
    long   HighUsn;
    ///Indicates the minimum supported major version for the USN change journal.
    ushort MinMajorVersion;
    ///Indicates the maximum supported major version for the USN change journal. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>2</dt> </dl> </td> <td width="60%"> The data returned from
    ///the FSCTL_ENUM_USN_DATA control code will contain USN_RECORD_V2 structures. </td> </tr> <tr> <td width="40%">
    ///<dl> <dt>3</dt> </dl> </td> <td width="60%"> The data returned from the FSCTL_ENUM_USN_DATA control code will
    ///contain USN_RECORD_V2 or USN_RECORD_V3 structures. </td> </tr> </table>
    ushort MaxMajorVersion;
}

///Contains information that describes an update sequence number (USN) change journal.
struct CREATE_USN_JOURNAL_DATA
{
    ///The target maximum size that the NTFS file system allocates for the change journal, in bytes. The change journal
    ///can grow larger than this value, but it is then truncated at the next NTFS file system checkpoint to less than
    ///this value.
    ulong MaximumSize;
    ///The size of memory allocation that is added to the end and removed from the beginning of the change journal, in
    ///bytes. The change journal can grow to more than the sum of the values of <b>MaximumSize</b> and
    ///<b>AllocationDelta</b> before being trimmed.
    ulong AllocationDelta;
}

///Specifies the versions of the update sequence number (USN) change journal supported by the application. This
///structure is the input structure to the FSCTL_READ_FILE_USN_DATA control code.
struct READ_FILE_USN_DATA
{
    ///The lowest version of the USN change journal accepted by the application. If the input buffer is not specified
    ///this defaults to 2.
    ushort MinMajorVersion;
    ///The highest version of the USN change journal accepted by the application. If the input buffer is not specified
    ///this defaults to 2. To support 128-bit file identifiers used by ReFS this must be 3 or higher.
    ushort MaxMajorVersion;
}

///Contains information defining a set of update sequence number (USN) change journal records to return to the calling
///process. It is used by the FSCTL_QUERY_USN_JOURNAL and FSCTL_READ_USN_JOURNAL control codes. Prior to Windows 8 and
///Windows Server 2012 this structure was named <b>READ_USN_JOURNAL_DATA</b>. Use that name to compile with older SDKs
///and compilers. Windows Server 2012 introduced READ_USN_JOURNAL_DATA_V1 to support 128-bit file identifiers used by
///ReFS.
struct READ_USN_JOURNAL_DATA_V0
{
    ///The USN at which to begin reading the change journal. To start the read operation at the first record in the
    ///journal, set the <b>StartUsn</b> member to zero. Because a USN is contained in every journal record, the output
    ///buffer tells at which record the read operation actually started. To start the read operation at a specific
    ///record, set <b>StartUsn</b> to that record USN. If a nonzero USN is specified that is less than the first USN in
    ///the change journal, then an error occurs and the <b>ERROR_JOURNAL_ENTRY_DELETED</b> error code is returned. This
    ///code may indicate a case in which the specified USN is valid at one time but has since been deleted. For more
    ///information on navigating the change journal buffer returned in <b>READ_USN_JOURNAL_DATA_V0</b>, see Walking a
    ///Buffer of Change Journal Records.
    long  StartUsn;
    ///A mask of flags, each flag noting a change for which the file or directory has a record in the change journal. To
    ///be returned in a FSCTL_READ_USN_JOURNAL operation, a change journal record must have at least one of these flags
    ///set. The list of valid flags is as follows. Unused bits are reserved. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="USN_REASON_BASIC_INFO_CHANGE"></a><a
    ///id="usn_reason_basic_info_change"></a><dl> <dt><b>USN_REASON_BASIC_INFO_CHANGE</b></dt> <dt>0x00008000</dt> </dl>
    ///</td> <td width="60%"> A user has either changed one or more file or directory attributes (such as the read-only,
    ///hidden, system, archive, or sparse attribute), or one or more time stamps. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_CLOSE"></a><a id="usn_reason_close"></a><dl> <dt><b>USN_REASON_CLOSE</b></dt> <dt>0x80000000</dt>
    ///</dl> </td> <td width="60%"> The file or directory is closed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_COMPRESSION_CHANGE"></a><a id="usn_reason_compression_change"></a><dl>
    ///<dt><b>USN_REASON_COMPRESSION_CHANGE</b></dt> <dt>0x00020000</dt> </dl> </td> <td width="60%"> The compression
    ///state of the file or directory is changed from or to compressed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_DATA_EXTEND"></a><a id="usn_reason_data_extend"></a><dl> <dt><b>USN_REASON_DATA_EXTEND</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> The file or directory is added to. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_DATA_OVERWRITE"></a><a id="usn_reason_data_overwrite"></a><dl>
    ///<dt><b>USN_REASON_DATA_OVERWRITE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Data in the file or
    ///directory is overwritten. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_DATA_TRUNCATION"></a><a
    ///id="usn_reason_data_truncation"></a><dl> <dt><b>USN_REASON_DATA_TRUNCATION</b></dt> <dt>0x00000004</dt> </dl>
    ///</td> <td width="60%"> The file or directory is truncated. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_EA_CHANGE"></a><a id="usn_reason_ea_change"></a><dl> <dt><b>USN_REASON_EA_CHANGE</b></dt>
    ///<dt>0x00000400</dt> </dl> </td> <td width="60%"> The user makes a change to the file or directory extended
    ///attributes. These NTFS file system attributes are not accessible to Windows-based applications. </td> </tr> <tr>
    ///<td width="40%"><a id="USN_REASON_ENCRYPTION_CHANGE"></a><a id="usn_reason_encryption_change"></a><dl>
    ///<dt><b>USN_REASON_ENCRYPTION_CHANGE</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The file or
    ///directory is encrypted or decrypted. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_FILE_CREATE"></a><a
    ///id="usn_reason_file_create"></a><dl> <dt><b>USN_REASON_FILE_CREATE</b></dt> <dt>0x00000100</dt> </dl> </td> <td
    ///width="60%"> The file or directory is created for the first time. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_FILE_DELETE"></a><a id="usn_reason_file_delete"></a><dl> <dt><b>USN_REASON_FILE_DELETE</b></dt>
    ///<dt>0x00000200</dt> </dl> </td> <td width="60%"> The file or directory is deleted. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_HARD_LINK_CHANGE"></a><a id="usn_reason_hard_link_change"></a><dl>
    ///<dt><b>USN_REASON_HARD_LINK_CHANGE</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> An NTFS file system
    ///hard link is added to or removed from the file or directory. An NTFS file system hard link, similar to a POSIX
    ///hard link, is one of several directory entries that see the same file or directory. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_INDEXABLE_CHANGE"></a><a id="usn_reason_indexable_change"></a><dl>
    ///<dt><b>USN_REASON_INDEXABLE_CHANGE</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> A user changed the
    ///<b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b> attribute. That is, the user changed the file or directory from one
    ///that can be content indexed to one that cannot, or vice versa. (Content indexing permits rapid searching of data
    ///by building a database of selected content.) </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_EXTEND"></a><a id="usn_reason_named_data_extend"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_EXTEND</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> One or more named
    ///data streams for the file were added to. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_OVERWRITE"></a><a id="usn_reason_named_data_overwrite"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_OVERWRITE</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> Data in one or
    ///more named data streams for the file is overwritten. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_TRUNCATION"></a><a id="usn_reason_named_data_truncation"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_TRUNCATION</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> One or more
    ///named data streams for the file is truncated. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_OBJECT_ID_CHANGE"></a><a id="usn_reason_object_id_change"></a><dl>
    ///<dt><b>USN_REASON_OBJECT_ID_CHANGE</b></dt> <dt>0x00080000</dt> </dl> </td> <td width="60%"> The object
    ///identifier of the file or directory is changed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_RENAME_NEW_NAME"></a><a id="usn_reason_rename_new_name"></a><dl>
    ///<dt><b>USN_REASON_RENAME_NEW_NAME</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> The file or directory
    ///is renamed, and the file name in the USN_RECORD_V2 or USN_RECORD_V3 structure holding this journal record is the
    ///new name. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_RENAME_OLD_NAME"></a><a
    ///id="usn_reason_rename_old_name"></a><dl> <dt><b>USN_REASON_RENAME_OLD_NAME</b></dt> <dt>0x00001000</dt> </dl>
    ///</td> <td width="60%"> The file or directory is renamed, and the file name in the USN_RECORD_V2 or USN_RECORD_V3
    ///structure holding this journal record is the previous name. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_REPARSE_POINT_CHANGE"></a><a id="usn_reason_reparse_point_change"></a><dl>
    ///<dt><b>USN_REASON_REPARSE_POINT_CHANGE</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The reparse
    ///point contained in the file or directory is changed, or a reparse point is added to or deleted from the file or
    ///directory. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_SECURITY_CHANGE"></a><a
    ///id="usn_reason_security_change"></a><dl> <dt><b>USN_REASON_SECURITY_CHANGE</b></dt> <dt>0x00000800</dt> </dl>
    ///</td> <td width="60%"> A change is made in the access permissions to the file or directory. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_STREAM_CHANGE"></a><a id="usn_reason_stream_change"></a><dl>
    ///<dt><b>USN_REASON_STREAM_CHANGE</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> A named stream is added
    ///to or removed from the file or directory, or a named stream is renamed. </td> </tr> </table>
    uint  ReasonMask;
    ///A value that specifies when to return change journal records. To receive notification when the final handle for
    ///the changed file or directory is closed, rather than at the time a change occurs, set <b>ReturnOnlyOnClose</b> to
    ///any nonzero value and specify the <b>USN_REASON_CLOSE</b> flag in the <b>ReasonMask</b> member. All changes
    ///indicated by <b>ReasonMask</b> flags eventually generate a call to the change journal software when the file is
    ///closed. If your DeviceIoControl call is waiting for the file to be closed, that call in turn will allow your
    ///<b>DeviceIoControl</b> call to return. In the event that a file or directory is not closed prior to a volume
    ///failure, operating system failure, or shutdown, a cleanup call to the change journal software occurs the next
    ///time the volume is mounted. The call occurs even if there is an intervening system restart. To receive
    ///notification the first time each change is logged, as well as at cleanup, set <b>ReturnOnlyOnClose</b> to zero.
    ///Whether <b>ReturnOnlyOnClose</b> is zero or nonzero, the records generated at cleanup log within the change
    ///journal all reasons for USN changes that occurred to the file or directory. Each time a final close operation
    ///occurs for an item, a USN close record is written to the change journal, and the <b>ReasonMask</b> flags for the
    ///item are all reset. For a file or directory for which no user data exists (for example, a mounted folder), the
    ///final close operation occurs when the CloseHandle function is called on the last user handle to the item.
    uint  ReturnOnlyOnClose;
    ///The time-out value, in seconds, used with the <b>BytesToWaitFor</b> member to tell the operating system what to
    ///do if the FSCTL_READ_USN_JOURNAL operation requests more data than exists in the change journal. If
    ///<b>Timeout</b> is zero and <b>BytesToWaitFor</b> is nonzero, and the FSCTL_READ_USN_JOURNAL operation call
    ///reaches the end of the change journal without finding data to return, <b>FSCTL_READ_USN_JOURNAL</b> waits until
    ///<b>BytesToWaitFor</b> bytes of unfiltered data have been added to the change journal and then retrieves the
    ///specified records. If <b>Timeout</b> is nonzero and <b>BytesToWaitFor</b> is nonzero, and the
    ///FSCTL_READ_USN_JOURNAL operation call reaches the end of the change journal without finding data to return,
    ///<b>FSCTL_READ_USN_JOURNAL</b> waits <b>Timeout</b> seconds and then attempts to return the specified records.
    ///After <b>Timeout</b> seconds, <b>FSCTL_READ_USN_JOURNAL</b> retrieves any records available within the specified
    ///range. In either case, after the time-out period any new data appended to the change journal is processed. If
    ///there are still no records to return from the specified set, the time-out period is repeated. In this mode,
    ///FSCTL_READ_USN_JOURNAL remains outstanding until at least one record is returned or I/O is canceled. If
    ///<b>BytesToWaitFor</b> is zero, then <b>Timeout</b> is ignored. <b>Timeout</b> is also ignored for asynchronously
    ///opened handles.
    ulong Timeout;
    ///The number of bytes of unfiltered data added to the change journal. Use this value with <b>Timeout</b> to tell
    ///the operating system what to do if the FSCTL_READ_USN_JOURNAL operation requests more data than exists in the
    ///change journal. If <b>BytesToWaitFor</b> is zero, then <b>Timeout</b> is ignored. In this case, the
    ///FSCTL_READ_USN_JOURNAL operation always returns successfully when the end of the change journal file is
    ///encountered. It also retrieves the USN that should be used for the next <b>FSCTL_READ_USN_JOURNAL</b> operation.
    ///When the returned next USN is the same as the <b>StartUsn</b> supplied, there are no records available. The
    ///calling process should not use <b>FSCTL_READ_USN_JOURNAL</b> again immediately. Because the amount of data
    ///returned cannot be predicted when <b>BytesToWaitFor</b> is zero, you run a risk of overflowing the output buffer.
    ///To reduce this risk, specify a nonzero <b>BytesToWaitFor</b> value in repeated FSCTL_READ_USN_JOURNAL operations
    ///until all records in the change journal are exhausted. Then specify zero to await new records. Alternatively, use
    ///the <i>lpBytesReturned</i> parameter of DeviceIoControl in the FSCTL_READ_USN_JOURNAL operation call to determine
    ///the amount of data available, reallocate the output buffer (with room to spare for new records), and call
    ///<b>DeviceIoControl</b> again.
    ulong BytesToWaitFor;
    ///The identifier for the instance of the journal that is current for the volume. The NTFS file system can miss
    ///putting events in the change journal if the change journal is stopped and restarted or deleted and re-created. If
    ///either of these events occurs, the NTFS file system gives the journal a new identifier. If the journal identifier
    ///does not agree with the current journal identifier, the call to DeviceIoControl fails and returns an appropriate
    ///error code. To retrieve the new journal identifier, call <b>DeviceIoControl</b> with the FSCTL_QUERY_USN_JOURNAL
    ///operation.
    ulong UsnJournalID;
}

///Contains information defining a set of update sequence number (USN) change journal records to return to the calling
///process. It is used by the FSCTL_QUERY_USN_JOURNAL and FSCTL_READ_USN_JOURNAL control codes. Prior to Windows 8 and
///Windows Server 2012 this structure was named <b>READ_USN_JOURNAL_DATA</b>. Use that name to compile with older SDKs
///and compilers. Windows Server 2012 introduced READ_USN_JOURNAL_DATA_V1 to support 128-bit file identifiers used by
///ReFS.
struct READ_USN_JOURNAL_DATA_V1
{
    ///The USN at which to begin reading the change journal. To start the read operation at the first record in the
    ///journal, set the <b>StartUsn</b> member to zero. Because a USN is contained in every journal record, the output
    ///buffer tells at which record the read operation actually started. To start the read operation at a specific
    ///record, set <b>StartUsn</b> to that record USN. If a nonzero USN is specified that is less than the first USN in
    ///the change journal, then an error occurs and the <b>ERROR_JOURNAL_ENTRY_DELETED</b> error code is returned. This
    ///code may indicate a case in which the specified USN is valid at one time but has since been deleted. For more
    ///information on navigating the change journal buffer returned in <b>READ_USN_JOURNAL_DATA_V0</b>, see Walking a
    ///Buffer of Change Journal Records.
    long   StartUsn;
    ///A mask of flags, each flag noting a change for which the file or directory has a record in the change journal. To
    ///be returned in a FSCTL_READ_USN_JOURNAL operation, a change journal record must have at least one of these flags
    ///set. The list of valid flags is as follows. Unused bits are reserved. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="USN_REASON_BASIC_INFO_CHANGE"></a><a
    ///id="usn_reason_basic_info_change"></a><dl> <dt><b>USN_REASON_BASIC_INFO_CHANGE</b></dt> <dt>0x00008000</dt> </dl>
    ///</td> <td width="60%"> A user has either changed one or more file or directory attributes (such as the read-only,
    ///hidden, system, archive, or sparse attribute), or one or more time stamps. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_CLOSE"></a><a id="usn_reason_close"></a><dl> <dt><b>USN_REASON_CLOSE</b></dt> <dt>0x80000000</dt>
    ///</dl> </td> <td width="60%"> The file or directory is closed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_COMPRESSION_CHANGE"></a><a id="usn_reason_compression_change"></a><dl>
    ///<dt><b>USN_REASON_COMPRESSION_CHANGE</b></dt> <dt>0x00020000</dt> </dl> </td> <td width="60%"> The compression
    ///state of the file or directory is changed from or to compressed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_DATA_EXTEND"></a><a id="usn_reason_data_extend"></a><dl> <dt><b>USN_REASON_DATA_EXTEND</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> The file or directory is added to. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_DATA_OVERWRITE"></a><a id="usn_reason_data_overwrite"></a><dl>
    ///<dt><b>USN_REASON_DATA_OVERWRITE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Data in the file or
    ///directory is overwritten. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_DATA_TRUNCATION"></a><a
    ///id="usn_reason_data_truncation"></a><dl> <dt><b>USN_REASON_DATA_TRUNCATION</b></dt> <dt>0x00000004</dt> </dl>
    ///</td> <td width="60%"> The file or directory is truncated. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_EA_CHANGE"></a><a id="usn_reason_ea_change"></a><dl> <dt><b>USN_REASON_EA_CHANGE</b></dt>
    ///<dt>0x00000400</dt> </dl> </td> <td width="60%"> The user makes a change to the file or directory extended
    ///attributes. These NTFS file system attributes are not accessible to Windows-based applications. </td> </tr> <tr>
    ///<td width="40%"><a id="USN_REASON_ENCRYPTION_CHANGE"></a><a id="usn_reason_encryption_change"></a><dl>
    ///<dt><b>USN_REASON_ENCRYPTION_CHANGE</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The file or
    ///directory is encrypted or decrypted. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_FILE_CREATE"></a><a
    ///id="usn_reason_file_create"></a><dl> <dt><b>USN_REASON_FILE_CREATE</b></dt> <dt>0x00000100</dt> </dl> </td> <td
    ///width="60%"> The file or directory is created for the first time. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_FILE_DELETE"></a><a id="usn_reason_file_delete"></a><dl> <dt><b>USN_REASON_FILE_DELETE</b></dt>
    ///<dt>0x00000200</dt> </dl> </td> <td width="60%"> The file or directory is deleted. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_HARD_LINK_CHANGE"></a><a id="usn_reason_hard_link_change"></a><dl>
    ///<dt><b>USN_REASON_HARD_LINK_CHANGE</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> An NTFS file system
    ///hard link is added to or removed from the file or directory. An NTFS file system hard link, similar to a POSIX
    ///hard link, is one of several directory entries that see the same file or directory. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_INDEXABLE_CHANGE"></a><a id="usn_reason_indexable_change"></a><dl>
    ///<dt><b>USN_REASON_INDEXABLE_CHANGE</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> A user changed the
    ///<b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b> attribute. That is, the user changed the file or directory from one
    ///that can be content indexed to one that cannot, or vice versa. (Content indexing permits rapid searching of data
    ///by building a database of selected content.) </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_EXTEND"></a><a id="usn_reason_named_data_extend"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_EXTEND</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> One or more named
    ///data streams for the file were added to. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_OVERWRITE"></a><a id="usn_reason_named_data_overwrite"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_OVERWRITE</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> Data in one or
    ///more named data streams for the file is overwritten. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_TRUNCATION"></a><a id="usn_reason_named_data_truncation"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_TRUNCATION</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> One or more
    ///named data streams for the file is truncated. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_OBJECT_ID_CHANGE"></a><a id="usn_reason_object_id_change"></a><dl>
    ///<dt><b>USN_REASON_OBJECT_ID_CHANGE</b></dt> <dt>0x00080000</dt> </dl> </td> <td width="60%"> The object
    ///identifier of the file or directory is changed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_RENAME_NEW_NAME"></a><a id="usn_reason_rename_new_name"></a><dl>
    ///<dt><b>USN_REASON_RENAME_NEW_NAME</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> The file or directory
    ///is renamed, and the file name in the USN_RECORD_V2 or USN_RECORD_V3 structure holding this journal record is the
    ///new name. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_RENAME_OLD_NAME"></a><a
    ///id="usn_reason_rename_old_name"></a><dl> <dt><b>USN_REASON_RENAME_OLD_NAME</b></dt> <dt>0x00001000</dt> </dl>
    ///</td> <td width="60%"> The file or directory is renamed, and the file name in the USN_RECORD_V2 or USN_RECORD_V3
    ///structure holding this journal record is the previous name. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_REPARSE_POINT_CHANGE"></a><a id="usn_reason_reparse_point_change"></a><dl>
    ///<dt><b>USN_REASON_REPARSE_POINT_CHANGE</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The reparse
    ///point contained in the file or directory is changed, or a reparse point is added to or deleted from the file or
    ///directory. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_SECURITY_CHANGE"></a><a
    ///id="usn_reason_security_change"></a><dl> <dt><b>USN_REASON_SECURITY_CHANGE</b></dt> <dt>0x00000800</dt> </dl>
    ///</td> <td width="60%"> A change is made in the access permissions to the file or directory. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_STREAM_CHANGE"></a><a id="usn_reason_stream_change"></a><dl>
    ///<dt><b>USN_REASON_STREAM_CHANGE</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> A named stream is added
    ///to or removed from the file or directory, or a named stream is renamed. </td> </tr> </table>
    uint   ReasonMask;
    ///A value that specifies when to return change journal records. To receive notification when the final handle for
    ///the changed file or directory is closed, rather than at the time a change occurs, set <b>ReturnOnlyOnClose</b> to
    ///any nonzero value and specify the <b>USN_REASON_CLOSE</b> flag in the <b>ReasonMask</b> member. All changes
    ///indicated by <b>ReasonMask</b> flags eventually generate a call to the change journal software when the file is
    ///closed. If your DeviceIoControl call is waiting for the file to be closed, that call in turn will allow your
    ///<b>DeviceIoControl</b> call to return. In the event that a file or directory is not closed prior to a volume
    ///failure, operating system failure, or shutdown, a cleanup call to the change journal software occurs the next
    ///time the volume is mounted. The call occurs even if there is an intervening system restart. To receive
    ///notification the first time each change is logged, as well as at cleanup, set <b>ReturnOnlyOnClose</b> to zero.
    ///Whether <b>ReturnOnlyOnClose</b> is zero or nonzero, the records generated at cleanup log within the change
    ///journal all reasons for USN changes that occurred to the file or directory. Each time a final close operation
    ///occurs for an item, a USN close record is written to the change journal, and the <b>ReasonMask</b> flags for the
    ///item are all reset. For a file or directory for which no user data exists (for example, a mounted folder), the
    ///final close operation occurs when the CloseHandle function is called on the last user handle to the item.
    uint   ReturnOnlyOnClose;
    ///The time-out value, in seconds, used with the <b>BytesToWaitFor</b> member to tell the operating system what to
    ///do if the FSCTL_READ_USN_JOURNAL operation requests more data than exists in the change journal. If
    ///<b>Timeout</b> is zero and <b>BytesToWaitFor</b> is nonzero, and the FSCTL_READ_USN_JOURNAL operation call
    ///reaches the end of the change journal without finding data to return, <b>FSCTL_READ_USN_JOURNAL</b> waits until
    ///<b>BytesToWaitFor</b> bytes of unfiltered data have been added to the change journal and then retrieves the
    ///specified records. If <b>Timeout</b> is nonzero and <b>BytesToWaitFor</b> is nonzero, and the
    ///FSCTL_READ_USN_JOURNAL operation call reaches the end of the change journal without finding data to return,
    ///<b>FSCTL_READ_USN_JOURNAL</b> waits <b>Timeout</b> seconds and then attempts to return the specified records.
    ///After <b>Timeout</b> seconds, <b>FSCTL_READ_USN_JOURNAL</b> retrieves any records available within the specified
    ///range. In either case, after the time-out period any new data appended to the change journal is processed. If
    ///there are still no records to return from the specified set, the time-out period is repeated. In this mode,
    ///FSCTL_READ_USN_JOURNAL remains outstanding until at least one record is returned or I/O is canceled. If
    ///<b>BytesToWaitFor</b> is zero, then <b>Timeout</b> is ignored. <b>Timeout</b> is also ignored for asynchronously
    ///opened handles.
    ulong  Timeout;
    ///The number of bytes of unfiltered data added to the change journal. Use this value with <b>Timeout</b> to tell
    ///the operating system what to do if the FSCTL_READ_USN_JOURNAL operation requests more data than exists in the
    ///change journal. If <b>BytesToWaitFor</b> is zero, then <b>Timeout</b> is ignored. In this case, the
    ///FSCTL_READ_USN_JOURNAL operation always returns successfully when the end of the change journal file is
    ///encountered. It also retrieves the USN that should be used for the next <b>FSCTL_READ_USN_JOURNAL</b> operation.
    ///When the returned next USN is the same as the <b>StartUsn</b> supplied, there are no records available. The
    ///calling process should not use <b>FSCTL_READ_USN_JOURNAL</b> again immediately. Because the amount of data
    ///returned cannot be predicted when <b>BytesToWaitFor</b> is zero, you run a risk of overflowing the output buffer.
    ///To reduce this risk, specify a nonzero <b>BytesToWaitFor</b> value in repeated FSCTL_READ_USN_JOURNAL operations
    ///until all records in the change journal are exhausted. Then specify zero to await new records. Alternatively, use
    ///the <i>lpBytesReturned</i> parameter of DeviceIoControl in the FSCTL_READ_USN_JOURNAL operation call to determine
    ///the amount of data available, reallocate the output buffer (with room to spare for new records), and call
    ///<b>DeviceIoControl</b> again.
    ulong  BytesToWaitFor;
    ///The identifier for the instance of the journal that is current for the volume. The NTFS file system can miss
    ///putting events in the change journal if the change journal is stopped and restarted or deleted and re-created. If
    ///either of these events occurs, the NTFS file system gives the journal a new identifier. If the journal identifier
    ///does not agree with the current journal identifier, the call to DeviceIoControl fails and returns an appropriate
    ///error code. To retrieve the new journal identifier, call <b>DeviceIoControl</b> with the FSCTL_QUERY_USN_JOURNAL
    ///operation.
    ulong  UsnJournalID;
    ushort MinMajorVersion;
    ushort MaxMajorVersion;
}

///Contains information on range tracking parameters for an update sequence number (USN) change journal using the
///FSCTL_USN_TRACK_MODIFIED_RANGES control code.
struct USN_TRACK_MODIFIED_RANGES
{
    ///Indicates enabling range tracking. <table> <tr> <td>Value</td> <td>Description</td> </tr> <tr>
    ///<td>FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE 0x00000001 </td> <td>This flag is mandatory with
    ///FSCTL_USN_TRACK_MODIFIED_RANGES and is used to enable range tracking on the volume.</td> </tr> </table>
    uint  Flags;
    ///Reserved.
    uint  Unused;
    ///Chunk size for tracking ranges. A single byte modification will be reflected as the whole chunk being modified.
    ulong ChunkSize;
    ///File size threshold to start outputting USN_RECORD_V4 record(s) for modified file, i.e. if the modified file size
    ///is less than this threshold, then no <b>USN_RECORD_V4</b> record will be output.
    long  FileSizeThreshold;
}

///Contains returned update sequence number (USN) from FSCTL_USN_TRACK_MODIFIED_RANGES control code.
struct USN_RANGE_TRACK_OUTPUT
{
    ///Returned update sequence number (USN) that identifies at what point in the USN Journal that range tracking was
    ///enabled.
    long Usn;
}

///Contains the information for an update sequence number (USN) change journal version 2.0 record. Applications should
///not attempt to work with change journal versions earlier than 2.0. Prior to Windows 8 and Windows Server 2012 this
///structure was named <b>USN_RECORD</b>. Use that name to compile with older SDKs and compilers.
struct USN_RECORD_V2
{
    ///The total length of a record, in bytes. Because <b>USN_RECORD_V2</b> is a variable size, the <b>RecordLength</b>
    ///member should be used when calculating the address of the next record in an output buffer, for example, a buffer
    ///that is returned from operations for the DeviceIoControl function that work with <b>USN_RECORD_V2</b>. The size
    ///in bytes of any change journal record is at most the size of the <b>USN_RECORD_V2</b> structure, plus
    ///<i>MaximumComponentLength</i> characters minus 1 (for the character declared in the structure) times the size of
    ///a wide character. The value of <i>MaximumComponentLength</i> may be determined by calling the
    ///GetVolumeInformation function. In C, you can determine a record size by using the following code example. <div
    ///class="code"><span codelanguage="ManagedCPlusPlus"><table> <tr> <th>C++</th> </tr> <tr> <td> <pre>
    ///MaximumChangeJournalRecordSize = ( MaximumComponentLength * sizeof(WCHAR) + sizeof(USN_RECORD) - sizeof(WCHAR) );
    ///</pre> </td> </tr> </table></span></div> To maintain compatibility across version changes of the change journal
    ///software, use a run-time calculation to determine the size of the <b>USN_RECORD_V2</b> structure. For more
    ///information about compatibility across version changes, see the Remarks section in this topic.
    uint          RecordLength;
    ///The major version number of the change journal software for this record. For example, if the change journal
    ///software is version 2.0, the major version number is 2. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"> <dl> <dt>2</dt> </dl> </td> <td width="60%"> The structure is a <b>USN_RECORD_V2</b> structure
    ///and the remainder of the structure should be parsed using that layout. </td> </tr> <tr> <td width="40%"> <dl>
    ///<dt>3</dt> </dl> </td> <td width="60%"> The structure is a USN_RECORD_V3 structure and the remainder of the
    ///structure should be parsed using that layout. </td> </tr> <tr> <td width="40%"> <dl> <dt>4</dt> </dl> </td> <td
    ///width="60%"> The structure is a USN_RECORD_V4 structure and the remainder of the structure should be parsed using
    ///that layout. </td> </tr> </table>
    ushort        MajorVersion;
    ///The minor version number of the change journal software for this record. For example, if the change journal
    ///software is version 2.0, the minor version number is zero.
    ushort        MinorVersion;
    ///The ordinal number of the file or directory for which this record notes changes. This is an arbitrarily assigned
    ///value that associates a journal record with a file.
    ulong         FileReferenceNumber;
    ///The ordinal number of the directory where the file or directory that is associated with this record is located.
    ///This is an arbitrarily assigned value that associates a journal record with a parent directory.
    ulong         ParentFileReferenceNumber;
    ///The USN of this record.
    long          Usn;
    ///The standard UTC time stamp (FILETIME) of this record, in 64-bit format.
    LARGE_INTEGER TimeStamp;
    ///The flags that identify reasons for changes that have accumulated in this file or directory journal record since
    ///the file or directory opened. When a file or directory closes, then a final USN record is generated with the
    ///<b>USN_REASON_CLOSE</b> flag set. The next change (for example, after the next open operation or deletion) starts
    ///a new record with a new set of reason flags. A rename or move operation generates two USN records, one that
    ///records the old parent directory for the item, and one that records a new parent. The following table identifies
    ///the possible flags. <div class="alert"><b>Note</b> Unused bits are reserved.</div> <div> </div> <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="USN_REASON_BASIC_INFO_CHANGE"></a><a
    ///id="usn_reason_basic_info_change"></a><dl> <dt><b>USN_REASON_BASIC_INFO_CHANGE</b></dt> <dt>0x00008000</dt> </dl>
    ///</td> <td width="60%"> A user has either changed one or more file or directory attributes (for example, the
    ///read-only, hidden, system, archive, or sparse attribute), or one or more time stamps. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_CLOSE"></a><a id="usn_reason_close"></a><dl> <dt><b>USN_REASON_CLOSE</b></dt>
    ///<dt>0x80000000</dt> </dl> </td> <td width="60%"> The file or directory is closed. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_COMPRESSION_CHANGE"></a><a id="usn_reason_compression_change"></a><dl>
    ///<dt><b>USN_REASON_COMPRESSION_CHANGE</b></dt> <dt>0x00020000</dt> </dl> </td> <td width="60%"> The compression
    ///state of the file or directory is changed from or to compressed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_DATA_EXTEND"></a><a id="usn_reason_data_extend"></a><dl> <dt><b>USN_REASON_DATA_EXTEND</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> The file or directory is extended (added to). </td> </tr> <tr>
    ///<td width="40%"><a id="USN_REASON_DATA_OVERWRITE"></a><a id="usn_reason_data_overwrite"></a><dl>
    ///<dt><b>USN_REASON_DATA_OVERWRITE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The data in the file
    ///or directory is overwritten. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_DATA_TRUNCATION"></a><a
    ///id="usn_reason_data_truncation"></a><dl> <dt><b>USN_REASON_DATA_TRUNCATION</b></dt> <dt>0x00000004</dt> </dl>
    ///</td> <td width="60%"> The file or directory is truncated. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_EA_CHANGE"></a><a id="usn_reason_ea_change"></a><dl> <dt><b>USN_REASON_EA_CHANGE</b></dt>
    ///<dt>0x00000400</dt> </dl> </td> <td width="60%"> The user made a change to the extended attributes of a file or
    ///directory. These NTFS file system attributes are not accessible to Windows-based applications. </td> </tr> <tr>
    ///<td width="40%"><a id="USN_REASON_ENCRYPTION_CHANGE"></a><a id="usn_reason_encryption_change"></a><dl>
    ///<dt><b>USN_REASON_ENCRYPTION_CHANGE</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The file or
    ///directory is encrypted or decrypted. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_FILE_CREATE"></a><a
    ///id="usn_reason_file_create"></a><dl> <dt><b>USN_REASON_FILE_CREATE</b></dt> <dt>0x00000100</dt> </dl> </td> <td
    ///width="60%"> The file or directory is created for the first time. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_FILE_DELETE"></a><a id="usn_reason_file_delete"></a><dl> <dt><b>USN_REASON_FILE_DELETE</b></dt>
    ///<dt>0x00000200</dt> </dl> </td> <td width="60%"> The file or directory is deleted. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_HARD_LINK_CHANGE"></a><a id="usn_reason_hard_link_change"></a><dl>
    ///<dt><b>USN_REASON_HARD_LINK_CHANGE</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> An NTFS file system
    ///hard link is added to or removed from the file or directory. An NTFS file system hard link, similar to a POSIX
    ///hard link, is one of several directory entries that see the same file or directory. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_INDEXABLE_CHANGE"></a><a id="usn_reason_indexable_change"></a><dl>
    ///<dt><b>USN_REASON_INDEXABLE_CHANGE</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> A user changes the
    ///<b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b> attribute. That is, the user changes the file or directory from one
    ///where content can be indexed to one where content cannot be indexed, or vice versa. Content indexing permits
    ///rapid searching of data by building a database of selected content. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_INTEGRITY_CHANGE"></a><a id="usn_reason_integrity_change"></a><dl>
    ///<dt><b>USN_REASON_INTEGRITY_CHANGE</b></dt> <dt>0x00800000</dt> </dl> </td> <td width="60%"> A user changed the
    ///state of the <b>FILE_ATTRIBUTE_INTEGRITY_STREAM</b> attribute for the given stream. On the ReFS file system,
    ///integrity streams maintain a checksum of all data for that stream, so that the contents of the file can be
    ///validated during read or write operations. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_EXTEND"></a><a id="usn_reason_named_data_extend"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_EXTEND</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> The one or more
    ///named data streams for a file are extended (added to). </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_OVERWRITE"></a><a id="usn_reason_named_data_overwrite"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_OVERWRITE</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> The data in one
    ///or more named data streams for a file is overwritten. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_TRUNCATION"></a><a id="usn_reason_named_data_truncation"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_TRUNCATION</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> The one or more
    ///named data streams for a file is truncated. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_OBJECT_ID_CHANGE"></a><a id="usn_reason_object_id_change"></a><dl>
    ///<dt><b>USN_REASON_OBJECT_ID_CHANGE</b></dt> <dt>0x00080000</dt> </dl> </td> <td width="60%"> The object
    ///identifier of a file or directory is changed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_RENAME_NEW_NAME"></a><a id="usn_reason_rename_new_name"></a><dl>
    ///<dt><b>USN_REASON_RENAME_NEW_NAME</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> A file or directory
    ///is renamed, and the file name in the <b>USN_RECORD_V2</b> structure is the new name. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_RENAME_OLD_NAME"></a><a id="usn_reason_rename_old_name"></a><dl>
    ///<dt><b>USN_REASON_RENAME_OLD_NAME</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> The file or directory
    ///is renamed, and the file name in the <b>USN_RECORD_V2</b> structure is the previous name. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_REPARSE_POINT_CHANGE"></a><a id="usn_reason_reparse_point_change"></a><dl>
    ///<dt><b>USN_REASON_REPARSE_POINT_CHANGE</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The reparse
    ///point that is contained in a file or directory is changed, or a reparse point is added to or deleted from a file
    ///or directory. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_SECURITY_CHANGE"></a><a
    ///id="usn_reason_security_change"></a><dl> <dt><b>USN_REASON_SECURITY_CHANGE</b></dt> <dt>0x00000800</dt> </dl>
    ///</td> <td width="60%"> A change is made in the access rights to a file or directory. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_STREAM_CHANGE"></a><a id="usn_reason_stream_change"></a><dl>
    ///<dt><b>USN_REASON_STREAM_CHANGE</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> A named stream is added
    ///to or removed from a file, or a named stream is renamed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_TRANSACTED_CHANGE"></a><a id="usn_reason_transacted_change"></a><dl>
    ///<dt><b>USN_REASON_TRANSACTED_CHANGE</b></dt> <dt>0x00400000 </dt> </dl> </td> <td width="60%"> The given stream
    ///is modified through a TxF transaction. </td> </tr> </table>
    uint          Reason;
    ///Additional information about the source of the change, set by the FSCTL_MARK_HANDLE of the DeviceIoControl
    ///operation. When a thread writes a new USN record, the source information flags in the prior record continues to
    ///be present only if the thread also sets those flags. Therefore, the source information structure allows
    ///applications to filter out USN records that are set only by a known source, for example, an antivirus filter. One
    ///of the two following values can be set. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="USN_SOURCE_AUXILIARY_DATA"></a><a id="usn_source_auxiliary_data"></a><dl>
    ///<dt><b>USN_SOURCE_AUXILIARY_DATA</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The operation adds a
    ///private data stream to a file or directory. An example might be a virus detector adding checksum information. As
    ///the virus detector modifies the item, the system generates USN records. <b>USN_SOURCE_AUXILIARY_DATA</b>
    ///indicates that the modifications did not change the application data. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_SOURCE_DATA_MANAGEMENT"></a><a id="usn_source_data_management"></a><dl>
    ///<dt><b>USN_SOURCE_DATA_MANAGEMENT</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The operation
    ///provides information about a change to the file or directory made by the operating system. A typical use is when
    ///the Remote Storage system moves data from external to local storage. Remote Storage is the hierarchical storage
    ///management software. Such a move usually at a minimum adds the <b>USN_REASON_DATA_OVERWRITE</b> flag to a USN
    ///record. However, the data has not changed from the user's point of view. By noting
    ///<b>USN_SOURCE_DATA_MANAGEMENT</b> in the <b>SourceInfo</b> member, you can determine that although a write
    ///operation is performed on the item, data has not changed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_SOURCE_REPLICATION_MANAGEMENT"></a><a id="usn_source_replication_management"></a><dl>
    ///<dt><b>USN_SOURCE_REPLICATION_MANAGEMENT</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The operation
    ///is modifying a file to match the contents of the same file which exists in another member of the replica set.
    ///</td> </tr> <tr> <td width="40%"><a id="USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT"></a><a
    ///id="usn_source_client_replication_management"></a><dl> <dt><b>USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT</b></dt>
    ///<dt>0x00000008</dt> </dl> </td> <td width="60%"> The operation is modifying a file on client systems to match the
    ///contents of the same file that exists in the cloud. </td> </tr> </table>
    uint          SourceInfo;
    ///The unique security identifier assigned to the file or directory associated with this record.
    uint          SecurityId;
    ///The attributes for the file or directory associated with this record, as returned by the GetFileAttributes
    ///function. Attributes of streams associated with the file or directory are excluded.
    uint          FileAttributes;
    ///The length of the name of the file or directory associated with this record, in bytes. The <b>FileName</b> member
    ///contains this name. Use this member to determine file name length, rather than depending on a trailing '\0' to
    ///delimit the file name in <b>FileName</b>.
    ushort        FileNameLength;
    ///The offset of the <b>FileName</b> member from the beginning of the structure.
    ushort        FileNameOffset;
    ///The name of the file or directory associated with this record in Unicode format. This file or directory name is
    ///of variable length. When working with <b>FileName</b>, do not count on the file name that contains a trailing
    ///'\0' delimiter, but instead determine the length of the file name by using <b>FileNameLength</b>. Do not perform
    ///any compile-time pointer arithmetic using <b>FileName</b>. Instead, make necessary calculations at run time by
    ///using the value of the <b>FileNameOffset</b> member. Doing so helps make your code compatible with any future
    ///versions of <b>USN_RECORD_V2</b>.
    ushort[1]     FileName;
}

///Contains the information for an update sequence number (USN) change journal version 3.0 record. The version 2.0
///record is defined by the USN_RECORD_V2 structure (also called <b>USN_RECORD</b> structure).
struct USN_RECORD_V3
{
    ///The total length of a record, in bytes. Because <b>USN_RECORD_V3</b> is a variable size, the <b>RecordLength</b>
    ///member should be used when calculating the address of the next record in an output buffer, for example, a buffer
    ///that is returned from operations for the DeviceIoControl function that work with <b>USN_RECORD_V3</b>. The size
    ///in bytes of any change journal record is at most the size of the <b>USN_RECORD_V3</b> structure, plus
    ///<i>MaximumComponentLength</i> characters minus 1 (for the character declared in the structure) times the size of
    ///a wide character. The value of <i>MaximumComponentLength</i> may be determined by calling the
    ///GetVolumeInformation function. In C, you can determine a record size by using the following code example. <div
    ///class="code"><span codelanguage="ManagedCPlusPlus"><table> <tr> <th>C++</th> </tr> <tr> <td> <pre>
    ///MaximumChangeJournalRecordSize = QuadAlign( (MaximumComponentLength - 1) * sizeof(WCHAR) + sizeof(USN_RECORD_V3)
    ///); </pre> </td> </tr> </table></span></div> To maintain compatibility across version changes of the change
    ///journal software, use a run-time calculation to determine the size of the <b>USN_RECORD_V3</b> structure. For
    ///more information about compatibility across version changes, see the Remarks section in this topic.
    uint          RecordLength;
    ///The major version number of the change journal software for this record. For example, if the change journal
    ///software is version 3.0, the major version number is 3. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"> <dl> <dt>2</dt> </dl> </td> <td width="60%"> The structure is a USN_RECORD_V2 structure and the
    ///remainder of the structure should be parsed using that layout. </td> </tr> <tr> <td width="40%"> <dl> <dt>3</dt>
    ///</dl> </td> <td width="60%"> The structure is a <b>USN_RECORD_V3</b> structure and the remainder of the structure
    ///should be parsed using that layout. </td> </tr> <tr> <td width="40%"> <dl> <dt>4</dt> </dl> </td> <td
    ///width="60%"> The structure is a USN_RECORD_V4 structure and the remainder of the structure should be parsed using
    ///that layout. </td> </tr> </table>
    ushort        MajorVersion;
    ///The minor version number of the change journal software for this record. For example, if the change journal
    ///software is version 3.0, the minor version number is zero.
    ushort        MinorVersion;
    ///The 128-bit ordinal number of the file or directory for which this record notes changes. This is an arbitrarily
    ///assigned value that associates a journal record with a file.
    FILE_ID_128   FileReferenceNumber;
    ///The 128-bit ordinal number of the directory where the file or directory that is associated with this record is
    ///located. This is an arbitrarily assigned value that associates a journal record with a parent directory.
    FILE_ID_128   ParentFileReferenceNumber;
    ///The USN of this record.
    long          Usn;
    ///The standard UTC time stamp (FILETIME) of this record, in 64-bit format.
    LARGE_INTEGER TimeStamp;
    ///The flags that identify reasons for changes that have accumulated in this file or directory journal record since
    ///the file or directory opened. When a file or directory closes, then a final USN record is generated with the
    ///<b>USN_REASON_CLOSE</b> flag set. The next change (for example, after the next open operation or deletion) starts
    ///a new record with a new set of reason flags. A rename or move operation generates two USN records, one that
    ///records the old parent directory for the item, and one that records a new parent. The following table identifies
    ///the possible flags. <div class="alert"><b>Note</b> Unused bits are reserved.</div> <div> </div> <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="USN_REASON_BASIC_INFO_CHANGE"></a><a
    ///id="usn_reason_basic_info_change"></a><dl> <dt><b>USN_REASON_BASIC_INFO_CHANGE</b></dt> <dt>0x00008000</dt> </dl>
    ///</td> <td width="60%"> A user has either changed one or more file or directory attributes (for example, the
    ///read-only, hidden, system, archive, or sparse attribute), or one or more time stamps. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_CLOSE"></a><a id="usn_reason_close"></a><dl> <dt><b>USN_REASON_CLOSE</b></dt>
    ///<dt>0x80000000</dt> </dl> </td> <td width="60%"> The file or directory is closed. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_COMPRESSION_CHANGE"></a><a id="usn_reason_compression_change"></a><dl>
    ///<dt><b>USN_REASON_COMPRESSION_CHANGE</b></dt> <dt>0x00020000</dt> </dl> </td> <td width="60%"> The compression
    ///state of the file or directory is changed from or to compressed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_DATA_EXTEND"></a><a id="usn_reason_data_extend"></a><dl> <dt><b>USN_REASON_DATA_EXTEND</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> The file or directory is extended (added to). </td> </tr> <tr>
    ///<td width="40%"><a id="USN_REASON_DATA_OVERWRITE"></a><a id="usn_reason_data_overwrite"></a><dl>
    ///<dt><b>USN_REASON_DATA_OVERWRITE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The data in the file
    ///or directory is overwritten. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_DATA_TRUNCATION"></a><a
    ///id="usn_reason_data_truncation"></a><dl> <dt><b>USN_REASON_DATA_TRUNCATION</b></dt> <dt>0x00000004</dt> </dl>
    ///</td> <td width="60%"> The file or directory is truncated. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_EA_CHANGE"></a><a id="usn_reason_ea_change"></a><dl> <dt><b>USN_REASON_EA_CHANGE</b></dt>
    ///<dt>0x00000400</dt> </dl> </td> <td width="60%"> The user made a change to the extended attributes of a file or
    ///directory. These NTFS file system attributes are not accessible to Windows-based applications. </td> </tr> <tr>
    ///<td width="40%"><a id="USN_REASON_ENCRYPTION_CHANGE"></a><a id="usn_reason_encryption_change"></a><dl>
    ///<dt><b>USN_REASON_ENCRYPTION_CHANGE</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The file or
    ///directory is encrypted or decrypted. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_FILE_CREATE"></a><a
    ///id="usn_reason_file_create"></a><dl> <dt><b>USN_REASON_FILE_CREATE</b></dt> <dt>0x00000100</dt> </dl> </td> <td
    ///width="60%"> The file or directory is created for the first time. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_FILE_DELETE"></a><a id="usn_reason_file_delete"></a><dl> <dt><b>USN_REASON_FILE_DELETE</b></dt>
    ///<dt>0x00000200</dt> </dl> </td> <td width="60%"> The file or directory is deleted. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_HARD_LINK_CHANGE"></a><a id="usn_reason_hard_link_change"></a><dl>
    ///<dt><b>USN_REASON_HARD_LINK_CHANGE</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> An NTFS file system
    ///hard link is added to or removed from the file or directory. An NTFS file system hard link, similar to a POSIX
    ///hard link, is one of several directory entries that see the same file or directory. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_INDEXABLE_CHANGE"></a><a id="usn_reason_indexable_change"></a><dl>
    ///<dt><b>USN_REASON_INDEXABLE_CHANGE</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> A user changes the
    ///<b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b> attribute. That is, the user changes the file or directory from one
    ///where content can be indexed to one where content cannot be indexed, or vice versa. Content indexing permits
    ///rapid searching of data by building a database of selected content. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_INTEGRITY_CHANGE"></a><a id="usn_reason_integrity_change"></a><dl>
    ///<dt><b>USN_REASON_INTEGRITY_CHANGE</b></dt> <dt>0x00800000</dt> </dl> </td> <td width="60%"> A user changed the
    ///state of the <b>FILE_ATTRIBUTE_INTEGRITY_STREAM</b> attribute for the given stream. On the ReFS file system,
    ///integrity streams maintain a checksum of all data for that stream, so that the contents of the file can be
    ///validated during read or write operations. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_EXTEND"></a><a id="usn_reason_named_data_extend"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_EXTEND</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> The one or more
    ///named data streams for a file are extended (added to). </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_OVERWRITE"></a><a id="usn_reason_named_data_overwrite"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_OVERWRITE</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> The data in one
    ///or more named data streams for a file is overwritten. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_TRUNCATION"></a><a id="usn_reason_named_data_truncation"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_TRUNCATION</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> The one or more
    ///named data streams for a file is truncated. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_OBJECT_ID_CHANGE"></a><a id="usn_reason_object_id_change"></a><dl>
    ///<dt><b>USN_REASON_OBJECT_ID_CHANGE</b></dt> <dt>0x00080000</dt> </dl> </td> <td width="60%"> The object
    ///identifier of a file or directory is changed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_RENAME_NEW_NAME"></a><a id="usn_reason_rename_new_name"></a><dl>
    ///<dt><b>USN_REASON_RENAME_NEW_NAME</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> A file or directory
    ///is renamed, and the file name in the <b>USN_RECORD_V3</b> structure is the new name. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_RENAME_OLD_NAME"></a><a id="usn_reason_rename_old_name"></a><dl>
    ///<dt><b>USN_REASON_RENAME_OLD_NAME</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> The file or directory
    ///is renamed, and the file name in the <b>USN_RECORD_V3</b> structure is the previous name. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_REPARSE_POINT_CHANGE"></a><a id="usn_reason_reparse_point_change"></a><dl>
    ///<dt><b>USN_REASON_REPARSE_POINT_CHANGE</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The reparse
    ///point that is contained in a file or directory is changed, or a reparse point is added to or deleted from a file
    ///or directory. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_SECURITY_CHANGE"></a><a
    ///id="usn_reason_security_change"></a><dl> <dt><b>USN_REASON_SECURITY_CHANGE</b></dt> <dt>0x00000800</dt> </dl>
    ///</td> <td width="60%"> A change is made in the access rights to a file or directory. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_STREAM_CHANGE"></a><a id="usn_reason_stream_change"></a><dl>
    ///<dt><b>USN_REASON_STREAM_CHANGE</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> A named stream is added
    ///to or removed from a file, or a named stream is renamed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_TRANSACTED_CHANGE"></a><a id="usn_reason_transacted_change"></a><dl>
    ///<dt><b>USN_REASON_TRANSACTED_CHANGE</b></dt> <dt>0x00400000 </dt> </dl> </td> <td width="60%"> The given stream
    ///is modified through a TxF transaction. </td> </tr> </table>
    uint          Reason;
    ///Additional information about the source of the change, set by the FSCTL_MARK_HANDLE of the DeviceIoControl
    ///operation. When a thread writes a new USN record, the source information flags in the prior record continues to
    ///be present only if the thread also sets those flags. Therefore, the source information structure allows
    ///applications to filter out USN records that are set only by a known source, for example, an antivirus filter. One
    ///of the two following values can be set. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="USN_SOURCE_AUXILIARY_DATA"></a><a id="usn_source_auxiliary_data"></a><dl>
    ///<dt><b>USN_SOURCE_AUXILIARY_DATA</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The operation adds a
    ///private data stream to a file or directory. An example might be a virus detector adding checksum information. As
    ///the virus detector modifies the item, the system generates USN records. <b>USN_SOURCE_AUXILIARY_DATA</b>
    ///indicates that the modifications did not change the application data. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_SOURCE_DATA_MANAGEMENT"></a><a id="usn_source_data_management"></a><dl>
    ///<dt><b>USN_SOURCE_DATA_MANAGEMENT</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The operation
    ///provides information about a change to the file or directory made by the operating system. A typical use is when
    ///the Remote Storage system moves data from external to local storage. Remote Storage is the hierarchical storage
    ///management software. Such a move usually at a minimum adds the <b>USN_REASON_DATA_OVERWRITE</b> flag to a USN
    ///record. However, the data has not changed from the user's point of view. By noting
    ///<b>USN_SOURCE_DATA_MANAGEMENT</b> in the <b>SourceInfo</b> member, you can determine that although a write
    ///operation is performed on the item, data has not changed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_SOURCE_REPLICATION_MANAGEMENT"></a><a id="usn_source_replication_management"></a><dl>
    ///<dt><b>USN_SOURCE_REPLICATION_MANAGEMENT</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The operation
    ///is modifying a file to match the contents of the same file which exists in another member of the replica set.
    ///</td> </tr> <tr> <td width="40%"><a id="USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT"></a><a
    ///id="usn_source_client_replication_management"></a><dl> <dt><b>USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT</b></dt>
    ///<dt>0x00000008</dt> </dl> </td> <td width="60%"> The operation is modifying a file on client systems to match the
    ///contents of the same file that exists in the cloud. </td> </tr> </table>
    uint          SourceInfo;
    ///The unique security identifier assigned to the file or directory associated with this record.
    uint          SecurityId;
    ///The attributes for the file or directory associated with this record, as returned by the GetFileAttributes
    ///function. Attributes of streams associated with the file or directory are excluded.
    uint          FileAttributes;
    ///The length of the name of the file or directory associated with this record, in bytes. The <b>FileName</b> member
    ///contains this name. Use this member to determine file name length, rather than depending on a trailing '\0' to
    ///delimit the file name in <b>FileName</b>.
    ushort        FileNameLength;
    ///The offset of the <b>FileName</b> member from the beginning of the structure.
    ushort        FileNameOffset;
    ///The name of the file or directory associated with this record in Unicode format. This file or directory name is
    ///of variable length. When working with <b>FileName</b>, do not count on the file name that contains a trailing
    ///'\0' delimiter, but instead determine the length of the file name by using <b>FileNameLength</b>. Do not perform
    ///any compile-time pointer arithmetic using <b>FileName</b>. Instead, make necessary calculations at run time by
    ///using the value of the <b>FileNameOffset</b> member. Doing so helps make your code compatible with any future
    ///versions of <b>USN_RECORD_V3</b>.
    ushort[1]     FileName;
}

///Contains the information for an update sequence number (USN) common header which is common through USN_RECORD_V2,
///USN_RECORD_V3 and USN_RECORD_V4.
struct USN_RECORD_COMMON_HEADER
{
    ///The total length of a record, in bytes. Because USN record is a variable size, the <b>RecordLength</b> member
    ///should be used when calculating the address of the next record in an output buffer, for example, a buffer that is
    ///returned from operations for the DeviceIoControl function that work with different USN record types. For
    ///USN_RECORD_V4, the size in bytes of any change journal record is at most the size of the structure, plus
    ///(NumberOfExtents-1) times size of the USN_RECORD_EXTENT.
    uint   RecordLength;
    ///The major version number of the change journal software for this record. For example, if the change journal
    ///software is version 4.0, the major version number is 4. <table> <tr> <th>Value</th> <th>Description</th> </tr>
    ///<tr> <td>2</td> <td>The structure is a USN_RECORD_V2 structure and the remainder of the structure should be
    ///parsed using that layout.</td> </tr> <tr> <td>3</td> <td>The structure is a USN_RECORD_V3 structure and the
    ///remainder of the structure should be parsed using that layout.</td> </tr> <tr> <td>4</td> <td>The structure is a
    ///USN_RECORD_V4 structure and the remainder of the structure should be parsed using that layout.</td> </tr>
    ///</table>
    ushort MajorVersion;
    ///The minor version number of the change journal software for this record. For example, if the change journal
    ///software is version 4.0, the minor version number is zero.
    ushort MinorVersion;
}

///Contains the offset and length for an update sequence number (USN) record extent.
struct USN_RECORD_EXTENT
{
    ///The offset of the extent, in bytes.
    long Offset;
    ///The length of the extent, in bytes.
    long Length;
}

///Contains the information for an update sequence number (USN) change journal version 4.0 record. The version 2.0 and
///3.0 records are defined by the USN_RECORD_V2 (also called <b>USN_RECORD</b>) and USN_RECORD_V3 structures
///respectively.
struct USN_RECORD_V4
{
    ///A USN_RECORD_COMMON_HEADER structure that describes the record length, major version, and minor version for the
    ///record.
    USN_RECORD_COMMON_HEADER Header;
    ///The 128-bit ordinal number of the file or directory for which this record notes changes. This value is an
    ///arbitrarily assigned value that associates a journal record with a file.
    FILE_ID_128          FileReferenceNumber;
    ///The 128-bit ordinal number of the directory where the file or directory that is associated with this record is
    ///located. This value is an arbitrarily assigned value that associates a journal record with a parent directory.
    FILE_ID_128          ParentFileReferenceNumber;
    ///The USN of this record.
    long                 Usn;
    ///The flags that identify reasons for changes that have accumulated in this file or directory journal record since
    ///the file or directory opened. When a file or directory closes, then a final USN record is generated with the
    ///<b>USN_REASON_CLOSE</b> flag set. The next change (for example, after the next open operation or deletion) starts
    ///a new record with a new set of reason flags. A rename or move operation generates two USN records, one that
    ///records the old parent directory for the item, and one that records a new parent. The following table identifies
    ///the possible flags. <div class="alert"><b>Note</b> Unused bits are reserved.</div> <div> </div> <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="USN_REASON_BASIC_INFO_CHANGE"></a><a
    ///id="usn_reason_basic_info_change"></a><dl> <dt><b>USN_REASON_BASIC_INFO_CHANGE</b></dt> <dt>0x00008000</dt> </dl>
    ///</td> <td width="60%"> A user has either changed one or more file or directory attributes (for example, the
    ///read-only, hidden, system, archive, or sparse attribute), or one or more time stamps. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_CLOSE"></a><a id="usn_reason_close"></a><dl> <dt><b>USN_REASON_CLOSE</b></dt>
    ///<dt>0x80000000</dt> </dl> </td> <td width="60%"> The file or directory is closed. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_COMPRESSION_CHANGE"></a><a id="usn_reason_compression_change"></a><dl>
    ///<dt><b>USN_REASON_COMPRESSION_CHANGE</b></dt> <dt>0x00020000</dt> </dl> </td> <td width="60%"> The compression
    ///state of the file or directory is changed from or to compressed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_DATA_EXTEND"></a><a id="usn_reason_data_extend"></a><dl> <dt><b>USN_REASON_DATA_EXTEND</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> The file or directory is extended (added to). </td> </tr> <tr>
    ///<td width="40%"><a id="USN_REASON_DATA_OVERWRITE"></a><a id="usn_reason_data_overwrite"></a><dl>
    ///<dt><b>USN_REASON_DATA_OVERWRITE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The data in the file
    ///or directory is overwritten. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_DATA_TRUNCATION"></a><a
    ///id="usn_reason_data_truncation"></a><dl> <dt><b>USN_REASON_DATA_TRUNCATION</b></dt> <dt>0x00000004</dt> </dl>
    ///</td> <td width="60%"> The file or directory is truncated. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_EA_CHANGE"></a><a id="usn_reason_ea_change"></a><dl> <dt><b>USN_REASON_EA_CHANGE</b></dt>
    ///<dt>0x00000400</dt> </dl> </td> <td width="60%"> The user made a change to the extended attributes of a file or
    ///directory. These NTFS file system attributes are not accessible to Windows-based applications. </td> </tr> <tr>
    ///<td width="40%"><a id="USN_REASON_ENCRYPTION_CHANGE"></a><a id="usn_reason_encryption_change"></a><dl>
    ///<dt><b>USN_REASON_ENCRYPTION_CHANGE</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The file or
    ///directory is encrypted or decrypted. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_FILE_CREATE"></a><a
    ///id="usn_reason_file_create"></a><dl> <dt><b>USN_REASON_FILE_CREATE</b></dt> <dt>0x00000100</dt> </dl> </td> <td
    ///width="60%"> The file or directory is created for the first time. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_FILE_DELETE"></a><a id="usn_reason_file_delete"></a><dl> <dt><b>USN_REASON_FILE_DELETE</b></dt>
    ///<dt>0x00000200</dt> </dl> </td> <td width="60%"> The file or directory is deleted. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_HARD_LINK_CHANGE"></a><a id="usn_reason_hard_link_change"></a><dl>
    ///<dt><b>USN_REASON_HARD_LINK_CHANGE</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> An NTFS file system
    ///hard link is added to or removed from the file or directory. An NTFS file system hard link, similar to a POSIX
    ///hard link, is one of several directory entries that see the same file or directory. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_INDEXABLE_CHANGE"></a><a id="usn_reason_indexable_change"></a><dl>
    ///<dt><b>USN_REASON_INDEXABLE_CHANGE</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> A user changes the
    ///<b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b> attribute. That is, the user changes the file or directory from one
    ///where content can be indexed to one where content cannot be indexed, or vice versa. Content indexing permits
    ///rapid searching of data by building a database of selected content. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_INTEGRITY_CHANGE"></a><a id="usn_reason_integrity_change"></a><dl>
    ///<dt><b>USN_REASON_INTEGRITY_CHANGE</b></dt> <dt>0x00800000</dt> </dl> </td> <td width="60%"> A user changed the
    ///state of the <b>FILE_ATTRIBUTE_INTEGRITY_STREAM</b> attribute for the given stream. On the ReFS file system,
    ///integrity streams maintain a checksum of all data for that stream, so that the contents of the file can be
    ///validated during read or write operations. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_EXTEND"></a><a id="usn_reason_named_data_extend"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_EXTEND</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> The one or more
    ///named data streams for a file are extended (added to). </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_OVERWRITE"></a><a id="usn_reason_named_data_overwrite"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_OVERWRITE</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> The data in one
    ///or more named data streams for a file is overwritten. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_NAMED_DATA_TRUNCATION"></a><a id="usn_reason_named_data_truncation"></a><dl>
    ///<dt><b>USN_REASON_NAMED_DATA_TRUNCATION</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> The one or more
    ///named data streams for a file is truncated. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_OBJECT_ID_CHANGE"></a><a id="usn_reason_object_id_change"></a><dl>
    ///<dt><b>USN_REASON_OBJECT_ID_CHANGE</b></dt> <dt>0x00080000</dt> </dl> </td> <td width="60%"> The object
    ///identifier of a file or directory is changed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_RENAME_NEW_NAME"></a><a id="usn_reason_rename_new_name"></a><dl>
    ///<dt><b>USN_REASON_RENAME_NEW_NAME</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> A file or directory
    ///is renamed, and the file name in the <b>USN_RECORD_V4</b> structure is the new name. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_RENAME_OLD_NAME"></a><a id="usn_reason_rename_old_name"></a><dl>
    ///<dt><b>USN_REASON_RENAME_OLD_NAME</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> The file or directory
    ///is renamed, and the file name in the <b>USN_RECORD_V4</b> structure is the previous name. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_REPARSE_POINT_CHANGE"></a><a id="usn_reason_reparse_point_change"></a><dl>
    ///<dt><b>USN_REASON_REPARSE_POINT_CHANGE</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The reparse
    ///point that is contained in a file or directory is changed, or a reparse point is added to or deleted from a file
    ///or directory. </td> </tr> <tr> <td width="40%"><a id="USN_REASON_SECURITY_CHANGE"></a><a
    ///id="usn_reason_security_change"></a><dl> <dt><b>USN_REASON_SECURITY_CHANGE</b></dt> <dt>0x00000800</dt> </dl>
    ///</td> <td width="60%"> A change is made in the access rights to a file or directory. </td> </tr> <tr> <td
    ///width="40%"><a id="USN_REASON_STREAM_CHANGE"></a><a id="usn_reason_stream_change"></a><dl>
    ///<dt><b>USN_REASON_STREAM_CHANGE</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> A named stream is added
    ///to or removed from a file, or a named stream is renamed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_REASON_TRANSACTED_CHANGE"></a><a id="usn_reason_transacted_change"></a><dl>
    ///<dt><b>USN_REASON_TRANSACTED_CHANGE</b></dt> <dt>0x00400000 </dt> </dl> </td> <td width="60%"> The given stream
    ///is modified through a committed TxF transaction. </td> </tr> </table>
    uint                 Reason;
    ///Additional information about the source of the change, set by the FSCTL_MARK_HANDLE of the DeviceIoControl
    ///operation. When a thread writes a new USN record, the source information flags in the prior record continue to be
    ///present only if the thread also sets those flags. Therefore, the source information structure allows applications
    ///to filter out USN records that are set only by a known source, for example, an antivirus filter. One of the
    ///following values can be set. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="USN_SOURCE_AUXILIARY_DATA"></a><a id="usn_source_auxiliary_data"></a><dl>
    ///<dt><b>USN_SOURCE_AUXILIARY_DATA</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The operation adds a
    ///private data stream to a file or directory. One example is a virus detector adding checksum information. As the
    ///virus detector modifies the item, the system generates USN records. <b>USN_SOURCE_AUXILIARY_DATA</b> indicates
    ///that the modifications did not change the application data. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_SOURCE_DATA_MANAGEMENT"></a><a id="usn_source_data_management"></a><dl>
    ///<dt><b>USN_SOURCE_DATA_MANAGEMENT</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The operation
    ///provides information about a change to the file or directory made by the operating system. A typical use is when
    ///the Remote Storage system moves data from external to local storage. Remote Storage is the hierarchical storage
    ///management software. Such a move usually at a minimum adds the <b>USN_REASON_DATA_OVERWRITE</b> flag to a USN
    ///record. However, the data has not changed from the user's point of view. By noting
    ///<b>USN_SOURCE_DATA_MANAGEMENT</b> in the <b>SourceInfo</b> member, you can determine that although a write
    ///operation is performed on the item, data has not changed. </td> </tr> <tr> <td width="40%"><a
    ///id="USN_SOURCE_REPLICATION_MANAGEMENT"></a><a id="usn_source_replication_management"></a><dl>
    ///<dt><b>USN_SOURCE_REPLICATION_MANAGEMENT</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The operation
    ///is modifying a file to match the contents of the same file which exists in another member of the replica set.
    ///</td> </tr> <tr> <td width="40%"><a id="USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT"></a><a
    ///id="usn_source_client_replication_management"></a><dl> <dt><b>USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT</b></dt>
    ///<dt>0x00000008</dt> </dl> </td> <td width="60%"> The operation is modifying a file on client systems to match the
    ///contents of the same file that exists in the cloud. </td> </tr> </table>
    uint                 SourceInfo;
    ///The number of extents that remain after the current <b>USN_RECORD_V4</b> record. Multiple version 4.0 records may
    ///be required to describe all of the modified extents for a given file. When the <b>RemainingExtents</b> member is
    ///0, the current <b>USN_RECORD_V4</b> record is the last <b>USN_RECORD_V4</b> record for the file. The last
    ///<b>USN_RECORD_V4</b> entry for a given file is always followed by a USN_RECORD_V3 record with at least the
    ///<b>USN_REASON_CLOSE</b> flag set.
    uint                 RemainingExtents;
    ///The number of extents in current <b>USN_RECORD_V4</b> entry.
    ushort               NumberOfExtents;
    ///The size of each USN_RECORD_EXTENT structure in the <b>Extents</b> member, in bytes.
    ushort               ExtentSize;
    ///An array of USN_RECORD_EXTENT structures that represent the extents in the <b>USN_RECORD_V4</b> entry.
    USN_RECORD_EXTENT[1] Extents;
}

///Represents an update sequence number (USN) change journal, its records, and its capacity. This structure is the
///output buffer for the FSCTL_QUERY_USN_JOURNAL control code. Prior to Windows 8 and Windows Server 2012 this structure
///was named <b>USN_JOURNAL_DATA</b>. Use that name to compile with older SDKs and compilers.
struct USN_JOURNAL_DATA_V0
{
    ///The current journal identifier. A journal is assigned a new identifier on creation and can be stamped with a new
    ///identifier in the course of its existence. The NTFS file system uses this identifier for an integrity check.
    ulong UsnJournalID;
    ///The number of first record that can be read from the journal.
    long  FirstUsn;
    ///The number of next record to be written to the journal.
    long  NextUsn;
    ///The first record that was written into the journal for this journal instance. Enumerating the files or
    ///directories on a volume can return a USN lower than this value (in other words, a <b>FirstUsn</b> member value
    ///less than the <b>LowestValidUsn</b> member value). If it does, the journal has been stamped with a new identifier
    ///since the last USN was written. In this case, <b>LowestValidUsn</b> may indicate a discontinuity in the journal,
    ///in which changes to some or all files or directories on the volume may have occurred that are not recorded in the
    ///change journal.
    long  LowestValidUsn;
    ///The largest USN that the change journal supports. An administrator must delete the change journal as the value of
    ///<b>NextUsn</b> approaches this value.
    long  MaxUsn;
    ///The target maximum size for the change journal, in bytes. The change journal can grow larger than this value, but
    ///it is then truncated at the next NTFS file system checkpoint to less than this value.
    ulong MaximumSize;
    ///The number of bytes of disk memory added to the end and removed from the beginning of the change journal each
    ///time memory is allocated or deallocated. In other words, allocation and deallocation take place in units of this
    ///size. An integer multiple of a cluster size is a reasonable value for this member.
    ulong AllocationDelta;
}

///Represents an update sequence number (USN) change journal, its records, and its capacity. This structure is the
///output buffer for the FSCTL_QUERY_USN_JOURNAL control code. Prior to Windows 8 and Windows Server 2012 this structure
///was named <b>USN_JOURNAL_DATA</b>. Use that name to compile with older SDKs and compilers.
struct USN_JOURNAL_DATA_V1
{
    ///The current journal identifier. A journal is assigned a new identifier on creation and can be stamped with a new
    ///identifier in the course of its existence. The NTFS file system uses this identifier for an integrity check.
    ulong  UsnJournalID;
    ///The number of first record that can be read from the journal.
    long   FirstUsn;
    ///The number of next record to be written to the journal.
    long   NextUsn;
    ///The first record that was written into the journal for this journal instance. Enumerating the files or
    ///directories on a volume can return a USN lower than this value (in other words, a <b>FirstUsn</b> member value
    ///less than the <b>LowestValidUsn</b> member value). If it does, the journal has been stamped with a new identifier
    ///since the last USN was written. In this case, <b>LowestValidUsn</b> may indicate a discontinuity in the journal,
    ///in which changes to some or all files or directories on the volume may have occurred that are not recorded in the
    ///change journal.
    long   LowestValidUsn;
    ///The largest USN that the change journal supports. An administrator must delete the change journal as the value of
    ///<b>NextUsn</b> approaches this value.
    long   MaxUsn;
    ///The target maximum size for the change journal, in bytes. The change journal can grow larger than this value, but
    ///it is then truncated at the next NTFS file system checkpoint to less than this value.
    ulong  MaximumSize;
    ///The number of bytes of disk memory added to the end and removed from the beginning of the change journal each
    ///time memory is allocated or deallocated. In other words, allocation and deallocation take place in units of this
    ///size. An integer multiple of a cluster size is a reasonable value for this member.
    ulong  AllocationDelta;
    ushort MinSupportedMajorVersion;
    ushort MaxSupportedMajorVersion;
}

///Represents an update sequence number (USN) change journal, its records, and its capacity. This structure is the
///output buffer for the FSCTL_QUERY_USN_JOURNAL control code.
struct USN_JOURNAL_DATA_V2
{
    ///The current journal identifier. A journal is assigned a new identifier on creation and can be stamped with a new
    ///identifier in the course of its existence. The NTFS file system uses this identifier for an integrity check.
    ulong  UsnJournalID;
    ///The number of first record that can be read from the journal.
    long   FirstUsn;
    ///The number of next record to be written to the journal.
    long   NextUsn;
    ///The first record that was written into the journal for this journal instance. Enumerating the files or
    ///directories on a volume can return a USN lower than this value (in other words, a <b>FirstUsn</b> member value
    ///less than the <b>LowestValidUsn</b> member value). If it does, the journal has been stamped with a new identifier
    ///since the last USN was written. In this case, <b>LowestValidUsn</b> may indicate a discontinuity in the journal,
    ///in which changes to some or all files or directories on the volume may have occurred that are not recorded in the
    ///change journal.
    long   LowestValidUsn;
    ///The largest USN that the change journal supports. An administrator must delete the change journal as the value of
    ///<b>NextUsn</b> approaches this value.
    long   MaxUsn;
    ///The target maximum size for the change journal, in bytes. The change journal can grow larger than this value, but
    ///it is then truncated at the next NTFS file system checkpoint to less than this value.
    ulong  MaximumSize;
    ///The number of bytes of disk memory added to the end and removed from the beginning of the change journal each
    ///time memory is allocated or deallocated. In other words, allocation and deallocation take place in units of this
    ///size. An integer multiple of a cluster size is a reasonable value for this member.
    ulong  AllocationDelta;
    ///The minimum version of the USN change journal that the file system supports.
    ushort MinSupportedMajorVersion;
    ///The maximum version of the USN change journal that the file system supports.
    ushort MaxSupportedMajorVersion;
    ///Whether or not range tracking is turned on. The following are the possible values for the <b>Flags</b> member.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x00000000</dt> </dl> </td> <td
    ///width="60%"> Range tracking is not turned on for the volume. </td> </tr> <tr> <td width="40%"><a
    ///id="FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE"></a><a id="flag_usn_track_modified_ranges_enable"></a><dl>
    ///<dt><b>FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Range
    ///tracking is turned on for the volume. </td> </tr> </table>
    uint   Flags;
    ///The granularity of tracked ranges. Valid only when you also set the <b>Flags</b> member to
    ///<b>FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE</b>.
    ulong  RangeTrackChunkSize;
    ///File size threshold to start tracking range for files with equal or larger size. Valid only when you also set the
    ///<b>Flags</b> member to <b>FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE</b>.
    long   RangeTrackFileSizeThreshold;
}

///Contains information on the deletion of an update sequence number (USN) change journal using the
///FSCTL_DELETE_USN_JOURNAL control code.
struct DELETE_USN_JOURNAL_DATA
{
    ///The identifier of the change journal to be deleted. If the journal is active and deletion is requested by setting
    ///the USN_DELETE_FLAG_DELETE flag in the <b>DeleteFlags</b> member, then this identifier must specify the change
    ///journal for the current volume. Use FSCTL_QUERY_USN_JOURNAL to retrieve the identifier of this change journal. If
    ///in this case the identifier is not for the current volume's change journal, FSCTL_DELETE_USN_JOURNAL fails. If
    ///notification instead of deletion is requested by setting only the USN_DELETE_FLAG_NOTIFY flag in
    ///<b>DeleteFlags</b>, <b>UsnJournalID</b> is ignored.
    ulong UsnJournalID;
    ///Indicates whether deletion or notification regarding deletion is performed, or both. The <b>DeleteFlags</b>
    ///member must contain one or both of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="USN_DELETE_FLAG_DELETE"></a><a id="usn_delete_flag_delete"></a><dl>
    ///<dt><b>USN_DELETE_FLAG_DELETE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> If this flag is set and
    ///the USN_DELETE_FLAG_NOTIFY flag is not set, the FSCTL_DELETE_USN_JOURNAL operation starts the journal deletion
    ///process and returns immediately. The journal deletion process continues, if necessary, across system restarts. If
    ///this flag is set and the USN_DELETE_FLAG_NOTIFY flag is also set, both deletion and notification occur. If this
    ///flag is set and the journal is active, you must provide the identifier for the change journal for the current
    ///volume in <b>UsnJournalID</b> or the operation fails. If the journal is not active, then <b>UsnJournalID</b> is
    ///ignored and the journal is deleted. </td> </tr> <tr> <td width="40%"><a id="USN_DELETE_FLAG_NOTIFY"></a><a
    ///id="usn_delete_flag_notify"></a><dl> <dt><b>USN_DELETE_FLAG_NOTIFY</b></dt> <dt>0x00000002</dt> </dl> </td> <td
    ///width="60%"> If this flag is set, the call sets up notification about when deletion is complete. The journal
    ///deletion request is completed when the journal deletion process is complete. If this flag is set and the
    ///USN_DELETE_FLAG_DELETE flag is not set, then the call sets up notification of a deletion that may already be in
    ///progress. For example, when your application starts, it might use this flag to determine if a deletion is in
    ///progress. If this flag is set and the USN_DELETE_FLAG_DELETE flag is also set, both deletion and notification
    ///occur. The notification is performed using an I/O completion port or another mechanism for asynchronous event
    ///notification. </td> </tr> </table>
    uint  DeleteFlags;
}

///Contains information that is used to mark a specified file or directory, and its update sequence number (USN) change
///journal record with data about changes. It is used by the FSCTL_MARK_HANDLE control code.
struct MARK_HANDLE_INFO
{
    union
    {
        uint UsnSourceInfo;
        uint CopyNumber;
    }
    ///The volume handle to the volume where the file or directory resides. For more information on obtaining a volume
    ///handle, see the Remarks section. This handle is required to check the privileges for this operation. The caller
    ///must have the <b>SE_MANAGE_VOLUME_NAME</b> privilege. For more information, see Privileges.
    HANDLE VolumeHandle;
    ///The flag that specifies additional information about the file or directory identified by the handle value in the
    ///<b>VolumeHandle</b> member. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="MARK_HANDLE_PROTECT_CLUSTERS"></a><a id="mark_handle_protect_clusters"></a><dl>
    ///<dt><b>MARK_HANDLE_PROTECT_CLUSTERS</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The file is marked
    ///as unable to be defragmented until the handle is closed. Once a handle marked <b>MARK_HANDLE_PROTECT_CLUSTERS</b>
    ///is closed, there is no guarantee that the file's clusters won't move. </td> </tr> <tr> <td width="40%"><a
    ///id="MARK_HANDLE_TXF_SYSTEM_LOG"></a><a id="mark_handle_txf_system_log"></a><dl>
    ///<dt><b>MARK_HANDLE_TXF_SYSTEM_LOG</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The file is marked as
    ///unable to be defragmented until the handle is closed. <b>Windows Server 2003: </b>This flag is not supported
    ///until Windows Server 2003 with SP1. <b>Windows XP: </b>This flag is not supported. </td> </tr> <tr> <td
    ///width="40%"><a id="MARK_HANDLE_NOT_TXF_SYSTEM_LOG"></a><a id="mark_handle_not_txf_system_log"></a><dl>
    ///<dt><b>MARK_HANDLE_NOT_TXF_SYSTEM_LOG</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> The file is
    ///marked as unable to be defragmented until the handle is closed. <b>Windows Server 2003: </b>This flag is not
    ///supported until Windows Server 2003 with SP1. <b>Windows XP: </b>This flag is not supported. </td> </tr> <tr> <td
    ///width="40%"><a id="MARK_HANDLE_REALTIME"></a><a id="mark_handle_realtime"></a><dl>
    ///<dt><b>MARK_HANDLE_REALTIME</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> The file is marked for
    ///real-time read behavior regardless of the actual file type. Files marked with this flag must be opened for
    ///unbuffered I/O. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is not
    ///supported. </td> </tr> <tr> <td width="40%"><a id="MARK_HANDLE_NOT_REALTIME"></a><a
    ///id="mark_handle_not_realtime"></a><dl> <dt><b>MARK_HANDLE_NOT_REALTIME</b></dt> <dt>0x00000040</dt> </dl> </td>
    ///<td width="60%"> The file previously marked for real-time read behavior using the <b>MARK_HANDLE_REALTIME</b>
    ///flag can be unmarked using this flag, removing the real-time behavior. Files marked with this flag must be opened
    ///for unbuffered I/O. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is
    ///not supported. </td> </tr> <tr> <td width="40%"><a id="MARK_HANDLE_READ_COPY"></a><a
    ///id="mark_handle_read_copy"></a><dl> <dt><b>MARK_HANDLE_READ_COPY</b></dt> <dt>0x00000080</dt> </dl> </td> <td
    ///width="60%"> Indicates the copy number specified in the <b>CopyNumber</b> member should be used for reads. Files
    ///marked with this flag must be opened for unbuffered I/O. <b>Windows Server 2008 R2, Windows 7, Windows Server
    ///2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is not supported until Windows 8 and
    ///Windows Server 2012. </td> </tr> <tr> <td width="40%"><a id="MARK_HANDLE_NOT_READ_COPY"></a><a
    ///id="mark_handle_not_read_copy"></a><dl> <dt><b>MARK_HANDLE_NOT_READ_COPY</b></dt> <dt>0x00000100</dt> </dl> </td>
    ///<td width="60%"> The file previously marked for read-copy behavior using the <b>MARK_HANDLE_READ_COPY</b> flag
    ///can be unmarked using this flag, removing the read-copy behavior. Files marked with this flag must be opened for
    ///unbuffered I/O. <b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and
    ///Windows XP: </b>This flag is not supported until Windows 8 and Windows Server 2012. </td> </tr> </td> </tr> <tr>
    ///<td width="40%"><a id="MARK_HANDLE_RETURN_PURGE_FAILURE"></a><a id="mark_handle_return_purge_failure"></a><dl>
    ///<dt><b>MARK_HANDLE_RETURN_PURGE_FAILURE</b></dt> <dt>0x00000400</dt> </dl> </td> <td width="60%"> When
    ///intermixing memory mapped/cached IO with non-cached IO the system attempts, when a non-cached io is issued, to
    ///purge memory mappings for the range of the non-cached IO. If these purges fail the system normally does not
    ///return the failure to the caller which can lead to corrupted state (which is why the documentation says to not do
    ///this). This flag tells the system to return purge failures for the given handle so the application can better
    ///handle this situation This flag is not supported until Windows 8 and Windows Server 2012. </td> </tr> </td> </tr>
    ///<tr> <td width="40%"><a id="MARK_HANDLE_DISABLE_FILE_METADATA_OPTIMIZATION"></a><a
    ///id="mark_handle_disable_file_metadata_optimization"></a><dl>
    ///<dt><b>MARK_HANDLE_DISABLE_FILE_METADATA_OPTIMIZATION </b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%">
    ///A highly fragmented file in NTFS uses multiple MFT records to describe all of the extents for a file. This list
    ///of child MFT records (also known as FRS records) are controlled by a structure known as an attribute list. An
    ///attribute list is limited to 128K in size. When the size of an attribute list hits a certain threshold NTFS will
    ///trigger a background compaction on the extents so the minimum number of child FRS records will be used. This flag
    ///disables this FRS compaction feature for the given file. This flag is not supported until Windows 10. </td> </tr>
    ///</td> </tr> <tr> <td width="40%"><a id="MARK_HANDLE_ENABLE_USN_SOURCE_ON_PAGING_IO "></a><a
    ///id="mark_handle_enable_usn_source_on_paging_io"></a><dl> <dt><b>MARK_HANDLE_ENABLE_USN_SOURCE_ON_PAGING_IO
    ///</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> Tells NTFS to set the given UsnSourceInfo value on
    ///Paging writes in the USN Journal. Traditionally this was not done on paging writes since the system did not know
    ///what thread made the given changes. This is an override. This only works if the FileObject the memory manager is
    ///using has this state associated with it. This flag is not supported until Windows 10. </td> </tr> </td> </tr>
    ///<tr> <td width="40%"><a id="MARK_HANDLE_SKIP_COHERENCY_SYNC_DISALLOW_WRITES"></a><a
    ///id="mark_handle_skip_coherency_sync_disallow_writes"></a><dl>
    ///<dt><b>MARK_HANDLE_SKIP_COHERENCY_SYNC_DISALLOW_WRITES</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%">
    ///Setting this flag tells the system that writes are not allowed on this file. If an application tries to open the
    ///file for write access, the operation is failed with STATUS_ACCESS_DENIED. If a write is seen the operation is
    ///failed with STATUS_MARKED_TO_DISALLOW_WRITES This flag is not supported until Windows 10. </td> </tr> </table>
    uint   HandleInfo;
}

///Contains statistical information from the file system. <div class="alert"><b>Tip</b> Applications targeting Windows
///10 can access additional statistics through FILESYSTEM_STATISTICS_EX. </div><div> </div>
struct FILESYSTEM_STATISTICS
{
    ///The type of file system. This member can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILESYSTEM_STATISTICS_TYPE_EXFAT"></a><a
    ///id="filesystem_statistics_type_exfat"></a><dl> <dt><b>FILESYSTEM_STATISTICS_TYPE_EXFAT</b></dt> <dt>3</dt> </dl>
    ///</td> <td width="60%"> The file system is an exFAT file system. If this value is set, this structure is followed
    ///by an EXFAT_STATISTICS structure. <b>Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not
    ///supported until Windows Vista with SP1. </td> </tr> <tr> <td width="40%"><a
    ///id="FILESYSTEM_STATISTICS_TYPE_FAT"></a><a id="filesystem_statistics_type_fat"></a><dl>
    ///<dt><b>FILESYSTEM_STATISTICS_TYPE_FAT</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The file system is a FAT
    ///file system. If this value is set, this structure is followed by a FAT_STATISTICS structure. </td> </tr> <tr> <td
    ///width="40%"><a id="FILESYSTEM_STATISTICS_TYPE_NTFS"></a><a id="filesystem_statistics_type_ntfs"></a><dl>
    ///<dt><b>FILESYSTEM_STATISTICS_TYPE_NTFS</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The file system is the
    ///NTFS file system. If this value is set, this structure is followed by an NTFS_STATISTICS structure. </td> </tr>
    ///</table>
    ushort FileSystemType;
    ///This member is set to 1 (one).
    ushort Version;
    ///The size of this structure plus the size of the file system-specific structure that follows this structure,
    ///multiplied by the number of processors. This value must be a multiple of 64. For example, if the size of
    ///<b>FILESYSTEM_STATISTICS</b> is 0x38, the size of NTFS_STATISTICS is 0xD8, and if there are 2 processors, the
    ///buffer allocated must be 0x280. sizeof(<b>FILESYSTEM_STATISTICS</b>) = 0x38 sizeof(NTFS_STATISTICS) = 0xD8 Total
    ///Size = 0x110 size of the complete structure = 0x140 (which is the aligned length, a multiple of 64) multiplied by
    ///2 (the number of processors) = 0x280
    uint   SizeOfCompleteStructure;
    ///The number of read operations on user files.
    uint   UserFileReads;
    ///The number of bytes read from user files.
    uint   UserFileReadBytes;
    ///The number of read operations on user files. This value includes sub-read operations.
    uint   UserDiskReads;
    ///The number of write operations on user files.
    uint   UserFileWrites;
    ///The number of bytes written to user files.
    uint   UserFileWriteBytes;
    ///The number of write operations on user files. This value includes sub-write operations.
    uint   UserDiskWrites;
    ///The number of read operations on metadata files.
    uint   MetaDataReads;
    ///The number of bytes read from metadata files.
    uint   MetaDataReadBytes;
    ///The number of read operations on metadata files. This value includes sub-read operations.
    uint   MetaDataDiskReads;
    ///The number of write operations on metadata files.
    uint   MetaDataWrites;
    ///The number of bytes written to metadata files.
    uint   MetaDataWriteBytes;
    ///The number of write operations on metadata files. This value includes sub-write operations.
    uint   MetaDataDiskWrites;
}

///Contains statistical information from the FAT file system.
struct FAT_STATISTICS
{
    ///The number of create operations.
    uint CreateHits;
    ///The number of successful create operations.
    uint SuccessfulCreates;
    ///The number of failed create operations.
    uint FailedCreates;
    ///The number of read operations that were not cached.
    uint NonCachedReads;
    ///The number of bytes read from a file that were not cached.
    uint NonCachedReadBytes;
    ///The number of write operations that were not cached.
    uint NonCachedWrites;
    ///The number of bytes written to a file that were not cached.
    uint NonCachedWriteBytes;
    ///The number of read operations that were not cached. This value includes sub-read operations.
    uint NonCachedDiskReads;
    ///The number of write operations that were not cached. This value includes sub-write operations.
    uint NonCachedDiskWrites;
}

///Contains statistical information from the exFAT file system.
struct EXFAT_STATISTICS
{
    ///The number of create operations.
    uint CreateHits;
    ///The number of successful create operations.
    uint SuccessfulCreates;
    ///The number of failed create operations.
    uint FailedCreates;
    ///The number of read operations that were not cached.
    uint NonCachedReads;
    ///The number of bytes read from a file that were not cached.
    uint NonCachedReadBytes;
    ///The number of write operations that were not cached.
    uint NonCachedWrites;
    ///The number of bytes written to a file that were not cached.
    uint NonCachedWriteBytes;
    ///The number of read operations that were not cached. This value includes sub-read operations.
    uint NonCachedDiskReads;
    ///The number of write operations that were not cached. This value includes sub-write operations.
    uint NonCachedDiskWrites;
}

///Contains statistical information from the NTFS file system. <div class="alert"><b>Tip</b> Applications targeting
///Windows 10 can access additional statistics through NTFS_STATISTICS_EX. </div><div> </div>
struct NTFS_STATISTICS
{
    ///The number of exceptions generated due to the log file being full.
    uint   LogFileFullExceptions;
    ///The number of other exceptions generated.
    uint   OtherExceptions;
    ///The number of read operations on the master file table (MFT).
    uint   MftReads;
    ///The number of bytes read from the MFT.
    uint   MftReadBytes;
    ///The number of write operations on the MFT.
    uint   MftWrites;
    ///The number of bytes written to the MFT.
    uint   MftWriteBytes;
    struct MftWritesUserLevel
    {
        ushort Write;
        ushort Create;
        ushort SetInfo;
        ushort Flush;
    }
    ///The number of flushes of the MFT performed because the log file was full.
    ushort MftWritesFlushForLogFileFull;
    ///The number of MFT write operations performed by the lazy writer thread.
    ushort MftWritesLazyWriter;
    ///Reserved.
    ushort MftWritesUserRequest;
    ///The number of write operations on the MFT mirror.
    uint   Mft2Writes;
    ///The number of bytes written to the MFT mirror.
    uint   Mft2WriteBytes;
    struct Mft2WritesUserLevel
    {
        ushort Write;
        ushort Create;
        ushort SetInfo;
        ushort Flush;
    }
    ///The number of flushes of the MFT mirror performed because the log file was full.
    ushort Mft2WritesFlushForLogFileFull;
    ///The number of MFT mirror write operations performed by the lazy writer thread.
    ushort Mft2WritesLazyWriter;
    ///Reserved.
    ushort Mft2WritesUserRequest;
    ///The number of read operations on the root index.
    uint   RootIndexReads;
    ///The number of bytes read from the root index.
    uint   RootIndexReadBytes;
    ///The number of write operations on the root index.
    uint   RootIndexWrites;
    ///The number of bytes written to the root index.
    uint   RootIndexWriteBytes;
    ///The number of read operations on the cluster allocation bitmap.
    uint   BitmapReads;
    ///The number of bytes read from the cluster allocation bitmap.
    uint   BitmapReadBytes;
    ///The number of write operations on the cluster allocation bitmap.
    uint   BitmapWrites;
    ///The number of bytes written to the cluster allocation bitmap.
    uint   BitmapWriteBytes;
    ///The number of flushes of the bitmap performed because the log file was full.
    ushort BitmapWritesFlushForLogFileFull;
    ///The number of bitmap write operations performed by the lazy writer thread.
    ushort BitmapWritesLazyWriter;
    ///Reserved.
    ushort BitmapWritesUserRequest;
    struct BitmapWritesUserLevel
    {
        ushort Write;
        ushort Create;
        ushort SetInfo;
    }
    ///The number of read operations on the MFT bitmap.
    uint   MftBitmapReads;
    ///The number of bytes read from the MFT bitmap.
    uint   MftBitmapReadBytes;
    ///The number of write operations on the MFT bitmap.
    uint   MftBitmapWrites;
    ///The number of bytes written to the MFT bitmap.
    uint   MftBitmapWriteBytes;
    ///The number of flushes of the MFT bitmap performed because the log file was full.
    ushort MftBitmapWritesFlushForLogFileFull;
    ///The number of MFT bitmap write operations performed by the lazy writer thread.
    ushort MftBitmapWritesLazyWriter;
    ///Reserved.
    ushort MftBitmapWritesUserRequest;
    struct MftBitmapWritesUserLevel
    {
        ushort Write;
        ushort Create;
        ushort SetInfo;
        ushort Flush;
    }
    ///The number of read operations on the user index.
    uint   UserIndexReads;
    ///The number of bytes read from the user index.
    uint   UserIndexReadBytes;
    ///The number of write operations on the user index.
    uint   UserIndexWrites;
    ///The number of bytes written to the user index.
    uint   UserIndexWriteBytes;
    ///The number of read operations on the log file.
    uint   LogFileReads;
    ///The number of bytes read from the log file.
    uint   LogFileReadBytes;
    ///The number of write operations on the log file.
    uint   LogFileWrites;
    ///The number of bytes written to the log file.
    uint   LogFileWriteBytes;
    struct Allocate
    {
        uint Calls;
        uint Clusters;
        uint Hints;
        uint RunsReturned;
        uint HintsHonored;
        uint HintsClusters;
        uint Cache;
        uint CacheClusters;
        uint CacheMiss;
        uint CacheMissClusters;
    }
    ///The number of failed attempts made to acquire a slab of storage for use on the current thinly provisioned volume.
    ///Support for this member started with Windows 8.1.
    uint   DiskResourcesExhausted;
}

///Contains statistical information from the file system.Support for this structure started with Windows 10.
struct FILESYSTEM_STATISTICS_EX
{
    ///The type of file system. This member can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILESYSTEM_STATISTICS_TYPE_EXFAT"></a><a
    ///id="filesystem_statistics_type_exfat"></a><dl> <dt><b>FILESYSTEM_STATISTICS_TYPE_EXFAT</b></dt> <dt>3</dt> </dl>
    ///</td> <td width="60%"> The file system is an exFAT file system. If this value is set, this structure is followed
    ///by an EXFAT_STATISTICS structure. <b>Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not
    ///supported until Windows Vista with SP1. </td> </tr> <tr> <td width="40%"><a
    ///id="FILESYSTEM_STATISTICS_TYPE_FAT"></a><a id="filesystem_statistics_type_fat"></a><dl>
    ///<dt><b>FILESYSTEM_STATISTICS_TYPE_FAT</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The file system is a FAT
    ///file system. If this value is set, this structure is followed by a FAT_STATISTICS structure. </td> </tr> <tr> <td
    ///width="40%"><a id="FILESYSTEM_STATISTICS_TYPE_NTFS"></a><a id="filesystem_statistics_type_ntfs"></a><dl>
    ///<dt><b>FILESYSTEM_STATISTICS_TYPE_NTFS</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The file system is the
    ///NTFS file system. If this value is set, this structure is followed by an NTFS_STATISTICS_EX structure. </td>
    ///</tr> </table>
    ushort FileSystemType;
    ///This member is set to 1 (one).
    ushort Version;
    ///The size of this structure plus the size of the file system-specific structure that follows this structure,
    ///multiplied by the number of processors. This value must be a multiple of 64. For example, if the size of
    ///<b>FILESYSTEM_STATISTICS_EX</b> is 0x68, the size of NTFS_STATISTICS_EX is 0x1D8, and if there are 2 processors,
    ///the buffer allocated must be 0x480. sizeof(<b>FILESYSTEM_STATISTICS_EX</b>) = 0x68 sizeof(NTFS_STATISTICS_EX) =
    ///0x1D8 Total Size = 0x240 size of the complete structure = 0x240 (which is the aligned length, a multiple of 64)
    ///multiplied by 2 (the number of processors) = 0x480
    uint   SizeOfCompleteStructure;
    ///The number of read operations on user files.
    ulong  UserFileReads;
    ///The number of bytes read from user files.
    ulong  UserFileReadBytes;
    ///The number of read operations on user files. This value includes sub-read operations.
    ulong  UserDiskReads;
    ///The number of write operations on user files.
    ulong  UserFileWrites;
    ///The number of bytes written to user files.
    ulong  UserFileWriteBytes;
    ///The number of write operations on user files. This value includes sub-write operations.
    ulong  UserDiskWrites;
    ///The number of read operations on metadata files.
    ulong  MetaDataReads;
    ///The number of bytes read from metadata files.
    ulong  MetaDataReadBytes;
    ///The number of read operations on metadata files. This value includes sub-read operations.
    ulong  MetaDataDiskReads;
    ///The number of write operations on metadata files.
    ulong  MetaDataWrites;
    ///The number of bytes written to metadata files.
    ulong  MetaDataWriteBytes;
    ///The number of write operations on metadata files. This value includes sub-write operations.
    ulong  MetaDataDiskWrites;
}

///<p class="CCE_Message">[Some information relates to pre-released product which may be substantially modified before
///it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information
///provided here.] Contains statistical information from the NTFS file system.Support for this structure started with
///Windows 10.
struct NTFS_STATISTICS_EX
{
    ///The number of exceptions generated due to the log file being full.
    uint  LogFileFullExceptions;
    ///The number of other exceptions generated.
    uint  OtherExceptions;
    ///The number of read operations on the master file table (MFT).
    ulong MftReads;
    ///The number of bytes read from the MFT.
    ulong MftReadBytes;
    ///The number of write operations on the MFT.
    ulong MftWrites;
    ///The number of bytes written to the MFT.
    ulong MftWriteBytes;
    struct MftWritesUserLevel
    {
        uint Write;
        uint Create;
        uint SetInfo;
        uint Flush;
    }
    ///The number of flushes of the MFT performed because the log file was full.
    uint  MftWritesFlushForLogFileFull;
    ///The number of MFT write operations performed by the lazy writer thread.
    uint  MftWritesLazyWriter;
    ///Reserved.
    uint  MftWritesUserRequest;
    ///The number of write operations on the MFT mirror.
    ulong Mft2Writes;
    ///The number of bytes written to the MFT mirror.
    ulong Mft2WriteBytes;
    struct Mft2WritesUserLevel
    {
        uint Write;
        uint Create;
        uint SetInfo;
        uint Flush;
    }
    ///The number of flushes of the MFT mirror performed because the log file was full.
    uint  Mft2WritesFlushForLogFileFull;
    ///The number of MFT mirror write operations performed by the lazy writer thread.
    uint  Mft2WritesLazyWriter;
    ///Reserved.
    uint  Mft2WritesUserRequest;
    ///The number of read operations on the root index.
    ulong RootIndexReads;
    ///The number of bytes read from the root index.
    ulong RootIndexReadBytes;
    ///The number of write operations on the root index.
    ulong RootIndexWrites;
    ///The number of bytes written to the root index.
    ulong RootIndexWriteBytes;
    ///The number of read operations on the cluster allocation bitmap.
    ulong BitmapReads;
    ///The number of bytes read from the cluster allocation bitmap.
    ulong BitmapReadBytes;
    ///The number of write operations on the cluster allocation bitmap.
    ulong BitmapWrites;
    ///The number of bytes written to the cluster allocation bitmap.
    ulong BitmapWriteBytes;
    ///The number of flushes of the bitmap performed because the log file was full.
    uint  BitmapWritesFlushForLogFileFull;
    ///The number of bitmap write operations performed by the lazy writer thread.
    uint  BitmapWritesLazyWriter;
    ///Reserved.
    uint  BitmapWritesUserRequest;
    struct BitmapWritesUserLevel
    {
        uint Write;
        uint Create;
        uint SetInfo;
        uint Flush;
    }
    ///The number of read operations on the MFT bitmap.
    ulong MftBitmapReads;
    ///The number of bytes read from the MFT bitmap.
    ulong MftBitmapReadBytes;
    ///The number of write operations on the MFT bitmap.
    ulong MftBitmapWrites;
    ///The number of bytes written to the MFT bitmap.
    ulong MftBitmapWriteBytes;
    ///The number of flushes of the MFT bitmap performed because the log file was full.
    uint  MftBitmapWritesFlushForLogFileFull;
    ///The number of MFT bitmap write operations performed by the lazy writer thread.
    uint  MftBitmapWritesLazyWriter;
    ///Reserved.
    uint  MftBitmapWritesUserRequest;
    struct MftBitmapWritesUserLevel
    {
        uint Write;
        uint Create;
        uint SetInfo;
        uint Flush;
    }
    ///The number of read operations on the user index.
    ulong UserIndexReads;
    ///The number of bytes read from the user index.
    ulong UserIndexReadBytes;
    ///The number of write operations on the user index.
    ulong UserIndexWrites;
    ///The number of bytes written to the user index.
    ulong UserIndexWriteBytes;
    ///The number of read operations on the log file.
    ulong LogFileReads;
    ///The number of bytes read from the log file.
    ulong LogFileReadBytes;
    ///The number of write operations on the log file.
    ulong LogFileWrites;
    ///The number of bytes written to the log file.
    ulong LogFileWriteBytes;
    struct Allocate
    {
        uint  Calls;
        uint  RunsReturned;
        uint  Hints;
        uint  HintsHonored;
        uint  Cache;
        uint  CacheMiss;
        ulong Clusters;
        ulong HintsClusters;
        ulong CacheClusters;
        ulong CacheMissClusters;
    }
    ///The number of failed attempts made to acquire a slab of storage for use on the current thinly provisioned volume.
    uint  DiskResourcesExhausted;
    ///The number of volume level trim operations issued.
    ulong VolumeTrimCount;
    ///The total time elapsed during all volume level trim operations. This value, divided by the frequency value from
    ///QueryPerformanceFrequency or KeQueryPerformanceCounter, will give the time in seconds.
    ulong VolumeTrimTime;
    ///The total number of bytes issued by all volume level trim operations.
    ulong VolumeTrimByteCount;
    ///The number of file level trim operations issued.
    ulong FileLevelTrimCount;
    ///The total time elapsed during all file level trim operations. This value, divided by the frequency value from
    ///QueryPerformanceFrequency or KeQueryPerformanceCounter, will give the time in seconds.
    ulong FileLevelTrimTime;
    ///The total number of bytes issued by all file level trim operations.
    ulong FileLevelTrimByteCount;
    ///The number of times a volume level trim operation was aborted before being sent down through the storage stack.
    ulong VolumeTrimSkippedCount;
    ///The number of bytes that were not sent through a volume level trim operation because they were skipped.
    ulong VolumeTrimSkippedByteCount;
    ulong NtfsFillStatInfoFromMftRecordCalledCount;
    ulong NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount;
    ulong NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount;
}

///Contains an object identifier and user-defined metadata associated with the object identifier.
struct FILE_OBJECTID_BUFFER
{
    ///The identifier that uniquely identifies the file or directory within the volume on which it resides.
    ubyte[16] ObjectId;
    union
    {
        struct
        {
            ubyte[16] BirthVolumeId;
            ubyte[16] BirthObjectId;
            ubyte[16] DomainId;
        }
        ubyte[48] ExtendedInfo;
    }
}

///Specifies the sparse state to be set.<b>Windows Server 2003 and Windows XP: </b>This structure is optional. For more
///information, see FSCTL_SET_SPARSE.
struct FILE_SET_SPARSE_BUFFER
{
    ///If <b>TRUE</b>, makes the file sparse. If <b>FALSE</b>, makes the file not sparse. <b>Windows Server 2008 R2,
    ///Windows 7, Windows Server 2008 and Windows Vista: </b>A value of <b>FALSE</b> for this member is valid only on
    ///files that no longer have any sparse regions. For more information, see FSCTL_SET_SPARSE. <b>Windows Server 2003
    ///and Windows XP: </b>A value of <b>FALSE</b> for this member is not supported. Specifying <b>FALSE</b> will cause
    ///the FSCTL_SET_SPARSE call to fail.
    ubyte SetSparse;
}

///Contains a range of a file to set to zeros. This structure is used by the FSCTL_SET_ZERO_DATA control code
struct FILE_ZERO_DATA_INFORMATION
{
    ///The file offset of the start of the range to set to zeros, in bytes.
    LARGE_INTEGER FileOffset;
    ///The byte offset of the first byte beyond the last zeroed byte.
    LARGE_INTEGER BeyondFinalZero;
}

///Indicates a range of bytes in a file. This structure is used with the FSCTL_QUERY_ALLOCATED_RANGES control code. On
///input, the structure indicates the range of the file to search. On output, the operation retrieves an array of
///<b>FILE_ALLOCATED_RANGE_BUFFER</b> structures to indicate the allocated ranges within the search range.
struct FILE_ALLOCATED_RANGE_BUFFER
{
    ///The file offset of the start of a range of bytes in a file, in bytes.
    LARGE_INTEGER FileOffset;
    ///The size of the range, in bytes.
    LARGE_INTEGER Length;
}

///Indicates the range of the read operation to perform and the plex from which to read.
struct PLEX_READ_DATA_REQUEST
{
    ///The offset of the range to be read. The offset can be the virtual offset to a file or volume. File offsets should
    ///be cluster aligned and volume offsets should be sector aligned.
    LARGE_INTEGER ByteOffset;
    ///The length of the range to be read. The maximum value is 64 KB.
    uint          ByteLength;
    ///The plex from which to read. A value of zero indicates the primary copy, a value of one indicates the secondary
    ///copy, and so on.
    uint          PlexNumber;
}

///Specifies the disc to close the current session for. This control code is used for UDF file systems. This structure
///is used for input when calling FSCTL_MAKE_MEDIA_COMPATIBLE.
struct FILE_MAKE_COMPATIBLE_BUFFER
{
    ///If <b>TRUE</b>, indicates the media should be finalized. No new data can be appended to the media.
    ubyte CloseDisc;
}

///Specifies the defect management state to be set.
struct FILE_SET_DEFECT_MGMT_BUFFER
{
    ///If <b>TRUE</b>, indicates that defect management is disabled.
    ubyte Disable;
}

///Contains defect management properties.
struct FILE_QUERY_SPARING_BUFFER
{
    ///The size of a sparing packet and the underlying error check and correction (ECC) block size of the volume.
    uint  SparingUnitBytes;
    ///If <b>TRUE</b>, indicates that sparing behavior is software-based; if <b>FALSE</b>, it is hardware-based.
    ubyte SoftwareSparing;
    ///The total number of blocks allocated for sparing.
    uint  TotalSpareBlocks;
    ///The number of blocks available for sparing.
    uint  FreeSpareBlocks;
}

///Receives the volume information from a call to FSCTL_QUERY_ON_DISK_VOLUME_INFO.
struct FILE_QUERY_ON_DISK_VOL_INFO_BUFFER
{
    ///The number of directories on the specified disk. This member is -1 if the number is unknown. For UDF file systems
    ///with a virtual allocation table, this information is available only if the UDF revision is greater than 1.50.
    LARGE_INTEGER DirectoryCount;
    ///The number of files on the specified disk. Returns -1 if the number is unknown. For UDF file systems with a
    ///virtual allocation table, this information is available only if the UDF revision is greater than 1.50.
    LARGE_INTEGER FileCount;
    ///The major version number of the file system. Returns -1 if the number is unknown or not applicable. On UDF 1.02
    ///file systems, 1 is returned.
    ushort        FsFormatMajVersion;
    ///The minor version number of the file system. Returns -1 if the number is unknown or not applicable. On UDF 1.02
    ///file systems, 02 is returned.
    ushort        FsFormatMinVersion;
    ///Always returns UDF.
    ushort[12]    FsFormatName;
    ///The time the media was formatted.
    LARGE_INTEGER FormatTime;
    ///The time the media was last updated.
    LARGE_INTEGER LastUpdateTime;
    ///Any copyright information associated with the volume.
    ushort[34]    CopyrightInfo;
    ///Any abstract information written on the media.
    ushort[34]    AbstractInfo;
    ///Implementation-specific information; in some cases, it is the operating system version that the media was
    ///formatted by.
    ushort[34]    FormattingImplementationInfo;
    ///The last implementation that modified the disk. This information is implementation specific; in some cases, it is
    ///the operating system version that the media was last modified by.
    ushort[34]    LastModifyingImplementationInfo;
}

///Specifies the volume shrink operation to perform.
struct SHRINK_VOLUME_INFORMATION
{
    ///Indicates the operation to perform. The valid values are as follows. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="ShrinkPrepare"></a><a id="shrinkprepare"></a><a id="SHRINKPREPARE"></a><dl>
    ///<dt><b>ShrinkPrepare</b></dt> </dl> </td> <td width="60%"> Volume should perform any steps necessary to prepare
    ///for a shrink operation. </td> </tr> <tr> <td width="40%"><a id="ShrinkCommit"></a><a id="shrinkcommit"></a><a
    ///id="SHRINKCOMMIT"></a><dl> <dt><b>ShrinkCommit</b></dt> </dl> </td> <td width="60%"> Volume should commit the
    ///shrink operation changes. </td> </tr> <tr> <td width="40%"><a id="ShrinkAbort"></a><a id="shrinkabort"></a><a
    ///id="SHRINKABORT"></a><dl> <dt><b>ShrinkAbort</b></dt> </dl> </td> <td width="60%"> Volume should terminate the
    ///shrink operation. </td> </tr> </table>
    SHRINK_VOLUME_REQUEST_TYPES ShrinkRequestType;
    ///This member must be zero.
    ulong Flags;
    ///The number of sectors that should be in the shrunken volume. Used only when the <b>ShrinkRequestType</b> member
    ///is <b>ShrinkPrepare</b>, otherwise this member should be initialized to zero.
    long  NewNumberOfSectors;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains the information
///required when modifying log parameters and logging mode for a secondary resource manager.
struct TXFS_MODIFY_RM
{
    ///The log parameters to be set. This member can be one or more of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="TXFS_RM_FLAG_LOGGING_MODE"></a><a
    ///id="txfs_rm_flag_logging_mode"></a><dl> <dt><b>TXFS_RM_FLAG_LOGGING_MODE</b></dt> <dt>0x00000001</dt> </dl> </td>
    ///<td width="60%"> If this flag is set, the <b>LoggingMode</b> member of this structure is being used. If the flag
    ///is not set, the <b>LoggingMode</b> member is ignored. </td> </tr> <tr> <td width="40%"><a
    ///id="TXFS_RM_FLAG_RENAME_RM"></a><a id="txfs_rm_flag_rename_rm"></a><dl> <dt><b>TXFS_RM_FLAG_RENAME_RM</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> If this flag is set, the RM is instructed to rename itself
    ///(creating a new <b>GUID</b>). </td> </tr> <tr> <td width="40%"><a
    ///id="TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX"></a><a id="txfs_rm_flag_log_container_count_max"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> If this
    ///flag is set, the <b>LogContainerCountMax</b> member is being used. If the flag is not set, the
    ///<b>LogContainerCountMax</b> member is ignored. This flag is mutually exclusive with
    ///<b>TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN"></a><a id="txfs_rm_flag_log_container_count_min"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> If this
    ///flag is set, the <b>LogContainerCountMin</b> member is being used. If the flag is not set, the
    ///<b>LogContainerCountMin</b> member is ignored. This flag is mutually exclusive with
    ///<b>TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS"></a><a
    ///id="txfs_rm_flag_log_growth_increment_num_containers"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%">
    ///If this flag is set, the <b>LogGrowthIncrement</b> member is being used. If the flag is not set, the
    ///<b>LogGrowthIncrement</b> member is ignored. This flag indicates that the log should grow by the number of
    ///containers specified in the <b>LogGrowthIncrement</b> member. This flag is mutually exclusive with
    ///<b>TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT"></a><a id="txfs_rm_flag_log_growth_increment_percent"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> If
    ///this flag is set, the <b>LogGrowthIncrement</b> member is being used. If the flag is not set, the
    ///<b>LogGrowthIncrement</b> member is ignored. This flag indicates that the log should grow by the percentage of
    ///the log size specified in the <b>LogGrowthIncrement</b> member. This flag is mutually exclusive with
    ///<b>TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE"></a><a id="txfs_rm_flag_log_auto_shrink_percentage"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> If this
    ///flag is set, the <b>LogAutoShrinkPercentage</b> member is being used. If the flag is not set, the
    ///<b>LogAutoShrinkPercentage</b> is ignored. </td> </tr> <tr> <td width="40%"><a
    ///id="TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX"></a><a id="txfs_rm_flag_log_no_container_count_max"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> If this
    ///flag is set, the RM is instructed to allow its log to grow without bounds. This flag is mutually exclusive with
    ///<b>TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN"></a><a id="txfs_rm_flag_log_no_container_count_min"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> If this
    ///flag is set, the RM is instructed to allow its log to shrink the log to only two containers. This flag is
    ///mutually exclusive with <b>TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TXFS_RM_FLAG_GROW_LOG"></a><a id="txfs_rm_flag_grow_log"></a><dl> <dt><b>TXFS_RM_FLAG_GROW_LOG</b></dt>
    ///<dt>0x00000400</dt> </dl> </td> <td width="60%"> If this flag is set, the log is instructed to immediately
    ///increase its size to the size specified in <b>LogContainerCount</b>. If the flag is not set, the
    ///<b>LogContainerCount</b> is ignored. </td> </tr> <tr> <td width="40%"><a id="TXFS_RM_FLAG_SHRINK_LOG"></a><a
    ///id="txfs_rm_flag_shrink_log"></a><dl> <dt><b>TXFS_RM_FLAG_SHRINK_LOG</b></dt> <dt>0x00000800</dt> </dl> </td> <td
    ///width="60%"> If this flag is set, the log is instructed to immediately decrease its size to the size specified in
    ///<b>LogContainerCount</b>. If this flag and <b>TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE</b> are set, the log is
    ///instructed to shrink to its minimum allowable size, and <b>LogContainerCount</b> is ignored. </td> </tr> <tr> <td
    ///width="40%"><a id="TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE"></a><a id="txfs_rm_flag_enforce_minimum_size"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> If this flag
    ///and <b>TXFS_RM_FLAG_SHRINK_LOG</b> are set, the log is instructed to shrink to its minimum allowable size, and
    ///<b>LogContainerCount</b> is ignored. If this flag is set, the <b>TXFS_RM_FLAG_SHRINK_LOG</b> must be set. </td>
    ///</tr> <tr> <td width="40%"><a id="TXFS_RM_FLAG_PRESERVE_CHANGES"></a><a
    ///id="txfs_rm_flag_preserve_changes"></a><dl> <dt><b>TXFS_RM_FLAG_PRESERVE_CHANGES</b></dt> <dt>0x00002000</dt>
    ///</dl> </td> <td width="60%"> If this flag is set, the log is instructed to preserve the changes on disk. If this
    ///flag is not set, any changes made are temporary (that is, until the RM is shut down and restarted). </td> </tr>
    ///<tr> <td width="40%"><a id="TXFS_RM_FLAG_RESET_RM_AT_NEXT_START"></a><a
    ///id="txfs_rm_flag_reset_rm_at_next_start"></a><dl> <dt><b>TXFS_RM_FLAG_RESET_RM_AT_NEXT_START</b></dt>
    ///<dt>0x00004000</dt> </dl> </td> <td width="60%"> This flag is only valid for default RMs, not secondary RMs. If
    ///this flag is set, the RM is instructed to reset itself the next time it is started. The log and the associated
    ///metadata are deleted. </td> </tr> <tr> <td width="40%"><a id="TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START"></a><a
    ///id="txfs_rm_flag_do_not_reset_rm_at_next_start"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START</b></dt> <dt>0x00008000</dt> </dl> </td> <td width="60%"> This
    ///flag is only valid for default RMs, not secondary RMs. If this flag is set, a previous call to
    ///FSCTL_TXFS_MODIFY_RM is canceled with the <b>TXFS_RM_FLAG_RESET_RM_AT_NEXT_START</b> flag set. </td> </tr> <tr>
    ///<td width="40%"><a id="TXFS_RM_FLAG_PREFER_CONSISTENCY"></a><a id="txfs_rm_flag_prefer_consistency"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_PREFER_CONSISTENCY</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> Indicates that
    ///the RM is to prefer transaction consistency over system availability. This flag is mutually exclusive with
    ///<b>TXFS_RM_FLAG_PREFER_AVAILABILITY</b> and is not supported by the default RM on the system volume. </td> </tr>
    ///<tr> <td width="40%"><a id="TXFS_RM_FLAG_PREFER_AVAILABILITY"></a><a
    ///id="txfs_rm_flag_prefer_availability"></a><dl> <dt><b>TXFS_RM_FLAG_PREFER_AVAILABILITY</b></dt>
    ///<dt>0x00020000</dt> </dl> </td> <td width="60%"> Indicates that the RM is to prefer system availability over
    ///transaction consistency. This flag is mutually exclusive with <b>TXFS_RM_FLAG_PREFER_CONSISTENCY</b> and is
    ///forced by the default RM on the system volume. </td> </tr> </table>
    uint   Flags;
    ///The maximum size of the log, in containers.
    uint   LogContainerCountMax;
    ///The minimum size of the log, in containers.
    uint   LogContainerCountMin;
    ///The actual size of the log, in containers.
    uint   LogContainerCount;
    ///The number of containers or percentage of space that should be added to the log.
    uint   LogGrowthIncrement;
    ///The percentage of log space to keep free. This member is used when the
    ///<b>TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE</b> flag is used, and instructs the log to automatically shrink
    ///itself, so no more than <b>LogAutoShrinkPercentage</b> of the log is free at any given time.
    uint   LogAutoShrinkPercentage;
    ///Reserved.
    ulong  Reserved;
    ///The current logging mode. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TXFS_LOGGING_MODE_SIMPLE"></a><a id="txfs_logging_mode_simple"></a><dl>
    ///<dt><b><b>TXFS_LOGGING_MODE_SIMPLE</b></b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Simple logging is used.
    ///</td> </tr> <tr> <td width="40%"><a id="TXFS_LOGGING_MODE_FULL"></a><a id="txfs_logging_mode_full"></a><dl>
    ///<dt><b><b>TXFS_LOGGING_MODE_FULL</b></b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Full logging is used </td>
    ///</tr> </table>
    ushort LoggingMode;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains information
///about the resource manager (RM).
struct TXFS_QUERY_RM_INFORMATION
{
    ///If FSCTL_TXFS_QUERY_RM_INFORMATION returns <b>ERROR_BUFFER_TOO_SMALL</b>, this member specifies the minimum
    ///number of bytes needed to return the information requested, including the <b>NULL</b> terminating character.
    uint          BytesRequired;
    ///The oldest log sequence number (LSN) currently used by the RM.
    ulong         TailLsn;
    ///The LSN most recently used by the RM in its log.
    ulong         CurrentLsn;
    ///The LSN of the archive tail of the log.
    ulong         ArchiveTailLsn;
    ///The actual size of a log container, in bytes.
    ulong         LogContainerSize;
    ///The highest timestamp associated with a log record.
    LARGE_INTEGER HighestVirtualClock;
    ///The number of log containers.
    uint          LogContainerCount;
    ///The maximum number of log containers.
    uint          LogContainerCountMax;
    ///The minimum number of containers allowed in the log.
    uint          LogContainerCountMin;
    ///The amount the log will grow by, which is either a number of containers or percentage of the log size; the growth
    ///type used is specified by the flags set in <b>Flags</b> member.
    uint          LogGrowthIncrement;
    ///If the auto-shrink policy is active, this member specifies the maximum allowable amount of free space in the log.
    ///If this member is zero, the auto-shrink policy is not active.
    uint          LogAutoShrinkPercentage;
    ///This member can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN"></a><a
    ///id="txfs_rm_flag_log_container_count_min"></a><dl> <dt><b>TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN</b></dt>
    ///<dt>0x00000008</dt> </dl> </td> <td width="60%"> If the flag is set, the RM's log is allowed to shrink as far as
    ///possible. This flag is mutually exclusive with <b>TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX</b>. </td> </tr> <tr>
    ///<td width="40%"><a id="TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS"></a><a
    ///id="txfs_rm_flag_log_growth_increment_num_containers"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%">
    ///Indicates the type of value in <b>LogGrowthIncrement</b>. If this flag is set, <b>LogGrowthIncrement</b> is a
    ///number of containers. This flag is mutually exclusive with <b>TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT</b>.
    ///</td> </tr> <tr> <td width="40%"><a id="TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT"></a><a
    ///id="txfs_rm_flag_log_growth_increment_percent"></a><dl> <dt><b>TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT</b></dt>
    ///<dt>0x00000020</dt> </dl> </td> <td width="60%"> Indicates the type of value in <b>LogGrowthIncrement</b>. If
    ///this flag is set, <b>LogGrowthIncrement</b> is a percentage. This flag is mutually exclusive with
    ///<b>TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX"></a><a id="txfs_rm_flag_log_no_container_count_max"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%">
    ///Indicates that the RM's log can grow without bounds. This flag is mutually exclusive with
    ///<b>TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TXFS_RM_FLAG_RESET_RM_AT_NEXT_START"></a><a id="txfs_rm_flag_reset_rm_at_next_start"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_RESET_RM_AT_NEXT_START</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> Indicates
    ///the current state of the RM reset flag. If this is set, the RM will reset itself the next time it is started.
    ///This flag is only valid for default RMs, not secondary RMs. This flag is mutually exclusive with
    ///<b>TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START"></a><a id="txfs_rm_flag_do_not_reset_rm_at_next_start"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START</b></dt> <dt>0x00008000</dt> </dl> </td> <td width="60%">
    ///Indicates the current state of the RM reset flag. If this is set, the RM will not reset itself the next time it
    ///is started. This flag is only valid for default RMs, not secondary RMs. This flag is mutually exclusive with
    ///<b>TXFS_RM_FLAG_RESET_RM_AT_NEXT_START</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TXFS_RM_FLAG_PREFER_CONSISTENCY"></a><a id="txfs_rm_flag_prefer_consistency"></a><dl>
    ///<dt><b>TXFS_RM_FLAG_PREFER_CONSISTENCY</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> Indicates that
    ///the RM is to prefer transaction consistency over system availability. This flag is mutually exclusive with
    ///<b>TXFS_RM_FLAG_PREFER_AVAILABILITY</b> and is not supported by the default RM on the system volume. </td> </tr>
    ///<tr> <td width="40%"><a id="TXFS_RM_FLAG_PREFER_AVAILABILITY"></a><a
    ///id="txfs_rm_flag_prefer_availability"></a><dl> <dt><b>TXFS_RM_FLAG_PREFER_AVAILABILITY</b></dt>
    ///<dt>0x00020000</dt> </dl> </td> <td width="60%"> Indicates that the RM is to prefer system availability over
    ///transaction consistency. This flag is mutually exclusive with <b>TXFS_RM_FLAG_PREFER_CONSISTENCY</b> and is
    ///forced by the default RM on the system volume. </td> </tr> </table>
    uint          Flags;
    ///The current logging mode. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TXFS_LOGGING_MODE_SIMPLE"></a><a id="txfs_logging_mode_simple"></a><dl>
    ///<dt><b><b>TXFS_LOGGING_MODE_SIMPLE</b></b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Simple logging is used.
    ///</td> </tr> <tr> <td width="40%"><a id="TXFS_LOGGING_MODE_FULL"></a><a id="txfs_logging_mode_full"></a><dl>
    ///<dt><b><b>TXFS_LOGGING_MODE_FULL</b></b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Full logging is used </td>
    ///</tr> </table>
    ushort        LoggingMode;
    ///Reserved.
    ushort        Reserved;
    ///The state of the RM. Valid values are as follows. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="TXFS_RM_STATE_NOT_STARTED"></a><a id="txfs_rm_state_not_started"></a><dl>
    ///<dt><b>TXFS_RM_STATE_NOT_STARTED</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> The RM is not yet started.
    ///</td> </tr> <tr> <td width="40%"><a id="TXFS_RM_STATE_STARTING"></a><a id="txfs_rm_state_starting"></a><dl>
    ///<dt><b>TXFS_RM_STATE_STARTING</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The RM is starting. </td> </tr>
    ///<tr> <td width="40%"><a id="TXFS_RM_STATE_ACTIVE"></a><a id="txfs_rm_state_active"></a><dl>
    ///<dt><b>TXFS_RM_STATE_ACTIVE</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The RM is active and ready to accept
    ///transactions. </td> </tr> <tr> <td width="40%"><a id="TXFS_RM_STATE_SHUTTING_DOWN"></a><a
    ///id="txfs_rm_state_shutting_down"></a><dl> <dt><b>TXFS_RM_STATE_SHUTTING_DOWN</b></dt> <dt>3</dt> </dl> </td> <td
    ///width="60%"> The RM is shutting down. </td> </tr> </table>
    uint          RmState;
    ///The total capacity of the log, in bytes.
    ulong         LogCapacity;
    ///The number of bytes free in the log.
    ulong         LogFree;
    ///The size of the $Tops file, in bytes.
    ulong         TopsSize;
    ///The amount of the $Tops file that is in use, in bytes.
    ulong         TopsUsed;
    ///The number of active transactions, at the time the query was issued.
    ulong         TransactionCount;
    ///The number of single-phase commit operations that have occurred on this RM.
    ulong         OnePCCount;
    ///The number of two-phase commit operations that have occurred on this RM.
    ulong         TwoPCCount;
    ///The number of times this RM's log has become full.
    ulong         NumberLogFileFull;
    ///The length of the oldest active transaction, in milliseconds.
    ulong         OldestTransactionAge;
    ///The <b>GUID</b> that indicates the name of this RM.
    GUID          RMName;
    ///The offset from the beginning of this structure to a <b>NULL</b>-terminated Unicode string that contains the path
    ///to the TM's log.
    uint          TmLogPathOffset;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains the version
///information about the miniversion that is created.
struct TXFS_GET_METADATA_INFO_OUT
{
    struct TxfFileId
    {
        long LowPart;
        long HighPart;
    }
    ///The <b>GUID</b> of the transaction that locked the specified file locked, if the file is locked.
    GUID  LockingTransaction;
    ///Receives the last LSN for the most recent log record written for file. It is a property of the file that refers
    ///to the log, and references the last log entry of the file.
    ulong LastLsn;
    ///Indicates the state of the transaction that has locked the file. Valid values are: <a
    ///id="TXFS_TRANSACTION_STATE_ACTIVE"></a> <a id="txfs_transaction_state_active"></a>
    uint  TransactionState;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains information
///about a locked transaction.
struct TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY
{
    ///The offset, in bytes, from the beginning of the TXFS_LIST_TRANSACTION_LOCKED_FILES structure to the next
    ///<b>TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY</b>.
    ulong     Offset;
    ///Indicates whether the current name was deleted or created in the current transaction. Note that both flags may
    ///appear if the name was both created and deleted in the same transaction. In that case, the <b>FileName</b> member
    ///will contain only an empty string with a terminating null character ("\0") because there is no meaningful name to
    ///report.
    uint      NameFlags;
    ///The NTFS File ID of the file.
    long      FileId;
    ///Reserved. Specify zero.
    uint      Reserved1;
    ///Reserved. Specify zero.
    uint      Reserved2;
    ///Reserved. Specify zero.
    long      Reserved3;
    ///The path to the file, relative to the volume root. The file name is a NULL-terminated Unicode string.
    ushort[1] FileName;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains a list of files
///locked by a transacted writer.
struct TXFS_LIST_TRANSACTION_LOCKED_FILES
{
    ///The KTM transaction to enumerate locked files for in this RM.
    GUID  KtmTransaction;
    ///The number of files involved for the specified transaction on this resource manager.
    ulong NumberOfFiles;
    ///The length of the buffer required to hold the complete list of files at the time of this call. This is not
    ///guaranteed to be the same length as any other subsequent call.
    ulong BufferSizeRequired;
    ///The offset from the beginning of this structure to the beginning of the first
    ///TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY structure.
    ulong Offset;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains information
///about a transaction.
struct TXFS_LIST_TRANSACTIONS_ENTRY
{
    ///The GUID of the transaction.
    GUID TransactionId;
    ///The current state of the transaction.
    uint TransactionState;
    ///Reserved.
    uint Reserved1;
    ///Reserved.
    uint Reserved2;
    ///Reserved.
    long Reserved3;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains a list of
///transactions.
struct TXFS_LIST_TRANSACTIONS
{
    ///The number of transactions for this resource manager.
    ulong NumberOfTransactions;
    ///The length of the buffer required to hold the complete list of transactions at the time of this call. The number
    ///of transactions returned from one call to the next can change depending on the number of active transactions at
    ///any given point in time. If this call returns a request for a larger buffer, that size may or may not be adequate
    ///for the next call, based on the number of active transactions at the time of the next call.
    ulong BufferSizeRequired;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains a Transactional
///NTFS (TxF) specific structure. This information should only be used when calling TXFS_WRITE_BACKUP_INFORMATION.
struct TXFS_READ_BACKUP_INFORMATION_OUT
{
    union
    {
        uint     BufferLength;
        ubyte[1] Buffer;
    }
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains a Transactional
///NTFS (TxF) specific structure. This information should only be used when calling TXFS_WRITE_BACKUP_INFORMATION.
struct TXFS_WRITE_BACKUP_INFORMATION
{
    ///The buffer for the data.
    ubyte[1] Buffer;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains the information
///about the base and latest versions of the specified file.
struct TXFS_GET_TRANSACTED_VERSION
{
    ///The version of the file that this handle is opened with. This member can be one of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="TXFS_TRANSACTED_VERSION_NONTRANSACTED"></a><a id="txfs_transacted_version_nontransacted"></a><dl>
    ///<dt><b>TXFS_TRANSACTED_VERSION_NONTRANSACTED</b></dt> <dt>0xFFFFFFFE</dt> </dl> </td> <td width="60%"> The file
    ///is not a transacted file. </td> </tr> <tr> <td width="40%"><a id="TXFS_TRANSACTED_VERSION_UNCOMMITTED"></a><a
    ///id="txfs_transacted_version_uncommitted"></a><dl> <dt><b>TXFS_TRANSACTED_VERSION_UNCOMMITTED</b></dt>
    ///<dt>0xFFFFFFFF</dt> </dl> </td> <td width="60%"> The file has been opened as a transacted writer. </td> </tr>
    ///</table> If the handle has been opened as a transacted reader, the value returned for this member is a positive
    ///integer that represents the version number of the file the handle is associated with.
    uint   ThisBaseVersion;
    ///The most recently committed version of the file.
    uint   LatestVersion;
    ///If the handle to a miniversion is open, this member contains the ID of the miniversion. If the handle is not
    ///open, this member is zero (0).
    ushort ThisMiniVersion;
    ///The first available miniversion for this file. If there are no miniversions, or they are not visible to the
    ///transaction bound to the file handle, this field is zero (0).
    ushort FirstMiniVersion;
    ///The latest available miniversion for this file. If there are no miniversions, or they are not visible to the
    ///transaction bound to the file handle, this field is zero (0).
    ushort LatestMiniVersion;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] The
///<b>FSCTL_TXFS_SAVEPOINT_INFORMATION</b> structure specifies the action to perform, and on which transaction.
struct TXFS_SAVEPOINT_INFORMATION
{
    ///Handle to the transaction on which to perform the savepoint operation.
    HANDLE KtmTransaction;
    ///Specifies the savepoint action to perform. Valid values are: <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="TXFS_SAVEPOINT_SET"></a><a id="txfs_savepoint_set"></a><dl>
    ///<dt><b>TXFS_SAVEPOINT_SET</b></dt> <dt>1 (0x1)</dt> </dl> </td> <td width="60%"> Creates a new savepoint. </td>
    ///</tr> <tr> <td width="40%"><a id="TXFS_SAVEPOINT_ROLLBACK"></a><a id="txfs_savepoint_rollback"></a><dl>
    ///<dt><b>TXFS_SAVEPOINT_ROLLBACK</b></dt> <dt>2 (0x2)</dt> </dl> </td> <td width="60%"> Rolls back to the savepoint
    ///specified by the <b>SavepointId</b> member. </td> </tr> <tr> <td width="40%"><a id="TXFS_SAVEPOINT_CLEAR"></a><a
    ///id="txfs_savepoint_clear"></a><dl> <dt><b>TXFS_SAVEPOINT_CLEAR</b></dt> <dt>4 (0x4)</dt> </dl> </td> <td
    ///width="60%"> Clears the most recently set savepoint for the specified transaction. </td> </tr> <tr> <td
    ///width="40%"><a id="TXFS_SAVEPOINT_CLEAR_ALL"></a><a id="txfs_savepoint_clear_all"></a><dl>
    ///<dt><b>TXFS_SAVEPOINT_CLEAR_ALL</b></dt> <dt>16 (0x10)</dt> </dl> </td> <td width="60%"> Clears all savepoints
    ///for the transaction. </td> </tr> </table>
    uint   ActionCode;
    ///If <b>ActionCode</b> is <b>TXFS_SAVEPOINT_SET</b>, on output, returns the newly-created savepoint ID. If
    ///<b>ActionCode</b> is <b>TXFS_ROLLBACK_TO_SAVEPOINT</b>, on input, specifies the savepoint ID to roll back to.
    ///Remains unchanged on output. If <b>ActionCode</b> is <b>TXFS_SAVEPOINT_CLEAR</b> or
    ///<b>TXFS_SAVEPOINT_CLEAR_ALL</b>, this member is not used; therefore, on input, specify <b>NULL</b>.
    uint   SavepointId;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains the version
///information about the miniversion created by FSCTL_TXFS_CREATE_MINIVERSION.
struct TXFS_CREATE_MINIVERSION_INFO
{
    ///The version number of this <b>TXFS_CREATE_MINIVERSION_INFO</b> structure.
    ushort StructureVersion;
    ///The length of this <b>TXFS_CREATE_MINIVERSION_INFO</b> structure.
    ushort StructureLength;
    ///The identifier of the most recently committed version of the file.
    uint   BaseVersion;
    ///The identifier of the newly-created miniversion.
    ushort MiniVersion;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains the flag that
///indicates whether transactions were active or not when a snapshot was taken.
struct TXFS_TRANSACTION_ACTIVE_INFO
{
    ///This member is <b>TRUE</b> if the mounted snapshot volume had active transactions when the snapshot was taken;
    ///and <b>FALSE</b> otherwise.
    ubyte TransactionsActiveAtSnapshot;
}

///Contains the output for the FSCTL_GET_BOOT_AREA_INFO control code.
struct BOOT_AREA_INFO
{
    ///Number of elements in the <b>BootSectors</b> array.
    uint BootSectorCount;
    struct
    {
        LARGE_INTEGER Offset;
    }
}

///Contains the output for the FSCTL_GET_RETRIEVAL_POINTER_BASE control code.
struct RETRIEVAL_POINTER_BASE
{
    ///The volume-relative sector offset to the first allocatable unit on the file system, also referred to as the base
    ///of the cluster heap.
    LARGE_INTEGER FileAreaOffset;
}

///Contains file system recognition information retrieved by the FSCTL_QUERY_FILE_SYSTEM_RECOGNITION control code.
struct FILE_SYSTEM_RECOGNITION_INFORMATION
{
    ///The file system name stored on the disk. This is a null-terminated string of 8 ASCII characters that represents
    ///the nonlocalizable human-readable name of the file system the volume is formatted with.
    byte[9] FileSystem;
}

///Contains the information to request an opportunistic lock (oplock) or to acknowledge an oplock break with the
///FSCTL_REQUEST_OPLOCK control code.
struct REQUEST_OPLOCK_INPUT_BUFFER
{
    ///The version of the <b>REQUEST_OPLOCK_INPUT_BUFFER</b> structure that is being used. Set this member to
    ///<b>REQUEST_OPLOCK_CURRENT_VERSION</b>.
    ushort StructureVersion;
    ///The length of this structure, in bytes. Must be set to <code>sizeof(REQUEST_OPLOCK_INPUT_BUFFER)</code>.
    ushort StructureLength;
    ///A valid combination of the following oplock level values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="OPLOCK_LEVEL_CACHE_READ"></a><a id="oplock_level_cache_read"></a><dl>
    ///<dt><b>OPLOCK_LEVEL_CACHE_READ</b></dt> </dl> </td> <td width="60%"> Allows clients to cache reads. May be
    ///granted to multiple clients. </td> </tr> <tr> <td width="40%"><a id="OPLOCK_LEVEL_CACHE_HANDLE"></a><a
    ///id="oplock_level_cache_handle"></a><dl> <dt><b>OPLOCK_LEVEL_CACHE_HANDLE</b></dt> </dl> </td> <td width="60%">
    ///Allows clients to cache open handles. May be granted to multiple clients. </td> </tr> <tr> <td width="40%"><a
    ///id="OPLOCK_LEVEL_CACHE_WRITE"></a><a id="oplock_level_cache_write"></a><dl>
    ///<dt><b>OPLOCK_LEVEL_CACHE_WRITE</b></dt> </dl> </td> <td width="60%"> Allows clients to cache writes and byte
    ///range locks. May be granted only to a single client. </td> </tr> </table> Valid combinations of these values are
    ///as follows: <ul> <li><code>OPLOCK_LEVEL_CACHE_READ</code></li> <li><code>OPLOCK_LEVEL_CACHE_READ |
    ///OPLOCK_LEVEL_CACHE_HANDLE</code></li> <li><code>OPLOCK_LEVEL_CACHE_READ | OPLOCK_LEVEL_CACHE_WRITE</code></li>
    ///<li><code>OPLOCK_LEVEL_CACHE_READ | OPLOCK_LEVEL_CACHE_WRITE | OPLOCK_LEVEL_CACHE_HANDLE</code></li> </ul> For
    ///more information about these value combinations, see FSCTL_REQUEST_OPLOCK.
    uint   RequestedOplockLevel;
    ///A valid combination of the following request flag values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="REQUEST_OPLOCK_INPUT_FLAG_REQUEST"></a><a id="request_oplock_input_flag_request"></a><dl>
    ///<dt><b>REQUEST_OPLOCK_INPUT_FLAG_REQUEST</b></dt> </dl> </td> <td width="60%"> Request for a new oplock. Setting
    ///this flag together with <b>REQUEST_OPLOCK_INPUT_FLAG_ACK</b> is not valid and will cause the request to fail with
    ///<b>ERROR_INVALID_PARAMETER</b>. </td> </tr> <tr> <td width="40%"><a id="REQUEST_OPLOCK_INPUT_FLAG_ACK"></a><a
    ///id="request_oplock_input_flag_ack"></a><dl> <dt><b>REQUEST_OPLOCK_INPUT_FLAG_ACK</b></dt> </dl> </td> <td
    ///width="60%"> Acknowledgment of an oplock break. Setting this flag together with <b>REQUEST_OPLOCK_
    ///INPUT_FLAG_REQUEST</b> is not valid and will cause the request to fail with <b>ERROR_INVALID_PARAMETER</b>. </td>
    ///</tr> </table>
    uint   Flags;
}

///Contains the opportunistic lock (oplock) information returned by the FSCTL_REQUEST_OPLOCK control code.
struct REQUEST_OPLOCK_OUTPUT_BUFFER
{
    ///The version of the <b>REQUEST_OPLOCK_OUTPUT_BUFFER</b> structure that is being used.
    ushort StructureVersion;
    ///The length of this structure, in bytes.
    ushort StructureLength;
    ///One or more <b>OPLOCK_LEVEL_CACHE_</b><i>XXX</i> values that indicate the level of the oplock that was broken.
    ///For possible values, see the <b>RequestedOplockLevel</b> member of the REQUEST_OPLOCK_INPUT_BUFFER structure.
    uint   OriginalOplockLevel;
    ///One or more <b>OPLOCK_LEVEL_CACHE_</b><i>XXX</i> values that indicate the level to which an oplock is being
    ///broken, or an oplock level that may be available for granting, depending on the operation returning this buffer.
    ///For possible values, see the <b>RequestedOplockLevel</b> member of the REQUEST_OPLOCK_INPUT_BUFFER structure.
    uint   NewOplockLevel;
    ///One or more <b>REQUEST_OPLOCK_OUTPUT_FLAG_</b><i>XXX</i> values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED"></a><a
    ///id="request_oplock_output_flag_ack_required"></a><dl> <dt><b>REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED</b></dt>
    ///</dl> </td> <td width="60%"> Indicates that an acknowledgment is required, and the oplock described in
    ///<b>OriginalOplockLevel</b> will continue to remain in force until the break is successfully acknowledged. </td>
    ///</tr> <tr> <td width="40%"><a id="REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED"></a><a
    ///id="request_oplock_output_flag_modes_provided"></a><dl> <dt><b>REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED</b></dt>
    ///</dl> </td> <td width="60%"> Indicates that the <b>ShareMode</b> and <b>AccessMode</b> members contain the share
    ///and access flags, respectively, of the request causing the oplock break. For more information, see the Remarks
    ///section. </td> </tr> </table>
    uint   Flags;
    ///If the <b>REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED</b> flag is set and the <b>OPLOCK_LEVEL_CACHE_HANDLE</b>
    ///level is being lost in an oplock break, contains the access mode mode of the request that is causing the break.
    uint   AccessMode;
    ///If the <b>REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED</b> flag is set and the <b>OPLOCK_LEVEL_CACHE_HANDLE</b>
    ///level is being lost in an oplock break, contains the share mode of the request that is causing the break.
    ushort ShareMode;
}

///Passed as input to the FSCTL_LOOKUP_STREAM_FROM_CLUSTER control code.
struct LOOKUP_STREAM_FROM_CLUSTER_INPUT
{
    ///Flags for the operation. Currently no flags are defined.
    uint             Flags;
    ///Number of clusters in the following array of clusters. The input buffer must be large enough to contain this
    ///number or the operation will fail.
    uint             NumberOfClusters;
    ///An array of one or more clusters to look up.
    LARGE_INTEGER[1] Cluster;
}

///Received as output from the FSCTL_LOOKUP_STREAM_FROM_CLUSTER control code.
struct LOOKUP_STREAM_FROM_CLUSTER_OUTPUT
{
    ///Offset from the beginning of this structure to the first entry returned. If no entries are returned, this value
    ///is zero.
    uint Offset;
    ///Number of matches to the input criteria. Note that more matches may be found than entries returned if the buffer
    ///provided is not large enough.
    uint NumberOfMatches;
    ///Minimum size of the buffer, in bytes, which would be needed to contain all matching entries to the input
    ///criteria.
    uint BufferSizeRequired;
}

///Returned from the FSCTL_LOOKUP_STREAM_FROM_CLUSTER control code. Zero or more of these structures follow the
///LOOKUP_STREAM_FROM_CLUSTER_OUTPUT structure in the output buffer returned.
struct LOOKUP_STREAM_FROM_CLUSTER_ENTRY
{
    ///Offset in bytes from the beginning of this structure to the next <b>LOOKUP_STREAM_FROM_CLUSTER_ENTRY</b>
    ///structure returned. If there are no more entries, this value is zero.
    uint          OffsetToNext;
    ///Flags describing characteristics about this stream. The value will consist of one or more of these values. At
    ///least one of the <b>LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_*</b> values that fall within the
    ///<b>LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK</b> (0xff000000) will be set; one or more of the other flag
    ///values may be set. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE"></a><a
    ///id="lookup_stream_from_cluster_entry_flag_page_file"></a><dl>
    ///<dt><b>LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%">
    ///The stream is part of the system pagefile. </td> </tr> <tr> <td width="40%"><a
    ///id="LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET"></a><a
    ///id="lookup_stream_from_cluster_entry_flag_deny_defrag_set"></a><dl>
    ///<dt><b>LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET</b></dt> <dt>0x00000002</dt> </dl> </td> <td
    ///width="60%"> The stream is locked from defragmentation. The <b>HandleInfo</b> member of the MARK_HANDLE_INFO
    ///structure for this stream has the <b>MARK_HANDLE_PROTECT_CLUSTERS</b> flag set. </td> </tr> <tr> <td
    ///width="40%"><a id="LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE"></a><a
    ///id="lookup_stream_from_cluster_entry_flag_fs_system_file"></a><dl>
    ///<dt><b>LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE</b></dt> <dt>0x00000004</dt> </dl> </td> <td
    ///width="60%"> The stream is part of a file that is internal to the filesystem. </td> </tr> <tr> <td width="40%"><a
    ///id="LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE"></a><a
    ///id="lookup_stream_from_cluster_entry_flag_txf_system_file"></a><dl>
    ///<dt><b>LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE</b></dt> <dt>0x00000008</dt> </dl> </td> <td
    ///width="60%"> The stream is part of a file that is internal to TxF. </td> </tr> <tr> <td width="40%"><a
    ///id="LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA"></a><a
    ///id="lookup_stream_from_cluster_entry_attribute_data"></a><dl>
    ///<dt><b>LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA</b></dt> <dt>0x01000000</dt> </dl> </td> <td width="60%">
    ///The stream is part of a $DATA attribute for the file (data stream). </td> </tr> <tr> <td width="40%"><a
    ///id="LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX"></a><a
    ///id="lookup_stream_from_cluster_entry_attribute_index"></a><dl>
    ///<dt><b>LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX</b></dt> <dt>0x02000000</dt> </dl> </td> <td width="60%">
    ///The stream is part of the $INDEX_ALLOCATION attribute for the file. </td> </tr> <tr> <td width="40%"><a
    ///id="LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM"></a><a
    ///id="lookup_stream_from_cluster_entry_attribute_system"></a><dl>
    ///<dt><b>LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM</b></dt> <dt>0x03000000</dt> </dl> </td> <td
    ///width="60%"> The stream is part of another attribute for the file. </td> </tr> </table>
    uint          Flags;
    ///This value is reserved and is currently zero.
    LARGE_INTEGER Reserved;
    ///This is the cluster that this entry refers to. It will be one of the clusters passed in the input structure.
    LARGE_INTEGER Cluster;
    ///A <b>NULL</b>-terminated Unicode string containing the path of the object relative to the root of the volume.
    ///This string will refer to the attribute or stream represented by the cluster. This string is not limited by
    ///<b>MAX_PATH</b> and may be up to 32,768 characters (65,536 bytes) in length. Not all of the filenames returned
    ///can be opened; some are internal to NTFS and always opened exclusively. The string returned includes the full
    ///path including filename, stream name, and attribute type name in the form "<i>full</i>&
    ushort[1]     FileName;
}

///Contains the output for the FSCTL_IS_CSV_FILE control code that retrieves namespace information for a file.
struct CSV_NAMESPACE_INFO
{
    ///The version number. This value must be set to <b>CSV_NAMESPACE_INFO_V1</b>. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="CSV_NAMESPACE_INFO_V1"></a><a
    ///id="csv_namespace_info_v1"></a><dl> <dt><b>CSV_NAMESPACE_INFO_V1</b></dt> </dl> </td> <td width="60%"> Version 1.
    ///</td> </tr> </table>
    uint          Version;
    ///The device number of the disk.
    uint          DeviceNumber;
    ///The starting offset of the volume.
    LARGE_INTEGER StartingOffset;
    ///The sector size of the disk.
    uint          SectorSize;
}

///Represents a type of CSV control operation.
struct CSV_CONTROL_PARAM
{
    ///The type of CSV control operation to undertake.
    CSV_CONTROL_OP Operation;
    ///Unused.
    long           Unused;
}

///Contains information about whether files in a stream have been redirected.
struct CSV_QUERY_REDIRECT_STATE
{
    ///The identifier of an MDS node.
    uint  MdsNodeId;
    ///The identifier of a DS node.
    uint  DsNodeId;
    ///<b>TRUE</b> if the file has been redirected; otherwise, <b>FALSE</b>.
    ubyte FileRedirected;
}

///Contains information about whether files in a stream have been modified.
struct CSV_QUERY_FILE_REVISION
{
    ///The identifier of an NTFS file.
    long    FileId;
    ///File revision tracking elements. <ul> <li><b>FileRevision</b>[0] increases every time the CSV MDS stack is
    ///rebuilt and CSVFLT loses its state.</li> <li><b>FileRevision</b>[1] increases every time the CSV MDS stack purges
    ///the cached revision number for the file.</li> <li><b>FileRevision</b>[2] increases every time the CSV MDS
    ///observes that file sizes might have changed or the file might have been written to. The element is also
    ///incremented whenever one of the nodes performs the first direct input/output operation on a stream that is
    ///associated with this file after opening this stream.</li> </ul> If any of the numbers are 0, the function caller
    ///should assume that the file was modified.
    long[3] FileRevision;
}

///Contains the path that is used by CSV to communicate to the MDS.
struct CSV_QUERY_MDS_PATH
{
    ///The identifier of an MDS node.
    uint      MdsNodeId;
    ///The identifier of a DS node.
    uint      DsNodeId;
    ///The length of the path.
    uint      PathLength;
    ///The path.
    ushort[1] Path;
}

///Contains troubleshooting information about why a volume is in redirected mode.
struct CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT
{
    ///The integer portion of VetoedFromAltitude.
    ulong       VetoedFromAltitudeIntegral;
    ///The decimal portion of VetoedFromAltitude.
    ulong       VetoedFromAltitudeDecimal;
    ///The reason why volume is in a redirected mode.
    ushort[256] Reason;
}

///Contains the output for the FSCTL_IS_VOLUME_OWNED_BYCSVFS control code that determines whether a volume is owned by
///CSVFS.
struct CSV_IS_OWNED_BY_CSVFS
{
    ///<b>TRUE</b> if a volume is owned by CSVFS; otherwise, <b>FALSE</b>.
    ubyte OwnedByCSVFS;
}

///Specifies a range of a file that is to be trimmed.
struct FILE_LEVEL_TRIM_RANGE
{
    ///Offset, in bytes, from the start of the file for the range to be trimmed.
    ulong Offset;
    ///Length, in bytes, for the range to be trimmed.
    ulong Length;
}

///Used as input to the FSCTL_FILE_LEVEL_TRIM control code.
struct FILE_LEVEL_TRIM
{
    ///Reserved. Set to zero (0).
    uint Key;
    ///Number of FILE_LEVEL_TRIM_RANGE entries in the <b>Ranges</b> member. On return should be compared with the
    ///<b>NumRangesProcessed</b> member of the FILE_LEVEL_TRIM_OUTPUT structure.
    uint NumRanges;
    ///Array of ranges that describe the portions of the file that are to be trimmed.
    FILE_LEVEL_TRIM_RANGE[1] Ranges;
}

///Used as output to the FSCTL_FILE_LEVEL_TRIM control code.
struct FILE_LEVEL_TRIM_OUTPUT
{
    ///Contains the number of ranges that were successfully processed. This may be less than the value passed in the
    ///<b>NumRanges</b> member of the FILE_LEVEL_TRIM structure. If it is then the last ranges in the array were not
    ///processed.
    uint NumRangesProcessed;
}

///Contains the integrity information for a file or directory. Returned from the FSCTL_GET_INTEGRITY_INFORMATION control
///code.
struct FSCTL_GET_INTEGRITY_INFORMATION_BUFFER
{
    ///The checksum algorithm used. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="CHECKSUM_TYPE_NONE"></a><a id="checksum_type_none"></a><dl> <dt><b>CHECKSUM_TYPE_NONE</b></dt>
    ///<dt>0x0000</dt> </dl> </td> <td width="60%"> The file or directory is not configured to use integrity. </td>
    ///</tr> <tr> <td width="40%"><a id="CHECKSUM_TYPE_CRC64"></a><a id="checksum_type_crc64"></a><dl>
    ///<dt><b>CHECKSUM_TYPE_CRC64</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> The file or directory uses a
    ///CRC64 checksum to provide integrity. </td> </tr> <tr> <td width="40%"> <dl> <dt>3–0xffff</dt> </dl> </td> <td
    ///width="60%"> Reserved for future use. </td> </tr> </table>
    ushort ChecksumAlgorithm;
    ///Reserved for future use. Set to 0.
    ushort Reserved;
    ///Contains one or more flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="FSCTL_INTEGRITY_FLAG_CHECKSUM_ENFORCEMENT_OFF"></a><a
    ///id="fsctl_integrity_flag_checksum_enforcement_off"></a><dl>
    ///<dt><b>FSCTL_INTEGRITY_FLAG_CHECKSUM_ENFORCEMENT_OFF</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> If
    ///set, the checksum enforcement is disabled. </td> </tr> </table>
    uint   Flags;
    ///Size in bytes of the chunks used to calculate checksums.
    uint   ChecksumChunkSizeInBytes;
    ///Size in bytes of a cluster for this volume. This value must be a power of 2, must be greater than or equal to the
    ///sector size of the underlying hardware and must be a power of 2 multiple of the sector size.
    uint   ClusterSizeInBytes;
}

///Input buffer passed with the FSCTL_SET_INTEGRITY_INFORMATION control code.
struct FSCTL_SET_INTEGRITY_INFORMATION_BUFFER
{
    ///Specifies the checksum algorithm. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="CHECKSUM_TYPE_NONE"></a><a id="checksum_type_none"></a><dl> <dt><b>CHECKSUM_TYPE_NONE</b></dt>
    ///<dt>0x0000</dt> </dl> </td> <td width="60%"> The file or directory is not configured to use integrity. </td>
    ///</tr> <tr> <td width="40%"><a id="CHECKSUM_TYPE_CRC64"></a><a id="checksum_type_crc64"></a><dl>
    ///<dt><b>CHECKSUM_TYPE_CRC64</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> The file or directory uses a
    ///CRC64 checksum to provide integrity. </td> </tr> <tr> <td width="40%"> <dl> <dt>3–0xfffe</dt> </dl> </td> <td
    ///width="60%"> Reserved for future use. Must not be used. </td> </tr> <tr> <td width="40%"><a
    ///id="CHECKSUM_TYPE_UNCHANGED"></a><a id="checksum_type_unchanged"></a><dl> <dt><b>CHECKSUM_TYPE_UNCHANGED</b></dt>
    ///<dt>0xffff</dt> </dl> </td> <td width="60%"> The checksum algorithm is to remain the same. </td> </tr> </table>
    ushort ChecksumAlgorithm;
    ///Must be 0
    ushort Reserved;
    ///Contains zero or more flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="FSCTL_INTEGRITY_FLAG_CHECKSUM_ENFORCEMENT_OFF"></a><a
    ///id="fsctl_integrity_flag_checksum_enforcement_off"></a><dl>
    ///<dt><b>FSCTL_INTEGRITY_FLAG_CHECKSUM_ENFORCEMENT_OFF</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> If
    ///set, the checksum enforcement is disabled and reads will succeed even if the checksums do not match. This flag is
    ///valid only if the file has an integrity algorithm set. If there is no algorithm set or the <b>CheckSum</b> member
    ///is set to <b>CHECKSUM_TYPE_NONE</b>, then the operation fails with <b>ERROR_INVALID_PARAMETER</b>. </td> </tr>
    ///</table>
    uint   Flags;
}

///Input structure for the FSCTL_REPAIR_COPIES control code. It describes a single block of data and indicates which of
///the copies is to be copied to the specified copies of the data. The
struct REPAIR_COPIES_INPUT
{
    ///Set to <code>sizeof(REPAIR_COPIES_INPUT)</code>.
    uint          Size;
    ///Reserved (must be zero)
    uint          Flags;
    ///The file position to start the repair operation.
    LARGE_INTEGER FileOffset;
    ///The number of bytes to be repaired.
    uint          Length;
    ///The zero-based copy number of the source copy.
    uint          SourceCopy;
    ///The number of copies that will be repaired. This is the size of the <b>RepairCopies</b> array.
    uint          NumberOfRepairCopies;
    ///The zero-based copy numbers of the copies that will be repaired.
    uint[1]       RepairCopies;
}

///Contains output of a repair copies operation returned from the FSCTL_REPAIR_COPIES control code.
struct REPAIR_COPIES_OUTPUT
{
    ///Set to <code>sizeof(REPAIR_COPIES_OUTPUT)</code>.
    uint          Size;
    ///Indicates the status of the repair operation. The value is a <b>NTSTATUS</b> value. See
    ///http://msdn.microsoft.com/en-us/library/cc704588(PROT.10).aspx for a list of <b>NTSTATUS</b> values.
    uint          Status;
    LARGE_INTEGER ResumeFileOffset;
}

///Represents an identifier for the storage tier relative to the volume.
struct FILE_STORAGE_TIER
{
    ///Tier ID.
    GUID        Id;
    ///Name for the tier.
    ushort[256] Name;
    ///Note for the tier.
    ushort[256] Description;
    ///The file storage tier flags. This member can be one or more of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_STORAGE_TIER_FLAG_NO_SEEK_PENALTY"></a><a
    ///id="file_storage_tier_flag_no_seek_penalty"></a><dl> <dt><b>FILE_STORAGE_TIER_FLAG_NO_SEEK_PENALTY</b></dt>
    ///<dt>0x00020000</dt> </dl> </td> <td width="60%"> Tier does not suffer a seek penalty on IO operations, which
    ///indicates that is an SSD (solid state drive). </td> </tr> </table>
    ulong       Flags;
    ///Provisioned capacity of the tier.
    ulong       ProvisionedCapacity;
    ///Media type of the tier.
    FILE_STORAGE_TIER_MEDIA_TYPE MediaType;
    FILE_STORAGE_TIER_CLASS Class;
}

///Contains information for all tiers of a specific volume.
struct FSCTL_QUERY_STORAGE_CLASSES_OUTPUT
{
    ///The size of this structure serves as the version. Set it to
    ///<b>sizeof</b>(<b>FSCTL_QUERY_STORAGE_CLASSES_OUTPUT</b>).
    uint                 Version;
    ///Size of this structure plus all the variable sized fields.
    uint                 Size;
    ///The element status. This member can be one or more of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_STORAGE_TIER_FLAG_NO_SEEK_PENALTY"></a><a
    ///id="file_storage_tier_flag_no_seek_penalty"></a><dl> <dt><b>FILE_STORAGE_TIER_FLAG_NO_SEEK_PENALTY</b></dt>
    ///<dt>0x00020000</dt> </dl> </td> <td width="60%"> Tier does not suffer a seek penalty on IO operations, which
    ///indicates that is an SSD (solid state drive). </td> </tr> </table>
    uint                 Flags;
    ///Total number of available tiers for this disk.
    uint                 TotalNumberOfTiers;
    ///Number of tiers that fit in the output.
    uint                 NumberOfTiersReturned;
    FILE_STORAGE_TIER[1] Tiers;
}

///Contains the storage tier regions from the storage stack for a particular volume.
struct FSCTL_QUERY_REGION_INFO_INPUT
{
    ///The size of this structure serves as the version. Set it to <b>sizeof</b>(<b>FSCTL_QUERY_REGION_INFO_INPUT</b>).
    uint    Version;
    ///The size of this structure in bytes.
    uint    Size;
    ///Reserved for future use.
    uint    Flags;
    ///Number of entries in <b>TierIds</b>, 0 to request IDs for the entire volume.
    uint    NumberOfTierIds;
    GUID[1] TierIds;
}

///Describes a single storage tier region.
struct FILE_STORAGE_TIER_REGION
{
    ///Tier ID.
    GUID  TierId;
    ///Offset from the beginning of the volume of this region, in bytes.
    ulong Offset;
    ulong Length;
}

///Contains information for one or more regions.
struct FSCTL_QUERY_REGION_INFO_OUTPUT
{
    ///The size of this structure serves as the version. Set it to <b>sizeof</b>(<b>FSCTL_QUERY_REGION_INFO_OUTPUT</b>).
    uint  Version;
    ///The size of this structure in bytes.
    uint  Size;
    ///Reserved for future use.
    uint  Flags;
    ///Reserved for future use.
    uint  Reserved;
    ///Offset from the beginning of the volume to the first slab of the tiered volume. If the logical disk is made up of
    ///multiple tiers and each tier maps to a set of regions then the first tier for the volume contained on the logical
    ///disk has a certain offset within the tier that represents the offset of the volume on the logical disk. The
    ///<b>Alignment</b> member contains this value.
    ulong Alignment;
    ///Total number of available regions.
    uint  TotalNumberOfRegions;
    ///Number of regions that fit in the output.
    uint  NumberOfRegionsReturned;
    FILE_STORAGE_TIER_REGION[1] Regions;
}

///Contains parameters for the FSCTL_DUPLICATE_EXTENTS control code that performs the Block Cloning operation.
struct DUPLICATE_EXTENTS_DATA
{
    ///A handle to the source file from which the byte range is to be copied. To retrieve a file handle, use the
    ///CreateFile function.
    HANDLE        FileHandle;
    ///The offset, in bytes, to the beginning of the range to copy from the source file.
    LARGE_INTEGER SourceFileOffset;
    ///The offset, in bytes, to place the copied byte range in the destination file.
    LARGE_INTEGER TargetFileOffset;
    ///The length, in bytes, of the range to copy.
    LARGE_INTEGER ByteCount;
}

///Represents a disk extent.
struct DISK_EXTENT
{
    ///The number of the disk that contains this extent. This is the same number that is used to construct the name of
    ///the disk, for example, the *X* in "\\\\?\\PhysicalDrive*X*" or "\\\\?\\\Harddisk*X*".
    uint          DiskNumber;
    ///The offset from the beginning of the disk to the extent, in bytes.
    LARGE_INTEGER StartingOffset;
    ///The number of bytes in this extent.
    LARGE_INTEGER ExtentLength;
}

///Represents a physical location on a disk. It is the output buffer for the IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS
///control code.
struct VOLUME_DISK_EXTENTS
{
    ///The number of disks in the volume (a volume can span multiple disks). An extent is a contiguous run of sectors on
    ///one disk. When the number of extents returned is greater than one (1), the error code <b>ERROR_MORE_DATA</b> is
    ///returned. You should call DeviceIoControl again, allocating enough buffer space based on the value of
    ///<b>NumberOfDiskExtents</b> after the first <b>DeviceIoControl</b> call.
    uint           NumberOfDiskExtents;
    ///An array of DISK_EXTENT structures.
    DISK_EXTENT[1] Extents;
}

///Contains volume attributes retrieved with the IOCTL_VOLUME_GET_GPT_ATTRIBUTES control code.
struct VOLUME_GET_GPT_ATTRIBUTES_INFORMATION
{
    ///Specifies all of the attributes associated with a volume. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY"></a><a
    ///id="gpt_basic_data_attribute_read_only"></a><dl> <dt><b>GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY</b></dt>
    ///<dt>0x1000000000000000</dt> </dl> </td> <td width="60%"> The volume is read-only. </td> </tr> <tr> <td
    ///width="40%"><a id="GPT_BASIC_DATA_ATTRIBUTE_SHADOW_COPY"></a><a
    ///id="gpt_basic_data_attribute_shadow_copy"></a><dl> <dt><b>GPT_BASIC_DATA_ATTRIBUTE_SHADOW_COPY</b></dt>
    ///<dt>0x2000000000000000</dt> </dl> </td> <td width="60%"> The volume is a shadow copy of another volume. For more
    ///information, see Volume Shadow Copy Service Overview. </td> </tr> <tr> <td width="40%"><a
    ///id="GPT_BASIC_DATA_ATTRIBUTE_HIDDEN"></a><a id="gpt_basic_data_attribute_hidden"></a><dl>
    ///<dt><b>GPT_BASIC_DATA_ATTRIBUTE_HIDDEN</b></dt> <dt>0x4000000000000000</dt> </dl> </td> <td width="60%"> The
    ///volume is hidden. </td> </tr> <tr> <td width="40%"><a id="GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER"></a><a
    ///id="gpt_basic_data_attribute_no_drive_letter"></a><dl> <dt><b>GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER</b></dt>
    ///<dt>0x8000000000000000</dt> </dl> </td> <td width="60%"> The volume is not assigned a default drive letter. </td>
    ///</tr> </table>
    ulong GptAttributes;
}

///Contains the data that is associated with a transaction notification.
struct TRANSACTION_NOTIFICATION
{
    ///The user-defined, opaque ID for this transaction.
    void*         TransactionKey;
    ///The NOTIFICATION_MASK value for this transaction.
    uint          TransactionNotification;
    ///The latest virtual clock value that is associated with this transaction. See LARGE_INTEGER.
    LARGE_INTEGER TmVirtualClock;
    ///Indicates the number of bytes for the TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT structure that follow this
    ///<b>TRANSACTION_NOTIFICATION</b> structure.
    uint          ArgumentLength;
}

///Indicates the transaction to be recovered. This structure is sent with a recovery notification.
struct TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT
{
    ///The enlistment identifier.
    GUID EnlistmentId;
    ///The transaction identifier, sometimes called the unit of work.
    GUID UOW;
}

struct TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT
{
    GUID TmIdentity;
    uint Flags;
}

struct TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT
{
    uint SavepointId;
}

struct TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT
{
    uint PropagationCookie;
    GUID UOW;
    GUID TmIdentity;
    uint BufferLength;
}

struct TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT
{
    uint MarshalCookie;
    GUID UOW;
}

struct KCRM_MARSHAL_HEADER
{
    uint VersionMajor;
    uint VersionMinor;
    uint NumProtocols;
    uint Unused;
}

struct KCRM_TRANSACTION_BLOB
{
    GUID       UOW;
    GUID       TmIdentity;
    uint       IsolationLevel;
    uint       IsolationFlags;
    uint       Timeout;
    ushort[64] Description;
}

struct KCRM_PROTOCOL_BLOB
{
    GUID ProtocolId;
    uint StaticInfoLength;
    uint TransactionIdInfoLength;
    uint Unused1;
    uint Unused2;
}

struct DISK_SPACE_INFORMATION
{
    ulong ActualTotalAllocationUnits;
    ulong ActualAvailableAllocationUnits;
    ulong ActualPoolUnavailableAllocationUnits;
    ulong CallerTotalAllocationUnits;
    ulong CallerAvailableAllocationUnits;
    ulong CallerPoolUnavailableAllocationUnits;
    ulong UsedAllocationUnits;
    ulong TotalReservedAllocationUnits;
    ulong VolumeStorageReserveAllocationUnits;
    ulong AvailableCommittedAllocationUnits;
    ulong PoolAvailableAllocationUnits;
    uint  SectorsPerAllocationUnit;
    uint  BytesPerSector;
}

///Contains attribute information for a file or directory. The GetFileAttributesEx function uses this structure.
struct WIN32_FILE_ATTRIBUTE_DATA
{
    ///The file system attribute information for a file or directory. For possible values and their descriptions, see
    ///File Attribute Constants.
    uint     dwFileAttributes;
    ///A FILETIME structure that specifies when the file or directory is created. If the underlying file system does not
    ///support creation time, this member is zero.
    FILETIME ftCreationTime;
    ///A FILETIME structure. For a file, the structure specifies when the file is last read from or written to. For a
    ///directory, the structure specifies when the directory is created. For both files and directories, the specified
    ///date is correct, but the time of day is always set to midnight. If the underlying file system does not support
    ///last access time, this member is zero.
    FILETIME ftLastAccessTime;
    ///A FILETIME structure. For a file, the structure specifies when the file is last written to. For a directory, the
    ///structure specifies when the directory is created. If the underlying file system does not support last write
    ///time, this member is zero.
    FILETIME ftLastWriteTime;
    ///The high-order <b>DWORD</b> of the file size. This member does not have a meaning for directories.
    uint     nFileSizeHigh;
    ///The low-order <b>DWORD</b> of the file size. This member does not have a meaning for directories.
    uint     nFileSizeLow;
}

///Contains information that the GetFileInformationByHandle function retrieves.
struct BY_HANDLE_FILE_INFORMATION
{
    ///The file attributes. For possible values and their descriptions, see File Attribute Constants.
    uint     dwFileAttributes;
    ///A FILETIME structure that specifies when a file or directory is created. If the underlying file system does not
    ///support creation time, this member is zero (0).
    FILETIME ftCreationTime;
    ///A FILETIME structure. For a file, the structure specifies the last time that a file is read from or written to.
    ///For a directory, the structure specifies when the directory is created. For both files and directories, the
    ///specified date is correct, but the time of day is always set to midnight. If the underlying file system does not
    ///support the last access time, this member is zero (0).
    FILETIME ftLastAccessTime;
    ///A FILETIME structure. For a file, the structure specifies the last time that a file is written to. For a
    ///directory, the structure specifies when the directory is created. If the underlying file system does not support
    ///the last write time, this member is zero (0).
    FILETIME ftLastWriteTime;
    ///The serial number of the volume that contains a file.
    uint     dwVolumeSerialNumber;
    ///The high-order part of the file size.
    uint     nFileSizeHigh;
    ///The low-order part of the file size.
    uint     nFileSizeLow;
    ///The number of links to this file. For the FAT file system this member is always 1. For the NTFS file system, it
    ///can be more than 1.
    uint     nNumberOfLinks;
    ///The high-order part of a unique identifier that is associated with a file. For more information, see
    ///<b>nFileIndexLow</b>.
    uint     nFileIndexHigh;
    ///The low-order part of a unique identifier that is associated with a file. The identifier (low and high parts) and
    ///the volume serial number uniquely identify a file on a single computer. To determine whether two open handles
    ///represent the same file, combine the identifier and the volume serial number for each file and compare them. The
    ///ReFS file system, introduced with Windows Server 2012, includes 128-bit file identifiers. To retrieve the 128-bit
    ///file identifier use the GetFileInformationByHandleEx function with <b>FileIdInfo</b> to retrieve the FILE_ID_INFO
    ///structure. The 64-bit identifier in this structure is not guaranteed to be unique on ReFS.
    uint     nFileIndexLow;
}

///Contains optional extended parameters for CreateFile2.
struct CREATEFILE2_EXTENDED_PARAMETERS
{
    ///Contains the size of this structure, <code>sizeof(CREATEFILE2_EXTENDED_PARAMETERS)</code>.
    uint                 dwSize;
    ///The file or device attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default value for
    ///files. This parameter can include any combination of the available file attributes (<b>FILE_ATTRIBUTE_*</b>). All
    ///other file attributes override <b>FILE_ATTRIBUTE_NORMAL</b>. <div class="alert"><b>Note</b> When CreateFile2
    ///opens an existing file, it generally combines the file flags with the file attributes of the existing file, and
    ///ignores any file attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in
    ///Creating and Opening Files.</div> <div> </div> Some of the following file attributes and flags may only apply to
    ///files and not necessarily all other types of devices that CreateFile2 can open. For additional information, see
    ///the Remarks section of the CreateFile2 reference page and Creating and Opening Files. For more advanced access to
    ///file attributes, see SetFileAttributes. For a complete list of all file attributes with their values and
    ///descriptions, see File Attribute Constants. <table> <tr> <th>Attribute</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
    ///<dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt> <dt>32 (0x20)</dt> </dl> </td> <td width="60%"> The file should be
    ///archived. Applications use this attribute to mark files for backup or removal. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_ATTRIBUTE_ENCRYPTED"></a><a id="file_attribute_encrypted"></a><dl>
    ///<dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt> <dt>16384 (0x4000)</dt> </dl> </td> <td width="60%"> The file or
    ///directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory, this
    ///means that encryption is the default for newly created files and subdirectories. For more information, see File
    ///Encryption. This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified. This flag is not supported
    ///on Home, Home Premium, Starter, or ARM editions of Windows. This flag is not supported when called from a Windows
    ///Store app. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a
    ///id="file_attribute_hidden"></a><dl> <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt> <dt>2 (0x2)</dt> </dl> </td> <td
    ///width="60%"> The file is hidden. Do not include it in an ordinary directory listing. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_ATTRIBUTE_INTEGRITY_STREAM"></a><a id="file_attribute_integrity_stream"></a><dl>
    ///<dt><b>FILE_ATTRIBUTE_INTEGRITY_STREAM</b></dt> <dt>32768 (0x8000)</dt> </dl> </td> <td width="60%"> A file or
    ///directory that is configured with integrity. For a file, all data streams in the file have integrity. For a
    ///directory, integrity is the default for newly created files and subdirectories, unless the caller specifies
    ///otherwise. This flag is only supported on the ReFS file system. </td> </tr> <tr> <td width="40%"><a
    ///id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl> <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
    ///<dt>128 (0x80)</dt> </dl> </td> <td width="60%"> The file does not have other attributes set. This attribute is
    ///valid only if used alone. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a
    ///id="file_attribute_offline"></a><dl> <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt> <dt>4096 (0x1000)</dt> </dl> </td>
    ///<td width="60%"> The data of a file is not immediately available. This attribute indicates that file data is
    ///physically moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage
    ///management software. Applications should not arbitrarily change this attribute. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
    ///<dt><b>FILE_ATTRIBUTE_READONLY</b></dt> <dt>1 (0x1)</dt> </dl> </td> <td width="60%"> The file is read only.
    ///Applications can read the file, but cannot write to or delete it. </td> </tr> <tr> <td width="40%"><a
    ///id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl> <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt> <dt>4
    ///(0x4)</dt> </dl> </td> <td width="60%"> The file is part of or used exclusively by an operating system. </td>
    ///</tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
    ///<dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt> <dt>256 (0x100)</dt> </dl> </td> <td width="60%"> The file is being used
    ///for temporary storage. For more information, see the Caching Behavior section of this topic. </td> </tr> </table>
    uint                 dwFileAttributes;
    ///This parameter can contain combinations of flags (<b>FILE_FLAG_*</b>) for control of file or device caching
    ///behavior, access modes, and other special-purpose flags. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a id="file_flag_backup_semantics"></a><dl>
    ///<dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt> <dt>0x02000000</dt> </dl> </td> <td width="60%"> The file is being
    ///opened or created for a backup or restore operation. The system ensures that the calling process overrides file
    ///security checks when the process has <b>SE_BACKUP_NAME</b> and <b>SE_RESTORE_NAME</b> privileges. For more
    ///information, see Changing Privileges in a Token. You must set this flag to obtain a handle to a directory. A
    ///directory handle can be passed to some functions instead of a file handle. For more information, see the Remarks
    ///section. </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_DELETE_ON_CLOSE"></a><a
    ///id="file_flag_delete_on_close"></a><dl> <dt><b>FILE_FLAG_DELETE_ON_CLOSE</b></dt> <dt>0x04000000</dt> </dl> </td>
    ///<td width="60%"> The file is to be deleted immediately after all of its handles are closed, which includes the
    ///specified handle and any other open or duplicated handles. If there are existing open handles to a file, the call
    ///fails unless they were all opened with the <b>FILE_SHARE_DELETE</b> share mode. Subsequent open requests for the
    ///file fail, unless the <b>FILE_SHARE_DELETE</b> share mode is specified. </td> </tr> <tr> <td width="40%"><a
    ///id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl> <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
    ///<dt>0x20000000</dt> </dl> </td> <td width="60%"> The file or device is being opened with no system caching for
    ///data reads and writes. This flag does not affect hard disk caching or memory mapped files. There are strict
    ///requirements for successfully working with files opened with CreateFile2 using the <b>FILE_FLAG_NO_BUFFERING</b>
    ///flag, for details see File Buffering. </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_OPEN_NO_RECALL"></a><a
    ///id="file_flag_open_no_recall"></a><dl> <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt> <dt>0x00100000</dt> </dl> </td>
    ///<td width="60%"> The file data is requested, but it should continue to be located in remote storage. It should
    ///not be transported back to local storage. This flag is for use by remote storage systems. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
    ///<dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> Normal reparse
    ///point processing will not occur; CreateFile2 will attempt to open the reparse point. When a file is opened, a
    ///file handle is returned, whether or not the filter that controls the reparse point is operational. This flag
    ///cannot be used with the <b>CREATE_ALWAYS</b> flag. If the file is not a reparse point, then this flag is ignored.
    ///For more information, see the Remarks section. </td> </tr> <tr> <td width="40%"><a
    ///id="FILE_FLAG_OPEN_REQUIRING_OPLOCK"></a><a id="file_flag_open_requiring_oplock"></a><dl>
    ///<dt><b>FILE_FLAG_OPEN_REQUIRING_OPLOCK</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The file is
    ///being opened and an opportunistic lock (oplock) on the file is being requested as a single atomic operation. The
    ///file system checks for oplocks before it performs the create operation, and will fail the create with a last
    ///error code of <b>ERROR_CANNOT_BREAK_OPLOCK</b> if the result would be to break an existing oplock. If you use
    ///this flag and your call to the CreateFile2 function successfully returns, the first operation you should perform
    ///on the file handle is to request an oplock by calling the DeviceIOControl function and then pass in
    ///FSCTL_REQUEST_OPLOCK or one of the other Opportunistic Lock Operations. If you perform other file system
    ///operations with the file handle before requesting an oplock, a deadlock might occur.<div
    ///class="alert"><b>Note</b> You can safely call the CloseHandle function on the file handle without first
    ///requesting an oplock.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a
    ///id="file_flag_overlapped"></a><dl> <dt><b>FILE_FLAG_OVERLAPPED</b></dt> <dt>0x40000000</dt> </dl> </td> <td
    ///width="60%"> The file or device is being opened or created for asynchronous I/O. When subsequent I/O operations
    ///are completed on this handle, the event specified in the OVERLAPPED structure will be set to the signaled state.
    ///If this flag is specified, the file can be used for simultaneous read and write operations. If this flag is not
    ///specified, then I/O operations are serialized, even if the calls to the read and write functions specify an
    ///OVERLAPPED structure. For information about considerations when using a file handle created with this flag, see
    ///the Synchronous and Asynchronous I/O Handles section of this topic. </td> </tr> <tr> <td width="40%"><a
    ///id="FILE_FLAG_POSIX_SEMANTICS"></a><a id="file_flag_posix_semantics"></a><dl>
    ///<dt><b>FILE_FLAG_POSIX_SEMANTICS</b></dt> <dt>0x01000000</dt> </dl> </td> <td width="60%"> Access will occur
    ///according to POSIX rules. This includes allowing multiple files with names, differing only in case, for file
    ///systems that support that naming. Use care when using this option, because files created with this flag may not
    ///be accessible by applications that are written for MS-DOS or 16-bit Windows. </td> </tr> <tr> <td width="40%"><a
    ///id="FILE_FLAG_RANDOM_ACCESS"></a><a id="file_flag_random_access"></a><dl> <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt>
    ///<dt>0x10000000</dt> </dl> </td> <td width="60%"> Access is intended to be random. The system can use this as a
    ///hint to optimize file caching. This flag has no effect if the file system does not support cached I/O and
    ///<b>FILE_FLAG_NO_BUFFERING</b>. For more information, see the Caching Behavior section of this topic. </td> </tr>
    ///<tr> <td width="40%"><a id="FILE_FLAG_SESSION_AWARE"></a><a id="file_flag_session_aware"></a><dl>
    ///<dt><b>FILE_FLAG_SESSION_AWARE</b></dt> <dt>0x00800000</dt> </dl> </td> <td width="60%"> The file or device is
    ///being opened with session awareness. If this flag is not specified, then per-session devices (such as a device
    ///using RemoteFX USB Redirection) cannot be opened by processes running in session 0. This flag has no effect for
    ///callers not in session 0. This flag is supported only on server editions of Windows. <b>Windows Server 2008 R2
    ///and Windows Server 2008: </b>This flag is not supported before Windows Server 2012. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
    ///<dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt> <dt>0x08000000</dt> </dl> </td> <td width="60%"> Access is intended to
    ///be sequential from beginning to end. The system can use this as a hint to optimize file caching. This flag should
    ///not be used if read-behind (that is, backwards scans) will be used. This flag has no effect if the file system
    ///does not support cached I/O and <b>FILE_FLAG_NO_BUFFERING</b>. For more information, see the Caching Behavior
    ///section of this topic. </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_WRITE_THROUGH"></a><a
    ///id="file_flag_write_through"></a><dl> <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt> <dt>0x80000000</dt> </dl> </td> <td
    ///width="60%"> Write operations will not go through any intermediate cache, they will go directly to disk. For
    ///additional information, see the Caching Behavior section of this topic. </td> </tr> </table>
    uint                 dwFileFlags;
    ///The <i>dwSecurityQosFlags</i> parameter specifies SQOS information. For more information, see Impersonation
    ///Levels. <table> <tr> <th>Security flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="SECURITY_ANONYMOUS"></a><a id="security_anonymous"></a><dl> <dt><b>SECURITY_ANONYMOUS</b></dt> </dl> </td>
    ///<td width="60%"> Impersonates a client at the Anonymous impersonation level. </td> </tr> <tr> <td width="40%"><a
    ///id="SECURITY_CONTEXT_TRACKING"></a><a id="security_context_tracking"></a><dl>
    ///<dt><b>SECURITY_CONTEXT_TRACKING</b></dt> </dl> </td> <td width="60%"> The security tracking mode is dynamic. If
    ///this flag is not specified, the security tracking mode is static. </td> </tr> <tr> <td width="40%"><a
    ///id="SECURITY_DELEGATION"></a><a id="security_delegation"></a><dl> <dt><b>SECURITY_DELEGATION</b></dt> </dl> </td>
    ///<td width="60%"> Impersonates a client at the Delegation impersonation level. </td> </tr> <tr> <td width="40%"><a
    ///id="SECURITY_EFFECTIVE_ONLY"></a><a id="security_effective_only"></a><dl> <dt><b>SECURITY_EFFECTIVE_ONLY</b></dt>
    ///</dl> </td> <td width="60%"> Only the enabled aspects of the client's security context are available to the
    ///server. If you do not specify this flag, all aspects of the client's security context are available. This allows
    ///the client to limit the groups and privileges that a server can use while impersonating the client. </td> </tr>
    ///<tr> <td width="40%"><a id="SECURITY_IDENTIFICATION"></a><a id="security_identification"></a><dl>
    ///<dt><b>SECURITY_IDENTIFICATION</b></dt> </dl> </td> <td width="60%"> Impersonates a client at the Identification
    ///impersonation level. </td> </tr> <tr> <td width="40%"><a id="SECURITY_IMPERSONATION"></a><a
    ///id="security_impersonation"></a><dl> <dt><b>SECURITY_IMPERSONATION</b></dt> </dl> </td> <td width="60%">
    ///Impersonate a client at the impersonation level. This is the default behavior if no other flags are specified.
    ///</td> </tr> </table>
    uint                 dwSecurityQosFlags;
    ///A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: an optional
    ///security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child
    ///processes. This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the handle returned by
    ///CreateFile2 cannot be inherited by any child processes the application may create and the file or device
    ///associated with the returned handle gets a default security descriptor. The <b>lpSecurityDescriptor</b> member of
    ///the structure specifies a SECURITY_DESCRIPTOR for a file or device. If this member is <b>NULL</b>, the file or
    ///device associated with the returned handle is assigned a default security descriptor. CreateFile2 ignores the
    ///<b>lpSecurityDescriptor</b> member when opening an existing file or device, but continues to use the
    ///<b>bInheritHandle</b> member. The <b>bInheritHandle</b>member of the structure specifies whether the returned
    ///handle can be inherited. For more information, see the Remarks section of the CreateFile2 topic.
    SECURITY_ATTRIBUTES* lpSecurityAttributes;
    ///A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template file supplies file
    ///attributes and extended attributes for the file that is being created. This parameter can be <b>NULL</b>. When
    ///opening an existing file, CreateFile2 ignores this parameter. When opening a new encrypted file, the file
    ///inherits the discretionary access control list from its parent directory. For additional information, see File
    ///Encryption.
    HANDLE               hTemplateFile;
}

///Contains information about the stream found by the FindFirstStreamW or FindNextStreamW function.
struct WIN32_FIND_STREAM_DATA
{
    ///A LARGE_INTEGER value that specifies the size of the stream, in bytes.
    LARGE_INTEGER StreamSize;
    ///The name of the stream. The string name format is ":<i>streamname</i>:$<i>streamtype</i>".
    ushort[296]   cStreamName;
}

///Contains a certificate.
struct EFS_CERTIFICATE_BLOB
{
    ///A certificate encoding type. This member can be one of the following values. <a id="CRYPT_ASN_ENCODING"></a> <a
    ///id="crypt_asn_encoding"></a>
    uint   dwCertEncodingType;
    ///The number of bytes in the <b>pbData</b> buffer.
    uint   cbData;
    ///The binary certificate. The <b>dwCertEncodingType</b> member specifies the format for this certificate.
    ubyte* pbData;
}

///Contains a certificate hash.
struct EFS_HASH_BLOB
{
    ///The number of bytes in the <b>pbData</b> buffer.
    uint   cbData;
    ///The certificate hash.
    ubyte* pbData;
}

struct EFS_RPC_BLOB
{
    uint   cbData;
    ubyte* pbData;
}

struct EFS_PIN_BLOB
{
    uint   cbPadding;
    uint   cbData;
    ubyte* pbData;
}

struct EFS_KEY_INFO
{
    uint dwVersion;
    uint Entropy;
    uint Algorithm;
    uint KeyLength;
}

struct EFS_COMPATIBILITY_INFO
{
    uint EfsVersion;
}

struct EFS_VERSION_INFO
{
    uint EfsVersion;
    uint SubVersion;
}

struct EFS_DECRYPTION_STATUS_INFO
{
    uint dwDecryptionError;
    uint dwHashOffset;
    uint cbHash;
}

struct EFS_ENCRYPTION_STATUS_INFO
{
    BOOL bHasCurrentKey;
    uint dwEncryptionError;
}

///Contains a certificate and the SID of its owner.
struct ENCRYPTION_CERTIFICATE
{
    ///The length of this structure, in bytes.
    uint cbTotalLength;
    ///The SID of the user who owns the certificate.
    SID* pUserSid;
    ///A pointer to an EFS_CERTIFICATE_BLOB structure.
    EFS_CERTIFICATE_BLOB* pCertBlob;
}

///Contains a certificate hash and display information for the certificate.
struct ENCRYPTION_CERTIFICATE_HASH
{
    ///The length of this structure, in bytes.
    uint           cbTotalLength;
    ///The SID of the user who created the certificate. This member is optional and can be <b>NULL</b>.
    SID*           pUserSid;
    ///A pointer to an EFS_HASH_BLOB structure.
    EFS_HASH_BLOB* pHash;
    ///User-displayable information for the certificate. This is usually the user's common name and universal principal
    ///name (UPN).
    const(wchar)*  lpDisplayInformation;
}

///Contains a list of certificate hashes.
struct ENCRYPTION_CERTIFICATE_HASH_LIST
{
    ///The number of certificate hashes in the list.
    uint nCert_Hash;
    ///A pointer to the first ENCRYPTION_CERTIFICATE_HASH structure in the list.
    ENCRYPTION_CERTIFICATE_HASH** pUsers;
}

///Contains a list of certificates.
struct ENCRYPTION_CERTIFICATE_LIST
{
    ///The number of certificates in the list.
    uint nUsers;
    ///A pointer to the first ENCRYPTION_CERTIFICATE structure in the list.
    ENCRYPTION_CERTIFICATE** pUsers;
}

struct ENCRYPTED_FILE_METADATA_SIGNATURE
{
    uint          dwEfsAccessType;
    ENCRYPTION_CERTIFICATE_HASH_LIST* pCertificatesAdded;
    ENCRYPTION_CERTIFICATE* pEncryptionCertificate;
    EFS_RPC_BLOB* pEfsStreamSignature;
}

struct ENCRYPTION_PROTECTOR
{
    uint          cbTotalLength;
    SID*          pUserSid;
    const(wchar)* lpProtectorDescriptor;
}

struct ENCRYPTION_PROTECTOR_LIST
{
    uint nProtectors;
    ENCRYPTION_PROTECTOR** pProtectors;
}

struct NTMS_ASYNC_IO
{
    GUID   OperationId;
    GUID   EventId;
    uint   dwOperationType;
    uint   dwResult;
    uint   dwAsyncState;
    HANDLE hEvent;
    BOOL   bOnStateChange;
}

struct NTMS_MOUNT_INFORMATION
{
    uint  dwSize;
    void* lpReserved;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_ALLOCATION_INFORMATION</b> structure contains information about the source media pool from which a medium
///was taken.
struct NTMS_ALLOCATION_INFORMATION
{
    ///Size of the structure.
    uint  dwSize;
    void* lpReserved;
    ///Unique identifier of the original source of the media.
    GUID  AllocatedFrom;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_DRIVEINFORMATION</b> structure defines properties specific to a drive object.
struct NTMS_DRIVEINFORMATIONA
{
    ///Number of the drive in the library. This is set zero or one relative the value based on the drive numbering
    ///system of the device. Some changers number drives beginning with zero, and some changers begin with one.
    uint       Number;
    ///State of the drive. This can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="NTMS_DRIVESTATE_BEING_CLEANED"></a><a id="ntms_drivestate_being_cleaned"></a><dl>
    ///<dt><b>NTMS_DRIVESTATE_BEING_CLEANED</b></dt> </dl> </td> <td width="60%"> The drive is being cleaned and is
    ///unavailable. </td> </tr> <tr> <td width="40%"><a id="NTMS_DRIVESTATE_DISMOUNTABLE"></a><a
    ///id="ntms_drivestate_dismountable"></a><dl> <dt><b>NTMS_DRIVESTATE_DISMOUNTABLE</b></dt> </dl> </td> <td
    ///width="60%"> If a library is set for lazy dismounts, the medium might be left in the library's drive on a
    ///dismount. RSM can satisfy mount requests for loaded and dismounted drives. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_DRIVESTATE_DISMOUNTED"></a><a id="ntms_drivestate_dismounted"></a><dl>
    ///<dt><b>NTMS_DRIVESTATE_DISMOUNTED</b></dt> </dl> </td> <td width="60%"> No medium in the drive. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_DRIVESTATE_LOADED"></a><a id="ntms_drivestate_loaded"></a><dl>
    ///<dt><b>NTMS_DRIVESTATE_LOADED</b></dt> </dl> </td> <td width="60%"> The medium is mounted in the drive and is
    ///loaded for read and write access. </td> </tr> <tr> <td width="40%"><a id="NTMS_DRIVESTATE_MOUNTED"></a><a
    ///id="ntms_drivestate_mounted"></a><dl> <dt><b>NTMS_DRIVESTATE_MOUNTED</b></dt> </dl> </td> <td width="60%"> The
    ///medium is mounted in the drive but is not ready for read and write access. This is a temporary state that is used
    ///while a drive is waiting for spindle synchronization or loading tape media into the head mechanism. </td> </tr>
    ///<tr> <td width="40%"><a id="NTMS_DRIVESTATE_UNLOADED"></a><a id="ntms_drivestate_unloaded"></a><dl>
    ///<dt><b>NTMS_DRIVESTATE_UNLOADED</b></dt> </dl> </td> <td width="60%"> The medium has been dismounted by the drive
    ///and is ready to be opened. This state indicates that the spindle has stopped or a tape media has been returned to
    ///the tape cartridge. </td> </tr> </table>
    uint       State;
    ///Unique identifier of the drive type object containing the attributes for the drive.
    GUID       DriveType;
    ///Name of the device used to access the drive. For a tape drive this contains the device name \\.\tape0 or
    ///\\.\tape1. Other devices provide the name of a SCSI disk drive or the root of a file system that currently has
    ///the device mounted (raw, NTFS, FAT and so forth).
    byte[64]   szDeviceName;
    ///Serial number for the drive represented as a string. Devices that do not support serial numbers report NULL for
    ///this member.
    byte[32]   szSerialNumber;
    ///Revision for the drive represented as a string.
    byte[32]   szRevision;
    ///SCSI host adapter to which the drive is connected.
    ushort     ScsiPort;
    ///SCSI bus to which the drive is connected.
    ushort     ScsiBus;
    ///SCSI target ID for the drive.
    ushort     ScsiTarget;
    ///SCSI logical unit ID for the drive.
    ushort     ScsiLun;
    ///Number of times the drive has had a medium mounted to it. If the drive supports the reporting of a unique serial
    ///number, this value is the number of times the drive has been mounted since it was installed. If the drive does
    ///not support the reporting of serial numbers, this member reflects the number of mounts to all of the drives at
    ///that location.
    uint       dwMountCount;
    ///Last time the drive was cleaned.
    SYSTEMTIME LastCleanedTs;
    ///Partition identifier of the medium that is in the drive. If this value is NULL and the drive is found to be full,
    ///the media was loaded by a user and needs to be classified.
    GUID       SavedPartitionId;
    ///Unique identifier of the library that contains the drive.
    GUID       Library;
    ///Reserved.
    GUID       Reserved;
    ///Minimum number of seconds a medium will remain in a drive of a library after a deferred dismount has been
    ///performed. The default is 5 minutes. This member does not apply to stand-alone libraries. This member is
    ///writable.
    uint       dwDeferDismountDelay;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_DRIVEINFORMATION</b> structure defines properties specific to a drive object.
struct NTMS_DRIVEINFORMATIONW
{
    ///Number of the drive in the library. This is set zero or one relative the value based on the drive numbering
    ///system of the device. Some changers number drives beginning with zero, and some changers begin with one.
    uint       Number;
    ///State of the drive. This can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="NTMS_DRIVESTATE_BEING_CLEANED"></a><a id="ntms_drivestate_being_cleaned"></a><dl>
    ///<dt><b>NTMS_DRIVESTATE_BEING_CLEANED</b></dt> </dl> </td> <td width="60%"> The drive is being cleaned and is
    ///unavailable. </td> </tr> <tr> <td width="40%"><a id="NTMS_DRIVESTATE_DISMOUNTABLE"></a><a
    ///id="ntms_drivestate_dismountable"></a><dl> <dt><b>NTMS_DRIVESTATE_DISMOUNTABLE</b></dt> </dl> </td> <td
    ///width="60%"> If a library is set for lazy dismounts, the medium might be left in the library's drive on a
    ///dismount. RSM can satisfy mount requests for loaded and dismounted drives. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_DRIVESTATE_DISMOUNTED"></a><a id="ntms_drivestate_dismounted"></a><dl>
    ///<dt><b>NTMS_DRIVESTATE_DISMOUNTED</b></dt> </dl> </td> <td width="60%"> No medium in the drive. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_DRIVESTATE_LOADED"></a><a id="ntms_drivestate_loaded"></a><dl>
    ///<dt><b>NTMS_DRIVESTATE_LOADED</b></dt> </dl> </td> <td width="60%"> The medium is mounted in the drive and is
    ///loaded for read and write access. </td> </tr> <tr> <td width="40%"><a id="NTMS_DRIVESTATE_MOUNTED"></a><a
    ///id="ntms_drivestate_mounted"></a><dl> <dt><b>NTMS_DRIVESTATE_MOUNTED</b></dt> </dl> </td> <td width="60%"> The
    ///medium is mounted in the drive but is not ready for read and write access. This is a temporary state that is used
    ///while a drive is waiting for spindle synchronization or loading tape media into the head mechanism. </td> </tr>
    ///<tr> <td width="40%"><a id="NTMS_DRIVESTATE_UNLOADED"></a><a id="ntms_drivestate_unloaded"></a><dl>
    ///<dt><b>NTMS_DRIVESTATE_UNLOADED</b></dt> </dl> </td> <td width="60%"> The medium has been dismounted by the drive
    ///and is ready to be opened. This state indicates that the spindle has stopped or a tape media has been returned to
    ///the tape cartridge. </td> </tr> </table>
    uint       State;
    ///Unique identifier of the drive type object containing the attributes for the drive.
    GUID       DriveType;
    ///Name of the device used to access the drive. For a tape drive this contains the device name \\.\tape0 or
    ///\\.\tape1. Other devices provide the name of a SCSI disk drive or the root of a file system that currently has
    ///the device mounted (raw, NTFS, FAT and so forth).
    ushort[64] szDeviceName;
    ///Serial number for the drive represented as a string. Devices that do not support serial numbers report NULL for
    ///this member.
    ushort[32] szSerialNumber;
    ///Revision for the drive represented as a string.
    ushort[32] szRevision;
    ///SCSI host adapter to which the drive is connected.
    ushort     ScsiPort;
    ///SCSI bus to which the drive is connected.
    ushort     ScsiBus;
    ///SCSI target ID for the drive.
    ushort     ScsiTarget;
    ///SCSI logical unit ID for the drive.
    ushort     ScsiLun;
    ///Number of times the drive has had a medium mounted to it. If the drive supports the reporting of a unique serial
    ///number, this value is the number of times the drive has been mounted since it was installed. If the drive does
    ///not support the reporting of serial numbers, this member reflects the number of mounts to all of the drives at
    ///that location.
    uint       dwMountCount;
    ///Last time the drive was cleaned.
    SYSTEMTIME LastCleanedTs;
    ///Partition identifier of the medium that is in the drive. If this value is NULL and the drive is found to be full,
    ///the media was loaded by a user and needs to be classified.
    GUID       SavedPartitionId;
    ///Unique identifier of the library that contains the drive.
    GUID       Library;
    ///Reserved.
    GUID       Reserved;
    ///Minimum number of seconds a medium will remain in a drive of a library after a deferred dismount has been
    ///performed. The default is 5 minutes. This member does not apply to stand-alone libraries. This member is
    ///writable.
    uint       dwDeferDismountDelay;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_LIBRARYINFORMATION</b> structure defines properties specific to a library object.
struct NTMS_LIBRARYINFORMATION
{
    ///Library type object. This can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="NTMS_LIBRARYTYPE_ONLINE"></a><a id="ntms_librarytype_online"></a><dl>
    ///<dt><b>NTMS_LIBRARYTYPE_ONLINE</b></dt> </dl> </td> <td width="60%"> A robotic element that automates the
    ///mounting and dismounting of media into one or more drives. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LIBRARYTYPE_STANDALONE"></a><a id="ntms_librarytype_standalone"></a><dl>
    ///<dt><b>NTMS_LIBRARYTYPE_STANDALONE</b></dt> </dl> </td> <td width="60%"> A stand-alone drive that is modeled as a
    ///library with one drive in RSM. </td> </tr> <tr> <td width="40%"><a id="NTMS_LIBRARYTYPE_OFFLINE"></a><a
    ///id="ntms_librarytype_offline"></a><dl> <dt><b>NTMS_LIBRARYTYPE_OFFLINE</b></dt> </dl> </td> <td width="60%">
    ///Media that is not in a library is in the offline library. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LIBRARYTYPE_UNKNOWN"></a><a id="ntms_librarytype_unknown"></a><dl>
    ///<dt><b>NTMS_LIBRARYTYPE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> Library type cannot be determined. </td>
    ///</tr> </table>
    uint LibraryType;
    ///For each library, this represents the slot that was assigned to the cleaner cartridge. If this member is
    ///<b>NULL</b>, there is no cleaner slot defined for this library.
    GUID CleanerSlot;
    ///Represents a libraries' default or preferred cleaner slot. If <b>NULL</b>, there is not a preferred slot.
    GUID CleanerSlotDefault;
    ///Used by drives that require cleaning under robotics control. If <b>TRUE</b>, automatic drive cleaning operations
    ///are enabled.
    BOOL LibrarySupportsDriveCleaning;
    ///Returns <b>TRUE</b> if a bar code reader is installed in a library; otherwise returns <b>FALSE</b>.
    BOOL BarCodeReaderInstalled;
    ///Default or user-selected method for performing inventory of this library. (This member is writable.) This can be
    ///one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="NTMS_INVENTORY_FAST"></a><a id="ntms_inventory_fast"></a><dl> <dt><b>NTMS_INVENTORY_FAST</b></dt> </dl> </td>
    ///<td width="60%"> If the library has a bar-code reader installed, this value causes a bar-code inventory to be
    ///performed. If the library does not have a bar-code reader, this flag causes a differential inventory to be
    ///performed (slots which transitioned from empty to full are classified). </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_INVENTORY_OMID"></a><a id="ntms_inventory_omid"></a><dl> <dt><b>NTMS_INVENTORY_OMID</b></dt> </dl> </td>
    ///<td width="60%"> A full inventory involves mounting each side in a library and reading the on-media
    ///identification from the media. This type of inventory can be very time consuming for some library units. </td>
    ///</tr> <tr> <td width="40%"><a id="NTMS_INVENTORY_NONE"></a><a id="ntms_inventory_none"></a><dl>
    ///<dt><b>NTMS_INVENTORY_NONE</b></dt> </dl> </td> <td width="60%"> After the library door is closed, no inventory
    ///is performed. Inventory might be required if a mount label-check fails. </td> </tr> </table>
    uint InventoryMethod;
    ///Number of uses remaining on the cleaner in the library. This member is zero if no cleaner is present or if the
    ///library does not support cleaning.
    uint dwCleanerUsesRemaining;
    ///Number of the first drive in the library.
    uint FirstDriveNumber;
    ///Number of drives in the library.
    uint dwNumberOfDrives;
    ///Number of the first slot in the library.
    uint FirstSlotNumber;
    ///Number of slots in the library.
    uint dwNumberOfSlots;
    ///Number of the first access door in the library.
    uint FirstDoorNumber;
    ///Number of access doors in the library.
    uint dwNumberOfDoors;
    ///Number of the first insert/eject port in the library.
    uint FirstPortNumber;
    ///Number of insert/eject ports in the library.
    uint dwNumberOfPorts;
    ///Number of the first changer in the library.
    uint FirstChangerNumber;
    ///Number of changers in the library.
    uint dwNumberOfChangers;
    ///Number of media in the online or offline library.
    uint dwNumberOfMedia;
    ///Number of media types supported by the library.
    uint dwNumberOfMediaTypes;
    ///Number of current library requests.
    uint dwNumberOfLibRequests;
    ///Reserved.
    GUID Reserved;
    ///If this member is <b>TRUE</b>, a full inventory will be performed if a mount fails. The failure may be either
    ///hardware or label mismatch. For ATAPI CD libraries, this parameter cannot be disabled. The default is
    ///<b>TRUE</b>. Large library owners should disable this feature.
    BOOL AutoRecovery;
    ///This member can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="NTMS_LIBRARYFLAG_FIXEDOFFLINE"></a><a id="ntms_libraryflag_fixedoffline"></a><dl>
    ///<dt><b>NTMS_LIBRARYFLAG_FIXEDOFFLINE</b></dt> </dl> </td> <td width="60%"> The library is an offline library, not
    ///a library that is not present. </td> </tr> <tr> <td width="40%"><a id="NTMS_LIBRARYFLAG_CLEANERPRESENT"></a><a
    ///id="ntms_libraryflag_cleanerpresent"></a><dl> <dt><b>NTMS_LIBRARYFLAG_CLEANERPRESENT</b></dt> </dl> </td> <td
    ///width="60%"> A cleaner is present in the changer. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LIBRARYFLAG_IGNORECLEANERUSESREMAINING"></a><a id="ntms_libraryflag_ignorecleanerusesremaining"></a><dl>
    ///<dt><b>NTMS_LIBRARYFLAG_IGNORECLEANERUSESREMAINING</b></dt> </dl> </td> <td width="60%"> The cleaner cartridge
    ///will be used until it no longer cleans the drive, instead of keeping track of the number of cleanings left. Do
    ///not set this flag directly. It is set or cleared based on the value of <b>dwCleanerUsesRemaining</b>. It is set
    ///if <b>dwCleanerUsesRemaining</b> is 0xFFFFFFFF, and cleared otherwise. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LIBRARYFLAG_RECOGNIZECLEANERBARCODE"></a><a id="ntms_libraryflag_recognizecleanerbarcode"></a><dl>
    ///<dt><b>NTMS_LIBRARYFLAG_RECOGNIZECLEANERBARCODE</b></dt> </dl> </td> <td width="60%"> Treat barcoded cartridges
    ///that have CLN as a prefix as cleaner cartridges, instead of mounting them in the drive to identify them. </td>
    ///</tr> </table>
    uint dwFlags;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_CHANGERINFORMATION</b> structure defines properties specific to a robotic changer object.
struct NTMS_CHANGERINFORMATIONA
{
    ///Number of the changer within the library.
    uint     Number;
    ///Identifier of the changer type of this changer.
    GUID     ChangerType;
    ///Serial number for the changer represented as a string. Devices that do not support serial numbers report
    ///<b>NULL</b> for this member.
    byte[32] szSerialNumber;
    ///Revision for the changer, represented as a string.
    byte[32] szRevision;
    ///Name of the device used to access the changer.
    byte[64] szDeviceName;
    ///SCSI host adapter to which the changer is connected.
    ushort   ScsiPort;
    ///SCSI bus to which the changer is connected.
    ushort   ScsiBus;
    ///SCSI target ID for the changer.
    ushort   ScsiTarget;
    ///SCSI logical unit ID for the changer.
    ushort   ScsiLun;
    ///Unique identifier of the library that contains the changer.
    GUID     Library;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_CHANGERINFORMATION</b> structure defines properties specific to a robotic changer object.
struct NTMS_CHANGERINFORMATIONW
{
    ///Number of the changer within the library.
    uint       Number;
    ///Identifier of the changer type of this changer.
    GUID       ChangerType;
    ///Serial number for the changer represented as a string. Devices that do not support serial numbers report
    ///<b>NULL</b> for this member.
    ushort[32] szSerialNumber;
    ///Revision for the changer, represented as a string.
    ushort[32] szRevision;
    ///Name of the device used to access the changer.
    ushort[64] szDeviceName;
    ///SCSI host adapter to which the changer is connected.
    ushort     ScsiPort;
    ///SCSI bus to which the changer is connected.
    ushort     ScsiBus;
    ///SCSI target ID for the changer.
    ushort     ScsiTarget;
    ///SCSI logical unit ID for the changer.
    ushort     ScsiLun;
    ///Unique identifier of the library that contains the changer.
    GUID       Library;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_STORAGESLOTINFORMATION</b> structure defines properties specific to a storage slot object.
struct NTMS_STORAGESLOTINFORMATION
{
    ///Number of the slot in the library.
    uint Number;
    ///Current state of the slot. This can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="NTMS_SLOTSTATE_EMPTY"></a><a id="ntms_slotstate_empty"></a><dl>
    ///<dt><b>NTMS_SLOTSTATE_EMPTY</b></dt> </dl> </td> <td width="60%"> Slot is present, but does not contain a piece
    ///of physical media. </td> </tr> <tr> <td width="40%"><a id="NTMS_SLOTSTATE_FULL"></a><a
    ///id="ntms_slotstate_full"></a><dl> <dt><b>NTMS_SLOTSTATE_FULL</b></dt> </dl> </td> <td width="60%"> Slot is
    ///present and contains a piece of physical media. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_SLOTSTATE_NOTPRESENT"></a><a id="ntms_slotstate_notpresent"></a><dl>
    ///<dt><b>NTMS_SLOTSTATE_NOTPRESENT</b></dt> </dl> </td> <td width="60%"> Slot is not present. If the library
    ///contains magazines, this value is reported for each slot when the associated magazine is missing. </td> </tr>
    ///<tr> <td width="40%"><a id="NTMS_SLOTSTATE_UNKNOWN"></a><a id="ntms_slotstate_unknown"></a><dl>
    ///<dt><b>NTMS_SLOTSTATE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> Slot state cannot be determined. </td> </tr>
    ///<tr> <td width="40%"><a id="NTMS_SLOTSTATE_NEEDSINVENTORY"></a><a id="ntms_slotstate_needsinventory"></a><dl>
    ///<dt><b>NTMS_SLOTSTATE_NEEDSINVENTORY</b></dt> </dl> </td> <td width="60%"> Slot needs inventory. </td> </tr>
    ///</table>
    uint State;
    ///Library that contains the slot.
    GUID Library;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_IEDOORINFORMATION</b> structure defines properties specific to an insert/eject door object.
struct NTMS_IEDOORINFORMATION
{
    ///Number of the door in the library. Typically, libraries have one door.
    uint   Number;
    ///State of the door. This can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="NTMS_DOORSTATE_CLOSED"></a><a id="ntms_doorstate_closed"></a><dl>
    ///<dt><b>NTMS_DOORSTATE_CLOSED</b></dt> </dl> </td> <td width="60%"> Library door is closed. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_DOORSTATE_OPEN"></a><a id="ntms_doorstate_open"></a><dl>
    ///<dt><b>NTMS_DOORSTATE_OPEN</b></dt> </dl> </td> <td width="60%"> Library door is open. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_DOORSTATE_UNKNOWN"></a><a id="ntms_doorstate_unknown"></a><dl>
    ///<dt><b>NTMS_DOORSTATE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> State of the library is unknown. </td> </tr>
    ///</table>
    uint   State;
    ///Maximum number of seconds the door is to remain open. Valid values are between 0-65,535 seconds This member is
    ///writable.
    ushort MaxOpenSecs;
    ///Library that contains this door.
    GUID   Library;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_IEPORTINFORMATION</b> structure defines properties specific to an insert/eject port object.
struct NTMS_IEPORTINFORMATION
{
    ///Library port number.
    uint   Number;
    ///Full/Empty state of the NTMS_IEPORT object. This can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_PORTCONTENT_FULL"></a><a
    ///id="ntms_portcontent_full"></a><dl> <dt><b>NTMS_PORTCONTENT_FULL</b></dt> </dl> </td> <td width="60%"> Port is
    ///full. </td> </tr> <tr> <td width="40%"><a id="NTMS_PORTCONTENT_EMPTY"></a><a id="ntms_portcontent_empty"></a><dl>
    ///<dt><b>NTMS_PORTCONTENT_EMPTY</b></dt> </dl> </td> <td width="60%"> Port is empty. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_PORTCONTENT_UNKNOWN"></a><a id="ntms_portcontent_unknown"></a><dl>
    ///<dt><b>NTMS_PORTCONTENT_UNKNOWN</b></dt> </dl> </td> <td width="60%"> Content of port is not known. </td> </tr>
    ///</table>
    uint   Content;
    ///Position of the NTMS_IEPORT object. This can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_PORTPOSITION_EXTENDED"></a><a
    ///id="ntms_portposition_extended"></a><dl> <dt><b>NTMS_PORTPOSITION_EXTENDED</b></dt> </dl> </td> <td width="60%">
    ///Port is extended. </td> </tr> <tr> <td width="40%"><a id="NTMS_PORTPOSITION_RETRACTED"></a><a
    ///id="ntms_portposition_retracted"></a><dl> <dt><b>NTMS_PORTPOSITION_RETRACTED</b></dt> </dl> </td> <td
    ///width="60%"> Port is retracted. </td> </tr> <tr> <td width="40%"><a id="NTMS_PORTPOSITION_UNKNOWN"></a><a
    ///id="ntms_portposition_unknown"></a><dl> <dt><b>NTMS_PORTPOSITION_UNKNOWN</b></dt> </dl> </td> <td width="60%">
    ///Port position is unknown. </td> </tr> </table>
    uint   Position;
    ///Maximum number of seconds the port is allowed to remain open before an operator request is issued. Valid values
    ///are between 0 and 65,535 seconds. This member is writable.
    ushort MaxExtendSecs;
    ///Library that contains the port.
    GUID   Library;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_PMIDINFORMATION</b> structure defines the properties specific to a physical media object.
struct NTMS_PMIDINFORMATIONA
{
    ///Unique ID of the library in which the media is contained.
    GUID     CurrentLibrary;
    ///Unique ID of the media pool to which the media is assigned.
    GUID     MediaPool;
    ///Unique ID of the physical location object for the media.
    GUID     Location;
    ///Current location type of a piece of physical media. The value of this member can be set to NTMS_STORAGESLOT,
    ///NTMS_DRIVE, NTMS_IEPORT. (Offline media are in slots.)
    uint     LocationType;
    ///Unique ID of a media type object.
    GUID     MediaType;
    ///Unique ID of the library storage slot in which media is stored.
    GUID     HomeSlot;
    ///String that matches the bar-code value on a bar-code label of a piece of physical media.
    byte[64] szBarCode;
    ///Current state of the bar code. This can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_BARCODESTATE_OK"></a><a
    ///id="ntms_barcodestate_ok"></a><dl> <dt><b>NTMS_BARCODESTATE_OK</b></dt> </dl> </td> <td width="60%"> The media
    ///has a bar code and it is readable. </td> </tr> <tr> <td width="40%"><a id="NTMS_BARCODESTATE_UNREADABLE"></a><a
    ///id="ntms_barcodestate_unreadable"></a><dl> <dt><b>NTMS_BARCODESTATE_UNREADABLE</b></dt> </dl> </td> <td
    ///width="60%"> The media either does not have a bar code or the bar code is unreadable. </td> </tr> </table>
    uint     BarCodeState;
    ///Sequential number assigned to the specified medium as a human-readable value that must be transcribed by a user
    ///on the medium so that the medium can be located in an offline library.
    byte[32] szSequenceNumber;
    ///Current state for the piece of physical media. This can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_MEDIASTATE_IDLE"></a><a
    ///id="ntms_mediastate_idle"></a><dl> <dt><b>NTMS_MEDIASTATE_IDLE</b></dt> </dl> </td> <td width="60%"> The media is
    ///in a slot in the library, in a drive dismounted, or in an offline library. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_MEDIASTATE_INUSE"></a><a id="ntms_mediastate_inuse"></a><dl> <dt><b>NTMS_MEDIASTATE_INUSE</b></dt> </dl>
    ///</td> <td width="60%"> The media is marked as in use as soon as a request for an operation is successfully made
    ///to RSM. </td> </tr> <tr> <td width="40%"><a id="NTMS_MEDIASTATE_LOADED"></a><a
    ///id="ntms_mediastate_loaded"></a><dl> <dt><b>NTMS_MEDIASTATE_LOADED</b></dt> </dl> </td> <td width="60%"> The
    ///state of the media when RSM has determined that the media is available for reading and writing. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_MEDIASTATE_MOUNTED"></a><a id="ntms_mediastate_mounted"></a><dl>
    ///<dt><b>NTMS_MEDIASTATE_MOUNTED</b></dt> </dl> </td> <td width="60%"> The state of a piece of physical media when
    ///the media is placed in a drive. </td> </tr> <tr> <td width="40%"><a id="NTMS_MEDIASTATE_OP_ERROR"></a><a
    ///id="ntms_mediastate_op_error"></a><dl> <dt><b>NTMS_MEDIASTATE_OP_ERROR</b></dt> </dl> </td> <td width="60%"> The
    ///physical media is in an error state that is recoverable. No operator intervention is required. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_MEDIASTATE_UNLOADED"></a><a id="ntms_mediastate_unloaded"></a><dl>
    ///<dt><b>NTMS_MEDIASTATE_UNLOADED</b></dt> </dl> </td> <td width="60%"> The state of the media when it is ready to
    ///be removed from a drive. The drive state, DISMOUNTABLE, also indicates that a drive can be removed at any time.
    ///</td> </tr> <tr> <td width="40%"><a id="NTMS_MEDIASTATE_OPREQ"></a><a id="ntms_mediastate_opreq"></a><dl>
    ///<dt><b>NTMS_MEDIASTATE_OPREQ</b></dt> </dl> </td> <td width="60%"> Media is waiting for operator request. </td>
    ///</tr> </table>
    uint     MediaState;
    ///Number of sides on the medium.
    uint     dwNumberOfPartitions;
    ///SCSI media type code.
    uint     dwMediaTypeCode;
    ///SCSI density code.
    uint     dwDensityCode;
    ///Globally unique ID of the side of the media that is currently mounted.
    GUID     MountedPartition;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_PMIDINFORMATION</b> structure defines the properties specific to a physical media object.
struct NTMS_PMIDINFORMATIONW
{
    ///Unique ID of the library in which the media is contained.
    GUID       CurrentLibrary;
    ///Unique ID of the media pool to which the media is assigned.
    GUID       MediaPool;
    ///Unique ID of the physical location object for the media.
    GUID       Location;
    ///Current location type of a piece of physical media. The value of this member can be set to NTMS_STORAGESLOT,
    ///NTMS_DRIVE, NTMS_IEPORT. (Offline media are in slots.)
    uint       LocationType;
    ///Unique ID of a media type object.
    GUID       MediaType;
    ///Unique ID of the library storage slot in which media is stored.
    GUID       HomeSlot;
    ///String that matches the bar-code value on a bar-code label of a piece of physical media.
    ushort[64] szBarCode;
    ///Current state of the bar code. This can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_BARCODESTATE_OK"></a><a
    ///id="ntms_barcodestate_ok"></a><dl> <dt><b>NTMS_BARCODESTATE_OK</b></dt> </dl> </td> <td width="60%"> The media
    ///has a bar code and it is readable. </td> </tr> <tr> <td width="40%"><a id="NTMS_BARCODESTATE_UNREADABLE"></a><a
    ///id="ntms_barcodestate_unreadable"></a><dl> <dt><b>NTMS_BARCODESTATE_UNREADABLE</b></dt> </dl> </td> <td
    ///width="60%"> The media either does not have a bar code or the bar code is unreadable. </td> </tr> </table>
    uint       BarCodeState;
    ///Sequential number assigned to the specified medium as a human-readable value that must be transcribed by a user
    ///on the medium so that the medium can be located in an offline library.
    ushort[32] szSequenceNumber;
    ///Current state for the piece of physical media. This can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_MEDIASTATE_IDLE"></a><a
    ///id="ntms_mediastate_idle"></a><dl> <dt><b>NTMS_MEDIASTATE_IDLE</b></dt> </dl> </td> <td width="60%"> The media is
    ///in a slot in the library, in a drive dismounted, or in an offline library. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_MEDIASTATE_INUSE"></a><a id="ntms_mediastate_inuse"></a><dl> <dt><b>NTMS_MEDIASTATE_INUSE</b></dt> </dl>
    ///</td> <td width="60%"> The media is marked as in use as soon as a request for an operation is successfully made
    ///to RSM. </td> </tr> <tr> <td width="40%"><a id="NTMS_MEDIASTATE_LOADED"></a><a
    ///id="ntms_mediastate_loaded"></a><dl> <dt><b>NTMS_MEDIASTATE_LOADED</b></dt> </dl> </td> <td width="60%"> The
    ///state of the media when RSM has determined that the media is available for reading and writing. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_MEDIASTATE_MOUNTED"></a><a id="ntms_mediastate_mounted"></a><dl>
    ///<dt><b>NTMS_MEDIASTATE_MOUNTED</b></dt> </dl> </td> <td width="60%"> The state of a piece of physical media when
    ///the media is placed in a drive. </td> </tr> <tr> <td width="40%"><a id="NTMS_MEDIASTATE_OP_ERROR"></a><a
    ///id="ntms_mediastate_op_error"></a><dl> <dt><b>NTMS_MEDIASTATE_OP_ERROR</b></dt> </dl> </td> <td width="60%"> The
    ///physical media is in an error state that is recoverable. No operator intervention is required. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_MEDIASTATE_UNLOADED"></a><a id="ntms_mediastate_unloaded"></a><dl>
    ///<dt><b>NTMS_MEDIASTATE_UNLOADED</b></dt> </dl> </td> <td width="60%"> The state of the media when it is ready to
    ///be removed from a drive. The drive state, DISMOUNTABLE, also indicates that a drive can be removed at any time.
    ///</td> </tr> <tr> <td width="40%"><a id="NTMS_MEDIASTATE_OPREQ"></a><a id="ntms_mediastate_opreq"></a><dl>
    ///<dt><b>NTMS_MEDIASTATE_OPREQ</b></dt> </dl> </td> <td width="60%"> Media is waiting for operator request. </td>
    ///</tr> </table>
    uint       MediaState;
    ///Number of sides on the medium.
    uint       dwNumberOfPartitions;
    ///SCSI media type code.
    uint       dwMediaTypeCode;
    ///SCSI density code.
    uint       dwDensityCode;
    ///Globally unique ID of the side of the media that is currently mounted.
    GUID       MountedPartition;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_LMIDINFORMATION</b> structure defines the properties specific to a logical media object.
struct NTMS_LMIDINFORMATION
{
    ///Unique identifier of the media pool that contains the logical media.
    GUID MediaPool;
    ///Number of sides in the media object.
    uint dwNumberOfPartitions;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_PARTITIONINFORMATION</b> structure defines the properties specific to the side object.
struct NTMS_PARTITIONINFORMATIONA
{
    ///Unique physical media identifier for the medium that contains this side.
    GUID          PhysicalMedia;
    ///Unique logical media identifier (LMID) for a piece of logical media that contains this side. This parameter is a
    ///<b>NULL</b> if the side is not allocated.
    GUID          LogicalMedia;
    ///Side life cycle information. This can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_PARTSTATE_ALLOCATED"></a><a
    ///id="ntms_partstate_allocated"></a><dl> <dt><b>NTMS_PARTSTATE_ALLOCATED</b></dt> </dl> </td> <td width="60%"> The
    ///media has been allocated to an application. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_PARTSTATE_AVAILABLE"></a><a id="ntms_partstate_available"></a><dl>
    ///<dt><b>NTMS_PARTSTATE_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The media is available to be allocated.
    ///</td> </tr> <tr> <td width="40%"><a id="NTMS_PARTSTATE_COMPLETE"></a><a id="ntms_partstate_complete"></a><dl>
    ///<dt><b>NTMS_PARTSTATE_COMPLETE</b></dt> </dl> </td> <td width="60%"> The media has been completely written and
    ///marked as complete by an application. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_PARTSTATE_DECOMMISIONED"></a><a id="ntms_partstate_decommisioned"></a><dl>
    ///<dt><b>NTMS_PARTSTATE_DECOMMISIONED</b></dt> </dl> </td> <td width="60%"> The media is unsuitable for data
    ///storage and is no longer usable. </td> </tr> <tr> <td width="40%"><a id="NTMS_PARTSTATE_INCOMPATIBLE"></a><a
    ///id="ntms_partstate_incompatible"></a><dl> <dt><b>NTMS_PARTSTATE_INCOMPATIBLE</b></dt> </dl> </td> <td
    ///width="60%"> The media has been found to be and marked as incompatible with the drive. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_PARTSTATE_FOREIGN"></a><a id="ntms_partstate_foreign"></a><dl>
    ///<dt><b>NTMS_PARTSTATE_FOREIGN</b></dt> </dl> </td> <td width="60%"> The media is in a unrecognized pool. </td>
    ///</tr> <tr> <td width="40%"><a id="NTMS_PARTSTATE_IMPORT"></a><a id="ntms_partstate_import"></a><dl>
    ///<dt><b>NTMS_PARTSTATE_IMPORT</b></dt> </dl> </td> <td width="60%"> The media is in the import pool. </td> </tr>
    ///<tr> <td width="40%"><a id="NTMS_PARTSTATE_UNPREPARED"></a><a id="ntms_partstate_unprepared"></a><dl>
    ///<dt><b>NTMS_PARTSTATE_UNPREPARED</b></dt> </dl> </td> <td width="60%"> The media is waiting for a free label to
    ///be applied. </td> </tr> <tr> <td width="40%"><a id="NTMS_PARTSTATE_RESERVED"></a><a
    ///id="ntms_partstate_reserved"></a><dl> <dt><b>NTMS_PARTSTATE_RESERVED</b></dt> </dl> </td> <td width="60%"> The
    ///side has been reserved by the AllocateNtmsMedia function with the <i>dwOption</i> parameter set to
    ///NTMS_ALLOCATE_NEW. </td> </tr> </table>
    uint          State;
    ///Zero-relative value which indicates which side of a multi-sided media this is. For single-sided media, such as
    ///tape, this value is always zero. For dual-sided media one NTMS_PARITIONINFORMATION record has this property set
    ///to zero - the "A" side - and a second NTMS_PARTITIONINFORMATION record has it set to 1 - the "B" side.
    ushort        Side;
    ///Length of the label ID string of the on-media identifier.
    uint          dwOmidLabelIdLength;
    ///Label ID unique identifier of the on-media identifier.
    ubyte[255]    OmidLabelId;
    ///Label type of the on-media identifier.
    byte[64]      szOmidLabelType;
    ///Label information of the on-media identifier.
    byte[256]     szOmidLabelInfo;
    ///Number of times this media has been mounted into a drive. This is initialized to zero when the objects are
    ///created in the database.
    uint          dwMountCount;
    ///Number of times this media has been allocated.
    uint          dwAllocateCount;
    ///Number bytes of storage available on this side.
    LARGE_INTEGER Capacity;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_PARTITIONINFORMATION</b> structure defines the properties specific to the side object.
struct NTMS_PARTITIONINFORMATIONW
{
    ///Unique physical media identifier for the medium that contains this side.
    GUID          PhysicalMedia;
    ///Unique logical media identifier (LMID) for a piece of logical media that contains this side. This parameter is a
    ///<b>NULL</b> if the side is not allocated.
    GUID          LogicalMedia;
    ///Side life cycle information. This can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_PARTSTATE_ALLOCATED"></a><a
    ///id="ntms_partstate_allocated"></a><dl> <dt><b>NTMS_PARTSTATE_ALLOCATED</b></dt> </dl> </td> <td width="60%"> The
    ///media has been allocated to an application. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_PARTSTATE_AVAILABLE"></a><a id="ntms_partstate_available"></a><dl>
    ///<dt><b>NTMS_PARTSTATE_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The media is available to be allocated.
    ///</td> </tr> <tr> <td width="40%"><a id="NTMS_PARTSTATE_COMPLETE"></a><a id="ntms_partstate_complete"></a><dl>
    ///<dt><b>NTMS_PARTSTATE_COMPLETE</b></dt> </dl> </td> <td width="60%"> The media has been completely written and
    ///marked as complete by an application. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_PARTSTATE_DECOMMISIONED"></a><a id="ntms_partstate_decommisioned"></a><dl>
    ///<dt><b>NTMS_PARTSTATE_DECOMMISIONED</b></dt> </dl> </td> <td width="60%"> The media is unsuitable for data
    ///storage and is no longer usable. </td> </tr> <tr> <td width="40%"><a id="NTMS_PARTSTATE_INCOMPATIBLE"></a><a
    ///id="ntms_partstate_incompatible"></a><dl> <dt><b>NTMS_PARTSTATE_INCOMPATIBLE</b></dt> </dl> </td> <td
    ///width="60%"> The media has been found to be and marked as incompatible with the drive. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_PARTSTATE_FOREIGN"></a><a id="ntms_partstate_foreign"></a><dl>
    ///<dt><b>NTMS_PARTSTATE_FOREIGN</b></dt> </dl> </td> <td width="60%"> The media is in a unrecognized pool. </td>
    ///</tr> <tr> <td width="40%"><a id="NTMS_PARTSTATE_IMPORT"></a><a id="ntms_partstate_import"></a><dl>
    ///<dt><b>NTMS_PARTSTATE_IMPORT</b></dt> </dl> </td> <td width="60%"> The media is in the import pool. </td> </tr>
    ///<tr> <td width="40%"><a id="NTMS_PARTSTATE_UNPREPARED"></a><a id="ntms_partstate_unprepared"></a><dl>
    ///<dt><b>NTMS_PARTSTATE_UNPREPARED</b></dt> </dl> </td> <td width="60%"> The media is waiting for a free label to
    ///be applied. </td> </tr> <tr> <td width="40%"><a id="NTMS_PARTSTATE_RESERVED"></a><a
    ///id="ntms_partstate_reserved"></a><dl> <dt><b>NTMS_PARTSTATE_RESERVED</b></dt> </dl> </td> <td width="60%"> The
    ///side has been reserved by the AllocateNtmsMedia function with the <i>dwOption</i> parameter set to
    ///NTMS_ALLOCATE_NEW. </td> </tr> </table>
    uint          State;
    ///Zero-relative value which indicates which side of a multi-sided media this is. For single-sided media, such as
    ///tape, this value is always zero. For dual-sided media one NTMS_PARITIONINFORMATION record has this property set
    ///to zero - the "A" side - and a second NTMS_PARTITIONINFORMATION record has it set to 1 - the "B" side.
    ushort        Side;
    ///Length of the label ID string of the on-media identifier.
    uint          dwOmidLabelIdLength;
    ///Label ID unique identifier of the on-media identifier.
    ubyte[255]    OmidLabelId;
    ///Label type of the on-media identifier.
    ushort[64]    szOmidLabelType;
    ///Label information of the on-media identifier.
    ushort[256]   szOmidLabelInfo;
    ///Number of times this media has been mounted into a drive. This is initialized to zero when the objects are
    ///created in the database.
    uint          dwMountCount;
    ///Number of times this media has been allocated.
    uint          dwAllocateCount;
    ///Number bytes of storage available on this side.
    LARGE_INTEGER Capacity;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_MEDIAPOOLINFORMATION</b> structure defines the properties specific to a media pool object.
struct NTMS_MEDIAPOOLINFORMATION
{
    ///NTMS supports the following media pool types. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="NTMS_POOLTYPE_UNKNOWN"></a><a id="ntms_pooltype_unknown"></a><dl>
    ///<dt><b>NTMS_POOLTYPE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> Unknown pool type. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_POOLTYPE_SCRATCH"></a><a id="ntms_pooltype_scratch"></a><dl>
    ///<dt><b>NTMS_POOLTYPE_SCRATCH</b></dt> </dl> </td> <td width="60%"> Media that is available to other applications.
    ///</td> </tr> <tr> <td width="40%"><a id="NTMS_POOLTYPE_FOREIGN"></a><a id="ntms_pooltype_foreign"></a><dl>
    ///<dt><b>NTMS_POOLTYPE_FOREIGN</b></dt> </dl> </td> <td width="60%"> Media that has been written to and does not
    ///contain a recognizable on-media identifier label-type or label ID. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_POOLTYPE_IMPORT"></a><a id="ntms_pooltype_import"></a><dl> <dt><b>NTMS_POOLTYPE_IMPORT</b></dt> </dl>
    ///</td> <td width="60%"> Media that has been written to, has a recognizable on-media identifier label type but an
    ///unrecognizable label ID. </td> </tr> <tr> <td width="40%"><a id="NTMS_POOLTYPE_APPLICATION"></a><a
    ///id="ntms_pooltype_application"></a><dl> <dt><b>NTMS_POOLTYPE_APPLICATION</b></dt> </dl> </td> <td width="60%">
    ///Media pool created by an application. One or more application media pools can be created per system. </td> </tr>
    ///</table>
    uint PoolType;
    ///Single media type that makes up each media pool.
    GUID MediaType;
    ///Parent media pool or <b>NULL</b>.
    GUID Parent;
    ///Bit field indicating action at allocation time. This member is writable. This can be the following value. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_ALLOCATE_FROMSCRATCH"></a><a
    ///id="ntms_allocate_fromscratch"></a><dl> <dt><b>NTMS_ALLOCATE_FROMSCRATCH</b></dt> </dl> </td> <td width="60%">
    ///Draw media from free if none is available in the pool. The default is not to draw from free. </td> </tr> </table>
    uint AllocationPolicy;
    ///Bit field indicating action at deallocation time. This member is writable. This can be the following value.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_DEALLOCATE_TOSCRATCH"></a><a
    ///id="ntms_deallocate_toscratch"></a><dl> <dt><b>NTMS_DEALLOCATE_TOSCRATCH</b></dt> </dl> </td> <td width="60%">
    ///Return media to free when available. The default is not to return to free. </td> </tr> </table>
    uint DeallocationPolicy;
    ///Number of times the medium can be allocated and deallocated. This member is writable.
    uint dwMaxAllocates;
    ///Number of physical media in this media pool.
    uint dwNumberOfPhysicalMedia;
    ///Number of logical media in this media pool.
    uint dwNumberOfLogicalMedia;
    ///Number of media pools in this media pool.
    uint dwNumberOfMediaPools;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_MEDIATYPEINFORMATION</b> structure defines the properties specific to a type of media supported by RSM.
struct NTMS_MEDIATYPEINFORMATION
{
    ///Each disk or tape driver reports the media-type enumeration value of the medium that is currently mounted in the
    ///drive. This member can be one of the values in the STORAGE_MEDIA_TYPE enumeration type. This unique media type
    ///value is mapped to a human-readable string in the object <b>szName</b> member.
    uint MediaType;
    ///Number of sides on the media.
    uint NumberOfSides;
    ///Identifies the read/write characteristics of the media type. This can be one of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_MEDIARW_REWRITABLE"></a><a
    ///id="ntms_mediarw_rewritable"></a><dl> <dt><b>NTMS_MEDIARW_REWRITABLE</b></dt> </dl> </td> <td width="60%"> Media
    ///that can be rewritten. This includes magnetic tape, magnetic disk, and some optical disk media. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_MEDIARW_WRITEONCE"></a><a id="ntms_mediarw_writeonce"></a><dl>
    ///<dt><b>NTMS_MEDIARW_WRITEONCE</b></dt> </dl> </td> <td width="60%"> Media that can only be written to one time.
    ///Some optical media, for example, 5.25", 12", 14" WORM, and CD-R, are designed to be write-once. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_MEDIARW_READONLY"></a><a id="ntms_mediarw_readonly"></a><dl>
    ///<dt><b>NTMS_MEDIARW_READONLY</b></dt> </dl> </td> <td width="60%"> Media that cannot be written to CD-ROM and
    ///DVD-ROM. </td> </tr> </table>
    uint ReadWriteCharacteristics;
    ///SCSI device type as reported from device inquiry data. This can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_DEVICE_CD_ROM"></a><a
    ///id="file_device_cd_rom"></a><dl> <dt><b>FILE_DEVICE_CD_ROM</b></dt> </dl> </td> <td width="60%"> CD-ROM device.
    ///</td> </tr> <tr> <td width="40%"><a id="FILE_DEVICE_DISK"></a><a id="file_device_disk"></a><dl>
    ///<dt><b>FILE_DEVICE_DISK</b></dt> </dl> </td> <td width="60%"> Direct access device. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_DEVICE_TAPE"></a><a id="file_device_tape"></a><dl> <dt><b>FILE_DEVICE_TAPE</b></dt> </dl>
    ///</td> <td width="60%"> Sequential access device. </td> </tr> </table>
    uint DeviceType;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_DRIVETYPEINFORMATION</b> structure defines the properties specific to a type of drive supported by RSM.
struct NTMS_DRIVETYPEINFORMATIONA
{
    ///Name of the vendor of the drive. This is acquired directly from the device inquiry data.
    byte[128] szVendor;
    ///Name of the product of the drive. This is acquired directly from the device inquiry data.
    byte[128] szProduct;
    ///This member is reserved for future use and should be ignored.
    uint      NumberOfHeads;
    ///The SCSI device type as reported from device inquiry data. From Winioctl.h. This can be one of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_DEVICE_CD_ROM"></a><a
    ///id="file_device_cd_rom"></a><dl> <dt><b>FILE_DEVICE_CD_ROM</b></dt> </dl> </td> <td width="60%"> CD-ROM device.
    ///</td> </tr> <tr> <td width="40%"><a id="FILE_DEVICE_DISK"></a><a id="file_device_disk"></a><dl>
    ///<dt><b>FILE_DEVICE_DISK</b></dt> </dl> </td> <td width="60%"> Direct access device. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_DEVICE_DVD"></a><a id="file_device_dvd"></a><dl> <dt><b>FILE_DEVICE_DVD</b></dt> </dl>
    ///</td> <td width="60%"> DVD device </td> </tr> <tr> <td width="40%"><a id="FILE_DEVICE_TAPE"></a><a
    ///id="file_device_tape"></a><dl> <dt><b>FILE_DEVICE_TAPE</b></dt> </dl> </td> <td width="60%"> Sequential access
    ///device. </td> </tr> </table>
    uint      DeviceType;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_DRIVETYPEINFORMATION</b> structure defines the properties specific to a type of drive supported by RSM.
struct NTMS_DRIVETYPEINFORMATIONW
{
    ///Name of the vendor of the drive. This is acquired directly from the device inquiry data.
    ushort[128] szVendor;
    ///Name of the product of the drive. This is acquired directly from the device inquiry data.
    ushort[128] szProduct;
    ///This member is reserved for future use and should be ignored.
    uint        NumberOfHeads;
    ///The SCSI device type as reported from device inquiry data. From Winioctl.h. This can be one of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_DEVICE_CD_ROM"></a><a
    ///id="file_device_cd_rom"></a><dl> <dt><b>FILE_DEVICE_CD_ROM</b></dt> </dl> </td> <td width="60%"> CD-ROM device.
    ///</td> </tr> <tr> <td width="40%"><a id="FILE_DEVICE_DISK"></a><a id="file_device_disk"></a><dl>
    ///<dt><b>FILE_DEVICE_DISK</b></dt> </dl> </td> <td width="60%"> Direct access device. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_DEVICE_DVD"></a><a id="file_device_dvd"></a><dl> <dt><b>FILE_DEVICE_DVD</b></dt> </dl>
    ///</td> <td width="60%"> DVD device </td> </tr> <tr> <td width="40%"><a id="FILE_DEVICE_TAPE"></a><a
    ///id="file_device_tape"></a><dl> <dt><b>FILE_DEVICE_TAPE</b></dt> </dl> </td> <td width="60%"> Sequential access
    ///device. </td> </tr> </table>
    uint        DeviceType;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_CHANGERTYPEINFORMATION</b> structure defines the properties specific to a type of robotic changer
///supported by RSM.
struct NTMS_CHANGERTYPEINFORMATIONA
{
    ///Name of the vendor of the changer. This is acquired directly from the device inquiry data.
    byte[128] szVendor;
    ///Product name of the changer. This is acquired directly from the device inquiry data.
    byte[128] szProduct;
    ///SCSI device type as reported from device inquiry data. From Winioctl.h. This can be the following value. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_DEVICE_CHANGER"></a><a
    ///id="file_device_changer"></a><dl> <dt><b>FILE_DEVICE_CHANGER</b></dt> </dl> </td> <td width="60%"> Changer
    ///device. </td> </tr> </table>
    uint      DeviceType;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_CHANGERTYPEINFORMATION</b> structure defines the properties specific to a type of robotic changer
///supported by RSM.
struct NTMS_CHANGERTYPEINFORMATIONW
{
    ///Name of the vendor of the changer. This is acquired directly from the device inquiry data.
    ushort[128] szVendor;
    ///Product name of the changer. This is acquired directly from the device inquiry data.
    ushort[128] szProduct;
    ///SCSI device type as reported from device inquiry data. From Winioctl.h. This can be the following value. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_DEVICE_CHANGER"></a><a
    ///id="file_device_changer"></a><dl> <dt><b>FILE_DEVICE_CHANGER</b></dt> </dl> </td> <td width="60%"> Changer
    ///device. </td> </tr> </table>
    uint        DeviceType;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_LIBREQUESTINFORMATION</b> structure defines the properties specific to a work request, which are queued
///to RSM.
struct NTMS_LIBREQUESTINFORMATIONA
{
    ///Item operation. This can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="NTMS_LM_CLASSIFY"></a><a id="ntms_lm_classify"></a><dl> <dt><b>NTMS_LM_CLASSIFY</b></dt>
    ///</dl> </td> <td width="60%"> Classify the medium. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_CLEANDRIVE"></a><a id="ntms_lm_cleandrive"></a><dl> <dt><b>NTMS_LM_CLEANDRIVE</b></dt> </dl> </td>
    ///<td width="60%"> Clean a drive. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_DISABLELIBRARY"></a><a
    ///id="ntms_lm_disablelibrary"></a><dl> <dt><b>NTMS_LM_DISABLELIBRARY</b></dt> </dl> </td> <td width="60%"> Disable
    ///the changer. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_DISABLEDRIVE"></a><a
    ///id="ntms_lm_disabledrive"></a><dl> <dt><b>NTMS_LM_DISABLEDRIVE</b></dt> </dl> </td> <td width="60%"> Disable a
    ///drive. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_DISABLEMEDIA"></a><a id="ntms_lm_disablemedia"></a><dl>
    ///<dt><b>NTMS_LM_DISABLEMEDIA</b></dt> </dl> </td> <td width="60%"> Disable the medium. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_DISMOUNT"></a><a id="ntms_lm_dismount"></a><dl> <dt><b>NTMS_LM_DISMOUNT</b></dt> </dl>
    ///</td> <td width="60%"> Dismount the medium from a drive. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_DOORACCESS"></a><a id="ntms_lm_dooraccess"></a><dl> <dt><b>NTMS_LM_DOORACCESS</b></dt> </dl> </td>
    ///<td width="60%"> Allow access to media through a library unit door. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_EJECT"></a><a id="ntms_lm_eject"></a><dl> <dt><b>NTMS_LM_EJECT</b></dt> </dl> </td> <td width="60%">
    ///Eject the medium from the library. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_EJECTCLEANER"></a><a
    ///id="ntms_lm_ejectcleaner"></a><dl> <dt><b>NTMS_LM_EJECTCLEANER</b></dt> </dl> </td> <td width="60%"> Eject a
    ///cleaner. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_ENABLELIBRARY"></a><a
    ///id="ntms_lm_enablelibrary"></a><dl> <dt><b>NTMS_LM_ENABLELIBRARY</b></dt> </dl> </td> <td width="60%"> Enable the
    ///changer. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_ENABLEDRIVE"></a><a id="ntms_lm_enabledrive"></a><dl>
    ///<dt><b>NTMS_LM_ENABLEDRIVE</b></dt> </dl> </td> <td width="60%"> Enable a drive. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_ENABLEMEDIA"></a><a id="ntms_lm_enablemedia"></a><dl>
    ///<dt><b>NTMS_LM_ENABLEMEDIA</b></dt> </dl> </td> <td width="60%"> Enable the medium. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_INJECT"></a><a id="ntms_lm_inject"></a><dl> <dt><b>NTMS_LM_INJECT</b></dt> </dl> </td>
    ///<td width="60%"> Insert the medium into the library. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_INJECTCLEANER"></a><a id="ntms_lm_injectcleaner"></a><dl> <dt><b>NTMS_LM_INJECTCLEANER</b></dt> </dl>
    ///</td> <td width="60%"> Insert a cleaner. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_INVENTORY"></a><a
    ///id="ntms_lm_inventory"></a><dl> <dt><b>NTMS_LM_INVENTORY</b></dt> </dl> </td> <td width="60%"> Perform an
    ///inventory of the library. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_MOUNT"></a><a
    ///id="ntms_lm_mount"></a><dl> <dt><b>NTMS_LM_MOUNT</b></dt> </dl> </td> <td width="60%"> Mount a side to a drive.
    ///</td> </tr> <tr> <td width="40%"><a id="NTMS_LM_PROCESSOMID"></a><a id="ntms_lm_processomid"></a><dl>
    ///<dt><b>NTMS_LM_PROCESSOMID</b></dt> </dl> </td> <td width="60%"> Process the OMID. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_RELEASECLEANER"></a><a id="ntms_lm_releasecleaner"></a><dl>
    ///<dt><b>NTMS_LM_RELEASECLEANER</b></dt> </dl> </td> <td width="60%"> Release a cleaner slot. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_REMOVE"></a><a id="ntms_lm_remove"></a><dl> <dt><b>NTMS_LM_REMOVE</b></dt> </dl> </td>
    ///<td width="60%"> Remove a work item from the queue. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_RESERVECLEANER"></a><a id="ntms_lm_reservecleaner"></a><dl> <dt><b>NTMS_LM_RESERVECLEANER</b></dt>
    ///</dl> </td> <td width="60%"> Reserve a cleaner slot. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_UPDATEOMID"></a><a id="ntms_lm_updateomid"></a><dl> <dt><b>NTMS_LM_UPDATEOMID</b></dt> </dl> </td>
    ///<td width="60%"> Update the OMID. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_WRITESCRATCH"></a><a
    ///id="ntms_lm_writescratch"></a><dl> <dt><b>NTMS_LM_WRITESCRATCH</b></dt> </dl> </td> <td width="60%"> Write a free
    ///label. </td> </tr> </table>
    uint       OperationCode;
    ///Work item options (command specific).
    uint       OperationOption;
    ///Current state of this work item. This can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_LM_QUEUED"></a><a id="ntms_lm_queued"></a><dl>
    ///<dt><b>NTMS_LM_QUEUED</b></dt> </dl> </td> <td width="60%"> Operation is queued. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_INPROCESS"></a><a id="ntms_lm_inprocess"></a><dl> <dt><b>NTMS_LM_INPROCESS</b></dt>
    ///</dl> </td> <td width="60%"> Operation is being processed. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_PASSED"></a><a id="ntms_lm_passed"></a><dl> <dt><b>NTMS_LM_PASSED</b></dt> </dl> </td> <td
    ///width="60%"> Operation completed successfully. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_FAILED"></a><a
    ///id="ntms_lm_failed"></a><dl> <dt><b>NTMS_LM_FAILED</b></dt> </dl> </td> <td width="60%"> Operation has completed
    ///with an error. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_WAITING"></a><a id="ntms_lm_waiting"></a><dl>
    ///<dt><b>NTMS_LM_WAITING</b></dt> </dl> </td> <td width="60%"> Operation is blocked. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_CANCELLED"></a><a id="ntms_lm_cancelled"></a><dl> <dt><b>NTMS_LM_CANCELLED</b></dt>
    ///</dl> </td> <td width="60%"> Operation has been canceled. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_INVALID"></a><a id="ntms_lm_invalid"></a><dl> <dt><b>NTMS_LM_INVALID</b></dt> </dl> </td> <td
    ///width="60%"> Operation is not valid. </td> </tr> </table>
    uint       State;
    ///Unique identifier of a side being serviced.
    GUID       PartitionId;
    ///Unique identifier of a drive being serviced.
    GUID       DriveId;
    ///Unique identifier of a piece of physical media being serviced.
    GUID       PhysMediaId;
    ///Library for this request.
    GUID       Library;
    ///Unique identifier of a slot of the piece of physical media being serviced.
    GUID       SlotId;
    ///System time that this request was queued to RSM.
    SYSTEMTIME TimeQueued;
    ///System time that this request was completed by RSM.
    SYSTEMTIME TimeCompleted;
    ///Application that submitted the operator request.
    byte[64]   szApplication;
    ///Interactive user logged on to the computer that submitted the operator request.
    byte[64]   szUser;
    ///Computer that submitted the operator request.
    byte[64]   szComputer;
    ///Error return for requests that return with state NTMS_LM_FAILED. This is a system error code.
    uint       dwErrorCode;
    ///Associated work item ID for this request. This is currently used to contain the work item ID to be canceled on an
    ///NTMS_LM_REMOVE request.
    GUID       WorkItemId;
    ///Priority of the work item.
    uint       dwPriority;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_LIBREQUESTINFORMATION</b> structure defines the properties specific to a work request, which are queued
///to RSM.
struct NTMS_LIBREQUESTINFORMATIONW
{
    ///Item operation. This can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="NTMS_LM_CLASSIFY"></a><a id="ntms_lm_classify"></a><dl> <dt><b>NTMS_LM_CLASSIFY</b></dt>
    ///</dl> </td> <td width="60%"> Classify the medium. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_CLEANDRIVE"></a><a id="ntms_lm_cleandrive"></a><dl> <dt><b>NTMS_LM_CLEANDRIVE</b></dt> </dl> </td>
    ///<td width="60%"> Clean a drive. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_DISABLELIBRARY"></a><a
    ///id="ntms_lm_disablelibrary"></a><dl> <dt><b>NTMS_LM_DISABLELIBRARY</b></dt> </dl> </td> <td width="60%"> Disable
    ///the changer. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_DISABLEDRIVE"></a><a
    ///id="ntms_lm_disabledrive"></a><dl> <dt><b>NTMS_LM_DISABLEDRIVE</b></dt> </dl> </td> <td width="60%"> Disable a
    ///drive. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_DISABLEMEDIA"></a><a id="ntms_lm_disablemedia"></a><dl>
    ///<dt><b>NTMS_LM_DISABLEMEDIA</b></dt> </dl> </td> <td width="60%"> Disable the medium. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_DISMOUNT"></a><a id="ntms_lm_dismount"></a><dl> <dt><b>NTMS_LM_DISMOUNT</b></dt> </dl>
    ///</td> <td width="60%"> Dismount the medium from a drive. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_DOORACCESS"></a><a id="ntms_lm_dooraccess"></a><dl> <dt><b>NTMS_LM_DOORACCESS</b></dt> </dl> </td>
    ///<td width="60%"> Allow access to media through a library unit door. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_EJECT"></a><a id="ntms_lm_eject"></a><dl> <dt><b>NTMS_LM_EJECT</b></dt> </dl> </td> <td width="60%">
    ///Eject the medium from the library. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_EJECTCLEANER"></a><a
    ///id="ntms_lm_ejectcleaner"></a><dl> <dt><b>NTMS_LM_EJECTCLEANER</b></dt> </dl> </td> <td width="60%"> Eject a
    ///cleaner. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_ENABLELIBRARY"></a><a
    ///id="ntms_lm_enablelibrary"></a><dl> <dt><b>NTMS_LM_ENABLELIBRARY</b></dt> </dl> </td> <td width="60%"> Enable the
    ///changer. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_ENABLEDRIVE"></a><a id="ntms_lm_enabledrive"></a><dl>
    ///<dt><b>NTMS_LM_ENABLEDRIVE</b></dt> </dl> </td> <td width="60%"> Enable a drive. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_ENABLEMEDIA"></a><a id="ntms_lm_enablemedia"></a><dl>
    ///<dt><b>NTMS_LM_ENABLEMEDIA</b></dt> </dl> </td> <td width="60%"> Enable the medium. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_INJECT"></a><a id="ntms_lm_inject"></a><dl> <dt><b>NTMS_LM_INJECT</b></dt> </dl> </td>
    ///<td width="60%"> Insert the medium into the library. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_INJECTCLEANER"></a><a id="ntms_lm_injectcleaner"></a><dl> <dt><b>NTMS_LM_INJECTCLEANER</b></dt> </dl>
    ///</td> <td width="60%"> Insert a cleaner. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_INVENTORY"></a><a
    ///id="ntms_lm_inventory"></a><dl> <dt><b>NTMS_LM_INVENTORY</b></dt> </dl> </td> <td width="60%"> Perform an
    ///inventory of the library. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_MOUNT"></a><a
    ///id="ntms_lm_mount"></a><dl> <dt><b>NTMS_LM_MOUNT</b></dt> </dl> </td> <td width="60%"> Mount a side to a drive.
    ///</td> </tr> <tr> <td width="40%"><a id="NTMS_LM_PROCESSOMID"></a><a id="ntms_lm_processomid"></a><dl>
    ///<dt><b>NTMS_LM_PROCESSOMID</b></dt> </dl> </td> <td width="60%"> Process the OMID. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_RELEASECLEANER"></a><a id="ntms_lm_releasecleaner"></a><dl>
    ///<dt><b>NTMS_LM_RELEASECLEANER</b></dt> </dl> </td> <td width="60%"> Release a cleaner slot. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_REMOVE"></a><a id="ntms_lm_remove"></a><dl> <dt><b>NTMS_LM_REMOVE</b></dt> </dl> </td>
    ///<td width="60%"> Remove a work item from the queue. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_RESERVECLEANER"></a><a id="ntms_lm_reservecleaner"></a><dl> <dt><b>NTMS_LM_RESERVECLEANER</b></dt>
    ///</dl> </td> <td width="60%"> Reserve a cleaner slot. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_UPDATEOMID"></a><a id="ntms_lm_updateomid"></a><dl> <dt><b>NTMS_LM_UPDATEOMID</b></dt> </dl> </td>
    ///<td width="60%"> Update the OMID. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_WRITESCRATCH"></a><a
    ///id="ntms_lm_writescratch"></a><dl> <dt><b>NTMS_LM_WRITESCRATCH</b></dt> </dl> </td> <td width="60%"> Write a free
    ///label. </td> </tr> </table>
    uint       OperationCode;
    ///Work item options (command specific).
    uint       OperationOption;
    ///Current state of this work item. This can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_LM_QUEUED"></a><a id="ntms_lm_queued"></a><dl>
    ///<dt><b>NTMS_LM_QUEUED</b></dt> </dl> </td> <td width="60%"> Operation is queued. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_INPROCESS"></a><a id="ntms_lm_inprocess"></a><dl> <dt><b>NTMS_LM_INPROCESS</b></dt>
    ///</dl> </td> <td width="60%"> Operation is being processed. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_PASSED"></a><a id="ntms_lm_passed"></a><dl> <dt><b>NTMS_LM_PASSED</b></dt> </dl> </td> <td
    ///width="60%"> Operation completed successfully. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_FAILED"></a><a
    ///id="ntms_lm_failed"></a><dl> <dt><b>NTMS_LM_FAILED</b></dt> </dl> </td> <td width="60%"> Operation has completed
    ///with an error. </td> </tr> <tr> <td width="40%"><a id="NTMS_LM_WAITING"></a><a id="ntms_lm_waiting"></a><dl>
    ///<dt><b>NTMS_LM_WAITING</b></dt> </dl> </td> <td width="60%"> Operation is blocked. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LM_CANCELLED"></a><a id="ntms_lm_cancelled"></a><dl> <dt><b>NTMS_LM_CANCELLED</b></dt>
    ///</dl> </td> <td width="60%"> Operation has been canceled. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LM_INVALID"></a><a id="ntms_lm_invalid"></a><dl> <dt><b>NTMS_LM_INVALID</b></dt> </dl> </td> <td
    ///width="60%"> Operation is not valid. </td> </tr> </table>
    uint       State;
    ///Unique identifier of a side being serviced.
    GUID       PartitionId;
    ///Unique identifier of a drive being serviced.
    GUID       DriveId;
    ///Unique identifier of a piece of physical media being serviced.
    GUID       PhysMediaId;
    ///Library for this request.
    GUID       Library;
    ///Unique identifier of a slot of the piece of physical media being serviced.
    GUID       SlotId;
    ///System time that this request was queued to RSM.
    SYSTEMTIME TimeQueued;
    ///System time that this request was completed by RSM.
    SYSTEMTIME TimeCompleted;
    ///Application that submitted the operator request.
    ushort[64] szApplication;
    ///Interactive user logged on to the computer that submitted the operator request.
    ushort[64] szUser;
    ///Computer that submitted the operator request.
    ushort[64] szComputer;
    ///Error return for requests that return with state NTMS_LM_FAILED. This is a system error code.
    uint       dwErrorCode;
    ///Associated work item ID for this request. This is currently used to contain the work item ID to be canceled on an
    ///NTMS_LM_REMOVE request.
    GUID       WorkItemId;
    ///Priority of the work item.
    uint       dwPriority;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_OPREQUESTINFORMATION</b> structure defines the properties specific to operator-request system control for
///RSM.
struct NTMS_OPREQUESTINFORMATIONA
{
    ///Type of operator request. This can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="NTMS_OPREQ_NEWMEDIA"></a><a id="ntms_opreq_newmedia"></a><dl>
    ///<dt><b>NTMS_OPREQ_NEWMEDIA</b></dt> </dl> </td> <td width="60%"> An application attempting to allocate media
    ///sends an operator request for new media when no media is available. When this flag is set, the <b>Arg1</b> member
    ///should be set to the GUID of the media pool requiring new media. Optionally, the <b>Arg2</b> member can be set to
    ///the particular library in which the new media should be placed. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPREQ_CLEANER"></a><a id="ntms_opreq_cleaner"></a><dl> <dt><b>NTMS_OPREQ_CLEANER</b></dt> </dl> </td>
    ///<td width="60%"> RSM sends an operator request for a cleaner when a clean operation is queued and no cleaner is
    ///online and available to the drive. When this flag is set, the <b>Arg1</b> member should be set to the GUID of the
    ///library requiring the cleaning cartridge. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPREQ_DEVICESERVICE"></a><a id="ntms_opreq_deviceservice"></a><dl>
    ///<dt><b>NTMS_OPREQ_DEVICESERVICE</b></dt> </dl> </td> <td width="60%"> An application or RSM sends an operator
    ///request for drive service when a changer device or drive is experiencing problems. When this flag is set, the
    ///<b>Arg1</b> member should be set to the GUID of the device requiring service. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPREQ_MOVEMEDIA"></a><a id="ntms_opreq_movemedia"></a><dl> <dt><b>NTMS_OPREQ_MOVEMEDIA</b></dt> </dl>
    ///</td> <td width="60%"> An application or RSM sends an operator request to move the specified medium to service a
    ///mount for offline media or to eject media to an offline library. When this flag is set, the <b>Arg1</b> member
    ///should be set to the GUID of the physical media to move and the <b>Arg2</b> member should be set to the GUID of
    ///the library this media should be moved to. </td> </tr> <tr> <td width="40%"><a id="NTMS_OPREQ_MESSAGE"></a><a
    ///id="ntms_opreq_message"></a><dl> <dt><b>NTMS_OPREQ_MESSAGE</b></dt> </dl> </td> <td width="60%"> An
    ///application-specific operator request. Text only. </td> </tr> </table>
    uint       Request;
    ///System time when the operator request was submitted.
    SYSTEMTIME Submitted;
    ///Current state of the operator service request. This can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_OPSTATE_SUBMITTED"></a><a
    ///id="ntms_opstate_submitted"></a><dl> <dt><b>NTMS_OPSTATE_SUBMITTED</b></dt> </dl> </td> <td width="60%"> The
    ///operator request has been submitted but not read by an operator console. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPSTATE_ACTIVE"></a><a id="ntms_opstate_active"></a><dl> <dt><b>NTMS_OPSTATE_ACTIVE</b></dt> </dl> </td>
    ///<td width="60%"> The operator request has been read by one or more operator consoles and might be in process.
    ///</td> </tr> <tr> <td width="40%"><a id="NTMS_OPSTATE_INPROGRESS"></a><a id="ntms_opstate_inprogress"></a><dl>
    ///<dt><b>NTMS_OPSTATE_INPROGRESS</b></dt> </dl> </td> <td width="60%"> The user has acknowledged this operator
    ///request and is in the process of performing the service. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPSTATE_REFUSED"></a><a id="ntms_opstate_refused"></a><dl> <dt><b>NTMS_OPSTATE_REFUSED</b></dt> </dl>
    ///</td> <td width="60%"> The user has rejected the operator service request. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPSTATE_COMPLETE"></a><a id="ntms_opstate_complete"></a><dl> <dt><b>NTMS_OPSTATE_COMPLETE</b></dt> </dl>
    ///</td> <td width="60%"> The user has completed the operator service request. </td> </tr> </table>
    uint       State;
    ///Operator message text.
    byte[256]  szMessage;
    ///Type of the <b>Arg1</b> object. This can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_UNKNOWN"></a><a id="ntms_unknown"></a><dl>
    ///<dt><b>NTMS_UNKNOWN</b></dt> </dl> </td> <td width="60%"> No object provided in <b>Arg1Type</b>. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_CHANGER"></a><a id="ntms_changer"></a><dl> <dt><b>NTMS_CHANGER</b></dt> </dl> </td>
    ///<td width="60%"> Medium changer object. </td> </tr> <tr> <td width="40%"><a id="NTMS_DRIVE"></a><a
    ///id="ntms_drive"></a><dl> <dt><b>NTMS_DRIVE</b></dt> </dl> </td> <td width="60%"> Drive object. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_IEDOOR"></a><a id="ntms_iedoor"></a><dl> <dt><b>NTMS_IEDOOR</b></dt> </dl> </td> <td
    ///width="60%"> Library door object. </td> </tr> <tr> <td width="40%"><a id="NTMS_IEPORT."></a><a
    ///id="ntms_ieport."></a><dl> <dt><b>NTMS_IEPORT.</b></dt> </dl> </td> <td width="60%"> Library insert/eject port
    ///object </td> </tr> <tr> <td width="40%"><a id="NTMS_LIBRARY"></a><a id="ntms_library"></a><dl>
    ///<dt><b>NTMS_LIBRARY</b></dt> </dl> </td> <td width="60%"> Library object. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_PARTITION"></a><a id="ntms_partition"></a><dl> <dt><b>NTMS_PARTITION</b></dt> </dl> </td> <td
    ///width="60%"> Side object. </td> </tr> <tr> <td width="40%"><a id="NTMS_PHYSICAL_MEDIA"></a><a
    ///id="ntms_physical_media"></a><dl> <dt><b>NTMS_PHYSICAL_MEDIA</b></dt> </dl> </td> <td width="60%"> Physical media
    ///object. </td> </tr> <tr> <td width="40%"><a id="NTMS_STORAGESLOT"></a><a id="ntms_storageslot"></a><dl>
    ///<dt><b>NTMS_STORAGESLOT</b></dt> </dl> </td> <td width="60%"> Library slot object. </td> </tr> </table>
    uint       Arg1Type;
    ///<b>Arg1</b> object ID used for move requests or other operator requests that require a reference object. The
    ///purpose of this object varies based on the type of operator request. For appropriate uses of <b>Arg1</b>, see the
    ///<b>Request</b> description.
    GUID       Arg1;
    ///Type of <b>Arg2</b> object. This can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="NTMS_UNKNOWN"></a><a id="ntms_unknown"></a><dl> <dt><b>NTMS_UNKNOWN</b></dt>
    ///</dl> </td> <td width="60%"> No object provided in <b>Arg2Type</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LIBRARY"></a><a id="ntms_library"></a><dl> <dt><b>NTMS_LIBRARY</b></dt> </dl> </td> <td width="60%">
    ///Library object. </td> </tr> </table>
    uint       Arg2Type;
    ///<b>Arg2</b> object ID used for operator requests that require a second reference object. The purpose of this
    ///object varies based on the type of operator request. For appropriate uses of <b>Arg2</b>, see the <b>Request</b>
    ///description.
    GUID       Arg2;
    ///Application that submitted the operator request.
    byte[64]   szApplication;
    ///Interactive user logged on to the computer that submitted the operator request.
    byte[64]   szUser;
    ///Computer that submitted the operator request.
    byte[64]   szComputer;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_OPREQUESTINFORMATION</b> structure defines the properties specific to operator-request system control for
///RSM.
struct NTMS_OPREQUESTINFORMATIONW
{
    ///Type of operator request. This can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="NTMS_OPREQ_NEWMEDIA"></a><a id="ntms_opreq_newmedia"></a><dl>
    ///<dt><b>NTMS_OPREQ_NEWMEDIA</b></dt> </dl> </td> <td width="60%"> An application attempting to allocate media
    ///sends an operator request for new media when no media is available. When this flag is set, the <b>Arg1</b> member
    ///should be set to the GUID of the media pool requiring new media. Optionally, the <b>Arg2</b> member can be set to
    ///the particular library in which the new media should be placed. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPREQ_CLEANER"></a><a id="ntms_opreq_cleaner"></a><dl> <dt><b>NTMS_OPREQ_CLEANER</b></dt> </dl> </td>
    ///<td width="60%"> RSM sends an operator request for a cleaner when a clean operation is queued and no cleaner is
    ///online and available to the drive. When this flag is set, the <b>Arg1</b> member should be set to the GUID of the
    ///library requiring the cleaning cartridge. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPREQ_DEVICESERVICE"></a><a id="ntms_opreq_deviceservice"></a><dl>
    ///<dt><b>NTMS_OPREQ_DEVICESERVICE</b></dt> </dl> </td> <td width="60%"> An application or RSM sends an operator
    ///request for drive service when a changer device or drive is experiencing problems. When this flag is set, the
    ///<b>Arg1</b> member should be set to the GUID of the device requiring service. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPREQ_MOVEMEDIA"></a><a id="ntms_opreq_movemedia"></a><dl> <dt><b>NTMS_OPREQ_MOVEMEDIA</b></dt> </dl>
    ///</td> <td width="60%"> An application or RSM sends an operator request to move the specified medium to service a
    ///mount for offline media or to eject media to an offline library. When this flag is set, the <b>Arg1</b> member
    ///should be set to the GUID of the physical media to move and the <b>Arg2</b> member should be set to the GUID of
    ///the library this media should be moved to. </td> </tr> <tr> <td width="40%"><a id="NTMS_OPREQ_MESSAGE"></a><a
    ///id="ntms_opreq_message"></a><dl> <dt><b>NTMS_OPREQ_MESSAGE</b></dt> </dl> </td> <td width="60%"> An
    ///application-specific operator request. Text only. </td> </tr> </table>
    uint        Request;
    ///System time when the operator request was submitted.
    SYSTEMTIME  Submitted;
    ///Current state of the operator service request. This can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_OPSTATE_SUBMITTED"></a><a
    ///id="ntms_opstate_submitted"></a><dl> <dt><b>NTMS_OPSTATE_SUBMITTED</b></dt> </dl> </td> <td width="60%"> The
    ///operator request has been submitted but not read by an operator console. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPSTATE_ACTIVE"></a><a id="ntms_opstate_active"></a><dl> <dt><b>NTMS_OPSTATE_ACTIVE</b></dt> </dl> </td>
    ///<td width="60%"> The operator request has been read by one or more operator consoles and might be in process.
    ///</td> </tr> <tr> <td width="40%"><a id="NTMS_OPSTATE_INPROGRESS"></a><a id="ntms_opstate_inprogress"></a><dl>
    ///<dt><b>NTMS_OPSTATE_INPROGRESS</b></dt> </dl> </td> <td width="60%"> The user has acknowledged this operator
    ///request and is in the process of performing the service. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPSTATE_REFUSED"></a><a id="ntms_opstate_refused"></a><dl> <dt><b>NTMS_OPSTATE_REFUSED</b></dt> </dl>
    ///</td> <td width="60%"> The user has rejected the operator service request. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPSTATE_COMPLETE"></a><a id="ntms_opstate_complete"></a><dl> <dt><b>NTMS_OPSTATE_COMPLETE</b></dt> </dl>
    ///</td> <td width="60%"> The user has completed the operator service request. </td> </tr> </table>
    uint        State;
    ///Operator message text.
    ushort[256] szMessage;
    ///Type of the <b>Arg1</b> object. This can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_UNKNOWN"></a><a id="ntms_unknown"></a><dl>
    ///<dt><b>NTMS_UNKNOWN</b></dt> </dl> </td> <td width="60%"> No object provided in <b>Arg1Type</b>. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_CHANGER"></a><a id="ntms_changer"></a><dl> <dt><b>NTMS_CHANGER</b></dt> </dl> </td>
    ///<td width="60%"> Medium changer object. </td> </tr> <tr> <td width="40%"><a id="NTMS_DRIVE"></a><a
    ///id="ntms_drive"></a><dl> <dt><b>NTMS_DRIVE</b></dt> </dl> </td> <td width="60%"> Drive object. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_IEDOOR"></a><a id="ntms_iedoor"></a><dl> <dt><b>NTMS_IEDOOR</b></dt> </dl> </td> <td
    ///width="60%"> Library door object. </td> </tr> <tr> <td width="40%"><a id="NTMS_IEPORT."></a><a
    ///id="ntms_ieport."></a><dl> <dt><b>NTMS_IEPORT.</b></dt> </dl> </td> <td width="60%"> Library insert/eject port
    ///object </td> </tr> <tr> <td width="40%"><a id="NTMS_LIBRARY"></a><a id="ntms_library"></a><dl>
    ///<dt><b>NTMS_LIBRARY</b></dt> </dl> </td> <td width="60%"> Library object. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_PARTITION"></a><a id="ntms_partition"></a><dl> <dt><b>NTMS_PARTITION</b></dt> </dl> </td> <td
    ///width="60%"> Side object. </td> </tr> <tr> <td width="40%"><a id="NTMS_PHYSICAL_MEDIA"></a><a
    ///id="ntms_physical_media"></a><dl> <dt><b>NTMS_PHYSICAL_MEDIA</b></dt> </dl> </td> <td width="60%"> Physical media
    ///object. </td> </tr> <tr> <td width="40%"><a id="NTMS_STORAGESLOT"></a><a id="ntms_storageslot"></a><dl>
    ///<dt><b>NTMS_STORAGESLOT</b></dt> </dl> </td> <td width="60%"> Library slot object. </td> </tr> </table>
    uint        Arg1Type;
    ///<b>Arg1</b> object ID used for move requests or other operator requests that require a reference object. The
    ///purpose of this object varies based on the type of operator request. For appropriate uses of <b>Arg1</b>, see the
    ///<b>Request</b> description.
    GUID        Arg1;
    ///Type of <b>Arg2</b> object. This can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="NTMS_UNKNOWN"></a><a id="ntms_unknown"></a><dl> <dt><b>NTMS_UNKNOWN</b></dt>
    ///</dl> </td> <td width="60%"> No object provided in <b>Arg2Type</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LIBRARY"></a><a id="ntms_library"></a><dl> <dt><b>NTMS_LIBRARY</b></dt> </dl> </td> <td width="60%">
    ///Library object. </td> </tr> </table>
    uint        Arg2Type;
    ///<b>Arg2</b> object ID used for operator requests that require a second reference object. The purpose of this
    ///object varies based on the type of operator request. For appropriate uses of <b>Arg2</b>, see the <b>Request</b>
    ///description.
    GUID        Arg2;
    ///Application that submitted the operator request.
    ushort[64]  szApplication;
    ///Interactive user logged on to the computer that submitted the operator request.
    ushort[64]  szUser;
    ///Computer that submitted the operator request.
    ushort[64]  szComputer;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_COMPUTERINFORMATION</b> structure defines the properties specific to the RSM server.
struct NTMS_COMPUTERINFORMATION
{
    ///Number of seconds completed library requests are maintained in the work queue.
    uint dwLibRequestPurgeTime;
    ///Number of seconds that completed operator requests are maintained in the operator request queue.
    uint dwOpRequestPurgeTime;
    ///Library request options. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LIBREQFLAGS_NOAUTOPURGE"></a><a id="ntms_libreqflags_noautopurge"></a><dl>
    ///<dt><b>NTMS_LIBREQFLAGS_NOAUTOPURGE</b></dt> </dl> </td> <td width="60%"> Library requests are not purged from
    ///the work queue. Set to <b>NULL</b> by default. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_LIBREQFLAGS_NOFAILEDPURGE"></a><a id="ntms_libreqflags_nofailedpurge"></a><dl>
    ///<dt><b>NTMS_LIBREQFLAGS_NOFAILEDPURGE</b></dt> </dl> </td> <td width="60%"> Failed work items are not purged from
    ///the work queue. Set to <b>NULL</b> by default. </td> </tr> </table>
    uint dwLibRequestFlags;
    ///Operator request options. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPREQFLAGS_NOAUTOPURGE"></a><a id="ntms_opreqflags_noautopurge"></a><dl>
    ///<dt><b>NTMS_OPREQFLAGS_NOAUTOPURGE</b></dt> </dl> </td> <td width="60%"> Operator requests are not purged from
    ///the work queue. Set to <b>NULL</b> by default. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPREQFLAGS_NOFAILEDPURGE"></a><a id="ntms_opreqflags_nofailedpurge"></a><dl>
    ///<dt><b>NTMS_OPREQFLAGS_NOFAILEDPURGE</b></dt> </dl> </td> <td width="60%"> Operator requests are not purged from
    ///the queue. Set to <b>NULL</b> by default. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_OPREQFLAGS_NOALERTS"></a><a id="ntms_opreqflags_noalerts"></a><dl>
    ///<dt><b>NTMS_OPREQFLAGS_NOALERTS</b></dt> </dl> </td> <td width="60%"> The alert pop-up for operator requests is
    ///disabled. </td> </tr> <tr> <td width="40%"><a id="NTMS_OPREQFLAGS_NOTRAYICON"></a><a
    ///id="ntms_opreqflags_notrayicon"></a><dl> <dt><b>NTMS_OPREQFLAGS_NOTRAYICON</b></dt> </dl> </td> <td width="60%">
    ///The taskbar icon for operator requests is disabled. </td> </tr> </table>
    uint dwOpRequestFlags;
    ///Media pool policies. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="NTMS_POOLPOLICY_PURGEOFFLINESCRATCH"></a><a id="ntms_poolpolicy_purgeofflinescratch"></a><dl>
    ///<dt><b>NTMS_POOLPOLICY_PURGEOFFLINESCRATCH</b></dt> </dl> </td> <td width="60%"> Any Free media ejected are
    ///automatically deleted. Set to <b>NULL</b> by default. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_POOLPOLICY_KEEPOFFLINEIMPORT"></a><a id="ntms_poolpolicy_keepofflineimport"></a><dl>
    ///<dt><b>NTMS_POOLPOLICY_KEEPOFFLINEIMPORT</b></dt> </dl> </td> <td width="60%"> Any Import media ejected is not
    ///deleted automatically. Set to <b>NULL</b> by default. </td> </tr> </table>
    uint dwMediaPoolPolicy;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_OBJECTINFORMATION</b> structure defines the properties that an application can get and set for RSM
///devices, media and system controls (such as libraries, drives, media, operator requests). This is the common
///structure of objects in the RSM database.
struct NTMS_OBJECTINFORMATIONA
{
    ///Type: <b>DWORD</b> Size of the information structure, in bytes. This member must be set to the correct size of
    ///the structure prior to using either the GetNtmsObjectInformationfunction or the SetNtmsObjectInformation
    ///function.
    uint       dwSize;
    ///Type: <b>DWORD</b> Type of device or system control for which to get/set information. This member must be set to
    ///one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="NTMS_CHANGER"></a><a id="ntms_changer"></a><dl> <dt><b>NTMS_CHANGER</b></dt> </dl> </td> <td width="60%"> A
    ///changer object represents the robotic element of a library unit. The <b>Info</b> member is a pointer to an
    ///NTMS_CHANGERINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_CHANGER_TYPE"></a><a
    ///id="ntms_changer_type"></a><dl> <dt><b>NTMS_CHANGER_TYPE</b></dt> </dl> </td> <td width="60%"> A changer type
    ///object is created for each unique changer device type attached to a system. The <b>Info</b> member is a pointer
    ///to an NTMS_CHANGERTYPEINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_COMPUTER"></a><a
    ///id="ntms_computer"></a><dl> <dt><b>NTMS_COMPUTER</b></dt> </dl> </td> <td width="60%"> The current computer
    ///object. There is no structure for the computer object. The <b>Info</b> member is a pointer to an
    ///NTMS_COMPUTERINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_DRIVE"></a><a
    ///id="ntms_drive"></a><dl> <dt><b>NTMS_DRIVE</b></dt> </dl> </td> <td width="60%"> A drive object represents a tape
    ///drive or disk drive. The <b>Info</b> member is a pointer to an NTMS_DRIVEINFORMATION structure. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_DRIVE_TYPE"></a><a id="ntms_drive_type"></a><dl> <dt><b>NTMS_DRIVE_TYPE</b></dt>
    ///</dl> </td> <td width="60%"> A drive type object is created for each unique drive device type attached to a
    ///system. The <b>Info</b> member is a pointer to an NTMS_DRIVETYPEINFORMATION structure. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_IEDOOR"></a><a id="ntms_iedoor"></a><dl> <dt><b>NTMS_IEDOOR</b></dt> </dl> </td> <td
    ///width="60%"> An NTMS_IEDOOR object represents the door-access mechanism of a library unit. The <b>Info</b> member
    ///is a pointer to an NTMS_IEDOORINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_IEPORT"></a><a
    ///id="ntms_ieport"></a><dl> <dt><b>NTMS_IEPORT</b></dt> </dl> </td> <td width="60%"> An NTMS_IEPORT object
    ///represents the insert/eject port of a library unit. The <b>Info</b> member is a pointer to an
    ///NTMS_IEPORTINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_LIBRARY"></a><a
    ///id="ntms_library"></a><dl> <dt><b>NTMS_LIBRARY</b></dt> </dl> </td> <td width="60%"> A library object represents
    ///an online or offline library. The <b>Info</b> member is a pointer to an NTMS_LIBRARYINFORMATION structure. </td>
    ///</tr> <tr> <td width="40%"><a id="NTMS_LIBREQUEST"></a><a id="ntms_librequest"></a><dl>
    ///<dt><b>NTMS_LIBREQUEST</b></dt> </dl> </td> <td width="60%"> A library request object is created for each request
    ///for a library to perform an action. A list of library requests is maintained by RSM as a queue of work to be
    ///performed. The <b>Info</b> member is a pointer to an NTMS_LIBREQUESTINFORMATION structure. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LOGICAL_MEDIA"></a><a id="ntms_logical_media"></a><dl> <dt><b>NTMS_LOGICAL_MEDIA</b></dt>
    ///</dl> </td> <td width="60%"> The primary handle used by applications to access the specified medium. In the case
    ///of multi-sided media, each side is treated as an individual piece of physical media. The <b>Info</b> member is a
    ///pointer to an NTMS_LMIDINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_MEDIA_POOL"></a><a
    ///id="ntms_media_pool"></a><dl> <dt><b>NTMS_MEDIA_POOL</b></dt> </dl> </td> <td width="60%"> A media pool is a
    ///logical grouping of media. All media in a media pool must be the same media type. The <b>Info</b> member is a
    ///pointer to an NTMS_MEDIAPOOLINFORMATION structure. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_MEDIA_TYPE"></a><a id="ntms_media_type"></a><dl> <dt><b>NTMS_MEDIA_TYPE</b></dt> </dl> </td> <td
    ///width="60%"> A media type object is created for each unique media type in a system. The <b>Info</b> member is a
    ///pointer to an NTMS_MEDIATYPEINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_OPREQUEST"></a><a
    ///id="ntms_oprequest"></a><dl> <dt><b>NTMS_OPREQUEST</b></dt> </dl> </td> <td width="60%"> An operator request
    ///object represents an RSM request for a user to get the information. The <b>Info</b> member is a pointer to an
    ///NTMS_OPREQUESTINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_PARTITION"></a><a
    ///id="ntms_partition"></a><dl> <dt><b>NTMS_PARTITION</b></dt> </dl> </td> <td width="60%"> A side object represents
    ///a side of a piece of physical media. The <b>Info</b> member is a pointer to an NTMS_PARTITIONINFORMATION
    ///structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_PHYSICAL_MEDIA"></a><a id="ntms_physical_media"></a><dl>
    ///<dt><b>NTMS_PHYSICAL_MEDIA</b></dt> </dl> </td> <td width="60%"> A physical media object represents a magnetic
    ///tape or removable disk. A piece of physical media can contain one or more sides. The <b>Info</b> member is a
    ///pointer to an NTMS_PMIDINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_STORAGESLOT"></a><a
    ///id="ntms_storageslot"></a><dl> <dt><b>NTMS_STORAGESLOT</b></dt> </dl> </td> <td width="60%"> A storage slot
    ///object represents one of the slots that can hold the specified medium in a library. The <b>Info</b> member is a
    ///pointer to an NTMS_STORAGESLOTINFORMATION structure. </td> </tr> </table>
    uint       dwType;
    ///Type: <b>SYSTEMTIME</b> Date/time stamp when the object was created.
    SYSTEMTIME Created;
    ///Type: <b>SYSTEMTIME</b> Date/time stamp when the object was modified.
    SYSTEMTIME Modified;
    ///Type: <b>NTMS_GUID</b> GUID of the object.
    GUID       ObjectGuid;
    ///Type: <b>BOOL</b> Indicates whether the device or system control object is enabled.
    BOOL       Enabled;
    ///Type: <b>DWORD</b> Defines the current operational state of the object. This can be one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_NOT_PRESENT"></a><a
    ///id="ntms_not_present"></a><dl> <dt><b>NTMS_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> This device or
    ///object is not currently present. </td> </tr> <tr> <td width="40%"><a id="NTMS_READY"></a><a
    ///id="ntms_ready"></a><dl> <dt><b>NTMS_READY</b></dt> </dl> </td> <td width="60%"> This device or object is
    ///available and ready. </td> </tr> <tr> <td width="40%"><a id="NTMS_NEEDS_SERVICE"></a><a
    ///id="ntms_needs_service"></a><dl> <dt><b>NTMS_NEEDS_SERVICE</b></dt> </dl> </td> <td width="60%"> This device or
    ///object has failed and needs service. </td> </tr> </table>
    uint       dwOperationalState;
    ///Type: <b>TCHAR[NTMS_OBJECTNAME_LENGTH]</b> Name of the media, device, or system control object. Media pool and
    ///logical media names can be changed using the SetNtmsObjectInformation function. All other object names are
    ///read-only.
    byte[64]   szName;
    ///Type: <b>TCHAR[NTMS_DESCRIPTION_LENGTH]</b> Description of the device or system control object. The description
    ///of device and system control objects can be changed using the SetNtmsObjectInformation function. (Writable for
    ///all objects)
    byte[127]  szDescription;
    union Info
    {
        NTMS_DRIVEINFORMATIONA Drive;
        NTMS_DRIVETYPEINFORMATIONA DriveType;
        NTMS_LIBRARYINFORMATION Library;
        NTMS_CHANGERINFORMATIONA Changer;
        NTMS_CHANGERTYPEINFORMATIONA ChangerType;
        NTMS_STORAGESLOTINFORMATION StorageSlot;
        NTMS_IEDOORINFORMATION IEDoor;
        NTMS_IEPORTINFORMATION IEPort;
        NTMS_PMIDINFORMATIONA PhysicalMedia;
        NTMS_LMIDINFORMATION LogicalMedia;
        NTMS_PARTITIONINFORMATIONA Partition;
        NTMS_MEDIAPOOLINFORMATION MediaPool;
        NTMS_MEDIATYPEINFORMATION MediaType;
        NTMS_LIBREQUESTINFORMATIONA LibRequest;
        NTMS_OPREQUESTINFORMATIONA OpRequest;
        NTMS_COMPUTERINFORMATION Computer;
    }
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_OBJECTINFORMATION</b> structure defines the properties that an application can get and set for RSM
///devices, media and system controls (such as libraries, drives, media, operator requests). This is the common
///structure of objects in the RSM database.
struct NTMS_OBJECTINFORMATIONW
{
    ///Type: <b>DWORD</b> Size of the information structure, in bytes. This member must be set to the correct size of
    ///the structure prior to using either the GetNtmsObjectInformationfunction or the SetNtmsObjectInformation
    ///function.
    uint        dwSize;
    ///Type: <b>DWORD</b> Type of device or system control for which to get/set information. This member must be set to
    ///one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="NTMS_CHANGER"></a><a id="ntms_changer"></a><dl> <dt><b>NTMS_CHANGER</b></dt> </dl> </td> <td width="60%"> A
    ///changer object represents the robotic element of a library unit. The <b>Info</b> member is a pointer to an
    ///NTMS_CHANGERINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_CHANGER_TYPE"></a><a
    ///id="ntms_changer_type"></a><dl> <dt><b>NTMS_CHANGER_TYPE</b></dt> </dl> </td> <td width="60%"> A changer type
    ///object is created for each unique changer device type attached to a system. The <b>Info</b> member is a pointer
    ///to an NTMS_CHANGERTYPEINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_COMPUTER"></a><a
    ///id="ntms_computer"></a><dl> <dt><b>NTMS_COMPUTER</b></dt> </dl> </td> <td width="60%"> The current computer
    ///object. There is no structure for the computer object. The <b>Info</b> member is a pointer to an
    ///NTMS_COMPUTERINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_DRIVE"></a><a
    ///id="ntms_drive"></a><dl> <dt><b>NTMS_DRIVE</b></dt> </dl> </td> <td width="60%"> A drive object represents a tape
    ///drive or disk drive. The <b>Info</b> member is a pointer to an NTMS_DRIVEINFORMATION structure. </td> </tr> <tr>
    ///<td width="40%"><a id="NTMS_DRIVE_TYPE"></a><a id="ntms_drive_type"></a><dl> <dt><b>NTMS_DRIVE_TYPE</b></dt>
    ///</dl> </td> <td width="60%"> A drive type object is created for each unique drive device type attached to a
    ///system. The <b>Info</b> member is a pointer to an NTMS_DRIVETYPEINFORMATION structure. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_IEDOOR"></a><a id="ntms_iedoor"></a><dl> <dt><b>NTMS_IEDOOR</b></dt> </dl> </td> <td
    ///width="60%"> An NTMS_IEDOOR object represents the door-access mechanism of a library unit. The <b>Info</b> member
    ///is a pointer to an NTMS_IEDOORINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_IEPORT"></a><a
    ///id="ntms_ieport"></a><dl> <dt><b>NTMS_IEPORT</b></dt> </dl> </td> <td width="60%"> An NTMS_IEPORT object
    ///represents the insert/eject port of a library unit. The <b>Info</b> member is a pointer to an
    ///NTMS_IEPORTINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_LIBRARY"></a><a
    ///id="ntms_library"></a><dl> <dt><b>NTMS_LIBRARY</b></dt> </dl> </td> <td width="60%"> A library object represents
    ///an online or offline library. The <b>Info</b> member is a pointer to an NTMS_LIBRARYINFORMATION structure. </td>
    ///</tr> <tr> <td width="40%"><a id="NTMS_LIBREQUEST"></a><a id="ntms_librequest"></a><dl>
    ///<dt><b>NTMS_LIBREQUEST</b></dt> </dl> </td> <td width="60%"> A library request object is created for each request
    ///for a library to perform an action. A list of library requests is maintained by RSM as a queue of work to be
    ///performed. The <b>Info</b> member is a pointer to an NTMS_LIBREQUESTINFORMATION structure. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_LOGICAL_MEDIA"></a><a id="ntms_logical_media"></a><dl> <dt><b>NTMS_LOGICAL_MEDIA</b></dt>
    ///</dl> </td> <td width="60%"> The primary handle used by applications to access the specified medium. In the case
    ///of multi-sided media, each side is treated as an individual piece of physical media. The <b>Info</b> member is a
    ///pointer to an NTMS_LMIDINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_MEDIA_POOL"></a><a
    ///id="ntms_media_pool"></a><dl> <dt><b>NTMS_MEDIA_POOL</b></dt> </dl> </td> <td width="60%"> A media pool is a
    ///logical grouping of media. All media in a media pool must be the same media type. The <b>Info</b> member is a
    ///pointer to an NTMS_MEDIAPOOLINFORMATION structure. </td> </tr> <tr> <td width="40%"><a
    ///id="NTMS_MEDIA_TYPE"></a><a id="ntms_media_type"></a><dl> <dt><b>NTMS_MEDIA_TYPE</b></dt> </dl> </td> <td
    ///width="60%"> A media type object is created for each unique media type in a system. The <b>Info</b> member is a
    ///pointer to an NTMS_MEDIATYPEINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_OPREQUEST"></a><a
    ///id="ntms_oprequest"></a><dl> <dt><b>NTMS_OPREQUEST</b></dt> </dl> </td> <td width="60%"> An operator request
    ///object represents an RSM request for a user to get the information. The <b>Info</b> member is a pointer to an
    ///NTMS_OPREQUESTINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_PARTITION"></a><a
    ///id="ntms_partition"></a><dl> <dt><b>NTMS_PARTITION</b></dt> </dl> </td> <td width="60%"> A side object represents
    ///a side of a piece of physical media. The <b>Info</b> member is a pointer to an NTMS_PARTITIONINFORMATION
    ///structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_PHYSICAL_MEDIA"></a><a id="ntms_physical_media"></a><dl>
    ///<dt><b>NTMS_PHYSICAL_MEDIA</b></dt> </dl> </td> <td width="60%"> A physical media object represents a magnetic
    ///tape or removable disk. A piece of physical media can contain one or more sides. The <b>Info</b> member is a
    ///pointer to an NTMS_PMIDINFORMATION structure. </td> </tr> <tr> <td width="40%"><a id="NTMS_STORAGESLOT"></a><a
    ///id="ntms_storageslot"></a><dl> <dt><b>NTMS_STORAGESLOT</b></dt> </dl> </td> <td width="60%"> A storage slot
    ///object represents one of the slots that can hold the specified medium in a library. The <b>Info</b> member is a
    ///pointer to an NTMS_STORAGESLOTINFORMATION structure. </td> </tr> </table>
    uint        dwType;
    ///Type: <b>SYSTEMTIME</b> Date/time stamp when the object was created.
    SYSTEMTIME  Created;
    ///Type: <b>SYSTEMTIME</b> Date/time stamp when the object was modified.
    SYSTEMTIME  Modified;
    ///Type: <b>NTMS_GUID</b> GUID of the object.
    GUID        ObjectGuid;
    ///Type: <b>BOOL</b> Indicates whether the device or system control object is enabled.
    BOOL        Enabled;
    ///Type: <b>DWORD</b> Defines the current operational state of the object. This can be one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_NOT_PRESENT"></a><a
    ///id="ntms_not_present"></a><dl> <dt><b>NTMS_NOT_PRESENT</b></dt> </dl> </td> <td width="60%"> This device or
    ///object is not currently present. </td> </tr> <tr> <td width="40%"><a id="NTMS_READY"></a><a
    ///id="ntms_ready"></a><dl> <dt><b>NTMS_READY</b></dt> </dl> </td> <td width="60%"> This device or object is
    ///available and ready. </td> </tr> <tr> <td width="40%"><a id="NTMS_NEEDS_SERVICE"></a><a
    ///id="ntms_needs_service"></a><dl> <dt><b>NTMS_NEEDS_SERVICE</b></dt> </dl> </td> <td width="60%"> This device or
    ///object has failed and needs service. </td> </tr> </table>
    uint        dwOperationalState;
    ///Type: <b>TCHAR[NTMS_OBJECTNAME_LENGTH]</b> Name of the media, device, or system control object. Media pool and
    ///logical media names can be changed using the SetNtmsObjectInformation function. All other object names are
    ///read-only.
    ushort[64]  szName;
    ///Type: <b>TCHAR[NTMS_DESCRIPTION_LENGTH]</b> Description of the device or system control object. The description
    ///of device and system control objects can be changed using the SetNtmsObjectInformation function. (Writable for
    ///all objects)
    ushort[127] szDescription;
    union Info
    {
        NTMS_DRIVEINFORMATIONW Drive;
        NTMS_DRIVETYPEINFORMATIONW DriveType;
        NTMS_LIBRARYINFORMATION Library;
        NTMS_CHANGERINFORMATIONW Changer;
        NTMS_CHANGERTYPEINFORMATIONW ChangerType;
        NTMS_STORAGESLOTINFORMATION StorageSlot;
        NTMS_IEDOORINFORMATION IEDoor;
        NTMS_IEPORTINFORMATION IEPort;
        NTMS_PMIDINFORMATIONW PhysicalMedia;
        NTMS_LMIDINFORMATION LogicalMedia;
        NTMS_PARTITIONINFORMATIONW Partition;
        NTMS_MEDIAPOOLINFORMATION MediaPool;
        NTMS_MEDIATYPEINFORMATION MediaType;
        NTMS_LIBREQUESTINFORMATIONW LibRequest;
        NTMS_OPREQUESTINFORMATIONW OpRequest;
        NTMS_COMPUTERINFORMATION Computer;
    }
}

struct NTMS_I1_LIBRARYINFORMATION
{
    uint LibraryType;
    GUID CleanerSlot;
    GUID CleanerSlotDefault;
    BOOL LibrarySupportsDriveCleaning;
    BOOL BarCodeReaderInstalled;
    uint InventoryMethod;
    uint dwCleanerUsesRemaining;
    uint FirstDriveNumber;
    uint dwNumberOfDrives;
    uint FirstSlotNumber;
    uint dwNumberOfSlots;
    uint FirstDoorNumber;
    uint dwNumberOfDoors;
    uint FirstPortNumber;
    uint dwNumberOfPorts;
    uint FirstChangerNumber;
    uint dwNumberOfChangers;
    uint dwNumberOfMedia;
    uint dwNumberOfMediaTypes;
    uint dwNumberOfLibRequests;
    GUID Reserved;
}

struct NTMS_I1_LIBREQUESTINFORMATIONA
{
    uint       OperationCode;
    uint       OperationOption;
    uint       State;
    GUID       PartitionId;
    GUID       DriveId;
    GUID       PhysMediaId;
    GUID       Library;
    GUID       SlotId;
    SYSTEMTIME TimeQueued;
    SYSTEMTIME TimeCompleted;
    byte[64]   szApplication;
    byte[64]   szUser;
    byte[64]   szComputer;
}

struct NTMS_I1_LIBREQUESTINFORMATIONW
{
    uint       OperationCode;
    uint       OperationOption;
    uint       State;
    GUID       PartitionId;
    GUID       DriveId;
    GUID       PhysMediaId;
    GUID       Library;
    GUID       SlotId;
    SYSTEMTIME TimeQueued;
    SYSTEMTIME TimeCompleted;
    ushort[64] szApplication;
    ushort[64] szUser;
    ushort[64] szComputer;
}

struct NTMS_I1_PMIDINFORMATIONA
{
    GUID     CurrentLibrary;
    GUID     MediaPool;
    GUID     Location;
    uint     LocationType;
    GUID     MediaType;
    GUID     HomeSlot;
    byte[64] szBarCode;
    uint     BarCodeState;
    byte[32] szSequenceNumber;
    uint     MediaState;
    uint     dwNumberOfPartitions;
}

struct NTMS_I1_PMIDINFORMATIONW
{
    GUID       CurrentLibrary;
    GUID       MediaPool;
    GUID       Location;
    uint       LocationType;
    GUID       MediaType;
    GUID       HomeSlot;
    ushort[64] szBarCode;
    uint       BarCodeState;
    ushort[32] szSequenceNumber;
    uint       MediaState;
    uint       dwNumberOfPartitions;
}

struct NTMS_I1_PARTITIONINFORMATIONA
{
    GUID       PhysicalMedia;
    GUID       LogicalMedia;
    uint       State;
    ushort     Side;
    uint       dwOmidLabelIdLength;
    ubyte[255] OmidLabelId;
    byte[64]   szOmidLabelType;
    byte[256]  szOmidLabelInfo;
    uint       dwMountCount;
    uint       dwAllocateCount;
}

struct NTMS_I1_PARTITIONINFORMATIONW
{
    GUID        PhysicalMedia;
    GUID        LogicalMedia;
    uint        State;
    ushort      Side;
    uint        dwOmidLabelIdLength;
    ubyte[255]  OmidLabelId;
    ushort[64]  szOmidLabelType;
    ushort[256] szOmidLabelInfo;
    uint        dwMountCount;
    uint        dwAllocateCount;
}

struct NTMS_I1_OPREQUESTINFORMATIONA
{
    uint       Request;
    SYSTEMTIME Submitted;
    uint       State;
    byte[127]  szMessage;
    uint       Arg1Type;
    GUID       Arg1;
    uint       Arg2Type;
    GUID       Arg2;
    byte[64]   szApplication;
    byte[64]   szUser;
    byte[64]   szComputer;
}

struct NTMS_I1_OPREQUESTINFORMATIONW
{
    uint        Request;
    SYSTEMTIME  Submitted;
    uint        State;
    ushort[127] szMessage;
    uint        Arg1Type;
    GUID        Arg1;
    uint        Arg2Type;
    GUID        Arg2;
    ushort[64]  szApplication;
    ushort[64]  szUser;
    ushort[64]  szComputer;
}

struct NTMS_I1_OBJECTINFORMATIONA
{
    uint       dwSize;
    uint       dwType;
    SYSTEMTIME Created;
    SYSTEMTIME Modified;
    GUID       ObjectGuid;
    BOOL       Enabled;
    uint       dwOperationalState;
    byte[64]   szName;
    byte[127]  szDescription;
    union Info
    {
        NTMS_DRIVEINFORMATIONA Drive;
        NTMS_DRIVETYPEINFORMATIONA DriveType;
        NTMS_I1_LIBRARYINFORMATION Library;
        NTMS_CHANGERINFORMATIONA Changer;
        NTMS_CHANGERTYPEINFORMATIONA ChangerType;
        NTMS_STORAGESLOTINFORMATION StorageSlot;
        NTMS_IEDOORINFORMATION IEDoor;
        NTMS_IEPORTINFORMATION IEPort;
        NTMS_I1_PMIDINFORMATIONA PhysicalMedia;
        NTMS_LMIDINFORMATION LogicalMedia;
        NTMS_I1_PARTITIONINFORMATIONA Partition;
        NTMS_MEDIAPOOLINFORMATION MediaPool;
        NTMS_MEDIATYPEINFORMATION MediaType;
        NTMS_I1_LIBREQUESTINFORMATIONA LibRequest;
        NTMS_I1_OPREQUESTINFORMATIONA OpRequest;
    }
}

struct NTMS_I1_OBJECTINFORMATIONW
{
    uint        dwSize;
    uint        dwType;
    SYSTEMTIME  Created;
    SYSTEMTIME  Modified;
    GUID        ObjectGuid;
    BOOL        Enabled;
    uint        dwOperationalState;
    ushort[64]  szName;
    ushort[127] szDescription;
    union Info
    {
        NTMS_DRIVEINFORMATIONW Drive;
        NTMS_DRIVETYPEINFORMATIONW DriveType;
        NTMS_I1_LIBRARYINFORMATION Library;
        NTMS_CHANGERINFORMATIONW Changer;
        NTMS_CHANGERTYPEINFORMATIONW ChangerType;
        NTMS_STORAGESLOTINFORMATION StorageSlot;
        NTMS_IEDOORINFORMATION IEDoor;
        NTMS_IEPORTINFORMATION IEPort;
        NTMS_I1_PMIDINFORMATIONW PhysicalMedia;
        NTMS_LMIDINFORMATION LogicalMedia;
        NTMS_I1_PARTITIONINFORMATIONW Partition;
        NTMS_MEDIAPOOLINFORMATION MediaPool;
        NTMS_MEDIATYPEINFORMATION MediaType;
        NTMS_I1_LIBREQUESTINFORMATIONW LibRequest;
        NTMS_I1_OPREQUESTINFORMATIONW OpRequest;
    }
}

struct NTMS_FILESYSTEM_INFO
{
    ushort[64]  FileSystemType;
    ushort[256] VolumeName;
    uint        SerialNumber;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>NTMS_NOTIFICATIONINFORMATION</b> structure defines an object and operation that occurred in the RSM database.
struct NTMS_NOTIFICATIONINFORMATION
{
    ///Operation that occurred on the object. This member can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NTMS_OBJ_INSERT"></a><a
    ///id="ntms_obj_insert"></a><dl> <dt><b>NTMS_OBJ_INSERT</b></dt> </dl> </td> <td width="60%"> New object was
    ///inserted. </td> </tr> <tr> <td width="40%"><a id="NTMS_OBJ_DELETE"></a><a id="ntms_obj_delete"></a><dl>
    ///<dt><b>NTMS_OBJ_DELETE</b></dt> </dl> </td> <td width="60%"> Object was deleted. </td> </tr> <tr> <td
    ///width="40%"><a id="NTMS_OBJ_UPDATE"></a><a id="ntms_obj_update"></a><dl> <dt><b>NTMS_OBJ_UPDATE</b></dt> </dl>
    ///</td> <td width="60%"> Object was updated. </td> </tr> </table>
    uint dwOperation;
    ///Object Identifier.
    GUID ObjectId;
}

///<p class="CCE_Message">[Removable Storage Manager is no longer available as of Windows 7 and Windows Server 2008 R2.]
///The <b>MediaLabelInfo</b> structure conveys information to the RSM database about a tape OMID. The media label
///library fills in this structure for all media labels the library recognizes.
struct MediaLabelInfo
{
    ///Unicode string that identifies the source of the media label. Often this is the name of the backup application or
    ///Windows command that wrote the label, for example, "Microsoft Windows Wbadmin".
    ushort[64]  LabelType;
    ///Number of bytes that are used in the <b>LabelID</b> member.
    uint        LabelIDSize;
    ///Unique identifier for the media label.
    ubyte[256]  LabelID;
    ///Unicode string that describes the media. For example, the description for a backup media label would be similar
    ///to "Tape created on 04/14/97".
    ushort[256] LabelAppDescr;
}

///Represents a valid log address.
struct CLS_LSN
{
    ///The log sequence number (LSN).
    ulong Internal;
}

///Represents a node identifier.
struct CLFS_NODE_ID
{
    ///The CLFS node type.
    uint cType;
    ///The size of the CLFS node, in bytes.
    uint cbNode;
}

///Contains a user buffer, which is to become part of a log record, and its length. The ReserveAndAppendLog function
///uses <b>CLFS_WRITE_ENTRY</b> structures in the routine that appends log records to logs. This routine requires the
///client to specify a set of structures. <b>ReserveAndAppendLog</b> gathers these structures and formats them into a
///log record in a marshaling buffer, which is eventually flushed to the log.
struct CLS_WRITE_ENTRY
{
    ///The log record data buffer.
    void* Buffer;
    ///The length of the log record data buffer, in bytes.
    uint  ByteLength;
}

///Describes general information about a log. The GetLogFileInformation function returns the <b>CLFS_INFORMATION</b>
///structure.
struct CLS_INFORMATION
{
    ///The total available space that is allocated to a log, in bytes. This member is the sum of the sizes of all
    ///containers that are allocated to the dedicated log.
    long    TotalAvailable;
    ///The space that is available in a log to append new records and reservation allocations, in bytes.
    long    CurrentAvailable;
    ///The total space in a log that is dedicated to reservation allocations.
    long    TotalReservation;
    ///The size of the base log, in bytes.
    ulong   BaseFileSize;
    ///The size of a container, in bytes.
    ulong   ContainerSize;
    ///The number of active containers that are associated with a dedicated log.
    uint    TotalContainers;
    ///The number of containers that are not in an active log.
    uint    FreeContainers;
    ///The number of log streams that are active in a physical log.
    uint    TotalClients;
    ///The log attributes that are set by using the <i>fFlagsAndAttributes</i> parameter of CreateLogFile when a log is
    ///created.
    uint    Attributes;
    ///The number of bytes of data that can remain pending on the internal flush queue before the Common Log File System
    ///(CLFS) automatically writes the data to disk.
    uint    FlushThreshold;
    ///The sector size of the underlying disk geometry, in bytes. The sector size is assumed to be a multiple of 512 and
    ///consistent across log containers.
    uint    SectorSize;
    ///The log sequence number (LSN) of the log archive tail.
    CLS_LSN MinArchiveTailLsn;
    ///The LSN that marks the start of the active region of a log.
    CLS_LSN BaseLsn;
    ///The value of <b>LastFlushedLsn</b> indicates that any LSNs smaller than the one specified are already flushed to
    ///disk.
    CLS_LSN LastFlushedLsn;
    ///The value of <b>LastLsn</b> indicates that any LSNs smaller than the one specified are already appended to the
    ///log.
    CLS_LSN LastLsn;
    ///The LSN of the last written restart record. If the log does not have a restart area, the LSN has the value of
    ///CLFS_LSN_INVALID.
    CLS_LSN RestartLsn;
    ///The unique identifier for a log.
    GUID    Identity;
}

struct CLFS_LOG_NAME_INFORMATION
{
    ushort    NameLengthInBytes;
    ushort[1] Name;
}

struct CLFS_STREAM_ID_INFORMATION
{
    ubyte StreamIdentifier;
}

struct CLFS_PHYSICAL_LSN_INFORMATION
{
    ubyte   StreamIdentifier;
    CLS_LSN VirtualLsn;
    CLS_LSN PhysicalLsn;
}

///Describes general information about a container. The CreateLogContainerScanContext and ScanLogContainers functions
///use container descriptors to scan and return information about all Common Log File System (CLFS) containers.
struct CLS_CONTAINER_INFORMATION
{
    ///The file system attributes. CLFS uses the following attributes: <ul> <li>FILE_ATTRIBUTE_ARCHIVE - The log is not
    ///ephemeral. </li> <li>FILE_ATTRIBUTE_DEDICATED - The log is not multiplexed. </li> <li>FILE_ATTRIBUTE_READONLY -
    ///The file is read-only. Applications can read the file, but cannot write to it or delete it.</li> </ul> CLFS
    ///ignores but preserves all other file attribute values. The SetFileAttributes topic lists the valid values for
    ///attributes.
    uint        FileAttributes;
    ///The time a file is created.
    ulong       CreationTime;
    ///The last time a container is read from or written to.
    ulong       LastAccessTime;
    ///The last time a container is written to.
    ulong       LastWriteTime;
    ///The size of a container, in bytes.
    long        ContainerSize;
    ///The size of the actual file name, in characters. This number is different than <b>FileNameLength</b> when the
    ///file name of the container is longer than MAX_PATH_LENGTH.
    uint        FileNameActualLength;
    ///The size of the file name in the <i>FileName</i> buffer, in characters.
    uint        FileNameLength;
    ///A pointer to a string that contains the file name for a container.
    ushort[256] FileName;
    ///The current state of a container. This member can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="ClfsContainerInitializing"></a><a
    ///id="clfscontainerinitializing"></a><a id="CLFSCONTAINERINITIALIZING"></a><dl>
    ///<dt><b>ClfsContainerInitializing</b></dt> </dl> </td> <td width="60%"> The container is in the process of
    ///initializing. </td> </tr> <tr> <td width="40%"><a id="ClfsContainerInactive"></a><a
    ///id="clfscontainerinactive"></a><a id="CLFSCONTAINERINACTIVE"></a><dl> <dt><b>ClfsContainerInactive</b></dt> </dl>
    ///</td> <td width="60%"> The container is allocated, but is not in the active region of the log. </td> </tr> <tr>
    ///<td width="40%"><a id="ClfsContainerActive"></a><a id="clfscontaineractive"></a><a
    ///id="CLFSCONTAINERACTIVE"></a><dl> <dt><b>ClfsContainerActive</b></dt> </dl> </td> <td width="60%"> The container
    ///is being used as storage for part of the log. </td> </tr> <tr> <td width="40%"><a
    ///id="ClfsContainerActivePendingDelete"></a><a id="clfscontaineractivependingdelete"></a><a
    ///id="CLFSCONTAINERACTIVEPENDINGDELETE"></a><dl> <dt><b>ClfsContainerActivePendingDelete</b></dt> </dl> </td> <td
    ///width="60%"> The container is marked for deletion, but still contains part of the active log. </td> </tr> <tr>
    ///<td width="40%"><a id="ClfsContainerPendingArchive"></a><a id="clfscontainerpendingarchive"></a><a
    ///id="CLFSCONTAINERPENDINGARCHIVE"></a><dl> <dt><b>ClfsContainerPendingArchive</b></dt> </dl> </td> <td
    ///width="60%"> The container is marked for archive. </td> </tr> <tr> <td width="40%"><a
    ///id="ClfsContainerPendingArchiveAndDelete"></a><a id="clfscontainerpendingarchiveanddelete"></a><a
    ///id="CLFSCONTAINERPENDINGARCHIVEANDDELETE"></a><dl> <dt><b>ClfsContainerPendingArchiveAndDelete</b></dt> </dl>
    ///</td> <td width="60%"> The container is marked for deletion, but still contains log data that is not archived.
    ///</td> </tr> </table>
    uint        State;
    ///The physical container identifier that cannot be changed.
    uint        PhysicalContainerId;
    ///The logical container identifier that changes every time the container is recycled.
    uint        LogicalContainerId;
}

///Header for information retrieved by the GetLogIoStatistics function, which defines the I/O performance counters of a
///log.
struct CLS_IO_STATISTICS_HEADER
{
    ///The major version of the statistics buffer.
    ubyte              ubMajorVersion;
    ///The minor version of the statistics buffer.
    ubyte              ubMinorVersion;
    ///The class of I/O statistics that is exported. Currently, flush statistics are the only statistics information
    ///exported. These statistics include the frequency of data and metadata flushes on a dedicated log and the amount
    ///of data and metadata flushed. Because flush statistics are the sole statistics class, this member is currently
    ///unused but will be used in the future.
    CLFS_IOSTATS_CLASS eStatsClass;
    ///The length of the statistics buffer, including the header.
    ushort             cbLength;
    ///The offset of statistics counters from the beginning of the packet where the statistics data begins. This field
    ///allows transparent modifications to the header and length without affecting how the statistics data is accessed.
    uint               coffData;
}

///Defines the statistics that are reported by GetLogIoStatistics. Initially, statistics packets report only flush
///statistics, including the frequency of data and metadata flushes on a physical log and the amount of data and
///metadata flushed. The flush statistics are defined by the following I/O statistics packet types.
struct CLS_IO_STATISTICS
{
    ///The header for the statistics buffer.
    CLS_IO_STATISTICS_HEADER hdrIoStats;
    ///The frequency of data flushes for the logging session.
    ulong cFlush;
    ///The cumulative number of bytes of data flushed in the logging session.
    ulong cbFlush;
    ///The frequency of metadata flushes for the logging session.
    ulong cMetaFlush;
    ///The cumulative number of bytes of metadata flushed in the logging session.
    ulong cbMetaFlush;
}

///Contains information about the containers that are being scanned by ScanLogContainers, the kind of scan that is being
///performed, and a cursor to track which containers have been scanned.
struct CLS_SCAN_CONTEXT
{
    ///The ID of the current node. For more information, see CLFS_NODE_ID.
    CLFS_NODE_ID cidNode;
    ///A handle to the log being scanned that is obtained from CreateLogFile with permissions to scan the log
    ///containers.
    HANDLE       hLog;
    ///The index of the current container.
    uint         cIndex;
    ///The number of system-allocated CLFS_CONTAINER_INFORMATION structures in an array that is pointed to by
    ///<b>pinfoContainer</b>. That is, this member is the number of containers to scan with each scan call. The caller
    ///knows the scan is complete when the number of containers returned is less than this value.
    uint         cContainers;
    ///The number of containers that are returned after a call to ScanLogContainers.
    uint         cContainersReturned;
    ///The mode in which containers are scanned. Containers can be scanned in one of the following modes. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CLFS_SCAN_INIT"></a><a
    ///id="clfs_scan_init"></a><dl> <dt><b>CLFS_SCAN_INIT</b></dt> </dl> </td> <td width="60%"> Initializes the scan
    ///context, but does not allocate associated storage. The initialization is destructive, because all data that is
    ///stored in the current scan context is lost. </td> </tr> <tr> <td width="40%"><a id="CLFS_SCAN_CLOSE"></a><a
    ///id="clfs_scan_close"></a><dl> <dt><b>CLFS_SCAN_CLOSE</b></dt> </dl> </td> <td width="60%"> Uninitializes the scan
    ///context and deallocates system storage that is associated with a scan context. </td> </tr> <tr> <td
    ///width="40%"><a id="CLFS_SCAN_FORWARD"></a><a id="clfs_scan_forward"></a><dl> <dt><b>CLFS_SCAN_FORWARD</b></dt>
    ///</dl> </td> <td width="60%"> Causes the next call to ScanLogContainers to proceed in a forward direction. Cannot
    ///be used if <b>CLFS_SCAN_BACKWARD</b> is specified. </td> </tr> <tr> <td width="40%"><a
    ///id="CLFS_SCAN_BACKWARD"></a><a id="clfs_scan_backward"></a><dl> <dt><b>CLFS_SCAN_BACKWARD</b></dt> </dl> </td>
    ///<td width="60%"> Causes the next call to ScanLogContainers to proceed in a backward direction. Cannot be used if
    ///<b>CLFS_SCAN_FORWARD</b> is specified. </td> </tr> </table>
    ubyte        eScanMode;
    ///A pointer to a client-allocated array of CLFS_CONTAINER_INFORMATION structures to be filled by ScanLogContainers
    ///after each successful call.
    CLS_CONTAINER_INFORMATION* pinfoContainer;
}

///Used by the GetNextLogArchiveExtent function to return information about log archive extents.
struct CLS_ARCHIVE_DESCRIPTOR
{
    ///The offset in the container to the first byte of the archive extent.
    ulong coffLow;
    ///The offset in the container to the last byte of the archive extent.
    ulong coffHigh;
    ///The container information structure that describes the container associated with the archive extent. For more
    ///information, see CLFS_CONTAINER_INFORMATION.
    CLS_CONTAINER_INFORMATION infoContainer;
}

///The <b>CLFS_MGMT_POLICY</b> structure specifies a Common Log File System (CLFS) management policy. The
///<b>PolicyType</b> member specifies the members used for a policy.
struct CLFS_MGMT_POLICY
{
    ///Specifies the version of the log manager headers that the application is compiled with. Set this to
    ///CLFS_MGMT_POLICY_VERSION.
    uint Version;
    ///Specifies the length of the entire structure.
    uint LengthInBytes;
    ///Reserved. Specify zero.
    uint PolicyFlags;
    ///Specifies the members used for a specific policy. Valid values are specified by CLFS_MGMT_POLICY_TYPE.
    CLFS_MGMT_POLICY_TYPE PolicyType;
    union PolicyParameters
    {
        struct MaximumSize
        {
            uint Containers;
        }
        struct MinimumSize
        {
            uint Containers;
        }
        struct NewContainerSize
        {
            uint SizeInBytes;
        }
        struct GrowthRate
        {
            uint AbsoluteGrowthInContainers;
            uint RelativeGrowthPercentage;
        }
        struct LogTail
        {
            uint MinimumAvailablePercentage;
            uint MinimumAvailableContainers;
        }
        struct AutoShrink
        {
            uint Percentage;
        }
        struct AutoGrow
        {
            uint Enabled;
        }
        struct NewContainerPrefix
        {
            ushort    PrefixLengthInBytes;
            ushort[1] PrefixString;
        }
        struct NewContainerSuffix
        {
            ulong NextContainerSuffix;
        }
        struct NewContainerExtension
        {
            ushort    ExtensionLengthInBytes;
            ushort[1] ExtensionString;
        }
    }
}

///The <b>CLFS_MGMT_NOTIFICATION</b> structure specifies information about the notifications that the client receives.
struct CLFS_MGMT_NOTIFICATION
{
    ///The type of notification to receive. The following values are valid. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="ClfsMgmtAdvanceTailNotification"></a><a
    ///id="clfsmgmtadvancetailnotification"></a><a id="CLFSMGMTADVANCETAILNOTIFICATION"></a><dl>
    ///<dt><b>ClfsMgmtAdvanceTailNotification</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> The notification to
    ///advance the log tail. For more information, see LOG_TAIL_ADVANCE_CALLBACK. </td> </tr> <tr> <td width="40%"><a
    ///id="ClfsMgmtLogFullHandlerNotification"></a><a id="clfsmgmtlogfullhandlernotification"></a><a
    ///id="CLFSMGMTLOGFULLHANDLERNOTIFICATION"></a><dl> <dt><b>ClfsMgmtLogFullHandlerNotification</b></dt> <dt>1</dt>
    ///</dl> </td> <td width="60%"> The notification that a call to HandleLogFull is complete. For more information, see
    ///LOG_FULL_HANDLER_CALLBACK. </td> </tr> <tr> <td width="40%"><a id="ClfsMgmtLogUnpinnedNotification"></a><a
    ///id="clfsmgmtlogunpinnednotification"></a><a id="CLFSMGMTLOGUNPINNEDNOTIFICATION"></a><dl>
    ///<dt><b>ClfsMgmtLogUnpinnedNotification</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The notification that the
    ///log is unpinned. For more information, see LOG_UNPINNED_CALLBACK. </td> </tr> <tr> <td width="40%"><a
    ///id="ClfsMgmtLogWriteNotification"></a><a id="clfsmgmtlogwritenotification"></a><a
    ///id="CLFSMGMTLOGWRITENOTIFICATION"></a><dl> <dt><b>ClfsMgmtLogWriteNotification</b></dt> <dt>3</dt> </dl> </td>
    ///<td width="60%"> The notification that a nonzero number of bytes has been written to the log. For more
    ///information, see RegisterForLogWriteNotification. <b>Windows Server 2003 R2 and Windows Vista before SP1:
    ///</b>This value is not supported. </td> </tr> </table>
    CLFS_MGMT_NOTIFICATION_TYPE Notification;
    ///If <b>Notification</b> is <b>ClfsMgmtAdvanceTailNotification</b>, <b>Lsn</b> specifies the target log sequence
    ///number (LSN) the client should advance the log tail to.
    CLS_LSN Lsn;
    ///If <b>Notification</b> is <b>ClfsMgmtLogUnpinnedNotification</b>, <b>LogIsPinned</b> indicates that the log is
    ///pinned. This member is <b>TRUE</b> if the log is pinned.
    ushort  LogIsPinned;
}

///The <b>LOG_MANAGEMENT_CALLBACKS</b> structure is used to register with the Common Log File System (CLFS) for the
///callbacks that a client program requires information from.
struct LOG_MANAGEMENT_CALLBACKS
{
    ///A pointer to the context which is a client-defined value. CLFS ignores this value other than to pass it with
    ///every callback to the client.
    void* CallbackContext;
    ///Called when the management functionality determines that the client should advance the tail of its log.
    PLOG_TAIL_ADVANCE_CALLBACK AdvanceTailCallback;
    ///Called when an asynchronous request is initiated when HandleLogFull completes.
    PLOG_FULL_HANDLER_CALLBACK LogFullHandlerCallback;
    PLOG_UNPINNED_CALLBACK LogUnpinnedCallback;
}

///Represents the per-user quota information.
struct DISKQUOTA_USER_INFORMATION
{
    ///The disk space charged to the user, in bytes. This is the amount of information stored, not necessarily the
    ///number of bytes used on disk.
    long QuotaUsed;
    ///The warning threshold for the user, in bytes. You can use the IDiskQuotaControl::SetQuotaLogFlags method to
    ///configure the system to generate a system logfile entry when the disk space charged to the user exceeds this
    ///value.
    long QuotaThreshold;
    ///The quota limit for the user, in bytes. If this value is -1, the user has an unlimited quota. You can use the
    ///IDiskQuotaControl::SetQuotaLogFlags method to configure the system to generate a system logfile entry when the
    ///disk space charged to the user exceeds this value. You can also use the IDiskQuotaControl::SetQuotaState method
    ///to configure the system to deny additional disk space to the user when the disk space charged to the user exceeds
    ///this value.
    long QuotaLimit;
}

///Defines metadata specific to each WIM data source hosted on a volume.
struct WIM_ENTRY_INFO
{
    ///Specifies the size of the structure. Should be initialized to sizeof(WIM_ENTRY_INFO).
    uint          WimEntryInfoSize;
    ///Specifies the type of the WIM. Valid values are WIM_BOOT_OS_WIM and zero, which implies the WIM is not an
    ///operating system WIM.
    uint          WimType;
    ///Specifies a unique identifier for this data source.
    LARGE_INTEGER DataSourceId;
    ///Specifies the GUID which is stored in the WIM file’s header.
    GUID          WimGuid;
    ///Specifies a full path to the WIM file.
    const(wchar)* WimPath;
    ///Specifies the index within the WIM which is described by this data source.
    uint          WimIndex;
    uint          Flags;
}

///Defines metadata specific to files provided by WOF_PROVIDER_WIM.
struct WIM_EXTERNAL_FILE_INFO
{
    ///Specifies the data source from which the file’s data is being provided.
    LARGE_INTEGER DataSourceId;
    ubyte[20]     ResourceHash;
    ///Specifies one or more flags for this data file. When creating a new backed file, this member should be zero. When
    ///querying the state of an existing file, this member can include WIM_ENTRY_FLAG_NOT_ACTIVE, indicating the data
    ///source is removed or the WIM file is not found, or WIM_ENTRY_FLAG_SUSPENDED indicating that the data source is
    ///not currently in use but could become in use on demand.
    uint          Flags;
}

struct WOF_FILE_COMPRESSION_INFO_V0
{
    uint Algorithm;
}

///Defines metadata specific to files provided by WOF_PROVIDER_FILE.
struct WOF_FILE_COMPRESSION_INFO_V1
{
    ///Specifies the compression algorithm that is used to compress this file. Currently defined algorithms are: <table>
    ///<tr> <td>FILE_PROVIDER_COMPRESSION_XPRESS4K</td> <td>Indicates that the data for the file should be compressed in
    ///4kb chunks with the XPress algorithm. This algorithm is designed to be computationally lightweight, and provides
    ///for rapid access to data.</td> </tr> <tr> <td>FILE_PROVIDER_COMPRESSION_LZX</td> <td>Indicates that the data for
    ///the file should be compressed in 32kb chunks with the LZX algorithm. This algorithm is designed to be highly
    ///compact, and provides for small footprint for infrequently accessed data.</td> </tr> <tr>
    ///<td>FILE_PROVIDER_COMPRESSION_XPRESS8K</td> <td>Indicates that the data for the file should be compressed in 8kb
    ///chunks with the XPress algorithm.</td> </tr> <tr> <td>FILE_PROVIDER_COMPRESSION_XPRESS16K</td> <td>Indicates that
    ///the data for the file should be compressed in 16kb chunks with the XPress algorithm.</td> </tr> </table>
    uint Algorithm;
    uint Flags;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Represents a unique
///identifier within the context of the Resource Manager.
struct TXF_ID
{
    struct
    {
    align (4):
        long LowPart;
        long HighPart;
    }
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains the basic record
///information.
struct TXF_LOG_RECORD_BASE
{
    ///The version identifier for the replication record.
    ushort Version;
    ///The record type. This member can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="TXF_LOG_RECORD_TYPE_AFFECTED_FILE"></a><a
    ///id="txf_log_record_type_affected_file"></a><dl> <dt><b>TXF_LOG_RECORD_TYPE_AFFECTED_FILE</b></dt> <dt>4</dt>
    ///</dl> </td> <td width="60%"> The record is a TXF_LOG_RECORD_AFFECTED_FILE structure. </td> </tr> <tr> <td
    ///width="40%"><a id="TXF_LOG_RECORD_TYPE_TRUNCATE"></a><a id="txf_log_record_type_truncate"></a><dl>
    ///<dt><b>TXF_LOG_RECORD_TYPE_TRUNCATE</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The record is a
    ///TXF_LOG_RECORD_TRUNCATE structure. </td> </tr> <tr> <td width="40%"><a id="TXF_LOG_RECORD_TYPE_WRITE"></a><a
    ///id="txf_log_record_type_write"></a><dl> <dt><b>TXF_LOG_RECORD_TYPE_WRITE</b></dt> <dt>1</dt> </dl> </td> <td
    ///width="60%"> The record is a TXF_LOG_RECORD_WRITE structure. </td> </tr> </table>
    ushort RecordType;
    ///The length of this record, in bytes.
    uint   RecordLength;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains the record for a
///write operation.
struct TXF_LOG_RECORD_WRITE
{
align (4):
    ///The version identifier for the replication record.
    ushort Version;
    ///The record type. This member is set to <b>TXF_LOG_RECORD_TYPE_WRITE</b>.
    ushort RecordType;
    ///The length of this record, in bytes.
    uint   RecordLength;
    ///Reserved.
    uint   Flags;
    ///The TxF file identifier for the file associated with this record. For more information, see TXF_ID.
    TXF_ID TxfFileId;
    ///The KTM transaction <b>GUID</b> for this update.
    GUID   KtmGuid;
    ///The starting location of the write operation, as an offset from the beginning of the file.
    long   ByteOffsetInFile;
    ///The number of bytes written.
    uint   NumBytesWritten;
    ///The offset of the data (bytes written) from the beginning of this record.
    uint   ByteOffsetInStructure;
    ///The length of the file name, in bytes.
    uint   FileNameLength;
    ///The offset of the file name from the beginning of this record.
    uint   FileNameByteOffsetInStructure;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains the record for a
///truncate operation.
struct TXF_LOG_RECORD_TRUNCATE
{
align (4):
    ///The version identifier for the replication record.
    ushort Version;
    ///The record type. This member is set to TXF_LOG_RECORD_TYPE_TRUNCATE.
    ushort RecordType;
    ///The length of this record, in bytes.
    uint   RecordLength;
    ///Reserved.
    uint   Flags;
    ///The TxF file identifier for the file associated with this record. For more information, see TXF_ID.
    TXF_ID TxfFileId;
    ///The KTM transaction GUID for this update.
    GUID   KtmGuid;
    ///The new size of the file, in bytes.
    long   NewFileSize;
    ///The length of the file name, in bytes.
    uint   FileNameLength;
    ///The offset of the file name from the beginning of this record.
    uint   FileNameByteOffsetInStructure;
}

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Contains information for
///a file that was affected by a transaction.
struct TXF_LOG_RECORD_AFFECTED_FILE
{
    ///The version identifier for the replication record.
    ushort Version;
    ///The length of this record, in bytes.
    uint   RecordLength;
    ///This member is reserved.
    uint   Flags;
    ///The TxF file identifier for the file associated with this record. For more information, see TXF_ID.
    TXF_ID TxfFileId;
    ///The KTM transaction GUID for this update.
    GUID   KtmGuid;
    ///The length of the file name, in bytes.
    uint   FileNameLength;
    ///The offset of the file name from the beginning of this record.
    uint   FileNameByteOffsetInStructure;
}

struct VOLUME_FAILOVER_SET
{
    uint    NumberOfDisks;
    uint[1] DiskNumbers;
}

struct VOLUME_NUMBER
{
    uint      VolumeNumber;
    ushort[8] VolumeManagerName;
}

struct VOLUME_LOGICAL_OFFSET
{
    long LogicalOffset;
}

struct VOLUME_PHYSICAL_OFFSET
{
    uint DiskNumber;
    long Offset;
}

struct VOLUME_PHYSICAL_OFFSETS
{
    uint NumberOfPhysicalOffsets;
    VOLUME_PHYSICAL_OFFSET[1] PhysicalOffset;
}

struct VOLUME_READ_PLEX_INPUT
{
    LARGE_INTEGER ByteOffset;
    uint          Length;
    uint          PlexNumber;
}

struct VOLUME_SET_GPT_ATTRIBUTES_INFORMATION
{
    ulong  GptAttributes;
    ubyte  RevertOnClose;
    ubyte  ApplyToAllConnectedVolumes;
    ushort Reserved1;
    uint   Reserved2;
}

struct VOLUME_GET_BC_PROPERTIES_INPUT
{
    uint  Version;
    uint  Reserved1;
    ulong LowestByteOffset;
    ulong HighestByteOffset;
    uint  AccessType;
    uint  AccessMode;
}

struct VOLUME_GET_BC_PROPERTIES_OUTPUT
{
    uint  MaximumRequestsPerPeriod;
    uint  MinimumPeriod;
    ulong MaximumRequestSize;
    uint  EstimatedTimePerRequest;
    uint  NumOutStandingRequests;
    ulong RequestSize;
}

struct VOLUME_ALLOCATE_BC_STREAM_INPUT
{
    uint     Version;
    uint     RequestsPerPeriod;
    uint     Period;
    ubyte    RetryFailures;
    ubyte    Discardable;
    ubyte[2] Reserved1;
    ulong    LowestByteOffset;
    ulong    HighestByteOffset;
    uint     AccessType;
    uint     AccessMode;
}

struct VOLUME_ALLOCATE_BC_STREAM_OUTPUT
{
    ulong RequestSize;
    uint  NumOutStandingRequests;
}

struct FILE_EXTENT
{
    ulong VolumeOffset;
    ulong ExtentLength;
}

struct VOLUME_CRITICAL_IO
{
    uint           AccessType;
    uint           ExtentsCount;
    FILE_EXTENT[1] Extents;
}

struct VOLUME_ALLOCATION_HINT_INPUT
{
    uint ClusterSize;
    uint NumberOfClusters;
    long StartingClusterNumber;
}

struct VOLUME_ALLOCATION_HINT_OUTPUT
{
    uint[1] Bitmap;
}

struct VOLUME_SHRINK_INFO
{
    ulong VolumeSize;
}

///Contains the name of the shared resource.
struct SHARE_INFO_0
{
    ///Pointer to a Unicode string specifying the share name of a resource.
    const(wchar)* shi0_netname;
}

///Contains information about the shared resource, including the name and type of the resource, and a comment associated
///with the resource.
struct SHARE_INFO_1
{
    ///Pointer to a Unicode string specifying the share name of a resource. Calls to the NetShareSetInfo function ignore
    ///this member.
    const(wchar)* shi1_netname;
    ///A combination of values that specify the type of the shared resource. Calls to the <b>NetShareSetInfo</b>
    ///function ignore this member. One of the following values may be specified. You can isolate these values by using
    ///the <b>STYPE_MASK</b> value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="STYPE_DISKTREE"></a><a id="stype_disktree"></a><dl> <dt><b>STYPE_DISKTREE</b></dt> </dl> </td> <td
    ///width="60%"> Disk drive. </td> </tr> <tr> <td width="40%"><a id="STYPE_PRINTQ"></a><a id="stype_printq"></a><dl>
    ///<dt><b>STYPE_PRINTQ</b></dt> </dl> </td> <td width="60%"> Print queue. </td> </tr> <tr> <td width="40%"><a
    ///id="STYPE_DEVICE"></a><a id="stype_device"></a><dl> <dt><b>STYPE_DEVICE</b></dt> </dl> </td> <td width="60%">
    ///Communication device. </td> </tr> <tr> <td width="40%"><a id="STYPE_IPC"></a><a id="stype_ipc"></a><dl>
    ///<dt><b>STYPE_IPC</b></dt> </dl> </td> <td width="60%"> Interprocess communication (IPC). </td> </tr> </table> In
    ///addition, one or both of the following values may be specified. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="STYPE_SPECIAL"></a><a id="stype_special"></a><dl> <dt><b>STYPE_SPECIAL</b></dt>
    ///</dl> </td> <td width="60%"> Special share reserved for interprocess communication (IPC$) or remote
    ///administration of the server (ADMIN$). Can also refer to administrative shares such as C$, D$, E$, and so forth.
    ///For more information, see Network Share Functions. </td> </tr> <tr> <td width="40%"><a
    ///id="STYPE_TEMPORARY"></a><a id="stype_temporary"></a><dl> <dt><b>STYPE_TEMPORARY</b></dt> </dl> </td> <td
    ///width="60%"> A temporary share. </td> </tr> </table>
    uint          shi1_type;
    ///Pointer to a Unicode string specifying an optional comment about the shared resource.
    const(wchar)* shi1_remark;
}

///Contains information about the shared resource, including name of the resource, type and permissions, and the number
///of current connections. For more information about controlling access to securable objects, see Access Control,
///Privileges, and Securable Objects.
struct SHARE_INFO_2
{
    ///Pointer to a Unicode string specifying the share name of a resource. Calls to the NetShareSetInfo function ignore
    ///this member.
    const(wchar)* shi2_netname;
    ///A combination of values that specify the type of the shared resource. Calls to the <b>NetShareSetInfo</b>
    ///function ignore this member. One of the following values may be specified. You can isolate these values by using
    ///the <b>STYPE_MASK</b> value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="STYPE_DISKTREE"></a><a id="stype_disktree"></a><dl> <dt><b>STYPE_DISKTREE</b></dt> </dl> </td> <td
    ///width="60%"> Disk drive. </td> </tr> <tr> <td width="40%"><a id="STYPE_PRINTQ"></a><a id="stype_printq"></a><dl>
    ///<dt><b>STYPE_PRINTQ</b></dt> </dl> </td> <td width="60%"> Print queue. </td> </tr> <tr> <td width="40%"><a
    ///id="STYPE_DEVICE"></a><a id="stype_device"></a><dl> <dt><b>STYPE_DEVICE</b></dt> </dl> </td> <td width="60%">
    ///Communication device. </td> </tr> <tr> <td width="40%"><a id="STYPE_IPC"></a><a id="stype_ipc"></a><dl>
    ///<dt><b>STYPE_IPC</b></dt> </dl> </td> <td width="60%"> Interprocess communication (IPC). </td> </tr> </table> In
    ///addition, one or both of the following values may be specified. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="STYPE_SPECIAL"></a><a id="stype_special"></a><dl> <dt><b>STYPE_SPECIAL</b></dt>
    ///</dl> </td> <td width="60%"> Special share reserved for interprocess communication (IPC$) or remote
    ///administration of the server (ADMIN$). Can also refer to administrative shares such as C$, D$, E$, and so forth.
    ///For more information, see Network Share Functions. </td> </tr> <tr> <td width="40%"><a
    ///id="STYPE_TEMPORARY"></a><a id="stype_temporary"></a><dl> <dt><b>STYPE_TEMPORARY</b></dt> </dl> </td> <td
    ///width="60%"> A temporary share. </td> </tr> </table>
    uint          shi2_type;
    ///Pointer to a Unicode string that contains an optional comment about the shared resource.
    const(wchar)* shi2_remark;
    ///Specifies a DWORD value that indicates the shared resource's permissions for servers running with share-level
    ///security. A server running user-level security ignores this member. This member can be one or more of the
    ///following values. Calls to the NetShareSetInfo function ignore this member. Note that Windows does not support
    ///share-level security. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="ACCESS_READ"></a><a id="access_read"></a><dl> <dt><b>ACCESS_READ</b></dt> </dl> </td> <td width="60%">
    ///Permission to read data from a resource and, by default, to execute the resource. </td> </tr> <tr> <td
    ///width="40%"><a id="ACCESS_WRITE"></a><a id="access_write"></a><dl> <dt><b>ACCESS_WRITE</b></dt> </dl> </td> <td
    ///width="60%"> Permission to write data to the resource. </td> </tr> <tr> <td width="40%"><a
    ///id="ACCESS_CREATE"></a><a id="access_create"></a><dl> <dt><b>ACCESS_CREATE</b></dt> </dl> </td> <td width="60%">
    ///Permission to create an instance of the resource (such as a file); data can be written to the resource as the
    ///resource is created. </td> </tr> <tr> <td width="40%"><a id="ACCESS_EXEC"></a><a id="access_exec"></a><dl>
    ///<dt><b>ACCESS_EXEC</b></dt> </dl> </td> <td width="60%"> Permission to execute the resource. </td> </tr> <tr> <td
    ///width="40%"><a id="ACCESS_DELETE"></a><a id="access_delete"></a><dl> <dt><b>ACCESS_DELETE</b></dt> </dl> </td>
    ///<td width="60%"> Permission to delete the resource. </td> </tr> <tr> <td width="40%"><a id="ACCESS_ATRIB"></a><a
    ///id="access_atrib"></a><dl> <dt><b>ACCESS_ATRIB</b></dt> </dl> </td> <td width="60%"> Permission to modify the
    ///resource's attributes (such as the date and time when a file was last modified). </td> </tr> <tr> <td
    ///width="40%"><a id="ACCESS_PERM"></a><a id="access_perm"></a><dl> <dt><b>ACCESS_PERM</b></dt> </dl> </td> <td
    ///width="60%"> Permission to modify the permissions (read, write, create, execute, and delete) assigned to a
    ///resource for a user or application. </td> </tr> <tr> <td width="40%"><a id="ACCESS_ALL"></a><a
    ///id="access_all"></a><dl> <dt><b>ACCESS_ALL</b></dt> </dl> </td> <td width="60%"> Permission to read, write,
    ///create, execute, and delete resources, and to modify their attributes and permissions. </td> </tr> </table>
    uint          shi2_permissions;
    ///Specifies a DWORD value that indicates the maximum number of concurrent connections that the shared resource can
    ///accommodate. The number of connections is unlimited if the value specified in this member is –1.
    uint          shi2_max_uses;
    ///Specifies a DWORD value that indicates the number of current connections to the resource. Calls to the
    ///NetShareSetInfo function ignore this member.
    uint          shi2_current_uses;
    ///Pointer to a Unicode string specifying the local path for the shared resource. For disks, <b>shi2_path</b> is the
    ///path being shared. For print queues, <b>shi2_path</b> is the name of the print queue being shared. Calls to the
    ///<b>NetShareSetInfo</b> function ignore this member.
    const(wchar)* shi2_path;
    ///Pointer to a Unicode string that specifies the share's password when the server is running with share-level
    ///security. If the server is running with user-level security, this member is ignored. The <b>shi2_passwd</b>
    ///member can be no longer than SHPWLEN+1 bytes (including a terminating null character). Calls to the
    ///<b>NetShareSetInfo</b> function ignore this member. Note that Windows does not support share-level security.
    const(wchar)* shi2_passwd;
}

///Contains information about the shared resource including the name and type of the resource, and a comment associated
///with the resource.
struct SHARE_INFO_501
{
    ///Pointer to a Unicode string specifying the name of a shared resource.
    const(wchar)* shi501_netname;
    ///A combination of values that specify the type of share. One of the following values may be specified. You can
    ///isolate these values by using the <b>STYPE_MASK</b> value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="STYPE_DISKTREE"></a><a id="stype_disktree"></a><dl> <dt><b>STYPE_DISKTREE</b></dt>
    ///</dl> </td> <td width="60%"> Disk drive. </td> </tr> <tr> <td width="40%"><a id="STYPE_PRINTQ"></a><a
    ///id="stype_printq"></a><dl> <dt><b>STYPE_PRINTQ</b></dt> </dl> </td> <td width="60%"> Print queue. </td> </tr>
    ///<tr> <td width="40%"><a id="STYPE_DEVICE"></a><a id="stype_device"></a><dl> <dt><b>STYPE_DEVICE</b></dt> </dl>
    ///</td> <td width="60%"> Communication device. </td> </tr> <tr> <td width="40%"><a id="STYPE_IPC"></a><a
    ///id="stype_ipc"></a><dl> <dt><b>STYPE_IPC</b></dt> </dl> </td> <td width="60%"> Interprocess communication (IPC).
    ///</td> </tr> </table> In addition, one or both of the following values may be specified. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="STYPE_SPECIAL"></a><a
    ///id="stype_special"></a><dl> <dt><b>STYPE_SPECIAL</b></dt> </dl> </td> <td width="60%"> Special share reserved for
    ///interprocess communication (IPC$) or remote administration of the server (ADMIN$). Can also refer to
    ///administrative shares such as C$, D$, E$, and so forth. For more information, see Network Share Functions. </td>
    ///</tr> <tr> <td width="40%"><a id="STYPE_TEMPORARY"></a><a id="stype_temporary"></a><dl>
    ///<dt><b>STYPE_TEMPORARY</b></dt> </dl> </td> <td width="60%"> A temporary share. </td> </tr> </table>
    uint          shi501_type;
    ///Pointer to a Unicode string specifying an optional comment about the shared resource.
    const(wchar)* shi501_remark;
    ///Reserved; must be zero.
    uint          shi501_flags;
}

///Contains information about the shared resource, including name of the resource, type and permissions, number of
///connections, and other pertinent information.
struct SHARE_INFO_502
{
    ///Pointer to a Unicode string specifying the name of a shared resource. Calls to the NetShareSetInfo function
    ///ignore this member.
    const(wchar)* shi502_netname;
    ///A combination of values that specify the type of share. Calls to the <b>NetShareSetInfo</b> function ignore this
    ///member. One of the following values may be specified. You can isolate these values by using the <b>STYPE_MASK</b>
    ///value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="STYPE_DISKTREE"></a><a
    ///id="stype_disktree"></a><dl> <dt><b>STYPE_DISKTREE</b></dt> </dl> </td> <td width="60%"> Disk Drive. </td> </tr>
    ///<tr> <td width="40%"><a id="STYPE_PRINTQ"></a><a id="stype_printq"></a><dl> <dt><b>STYPE_PRINTQ</b></dt> </dl>
    ///</td> <td width="60%"> Print Queue. </td> </tr> <tr> <td width="40%"><a id="STYPE_DEVICE"></a><a
    ///id="stype_device"></a><dl> <dt><b>STYPE_DEVICE</b></dt> </dl> </td> <td width="60%"> Communication device. </td>
    ///</tr> <tr> <td width="40%"><a id="STYPE_IPC"></a><a id="stype_ipc"></a><dl> <dt><b>STYPE_IPC</b></dt> </dl> </td>
    ///<td width="60%"> Interprocess communication (IPC). </td> </tr> </table> In addition, one or both of the following
    ///values may be specified. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="STYPE_SPECIAL"></a><a id="stype_special"></a><dl> <dt><b>STYPE_SPECIAL</b></dt> </dl> </td> <td width="60%">
    ///Special share reserved for interprocess communication (IPC$) or remote administration of the server (ADMIN$). Can
    ///also refer to administrative shares such as C$, D$, E$, and so forth. For more information, see the network share
    ///functions. </td> </tr> <tr> <td width="40%"><a id="STYPE_TEMPORARY"></a><a id="stype_temporary"></a><dl>
    ///<dt><b>STYPE_TEMPORARY</b></dt> </dl> </td> <td width="60%"> A temporary share. </td> </tr> </table>
    uint          shi502_type;
    ///Pointer to a Unicode string specifying an optional comment about the shared resource.
    const(wchar)* shi502_remark;
    ///Specifies a DWORD value that indicates the shared resource's permissions for servers running with share-level
    ///security. This member is ignored on a server running user-level security. This member can be any of the following
    ///values. Calls to the NetShareSetInfo function ignore this member. Note that Windows does not support share-level
    ///security. For more information about controlling access to securable objects, see Access Control, Privileges, and
    ///Securable Objects. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="ACCESS_READ"></a><a id="access_read"></a><dl> <dt><b>ACCESS_READ</b></dt> </dl> </td> <td width="60%">
    ///Permission to read data from a resource and, by default, to execute the resource. </td> </tr> <tr> <td
    ///width="40%"><a id="ACCESS_WRITE"></a><a id="access_write"></a><dl> <dt><b>ACCESS_WRITE</b></dt> </dl> </td> <td
    ///width="60%"> Permission to write data to the resource. </td> </tr> <tr> <td width="40%"><a
    ///id="ACCESS_CREATE"></a><a id="access_create"></a><dl> <dt><b>ACCESS_CREATE</b></dt> </dl> </td> <td width="60%">
    ///Permission to create an instance of the resource (such as a file); data can be written to the resource as the
    ///resource is created. </td> </tr> <tr> <td width="40%"><a id="ACCESS_EXEC"></a><a id="access_exec"></a><dl>
    ///<dt><b>ACCESS_EXEC</b></dt> </dl> </td> <td width="60%"> Permission to execute the resource. </td> </tr> <tr> <td
    ///width="40%"><a id="ACCESS_DELETE"></a><a id="access_delete"></a><dl> <dt><b>ACCESS_DELETE</b></dt> </dl> </td>
    ///<td width="60%"> Permission to delete the resource. </td> </tr> <tr> <td width="40%"><a id="ACCESS_ATRIB"></a><a
    ///id="access_atrib"></a><dl> <dt><b>ACCESS_ATRIB</b></dt> </dl> </td> <td width="60%"> Permission to modify the
    ///resource's attributes (such as the date and time when a file was last modified). </td> </tr> <tr> <td
    ///width="40%"><a id="ACCESS_PERM"></a><a id="access_perm"></a><dl> <dt><b>ACCESS_PERM</b></dt> </dl> </td> <td
    ///width="60%"> Permission to modify the permissions (read, write, create, execute, and delete) assigned to a
    ///resource for a user or application. </td> </tr> <tr> <td width="40%"><a id="ACCESS_ALL"></a><a
    ///id="access_all"></a><dl> <dt><b>ACCESS_ALL</b></dt> </dl> </td> <td width="60%"> Permission to read, write,
    ///create, execute, and delete resources, and to modify their attributes and permissions. </td> </tr> </table>
    uint          shi502_permissions;
    ///Specifies a DWORD value that indicates the maximum number of concurrent connections that the shared resource can
    ///accommodate. The number of connections is unlimited if the value specified in this member is –1.
    uint          shi502_max_uses;
    ///Specifies a DWORD value that indicates the number of current connections to the resource. Calls to the
    ///NetShareSetInfo function ignore this member.
    uint          shi502_current_uses;
    ///Pointer to a Unicode string that contains the local path for the shared resource. For disks, this member is the
    ///path being shared. For print queues, this member is the name of the print queue being shared. Calls to the
    ///<b>NetShareSetInfo</b> function ignore this member.
    const(wchar)* shi502_path;
    ///Pointer to a Unicode string that specifies the share's password (when the server is running with share-level
    ///security). If the server is running with user-level security, this member is ignored. Note that Windows does not
    ///support share-level security. This member can be no longer than SHPWLEN+1 bytes (including a terminating null
    ///character). Calls to the <b>NetShareSetInfo</b> function ignore this member.
    const(wchar)* shi502_passwd;
    ///Reserved; must be zero. Calls to the NetShareSetInfo function ignore this member.
    uint          shi502_reserved;
    ///Specifies the SECURITY_DESCRIPTOR associated with this share.
    void*         shi502_security_descriptor;
}

///Contains information about the shared resource. It is identical to the SHARE_INFO_502 structure, except that it also
///contains the server name.
struct SHARE_INFO_503
{
    ///A pointer to a Unicode string specifying the name of a shared resource. Calls to the NetShareSetInfo function
    ///ignore this member.
    const(wchar)* shi503_netname;
    ///A combination of values that specify the type of share. Calls to the NetShareSetInfo function ignore this member.
    ///One of the following values may be specified. You can isolate these values by using the <b>STYPE_MASK</b> value.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="STYPE_DISKTREE"></a><a
    ///id="stype_disktree"></a><dl> <dt><b>STYPE_DISKTREE</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> Disk
    ///drive. </td> </tr> <tr> <td width="40%"><a id="STYPE_PRINTQ"></a><a id="stype_printq"></a><dl>
    ///<dt><b>STYPE_PRINTQ</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Print queue. </td> </tr> <tr> <td
    ///width="40%"><a id="STYPE_DEVICE"></a><a id="stype_device"></a><dl> <dt><b>STYPE_DEVICE</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> Communication device. </td> </tr> <tr> <td width="40%"><a
    ///id="STYPE_IPC"></a><a id="stype_ipc"></a><dl> <dt><b>STYPE_IPC</b></dt> <dt>0x00000003</dt> </dl> </td> <td
    ///width="60%"> Interprocess communication (IPC). </td> </tr> </table> In addition, one or both of the following
    ///values may be specified. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="STYPE_SPECIAL"></a><a id="stype_special"></a><dl> <dt><b>STYPE_SPECIAL</b></dt> <dt>0x80000000</dt> </dl>
    ///</td> <td width="60%"> Special share reserved for interprocess communication (IPC$) or remote administration of
    ///the server (ADMIN$). Can also refer to administrative shares such as C$, D$, E$, and so forth. For more
    ///information, see the network share functions. </td> </tr> <tr> <td width="40%"><a id="STYPE_TEMPORARY"></a><a
    ///id="stype_temporary"></a><dl> <dt><b>STYPE_TEMPORARY</b></dt> <dt>0x40000000</dt> </dl> </td> <td width="60%"> A
    ///temporary share. </td> </tr> </table>
    uint          shi503_type;
    ///A pointer to a Unicode string specifying an optional comment about the shared resource.
    const(wchar)* shi503_remark;
    ///Specifies a DWORD value that indicates the shared resource's permissions for servers running with share-level
    ///security. Note that Windows does not support share-level security. This member is ignored on a server running
    ///user-level security. For more information about controlling access to securable objects, see Access Control,
    ///Privileges, and Securable Objects. Calls to the NetShareSetInfo function ignore this member. This member can be
    ///any of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="ACCESS_READ"></a><a id="access_read"></a><dl> <dt><b>ACCESS_READ</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> Permission to read data from a resource and, by default, to execute the resource. </td> </tr> <tr>
    ///<td width="40%"><a id="ACCESS_WRITE"></a><a id="access_write"></a><dl> <dt><b>ACCESS_WRITE</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> Permission to write data to the resource. </td> </tr> <tr> <td
    ///width="40%"><a id="ACCESS_CREATE"></a><a id="access_create"></a><dl> <dt><b>ACCESS_CREATE</b></dt>
    ///<dt>0x00000004</dt> </dl> </td> <td width="60%"> Permission to create an instance of the resource (such as a
    ///file); data can be written to the resource as the resource is created. </td> </tr> <tr> <td width="40%"><a
    ///id="ACCESS_EXEC"></a><a id="access_exec"></a><dl> <dt><b>ACCESS_EXEC</b></dt> <dt>0x00000008</dt> </dl> </td> <td
    ///width="60%"> Permission to execute the resource. </td> </tr> <tr> <td width="40%"><a id="ACCESS_DELETE"></a><a
    ///id="access_delete"></a><dl> <dt><b>ACCESS_DELETE</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%">
    ///Permission to delete the resource. </td> </tr> <tr> <td width="40%"><a id="ACCESS_ATRIB"></a><a
    ///id="access_atrib"></a><dl> <dt><b>ACCESS_ATRIB</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%">
    ///Permission to modify the resource's attributes (such as the date and time when a file was last modified). </td>
    ///</tr> <tr> <td width="40%"><a id="ACCESS_PERM"></a><a id="access_perm"></a><dl> <dt><b>ACCESS_PERM</b></dt>
    ///<dt>0x00000040</dt> </dl> </td> <td width="60%"> Permission to modify the permissions (read, write, create,
    ///execute, and delete) assigned to a resource for a user or application. </td> </tr> <tr> <td width="40%"><a
    ///id="ACCESS_ALL"></a><a id="access_all"></a><dl> <dt><b>ACCESS_ALL</b></dt> <dt>0x00008000</dt> </dl> </td> <td
    ///width="60%"> Permission to read, write, create, execute, and delete resources, and to modify their attributes and
    ///permissions. </td> </tr> </table>
    uint          shi503_permissions;
    ///Specifies a DWORD value that indicates the maximum number of concurrent connections that the shared resource can
    ///accommodate. The number of connections is unlimited if the value specified in this member is –1.
    uint          shi503_max_uses;
    ///Specifies a DWORD value that indicates the number of current connections to the resource. Calls to the
    ///NetShareSetInfo function ignore this member.
    uint          shi503_current_uses;
    ///A pointer to a Unicode string that contains the local path for the shared resource. For disks, this member is the
    ///path being shared. For print queues, this member is the name of the print queue being shared. Calls to the
    ///NetShareSetInfo function ignore this member.
    const(wchar)* shi503_path;
    ///A pointer to a Unicode string that specifies the share's password (when the server is running with share-level
    ///security). If the server is running with user-level security, this member is ignored. Note that Windows does not
    ///support share-level security. This member can be no longer than SHPWLEN+1 bytes (including a terminating null
    ///character). Calls to the NetShareSetInfo function ignore this member.
    const(wchar)* shi503_passwd;
    ///A pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the shared resource
    ///resides. A value of "*" indicates no configured server name.
    const(wchar)* shi503_servername;
    ///Reserved; must be zero. Calls to the NetShareSetInfo function ignore this member.
    uint          shi503_reserved;
    ///Specifies the SECURITY_DESCRIPTOR associated with this share.
    void*         shi503_security_descriptor;
}

///Contains a comment associated with the shared resource.
struct SHARE_INFO_1004
{
    ///Pointer to a Unicode string that contains an optional comment about the shared resource.
    const(wchar)* shi1004_remark;
}

///Contains information about the shared resource.
struct SHARE_INFO_1005
{
    ///A bitmask of flags that specify information about the shared resource. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="SHI1005_FLAGS_DFS"></a><a id="shi1005_flags_dfs"></a><dl>
    ///<dt><b><b>SHI1005_FLAGS_DFS</b></b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> The specified share is
    ///present in a Dfs tree structure. This flag cannot be set with NetShareSetInfo. </td> </tr> <tr> <td
    ///width="40%"><a id="SHI1005_FLAGS_DFS_ROOT"></a><a id="shi1005_flags_dfs_root"></a><dl>
    ///<dt><b><b>SHI1005_FLAGS_DFS_ROOT</b></b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> The specified share is
    ///the root volume in a Dfs tree structure. This flag cannot be set with NetShareSetInfo. </td> </tr> <tr> <td
    ///width="40%"><a id="SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS"></a><a
    ///id="shi1005_flags_restrict_exclusive_opens"></a><dl>
    ///<dt><b><b>SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS</b></b></dt> <dt>0x0100</dt> </dl> </td> <td width="60%"> The
    ///specified share disallows exclusive file opens, where reads to an open file are disallowed. </td> </tr> <tr> <td
    ///width="40%"><a id="SHI1005_FLAGS_FORCE_SHARED_DELETE"></a><a id="shi1005_flags_force_shared_delete"></a><dl>
    ///<dt><b><b>SHI1005_FLAGS_FORCE_SHARED_DELETE</b></b></dt> <dt>0x0200</dt> </dl> </td> <td width="60%"> Shared
    ///files in the specified share can be forcibly deleted. </td> </tr> <tr> <td width="40%"><a
    ///id="SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING"></a><a id="shi1005_flags_allow_namespace_caching"></a><dl>
    ///<dt><b><b>SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING</b></b></dt> <dt>0x0400</dt> </dl> </td> <td width="60%"> Clients
    ///are allowed to cache the namespace of the specified share. </td> </tr> <tr> <td width="40%"><a
    ///id="SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM"></a><a id="shi1005_flags_access_based_directory_enum"></a><dl>
    ///<dt><b><b>SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM</b></b></dt> <dt>0x0800</dt> </dl> </td> <td width="60%"> The
    ///server will filter directory entries based on the access permissions that the user on the client computer has for
    ///the server on which the files reside. Only files for which the user has read access and directories for which the
    ///user has FILE_LIST_DIRECTORY access will be returned. If the user has SeBackupPrivilege, all available
    ///information will be returned. For more information about file and directory access, see File Security and Access
    ///Rights. For more information about SeBackupPrivilege, see Privilege Constants. <div class="alert"><b>Note</b>
    ///This flag is supported only on servers running Windows Server 2003 with SP1 or later.</div> <div> </div> </td>
    ///</tr> <tr> <td width="40%"><a id="SHI1005_FLAGS_FORCE_LEVELII_OPLOCK"></a><a
    ///id="shi1005_flags_force_levelii_oplock"></a><dl> <dt><b>SHI1005_FLAGS_FORCE_LEVELII_OPLOCK</b></dt>
    ///<dt>0x1000</dt> </dl> </td> <td width="60%"> Prevents exclusive caching modes that can cause delays for highly
    ///shared read-only data. <div class="alert"><b>Note</b> This flag is supported only on servers running Windows
    ///Server 2008 R2 or later.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a
    ///id="SHI1005_FLAGS_ENABLE_HASH"></a><a id="shi1005_flags_enable_hash"></a><dl>
    ///<dt><b>SHI1005_FLAGS_ENABLE_HASH</b></dt> <dt>0x2000</dt> </dl> </td> <td width="60%"> Enables server-side
    ///functionality needed for peer caching support. Clients on high-latency or low-bandwidth connections can use
    ///alternate methods to retrieve data from peers if available, instead of sending requests to the server. This is
    ///only supported on shares configured for manual caching (CSC_CACHE_MANUAL_REINT). <div class="alert"><b>Note</b>
    ///This flag is supported only on servers running Windows Server 2008 R2 or later.</div> <div> </div> </td> </tr>
    ///<tr> <td width="40%"><a id="SHI1005_FLAGS_ENABLE_CA"></a><a id="shi1005_flags_enable_ca"></a><dl>
    ///<dt><b>SHI1005_FLAGS_ENABLE_CA</b></dt> <dt>0X4000</dt> </dl> </td> <td width="60%"> Enables Continuous
    ///Availability on a cluster share. Handles that are opened against a continuously available share can survive
    ///network failures as well as cluster node failures. <div class="alert"><b>Note</b> This flag can only be set on a
    ///scoped share on a server that meets the following conditions:<ul> <li>It is running Windows Server 2012 or later.
    ///</li> <li>It is in a cluster configuration.</li> <li>It has the "Services for Continuously Available shares" role
    ///service installed.</li> </ul> </div> <div> </div> <b>Windows 7, Windows Server 2008 R2, Windows Vista, Windows
    ///Server 2008 and Windows Server 2003: </b>This flag is not supported. </td> </tr> </table> The CSC_MASK and
    ///CSC_MASK_EXT mask values can be used to apply flags that are specific to client-side caching (CSC). <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CSC_MASK"></a><a id="csc_mask"></a><dl>
    ///<dt><b><b>CSC_MASK</b></b></dt> <dt>0x0030</dt> </dl> </td> <td width="60%"> Provides a mask for the following
    ///CSC states. <dl> <dt><b>CSC_CACHE_MANUAL_REINT</b> 0x0000</dt> <dd> Automatic file-by-file reintegration is not
    ///allowed. </dd> <dt><b>CSC_CACHE_AUTO_REINT</b> 0x0010</dt> <dd> File-by-file reintegration is allowed. </dd>
    ///<dt><b>CSC_CACHE_VDO</b> 0x0020</dt> <dd> File opens do not need to be flowed. </dd> <dt><b>CSC_CACHE_NONE</b>
    ///0x0030</dt> <dd> CSC is disabled for this share. </dd> </dl> </td> </tr> <tr> <td width="40%"><a
    ///id="CSC_MASK_EXT"></a><a id="csc_mask_ext"></a><dl> <dt><b><b>CSC_MASK_EXT</b></b></dt> <dt>0x2030</dt> </dl>
    ///</td> <td width="60%"> Provides a mask for the following CSC states and options. <dl>
    ///<dt><b>CSC_CACHE_MANUAL_REINT</b> 0x0000</dt> <dd> Automatic file-by-file reintegration is not allowed. </dd>
    ///<dt><b>CSC_CACHE_AUTO_REINT</b> 0x0010</dt> <dd> File-by-file reintegration is allowed. </dd>
    ///<dt><b>CSC_CACHE_VDO</b> 0x0020</dt> <dd> File opens do not need to be flowed. </dd> <dt><b>CSC_CACHE_NONE</b>
    ///0x0030</dt> <dd> CSC is disabled for this share. </dd> <dt><b>SHI1005_FLAGS_ENABLE_HASH</b> 0x2000</dt> <dd>
    ///Enables server-side functionality needed for peer caching support. </dd> </dl> </td> </tr> </table>
    uint shi1005_flags;
}

///Specifies the maximum number of concurrent connections that the shared resource can accommodate.
struct SHARE_INFO_1006
{
    ///Specifies a DWORD value that indicates the maximum number of concurrent connections that the shared resource can
    ///accommodate. The number of connections is unlimited if the value specified in this member is –1.
    uint shi1006_max_uses;
}

///Contains the security descriptor associated with the specified share. For more information, see Security Descriptors.
struct SHARE_INFO_1501
{
    ///Reserved; must be zero.
    uint  shi1501_reserved;
    ///Specifies the SECURITY_DESCRIPTOR associated with the share.
    void* shi1501_security_descriptor;
}

struct SHARE_INFO_1503
{
    GUID shi1503_sharefilter;
}

struct SERVER_ALIAS_INFO_0
{
    const(wchar)* srvai0_alias;
    const(wchar)* srvai0_target;
    ubyte         srvai0_default;
    uint          srvai0_reserved;
}

///Contains the name of the computer that established the session.
struct SESSION_INFO_0
{
    ///Pointer to a Unicode string that contains the name of the computer that established the session. This string
    ///cannot contain a backslash (\\).
    const(wchar)* sesi0_cname;
}

///Contains information about the session, including name of the computer; name of the user; and open files, pipes, and
///devices on the computer.
struct SESSION_INFO_1
{
    ///Pointer to a Unicode string specifying the name of the computer that established the session. This string cannot
    ///contain a backslash (\\).
    const(wchar)* sesi1_cname;
    ///Pointer to a Unicode string specifying the name of the user who established the session.
    const(wchar)* sesi1_username;
    ///Specifies a DWORD value that contains the number of files, devices, and pipes opened during the session.
    uint          sesi1_num_opens;
    ///Specifies a DWORD value that contains the number of seconds the session has been active.
    uint          sesi1_time;
    ///Specifies a DWORD value that contains the number of seconds the session has been idle.
    uint          sesi1_idle_time;
    ///Specifies a DWORD value that describes how the user established the session. This member can be one of the
    ///following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="SESS_GUEST"></a><a id="sess_guest"></a><dl> <dt><b>SESS_GUEST</b></dt> </dl> </td> <td width="60%"> The user
    ///specified by the <b>sesi1_username</b> member established the session using a guest account. </td> </tr> <tr> <td
    ///width="40%"><a id="SESS_NOENCRYPTION"></a><a id="sess_noencryption"></a><dl> <dt><b>SESS_NOENCRYPTION</b></dt>
    ///</dl> </td> <td width="60%"> The user specified by the <b>sesi1_username</b> member established the session
    ///without using password encryption. </td> </tr> </table>
    uint          sesi1_user_flags;
}

///Contains information about the session, including name of the computer; name of the user; open files, pipes, and
///devices on the computer; and the type of client that established the session.
struct SESSION_INFO_2
{
    ///Pointer to a Unicode string specifying the name of the computer that established the session. This string cannot
    ///contain a backslash (\\).
    const(wchar)* sesi2_cname;
    ///Pointer to a Unicode string specifying the name of the user who established the session.
    const(wchar)* sesi2_username;
    ///Specifies a DWORD value that contains the number of files, devices, and pipes opened during the session.
    uint          sesi2_num_opens;
    ///Specifies a DWORD value that contains the number of seconds the session has been active.
    uint          sesi2_time;
    ///Specifies a DWORD value that contains the number of seconds the session has been idle.
    uint          sesi2_idle_time;
    ///Specifies a DWORD value that describes how the user established the session. This member can be one of the
    ///following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="SESS_GUEST"></a><a id="sess_guest"></a><dl> <dt><b>SESS_GUEST</b></dt> </dl> </td> <td width="60%"> The user
    ///specified by the <b>sesi2_username</b> member established the session using a guest account. </td> </tr> <tr> <td
    ///width="40%"><a id="SESS_NOENCRYPTION"></a><a id="sess_noencryption"></a><dl> <dt><b>SESS_NOENCRYPTION</b></dt>
    ///</dl> </td> <td width="60%"> The user specified by the <b>sesi2_username</b> member established the session
    ///without using password encryption. </td> </tr> </table>
    uint          sesi2_user_flags;
    ///Pointer to a Unicode string that specifies the type of client that established the session. Following are the
    ///defined types for LAN Manager servers. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="DOS_LM_1.0"></a><a id="dos_lm_1.0"></a><dl> <dt><b>DOS LM 1.0</b></dt> </dl> </td> <td width="60%"> LAN
    ///Manager for MS-DOS 1.0 clients </td> </tr> <tr> <td width="40%"><a id="DOS_LM_2.0"></a><a
    ///id="dos_lm_2.0"></a><dl> <dt><b>DOS LM 2.0</b></dt> </dl> </td> <td width="60%"> LAN Manager for MS-DOS 2.0
    ///clients </td> </tr> <tr> <td width="40%"><a id="OS_2_LM_1.0"></a><a id="os_2_lm_1.0"></a><dl> <dt><b>OS/2 LM
    ///1.0</b></dt> </dl> </td> <td width="60%"> LAN Manager for MS-OS/2 1.0 clients </td> </tr> <tr> <td width="40%"><a
    ///id="OS_2_LM_2.0"></a><a id="os_2_lm_2.0"></a><dl> <dt><b>OS/2 LM 2.0</b></dt> </dl> </td> <td width="60%"> LAN
    ///Manager for MS-OS/2 2.0 clients </td> </tr> </table> Sessions from LAN Manager servers running UNIX also will
    ///appear as LAN Manager 2.0.
    const(wchar)* sesi2_cltype_name;
}

///Contains information about the session, including name of the computer; name of the user; and active and idle times
///for the session.
struct SESSION_INFO_10
{
    ///Pointer to a Unicode string specifying the name of the computer that established the session. This string cannot
    ///contain a backslash (\\).
    const(wchar)* sesi10_cname;
    ///Pointer to a Unicode string specifying the name of the user who established the session.
    const(wchar)* sesi10_username;
    ///Specifies the number of seconds the session has been active.
    uint          sesi10_time;
    ///Specifies the number of seconds the session has been idle.
    uint          sesi10_idle_time;
}

///Contains information about the session, including name of the computer; name of the user; open files, pipes, and
///devices on the computer; and the name of the transport the client is using.
struct SESSION_INFO_502
{
    ///Pointer to a Unicode string specifying the name of the computer that established the session. This string cannot
    ///contain a backslash (\\).
    const(wchar)* sesi502_cname;
    ///Pointer to a Unicode string specifying the name of the user who established the session.
    const(wchar)* sesi502_username;
    ///Specifies the number of files, devices, and pipes opened during the session.
    uint          sesi502_num_opens;
    ///Specifies the number of seconds the session has been active.
    uint          sesi502_time;
    ///Specifies the number of seconds the session has been idle.
    uint          sesi502_idle_time;
    ///Specifies a value that describes how the user established the session. This member can be one of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SESS_GUEST"></a><a
    ///id="sess_guest"></a><dl> <dt><b>SESS_GUEST</b></dt> </dl> </td> <td width="60%"> The user specified by the
    ///<b>sesi502_username</b> member established the session using a guest account. </td> </tr> <tr> <td width="40%"><a
    ///id="SESS_NOENCRYPTION"></a><a id="sess_noencryption"></a><dl> <dt><b>SESS_NOENCRYPTION</b></dt> </dl> </td> <td
    ///width="60%"> The user specified by the <b>sesi502_username</b> member established the session without using
    ///password encryption. </td> </tr> </table>
    uint          sesi502_user_flags;
    ///Pointer to a Unicode string that specifies the type of client that established the session. Following are the
    ///defined types for LAN Manager servers. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="DOS_LM_1.0"></a><a id="dos_lm_1.0"></a><dl> <dt><b>DOS LM 1.0</b></dt> </dl> </td> <td width="60%"> LAN
    ///Manager for MS-DOS 1.0 clients. </td> </tr> <tr> <td width="40%"><a id="DOS_LM_2.0"></a><a
    ///id="dos_lm_2.0"></a><dl> <dt><b>DOS LM 2.0</b></dt> </dl> </td> <td width="60%"> LAN Manager for MS-DOS 2.0
    ///clients. </td> </tr> <tr> <td width="40%"><a id="OS_2_LM_1.0"></a><a id="os_2_lm_1.0"></a><dl> <dt><b>OS/2 LM
    ///1.0</b></dt> </dl> </td> <td width="60%"> LAN Manager for MS-OS/2 1.0 clients. </td> </tr> <tr> <td
    ///width="40%"><a id="OS_2_LM_2.0"></a><a id="os_2_lm_2.0"></a><dl> <dt><b>OS/2 LM 2.0</b></dt> </dl> </td> <td
    ///width="60%"> LAN Manager for MS-OS/2 2.0 clients. </td> </tr> </table> Sessions from LAN Manager servers running
    ///UNIX also will appear as LAN Manager 2.0.
    const(wchar)* sesi502_cltype_name;
    ///Specifies the name of the transport that the client is using to communicate with the server.
    const(wchar)* sesi502_transport;
}

///Contains the identification number of a connection.
struct CONNECTION_INFO_0
{
    ///Specifies a connection identification number.
    uint coni0_id;
}

///Contains the identification number of a connection, number of open files, connection time, number of users on the
///connection, and the type of connection.
struct CONNECTION_INFO_1
{
    ///Specifies a connection identification number.
    uint          coni1_id;
    ///A combination of values that specify the type of connection made from the local device name to the shared
    ///resource. One of the following values may be specified. You can isolate these values by using the
    ///<b>STYPE_MASK</b> value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="STYPE_DISKTREE"></a><a id="stype_disktree"></a><dl> <dt><b>STYPE_DISKTREE</b></dt> </dl> </td> <td
    ///width="60%"> Disk drive. </td> </tr> <tr> <td width="40%"><a id="STYPE_PRINTQ"></a><a id="stype_printq"></a><dl>
    ///<dt><b>STYPE_PRINTQ</b></dt> </dl> </td> <td width="60%"> Print queue. </td> </tr> <tr> <td width="40%"><a
    ///id="STYPE_DEVICE"></a><a id="stype_device"></a><dl> <dt><b>STYPE_DEVICE</b></dt> </dl> </td> <td width="60%">
    ///Communication device. </td> </tr> <tr> <td width="40%"><a id="STYPE_IPC"></a><a id="stype_ipc"></a><dl>
    ///<dt><b>STYPE_IPC</b></dt> </dl> </td> <td width="60%"> Interprocess communication (IPC). </td> </tr> </table> In
    ///addition, one or both of the following values may be specified. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="STYPE_SPECIAL"></a><a id="stype_special"></a><dl> <dt><b>STYPE_SPECIAL</b></dt>
    ///</dl> </td> <td width="60%"> Special share reserved for interprocess communication (IPC$) or remote
    ///administration of the server (ADMIN$). Can also refer to administrative shares such as C$, D$, E$, and so forth.
    ///For more information, see Network Share Functions. </td> </tr> <tr> <td width="40%"><a
    ///id="STYPE_TEMPORARY"></a><a id="stype_temporary"></a><dl> <dt><b>STYPE_TEMPORARY</b></dt> </dl> </td> <td
    ///width="60%"> A temporary share. </td> </tr> </table>
    uint          coni1_type;
    ///Specifies the number of files currently open as a result of the connection.
    uint          coni1_num_opens;
    ///Specifies the number of users on the connection.
    uint          coni1_num_users;
    ///Specifies the number of seconds that the connection has been established.
    uint          coni1_time;
    ///Pointer to a string. If the server sharing the resource is running with user-level security, the
    ///<b>coni1_username</b> member describes which user made the connection. If the server is running with share-level
    ///security, <b>coni1_username</b> describes which computer (computername) made the connection. Note that Windows
    ///does not support share-level security. This string is Unicode if <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> are
    ///defined.
    const(wchar)* coni1_username;
    ///Pointer to a string that specifies either the share name of the server's shared resource or the computername of
    ///the client. The value of this member depends on which name was specified as the <i>qualifier</i> parameter to the
    ///NetConnectionEnum function. The name not specified in the <i>qualifier</i> parameter to <b>NetConnectionEnum</b>
    ///is automatically supplied to <b>coni1_netname</b>. This string is Unicode if <b>_WIN32_WINNT</b> or
    ///<b>FORCE_UNICODE</b> are defined.
    const(wchar)* coni1_netname;
}

///Contains the identification number for a file, device, or pipe.
struct FILE_INFO_2
{
    ///Specifies a DWORD value that contains the identification number assigned to the resource when it is opened.
    uint fi2_id;
}

///Contains the identification number and other pertinent information about files, devices, and pipes.
struct FILE_INFO_3
{
    ///Specifies a DWORD value that contains the identification number assigned to the resource when it is opened.
    uint          fi3_id;
    ///Specifies a DWORD value that contains the access permissions associated with the opening application. This member
    ///can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="PERM_FILE_READ"></a><a id="perm_file_read"></a><dl> <dt><b>PERM_FILE_READ</b></dt> </dl> </td>
    ///<td width="60%"> Permission to read a resource and, by default, execute the resource. </td> </tr> <tr> <td
    ///width="40%"><a id="PERM_FILE_WRITE"></a><a id="perm_file_write"></a><dl> <dt><b>PERM_FILE_WRITE</b></dt> </dl>
    ///</td> <td width="60%"> Permission to write to a resource. </td> </tr> <tr> <td width="40%"><a
    ///id="PERM_FILE_CREATE"></a><a id="perm_file_create"></a><dl> <dt><b>PERM_FILE_CREATE</b></dt> </dl> </td> <td
    ///width="60%"> Permission to create a resource; data can be written when creating the resource. </td> </tr>
    ///</table>
    uint          fi3_permissions;
    ///Specifies a DWORD value that contains the number of file locks on the file, device, or pipe.
    uint          fi3_num_locks;
    ///Pointer to a string that specifies the path of the opened resource. This string is Unicode if <b>_WIN32_WINNT</b>
    ///or <b>FORCE_UNICODE</b> are defined.
    const(wchar)* fi3_pathname;
    ///Pointer to a string that specifies which user (on servers that have user-level security) or which computer (on
    ///servers that have share-level security) opened the resource. Note that Windows does not support share-level
    ///security. This string is Unicode if <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> are defined.
    const(wchar)* fi3_username;
}

struct SERVER_CERTIFICATE_INFO_0
{
    const(wchar)* srvci0_name;
    const(wchar)* srvci0_subject;
    const(wchar)* srvci0_issuer;
    const(wchar)* srvci0_thumbprint;
    const(wchar)* srvci0_friendlyname;
    const(wchar)* srvci0_notbefore;
    const(wchar)* srvci0_notafter;
    const(wchar)* srvci0_storelocation;
    const(wchar)* srvci0_storename;
    uint          srvci0_type;
}

///Contains statistical information about the specified workstation.
struct STAT_WORKSTATION_0
{
    ///Specifies the time statistics collection started. This member also indicates when statistics for the workstations
    ///were last cleared. The value is stored as the number of seconds elapsed since 00:00:00, January 1, 1970.
    LARGE_INTEGER StatisticsStartTime;
    ///Specifies the total number of bytes received by the workstation.
    LARGE_INTEGER BytesReceived;
    ///Specifies the total number of server message blocks (SMBs) received by the workstation.
    LARGE_INTEGER SmbsReceived;
    ///Specifies the total number of bytes that have been read by paging I/O requests.
    LARGE_INTEGER PagingReadBytesRequested;
    ///Specifies the total number of bytes that have been read by non-paging I/O requests.
    LARGE_INTEGER NonPagingReadBytesRequested;
    ///Specifies the total number of bytes that have been read by cache I/O requests.
    LARGE_INTEGER CacheReadBytesRequested;
    ///Specifies the total amount of bytes that have been read by disk I/O requests.
    LARGE_INTEGER NetworkReadBytesRequested;
    ///Specifies the total number of bytes transmitted by the workstation.
    LARGE_INTEGER BytesTransmitted;
    ///Specifies the total number of SMBs transmitted by the workstation.
    LARGE_INTEGER SmbsTransmitted;
    ///Specifies the total number of bytes that have been written by paging I/O requests.
    LARGE_INTEGER PagingWriteBytesRequested;
    ///Specifies the total number of bytes that have been written by non-paging I/O requests.
    LARGE_INTEGER NonPagingWriteBytesRequested;
    ///Specifies the total number of bytes that have been written by cache I/O requests.
    LARGE_INTEGER CacheWriteBytesRequested;
    ///Specifies the total number of bytes that have been written by disk I/O requests.
    LARGE_INTEGER NetworkWriteBytesRequested;
    ///Specifies the total number of network operations that failed to begin.
    uint          InitiallyFailedOperations;
    ///Specifies the total number of network operations that failed to complete.
    uint          FailedCompletionOperations;
    ///Specifies the total number of read operations initiated by the workstation.
    uint          ReadOperations;
    ///Specifies the total number of random access reads initiated by the workstation.
    uint          RandomReadOperations;
    ///Specifies the total number of read requests the workstation has sent to servers.
    uint          ReadSmbs;
    ///Specifies the total number of read requests the workstation has sent to servers that are greater than twice the
    ///size of the server's negotiated buffer size.
    uint          LargeReadSmbs;
    ///Specifies the total number of read requests the workstation has sent to servers that are less than 1/4 of the
    ///size of the server's negotiated buffer size.
    uint          SmallReadSmbs;
    ///Specifies the total number of write operations initiated by the workstation.
    uint          WriteOperations;
    ///Specifies the total number of random access writes initiated by the workstation.
    uint          RandomWriteOperations;
    uint          WriteSmbs;
    ///Specifies the total number of write requests the workstation has sent to servers that are greater than twice the
    ///size of the server's negotiated buffer size.
    uint          LargeWriteSmbs;
    ///Specifies the total number of write requests the workstation has sent to servers that are less than 1/4 of the
    ///size of the server's negotiated buffer size.
    uint          SmallWriteSmbs;
    uint          RawReadsDenied;
    ///Specifies the total number of raw write requests made by the workstation that have been denied.
    uint          RawWritesDenied;
    ///Specifies the total number of network errors received by the workstation.
    uint          NetworkErrors;
    uint          Sessions;
    ///Specifies the number of times the workstation attempted to create a session but failed.
    uint          FailedSessions;
    ///Specifies the total number of connections that have failed.
    uint          Reconnects;
    ///Specifies the total number of connections to servers supporting the PCNET dialect that have succeeded.
    uint          CoreConnects;
    ///Specifies the total number of connections to servers supporting the LanManager 2.0 dialect that have succeeded.
    uint          Lanman20Connects;
    ///Specifies the total number of connections to servers supporting the LanManager 2.1 dialect that have succeeded.
    uint          Lanman21Connects;
    ///Specifies the total number of connections to servers supporting the NTLM dialect that have succeeded.
    uint          LanmanNtConnects;
    ///Specifies the number of times the workstation was disconnected by a network server.
    uint          ServerDisconnects;
    ///Specifies the total number of sessions that have expired on the workstation.
    uint          HungSessions;
    ///Specifies the total number of network connections established by the workstation.
    uint          UseCount;
    ///Specifies the total number of failed network connections for the workstation.
    uint          FailedUseCount;
    ///Specifies the number of current requests that have not been completed.
    uint          CurrentCommands;
}

///Contains statistical information about the server.
struct STAT_SERVER_0
{
    ///Specifies a DWORD value that indicates the time when statistics collection started (or when the statistics were
    ///last cleared). The value is stored as the number of seconds that have elapsed since 00:00:00, January 1, 1970,
    ///GMT. To calculate the length of time that statistics have been collected, subtract the value of this member from
    ///the present time.
    uint sts0_start;
    ///Specifies a DWORD value that indicates the number of times a file is opened on a server. This includes the number
    ///of times named pipes are opened.
    uint sts0_fopens;
    ///Specifies a DWORD value that indicates the number of times a server device is opened.
    uint sts0_devopens;
    ///Specifies a DWORD value that indicates the number of server print jobs spooled.
    uint sts0_jobsqueued;
    ///Specifies a DWORD value that indicates the number of times the server session started.
    uint sts0_sopens;
    ///Specifies a DWORD value that indicates the number of times the server session automatically disconnected.
    uint sts0_stimedout;
    ///Specifies a DWORD value that indicates the number of times the server sessions failed with an error.
    uint sts0_serrorout;
    ///Specifies a DWORD value that indicates the number of server password violations.
    uint sts0_pwerrors;
    ///Specifies a DWORD value that indicates the number of server access permission errors.
    uint sts0_permerrors;
    ///Specifies a DWORD value that indicates the number of server system errors.
    uint sts0_syserrors;
    ///Specifies the low-order DWORD of the number of server bytes sent to the network.
    uint sts0_bytessent_low;
    ///Specifies the high-order DWORD of the number of server bytes sent to the network.
    uint sts0_bytessent_high;
    ///Specifies the low-order DWORD of the number of server bytes received from the network.
    uint sts0_bytesrcvd_low;
    ///Specifies the high-order DWORD of the number of server bytes received from the network.
    uint sts0_bytesrcvd_high;
    ///Specifies a DWORD value that indicates the average server response time (in milliseconds).
    uint sts0_avresponse;
    ///Specifies a DWORD value that indicates the number of times the server required a request buffer but failed to
    ///allocate one. This value indicates that the server parameters may need adjustment.
    uint sts0_reqbufneed;
    ///Specifies a DWORD value that indicates the number of times the server required a big buffer but failed to
    ///allocate one. This value indicates that the server parameters may need adjustment.
    uint sts0_bigbufneed;
}

///Contains information about a file that the OpenFile function opened or attempted to open.
struct OFSTRUCT
{
    ///The size of the structure, in bytes.
    ubyte     cBytes;
    ///If this member is nonzero, the file is on a hard (fixed) disk. Otherwise, it is not.
    ubyte     fFixedDisk;
    ///The MS-DOS error code if the OpenFile function failed.
    ushort    nErrCode;
    ///Reserved; do not use.
    ushort    Reserved1;
    ///Reserved; do not use.
    ushort    Reserved2;
    ///The path and file name of the file.
    byte[128] szPathName;
}

///Passed to the CopyFile2ProgressRoutine callback function with information about a pending copy operation.
struct COPYFILE2_MESSAGE
{
    ///Value from the COPYFILE2_MESSAGE_TYPE enumeration used as a discriminant for the <b>Info</b> union within this
    ///structure. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="COPYFILE2_CALLBACK_CHUNK_STARTED"></a><a id="copyfile2_callback_chunk_started"></a><dl>
    ///<dt><b>COPYFILE2_CALLBACK_CHUNK_STARTED</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Indicates a single chunk
    ///of a stream has started to be copied. Information is in the <b>ChunkStarted</b> structure within the <b>Info</b>
    ///union. </td> </tr> <tr> <td width="40%"><a id="COPYFILE2_CALLBACK_CHUNK_FINISHED"></a><a
    ///id="copyfile2_callback_chunk_finished"></a><dl> <dt><b>COPYFILE2_CALLBACK_CHUNK_FINISHED</b></dt> <dt>2</dt>
    ///</dl> </td> <td width="60%"> Indicates the copy of a single chunk of a stream has completed. Information is in
    ///the <b>ChunkFinished</b> structure within the <b>Info</b> union. </td> </tr> <tr> <td width="40%"><a
    ///id="COPYFILE2_CALLBACK_STREAM_STARTED"></a><a id="copyfile2_callback_stream_started"></a><dl>
    ///<dt><b>COPYFILE2_CALLBACK_STREAM_STARTED</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> Indicates both source
    ///and destination handles for a stream have been opened and the copy of the stream is about to be started.
    ///Information is in the <b>StreamStarted</b> structure within the <b>Info</b> union. This does not indicate that
    ///the copy has started for that stream. </td> </tr> <tr> <td width="40%"><a
    ///id="COPYFILE2_CALLBACK_STREAM_FINISHED"></a><a id="copyfile2_callback_stream_finished"></a><dl>
    ///<dt><b>COPYFILE2_CALLBACK_STREAM_FINISHED</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Indicates the copy
    ///operation for a stream have started to be completed, either successfully or due to a
    ///<b>COPYFILE2_PROGRESS_STOP</b> return from CopyFile2ProgressRoutine. Information is in the <b>StreamFinished</b>
    ///structure within the <b>Info</b> union. </td> </tr> <tr> <td width="40%"><a
    ///id="COPYFILE2_CALLBACK_POLL_CONTINUE"></a><a id="copyfile2_callback_poll_continue"></a><dl>
    ///<dt><b>COPYFILE2_CALLBACK_POLL_CONTINUE</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> May be sent
    ///periodically. Information is in the <b>PollContinue</b> structure within the <b>Info</b> union. </td> </tr> <tr>
    ///<td width="40%"><a id="COPYFILE2_CALLBACK_ERROR"></a><a id="copyfile2_callback_error"></a><dl>
    ///<dt><b>COPYFILE2_CALLBACK_ERROR</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> An error was encountered during
    ///the copy operation. Information is in the <b>Error</b> structure within the <b>Info</b> union. </td> </tr>
    ///</table>
    COPYFILE2_MESSAGE_TYPE Type;
    uint dwPadding;
    union Info
    {
        struct ChunkStarted
        {
            uint           dwStreamNumber;
            uint           dwReserved;
            HANDLE         hSourceFile;
            HANDLE         hDestinationFile;
            ULARGE_INTEGER uliChunkNumber;
            ULARGE_INTEGER uliChunkSize;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliTotalFileSize;
        }
        struct ChunkFinished
        {
            uint           dwStreamNumber;
            uint           dwFlags;
            HANDLE         hSourceFile;
            HANDLE         hDestinationFile;
            ULARGE_INTEGER uliChunkNumber;
            ULARGE_INTEGER uliChunkSize;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliStreamBytesTransferred;
            ULARGE_INTEGER uliTotalFileSize;
            ULARGE_INTEGER uliTotalBytesTransferred;
        }
        struct StreamStarted
        {
            uint           dwStreamNumber;
            uint           dwReserved;
            HANDLE         hSourceFile;
            HANDLE         hDestinationFile;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliTotalFileSize;
        }
        struct StreamFinished
        {
            uint           dwStreamNumber;
            uint           dwReserved;
            HANDLE         hSourceFile;
            HANDLE         hDestinationFile;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliStreamBytesTransferred;
            ULARGE_INTEGER uliTotalFileSize;
            ULARGE_INTEGER uliTotalBytesTransferred;
        }
        struct PollContinue
        {
            uint dwReserved;
        }
        struct Error
        {
            COPYFILE2_COPY_PHASE CopyPhase;
            uint                 dwStreamNumber;
            HRESULT              hrFailure;
            uint                 dwReserved;
            ULARGE_INTEGER       uliChunkNumber;
            ULARGE_INTEGER       uliStreamSize;
            ULARGE_INTEGER       uliStreamBytesTransferred;
            ULARGE_INTEGER       uliTotalFileSize;
            ULARGE_INTEGER       uliTotalBytesTransferred;
        }
    }
}

///Contains extended parameters for the CopyFile2 function.
struct COPYFILE2_EXTENDED_PARAMETERS
{
    ///Contains the size of this structure, <code>sizeof(COPYFILE2_EXTENDED_PARAMETERS)</code>.
    uint  dwSize;
    ///Contains a combination of zero or more of these flag values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="COPY_FILE_ALLOW_DECRYPTED_DESTINATION"></a><a
    ///id="copy_file_allow_decrypted_destination"></a><dl> <dt><b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b></dt>
    ///<dt>0x00000008</dt> </dl> </td> <td width="60%"> The copy will be attempted even if the destination file cannot
    ///be encrypted. </td> </tr> <tr> <td width="40%"><a id="COPY_FILE_COPY_SYMLINK"></a><a
    ///id="copy_file_copy_symlink"></a><dl> <dt><b>COPY_FILE_COPY_SYMLINK</b></dt> <dt>0x00000800</dt> </dl> </td> <td
    ///width="60%"> If the source file is a symbolic link, the destination file is also a symbolic link pointing to the
    ///same file as the source symbolic link. </td> </tr> <tr> <td width="40%"><a id="COPY_FILE_FAIL_IF_EXISTS"></a><a
    ///id="copy_file_fail_if_exists"></a><dl> <dt><b>COPY_FILE_FAIL_IF_EXISTS</b></dt> <dt>0x00000001</dt> </dl> </td>
    ///<td width="60%"> If the destination file exists the copy operation fails immediately. If a file or directory
    ///exists with the destination name then the CopyFile2 function call will fail with either
    ///<code>HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)</code> or <code>HRESULT_FROM_WIN32(ERROR_FILE_EXISTS)</code>. If
    ///<b>COPY_FILE_RESUME_FROM_PAUSE</b> is also specified then a failure is only triggered if the destination file
    ///does not have a valid restart header. </td> </tr> <tr> <td width="40%"><a id="COPY_FILE_NO_BUFFERING"></a><a
    ///id="copy_file_no_buffering"></a><dl> <dt><b>COPY_FILE_NO_BUFFERING</b></dt> <dt>0x00001000</dt> </dl> </td> <td
    ///width="60%"> The copy is performed using unbuffered I/O, bypassing the system cache resources. This flag is
    ///recommended for very large file copies. It is not recommended to pause copies that are using this flag. </td>
    ///</tr> <tr> <td width="40%"><a id="COPY_FILE_NO_OFFLOAD"></a><a id="copy_file_no_offload"></a><dl>
    ///<dt><b>COPY_FILE_NO_OFFLOAD</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> Do not attempt to use the
    ///Windows Copy Offload mechanism. This is not generally recommended. </td> </tr> <tr> <td width="40%"><a
    ///id="COPY_FILE_OPEN_SOURCE_FOR_WRITE"></a><a id="copy_file_open_source_for_write"></a><dl>
    ///<dt><b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The file is
    ///copied and the source file is opened for write access. </td> </tr> <tr> <td width="40%"><a
    ///id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl> <dt><b>COPY_FILE_RESTARTABLE</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> The file is copied in a manner that can be restarted if the same
    ///source and destination filenames are used again. This is slower. </td> </tr> <tr> <td width="40%"><a
    ///id="COPY_FILE_REQUEST_SECURITY_PRIVILEGES"></a><a id="copy_file_request_security_privileges"></a><dl>
    ///<dt><b>COPY_FILE_REQUEST_SECURITY_PRIVILEGES</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> The copy
    ///is attempted, specifying <code>ACCESS_SYSTEM_SECURITY</code> for the source file and <code>ACCESS_SYSTEM_SECURITY
    ///| WRITE_DAC | WRITE_OWNER</code> for the destination file. If these requests are denied the access request will
    ///be reduced to the highest privilege level for which access is granted. For more information see SACL Access
    ///Right. This can be used to allow the CopyFile2ProgressRoutine callback to perform operations requiring higher
    ///privileges, such as copying the security attributes for the file. </td> </tr> <tr> <td width="40%"><a
    ///id="COPY_FILE_RESUME_FROM_PAUSE"></a><a id="copy_file_resume_from_pause"></a><dl>
    ///<dt><b>COPY_FILE_RESUME_FROM_PAUSE</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> The destination file
    ///is examined to see if it was copied using <b>COPY_FILE_RESTARTABLE</b>. If so the copy is resumed. If not the
    ///file will be fully copied. </td> </tr> </table>
    uint  dwCopyFlags;
    ///If this flag is set to <b>TRUE</b> during the copy operation then the copy operation is canceled.
    int*  pfCancel;
    ///The optional address of a callback function of type <b>PCOPYFILE2_PROGRESS_ROUTINE</b> that is called each time
    ///another portion of the file has been copied. This parameter can be <b>NULL</b>. For more information on the
    ///progress callback function, see the CopyFile2ProgressRoutine callback function.
    PCOPYFILE2_PROGRESS_ROUTINE pProgressRoutine;
    ///A pointer to application-specific context information to be passed to the CopyFile2ProgressRoutine.
    void* pvCallbackContext;
}

///Contains the basic information for a file. Used for file handles.
struct FILE_BASIC_INFO
{
    ///The time the file was created in FILETIME format, which is a 64-bit value representing the number of
    ///100-nanosecond intervals since January 1, 1601 (UTC).
    LARGE_INTEGER CreationTime;
    ///The time the file was last accessed in FILETIME format.
    LARGE_INTEGER LastAccessTime;
    ///The time the file was last written to in FILETIME format.
    LARGE_INTEGER LastWriteTime;
    ///The time the file was changed in FILETIME format.
    LARGE_INTEGER ChangeTime;
    ///The file attributes. For a list of attributes, see File Attribute Constants. If this is set to 0 in a
    ///<b>FILE_BASIC_INFO</b> structure passed to SetFileInformationByHandle then none of the attributes are changed.
    uint          FileAttributes;
}

///Receives extended information for the file. Used for file handles. Use only when calling
///GetFileInformationByHandleEx.
struct FILE_STANDARD_INFO
{
    ///The amount of space that is allocated for the file.
    LARGE_INTEGER AllocationSize;
    ///The end of the file.
    LARGE_INTEGER EndOfFile;
    ///The number of links to the file.
    uint          NumberOfLinks;
    ///<b>TRUE</b> if the file in the delete queue; otherwise, <b>false</b>.
    ubyte         DeletePending;
    ///<b>TRUE</b> if the file is a directory; otherwise, <b>false</b>.
    ubyte         Directory;
}

///Receives the file name. Used for any handles. Use only when calling GetFileInformationByHandleEx.
struct FILE_NAME_INFO
{
    ///The size of the <b>FileName</b> string, in bytes.
    uint      FileNameLength;
    ///The file name that is returned.
    ushort[1] FileName;
}

///Contains the name to which the file should be renamed. Use only when calling SetFileInformationByHandle.
struct FILE_RENAME_INFO
{
    union
    {
        ubyte ReplaceIfExists;
        uint  Flags;
    }
    ///A handle to the root directory in which the file to be renamed is located.
    HANDLE    RootDirectory;
    ///The size of <b>FileName</b> in bytes.
    uint      FileNameLength;
    ///The new file name.
    ushort[1] FileName;
}

///Contains the total number of bytes that should be allocated for a file. This structure is used when calling the
///SetFileInformationByHandle function.
struct FILE_ALLOCATION_INFO
{
    ///The new file allocation size, in bytes. This value is typically a multiple of the sector or cluster size for the
    ///underlying physical device.
    LARGE_INTEGER AllocationSize;
}

///Contains the specified value to which the end of the file should be set. Used for file handles. Use only when calling
///SetFileInformationByHandle.
struct FILE_END_OF_FILE_INFO
{
    ///The specified value for the new end of the file.
    LARGE_INTEGER EndOfFile;
}

///Receives file stream information for the specified file. Used for any handles. Use only when calling
///GetFileInformationByHandleEx.
struct FILE_STREAM_INFO
{
    ///The offset for the next <b>FILE_STREAM_INFO</b> entry that is returned. This member is zero if no other entries
    ///follow this one.
    uint          NextEntryOffset;
    ///The length, in bytes, of <b>StreamName</b>.
    uint          StreamNameLength;
    ///The size, in bytes, of the data stream.
    LARGE_INTEGER StreamSize;
    ///The amount of space that is allocated for the stream, in bytes. This value is usually a multiple of the sector or
    ///cluster size of the underlying physical device.
    LARGE_INTEGER StreamAllocationSize;
    ///The stream name.
    ushort[1]     StreamName;
}

///Receives file compression information. Used for any handles. Use only when calling GetFileInformationByHandleEx.
struct FILE_COMPRESSION_INFO
{
    ///The file size of the compressed file.
    LARGE_INTEGER CompressedFileSize;
    ///The compression format that is used to compress the file.
    ushort        CompressionFormat;
    ///The factor that the compression uses.
    ubyte         CompressionUnitShift;
    ///The number of chunks that are shifted by compression.
    ubyte         ChunkShift;
    ///The number of clusters that are shifted by compression.
    ubyte         ClusterShift;
    ///Reserved.
    ubyte[3]      Reserved;
}

///Receives the requested file attribute information. Used for any handles. Use only when calling
///GetFileInformationByHandleEx.
struct FILE_ATTRIBUTE_TAG_INFO
{
    ///The file attribute information.
    uint FileAttributes;
    ///The reparse tag.
    uint ReparseTag;
}

///Indicates whether a file should be deleted. Used for any handles. Use only when calling SetFileInformationByHandle.
struct FILE_DISPOSITION_INFO
{
    ubyte DeleteFileA;
}

///Contains information about files in the specified directory. Used for directory handles. Use only when calling
///GetFileInformationByHandleEx. The number of files that are returned for each call to
///<b>GetFileInformationByHandleEx</b> depends on the size of the buffer that is passed to the function. Any subsequent
///calls to <b>GetFileInformationByHandleEx</b> on the same handle will resume the enumeration operation after the last
///file is returned.
struct FILE_ID_BOTH_DIR_INFO
{
    ///The offset for the next <b>FILE_ID_BOTH_DIR_INFO</b> structure that is returned. Contains zero (0) if no other
    ///entries follow this one.
    uint          NextEntryOffset;
    ///The byte offset of the file within the parent directory. This member is undefined for file systems, such as NTFS,
    ///in which the position of a file within the parent directory is not fixed and can be changed at any time to
    ///maintain sort order.
    uint          FileIndex;
    ///The time that the file was created.
    LARGE_INTEGER CreationTime;
    ///The time that the file was last accessed.
    LARGE_INTEGER LastAccessTime;
    ///The time that the file was last written to.
    LARGE_INTEGER LastWriteTime;
    ///The time that the file was last changed.
    LARGE_INTEGER ChangeTime;
    ///The absolute new end-of-file position as a byte offset from the start of the file to the end of the file. Because
    ///this value is zero-based, it actually refers to the first free byte in the file. In other words, <b>EndOfFile</b>
    ///is the offset to the byte that immediately follows the last valid byte in the file.
    LARGE_INTEGER EndOfFile;
    ///The number of bytes that are allocated for the file. This value is usually a multiple of the sector or cluster
    ///size of the underlying physical device.
    LARGE_INTEGER AllocationSize;
    ///The file attributes. This member can be any valid combination of the following attributes:
    uint          FileAttributes;
    ///The length of the file name.
    uint          FileNameLength;
    ///The size of the extended attributes for the file.
    uint          EaSize;
    ///The length of <b>ShortName</b>.
    byte          ShortNameLength;
    ///The short 8.3 file naming convention (for example, "FILENAME.TXT") name of the file.
    ushort[12]    ShortName;
    ///The file ID.
    LARGE_INTEGER FileId;
    ///The first character of the file name string. This is followed in memory by the remainder of the string.
    ushort[1]     FileName;
}

///Contains directory information for a file. This structure is returned from the GetFileInformationByHandleEx function
///when <b>FileFullDirectoryInfo</b> or <b>FileFullDirectoryRestartInfo</b> is passed in the <i>FileInformationClass</i>
///parameter.
struct FILE_FULL_DIR_INFO
{
    ///The offset for the next <b>FILE_FULL_DIR_INFO</b> structure that is returned. Contains zero (0) if no other
    ///entries follow this one.
    uint          NextEntryOffset;
    ///The byte offset of the file within the parent directory. This member is undefined for file systems, such as NTFS,
    ///in which the position of a file within the parent directory is not fixed and can be changed at any time to
    ///maintain sort order.
    uint          FileIndex;
    ///The time that the file was created.
    LARGE_INTEGER CreationTime;
    ///The time that the file was last accessed.
    LARGE_INTEGER LastAccessTime;
    ///The time that the file was last written to.
    LARGE_INTEGER LastWriteTime;
    ///The time that the file was last changed.
    LARGE_INTEGER ChangeTime;
    ///The absolute new end-of-file position as a byte offset from the start of the file to the end of the default data
    ///stream of the file. Because this value is zero-based, it actually refers to the first free byte in the file. In
    ///other words, <b>EndOfFile</b> is the offset to the byte that immediately follows the last valid byte in the file.
    LARGE_INTEGER EndOfFile;
    ///The number of bytes that are allocated for the file. This value is usually a multiple of the sector or cluster
    ///size of the underlying physical device.
    LARGE_INTEGER AllocationSize;
    ///The file attributes. This member can be any valid combination of the following attributes:
    uint          FileAttributes;
    ///The length of the file name.
    uint          FileNameLength;
    ///The size of the extended attributes for the file.
    uint          EaSize;
    ///The first character of the file name string. This is followed in memory by the remainder of the string.
    ushort[1]     FileName;
}

///Specifies the priority hint for a file I/O operation.
struct FILE_IO_PRIORITY_HINT_INFO
{
    ///The priority hint. This member is a value from the PRIORITY_HINT enumeration.
    PRIORITY_HINT PriorityHint;
}

///Contains alignment information for a file. This structure is returned from the GetFileInformationByHandleEx function
///when <b>FileAlignmentInfo</b> is passed in the <i>FileInformationClass</i> parameter.
struct FILE_ALIGNMENT_INFO
{
    ///Minimum alignment requirement, in bytes.
    uint AlignmentRequirement;
}

///Contains directory information for a file. This structure is returned from the GetFileInformationByHandleEx function
///when <b>FileStorageInfo</b> is passed in the <i>FileInformationClass</i> parameter.
struct FILE_STORAGE_INFO
{
    ///Logical bytes per sector reported by physical storage. This is the smallest size for which uncached I/O is
    ///supported.
    uint LogicalBytesPerSector;
    ///Bytes per sector for atomic writes. Writes smaller than this may require a read before the entire block can be
    ///written atomically.
    uint PhysicalBytesPerSectorForAtomicity;
    ///Bytes per sector for optimal performance for writes.
    uint PhysicalBytesPerSectorForPerformance;
    ///This is the size of the block used for atomicity by the file system. This may be a trade-off between the optimal
    ///size of the physical media and one that is easier to adapt existing code and structures.
    uint FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
    ///This member can contain combinations of flags specifying information about the alignment of the storage. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="STORAGE_INFO_FLAGS_ALIGNED_DEVICE"></a><a
    ///id="storage_info_flags_aligned_device"></a><dl> <dt><b>STORAGE_INFO_FLAGS_ALIGNED_DEVICE</b></dt>
    ///<dt>0x00000001</dt> </dl> </td> <td width="60%"> When set, this flag indicates that the logical sectors of the
    ///storage device are aligned to physical sector boundaries. </td> </tr> <tr> <td width="40%"><a
    ///id="STORAGE_INFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE____"></a><a
    ///id="storage_info_flags_partition_aligned_on_device____"></a><dl>
    ///<dt><b>STORAGE_INFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE </b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%">
    ///When set, this flag indicates that the partition is aligned to physical sector boundaries on the storage device.
    ///</td> </tr> </table>
    uint Flags;
    ///Logical sector offset within the first physical sector where the first logical sector is placed, in bytes. If
    ///this value is set to <b>STORAGE_INFO_OFFSET_UNKNOWN</b> (0xffffffff), there was insufficient information to
    ///compute this field.
    uint ByteOffsetForSectorAlignment;
    ///Offset used to align the partition to a physical sector boundary on the storage device, in bytes. If this value
    ///is set to <b>STORAGE_INFO_OFFSET_UNKNOWN</b> (0xffffffff), there was insufficient information to compute this
    ///field.
    uint ByteOffsetForPartitionAlignment;
}

///Contains identification information for a file. This structure is returned from the GetFileInformationByHandleEx
///function when <b>FileIdInfo</b> is passed in the <i>FileInformationClass</i> parameter.
struct FILE_ID_INFO
{
    ///The serial number of the volume that contains a file.
    ulong       VolumeSerialNumber;
    ///The 128-bit file identifier for the file. The file identifier and the volume serial number uniquely identify a
    ///file on a single computer. To determine whether two open handles represent the same file, combine the identifier
    ///and the volume serial number for each file and compare them.
    FILE_ID_128 FileId;
}

///Contains identification information for a file. This structure is returned from the GetFileInformationByHandleEx
///function when <b>FileIdExtdDirectoryInfo</b> (0x13) or <b>FileIdExtdDirectoryRestartInfo</b> (0x14) is passed in the
///<i>FileInformationClass</i> parameter.
struct FILE_ID_EXTD_DIR_INFO
{
    ///The offset for the next <b>FILE_ID_EXTD_DIR_INFO</b> structure that is returned. Contains zero (0) if no other
    ///entries follow this one.
    uint          NextEntryOffset;
    ///The byte offset of the file within the parent directory. This member is undefined for file systems, such as NTFS,
    ///in which the position of a file within the parent directory is not fixed and can be changed at any time to
    ///maintain sort order.
    uint          FileIndex;
    ///The time that the file was created.
    LARGE_INTEGER CreationTime;
    ///The time that the file was last accessed.
    LARGE_INTEGER LastAccessTime;
    ///The time that the file was last written to.
    LARGE_INTEGER LastWriteTime;
    ///The time that the file was last changed.
    LARGE_INTEGER ChangeTime;
    ///The absolute new end-of-file position as a byte offset from the start of the file to the end of the file. Because
    ///this value is zero-based, it actually refers to the first free byte in the file. In other words, <b>EndOfFile</b>
    ///is the offset to the byte that immediately follows the last valid byte in the file.
    LARGE_INTEGER EndOfFile;
    ///The number of bytes that are allocated for the file. This value is usually a multiple of the sector or cluster
    ///size of the underlying physical device.
    LARGE_INTEGER AllocationSize;
    ///The file attributes. This member can be any valid combination of the following attributes: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a
    ///id="file_attribute_archive"></a><dl> <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt> <dt>32 (0x20)</dt> </dl> </td> <td
    ///width="60%"> A file or directory that is an archive file or directory. Applications typically use this attribute
    ///to mark files for backup or removal . </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_COMPRESSED"></a><a
    ///id="file_attribute_compressed"></a><dl> <dt><b>FILE_ATTRIBUTE_COMPRESSED</b></dt> <dt>2048 (0x800)</dt> </dl>
    ///</td> <td width="60%"> A file or directory that is compressed. For a file, all of the data in the file is
    ///compressed. For a directory, compression is the default for newly created files and subdirectories. </td> </tr>
    ///<tr> <td width="40%"><a id="FILE_ATTRIBUTE_DEVICE"></a><a id="file_attribute_device"></a><dl>
    ///<dt><b>FILE_ATTRIBUTE_DEVICE</b></dt> <dt>64 (0x40)</dt> </dl> </td> <td width="60%"> This value is reserved for
    ///system use. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_DIRECTORY"></a><a
    ///id="file_attribute_directory"></a><dl> <dt><b>FILE_ATTRIBUTE_DIRECTORY</b></dt> <dt>16 (0x10)</dt> </dl> </td>
    ///<td width="60%"> The handle that identifies a directory. </td> </tr> <tr> <td width="40%"><a
    ///id="FILE_ATTRIBUTE_ENCRYPTED"></a><a id="file_attribute_encrypted"></a><dl>
    ///<dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt> <dt>16384 (0x4000)</dt> </dl> </td> <td width="60%"> A file or directory
    ///that is encrypted. For a file, all data streams in the file are encrypted. For a directory, encryption is the
    ///default for newly created files and subdirectories. </td> </tr> <tr> <td width="40%"><a
    ///id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl> <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt> <dt>2
    ///(0x2)</dt> </dl> </td> <td width="60%"> The file or directory is hidden. It is not included in an ordinary
    ///directory listing. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a
    ///id="file_attribute_normal"></a><dl> <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt> <dt>128 (0x80)</dt> </dl> </td> <td
    ///width="60%"> A file that does not have other attributes set. This attribute is valid only when used alone. </td>
    ///</tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_NOT_CONTENT_INDEXED"></a><a
    ///id="file_attribute_not_content_indexed"></a><dl> <dt><b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b></dt> <dt>8192
    ///(0x2000)</dt> </dl> </td> <td width="60%"> The file or directory is not to be indexed by the content indexing
    ///service. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a
    ///id="file_attribute_offline"></a><dl> <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt> <dt>4096 (0x1000)</dt> </dl> </td>
    ///<td width="60%"> The data of a file is not available immediately. This attribute indicates that the file data is
    ///physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage
    ///management software. Applications should not arbitrarily change this attribute. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
    ///<dt><b>FILE_ATTRIBUTE_READONLY</b></dt> <dt>1 (0x1)</dt> </dl> </td> <td width="60%"> A file that is read-only.
    ///Applications can read the file, but cannot write to it or delete it. This attribute is not honored on
    ///directories. For more information, see You cannot view or change the Read-only or the System attributes of
    ///folders in Windows Server 2003, in Windows XP, in Windows Vista or in Windows 7. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_ATTRIBUTE_REPARSE_POINT"></a><a id="file_attribute_reparse_point"></a><dl>
    ///<dt><b>FILE_ATTRIBUTE_REPARSE_POINT</b></dt> <dt>1024 (0x400)</dt> </dl> </td> <td width="60%"> A file or
    ///directory that has an associated reparse point, or a file that is a symbolic link. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_ATTRIBUTE_SPARSE_FILE"></a><a id="file_attribute_sparse_file"></a><dl>
    ///<dt><b>FILE_ATTRIBUTE_SPARSE_FILE</b></dt> <dt>512 (0x200)</dt> </dl> </td> <td width="60%"> A file that is a
    ///sparse file. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_SYSTEM"></a><a
    ///id="file_attribute_system"></a><dl> <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt> <dt>4 (0x4)</dt> </dl> </td> <td
    ///width="60%"> A file or directory that the operating system uses a part of, or uses exclusively. </td> </tr> <tr>
    ///<td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
    ///<dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt> <dt>256 (0x100)</dt> </dl> </td> <td width="60%"> A file that is being
    ///used for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is
    ///available, because typically, an application deletes a temporary file after the handle is closed. In that
    ///scenario, the system can entirely avoid writing the data. Otherwise, the data is written after the handle is
    ///closed. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_VIRTUAL"></a><a
    ///id="file_attribute_virtual"></a><dl> <dt><b>FILE_ATTRIBUTE_VIRTUAL</b></dt> <dt>65536 (0x10000)</dt> </dl> </td>
    ///<td width="60%"> This value is reserved for system use. </td> </tr> </table>
    uint          FileAttributes;
    ///The length of the file name.
    uint          FileNameLength;
    ///The size of the extended attributes for the file.
    uint          EaSize;
    ///If the <b>FileAttributes</b> member includes the <b>FILE_ATTRIBUTE_REPARSE_POINT</b> attribute, this member
    ///specifies the reparse point tag. Otherwise, this value is undefined and should not be used. For more information
    ///see Reparse Point Tags.
    uint          ReparsePointTag;
    ///The file ID.
    FILE_ID_128   FileId;
    ///The first character of the file name string. This is followed in memory by the remainder of the string.
    ushort[1]     FileName;
}

///Contains file remote protocol information. This structure is returned from the GetFileInformationByHandleEx function
///when <b>FileRemoteProtocolInfo</b> is passed in the <i>FileInformationClass</i> parameter.
struct FILE_REMOTE_PROTOCOL_INFO
{
    ///Version of this structure. This member should be set to 2 if the communication is between computers running
    ///Windows 8, Windows Server 2012, or later and 1 otherwise.
    ushort StructureVersion;
    ///Size of this structure. This member should be set to <code>sizeof(FILE_REMOTE_PROTOCOL_INFO)</code>.
    ushort StructureSize;
    ///Remote protocol (<b>WNNC_NET_*</b>) defined in Wnnc.h or Ntifs.h.
    uint   Protocol;
    ///Major version of the remote protocol.
    ushort ProtocolMajorVersion;
    ///Minor version of the remote protocol.
    ushort ProtocolMinorVersion;
    ///Revision of the remote protocol.
    ushort ProtocolRevision;
    ///Should be set to zero. Do not use this member.
    ushort Reserved;
    ///Remote protocol information. This member can be set to zero or more of the following flags. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="REMOTE_PROTOCOL_FLAG_LOOPBACK"></a><a
    ///id="remote_protocol_flag_loopback"></a><dl> <dt><b>REMOTE_PROTOCOL_FLAG_LOOPBACK</b></dt> <dt>0x1</dt> </dl>
    ///</td> <td width="60%"> The remote protocol is using a loopback. </td> </tr> <tr> <td width="40%"><a
    ///id="REMOTE_PROTOCOL_FLAG_OFFLINE"></a><a id="remote_protocol_flag_offline"></a><dl>
    ///<dt><b>REMOTE_PROTOCOL_FLAG_OFFLINE</b></dt> <dt>0x2</dt> </dl> </td> <td width="60%"> The remote protocol is
    ///using an offline cache. </td> </tr> <tr> <td width="40%"><a
    ///id="REMOTE_PROTOCOL_INFO_FLAG_PERSISTENT_HANDLE"></a><a id="remote_protocol_info_flag_persistent_handle"></a><dl>
    ///<dt><b>REMOTE_PROTOCOL_INFO_FLAG_PERSISTENT_HANDLE</b></dt> <dt>0x4</dt> </dl> </td> <td width="60%"> The remote
    ///protocol is using a persistent handle. <b>Windows 7 and Windows Server 2008 R2: </b>This flag is not supported
    ///before Windows 8 and Windows Server 2012. </td> </tr> <tr> <td width="40%"><a
    ///id="REMOTE_PROTOCOL_INFO_FLAG_PRIVACY"></a><a id="remote_protocol_info_flag_privacy"></a><dl>
    ///<dt><b>REMOTE_PROTOCOL_INFO_FLAG_PRIVACY</b></dt> <dt>0x8</dt> </dl> </td> <td width="60%"> The remote protocol
    ///is using privacy. This is only supported if the <b>StructureVersion</b> member is 2 or higher. <b>Windows 7 and
    ///Windows Server 2008 R2: </b>This flag is not supported before Windows 8 and Windows Server 2012. </td> </tr> <tr>
    ///<td width="40%"><a id="REMOTE_PROTOCOL_INFO_FLAG_INTEGRITY"></a><a
    ///id="remote_protocol_info_flag_integrity"></a><dl> <dt><b>REMOTE_PROTOCOL_INFO_FLAG_INTEGRITY</b></dt>
    ///<dt>0x10</dt> </dl> </td> <td width="60%"> The remote protocol is using integrity so the data is signed. This is
    ///only supported if the <b>StructureVersion</b> member is 2 or higher. <b>Windows 7 and Windows Server 2008 R2:
    ///</b>This flag is not supported before Windows 8 and Windows Server 2012. </td> </tr> <tr> <td width="40%"><a
    ///id="REMOTE_PROTOCOL_INFO_FLAG_MUTUAL_AUTH"></a><a id="remote_protocol_info_flag_mutual_auth"></a><dl>
    ///<dt><b>REMOTE_PROTOCOL_INFO_FLAG_MUTUAL_AUTH</b></dt> <dt>0x20</dt> </dl> </td> <td width="60%"> The remote
    ///protocol is using mutual authentication using Kerberos. This is only supported if the <b>StructureVersion</b>
    ///member is 2 or higher. <b>Windows 7 and Windows Server 2008 R2: </b>This flag is not supported before Windows 8
    ///and Windows Server 2012. </td> </tr> </table>
    uint   Flags;
    struct GenericReserved
    {
        uint[8] Reserved;
    }
    union ProtocolSpecific
    {
        struct Smb2
        {
            struct Server
            {
                uint Capabilities;
            }
            struct Share
            {
                uint Capabilities;
                uint CachingFlags;
            }
        }
        uint[16] Reserved;
    }
}

///Specifies the type of ID that is being used.
struct FILE_ID_DESCRIPTOR
{
    ///The size of this <b>FILE_ID_DESCRIPTOR</b> structure.
    uint         dwSize;
    ///The discriminator for the union indicating the type of identifier that is being passed. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FileIdType"></a><a id="fileidtype"></a><a
    ///id="FILEIDTYPE"></a><dl> <dt><b>FileIdType</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Use the <b>FileId</b>
    ///member of the union. </td> </tr> <tr> <td width="40%"><a id="ObjectIdType"></a><a id="objectidtype"></a><a
    ///id="OBJECTIDTYPE"></a><dl> <dt><b>ObjectIdType</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Use the
    ///<b>ObjectId</b> member of the union. </td> </tr> <tr> <td width="40%"><a id="ExtendedFileIdType"></a><a
    ///id="extendedfileidtype"></a><a id="EXTENDEDFILEIDTYPE"></a><dl> <dt><b>ExtendedFileIdType</b></dt> <dt>2</dt>
    ///</dl> </td> <td width="60%"> Use the <b>ExtendedFileId</b> member of the union. <b>Windows XP, Windows Server
    ///2003, Windows Vista, Windows Server 2008, Windows 7 and Windows Server 2008 R2: </b>This value is not supported
    ///before Windows 8 and Windows Server 2012. </td> </tr> </table>
    FILE_ID_TYPE Type;
    union
    {
        LARGE_INTEGER FileId;
        GUID          ObjectId;
        FILE_ID_128   ExtendedFileId;
    }
}

// Functions

///Creates a new directory. If the underlying file system supports security on files and directories, the function
///applies a specified security descriptor to the new directory. To specify a template directory, use the
///CreateDirectoryEx function. To perform this operation as a transacted operation, use the CreateDirectoryTransacted
///function.
///Params:
///    lpPathName = The path of the directory to be created. For the ANSI version of this function, there is a default string size
///                 limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to
///                 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more
///                 information, see Naming a File <div class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the
///                 unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation
///                 without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length
///                 Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    lpSecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a
///                           security descriptor for the new directory. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a
///                           default security descriptor. The ACLs in the default security descriptor for a directory are inherited from its
///                           parent directory. The target file system must support security on files and directories for this parameter to
///                           have an effect. (This is indicated when GetVolumeInformation returns <b>FS_PERSISTENT_ACLS</b>.)
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Possible errors include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td>
///    <td width="60%"> The specified directory already exists. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> One or more intermediate directories do not
///    exist; this function will only create the final directory in the path. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL CreateDirectoryA(const(char)* lpPathName, SECURITY_ATTRIBUTES* lpSecurityAttributes);

///Creates a new directory. If the underlying file system supports security on files and directories, the function
///applies a specified security descriptor to the new directory. To specify a template directory, use the
///CreateDirectoryEx function. To perform this operation as a transacted operation, use the CreateDirectoryTransacted
///function.
///Params:
///    lpPathName = The path of the directory to be created. For the ANSI version of this function, there is a default string size
///                 limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to
///                 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more
///                 information, see Naming a File <div class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the
///                 unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation
///                 without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length
///                 Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    lpSecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a
///                           security descriptor for the new directory. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a
///                           default security descriptor. The ACLs in the default security descriptor for a directory are inherited from its
///                           parent directory. The target file system must support security on files and directories for this parameter to
///                           have an effect. (This is indicated when GetVolumeInformation returns <b>FS_PERSISTENT_ACLS</b>.)
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Possible errors include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td>
///    <td width="60%"> The specified directory already exists. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> One or more intermediate directories do not
///    exist; this function will only create the final directory in the path. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL CreateDirectoryW(const(wchar)* lpPathName, SECURITY_ATTRIBUTES* lpSecurityAttributes);

///Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream,
///directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The
///function returns a handle that can be used to access the file or device for various types of I/O depending on the
///file or device and the flags and attributes specified. To perform this operation as a transacted operation, which
///results in a handle that can be used for transacted I/O, use the CreateFileTransacted function.
///Params:
///    lpFileName = The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes
///                 (\\) in this name. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To
///                 extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to
///                 the path. For more information, see Naming Files, Paths, and Namespaces. For information on special device names,
///                 see Defining an MS-DOS Device Name. To create a file stream, specify the name of the file, a colon, and then the
///                 name of the stream. For more information, see File Streams. <div class="alert"><b>Tip</b> Starting with Windows
///                 10, version 1607, for the unicode version of this function (<b>CreateFileW</b>), you can opt-in to remove the
///                 <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming
///                 Files, Paths, and Namespaces for details.</div> <div> </div>
///    dwDesiredAccess = The requested access to the file or device, which can be summarized as read, write, both or neither zero). The
///                      most commonly used values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both (<code>GENERIC_READ |
///                      GENERIC_WRITE</code>). For more information, see Generic Access Rights, File Security and Access Rights, File
///                      Access Rights Constants, and ACCESS_MASK. If this parameter is zero, the application can query certain metadata
///                      such as file, directory, or device attributes without accessing that file or device, even if <b>GENERIC_READ</b>
///                      access would have been denied. You cannot request an access mode that conflicts with the sharing mode that is
///                      specified by the <i>dwShareMode</i> parameter in an open request that already has an open handle. For more
///                      information, see the Remarks section of this topic and Creating and Opening Files.
///    dwShareMode = The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none
///                  (refer to the following table). Access requests to attributes or extended attributes are not affected by this
///                  flag. If this parameter is zero and <b>CreateFile</b> succeeds, the file or device cannot be shared and cannot be
///                  opened again until the handle to the file or device is closed. For more information, see the Remarks section. You
///                  cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that
///                  has an open handle. <b>CreateFile</b> would fail and the GetLastError function would return
///                  <b>ERROR_SHARING_VIOLATION</b>. To enable a process to share a file or device while another process has the file
///                  or device open, use a compatible combination of one or more of the following values. For more information about
///                  valid combinations of this parameter with the <i>dwDesiredAccess</i> parameter, see Creating and Opening Files.
///                  <div class="alert"><b>Note</b> The sharing options for each open handle remain in effect until that handle is
///                  closed, regardless of process context.</div> <div> </div> <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                  <td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> Prevents
///                  other processes from opening a file or device if they request delete, read, or write access. </td> </tr> <tr> <td
///                  width="40%"><a id="FILE_SHARE_DELETE"></a><a id="file_share_delete"></a><dl> <dt><b>FILE_SHARE_DELETE</b></dt>
///                  <dt>0x00000004</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on a file or device to
///                  request delete access. Otherwise, other processes cannot open the file or device if they request delete access.
///                  If this flag is not specified, but the file or device has been opened for delete access, the function fails. <div
///                  class="alert"><b>Note</b> Delete access allows both delete and rename operations.</div> <div> </div> </td> </tr>
///                  <tr> <td width="40%"><a id="FILE_SHARE_READ"></a><a id="file_share_read"></a><dl> <dt><b>FILE_SHARE_READ</b></dt>
///                  <dt>0x00000001</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on a file or device to
///                  request read access. Otherwise, other processes cannot open the file or device if they request read access. If
///                  this flag is not specified, but the file or device has been opened for read access, the function fails. </td>
///                  </tr> <tr> <td width="40%"><a id="FILE_SHARE_WRITE"></a><a id="file_share_write"></a><dl>
///                  <dt><b>FILE_SHARE_WRITE</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Enables subsequent open
///                  operations on a file or device to request write access. Otherwise, other processes cannot open the file or device
///                  if they request write access. If this flag is not specified, but the file or device has been opened for write
///                  access or has a file mapping with write access, the function fails. </td> </tr> </table>
///    lpSecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: an optional
///                           security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child
///                           processes. This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the handle returned by
///                           <b>CreateFile</b> cannot be inherited by any child processes the application may create and the file or device
///                           associated with the returned handle gets a default security descriptor. The <b>lpSecurityDescriptor</b> member of
///                           the structure specifies a SECURITY_DESCRIPTOR for a file or device. If this member is <b>NULL</b>, the file or
///                           device associated with the returned handle is assigned a default security descriptor. <b>CreateFile</b> ignores
///                           the <b>lpSecurityDescriptor</b> member when opening an existing file or device, but continues to use the
///                           <b>bInheritHandle</b> member. The <b>bInheritHandle</b>member of the structure specifies whether the returned
///                           handle can be inherited. For more information, see the Remarks section.
///    dwCreationDisposition = An action to take on a file or device that exists or does not exist. For devices other than files, this parameter
///                            is usually set to <b>OPEN_EXISTING</b>. For more information, see the Remarks section. This parameter must be one
///                            of the following values, which cannot be combined: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                            width="40%"><a id="CREATE_ALWAYS"></a><a id="create_always"></a><dl> <dt><b>CREATE_ALWAYS</b></dt> <dt>2</dt>
///                            </dl> </td> <td width="60%"> Creates a new file, always. If the specified file exists and is writable, the
///                            function overwrites the file, the function succeeds, and last-error code is set to <b>ERROR_ALREADY_EXISTS</b>
///                            (183). If the specified file does not exist and is a valid path, a new file is created, the function succeeds,
///                            and the last-error code is set to zero. For more information, see the Remarks section of this topic. </td> </tr>
///                            <tr> <td width="40%"><a id="CREATE_NEW"></a><a id="create_new"></a><dl> <dt><b>CREATE_NEW</b></dt> <dt>1</dt>
///                            </dl> </td> <td width="60%"> Creates a new file, only if it does not already exist. If the specified file exists,
///                            the function fails and the last-error code is set to <b>ERROR_FILE_EXISTS</b> (80). If the specified file does
///                            not exist and is a valid path to a writable location, a new file is created. </td> </tr> <tr> <td width="40%"><a
///                            id="OPEN_ALWAYS"></a><a id="open_always"></a><dl> <dt><b>OPEN_ALWAYS</b></dt> <dt>4</dt> </dl> </td> <td
///                            width="60%"> Opens a file, always. If the specified file exists, the function succeeds and the last-error code is
///                            set to <b>ERROR_ALREADY_EXISTS</b> (183). If the specified file does not exist and is a valid path to a writable
///                            location, the function creates a file and the last-error code is set to zero. </td> </tr> <tr> <td width="40%"><a
///                            id="OPEN_EXISTING"></a><a id="open_existing"></a><dl> <dt><b>OPEN_EXISTING</b></dt> <dt>3</dt> </dl> </td> <td
///                            width="60%"> Opens a file or device, only if it exists. If the specified file or device does not exist, the
///                            function fails and the last-error code is set to <b>ERROR_FILE_NOT_FOUND</b> (2). For more information about
///                            devices, see the Remarks section. </td> </tr> <tr> <td width="40%"><a id="TRUNCATE_EXISTING"></a><a
///                            id="truncate_existing"></a><dl> <dt><b>TRUNCATE_EXISTING</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Opens a
///                            file and truncates it so that its size is zero bytes, only if it exists. If the specified file does not exist,
///                            the function fails and the last-error code is set to <b>ERROR_FILE_NOT_FOUND</b> (2). The calling process must
///                            open the file with the <b>GENERIC_WRITE</b> bit set as part of the <i>dwDesiredAccess</i> parameter. </td> </tr>
///                            </table>
///    dwFlagsAndAttributes = The file or device attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default value for
///                           files. This parameter can include any combination of the available file attributes (<b>FILE_ATTRIBUTE_*</b>). All
///                           other file attributes override <b>FILE_ATTRIBUTE_NORMAL</b>. This parameter can also contain combinations of
///                           flags (<b>FILE_FLAG_*</b>) for control of file or device caching behavior, access modes, and other
///                           special-purpose flags. These combine with any <b>FILE_ATTRIBUTE_*</b> values. This parameter can also contain
///                           Security Quality of Service (SQOS) information by specifying the <b>SECURITY_SQOS_PRESENT</b> flag. Additional
///                           SQOS-related flags information is presented in the table following the attributes and flags tables. <div
///                           class="alert"><b>Note</b> When <b>CreateFile</b> opens an existing file, it generally combines the file flags
///                           with the file attributes of the existing file, and ignores any file attributes supplied as part of
///                           <i>dwFlagsAndAttributes</i>. Special cases are detailed in Creating and Opening Files.</div> <div> </div> Some of
///                           the following file attributes and flags may only apply to files and not necessarily all other types of devices
///                           that <b>CreateFile</b> can open. For additional information, see the Remarks section of this topic and Creating
///                           and Opening Files. For more advanced access to file attributes, see SetFileAttributes. For a complete list of all
///                           file attributes with their values and descriptions, see File Attribute Constants. <table> <tr> <th>Attribute</th>
///                           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a
///                           id="file_attribute_archive"></a><dl> <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt> <dt>32 (0x20)</dt> </dl> </td> <td
///                           width="60%"> The file should be archived. Applications use this attribute to mark files for backup or removal.
///                           </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_ENCRYPTED"></a><a id="file_attribute_encrypted"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt> <dt>16384 (0x4000)</dt> </dl> </td> <td width="60%"> The file or
///                           directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory, this
///                           means that encryption is the default for newly created files and subdirectories. For more information, see File
///                           Encryption. This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified. This flag is not supported
///                           on Home, Home Premium, Starter, or ARM editions of Windows. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl> <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt> <dt>2
///                           (0x2)</dt> </dl> </td> <td width="60%"> The file is hidden. Do not include it in an ordinary directory listing.
///                           </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt> <dt>128 (0x80)</dt> </dl> </td> <td width="60%"> The file does not have
///                           other attributes set. This attribute is valid only if used alone. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl> <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
///                           <dt>4096 (0x1000)</dt> </dl> </td> <td width="60%"> The data of a file is not immediately available. This
///                           attribute indicates that file data is physically moved to offline storage. This attribute is used by Remote
///                           Storage, the hierarchical storage management software. Applications should not arbitrarily change this attribute.
///                           </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_READONLY</b></dt> <dt>1 (0x1)</dt> </dl> </td> <td width="60%"> The file is read only.
///                           Applications can read the file, but cannot write to or delete it. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl> <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt> <dt>4
///                           (0x4)</dt> </dl> </td> <td width="60%"> The file is part of or used exclusively by an operating system. </td>
///                           </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt> <dt>256 (0x100)</dt> </dl> </td> <td width="60%"> The file is being used
///                           for temporary storage. For more information, see the <a href="
///    hTemplateFile = A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template file supplies file
///                    attributes and extended attributes for the file that is being created. This parameter can be <b>NULL</b>. When
///                    opening an existing file, <b>CreateFile</b> ignores this parameter. When opening a new encrypted file, the file
///                    inherits the discretionary access control list from its parent directory. For additional information, see File
///                    Encryption.
///Returns:
///    If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail
///    slot. If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information,
///    call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateFileA(const(char)* lpFileName, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_FLAGS dwShareMode, 
                   SECURITY_ATTRIBUTES* lpSecurityAttributes, FILE_CREATE_FLAGS dwCreationDisposition, 
                   FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, HANDLE hTemplateFile);

///Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream,
///directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The
///function returns a handle that can be used to access the file or device for various types of I/O depending on the
///file or device and the flags and attributes specified. To perform this operation as a transacted operation, which
///results in a handle that can be used for transacted I/O, use the CreateFileTransacted function.
///Params:
///    lpFileName = The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes
///                 (\\) in this name. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To
///                 extend this limit to 32,767 wide characters, use this Unicode version of the function and prepend "\\\\?\\" to
///                 the path. For more information, see Naming Files, Paths, and Namespaces. For information on special device names,
///                 see Defining an MS-DOS Device Name. To create a file stream, specify the name of the file, a colon, and then the
///                 name of the stream. For more information, see File Streams. <div class="alert"><b>Tip</b> Starting with Windows
///                 10, version 1607, for the unicode version of this function (<b>CreateFileW</b>), you can opt-in to remove the
///                 <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming
///                 Files, Paths, and Namespaces for details.</div> <div> </div>
///    dwDesiredAccess = The requested access to the file or device, which can be summarized as read, write, both or neither zero). The
///                      most commonly used values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both (<code>GENERIC_READ |
///                      GENERIC_WRITE</code>). For more information, see Generic Access Rights, File Security and Access Rights, File
///                      Access Rights Constants, and ACCESS_MASK. If this parameter is zero, the application can query certain metadata
///                      such as file, directory, or device attributes without accessing that file or device, even if <b>GENERIC_READ</b>
///                      access would have been denied. You cannot request an access mode that conflicts with the sharing mode that is
///                      specified by the <i>dwShareMode</i> parameter in an open request that already has an open handle. For more
///                      information, see the Remarks section of this topic and Creating and Opening Files.
///    dwShareMode = The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none
///                  (refer to the following table). Access requests to attributes or extended attributes are not affected by this
///                  flag. If this parameter is zero and <b>CreateFile</b> succeeds, the file or device cannot be shared and cannot be
///                  opened again until the handle to the file or device is closed. For more information, see the Remarks section. You
///                  cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that
///                  has an open handle. <b>CreateFile</b> would fail and the GetLastError function would return
///                  <b>ERROR_SHARING_VIOLATION</b>. To enable a process to share a file or device while another process has the file
///                  or device open, use a compatible combination of one or more of the following values. For more information about
///                  valid combinations of this parameter with the <i>dwDesiredAccess</i> parameter, see Creating and Opening Files.
///                  <div class="alert"><b>Note</b> The sharing options for each open handle remain in effect until that handle is
///                  closed, regardless of process context.</div> <div> </div> <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                  <td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> Prevents
///                  other processes from opening a file or device if they request delete, read, or write access. </td> </tr> <tr> <td
///                  width="40%"><a id="FILE_SHARE_DELETE"></a><a id="file_share_delete"></a><dl> <dt><b>FILE_SHARE_DELETE</b></dt>
///                  <dt>0x00000004</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on a file or device to
///                  request delete access. Otherwise, other processes cannot open the file or device if they request delete access.
///                  If this flag is not specified, but the file or device has been opened for delete access, the function fails. <div
///                  class="alert"><b>Note</b> Delete access allows both delete and rename operations.</div> <div> </div> </td> </tr>
///                  <tr> <td width="40%"><a id="FILE_SHARE_READ"></a><a id="file_share_read"></a><dl> <dt><b>FILE_SHARE_READ</b></dt>
///                  <dt>0x00000001</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on a file or device to
///                  request read access. Otherwise, other processes cannot open the file or device if they request read access. If
///                  this flag is not specified, but the file or device has been opened for read access, the function fails. </td>
///                  </tr> <tr> <td width="40%"><a id="FILE_SHARE_WRITE"></a><a id="file_share_write"></a><dl>
///                  <dt><b>FILE_SHARE_WRITE</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Enables subsequent open
///                  operations on a file or device to request write access. Otherwise, other processes cannot open the file or device
///                  if they request write access. If this flag is not specified, but the file or device has been opened for write
///                  access or has a file mapping with write access, the function fails. </td> </tr> </table>
///    lpSecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: an optional
///                           security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child
///                           processes. This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the handle returned by
///                           <b>CreateFile</b> cannot be inherited by any child processes the application may create and the file or device
///                           associated with the returned handle gets a default security descriptor. The <b>lpSecurityDescriptor</b> member of
///                           the structure specifies a SECURITY_DESCRIPTOR for a file or device. If this member is <b>NULL</b>, the file or
///                           device associated with the returned handle is assigned a default security descriptor. <b>CreateFile</b> ignores
///                           the <b>lpSecurityDescriptor</b> member when opening an existing file or device, but continues to use the
///                           <b>bInheritHandle</b> member. The <b>bInheritHandle</b>member of the structure specifies whether the returned
///                           handle can be inherited. For more information, see the Remarks section.
///    dwCreationDisposition = An action to take on a file or device that exists or does not exist. For devices other than files, this parameter
///                            is usually set to <b>OPEN_EXISTING</b>. For more information, see the Remarks section. This parameter must be one
///                            of the following values, which cannot be combined: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                            width="40%"><a id="CREATE_ALWAYS"></a><a id="create_always"></a><dl> <dt><b>CREATE_ALWAYS</b></dt> <dt>2</dt>
///                            </dl> </td> <td width="60%"> Creates a new file, always. If the specified file exists and is writable, the
///                            function overwrites the file, the function succeeds, and last-error code is set to <b>ERROR_ALREADY_EXISTS</b>
///                            (183). If the specified file does not exist and is a valid path, a new file is created, the function succeeds,
///                            and the last-error code is set to zero. For more information, see the Remarks section of this topic. </td> </tr>
///                            <tr> <td width="40%"><a id="CREATE_NEW"></a><a id="create_new"></a><dl> <dt><b>CREATE_NEW</b></dt> <dt>1</dt>
///                            </dl> </td> <td width="60%"> Creates a new file, only if it does not already exist. If the specified file exists,
///                            the function fails and the last-error code is set to <b>ERROR_FILE_EXISTS</b> (80). If the specified file does
///                            not exist and is a valid path to a writable location, a new file is created. </td> </tr> <tr> <td width="40%"><a
///                            id="OPEN_ALWAYS"></a><a id="open_always"></a><dl> <dt><b>OPEN_ALWAYS</b></dt> <dt>4</dt> </dl> </td> <td
///                            width="60%"> Opens a file, always. If the specified file exists, the function succeeds and the last-error code is
///                            set to <b>ERROR_ALREADY_EXISTS</b> (183). If the specified file does not exist and is a valid path to a writable
///                            location, the function creates a file and the last-error code is set to zero. </td> </tr> <tr> <td width="40%"><a
///                            id="OPEN_EXISTING"></a><a id="open_existing"></a><dl> <dt><b>OPEN_EXISTING</b></dt> <dt>3</dt> </dl> </td> <td
///                            width="60%"> Opens a file or device, only if it exists. If the specified file or device does not exist, the
///                            function fails and the last-error code is set to <b>ERROR_FILE_NOT_FOUND</b> (2). For more information about
///                            devices, see the Remarks section. </td> </tr> <tr> <td width="40%"><a id="TRUNCATE_EXISTING"></a><a
///                            id="truncate_existing"></a><dl> <dt><b>TRUNCATE_EXISTING</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Opens a
///                            file and truncates it so that its size is zero bytes, only if it exists. If the specified file does not exist,
///                            the function fails and the last-error code is set to <b>ERROR_FILE_NOT_FOUND</b> (2). The calling process must
///                            open the file with the <b>GENERIC_WRITE</b> bit set as part of the <i>dwDesiredAccess</i> parameter. </td> </tr>
///                            </table>
///    dwFlagsAndAttributes = The file or device attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default value for
///                           files. This parameter can include any combination of the available file attributes (<b>FILE_ATTRIBUTE_*</b>). All
///                           other file attributes override <b>FILE_ATTRIBUTE_NORMAL</b>. This parameter can also contain combinations of
///                           flags (<b>FILE_FLAG_*</b>) for control of file or device caching behavior, access modes, and other
///                           special-purpose flags. These combine with any <b>FILE_ATTRIBUTE_*</b> values. This parameter can also contain
///                           Security Quality of Service (SQOS) information by specifying the <b>SECURITY_SQOS_PRESENT</b> flag. Additional
///                           SQOS-related flags information is presented in the table following the attributes and flags tables. <div
///                           class="alert"><b>Note</b> When <b>CreateFile</b> opens an existing file, it generally combines the file flags
///                           with the file attributes of the existing file, and ignores any file attributes supplied as part of
///                           <i>dwFlagsAndAttributes</i>. Special cases are detailed in Creating and Opening Files.</div> <div> </div> Some of
///                           the following file attributes and flags may only apply to files and not necessarily all other types of devices
///                           that <b>CreateFile</b> can open. For additional information, see the Remarks section of this topic and Creating
///                           and Opening Files. For more advanced access to file attributes, see SetFileAttributes. For a complete list of all
///                           file attributes with their values and descriptions, see File Attribute Constants. <table> <tr> <th>Attribute</th>
///                           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a
///                           id="file_attribute_archive"></a><dl> <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt> <dt>32 (0x20)</dt> </dl> </td> <td
///                           width="60%"> The file should be archived. Applications use this attribute to mark files for backup or removal.
///                           </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_ENCRYPTED"></a><a id="file_attribute_encrypted"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt> <dt>16384 (0x4000)</dt> </dl> </td> <td width="60%"> The file or
///                           directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory, this
///                           means that encryption is the default for newly created files and subdirectories. For more information, see File
///                           Encryption. This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified. This flag is not supported
///                           on Home, Home Premium, Starter, or ARM editions of Windows. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl> <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt> <dt>2
///                           (0x2)</dt> </dl> </td> <td width="60%"> The file is hidden. Do not include it in an ordinary directory listing.
///                           </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt> <dt>128 (0x80)</dt> </dl> </td> <td width="60%"> The file does not have
///                           other attributes set. This attribute is valid only if used alone. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl> <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
///                           <dt>4096 (0x1000)</dt> </dl> </td> <td width="60%"> The data of a file is not immediately available. This
///                           attribute indicates that file data is physically moved to offline storage. This attribute is used by Remote
///                           Storage, the hierarchical storage management software. Applications should not arbitrarily change this attribute.
///                           </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_READONLY</b></dt> <dt>1 (0x1)</dt> </dl> </td> <td width="60%"> The file is read only.
///                           Applications can read the file, but cannot write to or delete it. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl> <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt> <dt>4
///                           (0x4)</dt> </dl> </td> <td width="60%"> The file is part of or used exclusively by an operating system. </td>
///                           </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt> <dt>256 (0x100)</dt> </dl> </td> <td width="60%"> The file is being used
///                           for temporary storage. For more information, see the <a href="
///    hTemplateFile = A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template file supplies file
///                    attributes and extended attributes for the file that is being created. This parameter can be <b>NULL</b>. When
///                    opening an existing file, <b>CreateFile</b> ignores this parameter. When opening a new encrypted file, the file
///                    inherits the discretionary access control list from its parent directory. For additional information, see File
///                    Encryption.
///Returns:
///    If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail
///    slot. If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information,
///    call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateFileW(const(wchar)* lpFileName, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_FLAGS dwShareMode, 
                   SECURITY_ATTRIBUTES* lpSecurityAttributes, FILE_CREATE_FLAGS dwCreationDisposition, 
                   FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, HANDLE hTemplateFile);

///Defines, redefines, or deletes MS-DOS device names.
///Params:
///    dwFlags = The controllable aspects of the <b>DefineDosDevice</b> function. This parameter can be one or more of the
///              following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="DDD_EXACT_MATCH_ON_REMOVE"></a><a id="ddd_exact_match_on_remove"></a><dl>
///              <dt><b>DDD_EXACT_MATCH_ON_REMOVE</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> If this value is
///              specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will use an exact match to determine which
///              mapping to remove. Use this value to ensure that you do not delete something that you did not define. </td> </tr>
///              <tr> <td width="40%"><a id="DDD_NO_BROADCAST_SYSTEM"></a><a id="ddd_no_broadcast_system"></a><dl>
///              <dt><b>DDD_NO_BROADCAST_SYSTEM</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> Do not broadcast the
///              WM_SETTINGCHANGE message. By default, this message is broadcast to notify the shell and applications of the
///              change. </td> </tr> <tr> <td width="40%"><a id="DDD_RAW_TARGET_PATH"></a><a id="ddd_raw_target_path"></a><dl>
///              <dt><b>DDD_RAW_TARGET_PATH</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Uses the <i>lpTargetPath</i>
///              string as is. Otherwise, it is converted from an MS-DOS path to a path. </td> </tr> <tr> <td width="40%"><a
///              id="DDD_REMOVE_DEFINITION"></a><a id="ddd_remove_definition"></a><dl> <dt><b>DDD_REMOVE_DEFINITION</b></dt>
///              <dt>0x00000002</dt> </dl> </td> <td width="60%"> Removes the specified definition for the specified device. To
///              determine which definition to remove, the function walks the list of mappings for the device, looking for a match
///              of <i>lpTargetPath</i> against a prefix of each mapping associated with this device. The first mapping that
///              matches is the one removed, and then the function returns. If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to
///              a <b>NULL</b> string, the function will remove the first mapping associated with the device and pop the most
///              recent one pushed. If there is nothing left to pop, the device name will be removed. If this value is not
///              specified, the string pointed to by the <i>lpTargetPath</i> parameter will become the new mapping for this
///              device. </td> </tr> </table>
///    lpDeviceName = A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or
///                   deleting. The device name string must not have a colon as the last character, unless a drive letter is being
///                   defined, redefined, or deleted. For example, drive C would be the string "C:". In no case is a trailing backslash
///                   ("\") allowed.
///    lpTargetPath = A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the
///                   <b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path string.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DefineDosDeviceW(DEFINE_DOS_DEVICE_FLAGS dwFlags, const(wchar)* lpDeviceName, const(wchar)* lpTargetPath);

///Deletes an existing file. To perform this operation as a transacted operation, use the DeleteFileTransacted function.
///Params:
///    lpFileName = The name of the file to be deleted. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\\\?\\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting in Windows
///                 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the
///                 <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of
///                 Naming Files, Paths, and Namespaces for details. </div> <div> </div>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DeleteFileA(const(char)* lpFileName);

///Deletes an existing file. To perform this operation as a transacted operation, use the DeleteFileTransacted function.
///Params:
///    lpFileName = The name of the file to be deleted. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\\\?\\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting in Windows
///                 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the
///                 <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of
///                 Naming Files, Paths, and Namespaces for details. </div> <div> </div>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DeleteFileW(const(wchar)* lpFileName);

///Deletes a drive letter or mounted folder.
///Params:
///    lpszVolumeMountPoint = The drive letter or mounted folder to be deleted. A trailing backslash is required, for example, "X:\" or
///                           "Y:\MountX\".
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DeleteVolumeMountPointW(const(wchar)* lpszVolumeMountPoint);

///Closes a file search handle opened by the FindFirstFile, FindFirstFileEx, FindFirstFileNameW,
///FindFirstFileNameTransactedW, FindFirstFileTransacted, FindFirstStreamTransactedW, or FindFirstStreamW functions.
///Params:
///    hFindFile = The file search handle.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL FindClose(HANDLE hFindFile);

///Stops change notification handle monitoring.
///Params:
///    hChangeHandle = A handle to a change notification handle created by the FindFirstChangeNotification function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL FindCloseChangeNotification(FindChangeNotifcationHandle hChangeHandle);

///Creates a change notification handle and sets up initial change notification filter conditions. A wait on a
///notification handle succeeds when a change matching the filter conditions occurs in the specified directory or
///subtree. The function does not report changes to the specified directory itself. This function does not indicate the
///change that satisfied the wait condition. To retrieve information about the specific change as part of the
///notification, use the ReadDirectoryChangesW function.
///Params:
///    lpPathName = The full path of the directory to be watched. This cannot be a relative path or an empty string. In the ANSI
///                 version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide
///                 characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see
///                 Naming a File.
///    bWatchSubtree = If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if
///                    it is <b>FALSE</b>, it monitors only the specified directory.
///    dwNotifyFilter = The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following
///                     values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                     id="FILE_NOTIFY_CHANGE_FILE_NAME"></a><a id="file_notify_change_file_name"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_FILE_NAME</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Any file name
///                     change in the watched directory or subtree causes a change notification wait operation to return. Changes include
///                     renaming, creating, or deleting a file name. </td> </tr> <tr> <td width="40%"><a
///                     id="FILE_NOTIFY_CHANGE_DIR_NAME"></a><a id="file_notify_change_dir_name"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_DIR_NAME</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Any directory-name
///                     change in the watched directory or subtree causes a change notification wait operation to return. Changes include
///                     creating or deleting a directory. </td> </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_ATTRIBUTES"></a><a
///                     id="file_notify_change_attributes"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b></dt> <dt>0x00000004</dt>
///                     </dl> </td> <td width="60%"> Any attribute change in the watched directory or subtree causes a change
///                     notification wait operation to return. </td> </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_SIZE"></a><a
///                     id="file_notify_change_size"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_SIZE</b></dt> <dt>0x00000008</dt> </dl> </td> <td
///                     width="60%"> Any file-size change in the watched directory or subtree causes a change notification wait operation
///                     to return. The operating system detects a change in file size only when the file is written to the disk. For
///                     operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed. </td>
///                     </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_LAST_WRITE"></a><a
///                     id="file_notify_change_last_write"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_LAST_WRITE</b></dt> <dt>0x00000010</dt>
///                     </dl> </td> <td width="60%"> Any change to the last write-time of files in the watched directory or subtree
///                     causes a change notification wait operation to return. The operating system detects a change to the last
///                     write-time only when the file is written to the disk. For operating systems that use extensive caching, detection
///                     occurs only when the cache is sufficiently flushed. </td> </tr> <tr> <td width="40%"><a
///                     id="FILE_NOTIFY_CHANGE_SECURITY"></a><a id="file_notify_change_security"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_SECURITY</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> Any
///                     security-descriptor change in the watched directory or subtree causes a change notification wait operation to
///                     return. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a handle to a find change notification object. If the function
///    fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
FindChangeNotifcationHandle FindFirstChangeNotificationA(const(char)* lpPathName, BOOL bWatchSubtree, 
                                                         FILE_NOTIFY_CHANGE dwNotifyFilter);

///Creates a change notification handle and sets up initial change notification filter conditions. A wait on a
///notification handle succeeds when a change matching the filter conditions occurs in the specified directory or
///subtree. The function does not report changes to the specified directory itself. This function does not indicate the
///change that satisfied the wait condition. To retrieve information about the specific change as part of the
///notification, use the ReadDirectoryChangesW function.
///Params:
///    lpPathName = The full path of the directory to be watched. This cannot be a relative path or an empty string. In the ANSI
///                 version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide
///                 characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see
///                 Naming a File.
///    bWatchSubtree = If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if
///                    it is <b>FALSE</b>, it monitors only the specified directory.
///    dwNotifyFilter = The filter conditions that satisfy a change notification wait. This parameter can be one or more of the following
///                     values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                     id="FILE_NOTIFY_CHANGE_FILE_NAME"></a><a id="file_notify_change_file_name"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_FILE_NAME</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Any file name
///                     change in the watched directory or subtree causes a change notification wait operation to return. Changes include
///                     renaming, creating, or deleting a file name. </td> </tr> <tr> <td width="40%"><a
///                     id="FILE_NOTIFY_CHANGE_DIR_NAME"></a><a id="file_notify_change_dir_name"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_DIR_NAME</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Any directory-name
///                     change in the watched directory or subtree causes a change notification wait operation to return. Changes include
///                     creating or deleting a directory. </td> </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_ATTRIBUTES"></a><a
///                     id="file_notify_change_attributes"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b></dt> <dt>0x00000004</dt>
///                     </dl> </td> <td width="60%"> Any attribute change in the watched directory or subtree causes a change
///                     notification wait operation to return. </td> </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_SIZE"></a><a
///                     id="file_notify_change_size"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_SIZE</b></dt> <dt>0x00000008</dt> </dl> </td> <td
///                     width="60%"> Any file-size change in the watched directory or subtree causes a change notification wait operation
///                     to return. The operating system detects a change in file size only when the file is written to the disk. For
///                     operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed. </td>
///                     </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_LAST_WRITE"></a><a
///                     id="file_notify_change_last_write"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_LAST_WRITE</b></dt> <dt>0x00000010</dt>
///                     </dl> </td> <td width="60%"> Any change to the last write-time of files in the watched directory or subtree
///                     causes a change notification wait operation to return. The operating system detects a change to the last
///                     write-time only when the file is written to the disk. For operating systems that use extensive caching, detection
///                     occurs only when the cache is sufficiently flushed. </td> </tr> <tr> <td width="40%"><a
///                     id="FILE_NOTIFY_CHANGE_SECURITY"></a><a id="file_notify_change_security"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_SECURITY</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> Any
///                     security-descriptor change in the watched directory or subtree causes a change notification wait operation to
///                     return. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a handle to a find change notification object. If the function
///    fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
FindChangeNotifcationHandle FindFirstChangeNotificationW(const(wchar)* lpPathName, BOOL bWatchSubtree, 
                                                         uint dwNotifyFilter);

///Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if
///wildcards are used). To specify additional attributes to use in a search, use the FindFirstFileEx function. To
///perform this operation as a transacted operation, use the FindFirstFileTransacted function.
///Params:
///    lpFileName = The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk
///                 (*) or a question mark (?). This parameter should not be <b>NULL</b>, an invalid string (for example, an empty
///                 string or a string that is missing the terminating null character), or end in a trailing backslash (\\). If the
///                 string ends with a wildcard, period (.), or directory name, the user must have access permissions to the root and
///                 all subdirectories on the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\\\?\\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting in Windows
///                 10, version 1607, for the unicode version of this function (<b>FindFirstFileW</b>), you can opt-in to remove the
///                 <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of
///                 Naming Files, Paths, and Namespaces for details. </div> <div> </div>
///    lpFindFileData = A pointer to the WIN32_FIND_DATA structure that receives information about a found file or directory.
///Returns:
///    If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or
///    FindClose, and the <i>lpFindFileData</i> parameter contains information about the first file or directory found.
///    If the function fails or fails to locate files from the search string in the <i>lpFileName</i> parameter, the
///    return value is <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get
///    extended error information, call the GetLastError function. If the function fails because no matching files can
///    be found, the GetLastError function returns <b>ERROR_FILE_NOT_FOUND</b>.
///    
@DllImport("KERNEL32")
FindFileHandle FindFirstFileA(const(char)* lpFileName, WIN32_FIND_DATAA* lpFindFileData);

///Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if
///wildcards are used). To specify additional attributes to use in a search, use the FindFirstFileEx function. To
///perform this operation as a transacted operation, use the FindFirstFileTransacted function.
///Params:
///    lpFileName = The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk
///                 (*) or a question mark (?). This parameter should not be <b>NULL</b>, an invalid string (for example, an empty
///                 string or a string that is missing the terminating null character), or end in a trailing backslash (\\). If the
///                 string ends with a wildcard, period (.), or directory name, the user must have access permissions to the root and
///                 all subdirectories on the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\\\?\\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting in Windows
///                 10, version 1607, for the unicode version of this function (<b>FindFirstFileW</b>), you can opt-in to remove the
///                 <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of
///                 Naming Files, Paths, and Namespaces for details. </div> <div> </div>
///    lpFindFileData = A pointer to the WIN32_FIND_DATA structure that receives information about a found file or directory.
///Returns:
///    If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or
///    FindClose, and the <i>lpFindFileData</i> parameter contains information about the first file or directory found.
///    If the function fails or fails to locate files from the search string in the <i>lpFileName</i> parameter, the
///    return value is <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get
///    extended error information, call the GetLastError function. If the function fails because no matching files can
///    be found, the GetLastError function returns <b>ERROR_FILE_NOT_FOUND</b>.
///    
@DllImport("KERNEL32")
FindFileHandle FindFirstFileW(const(wchar)* lpFileName, WIN32_FIND_DATAW* lpFindFileData);

///Searches a directory for a file or subdirectory with a name and attributes that match those specified. For the most
///basic version of this function, see FindFirstFile. To perform this operation as a transacted operation, use the
///FindFirstFileTransacted function.
///Params:
///    lpFileName = The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk
///                 (*) or a question mark (?). This parameter should not be <b>NULL</b>, an invalid string (for example, an empty
///                 string or a string that is missing the terminating null character), or end in a trailing backslash (\\). If the
///                 string ends with a wildcard, period, or directory name, the user must have access to the root and all
///                 subdirectories on the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the
///                 function (<b>FindFirstFileExW</b>), and prepend "\\\\?\\" to the path. For more information, see Naming a File.
///                 <div class="alert"><b>Tip</b> Starting in Windows 10, version 1607, for the unicode version of this function
///                 (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending
///                 "\\?\". See the "Maximum Path Limitation" section of Naming Files, Paths, and Namespaces for details. </div>
///                 <div> </div>
///    fInfoLevelId = The information level of the returned data. This parameter is one of the FINDEX_INFO_LEVELS enumeration values.
///    lpFindFileData = A pointer to the buffer that receives the file data. The pointer type is determined by the level of information
///                     that is specified in the <i>fInfoLevelId</i> parameter.
///    fSearchOp = The type of filtering to perform that is different from wildcard matching. This parameter is one of the
///                FINDEX_SEARCH_OPS enumeration values.
///    lpSearchFilter = A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured search information. At this
///                     time, none of the supported <i>fSearchOp</i> values require extended search information. Therefore, this pointer
///                     must be <b>NULL</b>.
///    dwAdditionalFlags = Specifies additional flags that control the search. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                        width="40%"><a id="FIND_FIRST_EX_CASE_SENSITIVE"></a><a id="find_first_ex_case_sensitive"></a><dl>
///                        <dt><b>FIND_FIRST_EX_CASE_SENSITIVE</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Searches are case-sensitive.
///                        </td> </tr> <tr> <td width="40%"><a id="FIND_FIRST_EX_LARGE_FETCH"></a><a id="find_first_ex_large_fetch"></a><dl>
///                        <dt><b>FIND_FIRST_EX_LARGE_FETCH</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Uses a larger buffer for
///                        directory queries, which can increase performance of the find operation. <b>Windows Server 2008, Windows Vista,
///                        Windows Server 2003 and Windows XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
///                        </td> </tr> <tr> <td width="40%"><a id="FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY"></a><a
///                        id="find_first_ex_on_disk_entries_only"></a><dl> <dt><b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b></dt> <dt>4</dt>
///                        </dl> </td> <td width="60%"> Limits the results to files that are physically on disk. This flag is only relevant
///                        when a file virtualization filter is present. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or
///    FindClose, and the <i>lpFindFileData</i> parameter contains information about the first file or directory found.
///    If the function fails or fails to locate files from the search string in the <i>lpFileName</i> parameter, the
///    return value is <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get
///    extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
FindFileHandle FindFirstFileExA(const(char)* lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, char* lpFindFileData, 
                                FINDEX_SEARCH_OPS fSearchOp, void* lpSearchFilter, 
                                FIND_FIRST_EX_FLAGS dwAdditionalFlags);

///Searches a directory for a file or subdirectory with a name and attributes that match those specified. For the most
///basic version of this function, see FindFirstFile. To perform this operation as a transacted operation, use the
///FindFirstFileTransacted function.
///Params:
///    lpFileName = The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk
///                 (*) or a question mark (?). This parameter should not be <b>NULL</b>, an invalid string (for example, an empty
///                 string or a string that is missing the terminating null character), or end in a trailing backslash (\\). If the
///                 string ends with a wildcard, period, or directory name, the user must have access to the root and all
///                 subdirectories on the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the
///                 function (<b>FindFirstFileExW</b>), and prepend "\\\\?\\" to the path. For more information, see Naming a File.
///                 <div class="alert"><b>Tip</b> Starting in Windows 10, version 1607, for the unicode version of this function
///                 (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending
///                 "\\?\". See the "Maximum Path Limitation" section of Naming Files, Paths, and Namespaces for details. </div>
///                 <div> </div>
///    fInfoLevelId = The information level of the returned data. This parameter is one of the FINDEX_INFO_LEVELS enumeration values.
///    lpFindFileData = A pointer to the buffer that receives the file data. The pointer type is determined by the level of information
///                     that is specified in the <i>fInfoLevelId</i> parameter.
///    fSearchOp = The type of filtering to perform that is different from wildcard matching. This parameter is one of the
///                FINDEX_SEARCH_OPS enumeration values.
///    lpSearchFilter = A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured search information. At this
///                     time, none of the supported <i>fSearchOp</i> values require extended search information. Therefore, this pointer
///                     must be <b>NULL</b>.
///    dwAdditionalFlags = Specifies additional flags that control the search. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                        width="40%"><a id="FIND_FIRST_EX_CASE_SENSITIVE"></a><a id="find_first_ex_case_sensitive"></a><dl>
///                        <dt><b>FIND_FIRST_EX_CASE_SENSITIVE</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Searches are case-sensitive.
///                        </td> </tr> <tr> <td width="40%"><a id="FIND_FIRST_EX_LARGE_FETCH"></a><a id="find_first_ex_large_fetch"></a><dl>
///                        <dt><b>FIND_FIRST_EX_LARGE_FETCH</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Uses a larger buffer for
///                        directory queries, which can increase performance of the find operation. <b>Windows Server 2008, Windows Vista,
///                        Windows Server 2003 and Windows XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
///                        </td> </tr> <tr> <td width="40%"><a id="FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY"></a><a
///                        id="find_first_ex_on_disk_entries_only"></a><dl> <dt><b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b></dt> <dt>4</dt>
///                        </dl> </td> <td width="60%"> Limits the results to files that are physically on disk. This flag is only relevant
///                        when a file virtualization filter is present. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or
///    FindClose, and the <i>lpFindFileData</i> parameter contains information about the first file or directory found.
///    If the function fails or fails to locate files from the search string in the <i>lpFileName</i> parameter, the
///    return value is <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get
///    extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
FindFileHandle FindFirstFileExW(const(wchar)* lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, char* lpFindFileData, 
                                FINDEX_SEARCH_OPS fSearchOp, void* lpSearchFilter, 
                                FIND_FIRST_EX_FLAGS dwAdditionalFlags);

///Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a
///computer.
///Params:
///    lpszVolumeName = A pointer to a buffer that receives a null-terminated string that specifies a volume <b>GUID</b> path for the
///                     first volume that is found.
///    cchBufferLength = The length of the buffer to receive the volume <b>GUID</b> path, in <b>TCHARs</b>.
///Returns:
///    If the function succeeds, the return value is a search handle used in a subsequent call to the FindNextVolume and
///    FindVolumeClose functions. If the function fails to find any volumes, the return value is the
///    <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
FindVolumeHandle FindFirstVolumeW(const(wchar)* lpszVolumeName, uint cchBufferLength);

///Requests that the operating system signal a change notification handle the next time it detects an appropriate
///change.
///Params:
///    hChangeHandle = A handle to a change notification handle created by the FindFirstChangeNotification function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL FindNextChangeNotification(FindChangeNotifcationHandle hChangeHandle);

///Continues a file search from a previous call to the FindFirstFile, FindFirstFileEx, or FindFirstFileTransacted
///functions.
///Params:
///    hFindFile = The search handle returned by a previous call to the FindFirstFile or FindFirstFileEx function.
///    lpFindFileData = A pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.
///Returns:
///    If the function succeeds, the return value is nonzero and the <i>lpFindFileData</i> parameter contains
///    information about the next file or directory found. If the function fails, the return value is zero and the
///    contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the GetLastError
///    function. If the function fails because no more matching files can be found, the GetLastError function returns
///    <b>ERROR_NO_MORE_FILES</b>.
///    
@DllImport("KERNEL32")
BOOL FindNextFileA(FindFileHandle hFindFile, WIN32_FIND_DATAA* lpFindFileData);

///Continues a file search from a previous call to the FindFirstFile, FindFirstFileEx, or FindFirstFileTransacted
///functions.
///Params:
///    hFindFile = The search handle returned by a previous call to the FindFirstFile or FindFirstFileEx function.
///    lpFindFileData = A pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.
///Returns:
///    If the function succeeds, the return value is nonzero and the <i>lpFindFileData</i> parameter contains
///    information about the next file or directory found. If the function fails, the return value is zero and the
///    contents of <i>lpFindFileData</i> are indeterminate. To get extended error information, call the GetLastError
///    function. If the function fails because no more matching files can be found, the GetLastError function returns
///    <b>ERROR_NO_MORE_FILES</b>.
///    
@DllImport("KERNEL32")
BOOL FindNextFileW(HANDLE hFindFile, WIN32_FIND_DATAW* lpFindFileData);

///Continues a volume search started by a call to the FindFirstVolume function. <b>FindNextVolume</b> finds one volume
///per call.
///Params:
///    hFindVolume = The volume search handle returned by a previous call to the FindFirstVolume function.
///    lpszVolumeName = A pointer to a string that receives the volume <b>GUID</b> path that is found.
///    cchBufferLength = The length of the buffer that receives the volume <b>GUID</b> path, in <b>TCHARs</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If no matching files can be found, the <b>GetLastError</b>
///    function returns the <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
///    FindVolumeClose function.
///    
@DllImport("KERNEL32")
BOOL FindNextVolumeW(FindVolumeHandle hFindVolume, const(wchar)* lpszVolumeName, uint cchBufferLength);

///Closes the specified volume search handle. The FindFirstVolume and FindNextVolume functions use this search handle to
///locate volumes.
///Params:
///    hFindVolume = The volume search handle to be closed. This handle must have been previously opened by the FindFirstVolume
///                  function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL FindVolumeClose(FindVolumeHandle hFindVolume);

///Flushes the buffers of a specified file and causes all buffered data to be written to a file.
///Params:
///    hFile = A handle to the open file. The file handle must have the <b>GENERIC_WRITE</b> access right. For more information,
///            see File Security and Access Rights. If <i>hFile</i> is a handle to a communications device, the function only
///            flushes the transmit buffer. If <i>hFile</i> is a handle to the server end of a named pipe, the function does not
///            return until the client has read all buffered data from the pipe.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The function fails if <i>hFile</i> is a handle to the console
///    output. That is because the console output is not buffered. The function returns <b>FALSE</b>, and GetLastError
///    returns <b>ERROR_INVALID_HANDLE</b>.
///    
@DllImport("KERNEL32")
BOOL FlushFileBuffers(HANDLE hFile);

///Retrieves information about the specified disk, including the amount of free space on the disk.
///Params:
///    lpRootPathName = The root directory of the disk for which information is to be returned. If this parameter is <b>NULL</b>, the
///                     function uses the root of the current disk. If this parameter is a UNC name, it must include a trailing backslash
///                     (for example, "\\\\MyServer\\MyShare\\"). Furthermore, a drive specification must have a trailing backslash (for
///                     example, "C:\\"). The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this directory.
///    lpSectorsPerCluster = A pointer to a variable that receives the number of sectors per cluster.
///    lpBytesPerSector = A pointer to a variable that receives the number of bytes per sector.
///    lpNumberOfFreeClusters = A pointer to a variable that receives the total number of free clusters on the disk that are available to the
///                             user who is associated with the calling thread. If per-user disk quotas are in use, this value may be less than
///                             the total number of free clusters on the disk.
///    lpTotalNumberOfClusters = A pointer to a variable that receives the total number of clusters on the disk that are available to the user who
///                              is associated with the calling thread. If per-user disk quotas are in use, this value may be less than the total
///                              number of clusters on the disk.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetDiskFreeSpaceA(const(char)* lpRootPathName, uint* lpSectorsPerCluster, uint* lpBytesPerSector, 
                       uint* lpNumberOfFreeClusters, uint* lpTotalNumberOfClusters);

///Retrieves information about the specified disk, including the amount of free space on the disk.
///Params:
///    lpRootPathName = The root directory of the disk for which information is to be returned. If this parameter is <b>NULL</b>, the
///                     function uses the root of the current disk. If this parameter is a UNC name, it must include a trailing backslash
///                     (for example, "\\\\MyServer\\MyShare\\"). Furthermore, a drive specification must have a trailing backslash (for
///                     example, "C:\\"). The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this directory.
///    lpSectorsPerCluster = A pointer to a variable that receives the number of sectors per cluster.
///    lpBytesPerSector = A pointer to a variable that receives the number of bytes per sector.
///    lpNumberOfFreeClusters = A pointer to a variable that receives the total number of free clusters on the disk that are available to the
///                             user who is associated with the calling thread. If per-user disk quotas are in use, this value may be less than
///                             the total number of free clusters on the disk.
///    lpTotalNumberOfClusters = A pointer to a variable that receives the total number of clusters on the disk that are available to the user who
///                              is associated with the calling thread. If per-user disk quotas are in use, this value may be less than the total
///                              number of clusters on the disk.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetDiskFreeSpaceW(const(wchar)* lpRootPathName, uint* lpSectorsPerCluster, uint* lpBytesPerSector, 
                       uint* lpNumberOfFreeClusters, uint* lpTotalNumberOfClusters);

///Retrieves information about the amount of space that is available on a disk volume, which is the total amount of
///space, the total amount of free space, and the total amount of free space available to the user that is associated
///with the calling thread.
///Params:
///    lpDirectoryName = A directory on the disk. If this parameter is <b>NULL</b>, the function uses the root of the current disk. If
///                      this parameter is a UNC name, it must include a trailing backslash, for example, "\\\\MyServer\\MyShare\\". This
///                      parameter does not have to specify the root directory on a disk. The function accepts any directory on a disk.
///                      The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this directory.
///    lpFreeBytesAvailableToCaller = A pointer to a variable that receives the total number of free bytes on a disk that are available to the user who
///                                   is associated with the calling thread. This parameter can be <b>NULL</b>. If per-user quotas are being used, this
///                                   value may be less than the total number of free bytes on a disk.
///    lpTotalNumberOfBytes = A pointer to a variable that receives the total number of bytes on a disk that are available to the user who is
///                           associated with the calling thread. This parameter can be <b>NULL</b>. If per-user quotas are being used, this
///                           value may be less than the total number of bytes on a disk. To determine the total number of bytes on a disk or
///                           volume, use IOCTL_DISK_GET_LENGTH_INFO.
///    lpTotalNumberOfFreeBytes = A pointer to a variable that receives the total number of free bytes on a disk. This parameter can be
///                               <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetDiskFreeSpaceExA(const(char)* lpDirectoryName, ULARGE_INTEGER* lpFreeBytesAvailableToCaller, 
                         ULARGE_INTEGER* lpTotalNumberOfBytes, ULARGE_INTEGER* lpTotalNumberOfFreeBytes);

///Retrieves information about the amount of space that is available on a disk volume, which is the total amount of
///space, the total amount of free space, and the total amount of free space available to the user that is associated
///with the calling thread.
///Params:
///    lpDirectoryName = A directory on the disk. If this parameter is <b>NULL</b>, the function uses the root of the current disk. If
///                      this parameter is a UNC name, it must include a trailing backslash, for example, "\\\\MyServer\\MyShare\\". This
///                      parameter does not have to specify the root directory on a disk. The function accepts any directory on a disk.
///                      The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this directory.
///    lpFreeBytesAvailableToCaller = A pointer to a variable that receives the total number of free bytes on a disk that are available to the user who
///                                   is associated with the calling thread. This parameter can be <b>NULL</b>. If per-user quotas are being used, this
///                                   value may be less than the total number of free bytes on a disk.
///    lpTotalNumberOfBytes = A pointer to a variable that receives the total number of bytes on a disk that are available to the user who is
///                           associated with the calling thread. This parameter can be <b>NULL</b>. If per-user quotas are being used, this
///                           value may be less than the total number of bytes on a disk. To determine the total number of bytes on a disk or
///                           volume, use IOCTL_DISK_GET_LENGTH_INFO.
///    lpTotalNumberOfFreeBytes = A pointer to a variable that receives the total number of free bytes on a disk. This parameter can be
///                               <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetDiskFreeSpaceExW(const(wchar)* lpDirectoryName, ULARGE_INTEGER* lpFreeBytesAvailableToCaller, 
                         ULARGE_INTEGER* lpTotalNumberOfBytes, ULARGE_INTEGER* lpTotalNumberOfFreeBytes);

@DllImport("KERNEL32")
HRESULT GetDiskSpaceInformationA(const(char)* rootPath, DISK_SPACE_INFORMATION* diskSpaceInfo);

@DllImport("KERNEL32")
HRESULT GetDiskSpaceInformationW(const(wchar)* rootPath, DISK_SPACE_INFORMATION* diskSpaceInfo);

///Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive. To determine whether a
///drive is a USB-type drive, call SetupDiGetDeviceRegistryProperty and specify the <b>SPDRP_REMOVAL_POLICY</b>
///property.
///Params:
///    lpRootPathName = The root directory for the drive. A trailing backslash is required. If this parameter is <b>NULL</b>, the
///                     function uses the root of the current directory.
///Returns:
///    The return value specifies the type of drive, which can be one of the following values. <table> <tr> <th>Return
///    code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>DRIVE_UNKNOWN</b></dt> <dt>0</dt>
///    </dl> </td> <td width="60%"> The drive type cannot be determined. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DRIVE_NO_ROOT_DIR</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The root path is invalid; for example,
///    there is no volume mounted at the specified path. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DRIVE_REMOVABLE</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The drive has removable media; for
///    example, a floppy drive, thumb drive, or flash card reader. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DRIVE_FIXED</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> The drive has fixed media; for example, a
///    hard disk drive or flash drive. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DRIVE_REMOTE</b></dt> <dt>4</dt>
///    </dl> </td> <td width="60%"> The drive is a remote (network) drive. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DRIVE_CDROM</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> The drive is a CD-ROM drive. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>DRIVE_RAMDISK</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> The drive is a RAM
///    disk. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint GetDriveTypeA(const(char)* lpRootPathName);

///Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive. To determine whether a
///drive is a USB-type drive, call SetupDiGetDeviceRegistryProperty and specify the <b>SPDRP_REMOVAL_POLICY</b>
///property.
///Params:
///    lpRootPathName = The root directory for the drive. A trailing backslash is required. If this parameter is <b>NULL</b>, the
///                     function uses the root of the current directory.
///Returns:
///    The return value specifies the type of drive, which can be one of the following values. <table> <tr> <th>Return
///    code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>DRIVE_UNKNOWN</b></dt> <dt>0</dt>
///    </dl> </td> <td width="60%"> The drive type cannot be determined. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DRIVE_NO_ROOT_DIR</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The root path is invalid; for example,
///    there is no volume mounted at the specified path. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DRIVE_REMOVABLE</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The drive has removable media; for
///    example, a floppy drive, thumb drive, or flash card reader. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DRIVE_FIXED</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> The drive has fixed media; for example, a
///    hard disk drive or flash drive. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DRIVE_REMOTE</b></dt> <dt>4</dt>
///    </dl> </td> <td width="60%"> The drive is a remote (network) drive. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DRIVE_CDROM</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> The drive is a CD-ROM drive. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>DRIVE_RAMDISK</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> The drive is a RAM
///    disk. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint GetDriveTypeW(const(wchar)* lpRootPathName);

///Retrieves file system attributes for a specified file or directory. To get more attribute information, use the
///GetFileAttributesEx function. To perform this operation as a transacted operation, use the
///GetFileAttributesTransacted function.
///Params:
///    lpFileName = The name of the file or directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function
///                 (<b>GetFileAttributesW</b>), and prepend "\\\\?\\" to the path. For more information, see File Names, Paths, and
///                 Namespaces. <div class="alert"><b>Tip</b> Starting in Windows 10, version 1607, for the unicode version of this
///                 function (<b>GetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without
///                 prepending "\\?\". See the "Maximum Path Limitation" section of Naming Files, Paths, and Namespaces for details.
///                 </div> <div> </div>
///Returns:
///    If the function succeeds, the return value contains the attributes of the specified file or directory. For a list
///    of attribute values and their descriptions, see File Attribute Constants. If the function fails, the return value
///    is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetFileAttributesA(const(char)* lpFileName);

///Retrieves file system attributes for a specified file or directory. To get more attribute information, use the
///GetFileAttributesEx function. To perform this operation as a transacted operation, use the
///GetFileAttributesTransacted function.
///Params:
///    lpFileName = The name of the file or directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function
///                 (<b>GetFileAttributesW</b>), and prepend "\\\\?\\" to the path. For more information, see File Names, Paths, and
///                 Namespaces. <div class="alert"><b>Tip</b> Starting in Windows 10, version 1607, for the unicode version of this
///                 function (<b>GetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without
///                 prepending "\\?\". See the "Maximum Path Limitation" section of Naming Files, Paths, and Namespaces for details.
///                 </div> <div> </div>
///Returns:
///    If the function succeeds, the return value contains the attributes of the specified file or directory. For a list
///    of attribute values and their descriptions, see File Attribute Constants. If the function fails, the return value
///    is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetFileAttributesW(const(wchar)* lpFileName);

///Retrieves attributes for a specified file or directory. To perform this operation as a transacted operation, use the
///GetFileAttributesTransacted function.
///Params:
///    lpFileName = The name of the file or directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function
///                 (<b>GetFileAttributesExW</b>), and prepend "\\\\?\\" to the path. For more information, see Naming a File. <div
///                 class="alert"><b>Tip</b> Starting in Windows 10, version 1607, for the unicode version of this function
///                 (<b>GetFileAttributesExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without
///                 prepending "\\?\". See the "Maximum Path Limitation" section of Naming Files, Paths, and Namespaces for details.
///                 </div> <div> </div>
///    fInfoLevelId = A class of attribute information to retrieve. This parameter can be the following value from the
///                   GET_FILEEX_INFO_LEVELS enumeration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                   id="GetFileExInfoStandard"></a><a id="getfileexinfostandard"></a><a id="GETFILEEXINFOSTANDARD"></a><dl>
///                   <dt><b>GetFileExInfoStandard</b></dt> </dl> </td> <td width="60%"> The <i>lpFileInformation</i> parameter is a
///                   WIN32_FILE_ATTRIBUTE_DATA structure. </td> </tr> </table>
///    lpFileInformation = A pointer to a buffer that receives the attribute information. The type of attribute information that is stored
///                        into this buffer is determined by the value of <i>fInfoLevelId</i>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero
///    (0). To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetFileAttributesExA(const(char)* lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, char* lpFileInformation);

///Retrieves attributes for a specified file or directory. To perform this operation as a transacted operation, use the
///GetFileAttributesTransacted function.
///Params:
///    lpFileName = The name of the file or directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function
///                 (<b>GetFileAttributesExW</b>), and prepend "\\\\?\\" to the path. For more information, see Naming a File. <div
///                 class="alert"><b>Tip</b> Starting in Windows 10, version 1607, for the unicode version of this function
///                 (<b>GetFileAttributesExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without
///                 prepending "\\?\". See the "Maximum Path Limitation" section of Naming Files, Paths, and Namespaces for details.
///                 </div> <div> </div>
///    fInfoLevelId = A class of attribute information to retrieve. This parameter can be the following value from the
///                   GET_FILEEX_INFO_LEVELS enumeration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                   id="GetFileExInfoStandard"></a><a id="getfileexinfostandard"></a><a id="GETFILEEXINFOSTANDARD"></a><dl>
///                   <dt><b>GetFileExInfoStandard</b></dt> </dl> </td> <td width="60%"> The <i>lpFileInformation</i> parameter is a
///                   WIN32_FILE_ATTRIBUTE_DATA structure. </td> </tr> </table>
///    lpFileInformation = A pointer to a buffer that receives the attribute information. The type of attribute information that is stored
///                        into this buffer is determined by the value of <i>fInfoLevelId</i>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero
///    (0). To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetFileAttributesExW(const(wchar)* lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, char* lpFileInformation);

///Retrieves file information for the specified file. For a more advanced version of this function, see
///GetFileInformationByHandleEx. To set file information using a file handle, see SetFileInformationByHandle.
///Params:
///    hFile = A handle to the file that contains the information to be retrieved. This handle should not be a pipe handle.
///    lpFileInformation = A pointer to a BY_HANDLE_FILE_INFORMATION structure that receives the file information.
///Returns:
///    If the function succeeds, the return value is nonzero and file information data is contained in the buffer
///    pointed to by the <i>lpFileInformation</i> parameter. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetFileInformationByHandle(HANDLE hFile, BY_HANDLE_FILE_INFORMATION* lpFileInformation);

///Retrieves the size of the specified file, in bytes. It is recommended that you use GetFileSizeEx.
///Params:
///    hFile = A handle to the file.
///    lpFileSizeHigh = A pointer to the variable where the high-order doubleword of the file size is returned. This parameter can be
///                     <b>NULL</b> if the application does not require the high-order doubleword.
///Returns:
///    If the function succeeds, the return value is the low-order doubleword of the file size, and, if
///    <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order doubleword of the file size into the
///    variable pointed to by that parameter. If the function fails and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return
///    value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call GetLastError. When
///    <i>lpFileSizeHigh</i> is <b>NULL</b>, the results returned for large files are ambiguous, and you will not be
///    able to determine the actual size of the file. It is recommended that you use GetFileSizeEx instead. If the
///    function fails and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b> and
///    GetLastError will return a value other than <b>NO_ERROR</b>.
///    
@DllImport("KERNEL32")
uint GetFileSize(HANDLE hFile, uint* lpFileSizeHigh);

///Retrieves the size of the specified file.
///Params:
///    hFile = A handle to the file. The handle must have been created with the <b>FILE_READ_ATTRIBUTES</b> access right or
///            equivalent, or the caller must have sufficient permission on the directory that contains the file. For more
///            information, see File Security and Access Rights.
///    lpFileSize = A pointer to a LARGE_INTEGER structure that receives the file size, in bytes.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetFileSizeEx(HANDLE hFile, LARGE_INTEGER* lpFileSize);

///Retrieves the file type of the specified file.
///Params:
///    hFile = A handle to the file.
///Returns:
///    The function returns one of the following values. <table> <tr> <th>Return code/value</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>FILE_TYPE_CHAR</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> The
///    specified file is a character file, typically an LPT device or a console. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>FILE_TYPE_DISK</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> The specified file is a disk file.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>FILE_TYPE_PIPE</b></dt> <dt>0x0003</dt> </dl> </td> <td
///    width="60%"> The specified file is a socket, a named pipe, or an anonymous pipe. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>FILE_TYPE_REMOTE</b></dt> <dt>0x8000</dt> </dl> </td> <td width="60%"> Unused. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>FILE_TYPE_UNKNOWN</b></dt> <dt>0x0000</dt> </dl> </td> <td width="60%">
///    Either the type of the specified file is unknown, or the function failed. </td> </tr> </table> You can
///    distinguish between a "valid" return of <b>FILE_TYPE_UNKNOWN</b> and its return due to a calling error (for
///    example, passing an invalid handle to <b>GetFileType</b>) by calling GetLastError. If the function worked
///    properly and <b>FILE_TYPE_UNKNOWN</b> was returned, a call to <b>GetLastError</b> will return <b>NO_ERROR</b>. If
///    the function returned <b>FILE_TYPE_UNKNOWN</b> due to an error in calling <b>GetFileType</b>, GetLastError will
///    return the error code.
///    
@DllImport("KERNEL32")
uint GetFileType(HANDLE hFile);

///Retrieves the final path for the specified file. For more information about file and path names, see Naming a File.
///Params:
///    hFile = A handle to a file or directory.
///    lpszFilePath = A pointer to a buffer that receives the path of <i>hFile</i>.
///    cchFilePath = The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.
///    dwFlags = The type of result to return. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_NAME_NORMALIZED"></a><a
///              id="file_name_normalized"></a><dl> <dt><b>FILE_NAME_NORMALIZED</b></dt> <dt>0x0</dt> </dl> </td> <td width="60%">
///              Return the normalized drive name. This is the default. </td> </tr> <tr> <td width="40%"><a
///              id="FILE_NAME_OPENED"></a><a id="file_name_opened"></a><dl> <dt><b>FILE_NAME_OPENED</b></dt> <dt>0x8</dt> </dl>
///              </td> <td width="60%"> Return the opened file name (not normalized). </td> </tr> </table> This parameter can also
///              include one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="VOLUME_NAME_DOS"></a><a id="volume_name_dos"></a><dl> <dt><b>VOLUME_NAME_DOS</b></dt> <dt>0x0</dt> </dl>
///              </td> <td width="60%"> Return the path with the drive letter. This is the default. </td> </tr> <tr> <td
///              width="40%"><a id="VOLUME_NAME_GUID"></a><a id="volume_name_guid"></a><dl> <dt><b>VOLUME_NAME_GUID</b></dt>
///              <dt>0x1</dt> </dl> </td> <td width="60%"> Return the path with a volume <b>GUID</b> path instead of the drive
///              name. </td> </tr> <tr> <td width="40%"><a id="_VOLUME_NAME_NONE"></a><a id="_volume_name_none"></a><dl> <dt><b>
///              VOLUME_NAME_NONE</b></dt> <dt>0x4</dt> </dl> </td> <td width="60%"> Return the path with no drive information.
///              </td> </tr> <tr> <td width="40%"><a id="VOLUME_NAME_NT"></a><a id="volume_name_nt"></a><dl>
///              <dt><b>VOLUME_NAME_NT</b></dt> <dt>0x2</dt> </dl> </td> <td width="60%"> Return the path with the volume device
///              path. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is the length of the string received by <i>lpszFilePath</i>, in
///    <b>TCHAR</b>s. This value does not include the size of the terminating null character. <b>Windows Server 2008 and
///    Windows Vista: </b>For the ANSI version of this function, <b>GetFinalPathNameByHandleA</b>, the return value
///    includes the size of the terminating null character. If the function fails because <i>lpszFilePath</i> is too
///    small to hold the string plus the terminating null character, the return value is the required buffer size, in
///    <b>TCHAR</b>s. This value includes the size of the terminating null character. If the function fails for any
///    other reason, the return value is zero. To get extended error information, call GetLastError. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
///    </dl> </td> <td width="60%"> Can be returned if you are searching for a drive letter and one does not exist. For
///    example, the handle was opened on a drive that is not currently mounted, or if you create a volume and do not
///    assign it a drive letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to identify
///    it. This return value can also be returned if you are searching for a volume <b>GUID</b> path on a network share.
///    Volume <b>GUID</b> paths are not created for network shares. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory to complete the
///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> Invalid flags were specified for <i>dwFlags</i>. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint GetFinalPathNameByHandleA(HANDLE hFile, const(char)* lpszFilePath, uint cchFilePath, uint dwFlags);

///Retrieves the final path for the specified file. For more information about file and path names, see Naming a File.
///Params:
///    hFile = A handle to a file or directory.
///    lpszFilePath = A pointer to a buffer that receives the path of <i>hFile</i>.
///    cchFilePath = The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.
///    dwFlags = The type of result to return. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_NAME_NORMALIZED"></a><a
///              id="file_name_normalized"></a><dl> <dt><b>FILE_NAME_NORMALIZED</b></dt> <dt>0x0</dt> </dl> </td> <td width="60%">
///              Return the normalized drive name. This is the default. </td> </tr> <tr> <td width="40%"><a
///              id="FILE_NAME_OPENED"></a><a id="file_name_opened"></a><dl> <dt><b>FILE_NAME_OPENED</b></dt> <dt>0x8</dt> </dl>
///              </td> <td width="60%"> Return the opened file name (not normalized). </td> </tr> </table> This parameter can also
///              include one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="VOLUME_NAME_DOS"></a><a id="volume_name_dos"></a><dl> <dt><b>VOLUME_NAME_DOS</b></dt> <dt>0x0</dt> </dl>
///              </td> <td width="60%"> Return the path with the drive letter. This is the default. </td> </tr> <tr> <td
///              width="40%"><a id="VOLUME_NAME_GUID"></a><a id="volume_name_guid"></a><dl> <dt><b>VOLUME_NAME_GUID</b></dt>
///              <dt>0x1</dt> </dl> </td> <td width="60%"> Return the path with a volume <b>GUID</b> path instead of the drive
///              name. </td> </tr> <tr> <td width="40%"><a id="_VOLUME_NAME_NONE"></a><a id="_volume_name_none"></a><dl> <dt><b>
///              VOLUME_NAME_NONE</b></dt> <dt>0x4</dt> </dl> </td> <td width="60%"> Return the path with no drive information.
///              </td> </tr> <tr> <td width="40%"><a id="VOLUME_NAME_NT"></a><a id="volume_name_nt"></a><dl>
///              <dt><b>VOLUME_NAME_NT</b></dt> <dt>0x2</dt> </dl> </td> <td width="60%"> Return the path with the volume device
///              path. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is the length of the string received by <i>lpszFilePath</i>, in
///    <b>TCHAR</b>s. This value does not include the size of the terminating null character. <b>Windows Server 2008 and
///    Windows Vista: </b>For the ANSI version of this function, <b>GetFinalPathNameByHandleA</b>, the return value
///    includes the size of the terminating null character. If the function fails because <i>lpszFilePath</i> is too
///    small to hold the string plus the terminating null character, the return value is the required buffer size, in
///    <b>TCHAR</b>s. This value includes the size of the terminating null character. If the function fails for any
///    other reason, the return value is zero. To get extended error information, call GetLastError. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
///    </dl> </td> <td width="60%"> Can be returned if you are searching for a drive letter and one does not exist. For
///    example, the handle was opened on a drive that is not currently mounted, or if you create a volume and do not
///    assign it a drive letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to identify
///    it. This return value can also be returned if you are searching for a volume <b>GUID</b> path on a network share.
///    Volume <b>GUID</b> paths are not created for network shares. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory to complete the
///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> Invalid flags were specified for <i>dwFlags</i>. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint GetFinalPathNameByHandleW(HANDLE hFile, const(wchar)* lpszFilePath, uint cchFilePath, uint dwFlags);

///Retrieves the full path and file name of the specified file. To perform this operation as a transacted operation, use
///the GetFullPathNameTransacted function. For more information about file and path names, see File Names, Paths, and
///Namespaces. <div class="alert"><b>Note</b> See the Remarks section for discussion of the use of relative paths with
///the <b>GetFullPathName</b> function in multithreaded applications or shared library code.</div>
///Params:
///    lpFileName = The name of the file. This parameter can be a short (the 8.3 form) or long file name. This string can also be a
///                 share or volume name. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To
///                 extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFullPathNameW</b>),
///                 and prepend "\\\\?\\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b>
///                 Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFullPathNameW</b>), you can
///                 opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path
///                 Limitation" section of Naming Files, Paths, and Namespaces for details. </div> <div> </div>
///    nBufferLength = The size of the buffer to receive the null-terminated string for the drive and path, in <b>TCHARs</b>.
///    lpBuffer = A pointer to a buffer that receives the null-terminated string for the drive and path.
///    lpFilePart = A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final file name component in the
///                 path. This parameter can be <b>NULL</b>. If <i>lpBuffer</i> refers to a directory and not a file,
///                 <i>lpFilePart</i> receives zero.
///Returns:
///    If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to
///    <i>lpBuffer</i>, not including the terminating null character. If the <i>lpBuffer</i> buffer is too small to
///    contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path
///    and the terminating null character. If the function fails for any other reason, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetFullPathNameW(const(wchar)* lpFileName, uint nBufferLength, const(wchar)* lpBuffer, ushort** lpFilePart);

///Retrieves the full path and file name of the specified file. To perform this operation as a transacted operation, use
///the GetFullPathNameTransacted function. For more information about file and path names, see File Names, Paths, and
///Namespaces. <div class="alert"><b>Note</b> See the Remarks section for discussion of the use of relative paths with
///the <b>GetFullPathName</b> function in multithreaded applications or shared library code.</div>
///Params:
///    lpFileName = The name of the file. This parameter can be a short (the 8.3 form) or long file name. This string can also be a
///                 share or volume name. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To
///                 extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFullPathNameW</b>),
///                 and prepend "\\\\?\\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b>
///                 Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFullPathNameW</b>), you can
///                 opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path
///                 Limitation" section of Naming Files, Paths, and Namespaces for details. </div> <div> </div>
///    nBufferLength = The size of the buffer to receive the null-terminated string for the drive and path, in <b>TCHARs</b>.
///    lpBuffer = A pointer to a buffer that receives the null-terminated string for the drive and path.
///    lpFilePart = A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final file name component in the
///                 path. This parameter can be <b>NULL</b>. If <i>lpBuffer</i> refers to a directory and not a file,
///                 <i>lpFilePart</i> receives zero.
///Returns:
///    If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to
///    <i>lpBuffer</i>, not including the terminating null character. If the <i>lpBuffer</i> buffer is too small to
///    contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path
///    and the terminating null character. If the function fails for any other reason, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetFullPathNameA(const(char)* lpFileName, uint nBufferLength, const(char)* lpBuffer, byte** lpFilePart);

///Retrieves a bitmask representing the currently available disk drives.
///Returns:
///    If the function succeeds, the return value is a bitmask representing the currently available disk drives. Bit
///    position 0 (the least-significant bit) is drive A, bit position 1 is drive B, bit position 2 is drive C, and so
///    on. If the function fails, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetLogicalDrives();

///Fills a buffer with strings that specify valid drives in the system.
///Params:
///    nBufferLength = The maximum size of the buffer pointed to by <i>lpBuffer</i>, in <b>TCHARs</b>. This size does not include the
///                    terminating null character. If this parameter is zero, <i>lpBuffer</i> is not used.
///    lpBuffer = A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the system,
///               plus with an additional null character. Each string is a device name.
///Returns:
///    If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not
///    including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode
///    (UTF-16) null character uses two bytes. If the buffer is not large enough, the return value is greater than
///    <i>nBufferLength</i>. It is the size of the buffer required to hold the drive strings. If the function fails, the
///    return value is zero. To get extended error information, use the GetLastError function.
///    
@DllImport("KERNEL32")
uint GetLogicalDriveStringsW(uint nBufferLength, const(wchar)* lpBuffer);

///Converts the specified path to its long form. To perform this operation as a transacted operation, use the
///GetLongPathNameTransacted function. For more information about file and path names, see Naming Files, Paths, and
///Namespaces.
///Params:
///    lpszShortPath = The path to be converted. In the ANSI version of this function, <b>GetLongPathNameA</b>, the name is limited to
///                    <b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                    function, <b>GetLongPathNameW</b>, and prepend "\\\\?\\" to the path. For more information, see Naming Files,
///                    Paths, and Namespaces. <div class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode
///                    version of this function (<b>GetLongPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation
///                    without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths, and
///                    Namespaces for details.</div> <div> </div>
///    lpszLongPath = A pointer to the buffer to receive the long path. You can use the same buffer you used for the
///                   <i>lpszShortPath</i> parameter.
///    cchBuffer = The size of the buffer <i>lpszLongPath</i> points to, in <b>TCHARs</b>.
///Returns:
///    If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to
///    <i>lpszLongPath</i>, not including the terminating null character. If the <i>lpBuffer</i> buffer is too small to
///    contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path
///    and the terminating null character. If the function fails for any other reason, such as if the file does not
///    exist, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetLongPathNameA(const(char)* lpszShortPath, const(char)* lpszLongPath, uint cchBuffer);

///Converts the specified path to its long form. To perform this operation as a transacted operation, use the
///GetLongPathNameTransacted function. For more information about file and path names, see Naming Files, Paths, and
///Namespaces. > [!IMPORTANT] > To use this function, the caller must have the following permissions on the specified
///path and parent directories: > - List Folder > - Read Data > - Read Attributes
///Params:
///    lpszShortPath = The path to be converted. In the ANSI version of this function, <b>GetLongPathNameA</b>, the name is limited to
///                    <b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                    function, <b>GetLongPathNameW</b>, and prepend "\\\\?\\" to the path. For more information, see Naming Files,
///                    Paths, and Namespaces. <div class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode
///                    version of this function (<b>GetLongPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation
///                    without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths, and
///                    Namespaces for details.</div> <div> </div>
///    lpszLongPath = A pointer to the buffer to receive the long path. You can use the same buffer you used for the
///                   <i>lpszShortPath</i> parameter.
///    cchBuffer = The size of the buffer <i>lpszLongPath</i> points to, in <b>TCHARs</b>.
///Returns:
///    If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to
///    <i>lpszLongPath</i>, not including the terminating null character. If the <i>lpBuffer</i> buffer is too small to
///    contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path
///    and the terminating null character. If the function fails for any other reason, such as if the file does not
///    exist, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetLongPathNameW(const(wchar)* lpszShortPath, const(wchar)* lpszLongPath, uint cchBuffer);

///Retrieves the short path form of the specified path. For more information about file and path names, see Naming
///Files, Paths, and Namespaces.
///Params:
///    lpszLongPath = The path string. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To
///                   extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to
///                   the path. For more information, see Naming Files, Paths, and Namespaces.
///    lpszShortPath = A pointer to a buffer to receive the null-terminated short form of the path that <i>lpszLongPath</i> specifies.
///                    Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i> will always return the required buffer size
///                    for a specified <i>lpszLongPath</i>.
///    cchBuffer = The size of the buffer that <i>lpszShortPath</i> points to, in <b>TCHARs</b>. Set this parameter to zero if
///                <i>lpszShortPath</i> is set to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string that is copied to
///    <i>lpszShortPath</i>, not including the terminating null character. If the <i>lpszShortPath</i> buffer is too
///    small to contain the path, the return value is the size of the buffer, in <b>TCHARs</b>, that is required to hold
///    the path and the terminating null character. If the function fails for any other reason, the return value is
///    zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetShortPathNameW(const(wchar)* lpszLongPath, const(wchar)* lpszShortPath, uint cchBuffer);

///Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to
///it is released; otherwise, only a file name is generated.
///Params:
///    lpPathName = The directory path for the file name. Applications typically specify a period (.) for the current directory or
///                 the result of the GetTempPath function. The string cannot be longer than <b>MAX_PATH</b>–14 characters or
///                 <b>GetTempFileName</b> will fail. If this parameter is <b>NULL</b>, the function fails.
///    lpPrefixString = The null-terminated prefix string. The function uses up to the first three characters of this string as the
///                     prefix of the file name. This string must consist of characters in the OEM-defined character set.
///    uUnique = An unsigned integer to be used in creating the temporary file name. For more information, see Remarks. If
///              <i>uUnique</i> is zero, the function attempts to form a unique file name using the current system time. If the
///              file already exists, the number is increased by one and the functions tests if this file already exists. This
///              continues until a unique filename is found; the function creates a file by that name and closes it. Note that the
///              function does not attempt to verify the uniqueness of the file name when <i>uUnique</i> is nonzero.
///    lpTempFileName = A pointer to the buffer that receives the temporary file name. This buffer should be <b>MAX_PATH</b> characters
///                     to accommodate the path plus the terminating null character.
///Returns:
///    If the function succeeds, the return value specifies the unique numeric value used in the temporary file name. If
///    the <i>uUnique</i> parameter is nonzero, the return value specifies that same number. If the function fails, the
///    return value is zero. To get extended error information, call GetLastError. The following is a possible return
///    value. <table> <tr> <th>Return value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BUFFER_OVERFLOW</b></dt> </dl> </td> <td width="60%"> The length of the string pointed to by the
///    <i>lpPathName</i> parameter is more than <b>MAX_PATH</b>–14 characters. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint GetTempFileNameW(const(wchar)* lpPathName, const(wchar)* lpPrefixString, uint uUnique, 
                      const(wchar)* lpTempFileName);

///Retrieves information about the file system and volume associated with the specified file. To retrieve the current
///compression state of a file or directory, use FSCTL_GET_COMPRESSION.
///Params:
///    hFile = A handle to the file.
///    lpVolumeNameBuffer = A pointer to a buffer that receives the name of a specified volume. The maximum buffer size is
///                         <code>MAX_PATH+1</code>.
///    nVolumeNameSize = The length of a volume name buffer, in <b>WCHAR</b>s. The maximum buffer size is <code>MAX_PATH+1</code>. This
///                      parameter is ignored if the volume name buffer is not supplied.
///    lpVolumeSerialNumber = A pointer to a variable that receives the volume serial number. This parameter can be <b>NULL</b> if the serial
///                           number is not required. This function returns the volume serial number that the operating system assigns when a
///                           hard disk is formatted. To programmatically obtain the hard disk's serial number that the manufacturer assigns,
///                           use the Windows Management Instrumentation (WMI) Win32_PhysicalMedia property <b>SerialNumber</b>.
///    lpMaximumComponentLength = A pointer to a variable that receives the maximum length, in <b>WCHAR</b>s, of a file name component that a
///                               specified file system supports. A file name component is the portion of a file name between backslashes. The
///                               value that is stored in the variable that *<i>lpMaximumComponentLength</i> points to is used to indicate that a
///                               specified file system supports long names. For example, for a FAT file system that supports long names, the
///                               function stores the value 255, rather than the previous 8.3 indicator. Long names can also be supported on
///                               systems that use the NTFS file system.
///    lpFileSystemFlags = A pointer to a variable that receives flags associated with the specified file system. This parameter can be one
///                        or more of the following flags. However, <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are
///                        mutually exclusive. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                        id="FILE_CASE_PRESERVED_NAMES"></a><a id="file_case_preserved_names"></a><dl>
///                        <dt><b>FILE_CASE_PRESERVED_NAMES</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports preserved case of file names when it places a name on disk. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_CASE_SENSITIVE_SEARCH"></a><a id="file_case_sensitive_search"></a><dl>
///                        <dt><b>FILE_CASE_SENSITIVE_SEARCH</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports case-sensitive file names. </td> </tr> <tr> <td width="40%"><a id="FILE_FILE_COMPRESSION"></a><a
///                        id="file_file_compression"></a><dl> <dt><b>FILE_FILE_COMPRESSION</b></dt> <dt>0x00000010</dt> </dl> </td> <td
///                        width="60%"> The specified volume supports file-based compression. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_NAMED_STREAMS"></a><a id="file_named_streams"></a><dl> <dt><b>FILE_NAMED_STREAMS</b></dt>
///                        <dt>0x00040000</dt> </dl> </td> <td width="60%"> The specified volume supports named streams. </td> </tr> <tr>
///                        <td width="40%"><a id="FILE_PERSISTENT_ACLS"></a><a id="file_persistent_acls"></a><dl>
///                        <dt><b>FILE_PERSISTENT_ACLS</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> The specified volume
///                        preserves and enforces access control lists (ACL). For example, the NTFS file system preserves and enforces ACLs,
///                        and the FAT file system does not. </td> </tr> <tr> <td width="40%"><a id="FILE_READ_ONLY_VOLUME"></a><a
///                        id="file_read_only_volume"></a><dl> <dt><b>FILE_READ_ONLY_VOLUME</b></dt> <dt>0x00080000</dt> </dl> </td> <td
///                        width="60%"> The specified volume is read-only. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_SEQUENTIAL_WRITE_ONCE"></a><a id="file_sequential_write_once"></a><dl>
///                        <dt><b>FILE_SEQUENTIAL_WRITE_ONCE</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports a single sequential write. </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_ENCRYPTION"></a><a
///                        id="file_supports_encryption"></a><dl> <dt><b>FILE_SUPPORTS_ENCRYPTION</b></dt> <dt>0x00020000</dt> </dl> </td>
///                        <td width="60%"> The specified volume supports the Encrypted File System (EFS). For more information, see File
///                        Encryption. </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_EXTENDED_ATTRIBUTES"></a><a
///                        id="file_supports_extended_attributes"></a><dl> <dt><b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b></dt>
///                        <dt>0x00800000</dt> </dl> </td> <td width="60%"> The specified volume supports extended attributes. An extended
///                        attribute is a piece of application-specific metadata that an application can associate with a file and is not
///                        part of the file's data. <b>Windows Vista and Windows Server 2008: </b>This value is not supported. </td> </tr>
///                        <tr> <td width="40%"><a id="FILE_SUPPORTS_HARD_LINKS"></a><a id="file_supports_hard_links"></a><dl>
///                        <dt><b>FILE_SUPPORTS_HARD_LINKS</b></dt> <dt>0x00400000</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports hard links. For more information, see Hard Links and Junctions. <b>Windows Vista and Windows Server
///                        2008: </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_OBJECT_IDS"></a><a
///                        id="file_supports_object_ids"></a><dl> <dt><b>FILE_SUPPORTS_OBJECT_IDS</b></dt> <dt>0x00010000</dt> </dl> </td>
///                        <td width="60%"> The specified volume supports object identifiers. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_SUPPORTS_OPEN_BY_FILE_ID"></a><a id="file_supports_open_by_file_id"></a><dl>
///                        <dt><b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b></dt> <dt>0x01000000</dt> </dl> </td> <td width="60%"> The file system
///                        supports open by FileID. For more information, see FILE_ID_BOTH_DIR_INFO. <b>Windows Vista and Windows Server
///                        2008: </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_SUPPORTS_REPARSE_POINTS"></a><a id="file_supports_reparse_points"></a><dl>
///                        <dt><b>FILE_SUPPORTS_REPARSE_POINTS</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> The specified
///                        volume supports re-parse points. </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_SPARSE_FILES"></a><a
///                        id="file_supports_sparse_files"></a><dl> <dt><b>FILE_SUPPORTS_SPARSE_FILES</b></dt> <dt>0x00000040</dt> </dl>
///                        </td> <td width="60%"> The specified volume supports sparse files. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_SUPPORTS_TRANSACTIONS"></a><a id="file_supports_transactions"></a><dl>
///                        <dt><b>FILE_SUPPORTS_TRANSACTIONS</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports transactions. For more information, see About KTM. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_SUPPORTS_USN_JOURNAL"></a><a id="file_supports_usn_journal"></a><dl>
///                        <dt><b>FILE_SUPPORTS_USN_JOURNAL</b></dt> <dt>0x02000000</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports update sequence number (USN) journals. For more information, see Change Journal Records. <b>Windows
///                        Vista and Windows Server 2008: </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_UNICODE_ON_DISK"></a><a id="file_unicode_on_disk"></a><dl> <dt><b>FILE_UNICODE_ON_DISK</b></dt>
///                        <dt>0x00000004</dt> </dl> </td> <td width="60%"> The specified volume supports Unicode in file names as they
///                        appear on disk. </td> </tr> <tr> <td width="40%"><a id="FILE_VOLUME_IS_COMPRESSED"></a><a
///                        id="file_volume_is_compressed"></a><dl> <dt><b>FILE_VOLUME_IS_COMPRESSED</b></dt> <dt>0x00008000</dt> </dl> </td>
///                        <td width="60%"> The specified volume is a compressed volume. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_VOLUME_QUOTAS"></a><a id="file_volume_quotas"></a><dl> <dt><b>FILE_VOLUME_QUOTAS</b></dt>
///                        <dt>0x00000020</dt> </dl> </td> <td width="60%"> The specified volume supports disk quotas. </td> </tr> <tr> <td
///                        width="40%"><a id="FILE_SUPPORTS_BLOCK_REFCOUNTING"></a><a id="file_supports_block_refcounting"></a><dl>
///                        <dt><b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b></dt> <dt>0x08000000</dt> </dl> </td> <td width="60%"> The specified
///                        volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes
///                        to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation. </td> </tr> </table>
///    lpFileSystemNameBuffer = A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS
///                             file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.
///    nFileSystemNameSize = The length of the file system name buffer, in <b>WCHAR</b>s. The maximum buffer size is <code>MAX_PATH+1</code>.
///                          This parameter is ignored if the file system name buffer is not supplied.
///Returns:
///    If all the requested information is retrieved, the return value is nonzero. If not all the requested information
///    is retrieved, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetVolumeInformationByHandleW(HANDLE hFile, const(wchar)* lpVolumeNameBuffer, uint nVolumeNameSize, 
                                   uint* lpVolumeSerialNumber, uint* lpMaximumComponentLength, 
                                   uint* lpFileSystemFlags, const(wchar)* lpFileSystemNameBuffer, 
                                   uint nFileSystemNameSize);

///Retrieves information about the file system and volume associated with the specified root directory. To specify a
///handle when retrieving this information, use the GetVolumeInformationByHandleW function. To retrieve the current
///compression state of a file or directory, use FSCTL_GET_COMPRESSION.
///Params:
///    lpRootPathName = A pointer to a string that contains the root directory of the volume to be described. If this parameter is
///                     <b>NULL</b>, the root of the current directory is used. A trailing backslash is required. For example, you
///                     specify \\MyServer\MyShare as "\\MyServer\MyShare\", or the C drive as "C:\".
///    lpVolumeNameBuffer = A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the
///                         <i>nVolumeNameSize</i> parameter.
///    nVolumeNameSize = The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is <b>MAX_PATH</b>+1. This
///                      parameter is ignored if the volume name buffer is not supplied.
///    lpVolumeSerialNumber = A pointer to a variable that receives the volume serial number. This parameter can be <b>NULL</b> if the serial
///                           number is not required. This function returns the volume serial number that the operating system assigns when a
///                           hard disk is formatted. To programmatically obtain the hard disk's serial number that the manufacturer assigns,
///                           use the Windows Management Instrumentation (WMI) Win32_PhysicalMedia property <b>SerialNumber</b>.
///    lpMaximumComponentLength = A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file name component that a
///                               specified file system supports. A file name component is the portion of a file name between backslashes. The
///                               value that is stored in the variable that *<i>lpMaximumComponentLength</i> points to is used to indicate that a
///                               specified file system supports long names. For example, for a FAT file system that supports long names, the
///                               function stores the value 255, rather than the previous 8.3 indicator. Long names can also be supported on
///                               systems that use the NTFS file system.
///    lpFileSystemFlags = A pointer to a variable that receives flags associated with the specified file system. This parameter can be one
///                        or more of the following flags. However, <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are
///                        mutually exclusive. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                        id="FILE_CASE_PRESERVED_NAMES"></a><a id="file_case_preserved_names"></a><dl>
///                        <dt><b>FILE_CASE_PRESERVED_NAMES</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports preserved case of file names when it places a name on disk. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_CASE_SENSITIVE_SEARCH"></a><a id="file_case_sensitive_search"></a><dl>
///                        <dt><b>FILE_CASE_SENSITIVE_SEARCH</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports case-sensitive file names. </td> </tr> <tr> <td width="40%"><a id="FILE_DAX_VOLUME________"></a><a
///                        id="file_dax_volume________"></a><dl> <dt><b>FILE_DAX_VOLUME </b></dt> <dt>0x20000000</dt> </dl> </td> <td
///                        width="60%"> The specified volume is a direct access (DAX) volume. <div class="alert"><b>Note</b> This flag was
///                        introduced in Windows 10, version 1607.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_FILE_COMPRESSION"></a><a id="file_file_compression"></a><dl> <dt><b>FILE_FILE_COMPRESSION</b></dt>
///                        <dt>0x00000010</dt> </dl> </td> <td width="60%"> The specified volume supports file-based compression. </td>
///                        </tr> <tr> <td width="40%"><a id="FILE_NAMED_STREAMS"></a><a id="file_named_streams"></a><dl>
///                        <dt><b>FILE_NAMED_STREAMS</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The specified volume supports
///                        named streams. </td> </tr> <tr> <td width="40%"><a id="FILE_PERSISTENT_ACLS"></a><a
///                        id="file_persistent_acls"></a><dl> <dt><b>FILE_PERSISTENT_ACLS</b></dt> <dt>0x00000008</dt> </dl> </td> <td
///                        width="60%"> The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file
///                        system preserves and enforces ACLs, and the FAT file system does not. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_READ_ONLY_VOLUME"></a><a id="file_read_only_volume"></a><dl> <dt><b>FILE_READ_ONLY_VOLUME</b></dt>
///                        <dt>0x00080000</dt> </dl> </td> <td width="60%"> The specified volume is read-only. </td> </tr> <tr> <td
///                        width="40%"><a id="FILE_SEQUENTIAL_WRITE_ONCE"></a><a id="file_sequential_write_once"></a><dl>
///                        <dt><b>FILE_SEQUENTIAL_WRITE_ONCE</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports a single sequential write. </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_ENCRYPTION"></a><a
///                        id="file_supports_encryption"></a><dl> <dt><b>FILE_SUPPORTS_ENCRYPTION</b></dt> <dt>0x00020000</dt> </dl> </td>
///                        <td width="60%"> The specified volume supports the Encrypted File System (EFS). For more information, see File
///                        Encryption. </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_EXTENDED_ATTRIBUTES"></a><a
///                        id="file_supports_extended_attributes"></a><dl> <dt><b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b></dt>
///                        <dt>0x00800000</dt> </dl> </td> <td width="60%"> The specified volume supports extended attributes. An extended
///                        attribute is a piece of application-specific metadata that an application can associate with a file and is not
///                        part of the file's data. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This
///                        value is not supported until Windows Server 2008 R2 and Windows 7. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_SUPPORTS_HARD_LINKS"></a><a id="file_supports_hard_links"></a><dl>
///                        <dt><b>FILE_SUPPORTS_HARD_LINKS</b></dt> <dt>0x00400000</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports hard links. For more information, see Hard Links and Junctions. <b>Windows Server 2008, Windows Vista,
///                        Windows Server 2003 and Windows XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
///                        </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_OBJECT_IDS"></a><a id="file_supports_object_ids"></a><dl>
///                        <dt><b>FILE_SUPPORTS_OBJECT_IDS</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports object identifiers. </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_OPEN_BY_FILE_ID"></a><a
///                        id="file_supports_open_by_file_id"></a><dl> <dt><b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b></dt> <dt>0x01000000</dt>
///                        </dl> </td> <td width="60%"> The file system supports open by FileID. For more information, see
///                        FILE_ID_BOTH_DIR_INFO. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value
///                        is not supported until Windows Server 2008 R2 and Windows 7. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_SUPPORTS_REPARSE_POINTS"></a><a id="file_supports_reparse_points"></a><dl>
///                        <dt><b>FILE_SUPPORTS_REPARSE_POINTS</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> The specified
///                        volume supports reparse points. <b>ReFS: </b>ReFS supports reparse points but does not index them so
///                        FindFirstVolumeMountPoint and FindNextVolumeMountPoint will not function as expected. </td> </tr> <tr> <td
///                        width="40%"><a id="FILE_SUPPORTS_SPARSE_FILES"></a><a id="file_supports_sparse_files"></a><dl>
///                        <dt><b>FILE_SUPPORTS_SPARSE_FILES</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports sparse files. </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_TRANSACTIONS"></a><a
///                        id="file_supports_transactions"></a><dl> <dt><b>FILE_SUPPORTS_TRANSACTIONS</b></dt> <dt>0x00200000</dt> </dl>
///                        </td> <td width="60%"> The specified volume supports transactions. For more information, see About KTM. </td>
///                        </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_USN_JOURNAL"></a><a id="file_supports_usn_journal"></a><dl>
///                        <dt><b>FILE_SUPPORTS_USN_JOURNAL</b></dt> <dt>0x02000000</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports update sequence number (USN) journals. For more information, see Change Journal Records. <b>Windows
///                        Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported until Windows
///                        Server 2008 R2 and Windows 7. </td> </tr> <tr> <td width="40%"><a id="FILE_UNICODE_ON_DISK"></a><a
///                        id="file_unicode_on_disk"></a><dl> <dt><b>FILE_UNICODE_ON_DISK</b></dt> <dt>0x00000004</dt> </dl> </td> <td
///                        width="60%"> The specified volume supports Unicode in file names as they appear on disk. </td> </tr> <tr> <td
///                        width="40%"><a id="FILE_VOLUME_IS_COMPRESSED"></a><a id="file_volume_is_compressed"></a><dl>
///                        <dt><b>FILE_VOLUME_IS_COMPRESSED</b></dt> <dt>0x00008000</dt> </dl> </td> <td width="60%"> The specified volume
///                        is a compressed volume, for example, a DoubleSpace volume. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_VOLUME_QUOTAS"></a><a id="file_volume_quotas"></a><dl> <dt><b>FILE_VOLUME_QUOTAS</b></dt>
///                        <dt>0x00000020</dt> </dl> </td> <td width="60%"> The specified volume supports disk quotas. </td> </tr> <tr> <td
///                        width="40%"><a id="FILE_SUPPORTS_BLOCK_REFCOUNTING"></a><a id="file_supports_block_refcounting"></a><dl>
///                        <dt><b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b></dt> <dt>0x08000000</dt> </dl> </td> <td width="60%"> The specified
///                        volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes
///                        to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation. </td> </tr> </table>
///    lpFileSystemNameBuffer = A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS
///                             file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.
///    nFileSystemNameSize = The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is <b>MAX_PATH</b>+1. This
///                          parameter is ignored if the file system name buffer is not supplied.
///Returns:
///    If all the requested information is retrieved, the return value is nonzero. If not all the requested information
///    is retrieved, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetVolumeInformationW(const(wchar)* lpRootPathName, const(wchar)* lpVolumeNameBuffer, uint nVolumeNameSize, 
                           uint* lpVolumeSerialNumber, uint* lpMaximumComponentLength, uint* lpFileSystemFlags, 
                           const(wchar)* lpFileSystemNameBuffer, uint nFileSystemNameSize);

///Retrieves the volume mount point where the specified path is mounted.
///Params:
///    lpszFileName = A pointer to the input path string. Both absolute and relative file and directory names, for example, "..", are
///                   acceptable in this path. If you specify a relative directory or file name without a volume qualifier,
///                   **GetVolumePathName** returns the drive letter of the boot volume. If this parameter is an empty string, "", the
///                   function fails but the last error is set to **ERROR_SUCCESS**.
///    lpszVolumePathName = A pointer to a string that receives the volume mount point for the input path.
///    cchBufferLength = The length of the output buffer, in **TCHARs**.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call
///    [GetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror).
///    
@DllImport("KERNEL32")
BOOL GetVolumePathNameW(const(wchar)* lpszFileName, const(wchar)* lpszVolumePathName, uint cchBufferLength);

///Locks the specified file for exclusive access by the calling process. To specify additional options, for example
///creating a shared lock or for block-on-fail operation, use the LockFileEx function.
///Params:
///    hFile = A handle to the file. The file handle must have been created with the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b>
///            access right. For more information, see File Security and Access Rights.
///    dwFileOffsetLow = The low-order 32 bits of the starting byte offset in the file where the lock should begin.
///    dwFileOffsetHigh = The high-order 32 bits of the starting byte offset in the file where the lock should begin.
///    nNumberOfBytesToLockLow = The low-order 32 bits of the length of the byte range to be locked.
///    nNumberOfBytesToLockHigh = The high-order 32 bits of the length of the byte range to be locked.
///Returns:
///    If the function succeeds, the return value is nonzero (<b>TRUE</b>). If the function fails, the return value is
///    zero (<b>FALSE</b>). To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL LockFile(HANDLE hFile, uint dwFileOffsetLow, uint dwFileOffsetHigh, uint nNumberOfBytesToLockLow, 
              uint nNumberOfBytesToLockHigh);

///Locks the specified file for exclusive access by the calling process. This function can operate either synchronously
///or asynchronously and can request either an exclusive or a shared lock.
///Params:
///    hFile = A handle to the file. The handle must have been created with either the <b>GENERIC_READ</b> or
///            <b>GENERIC_WRITE</b> access right. For more information, see File Security and Access Rights.
///    dwFlags = This parameter may be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///              <tr> <td width="40%"><a id="LOCKFILE_EXCLUSIVE_LOCK"></a><a id="lockfile_exclusive_lock"></a><dl>
///              <dt><b>LOCKFILE_EXCLUSIVE_LOCK</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The function requests an
///              exclusive lock. Otherwise, it requests a shared lock. </td> </tr> <tr> <td width="40%"><a
///              id="LOCKFILE_FAIL_IMMEDIATELY"></a><a id="lockfile_fail_immediately"></a><dl>
///              <dt><b>LOCKFILE_FAIL_IMMEDIATELY</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The function returns
///              immediately if it is unable to acquire the requested lock. Otherwise, it waits. </td> </tr> </table>
///    dwReserved = Reserved parameter; must be set to zero.
///    nNumberOfBytesToLockLow = The low-order 32 bits of the length of the byte range to lock.
///    nNumberOfBytesToLockHigh = The high-order 32 bits of the length of the byte range to lock.
///    lpOverlapped = A pointer to an OVERLAPPED structure that the function uses with the locking request. This structure, which is
///                   required, contains the file offset of the beginning of the lock range. You must initialize the <b>hEvent</b>
///                   member to a valid handle or zero.
///Returns:
///    If the function succeeds, the return value is nonzero (<b>TRUE</b>). If the function fails, the return value is
///    zero (<b>FALSE</b>). To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL LockFileEx(HANDLE hFile, uint dwFlags, uint dwReserved, uint nNumberOfBytesToLockLow, 
                uint nNumberOfBytesToLockHigh, OVERLAPPED* lpOverlapped);

///Retrieves information about MS-DOS device names. The function can obtain the current mapping for a particular MS-DOS
///device name. The function can also obtain a list of all existing MS-DOS device names. MS-DOS device names are stored
///as junctions in the object namespace. The code that converts an MS-DOS path into a corresponding path uses these
///junctions to map MS-DOS devices and drive letters. The <b>QueryDosDevice</b> function enables an application to query
///the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific
///junction.
///Params:
///    lpDeviceName = An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing
///                   backslash; for example, use "C:", not "C:\\". This parameter can be <b>NULL</b>. In that case, the
///                   <b>QueryDosDevice</b> function will store a list of all existing MS-DOS device names into the buffer pointed to
///                   by <i>lpTargetPath</i>.
///    lpTargetPath = A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or more
///                   null-terminated strings. The final null-terminated string is followed by an additional <b>NULL</b>. If
///                   <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves information about the particular MS-DOS device
///                   specified by <i>lpDeviceName</i>. The first null-terminated string stored into the buffer is the current mapping
///                   for the device. The other null-terminated strings represent undeleted prior mappings for the device. If
///                   <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of all existing MS-DOS device names. Each
///                   null-terminated string stored into the buffer is the name of an existing MS-DOS device, for example,
///                   \Device\HarddiskVolume1 or \Device\Floppy0.
///    ucchMax = The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by <i>lpTargetPath</i>.
///Returns:
///    If the function succeeds, the return value is the number of <b>TCHARs</b> stored into the buffer pointed to by
///    <i>lpTargetPath</i>. If the function fails, the return value is zero. To get extended error information, call
///    GetLastError. If the buffer is too small, the function fails and the last error code is
///    <b>ERROR_INSUFFICIENT_BUFFER</b>.
///    
@DllImport("KERNEL32")
uint QueryDosDeviceW(const(wchar)* lpDeviceName, const(wchar)* lpTargetPath, uint ucchMax);

///Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
///pointer if supported by the device. This function is designed for both synchronous and asynchronous operations. For a
///similar function designed solely for asynchronous operation, see ReadFileEx.
///Params:
///    hFile = A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
///            socket, communications resource, mailslot, or pipe). The <i>hFile</i> parameter must have been created with read
///            access. For more information, see Generic Access Rights and File Security and Access Rights. For asynchronous
///            read operations, <i>hFile</i> can be any handle that is opened with the <b>FILE_FLAG_OVERLAPPED</b> flag by the
///            CreateFile function, or a socket handle returned by the socket or accept function.
///    lpBuffer = A pointer to the buffer that receives the data read from a file or device. This buffer must remain valid for the
///               duration of the read operation. The caller must not use this buffer until the read operation is completed.
///    nNumberOfBytesToRead = The maximum number of bytes to be read.
///    lpNumberOfBytesRead = A pointer to the variable that receives the number of bytes read when using a synchronous <i>hFile</i> parameter.
///                          <b>ReadFile</b> sets this value to zero before doing any work or error checking. Use <b>NULL</b> for this
///                          parameter if this is an asynchronous operation to avoid potentially erroneous results. This parameter can be
///                          <b>NULL</b> only when the <i>lpOverlapped</i> parameter is not <b>NULL</b>. For more information, see the Remarks
///                          section.
///    lpOverlapped = A pointer to an OVERLAPPED structure is required if the <i>hFile</i> parameter was opened with
///                   <b>FILE_FLAG_OVERLAPPED</b>, otherwise it can be <b>NULL</b>. If <i>hFile</i> is opened with
///                   <b>FILE_FLAG_OVERLAPPED</b>, the <i>lpOverlapped</i> parameter must point to a valid and unique OVERLAPPED
///                   structure, otherwise the function can incorrectly report that the read operation is complete. For an <i>hFile</i>
///                   that supports byte offsets, if you use this parameter you must specify a byte offset at which to start reading
///                   from the file or device. This offset is specified by setting the <b>Offset</b> and <b>OffsetHigh</b> members of
///                   the OVERLAPPED structure. For an <i>hFile</i> that does not support byte offsets, <b>Offset</b> and
///                   <b>OffsetHigh</b> are ignored. For more information about different combinations of <i>lpOverlapped</i> and
///                   <b>FILE_FLAG_OVERLAPPED</b>, see the Remarks section and the Synchronization and File Position section.
///Returns:
///    If the function succeeds, the return value is nonzero (<b>TRUE</b>). If the function fails, or is completing
///    asynchronously, the return value is zero (<b>FALSE</b>). To get extended error information, call the GetLastError
///    function. <div class="alert"><b>Note</b> The GetLastError code <b>ERROR_IO_PENDING</b> is not a failure; it
///    designates the read operation is pending completion asynchronously. For more information, see Remarks.</div>
///    <div> </div>
///    
@DllImport("KERNEL32")
BOOL ReadFile(HANDLE hFile, char* lpBuffer, uint nNumberOfBytesToRead, uint* lpNumberOfBytesRead, 
              OVERLAPPED* lpOverlapped);

///Reads data from the specified file or input/output (I/O) device. It reports its completion status asynchronously,
///calling the specified completion routine when reading is completed or canceled and the calling thread is in an
///alertable wait state. To read data from a file or device synchronously, use the ReadFile function.
///Params:
///    hFile = A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
///            drive, socket, communications resource, mailslot, or pipe). This parameter can be any handle opened with the
///            <b>FILE_FLAG_OVERLAPPED</b> flag by the CreateFile function, or a socket handle returned by the socket or accept
///            function. This handle also must have the <b>GENERIC_READ</b> access right. For more information on access rights,
///            see File Security and Access Rights.
///    lpBuffer = A pointer to a buffer that receives the data read from the file or device. This buffer must remain valid for the
///               duration of the read operation. The application should not use this buffer until the read operation is completed.
///    nNumberOfBytesToRead = The number of bytes to be read.
///    lpOverlapped = A pointer to an OVERLAPPED data structure that supplies data to be used during the asynchronous (overlapped) file
///                   read operation. For files that support byte offsets, you must specify a byte offset at which to start reading
///                   from the file. You specify this offset by setting the <b>Offset</b> and <b>OffsetHigh</b> members of the
///                   OVERLAPPED structure. For files or devices that do not support byte offsets, <b>Offset</b> and <b>OffsetHigh</b>
///                   are ignored. The <b>ReadFileEx</b> function ignores the OVERLAPPED structure's <b>hEvent</b> member. An
///                   application is free to use that member for its own purposes in the context of a <b>ReadFileEx</b> call.
///                   <b>ReadFileEx</b> signals completion of its read operation by calling, or queuing a call to, the completion
///                   routine pointed to by <i>lpCompletionRoutine</i>, so it does not need an event handle. The <b>ReadFileEx</b>
///                   function does use the OVERLAPPED structure's <b>Internal</b> and <b>InternalHigh</b> members. An application
///                   should not set these members. The OVERLAPPED data structure must remain valid for the duration of the read
///                   operation. It should not be a variable that can go out of scope while the read operation is pending completion.
///    lpCompletionRoutine = A pointer to the completion routine to be called when the read operation is complete and the calling thread is in
///                          an alertable wait state. For more information about the completion routine, see FileIOCompletionRoutine.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the function succeeds, the calling thread has an asynchronous
///    I/O operation pending: the overlapped read operation from the file. When this I/O operation completes, and the
///    calling thread is blocked in an alertable wait state, the system calls the function pointed to by
///    <i>lpCompletionRoutine</i>, and the wait state completes with a return code of <b>WAIT_IO_COMPLETION</b>. If the
///    function succeeds, and the file reading operation completes, but the calling thread is not in an alertable wait
///    state, the system queues the completion routine call, holding the call until the calling thread enters an
///    alertable wait state. For information about alertable waits and overlapped input/output operations, see About
///    Synchronization. If <b>ReadFileEx</b> attempts to read past the end-of-file (EOF), the call to
///    GetOverlappedResult for that operation returns <b>FALSE</b> and GetLastError returns <b>ERROR_HANDLE_EOF</b>.
///    
@DllImport("KERNEL32")
BOOL ReadFileEx(HANDLE hFile, char* lpBuffer, uint nNumberOfBytesToRead, OVERLAPPED* lpOverlapped, 
                LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

///Reads data from a file and stores it in an array of buffers. The function starts reading data from the file at a
///position that is specified by an OVERLAPPED structure. The <b>ReadFileScatter</b> function operates asynchronously.
///Params:
///    hFile = A handle to the file to be read. The file handle must be created with the <b>GENERIC_READ</b> right, and the
///            <b>FILE_FLAG_OVERLAPPED</b> and <b>FILE_FLAG_NO_BUFFERING</b> flags. For more information, see File Security and
///            Access Rights.
///    aSegmentArray = A pointer to an array of FILE_SEGMENT_ELEMENT buffers that receives the data. For a description of this union,
///                    see Remarks. Each element can receive one page of data. <div class="alert"><b>Note</b> To determine the size of a
///                    system page, use GetSystemInfo.</div> <div> </div> The array must contain enough elements to store
///                    <i>nNumberOfBytesToRead</i> bytes of data, plus one element for the terminating <b>NULL</b>. For example, if
///                    there are 40 KB to be read and the page size is 4 KB, the array must have 11 elements that includes 10 for the
///                    data and one for the <b>NULL</b>. Each buffer must be at least the size of a system memory page and must be
///                    aligned on a system memory page size boundary. The system reads one system memory page of data into each buffer.
///                    The function stores the data in the buffers in sequential order. For example, it stores data into the first
///                    buffer, then into the second buffer, and so on until each buffer is filled and all the data is stored, or there
///                    are no more buffers.
///    nNumberOfBytesToRead = The total number of bytes to be read from the file. Each element of <i>aSegmentArray</i> contains a one-page
///                           chunk of this total. Because the file must be opened with <b>FILE_FLAG_NO_BUFFERING</b>, the number of bytes must
///                           be a multiple of the sector size of the file system where the file is located.
///    lpReserved = This parameter is reserved for future use and must be <b>NULL</b>.
///    lpOverlapped = A pointer to an OVERLAPPED data structure. The <b>ReadFileScatter</b> function requires a valid OVERLAPPED
///                   structure. The <i>lpOverlapped</i> parameter cannot be <b>NULL</b>. The <b>ReadFileScatter</b> function starts
///                   reading data from the file at a position that is specified by the <b>Offset</b> and <b>OffsetHigh</b> members of
///                   the OVERLAPPED structure. The <b>ReadFileScatter</b> function may return before the read operation is complete.
///                   In that scenario, the <b>ReadFileScatter</b> function returns the value 0 (zero), and the GetLastError function
///                   returns the value <b>ERROR_IO_PENDING</b>. This asynchronous operation of <b>ReadFileScatter</b> lets the calling
///                   process continue while the read operation completes. You can call the GetOverlappedResult,
///                   HasOverlappedIoCompleted, or GetQueuedCompletionStatus functions to obtain information about the completion of
///                   the read operation. For more information, see Synchronous and Asynchronous I/O.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. If <b>ReadFileScatter</b> attempts to read past
///    the end-of-file (EOF), the call to GetOverlappedResult for that operation returns <b>FALSE</b> and GetLastError
///    returns <b>ERROR_HANDLE_EOF</b>. If the function returns before the read operation is complete, the function
///    returns zero (0), and GetLastError returns <b>ERROR_IO_PENDING</b>.
///    
@DllImport("KERNEL32")
BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT* aSegmentArray, uint nNumberOfBytesToRead, 
                     uint* lpReserved, OVERLAPPED* lpOverlapped);

///Deletes an existing empty directory. To perform this operation as a transacted operation, use the
///RemoveDirectoryTransacted function.
///Params:
///    lpPathName = The path of the directory to be removed. This path must specify an empty directory, and the calling process must
///                 have delete access to the directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\\\?\\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting with
///                 Windows 10, version 1607, for the unicode version of this function (<b>RemoveDirectoryW</b>), you can opt-in to
///                 remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section
///                 of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL RemoveDirectoryA(const(char)* lpPathName);

///Deletes an existing empty directory. To perform this operation as a transacted operation, use the
///RemoveDirectoryTransacted function.
///Params:
///    lpPathName = The path of the directory to be removed. This path must specify an empty directory, and the calling process must
///                 have delete access to the directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\\\?\\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting with
///                 Windows 10, version 1607, for the unicode version of this function (<b>RemoveDirectoryW</b>), you can opt-in to
///                 remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section
///                 of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL RemoveDirectoryW(const(wchar)* lpPathName);

///Sets the physical file size for the specified file to the current position of the file pointer. The physical file
///size is also referred to as the end of the file. The <b>SetEndOfFile</b> function can be used to truncate or extend a
///file. To set the logical end of a file, use the SetFileValidData function.
///Params:
///    hFile = A handle to the file to be extended or truncated. The file handle must be created with the <b>GENERIC_WRITE</b>
///            access right. For more information, see File Security and Access Rights.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetEndOfFile(HANDLE hFile);

///Sets the attributes for a file or directory. To perform this operation as a transacted operation, use the
///SetFileAttributesTransacted function.
///Params:
///    lpFileName = The name of the file whose attributes are to be set. In the ANSI version of this function, the name is limited to
///                 <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                 function (<b>SetFileAttributesW</b>) and prepend "\\\\?\\" to the path. For more information, see File Names,
///                 Paths, and Namespaces. <div class="alert"><b>Tip</b> Starting in Windows 10, version 1607, for the unicode
///                 version of this function (<b>SetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character
///                 limitation without prepending "\\?\". See the "Maximum Path Limitation" section of Naming Files, Paths, and
///                 Namespaces for details. </div> <div> </div>
///    dwFileAttributes = The file attributes to set for the file. This parameter can be one or more values, combined using the bitwise-OR
///                       operator. However, all other values override <b>FILE_ATTRIBUTE_NORMAL</b>. Not all attributes are supported by
///                       this function. For more information, see the Remarks section. The following is a list of supported attribute
///                       values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                       id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl> <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
///                       <dt>32 (0x20)</dt> </dl> </td> <td width="60%"> A file or directory that is an archive file or directory.
///                       Applications typically use this attribute to mark files for backup or removal. </td> </tr> <tr> <td
///                       width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
///                       <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt> <dt>2 (0x2)</dt> </dl> </td> <td width="60%"> The file or directory is
///                       hidden. It is not included in an ordinary directory listing. </td> </tr> <tr> <td width="40%"><a
///                       id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl> <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
///                       <dt>128 (0x80)</dt> </dl> </td> <td width="60%"> A file that does not have other attributes set. This attribute
///                       is valid only when used alone. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_NOT_CONTENT_INDEXED"></a><a
///                       id="file_attribute_not_content_indexed"></a><dl> <dt><b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b></dt> <dt>8192
///                       (0x2000)</dt> </dl> </td> <td width="60%"> The file or directory is not to be indexed by the content indexing
///                       service. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a
///                       id="file_attribute_offline"></a><dl> <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt> <dt>4096 (0x1000)</dt> </dl> </td>
///                       <td width="60%"> The data of a file is not available immediately. This attribute indicates that the file data is
///                       physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage
///                       management software. Applications should not arbitrarily change this attribute. </td> </tr> <tr> <td
///                       width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
///                       <dt><b>FILE_ATTRIBUTE_READONLY</b></dt> <dt>1 (0x1)</dt> </dl> </td> <td width="60%"> A file that is read-only.
///                       Applications can read the file, but cannot write to it or delete it. This attribute is not honored on
///                       directories. For more information, see "You cannot view or change the Read-only or the System attributes of
///                       folders in Windows Server 2003, in Windows XP, or in Windows Vista. </td> </tr> <tr> <td width="40%"><a
///                       id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl> <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt> <dt>4
///                       (0x4)</dt> </dl> </td> <td width="60%"> A file or directory that the operating system uses a part of, or uses
///                       exclusively. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a
///                       id="file_attribute_temporary"></a><dl> <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt> <dt>256 (0x100)</dt> </dl> </td>
///                       <td width="60%"> A file that is being used for temporary storage. File systems avoid writing data back to mass
///                       storage if sufficient cache memory is available, because typically, an application deletes a temporary file after
///                       the handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is
///                       written after the handle is closed. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetFileAttributesA(const(char)* lpFileName, FILE_FLAGS_AND_ATTRIBUTES dwFileAttributes);

///Sets the attributes for a file or directory. To perform this operation as a transacted operation, use the
///SetFileAttributesTransacted function.
///Params:
///    lpFileName = The name of the file whose attributes are to be set. In the ANSI version of this function, the name is limited to
///                 <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                 function (<b>SetFileAttributesW</b>) and prepend "\\\\?\\" to the path. For more information, see File Names,
///                 Paths, and Namespaces. <div class="alert"><b>Tip</b> Starting in Windows 10, version 1607, for the unicode
///                 version of this function (<b>SetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character
///                 limitation without prepending "\\?\". See the "Maximum Path Limitation" section of Naming Files, Paths, and
///                 Namespaces for details. </div> <div> </div>
///    dwFileAttributes = The file attributes to set for the file. This parameter can be one or more values, combined using the bitwise-OR
///                       operator. However, all other values override <b>FILE_ATTRIBUTE_NORMAL</b>. Not all attributes are supported by
///                       this function. For more information, see the Remarks section. The following is a list of supported attribute
///                       values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                       id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl> <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
///                       <dt>32 (0x20)</dt> </dl> </td> <td width="60%"> A file or directory that is an archive file or directory.
///                       Applications typically use this attribute to mark files for backup or removal. </td> </tr> <tr> <td
///                       width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
///                       <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt> <dt>2 (0x2)</dt> </dl> </td> <td width="60%"> The file or directory is
///                       hidden. It is not included in an ordinary directory listing. </td> </tr> <tr> <td width="40%"><a
///                       id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl> <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
///                       <dt>128 (0x80)</dt> </dl> </td> <td width="60%"> A file that does not have other attributes set. This attribute
///                       is valid only when used alone. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_NOT_CONTENT_INDEXED"></a><a
///                       id="file_attribute_not_content_indexed"></a><dl> <dt><b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b></dt> <dt>8192
///                       (0x2000)</dt> </dl> </td> <td width="60%"> The file or directory is not to be indexed by the content indexing
///                       service. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a
///                       id="file_attribute_offline"></a><dl> <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt> <dt>4096 (0x1000)</dt> </dl> </td>
///                       <td width="60%"> The data of a file is not available immediately. This attribute indicates that the file data is
///                       physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage
///                       management software. Applications should not arbitrarily change this attribute. </td> </tr> <tr> <td
///                       width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
///                       <dt><b>FILE_ATTRIBUTE_READONLY</b></dt> <dt>1 (0x1)</dt> </dl> </td> <td width="60%"> A file that is read-only.
///                       Applications can read the file, but cannot write to it or delete it. This attribute is not honored on
///                       directories. For more information, see "You cannot view or change the Read-only or the System attributes of
///                       folders in Windows Server 2003, in Windows XP, or in Windows Vista. </td> </tr> <tr> <td width="40%"><a
///                       id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl> <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt> <dt>4
///                       (0x4)</dt> </dl> </td> <td width="60%"> A file or directory that the operating system uses a part of, or uses
///                       exclusively. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a
///                       id="file_attribute_temporary"></a><dl> <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt> <dt>256 (0x100)</dt> </dl> </td>
///                       <td width="60%"> A file that is being used for temporary storage. File systems avoid writing data back to mass
///                       storage if sufficient cache memory is available, because typically, an application deletes a temporary file after
///                       the handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is
///                       written after the handle is closed. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetFileAttributesW(const(wchar)* lpFileName, FILE_FLAGS_AND_ATTRIBUTES dwFileAttributes);

///Sets the file information for the specified file. To retrieve file information using a file handle, see
///GetFileInformationByHandle or GetFileInformationByHandleEx.
///Params:
///    hFile = A handle to the file for which to change information. This handle must be opened with the appropriate permissions
///            for the requested change. For more information, see the Remarks and Example Code sections. This handle should not
///            be a pipe handle.
///    FileInformationClass = A FILE_INFO_BY_HANDLE_CLASS enumeration value that specifies the type of information to be changed. For a table
///                           of valid values, see the Remarks section.
///    lpFileInformation = A pointer to the buffer that contains the information to change for the specified file information class. The
///                        structure that this parameter points to corresponds to the class that is specified by
///                        <i>FileInformationClass</i>. For a table of valid structure types, see the Remarks section.
///    dwBufferSize = The size of <i>lpFileInformation</i>, in bytes.
///Returns:
///    Returns nonzero if successful or zero otherwise. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, 
                                char* lpFileInformation, uint dwBufferSize);

///Moves the file pointer of the specified file. This function stores the file pointer in two <b>LONG</b> values. To
///work with file pointers that are larger than a single <b>LONG</b> value, it is easier to use the SetFilePointerEx
///function.
///Params:
///    hFile = A handle to the file. The file handle must be created with the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access
///            right. For more information, see File Security and Access Rights.
///    lDistanceToMove = The low order 32-bits of a signed value that specifies the number of bytes to move the file pointer. If
///                      <i>lpDistanceToMoveHigh</i> is not <b>NULL</b>, <i>lpDistanceToMoveHigh</i> and <i>lDistanceToMove</i> form a
///                      single 64-bit signed value that specifies the distance to move. If <i>lpDistanceToMoveHigh</i> is <b>NULL</b>,
///                      <i>lDistanceToMove</i> is a 32-bit signed value. A positive value for <i>lDistanceToMove</i> moves the file
///                      pointer forward in the file, and a negative value moves the file pointer back.
///    lpDistanceToMoveHigh = A pointer to the high order 32-bits of the signed 64-bit distance to move. If you do not need the high order
///                           32-bits, this pointer must be set to <b>NULL</b>. When not <b>NULL</b>, this parameter also receives the high
///                           order <b>DWORD</b> of the new value of the file pointer. For more information, see the Remarks section in this
///                           topic.
///    dwMoveMethod = The starting point for the file pointer move. This parameter can be one of the following values. <table> <tr>
///                   <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_BEGIN"></a><a id="file_begin"></a><dl>
///                   <dt><b>FILE_BEGIN</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> The starting point is zero or the beginning of
///                   the file. </td> </tr> <tr> <td width="40%"><a id="FILE_CURRENT"></a><a id="file_current"></a><dl>
///                   <dt><b>FILE_CURRENT</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The starting point is the current value of
///                   the file pointer. </td> </tr> <tr> <td width="40%"><a id="FILE_END"></a><a id="file_end"></a><dl>
///                   <dt><b>FILE_END</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The starting point is the current end-of-file
///                   position. </td> </tr> </table>
///Returns:
///    If the function succeeds and <i>lpDistanceToMoveHigh</i> is <b>NULL</b>, the return value is the low-order
///    <b>DWORD</b> of the new file pointer. <b>Note</b> If the function returns a value other than
///    <b>INVALID_SET_FILE_POINTER</b>, the call to <b>SetFilePointer</b> has succeeded. You do not need to call
///    GetLastError. If function succeeds and <i>lpDistanceToMoveHigh</i> is not <b>NULL</b>, the return value is the
///    low-order <b>DWORD</b> of the new file pointer and <i>lpDistanceToMoveHigh</i> contains the high order
///    <b>DWORD</b> of the new file pointer. If the function fails, the return value is <b>INVALID_SET_FILE_POINTER</b>.
///    To get extended error information, call GetLastError. If a new file pointer is a negative value, the function
///    fails, the file pointer is not moved, and the code returned by GetLastError is <b>ERROR_NEGATIVE_SEEK</b>. If
///    <i>lpDistanceToMoveHigh</i> is <b>NULL</b> and the new file position does not fit in a 32-bit value, the function
///    fails and returns <b>INVALID_SET_FILE_POINTER</b>. <div class="alert"><b>Note</b> Because
///    <b>INVALID_SET_FILE_POINTER</b> is a valid value for the low-order <b>DWORD</b> of the new file pointer, you must
///    check both the return value of the function and the error code returned by GetLastError to determine whether or
///    not an error has occurred. If an error has occurred, the return value of <b>SetFilePointer</b> is
///    <b>INVALID_SET_FILE_POINTER</b> and <b>GetLastError</b> returns a value other than <b>NO_ERROR</b>. For a code
///    example that demonstrates how to check for failure, see the Remarks section in this topic.</div> <div> </div>
///    
@DllImport("KERNEL32")
uint SetFilePointer(HANDLE hFile, int lDistanceToMove, int* lpDistanceToMoveHigh, uint dwMoveMethod);

///Moves the file pointer of the specified file.
///Params:
///    hFile = A handle to the file. The file handle must have been created with the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b>
///            access right. For more information, see File Security and Access Rights.
///    liDistanceToMove = The number of bytes to move the file pointer. A positive value moves the pointer forward in the file and a
///                       negative value moves the file pointer backward.
///    lpNewFilePointer = A pointer to a variable to receive the new file pointer. If this parameter is <b>NULL</b>, the new file pointer
///                       is not returned.
///    dwMoveMethod = The starting point for the file pointer move. This parameter can be one of the following values. <table> <tr>
///                   <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_BEGIN"></a><a id="file_begin"></a><dl>
///                   <dt><b>FILE_BEGIN</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> The starting point is zero or the beginning of
///                   the file. If this flag is specified, then the <i>liDistanceToMove</i> parameter is interpreted as an unsigned
///                   value. </td> </tr> <tr> <td width="40%"><a id="FILE_CURRENT"></a><a id="file_current"></a><dl>
///                   <dt><b>FILE_CURRENT</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The start point is the current value of the
///                   file pointer. </td> </tr> <tr> <td width="40%"><a id="FILE_END"></a><a id="file_end"></a><dl>
///                   <dt><b>FILE_END</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The starting point is the current end-of-file
///                   position. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, LARGE_INTEGER* lpNewFilePointer, 
                      uint dwMoveMethod);

///Sets the valid data length of the specified file. This function is useful in very limited scenarios. For more
///information, see the Remarks section.<div class="alert"><b>Caution</b> Use of this function without proper security
///considerations may compromise data privacy and security. For more information, see the Remarks section.</div> <div>
///</div>
///Params:
///    hFile = A handle to the file. The file must have been opened with the <b>GENERIC_WRITE</b> access right, and the
///            <b>SE_MANAGE_VOLUME_NAME</b> privilege enabled. For more information, see File Security and Access Rights. <div
///            class="alert"><b>Note</b> The file cannot be a network file, or be compressed, sparse, or transacted.</div> <div>
///            </div>
///    ValidDataLength = The new valid data length. This parameter must be a positive value that is greater than the current valid data
///                      length, but less than the current file size.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetFileValidData(HANDLE hFile, long ValidDataLength);

///Unlocks a region in an open file. Unlocking a region enables other processes to access the region. For an alternate
///way to specify the region, use the UnlockFileEx function.
///Params:
///    hFile = A handle to the file that contains a region locked with LockFile. The file handle must have been created with
///            either the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see File Security and
///            Access Rights.
///    dwFileOffsetLow = The low-order word of the starting byte offset in the file where the locked region begins.
///    dwFileOffsetHigh = The high-order word of the starting byte offset in the file where the locked region begins.
///    nNumberOfBytesToUnlockLow = The low-order word of the length of the byte range to be unlocked.
///    nNumberOfBytesToUnlockHigh = The high-order word of the length of the byte range to be unlocked.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL UnlockFile(HANDLE hFile, uint dwFileOffsetLow, uint dwFileOffsetHigh, uint nNumberOfBytesToUnlockLow, 
                uint nNumberOfBytesToUnlockHigh);

///Unlocks a region in the specified file. This function can operate either synchronously or asynchronously.
///Params:
///    hFile = A handle to the file. The handle must have been created with either the <b>GENERIC_READ</b> or
///            <b>GENERIC_WRITE</b> access right. For more information, see File Security and Access Rights.
///    dwReserved = Reserved parameter; must be zero.
///    nNumberOfBytesToUnlockLow = The low-order part of the length of the byte range to unlock.
///    nNumberOfBytesToUnlockHigh = The high-order part of the length of the byte range to unlock.
///    lpOverlapped = A pointer to an OVERLAPPED structure that the function uses with the unlocking request. This structure contains
///                   the file offset of the beginning of the unlock range. You must initialize the <b>hEvent</b> member to a valid
///                   handle or zero. For more information, see Synchronous and Asynchronous I/O.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero or
///    <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL UnlockFileEx(HANDLE hFile, uint dwReserved, uint nNumberOfBytesToUnlockLow, uint nNumberOfBytesToUnlockHigh, 
                  OVERLAPPED* lpOverlapped);

///Writes data to the specified file or input/output (I/O) device. This function is designed for both synchronous and
///asynchronous operation. For a similar function designed solely for asynchronous operation, see WriteFileEx.
///Params:
///    hFile = A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
///            drive, socket, communications resource, mailslot, or pipe). The <i>hFile</i> parameter must have been created
///            with the write access. For more information, see Generic Access Rights and File Security and Access Rights. For
///            asynchronous write operations, <i>hFile</i> can be any handle opened with the CreateFile function using the
///            <b>FILE_FLAG_OVERLAPPED</b> flag or a socket handle returned by the socket or accept function.
///    lpBuffer = A pointer to the buffer containing the data to be written to the file or device. This buffer must remain valid
///               for the duration of the write operation. The caller must not use this buffer until the write operation is
///               completed.
///    nNumberOfBytesToWrite = The number of bytes to be written to the file or device. A value of zero specifies a null write operation. The
///                            behavior of a null write operation depends on the underlying file system or communications technology. <b>Windows
///                            Server 2003 and Windows XP: </b>Pipe write operations across a network are limited in size per write. The amount
///                            varies per platform. For x86 platforms it's 63.97 MB. For x64 platforms it's 31.97 MB. For Itanium it's 63.95 MB.
///                            For more information regarding pipes, see the Remarks section.
///    lpNumberOfBytesWritten = A pointer to the variable that receives the number of bytes written when using a synchronous <i>hFile</i>
///                             parameter. <b>WriteFile</b> sets this value to zero before doing any work or error checking. Use <b>NULL</b> for
///                             this parameter if this is an asynchronous operation to avoid potentially erroneous results. This parameter can be
///                             <b>NULL</b> only when the <i>lpOverlapped</i> parameter is not <b>NULL</b>. For more information, see the Remarks
///                             section.
///    lpOverlapped = A pointer to an OVERLAPPED structure is required if the <i>hFile</i> parameter was opened with
///                   <b>FILE_FLAG_OVERLAPPED</b>, otherwise this parameter can be <b>NULL</b>. For an <i>hFile</i> that supports byte
///                   offsets, if you use this parameter you must specify a byte offset at which to start writing to the file or
///                   device. This offset is specified by setting the <b>Offset</b> and <b>OffsetHigh</b> members of the OVERLAPPED
///                   structure. For an <i>hFile</i> that does not support byte offsets, <b>Offset</b> and <b>OffsetHigh</b> are
///                   ignored. To write to the end of file, specify both the <b>Offset</b> and <b>OffsetHigh</b> members of the
///                   OVERLAPPED structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function
///                   to open <i>hFile</i> using <b>FILE_APPEND_DATA</b> access. For more information about different combinations of
///                   <i>lpOverlapped</i> and <b>FILE_FLAG_OVERLAPPED</b>, see the Remarks section and the Synchronization and File
///                   Position section.
///Returns:
///    If the function succeeds, the return value is nonzero (<b>TRUE</b>). If the function fails, or is completing
///    asynchronously, the return value is zero (<b>FALSE</b>). To get extended error information, call the GetLastError
///    function. <div class="alert"><b>Note</b> The GetLastError code <b>ERROR_IO_PENDING</b> is not a failure; it
///    designates the write operation is pending completion asynchronously. For more information, see Remarks.</div>
///    <div> </div>
///    
@DllImport("KERNEL32")
BOOL WriteFile(HANDLE hFile, char* lpBuffer, uint nNumberOfBytesToWrite, uint* lpNumberOfBytesWritten, 
               OVERLAPPED* lpOverlapped);

///Writes data to the specified file or input/output (I/O) device. It reports its completion status asynchronously,
///calling the specified completion routine when writing is completed or canceled and the calling thread is in an
///alertable wait state. To write data to a file or device synchronously, use the WriteFile function.
///Params:
///    hFile = A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
///            drive, socket, communications resource, mailslot, or pipe). This parameter can be any handle opened with the
///            <b>FILE_FLAG_OVERLAPPED</b> flag by the CreateFile function, or a socket handle returned by the socket or accept
///            function. Do not associate an I/O completion port with this handle. For more information, see the Remarks
///            section. This handle also must have the <b>GENERIC_WRITE</b> access right. For more information on access rights,
///            see File Security and Access Rights.
///    lpBuffer = A pointer to the buffer containing the data to be written to the file or device. This buffer must remain valid
///               for the duration of the write operation. The caller must not use this buffer until the write operation is
///               completed.
///    nNumberOfBytesToWrite = The number of bytes to be written to the file or device. A value of zero specifies a null write operation. The
///                            behavior of a null write operation depends on the underlying file system. Pipe write operations across a network
///                            are limited to 65,535 bytes per write. For more information regarding pipes, see the Remarks section.
///    lpOverlapped = A pointer to an OVERLAPPED data structure that supplies data to be used during the overlapped (asynchronous)
///                   write operation. For files that support byte offsets, you must specify a byte offset at which to start writing to
///                   the file. You specify this offset by setting the <b>Offset</b> and <b>OffsetHigh</b> members of the OVERLAPPED
///                   structure. For files or devices that do not support byte offsets, <b>Offset</b> and <b>OffsetHigh</b> are
///                   ignored. To write to the end of file, specify both the <b>Offset</b> and <b>OffsetHigh</b> members of the
///                   OVERLAPPED structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function
///                   to open <i>hFile</i> using <b>FILE_APPEND_DATA</b> access. The <b>WriteFileEx</b> function ignores the OVERLAPPED
///                   structure's <b>hEvent</b> member. An application is free to use that member for its own purposes in the context
///                   of a <b>WriteFileEx</b> call. <b>WriteFileEx</b> signals completion of its writing operation by calling, or
///                   queuing a call to, the completion routine pointed to by <i>lpCompletionRoutine</i>, so it does not need an event
///                   handle. The <b>WriteFileEx</b> function does use the <b>Internal</b> and <b>InternalHigh</b> members of the
///                   OVERLAPPED structure. You should not change the value of these members. The OVERLAPPED data structure must remain
///                   valid for the duration of the write operation. It should not be a variable that can go out of scope while the
///                   write operation is pending completion.
///    lpCompletionRoutine = A pointer to a completion routine to be called when the write operation has been completed and the calling thread
///                          is in an alertable wait state. For more information about this completion routine, see FileIOCompletionRoutine.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the <b>WriteFileEx</b> function succeeds, the calling thread
///    has an asynchronous I/O operation pending: the overlapped write operation to the file. When this I/O operation
///    finishes, and the calling thread is blocked in an alertable wait state, the operating system calls the function
///    pointed to by <i>lpCompletionRoutine</i>, and the wait completes with a return code of <b>WAIT_IO_COMPLETION</b>.
///    If the function succeeds and the file-writing operation finishes, but the calling thread is not in an alertable
///    wait state, the system queues the call to *<i>lpCompletionRoutine</i>, holding the call until the calling thread
///    enters an alertable wait state. For more information about alertable wait states and overlapped input/output
///    operations, see About Synchronization.
///    
@DllImport("KERNEL32")
BOOL WriteFileEx(HANDLE hFile, char* lpBuffer, uint nNumberOfBytesToWrite, OVERLAPPED* lpOverlapped, 
                 LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

///Retrieves data from an array of buffers and writes the data to a file. The function starts writing data to the file
///at a position that is specified by an OVERLAPPED structure. The <b>WriteFileGather</b> function operates
///asynchronously.
///Params:
///    hFile = A handle to the file. The file handle must be created with the <b>GENERIC_WRITE</b> access right, and the
///            <b>FILE_FLAG_OVERLAPPED</b> and <b>FILE_FLAG_NO_BUFFERING</b> flags. For more information, see File Security and
///            Access Rights.
///    aSegmentArray = A pointer to an array of FILE_SEGMENT_ELEMENT buffers that contain the data. For a description of this union, see
///                    Remarks. Each element contains the address of one page of data. <div class="alert"><b>Note</b> To determine the
///                    size of a system page, use the GetSystemInfo function.</div> <div> </div>The array must contain enough elements
///                    to store <i>nNumberOfBytesToWrite</i> bytes of data, and one element for the terminating <b>NULL</b>. For
///                    example, if there are 40 KB to be read and the page size is 4 KB, the array must have 11 elements that includes
///                    10 elements for the data and one element for the <b>NULL</b>. Each buffer must be at least the size of a system
///                    memory page and must be aligned on a system memory page size boundary. The system writes one system memory page
///                    of data from each buffer. The function gathers the data from the buffers in a sequential order. For example, it
///                    writes data to the file from the first buffer, then the second buffer, and so on until there is no more data. Due
///                    to the asynchronous operation of this function, precautions must be taken to ensure that this parameter always
///                    references valid memory for the lifetime of the asynchronous writes. For instance, a common programming error is
///                    to use local stack storage and then allow execution to run out of scope.
///    nNumberOfBytesToWrite = The total number of bytes to be written. Each element of <i>aSegmentArray</i> contains a one-page chunk of this
///                            total. Because the file must be opened with <b>FILE_FLAG_NO_BUFFERING</b>, the number of bytes must be a multiple
///                            of the sector size of the file system where the file is located. If <i>nNumberOfBytesToWrite</i> is zero (0), the
///                            function performs a null write operation. The behavior of a null write operation depends on the underlying file
///                            system. If <i>nNumberOfBytesToWrite</i> is not zero (0) and the offset and length of the write place data beyond
///                            the current end of the file, the <b>WriteFileGather</b> function extends the file.
///    lpReserved = This parameter is reserved for future use and must be <b>NULL</b>.
///    lpOverlapped = A pointer to an OVERLAPPED data structure. The <b>WriteFileGather</b> function requires a valid OVERLAPPED
///                   structure. The <i>lpOverlapped</i> parameter cannot be <b>NULL</b>. The <b>WriteFileGather</b> function starts
///                   writing data to the file at a position that is specified by the <b>Offset</b> and <b>OffsetHigh</b> members of
///                   the OVERLAPPED structure. The <b>WriteFileGather</b> function may return before the write operation is complete.
///                   In that scenario, the <b>WriteFileGather</b> function returns the value zero (0), and the GetLastError function
///                   returns the value <b>ERROR_IO_PENDING</b>. This asynchronous operation of the <b>WriteFileGather</b> function
///                   lets the calling process continue while the write operation completes. You can call the GetOverlappedResult,
///                   HasOverlappedIoCompleted, or GetQueuedCompletionStatus function to obtain information about the completion of the
///                   write operation. For more information, see Synchronous and Asynchronous I/O.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. If the function returns before the write
///    operation is complete, the function returns zero (0), and the GetLastError function returns
///    <b>ERROR_IO_PENDING</b>.
///    
@DllImport("KERNEL32")
BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT* aSegmentArray, uint nNumberOfBytesToWrite, 
                     uint* lpReserved, OVERLAPPED* lpOverlapped);

///Retrieves the path of the directory designated for temporary files.
///Params:
///    nBufferLength = The size of the string buffer identified by <i>lpBuffer</i>, in <b>TCHARs</b>.
///    lpBuffer = A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. The
///               returned string ends with a backslash, for example, "C:\\TEMP\\".
///Returns:
///    If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to
///    <i>lpBuffer</i>, not including the terminating null character. If the return value is greater than
///    <i>nBufferLength</i>, the return value is the length, in <b>TCHARs</b>, of the buffer required to hold the path.
///    If the function fails, the return value is zero. To get extended error information, call GetLastError. The
///    maximum possible return value is <b>MAX_PATH</b>+1 (261).
///    
@DllImport("KERNEL32")
uint GetTempPathW(uint nBufferLength, const(wchar)* lpBuffer);

///Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point ( drive
///letter, volume <b>GUID</b> path, or mounted folder).
///Params:
///    lpszVolumeMountPoint = A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX\\") or a drive letter
///                           (for example, "X:\\"). The string must end with a trailing backslash ('\\').
///    lpszVolumeName = A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form
///                     "\\\\?\Volume{<i>GUID</i>}\\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more
///                     than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.
///    cchBufferLength = The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest
///                      possible volume <b>GUID</b> path is 50 characters.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetVolumeNameForVolumeMountPointW(const(wchar)* lpszVolumeMountPoint, const(wchar)* lpszVolumeName, 
                                       uint cchBufferLength);

///Retrieves a list of drive letters and mounted folder paths for the specified volume.
///Params:
///    lpszVolumeName = A volume <b>GUID</b> path for the volume. A volume <b>GUID</b> path is of the form
///                     "\\\\?\\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}\\".
///    lpszVolumePathNames = A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an array of
///                          null-terminated strings terminated by an additional <b>NULL</b> character. If the buffer is not large enough to
///                          hold the complete list, the buffer holds as much of the list as possible.
///    cchBufferLength = The length of the <i>lpszVolumePathNames</i> buffer, in <b>TCHARs</b>, including all <b>NULL</b> characters.
///    lpcchReturnLength = If the call is successful, this parameter is the number of <b>TCHARs</b> copied to the <i>lpszVolumePathNames</i>
///                        buffer. Otherwise, this parameter is the size of the buffer required to hold the complete list, in <b>TCHARs</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the buffer is not large enough to hold the complete list, the
///    error code is <b>ERROR_MORE_DATA</b> and the <i>lpcchReturnLength</i> parameter receives the required buffer
///    size.
///    
@DllImport("KERNEL32")
BOOL GetVolumePathNamesForVolumeNameW(const(wchar)* lpszVolumeName, const(wchar)* lpszVolumePathNames, 
                                      uint cchBufferLength, uint* lpcchReturnLength);

///Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream,
///directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The
///function returns a handle that can be used to access the file or device for various types of I/O depending on the
///file or device and the flags and attributes specified. When called from a Windows Store app, <b>CreateFile2</b> is
///simplified. You can open only files or directories inside the ApplicationData.LocalFolder or
///Package.InstalledLocation directories. You can't open named pipes or mailslots or create encrypted files
///(<b>FILE_ATTRIBUTE_ENCRYPTED</b>). <div class="alert"><b>Note</b> We refer here to the app's local folder and the
///package's installed location, not additional packages in the package graph, like resource packages.
///<b>CreateFile2</b> doesn't support opening files in additional packages in the package graph. For example, suppose an
///app has a dependency on WinJS. The app can call <b>CreateFile2</b> to open a file in its package but not in the
///<b>WinJS</b> package.</div><div> </div>To perform this operation as a transacted operation, which results in a handle
///that can be used for transacted I/O, use the CreateFileTransacted function.
///Params:
///    lpFileName = The name of the file or device to be created or opened. For information on special device names, see Defining an
///                 MS-DOS Device Name. To create a file stream, specify the name of the file, a colon, and then the name of the
///                 stream. For more information, see File Streams. <div class="alert"><b>Tip</b> Starting with Windows 10, version
///                 1607, you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path
///                 Length Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    dwDesiredAccess = The requested access to the file or device, which can be summarized as read, write, both or neither zero). The
///                      most commonly used values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both (<code>GENERIC_READ |
///                      GENERIC_WRITE</code>). For more information, see Generic Access Rights, File Security and Access Rights, File
///                      Access Rights Constants, and ACCESS_MASK. If this parameter is zero, the application can query certain metadata
///                      such as file, directory, or device attributes without accessing that file or device, even if <b>GENERIC_READ</b>
///                      access would have been denied. You cannot request an access mode that conflicts with the sharing mode that is
///                      specified by the <i>dwShareMode</i> parameter in an open request that already has an open handle. For more
///                      information, see the Remarks section of this topic and Creating and Opening Files.
///    dwShareMode = The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none
///                  (refer to the following table). Access requests to attributes or extended attributes are not affected by this
///                  flag. If this parameter is zero and <b>CreateFile2</b> succeeds, the file or device cannot be shared and cannot
///                  be opened again until the handle to the file or device is closed. For more information, see the Remarks section.
///                  You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request
///                  that has an open handle. <b>CreateFile2</b> would fail and the GetLastError function would return
///                  <b>ERROR_SHARING_VIOLATION</b>. To enable a process to share a file or device while another process has the file
///                  or device open, use a compatible combination of one or more of the following values. For more information about
///                  valid combinations of this parameter with the <i>dwDesiredAccess</i> parameter, see Creating and Opening Files.
///                  <div class="alert"><b>Note</b> The sharing options for each open handle remain in effect until that handle is
///                  closed, regardless of process context.</div> <div> </div> <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                  <td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> Prevents
///                  other processes from opening a file or device if they request delete, read, or write access. Exclusive access to
///                  a file or directory is only granted if the application has write access to the file. </td> </tr> <tr> <td
///                  width="40%"><a id="FILE_SHARE_DELETE"></a><a id="file_share_delete"></a><dl> <dt><b>FILE_SHARE_DELETE</b></dt>
///                  <dt>0x00000004</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on a file or device to
///                  request delete access. Otherwise, other processes cannot open the file or device if they request delete access.
///                  If this flag is not specified, but the file or device has been opened for delete access, the function fails. <div
///                  class="alert"><b>Note</b> Delete access allows both delete and rename operations.</div> <div> </div> </td> </tr>
///                  <tr> <td width="40%"><a id="FILE_SHARE_READ"></a><a id="file_share_read"></a><dl> <dt><b>FILE_SHARE_READ</b></dt>
///                  <dt>0x00000001</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on a file or device to
///                  request read access. Otherwise, other processes cannot open the file or device if they request read access. If
///                  this flag is not specified, but the file or device has been opened for read access, the function fails. If a file
///                  or directory is being opened and this flag is not specified, and the caller does not have write access to the
///                  file or directory, the function fails. </td> </tr> <tr> <td width="40%"><a id="FILE_SHARE_WRITE"></a><a
///                  id="file_share_write"></a><dl> <dt><b>FILE_SHARE_WRITE</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%">
///                  Enables subsequent open operations on a file or device to request write access. Otherwise, other processes cannot
///                  open the file or device if they request write access. If this flag is not specified, but the file or device has
///                  been opened for write access or has a file mapping with write access, the function fails. </td> </tr> </table>
///    dwCreationDisposition = An action to take on a file or device that exists or does not exist. For devices other than files, this parameter
///                            is usually set to <b>OPEN_EXISTING</b>. For more information, see the Remarks section. This parameter must be one
///                            of the following values, which cannot be combined: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                            width="40%"><a id="CREATE_ALWAYS"></a><a id="create_always"></a><dl> <dt><b>CREATE_ALWAYS</b></dt> <dt>2</dt>
///                            </dl> </td> <td width="60%"> Creates a new file, always. If the specified file exists and is writable, the
///                            function overwrites the file, the function succeeds, and last-error code is set to <b>ERROR_ALREADY_EXISTS</b>
///                            (183). If the specified file does not exist and is a valid path, a new file is created, the function succeeds,
///                            and the last-error code is set to zero. For more information, see the Remarks section of this topic. </td> </tr>
///                            <tr> <td width="40%"><a id="CREATE_NEW"></a><a id="create_new"></a><dl> <dt><b>CREATE_NEW</b></dt> <dt>1</dt>
///                            </dl> </td> <td width="60%"> Creates a new file, only if it does not already exist. If the specified file exists,
///                            the function fails and the last-error code is set to <b>ERROR_FILE_EXISTS</b> (80). If the specified file does
///                            not exist and is a valid path to a writable location, a new file is created. </td> </tr> <tr> <td width="40%"><a
///                            id="OPEN_ALWAYS"></a><a id="open_always"></a><dl> <dt><b>OPEN_ALWAYS</b></dt> <dt>4</dt> </dl> </td> <td
///                            width="60%"> Opens a file, always. If the specified file exists, the function succeeds and the last-error code is
///                            set to <b>ERROR_ALREADY_EXISTS</b> (183). If the specified file does not exist and is a valid path to a writable
///                            location, the function creates a file and the last-error code is set to zero. </td> </tr> <tr> <td width="40%"><a
///                            id="OPEN_EXISTING"></a><a id="open_existing"></a><dl> <dt><b>OPEN_EXISTING</b></dt> <dt>3</dt> </dl> </td> <td
///                            width="60%"> Opens a file or device, only if it exists. If the specified file or device does not exist, the
///                            function fails and the last-error code is set to <b>ERROR_FILE_NOT_FOUND</b> (2). For more information about
///                            devices, see the Remarks section. </td> </tr> <tr> <td width="40%"><a id="TRUNCATE_EXISTING"></a><a
///                            id="truncate_existing"></a><dl> <dt><b>TRUNCATE_EXISTING</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Opens a
///                            file and truncates it so that its size is zero bytes, only if it exists. If the specified file does not exist,
///                            the function fails and the last-error code is set to <b>ERROR_FILE_NOT_FOUND</b> (2). The calling process must
///                            open the file with the <b>GENERIC_WRITE</b> bit set as part of the <i>dwDesiredAccess</i> parameter. </td> </tr>
///                            </table>
///    pCreateExParams = Pointer to an optional CREATEFILE2_EXTENDED_PARAMETERS structure.
///Returns:
///    If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail
///    slot. If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information,
///    call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateFile2(const(wchar)* lpFileName, FILE_ACCESS_FLAGS dwDesiredAccess, FILE_SHARE_FLAGS dwShareMode, 
                   FILE_CREATE_FLAGS dwCreationDisposition, CREATEFILE2_EXTENDED_PARAMETERS* pCreateExParams);

///Associates a virtual address range with the specified file handle. This indicates that the kernel should optimize any
///further asynchronous I/O requests with overlapped structures inside this range. The overlapped range is locked in
///memory, and then unlocked when the file is closed. After a range is associated with a file handle, it cannot be
///disassociated.
///Params:
///    FileHandle = A handle to the file. This file handle must be opened with <b>FILE_READ_ATTRIBUTES</b> access rights.
///    OverlappedRangeStart = The starting address for the range.
///    Length = The length of the range, in bytes.
///Returns:
///    Returns nonzero if successful or zero otherwise. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetFileIoOverlappedRange(HANDLE FileHandle, ubyte* OverlappedRangeStart, uint Length);

///Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a
///volume that supports compression and the file is compressed, the value obtained is the compressed size of the
///specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the
///value obtained is the sparse size of the specified file. To perform this operation as a transacted operation, use the
///GetCompressedFileSizeTransacted function.
///Params:
///    lpFileName = The name of the file. Do not specify the name of a file on a nonseeking device, such as a pipe or a
///                 communications device, as its file size has no meaning. This parameter may include the path. In the ANSI version
///                 of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide
///                 characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see
///                 Naming a File. <div class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode version of
///                 this function (<b>GetCompressedFileSizeW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without
///                 prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for
///                 details.</div> <div> </div>
///    lpFileSizeHigh = The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order
///                     <b>DWORD</b> of the compressed file size. This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the
///                     compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.
///Returns:
///    If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk
///    storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the
///    high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the
///    compressed file size for compressed files, the actual file size for noncompressed files. If the function fails,
///    and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error
///    information, call GetLastError. If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is
///    non-<b>NULL</b>, an application must call GetLastError to determine whether the function has succeeded (value is
///    <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).
///    
@DllImport("KERNEL32")
uint GetCompressedFileSizeA(const(char)* lpFileName, uint* lpFileSizeHigh);

///Retrieves the actual number of bytes of disk storage used to store a specified file. If the file is located on a
///volume that supports compression and the file is compressed, the value obtained is the compressed size of the
///specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the
///value obtained is the sparse size of the specified file. To perform this operation as a transacted operation, use the
///GetCompressedFileSizeTransacted function.
///Params:
///    lpFileName = The name of the file. Do not specify the name of a file on a nonseeking device, such as a pipe or a
///                 communications device, as its file size has no meaning. This parameter may include the path. In the ANSI version
///                 of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide
///                 characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see
///                 Naming a File. <div class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode version of
///                 this function (<b>GetCompressedFileSizeW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without
///                 prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for
///                 details.</div> <div> </div>
///    lpFileSizeHigh = The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order
///                     <b>DWORD</b> of the compressed file size. This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the
///                     compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.
///Returns:
///    If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk
///    storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the
///    high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the
///    compressed file size for compressed files, the actual file size for noncompressed files. If the function fails,
///    and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error
///    information, call GetLastError. If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is
///    non-<b>NULL</b>, an application must call GetLastError to determine whether the function has succeeded (value is
///    <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).
///    
@DllImport("KERNEL32")
uint GetCompressedFileSizeW(const(wchar)* lpFileName, uint* lpFileSizeHigh);

///Enumerates the first stream with a ::$DATA stream type in the specified file or directory. To perform this operation
///as a transacted operation, use the FindFirstStreamTransactedW function.
///Params:
///    lpFileName = The fully qualified file name.
///    InfoLevel = The information level of the returned data. This parameter is one of the values in the STREAM_INFO_LEVELS
///                enumeration type. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="FindStreamInfoStandard"></a><a id="findstreaminfostandard"></a><a id="FINDSTREAMINFOSTANDARD"></a><dl>
///                <dt><b>FindStreamInfoStandard</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> The data is returned in a
///                WIN32_FIND_STREAM_DATA structure. </td> </tr> </table>
///    lpFindStreamData = A pointer to a buffer that receives the file stream data. The format of this data depends on the value of the
///                       <i>InfoLevel</i> parameter.
///    dwFlags = Reserved for future use. This parameter must be zero.
///Returns:
///    If the function succeeds, the return value is a search handle that can be used in subsequent calls to the
///    FindNextStreamW function. If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended
///    error information, call GetLastError. If no streams can be found, the function fails and GetLastError returns
///    <b>ERROR_HANDLE_EOF</b> (38). If the filesystem does not support streams, the function fails and GetLastError
///    returns <b>ERROR_INVALID_PARAMETER</b> (87).
///    
@DllImport("KERNEL32")
FindStreamHandle FindFirstStreamW(const(wchar)* lpFileName, STREAM_INFO_LEVELS InfoLevel, char* lpFindStreamData, 
                                  uint dwFlags);

///Continues a stream search started by a previous call to the FindFirstStreamW function.
///Params:
///    hFindStream = The search handle returned by a previous call to the FindFirstStreamW function.
///    lpFindStreamData = A pointer to the WIN32_FIND_STREAM_DATA structure that receives information about the stream.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If no more streams can be found, <b>GetLastError</b> returns
///    <b>ERROR_HANDLE_EOF</b> (38).
///    
@DllImport("KERNEL32")
BOOL FindNextStreamW(FindStreamHandle hFindStream, char* lpFindStreamData);

///Determines whether the file I/O functions are using the ANSI or OEM character set code page. This function is useful
///for 8-bit console input and output operations.
///Returns:
///    If the set of file I/O functions is using the ANSI code page, the return value is nonzero. If the set of file I/O
///    functions is using the OEM code page, the return value is zero.
///    
@DllImport("KERNEL32")
BOOL AreFileApisANSI();

///Retrieves the path of the directory designated for temporary files.
///Params:
///    nBufferLength = The size of the string buffer identified by <i>lpBuffer</i>, in <b>TCHARs</b>.
///    lpBuffer = A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. The
///               returned string ends with a backslash, for example, "C:\\TEMP\\".
///Returns:
///    If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to
///    <i>lpBuffer</i>, not including the terminating null character. If the return value is greater than
///    <i>nBufferLength</i>, the return value is the length, in <b>TCHARs</b>, of the buffer required to hold the path.
///    If the function fails, the return value is zero. To get extended error information, call GetLastError. The
///    maximum possible return value is <b>MAX_PATH</b>+1 (261).
///    
@DllImport("KERNEL32")
uint GetTempPathA(uint nBufferLength, const(char)* lpBuffer);

///Creates an enumeration of all the hard links to the specified file. The <b>FindFirstFileNameW</b> function returns a
///handle to the enumeration that can be used on subsequent calls to the FindNextFileNameW function. To perform this
///operation as a transacted operation, use the FindFirstFileNameTransactedW function.
///Params:
///    lpFileName = The name of the file. <div class="alert"><b>Tip</b> Starting with Windows 10, version 1607, you can opt-in to
///                 remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section
///                 of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    dwFlags = Reserved; specify zero (0).
///    StringLength = The size of the buffer pointed to by the <i>LinkName</i> parameter, in characters. If this call fails and the
///                   error returned from the GetLastError function is <b>ERROR_MORE_DATA</b> (234), the value that is returned by this
///                   parameter is the size that the buffer pointed to by <i>LinkName</i> must be to contain all the data.
///    LinkName = A pointer to a buffer to store the first link name found for <i>lpFileName</i>.
///Returns:
///    If the function succeeds, the return value is a search handle that can be used with the FindNextFileNameW
///    function or closed with the FindClose function. If the function fails, the return value is
///    <b>INVALID_HANDLE_VALUE</b> (0xffffffff). To get extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
FindFileNameHandle FindFirstFileNameW(const(wchar)* lpFileName, uint dwFlags, uint* StringLength, 
                                      const(wchar)* LinkName);

///Continues enumerating the hard links to a file using the handle returned by a successful call to the
///FindFirstFileNameW function.
///Params:
///    hFindStream = A handle to the enumeration that is returned by a successful call to FindFirstFileNameW.
///    StringLength = The size of the <i>LinkName</i> parameter, in characters. If this call fails and the error is
///                   <b>ERROR_MORE_DATA</b>, the value that is returned by this parameter is the size that <i>LinkName</i> must be to
///                   contain all the data.
///    LinkName = A pointer to a buffer to store the first link name found for <i>lpFileName</i>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. If no matching files can be found, the GetLastError function
///    returns <b>ERROR_HANDLE_EOF</b>.
///    
@DllImport("KERNEL32")
BOOL FindNextFileNameW(FindFileNameHandle hFindStream, uint* StringLength, const(wchar)* LinkName);

///Retrieves information about the file system and volume associated with the specified root directory. To specify a
///handle when retrieving this information, use the GetVolumeInformationByHandleW function. To retrieve the current
///compression state of a file or directory, use FSCTL_GET_COMPRESSION.
///Params:
///    lpRootPathName = A pointer to a string that contains the root directory of the volume to be described. If this parameter is
///                     <b>NULL</b>, the root of the current directory is used. A trailing backslash is required. For example, you
///                     specify \\\\MyServer\\MyShare as "\\\\MyServer\\MyShare\\", or the C drive as "C:\\".
///    lpVolumeNameBuffer = A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the
///                         <i>nVolumeNameSize</i> parameter.
///    nVolumeNameSize = The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is <b>MAX_PATH</b>+1. This
///                      parameter is ignored if the volume name buffer is not supplied.
///    lpVolumeSerialNumber = A pointer to a variable that receives the volume serial number. This parameter can be <b>NULL</b> if the serial
///                           number is not required. This function returns the volume serial number that the operating system assigns when a
///                           hard disk is formatted. To programmatically obtain the hard disk's serial number that the manufacturer assigns,
///                           use the Windows Management Instrumentation (WMI) Win32_PhysicalMedia property <b>SerialNumber</b>.
///    lpMaximumComponentLength = A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file name component that a
///                               specified file system supports. A file name component is the portion of a file name between backslashes. The
///                               value that is stored in the variable that *<i>lpMaximumComponentLength</i> points to is used to indicate that a
///                               specified file system supports long names. For example, for a FAT file system that supports long names, the
///                               function stores the value 255, rather than the previous 8.3 indicator. Long names can also be supported on
///                               systems that use the NTFS file system.
///    lpFileSystemFlags = A pointer to a variable that receives flags associated with the specified file system. This parameter can be one
///                        or more of the following flags. However, <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are
///                        mutually exclusive. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                        id="FILE_CASE_PRESERVED_NAMES"></a><a id="file_case_preserved_names"></a><dl>
///                        <dt><b>FILE_CASE_PRESERVED_NAMES</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports preserved case of file names when it places a name on disk. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_CASE_SENSITIVE_SEARCH"></a><a id="file_case_sensitive_search"></a><dl>
///                        <dt><b>FILE_CASE_SENSITIVE_SEARCH</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports case-sensitive file names. </td> </tr> <tr> <td width="40%"><a id="FILE_DAX_VOLUME________"></a><a
///                        id="file_dax_volume________"></a><dl> <dt><b>FILE_DAX_VOLUME </b></dt> <dt>0x20000000</dt> </dl> </td> <td
///                        width="60%"> The specified volume is a direct access (DAX) volume. <div class="alert"><b>Note</b> This flag was
///                        introduced in Windows 10, version 1607.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_FILE_COMPRESSION"></a><a id="file_file_compression"></a><dl> <dt><b>FILE_FILE_COMPRESSION</b></dt>
///                        <dt>0x00000010</dt> </dl> </td> <td width="60%"> The specified volume supports file-based compression. </td>
///                        </tr> <tr> <td width="40%"><a id="FILE_NAMED_STREAMS"></a><a id="file_named_streams"></a><dl>
///                        <dt><b>FILE_NAMED_STREAMS</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The specified volume supports
///                        named streams. </td> </tr> <tr> <td width="40%"><a id="FILE_PERSISTENT_ACLS"></a><a
///                        id="file_persistent_acls"></a><dl> <dt><b>FILE_PERSISTENT_ACLS</b></dt> <dt>0x00000008</dt> </dl> </td> <td
///                        width="60%"> The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file
///                        system preserves and enforces ACLs, and the FAT file system does not. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_READ_ONLY_VOLUME"></a><a id="file_read_only_volume"></a><dl> <dt><b>FILE_READ_ONLY_VOLUME</b></dt>
///                        <dt>0x00080000</dt> </dl> </td> <td width="60%"> The specified volume is read-only. </td> </tr> <tr> <td
///                        width="40%"><a id="FILE_SEQUENTIAL_WRITE_ONCE"></a><a id="file_sequential_write_once"></a><dl>
///                        <dt><b>FILE_SEQUENTIAL_WRITE_ONCE</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports a single sequential write. </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_ENCRYPTION"></a><a
///                        id="file_supports_encryption"></a><dl> <dt><b>FILE_SUPPORTS_ENCRYPTION</b></dt> <dt>0x00020000</dt> </dl> </td>
///                        <td width="60%"> The specified volume supports the Encrypted File System (EFS). For more information, see File
///                        Encryption. </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_EXTENDED_ATTRIBUTES"></a><a
///                        id="file_supports_extended_attributes"></a><dl> <dt><b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b></dt>
///                        <dt>0x00800000</dt> </dl> </td> <td width="60%"> The specified volume supports extended attributes. An extended
///                        attribute is a piece of application-specific metadata that an application can associate with a file and is not
///                        part of the file's data. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This
///                        value is not supported until Windows Server 2008 R2 and Windows 7. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_SUPPORTS_HARD_LINKS"></a><a id="file_supports_hard_links"></a><dl>
///                        <dt><b>FILE_SUPPORTS_HARD_LINKS</b></dt> <dt>0x00400000</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports hard links. For more information, see Hard Links and Junctions. <b>Windows Server 2008, Windows Vista,
///                        Windows Server 2003 and Windows XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
///                        </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_OBJECT_IDS"></a><a id="file_supports_object_ids"></a><dl>
///                        <dt><b>FILE_SUPPORTS_OBJECT_IDS</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports object identifiers. </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_OPEN_BY_FILE_ID"></a><a
///                        id="file_supports_open_by_file_id"></a><dl> <dt><b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b></dt> <dt>0x01000000</dt>
///                        </dl> </td> <td width="60%"> The file system supports open by FileID. For more information, see
///                        FILE_ID_BOTH_DIR_INFO. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value
///                        is not supported until Windows Server 2008 R2 and Windows 7. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_SUPPORTS_REPARSE_POINTS"></a><a id="file_supports_reparse_points"></a><dl>
///                        <dt><b>FILE_SUPPORTS_REPARSE_POINTS</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> The specified
///                        volume supports reparse points. <b>ReFS: </b>ReFS supports reparse points but does not index them so
///                        FindFirstVolumeMountPoint and FindNextVolumeMountPoint will not function as expected. </td> </tr> <tr> <td
///                        width="40%"><a id="FILE_SUPPORTS_SPARSE_FILES"></a><a id="file_supports_sparse_files"></a><dl>
///                        <dt><b>FILE_SUPPORTS_SPARSE_FILES</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports sparse files. </td> </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_TRANSACTIONS"></a><a
///                        id="file_supports_transactions"></a><dl> <dt><b>FILE_SUPPORTS_TRANSACTIONS</b></dt> <dt>0x00200000</dt> </dl>
///                        </td> <td width="60%"> The specified volume supports transactions. For more information, see About KTM. </td>
///                        </tr> <tr> <td width="40%"><a id="FILE_SUPPORTS_USN_JOURNAL"></a><a id="file_supports_usn_journal"></a><dl>
///                        <dt><b>FILE_SUPPORTS_USN_JOURNAL</b></dt> <dt>0x02000000</dt> </dl> </td> <td width="60%"> The specified volume
///                        supports update sequence number (USN) journals. For more information, see Change Journal Records. <b>Windows
///                        Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported until Windows
///                        Server 2008 R2 and Windows 7. </td> </tr> <tr> <td width="40%"><a id="FILE_UNICODE_ON_DISK"></a><a
///                        id="file_unicode_on_disk"></a><dl> <dt><b>FILE_UNICODE_ON_DISK</b></dt> <dt>0x00000004</dt> </dl> </td> <td
///                        width="60%"> The specified volume supports Unicode in file names as they appear on disk. </td> </tr> <tr> <td
///                        width="40%"><a id="FILE_VOLUME_IS_COMPRESSED"></a><a id="file_volume_is_compressed"></a><dl>
///                        <dt><b>FILE_VOLUME_IS_COMPRESSED</b></dt> <dt>0x00008000</dt> </dl> </td> <td width="60%"> The specified volume
///                        is a compressed volume, for example, a DoubleSpace volume. </td> </tr> <tr> <td width="40%"><a
///                        id="FILE_VOLUME_QUOTAS"></a><a id="file_volume_quotas"></a><dl> <dt><b>FILE_VOLUME_QUOTAS</b></dt>
///                        <dt>0x00000020</dt> </dl> </td> <td width="60%"> The specified volume supports disk quotas. </td> </tr> <tr> <td
///                        width="40%"><a id="FILE_SUPPORTS_BLOCK_REFCOUNTING"></a><a id="file_supports_block_refcounting"></a><dl>
///                        <dt><b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b></dt> <dt>0x08000000</dt> </dl> </td> <td width="60%"> The specified
///                        volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes
///                        to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation. </td> </tr> </table>
///    lpFileSystemNameBuffer = A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS
///                             file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.
///    nFileSystemNameSize = The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is <b>MAX_PATH</b>+1. This
///                          parameter is ignored if the file system name buffer is not supplied.
///Returns:
///    If all the requested information is retrieved, the return value is nonzero. If not all the requested information
///    is retrieved, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetVolumeInformationA(const(char)* lpRootPathName, const(char)* lpVolumeNameBuffer, uint nVolumeNameSize, 
                           uint* lpVolumeSerialNumber, uint* lpMaximumComponentLength, uint* lpFileSystemFlags, 
                           const(char)* lpFileSystemNameBuffer, uint nFileSystemNameSize);

///Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to
///it is released; otherwise, only a file name is generated.
///Params:
///    lpPathName = The directory path for the file name. Applications typically specify a period (.) for the current directory or
///                 the result of the GetTempPath function. The string cannot be longer than <b>MAX_PATH</b>–14 characters or
///                 <b>GetTempFileName</b> will fail. If this parameter is <b>NULL</b>, the function fails.
///    lpPrefixString = The null-terminated prefix string. The function uses up to the first three characters of this string as the
///                     prefix of the file name. This string must consist of characters in the OEM-defined character set.
///    uUnique = An unsigned integer to be used in creating the temporary file name. For more information, see Remarks. If
///              <i>uUnique</i> is zero, the function attempts to form a unique file name using the current system time. If the
///              file already exists, the number is increased by one and the functions tests if this file already exists. This
///              continues until a unique filename is found; the function creates a file by that name and closes it. Note that the
///              function does not attempt to verify the uniqueness of the file name when <i>uUnique</i> is nonzero.
///    lpTempFileName = A pointer to the buffer that receives the temporary file name. This buffer should be <b>MAX_PATH</b> characters
///                     to accommodate the path plus the terminating null character.
///Returns:
///    If the function succeeds, the return value specifies the unique numeric value used in the temporary file name. If
///    the <i>uUnique</i> parameter is nonzero, the return value specifies that same number. If the function fails, the
///    return value is zero. To get extended error information, call GetLastError. The following is a possible return
///    value. <table> <tr> <th>Return value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BUFFER_OVERFLOW</b></dt> </dl> </td> <td width="60%"> The length of the string pointed to by the
///    <i>lpPathName</i> parameter is more than <b>MAX_PATH</b>–14 characters. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint GetTempFileNameA(const(char)* lpPathName, const(char)* lpPrefixString, uint uUnique, 
                      const(char)* lpTempFileName);

///Causes the file I/O functions for the process to use the OEM character set code page. This function is useful for
///8-bit console input and output operations.
@DllImport("KERNEL32")
void SetFileApisToOEM();

///Causes the file I/O functions to use the ANSI character set code page for the current process. This function is
///useful for 8-bit console input and output operations.
@DllImport("KERNEL32")
void SetFileApisToANSI();

@DllImport("api-ms-win-core-file-fromapp-l1-1-0")
BOOL CopyFileFromAppW(const(wchar)* lpExistingFileName, const(wchar)* lpNewFileName, BOOL bFailIfExists);

@DllImport("api-ms-win-core-file-fromapp-l1-1-0")
BOOL CreateDirectoryFromAppW(const(wchar)* lpPathName, SECURITY_ATTRIBUTES* lpSecurityAttributes);

@DllImport("api-ms-win-core-file-fromapp-l1-1-0")
HANDLE CreateFileFromAppW(const(wchar)* lpFileName, uint dwDesiredAccess, uint dwShareMode, 
                          SECURITY_ATTRIBUTES* lpSecurityAttributes, uint dwCreationDisposition, 
                          uint dwFlagsAndAttributes, HANDLE hTemplateFile);

@DllImport("api-ms-win-core-file-fromapp-l1-1-0")
HANDLE CreateFile2FromAppW(const(wchar)* lpFileName, uint dwDesiredAccess, uint dwShareMode, 
                           uint dwCreationDisposition, CREATEFILE2_EXTENDED_PARAMETERS* pCreateExParams);

@DllImport("api-ms-win-core-file-fromapp-l1-1-0")
BOOL DeleteFileFromAppW(const(wchar)* lpFileName);

@DllImport("api-ms-win-core-file-fromapp-l1-1-0")
HANDLE FindFirstFileExFromAppW(const(wchar)* lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, char* lpFindFileData, 
                               FINDEX_SEARCH_OPS fSearchOp, void* lpSearchFilter, uint dwAdditionalFlags);

@DllImport("api-ms-win-core-file-fromapp-l1-1-0")
BOOL GetFileAttributesExFromAppW(const(wchar)* lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, 
                                 char* lpFileInformation);

@DllImport("api-ms-win-core-file-fromapp-l1-1-0")
BOOL MoveFileFromAppW(const(wchar)* lpExistingFileName, const(wchar)* lpNewFileName);

@DllImport("api-ms-win-core-file-fromapp-l1-1-0")
BOOL RemoveDirectoryFromAppW(const(wchar)* lpPathName);

@DllImport("api-ms-win-core-file-fromapp-l1-1-0")
BOOL ReplaceFileFromAppW(const(wchar)* lpReplacedFileName, const(wchar)* lpReplacementFileName, 
                         const(wchar)* lpBackupFileName, uint dwReplaceFlags, void* lpExclude, void* lpReserved);

@DllImport("api-ms-win-core-file-fromapp-l1-1-0")
BOOL SetFileAttributesFromAppW(const(wchar)* lpFileName, uint dwFileAttributes);

///Creates an input/output (I/O) completion port and associates it with a specified file handle, or creates an I/O
///completion port that is not yet associated with a file handle, allowing association at a later time. Associating an
///instance of an opened file handle with an I/O completion port allows a process to receive notification of the
///completion of asynchronous I/O operations involving that file handle. <div class="alert"><b>Note</b> <p
///class="note">The term <i>file handle</i> as used here refers to a system abstraction that represents an overlapped
///I/O endpoint, not only a file on disk. Any system objects that support overlapped I/O—such as network endpoints,
///TCP sockets, named pipes, and mail slots—can be used as file handles. For additional information, see the Remarks
///section. </div><div> </div>
///Params:
///    FileHandle = An open file handle or <b>INVALID_HANDLE_VALUE</b>. The handle must be to an object that supports overlapped I/O.
///                 If a handle is provided, it has to have been opened for overlapped I/O completion. For example, you must specify
///                 the <b>FILE_FLAG_OVERLAPPED</b> flag when using the CreateFile function to obtain the handle. If
///                 <b>INVALID_HANDLE_VALUE</b> is specified, the function creates an I/O completion port without associating it with
///                 a file handle. In this case, the <i>ExistingCompletionPort</i> parameter must be <b>NULL</b> and the
///                 <i>CompletionKey</i> parameter is ignored.
///    ExistingCompletionPort = A handle to an existing I/O completion port or <b>NULL</b>. If this parameter specifies an existing I/O
///                             completion port, the function associates it with the handle specified by the <i>FileHandle</i> parameter. The
///                             function returns the handle of the existing I/O completion port if successful; it does not create a new I/O
///                             completion port. If this parameter is <b>NULL</b>, the function creates a new I/O completion port and, if the
///                             <i>FileHandle</i> parameter is valid, associates it with the new I/O completion port. Otherwise no file handle
///                             association occurs. The function returns the handle to the new I/O completion port if successful.
///    CompletionKey = The per-handle user-defined completion key that is included in every I/O completion packet for the specified file
///                    handle. For more information, see the Remarks section.
///    NumberOfConcurrentThreads = The maximum number of threads that the operating system can allow to concurrently process I/O completion packets
///                                for the I/O completion port. This parameter is ignored if the <i>ExistingCompletionPort</i> parameter is not
///                                <b>NULL</b>. If this parameter is zero, the system allows as many concurrently running threads as there are
///                                processors in the system.
///Returns:
///    If the function succeeds, the return value is the handle to an I/O completion port: <ul> <li> If the
///    <i>ExistingCompletionPort</i> parameter was <b>NULL</b>, the return value is a new handle. </li> <li> If the
///    <i>ExistingCompletionPort</i> parameter was a valid I/O completion port handle, the return value is that same
///    handle. </li> <li> If the <i>FileHandle</i> parameter was a valid handle, that file handle is now associated with
///    the returned I/O completion port. </li> </ul> If the function fails, the return value is <b>NULL</b>. To get
///    extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, size_t CompletionKey, 
                              uint NumberOfConcurrentThreads);

///Attempts to dequeue an I/O completion packet from the specified I/O completion port. If there is no completion packet
///queued, the function waits for a pending I/O operation associated with the completion port to complete. To dequeue
///multiple I/O completion packets at once, use the GetQueuedCompletionStatusEx function.
///Params:
///    CompletionPort = A handle to the completion port. To create a completion port, use the CreateIoCompletionPort function.
///    lpNumberOfBytesTransferred = A pointer to a variable that receives the number of bytes transferred in a completed I/O operation.
///    lpCompletionKey = A pointer to a variable that receives the completion key value associated with the file handle whose I/O
///                      operation has completed. A completion key is a per-file key that is specified in a call to
///                      CreateIoCompletionPort.
///    lpOverlapped = A pointer to a variable that receives the address of the OVERLAPPED structure that was specified when the
///                   completed I/O operation was started. Even if you have passed the function a file handle associated with a
///                   completion port and a valid OVERLAPPED structure, an application can prevent completion port notification. This
///                   is done by specifying a valid event handle for the <b>hEvent</b> member of the <b>OVERLAPPED</b> structure, and
///                   setting its low-order bit. A valid event handle whose low-order bit is set keeps I/O completion from being queued
///                   to the completion port.
///    dwMilliseconds = The number of milliseconds that the caller is willing to wait for a completion packet to appear at the completion
///                     port. If a completion packet does not appear within the specified time, the function times out, returns
///                     <b>FALSE</b>, and sets *<i>lpOverlapped</i> to <b>NULL</b>. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the
///                     function will never time out. If <i>dwMilliseconds</i> is zero and there is no I/O operation to dequeue, the
///                     function will time out immediately.
///Returns:
///    Returns nonzero (<b>TRUE</b>) if successful or zero (<b>FALSE</b>) otherwise. To get extended error information,
///    call GetLastError. For more information, see the Remarks section.
///    
@DllImport("KERNEL32")
BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, uint* lpNumberOfBytesTransferred, uint* lpCompletionKey, 
                               OVERLAPPED** lpOverlapped, uint dwMilliseconds);

///Retrieves multiple completion port entries simultaneously. It waits for pending I/O operations that are associated
///with the specified completion port to complete. To dequeue I/O completion packets one at a time, use the
///GetQueuedCompletionStatus function.
///Params:
///    CompletionPort = A handle to the completion port. To create a completion port, use the CreateIoCompletionPort function.
///    lpCompletionPortEntries = On input, points to a pre-allocated array of OVERLAPPED_ENTRY structures. On output, receives an array of
///                              OVERLAPPED_ENTRY structures that hold the entries. The number of array elements is provided by
///                              <i>ulNumEntriesRemoved</i>. The number of bytes transferred during each I/O, the completion key that indicates on
///                              which file each I/O occurred, and the overlapped structure address used in each original I/O are all returned in
///                              the <i>lpCompletionPortEntries</i> array.
///    ulCount = The maximum number of entries to remove.
///    ulNumEntriesRemoved = A pointer to a variable that receives the number of entries actually removed.
///    dwMilliseconds = The number of milliseconds that the caller is willing to wait for a completion packet to appear at the completion
///                     port. If a completion packet does not appear within the specified time, the function times out and returns
///                     <b>FALSE</b>. If <i>dwMilliseconds</i> is <b>INFINITE</b> (0xFFFFFFFF), the function will never time out. If
///                     <i>dwMilliseconds</i> is zero and there is no I/O operation to dequeue, the function will time out immediately.
///    fAlertable = If this parameter is <b>FALSE</b>, the function does not return until the time-out period has elapsed or an entry
///                 is retrieved. If the parameter is <b>TRUE</b> and there are no available entries, the function performs an
///                 alertable wait. The thread returns when the system queues an I/O completion routine or APC to the thread and the
///                 thread executes the function. A completion routine is queued when the ReadFileEx or WriteFileEx function in which
///                 it was specified has completed, and the calling thread is the thread that initiated the operation. An APC is
///                 queued when you call QueueUserAPC.
///Returns:
///    Returns nonzero (<b>TRUE</b>) if successful or zero (<b>FALSE</b>) otherwise. To get extended error information,
///    call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, char* lpCompletionPortEntries, uint ulCount, 
                                 uint* ulNumEntriesRemoved, uint dwMilliseconds, BOOL fAlertable);

///Posts an I/O completion packet to an I/O completion port.
///Params:
///    CompletionPort = A handle to an I/O completion port to which the I/O completion packet is to be posted.
///    dwNumberOfBytesTransferred = The value to be returned through the <i>lpNumberOfBytesTransferred</i> parameter of the GetQueuedCompletionStatus
///                                 function.
///    dwCompletionKey = The value to be returned through the <i>lpCompletionKey</i> parameter of the GetQueuedCompletionStatus function.
///    lpOverlapped = The value to be returned through the <i>lpOverlapped</i> parameter of the GetQueuedCompletionStatus function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError .
///    
@DllImport("KERNEL32")
BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, uint dwNumberOfBytesTransferred, size_t dwCompletionKey, 
                                OVERLAPPED* lpOverlapped);

///Marks any outstanding I/O operations for the specified file handle. The function only cancels I/O operations in the
///current process, regardless of which thread created the I/O operation.
///Params:
///    hFile = A handle to the file.
///    lpOverlapped = A pointer to an OVERLAPPED data structure that contains the data used for asynchronous I/O. If this parameter is
///                   <b>NULL</b>, all I/O requests for the <i>hFile</i> parameter are canceled. If this parameter is not <b>NULL</b>,
///                   only those specific I/O requests that were issued for the file with the specified <i>lpOverlapped</i> overlapped
///                   structure are marked as canceled, meaning that you can cancel one or more requests, while the CancelIo function
///                   cancels all outstanding requests on a file handle.
///Returns:
///    If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued
///    by the calling process for the specified file handle was successfully requested. The application must not free or
///    reuse the OVERLAPPED structure associated with the canceled I/O operations until they have completed. The thread
///    can use the GetOverlappedResult function to determine when the I/O operations themselves have been completed. If
///    the function fails, the return value is 0 (zero). To get extended error information, call the GetLastError
///    function. If this function cannot find a request to cancel, the return value is 0 (zero), and GetLastError
///    returns <b>ERROR_NOT_FOUND</b>.
///    
@DllImport("KERNEL32")
BOOL CancelIoEx(HANDLE hFile, OVERLAPPED* lpOverlapped);

///Cancels all pending input and output (I/O) operations that are issued by the calling thread for the specified file.
///The function does not cancel I/O operations that other threads issue for a file handle. To cancel I/O operations from
///another thread, use the CancelIoEx function.
///Params:
///    hFile = A handle to the file. The function cancels all pending I/O operations for this file handle.
///Returns:
///    If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued
///    by the calling thread for the specified file handle was successfully requested. The thread can use the
///    GetOverlappedResult function to determine when the I/O operations themselves have been completed. If the function
///    fails, the return value is zero (0). To get extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
BOOL CancelIo(HANDLE hFile);

///Marks pending synchronous I/O operations that are issued by the specified thread as canceled.
///Params:
///    hThread = A handle to the thread.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call the GetLastError function. If this function cannot find a request to cancel,
///    the return value is 0 (zero), and GetLastError returns <b>ERROR_NOT_FOUND</b>.
///    
@DllImport("KERNEL32")
BOOL CancelSynchronousIo(HANDLE hThread);

///Disables file system redirection for the calling thread. File system redirection is enabled by default.
///Params:
///    OldValue = The WOW64 file system redirection value. The system uses this parameter to store information necessary to revert
///               (re-enable) file system redirection. <div class="alert"><b>Note</b> This value is for system use only. To avoid
///               unpredictable behavior, do not modify this value in any way.</div> <div> </div>
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL Wow64DisableWow64FsRedirection(void** OldValue);

///Restores file system redirection for the calling thread. This function should not be called without a previous call
///to the Wow64DisableWow64FsRedirectionfunction. Any data allocation on behalf of the Wow64DisableWow64FsRedirection
///function is cleaned up by this function.
///Params:
///    OlValue = TBD
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is
///    <b>FALSE</b> (zero). To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL Wow64RevertWow64FsRedirection(void* OlValue);

@DllImport("api-ms-win-core-wow64-l1-1-1")
ushort Wow64SetThreadDefaultGuestMachine(ushort Machine);

///Suspends the specified WOW64 thread.
///Params:
///    hThread = A handle to the thread that is to be suspended. The handle must have the THREAD_SUSPEND_RESUME access right. For
///              more information, see [Thread Security and Access
///              Rights](/windows/win32/procthread/thread-security-and-access-rights).
///Returns:
///    If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is (DWORD) -1.
///    To get extended error information, use the [GetLastError](../errhandlingapi/nf-errhandlingapi-getlasterror.md)
///    function.
///    
@DllImport("KERNEL32")
uint Wow64SuspendThread(HANDLE hThread);

@DllImport("KERNEL32")
int LZStart();

@DllImport("KERNEL32")
void LZDone();

@DllImport("KERNEL32")
int CopyLZFile(int hfSource, int hfDest);

///Copies a source file to a destination file. If the source file has been compressed by the Lempel-Ziv algorithm, this
///function creates a decompressed destination file. If the source file is not compressed, this function duplicates the
///original file.
///Params:
///    hfSource = A handle to the source file.
///    hfDest = A handle to the destination file.
///Returns:
///    If the function succeeds, the return value specifies the size, in bytes, of the destination file. If the function
///    fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that <b>LZCopy</b>
///    calls neither SetLastError nor SetLastErrorEx; thus, its failure does not affect a thread's last-error code. The
///    following is a list of error codes that <b>LZCopy</b> can return upon failure. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>LZERROR_BADINHANDLE</b></dt> </dl> </td> <td
///    width="60%"> The handle identifying the source file is not valid. The file cannot be read. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>LZERROR_BADOUTHANDLE</b></dt> </dl> </td> <td width="60%"> The handle identifying the
///    destination file is not valid. The file cannot be written. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>LZERROR_GLOBALLOC</b></dt> </dl> </td> <td width="60%"> The maximum number of open compressed files has
///    been exceeded or local memory cannot be allocated. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>LZERROR_GLOBLOCK</b></dt> </dl> </td> <td width="60%"> The LZ file handle cannot be locked down. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>LZERROR_READ</b></dt> </dl> </td> <td width="60%"> The source file format
///    is not valid. </td> </tr> </table> There is no extended error information for this function; do not call
///    GetLastError.
///    
@DllImport("KERNEL32")
int LZCopy(int hfSource, int hfDest);

///Allocates memory for the internal data structures required to decompress files, and then creates and initializes
///them.
///Params:
///    hfSource = A handle to the file.
///Returns:
///    If the function succeeds, the return value is a new LZ file handle. If the function fails, the return value is an
///    LZERROR_* code. These codes have values less than zero. Note that <b>LZInit</b> calls neither SetLastError nor
///    SetLastErrorEx; thus, its failure does not affect a thread's last-error code. The following is the list of the
///    error codes that <b>LZInit</b> can return upon failure. <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>LZERROR_BADINHANDLE</b></dt> </dl> </td> <td width="60%"> The handle
///    identifying the source file is not valid. The file cannot be read. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>LZERROR_GLOBALLOC</b></dt> </dl> </td> <td width="60%"> The maximum number of open compressed files has
///    been exceeded or local memory cannot be allocated. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>LZERROR_GLOBLOCK</b></dt> </dl> </td> <td width="60%"> The LZ file handle cannot be locked down. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>LZERROR_UNKNOWNALG</b></dt> </dl> </td> <td width="60%"> The file is
///    compressed with an unrecognized compression algorithm. </td> </tr> </table> There is no extended error
///    information for this function; do not call GetLastError.
///    
@DllImport("KERNEL32")
int LZInit(int hfSource);

///Retrieves the original name of a compressed file, if the file was compressed by the Lempel-Ziv algorithm.
///Params:
///    lpszSource = The name of the compressed file.
///    lpszBuffer = A pointer to a buffer that receives the original name of the compressed file.
///Returns:
///    If the function succeeds, the return value is 1. If the function fails, the return value is LZERROR_BADVALUE.
///    There is no extended error information for this function; do not call GetLastError. <div
///    class="alert"><b>Note</b> <b>GetExpandedName</b> calls neither SetLastError nor SetLastErrorEx; thus, its failure
///    does not affect a thread's last-error code.</div> <div> </div>
///    
@DllImport("KERNEL32")
int GetExpandedNameA(const(char)* lpszSource, const(char)* lpszBuffer);

///Retrieves the original name of a compressed file, if the file was compressed by the Lempel-Ziv algorithm.
///Params:
///    lpszSource = The name of the compressed file.
///    lpszBuffer = A pointer to a buffer that receives the original name of the compressed file.
///Returns:
///    If the function succeeds, the return value is 1. If the function fails, the return value is LZERROR_BADVALUE.
///    There is no extended error information for this function; do not call GetLastError. <div
///    class="alert"><b>Note</b> <b>GetExpandedName</b> calls neither SetLastError nor SetLastErrorEx; thus, its failure
///    does not affect a thread's last-error code.</div> <div> </div>
///    
@DllImport("KERNEL32")
int GetExpandedNameW(const(wchar)* lpszSource, const(wchar)* lpszBuffer);

///Creates, opens, reopens, or deletes the specified file.
///Params:
///    lpFileName = The name of the file.
///    lpReOpenBuf = A pointer to the OFSTRUCT structure that is to receive information about the file when the file is first opened.
///                  The structure can be used in subsequent calls to the <b>LZOpenFile</b> function to see the open file. The
///                  <b>szPathName</b> member of this structure contains characters from the original equipment manufacturer (OEM)
///                  character set.
///    wStyle = The action to be taken. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="OF_CANCEL"></a><a id="of_cancel"></a><dl>
///             <dt><b>OF_CANCEL</b></dt> <dt>0x0800</dt> </dl> </td> <td width="60%"> Ignored. Provided only for compatibility
///             with 16-bit Windows. Use the <b>OF_PROMPT</b> style to display a dialog box containing a <b>Cancel</b> button.
///             </td> </tr> <tr> <td width="40%"><a id="OF_CREATE"></a><a id="of_create"></a><dl> <dt><b>OF_CREATE</b></dt>
///             <dt>0x1000</dt> </dl> </td> <td width="60%"> Directs <b>LZOpenFile</b> to create a new file. If the file already
///             exists, it is truncated to zero length. </td> </tr> <tr> <td width="40%"><a id="OF_DELETE"></a><a
///             id="of_delete"></a><dl> <dt><b>OF_DELETE</b></dt> <dt>0x0200</dt> </dl> </td> <td width="60%"> Deletes the file.
///             </td> </tr> <tr> <td width="40%"><a id="OF_EXIST"></a><a id="of_exist"></a><dl> <dt><b>OF_EXIST</b></dt>
///             <dt>0x4000</dt> </dl> </td> <td width="60%"> Opens the file and then closes it to test for a file's existence.
///             </td> </tr> <tr> <td width="40%"><a id="OF_PARSE"></a><a id="of_parse"></a><dl> <dt><b>OF_PARSE</b></dt>
///             <dt>0x0100</dt> </dl> </td> <td width="60%"> Fills the OFSTRUCT structure but carries out no other action. </td>
///             </tr> <tr> <td width="40%"><a id="OF_PROMPT"></a><a id="of_prompt"></a><dl> <dt><b>OF_PROMPT</b></dt>
///             <dt>0x2000</dt> </dl> </td> <td width="60%"> Displays a dialog box if the requested file does not exist. The
///             dialog box informs the user that the system cannot find the file, and it contains <b>Retry</b> and <b>Cancel</b>
///             buttons. Clicking the <b>Cancel</b> button directs <b>LZOpenFile</b> to return a file not found error message.
///             </td> </tr> <tr> <td width="40%"><a id="OF_READ"></a><a id="of_read"></a><dl> <dt><b>OF_READ</b></dt>
///             <dt>0x0000</dt> </dl> </td> <td width="60%"> Opens the file for reading only. </td> </tr> <tr> <td width="40%"><a
///             id="OF_READWRITE"></a><a id="of_readwrite"></a><dl> <dt><b>OF_READWRITE</b></dt> <dt>0x0002</dt> </dl> </td> <td
///             width="60%"> Opens the file for reading and writing. </td> </tr> <tr> <td width="40%"><a id="OF_REOPEN"></a><a
///             id="of_reopen"></a><dl> <dt><b>OF_REOPEN</b></dt> <dt>0x8000</dt> </dl> </td> <td width="60%"> Opens the file
///             using information in the reopen buffer. </td> </tr> <tr> <td width="40%"><a id="OF_SHARE_DENY_NONE"></a><a
///             id="of_share_deny_none"></a><dl> <dt><b>OF_SHARE_DENY_NONE</b></dt> <dt>0x0040</dt> </dl> </td> <td width="60%">
///             Opens the file without denying other processes read or write access to the file. <b>LZOpenFile</b> fails if the
///             file has been opened in compatibility mode by any other process. </td> </tr> <tr> <td width="40%"><a
///             id="OF_SHARE_DENY_READ"></a><a id="of_share_deny_read"></a><dl> <dt><b>OF_SHARE_DENY_READ</b></dt>
///             <dt>0x0030</dt> </dl> </td> <td width="60%"> Opens the file and denies other processes read access to the file.
///             <b>LZOpenFile</b> fails if the file has been opened in compatibility mode or has been opened for read access by
///             any other process. </td> </tr> <tr> <td width="40%"><a id="OF_SHARE_DENY_WRITE"></a><a
///             id="of_share_deny_write"></a><dl> <dt><b>OF_SHARE_DENY_WRITE</b></dt> <dt>0x0020</dt> </dl> </td> <td
///             width="60%"> Opens the file and denies other processes write access to the file. <b>LZOpenFile</b> fails if the
///             file has been opened in compatibility mode or has been opened for write access by any other process. </td> </tr>
///             <tr> <td width="40%"><a id="OF_SHARE_EXCLUSIVE"></a><a id="of_share_exclusive"></a><dl>
///             <dt><b>OF_SHARE_EXCLUSIVE</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%"> Opens the file in exclusive mode,
///             denying other processes both read and write access to the file. <b>LZOpenFile</b> fails if the file has been
///             opened in any other mode for read or write access, even by the current process. </td> </tr> <tr> <td
///             width="40%"><a id="OF_WRITE"></a><a id="of_write"></a><dl> <dt><b>OF_WRITE</b></dt> <dt>0x0001</dt> </dl> </td>
///             <td width="60%"> Opens the file for writing only. </td> </tr> </table>
///Returns:
///    If the function succeeds and the value specified by the <i>wStyle</i> parameter is not <b>OF_READ</b>, the return
///    value is a handle identifying the file. If the file is compressed and opened with <i>wStyle</i> set to
///    <b>OF_READ</b>, the return value is a special file handle. If the function fails, the return value is an
///    <b>LZERROR_*</b> code. These codes have values less than zero. There is no extended error information for this
///    function; do not call GetLastError. <div class="alert"><b>Note</b> <b>LZOpenFile</b> calls neither SetLastError
///    nor SetLastErrorEx; thus, its failure does not affect a thread's last-error code.</div> <div> </div> The
///    following is the list of the error codes that <b>LZOpenFile</b> can return upon failure. <table> <tr> <th>Return
///    code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>LZERROR_BADINHANDLE</b></dt>
///    <dt>-1</dt> </dl> </td> <td width="60%"> The handle identifying the source file is not valid. The file cannot be
///    read. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>LZERROR_GLOBALLOC</b></dt> <dt>-5</dt> </dl> </td> <td
///    width="60%"> The maximum number of open compressed files has been exceeded or local memory cannot be allocated.
///    </td> </tr> </table>
///    
@DllImport("KERNEL32")
int LZOpenFileA(const(char)* lpFileName, OFSTRUCT* lpReOpenBuf, ushort wStyle);

///Creates, opens, reopens, or deletes the specified file.
///Params:
///    lpFileName = The name of the file.
///    lpReOpenBuf = A pointer to the OFSTRUCT structure that is to receive information about the file when the file is first opened.
///                  The structure can be used in subsequent calls to the <b>LZOpenFile</b> function to see the open file. The
///                  <b>szPathName</b> member of this structure contains characters from the original equipment manufacturer (OEM)
///                  character set.
///    wStyle = The action to be taken. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="OF_CANCEL"></a><a id="of_cancel"></a><dl>
///             <dt><b>OF_CANCEL</b></dt> <dt>0x0800</dt> </dl> </td> <td width="60%"> Ignored. Provided only for compatibility
///             with 16-bit Windows. Use the <b>OF_PROMPT</b> style to display a dialog box containing a <b>Cancel</b> button.
///             </td> </tr> <tr> <td width="40%"><a id="OF_CREATE"></a><a id="of_create"></a><dl> <dt><b>OF_CREATE</b></dt>
///             <dt>0x1000</dt> </dl> </td> <td width="60%"> Directs <b>LZOpenFile</b> to create a new file. If the file already
///             exists, it is truncated to zero length. </td> </tr> <tr> <td width="40%"><a id="OF_DELETE"></a><a
///             id="of_delete"></a><dl> <dt><b>OF_DELETE</b></dt> <dt>0x0200</dt> </dl> </td> <td width="60%"> Deletes the file.
///             </td> </tr> <tr> <td width="40%"><a id="OF_EXIST"></a><a id="of_exist"></a><dl> <dt><b>OF_EXIST</b></dt>
///             <dt>0x4000</dt> </dl> </td> <td width="60%"> Opens the file and then closes it to test for a file's existence.
///             </td> </tr> <tr> <td width="40%"><a id="OF_PARSE"></a><a id="of_parse"></a><dl> <dt><b>OF_PARSE</b></dt>
///             <dt>0x0100</dt> </dl> </td> <td width="60%"> Fills the OFSTRUCT structure but carries out no other action. </td>
///             </tr> <tr> <td width="40%"><a id="OF_PROMPT"></a><a id="of_prompt"></a><dl> <dt><b>OF_PROMPT</b></dt>
///             <dt>0x2000</dt> </dl> </td> <td width="60%"> Displays a dialog box if the requested file does not exist. The
///             dialog box informs the user that the system cannot find the file, and it contains <b>Retry</b> and <b>Cancel</b>
///             buttons. Clicking the <b>Cancel</b> button directs <b>LZOpenFile</b> to return a file not found error message.
///             </td> </tr> <tr> <td width="40%"><a id="OF_READ"></a><a id="of_read"></a><dl> <dt><b>OF_READ</b></dt>
///             <dt>0x0000</dt> </dl> </td> <td width="60%"> Opens the file for reading only. </td> </tr> <tr> <td width="40%"><a
///             id="OF_READWRITE"></a><a id="of_readwrite"></a><dl> <dt><b>OF_READWRITE</b></dt> <dt>0x0002</dt> </dl> </td> <td
///             width="60%"> Opens the file for reading and writing. </td> </tr> <tr> <td width="40%"><a id="OF_REOPEN"></a><a
///             id="of_reopen"></a><dl> <dt><b>OF_REOPEN</b></dt> <dt>0x8000</dt> </dl> </td> <td width="60%"> Opens the file
///             using information in the reopen buffer. </td> </tr> <tr> <td width="40%"><a id="OF_SHARE_DENY_NONE"></a><a
///             id="of_share_deny_none"></a><dl> <dt><b>OF_SHARE_DENY_NONE</b></dt> <dt>0x0040</dt> </dl> </td> <td width="60%">
///             Opens the file without denying other processes read or write access to the file. <b>LZOpenFile</b> fails if the
///             file has been opened in compatibility mode by any other process. </td> </tr> <tr> <td width="40%"><a
///             id="OF_SHARE_DENY_READ"></a><a id="of_share_deny_read"></a><dl> <dt><b>OF_SHARE_DENY_READ</b></dt>
///             <dt>0x0030</dt> </dl> </td> <td width="60%"> Opens the file and denies other processes read access to the file.
///             <b>LZOpenFile</b> fails if the file has been opened in compatibility mode or has been opened for read access by
///             any other process. </td> </tr> <tr> <td width="40%"><a id="OF_SHARE_DENY_WRITE"></a><a
///             id="of_share_deny_write"></a><dl> <dt><b>OF_SHARE_DENY_WRITE</b></dt> <dt>0x0020</dt> </dl> </td> <td
///             width="60%"> Opens the file and denies other processes write access to the file. <b>LZOpenFile</b> fails if the
///             file has been opened in compatibility mode or has been opened for write access by any other process. </td> </tr>
///             <tr> <td width="40%"><a id="OF_SHARE_EXCLUSIVE"></a><a id="of_share_exclusive"></a><dl>
///             <dt><b>OF_SHARE_EXCLUSIVE</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%"> Opens the file in exclusive mode,
///             denying other processes both read and write access to the file. <b>LZOpenFile</b> fails if the file has been
///             opened in any other mode for read or write access, even by the current process. </td> </tr> <tr> <td
///             width="40%"><a id="OF_WRITE"></a><a id="of_write"></a><dl> <dt><b>OF_WRITE</b></dt> <dt>0x0001</dt> </dl> </td>
///             <td width="60%"> Opens the file for writing only. </td> </tr> </table>
///Returns:
///    If the function succeeds and the value specified by the <i>wStyle</i> parameter is not <b>OF_READ</b>, the return
///    value is a handle identifying the file. If the file is compressed and opened with <i>wStyle</i> set to
///    <b>OF_READ</b>, the return value is a special file handle. If the function fails, the return value is an
///    <b>LZERROR_*</b> code. These codes have values less than zero. There is no extended error information for this
///    function; do not call GetLastError. <div class="alert"><b>Note</b> <b>LZOpenFile</b> calls neither SetLastError
///    nor SetLastErrorEx; thus, its failure does not affect a thread's last-error code.</div> <div> </div> The
///    following is the list of the error codes that <b>LZOpenFile</b> can return upon failure. <table> <tr> <th>Return
///    code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>LZERROR_BADINHANDLE</b></dt>
///    <dt>-1</dt> </dl> </td> <td width="60%"> The handle identifying the source file is not valid. The file cannot be
///    read. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>LZERROR_GLOBALLOC</b></dt> <dt>-5</dt> </dl> </td> <td
///    width="60%"> The maximum number of open compressed files has been exceeded or local memory cannot be allocated.
///    </td> </tr> </table>
///    
@DllImport("KERNEL32")
int LZOpenFileW(const(wchar)* lpFileName, OFSTRUCT* lpReOpenBuf, ushort wStyle);

///Moves a file pointer the specified number of bytes from a starting position.
///Params:
///    hFile = A handle to the file.
///    lOffset = The number of bytes by which to move the file pointer.
///    iOrigin = The starting position of the pointer. This parameter must be one of the following values. <table> <tr>
///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Moves
///              the file pointer <i>lOffset</i> bytes from the beginning of the file. </td> </tr> <tr> <td width="40%"> <dl>
///              <dt>1</dt> </dl> </td> <td width="60%"> Moves the file pointer <i>lOffset</i> bytes from the current position.
///              </td> </tr> <tr> <td width="40%"> <dl> <dt>2</dt> </dl> </td> <td width="60%"> Moves the file pointer
///              <i>lOffset</i> bytes from the end of the file. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value specifies the offset from the beginning of the file to the new pointer
///    position. If the function fails, the return value is an LZERROR_* code. These codes have values less than zero.
///    Note that <b>LZSeek</b> calls neither SetLastError nor SetLastErrorEx; thus, its failure does not affect a
///    thread's last-error code. The following is the list of error codes that <b>LZSeek</b> can return upon failure.
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>LZERROR_BADINHANDLE</b></dt> </dl> </td> <td width="60%"> The handle identifying the source file is not
///    valid. The file cannot be read. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>LZERROR_BADVALUE</b></dt> </dl>
///    </td> <td width="60%"> One of the parameters is outside the range of acceptable values. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>LZERROR_GLOBLOCK</b></dt> </dl> </td> <td width="60%"> The LZ file handle cannot be
///    locked down. </td> </tr> </table> There is no extended error information for this function; do not call
///    GetLastError.
///    
@DllImport("KERNEL32")
int LZSeek(int hFile, int lOffset, int iOrigin);

///Reads (at most) the specified number of bytes from a file and copies them into a buffer.
///Params:
///    hFile = A handle to the file.
///    lpBuffer = A pointer to a buffer that receives the bytes read from the file. Ensure that this buffer is larger than
///               <i>cbRead</i>.
///    cbRead = The count of bytes to be read.
///Returns:
///    If the function succeeds, the return value specifies the number of bytes read. If the function fails, the return
///    value is an LZERROR_* code. These codes have values less than zero. Note that <b>LZRead</b> calls neither
///    SetLastError nor SetLastErrorEx; thus, its failure does not affect a thread's last-error code. The following is
///    the list of error codes that <b>LZRead</b> can return upon failure. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>LZERROR_BADINHANDLE</b></dt> </dl> </td> <td
///    width="60%"> The handle identifying the source file is not valid. The file cannot be read. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>LZERROR_BADOUTHANDLE</b></dt> </dl> </td> <td width="60%"> The handle identifying the
///    destination file is not valid. The file cannot be written. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>LZERROR_BADVALUE</b></dt> </dl> </td> <td width="60%"> One of the input parameters is not valid. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>LZERROR_GLOBALLOC</b></dt> </dl> </td> <td width="60%"> The maximum
///    number of open compressed files has been exceeded or local memory cannot be allocated. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>LZERROR_GLOBLOCK</b></dt> </dl> </td> <td width="60%"> The LZ file handle cannot be
///    locked down. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>LZERROR_READ</b></dt> </dl> </td> <td width="60%"> The
///    source file format is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>LZERROR_WRITE</b></dt> </dl> </td>
///    <td width="60%"> There is insufficient space for the output file. </td> </tr> </table> There is no extended error
///    information for this function; do not call GetLastError.
///    
@DllImport("KERNEL32")
int LZRead(int hFile, char* lpBuffer, int cbRead);

///Closes a file that was opened by using the LZOpenFile function.
///Params:
///    hFile = A handle to the file to be closed.
@DllImport("KERNEL32")
void LZClose(int hFile);

///Retrieves a list of users for the specified file.
///Params:
///    lpFileName = The name of the file.
///    pUsers = A pointer to a ENCRYPTION_CERTIFICATE_HASH_LIST structure that receives the list of users.
///Returns:
///    If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. If the function fails, the return value is a
///    system error code. For a complete list of error codes, see System Error Codes or the header file WinError.h.
///    
@DllImport("ADVAPI32")
uint QueryUsersOnEncryptedFile(const(wchar)* lpFileName, ENCRYPTION_CERTIFICATE_HASH_LIST** pUsers);

///Retrieves a list of recovery agents for the specified file.
///Params:
///    lpFileName = The name of the file.
///    pRecoveryAgents = A pointer to a ENCRYPTION_CERTIFICATE_HASH_LIST structure that receives a list of recovery agents.
///Returns:
///    If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. If the function fails, the return value is a
///    system error code. For a complete list of error codes, see System Error Codes or the header file WinError.h.
///    
@DllImport("ADVAPI32")
uint QueryRecoveryAgentsOnEncryptedFile(const(wchar)* lpFileName, 
                                        ENCRYPTION_CERTIFICATE_HASH_LIST** pRecoveryAgents);

///Removes specified certificate hashes from a specified file.
///Params:
///    lpFileName = The name of the file.
///    pHashes = A pointer to an ENCRYPTION_CERTIFICATE_HASH_LIST structure that contains a list of certificate hashes to be
///              removed from the file.
///Returns:
///    If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. If the function fails, the return value is a
///    system error code. For a complete list of error codes, see System Error Codes or the header file WinError.h.
///    
@DllImport("ADVAPI32")
uint RemoveUsersFromEncryptedFile(const(wchar)* lpFileName, ENCRYPTION_CERTIFICATE_HASH_LIST* pHashes);

///Adds user keys to the specified encrypted file.
///Params:
///    lpFileName = The name of the encrypted file.
///    pEncryptionCertificates = A pointer to an ENCRYPTION_CERTIFICATE_LIST structure that contains the list of new user keys to be added to the
///                              file.
///Returns:
///    If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. If the function fails, the return value is a
///    system error code. For a complete list of error codes, see System Error Codes or the header file WinError.h.
///    
@DllImport("ADVAPI32")
uint AddUsersToEncryptedFile(const(wchar)* lpFileName, ENCRYPTION_CERTIFICATE_LIST* pEncryptionCertificates);

///Sets the user's current key to the specified certificate.
///Params:
///    pEncryptionCertificate = A pointer to a certificate that will be the user's key. This parameter is a pointer to an ENCRYPTION_CERTIFICATE
///                             structure.
///Returns:
///    If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. If the function fails, the return value is a
///    system error code. For a complete list of error codes, see System Error Codes or the header file WinError.h.
///    
@DllImport("ADVAPI32")
uint SetUserFileEncryptionKey(ENCRYPTION_CERTIFICATE* pEncryptionCertificate);

@DllImport("ADVAPI32")
uint SetUserFileEncryptionKeyEx(ENCRYPTION_CERTIFICATE* pEncryptionCertificate, uint dwCapabilities, uint dwFlags, 
                                void* pvReserved);

///Frees a certificate hash list.
///Params:
///    pUsers = A pointer to a certificate hash list structure, ENCRYPTION_CERTIFICATE_HASH_LIST, which was returned by the
///             QueryUsersOnEncryptedFile or QueryRecoveryAgentsOnEncryptedFile function.
@DllImport("ADVAPI32")
void FreeEncryptionCertificateHashList(ENCRYPTION_CERTIFICATE_HASH_LIST* pUsers);

///Disables or enables encryption of the specified directory and the files in it. It does not affect encryption of
///subdirectories below the indicated directory.
///Params:
///    DirPath = The name of the directory for which to enable or disable encryption.
///    Disable = Indicates whether to disable encryption (<b>TRUE</b>) or enable it (<b>FALSE</b>).
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL EncryptionDisable(const(wchar)* DirPath, BOOL Disable);

///Copies the EFS metadata from one file or directory to another.
///Params:
///    SrcFileName = The name of the file or directory from which the EFS metadata is to be copied. This source file or directory must
///                  be encrypted.
///    DstFileName = The name of the file or directory to which the EFS metadata is to be copied. This destination file or directory
///                  does not have to be encrypted before the call to this function; however if this function completes successfully,
///                  it will be encrypted. If the value of <i>SrcFileName</i> specifies a file, the value of this parameter must also
///                  specify a file, and likewise for directories. If a file or directory with the name specified by this parameter
///                  does not exist, a file or directory (depending on whether <i>SrcFileName</i> specifies a file or directory) will
///                  be created.
///    dwCreationDistribution = Describes how the destination file or directory identified by the <i>DstFileName</i> parameter value is to be
///                             opened. The following are the valid values of this parameter. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                             <tr> <td width="40%"><a id="CREATE_ALWAYS"></a><a id="create_always"></a><dl> <dt><b>CREATE_ALWAYS</b></dt>
///                             <dt>2</dt> </dl> </td> <td width="60%"> Always create the destination file or directory. Any value passed in this
///                             parameter other than <b>CREATE_NEW</b> will be processed as <b>CREATE_ALWAYS</b>. </td> </tr> <tr> <td
///                             width="40%"><a id="CREATE_NEW"></a><a id="create_new"></a><dl> <dt><b>CREATE_NEW</b></dt> <dt>1</dt> </dl> </td>
///                             <td width="60%"> Create the destination file or directory only if it does not already exist. If it does exist,
///                             and this value is specified, this function will fail. </td> </tr> </table>
///    dwAttributes = The file attributes of the destination file or directory. The <b>FILE_READ_ONLY</b> attribute is currently not
///                   processed by this function.
///    lpSecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure that specifies the security attributes of the destination file or
///                           directory, if it does not already exist. If you specify <b>NULL</b>, the file or directory gets a default
///                           security descriptor. The ACLs in the default security descriptor for a file or directory are inherited from its
///                           parent directory.
///Returns:
///    If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. If the function fails, the return value is a
///    system error code. For a complete list of error codes, see System Error Codes or the header file WinError.h.
///    
@DllImport("ADVAPI32")
uint DuplicateEncryptionInfoFile(const(wchar)* SrcFileName, const(wchar)* DstFileName, uint dwCreationDistribution, 
                                 uint dwAttributes, const(SECURITY_ATTRIBUTES)* lpSecurityAttributes);

@DllImport("ADVAPI32")
uint GetEncryptedFileMetadata(const(wchar)* lpFileName, uint* pcbMetadata, ubyte** ppbMetadata);

@DllImport("ADVAPI32")
uint SetEncryptedFileMetadata(const(wchar)* lpFileName, ubyte* pbOldMetadata, ubyte* pbNewMetadata, 
                              ENCRYPTION_CERTIFICATE_HASH* pOwnerHash, uint dwOperation, 
                              ENCRYPTION_CERTIFICATE_HASH_LIST* pCertificatesAdded);

@DllImport("ADVAPI32")
void FreeEncryptedFileMetadata(ubyte* pbMetadata);

@DllImport("clfsw32")
ubyte LsnEqual(const(CLS_LSN)* plsn1, const(CLS_LSN)* plsn2);

@DllImport("clfsw32")
ubyte LsnLess(const(CLS_LSN)* plsn1, const(CLS_LSN)* plsn2);

@DllImport("clfsw32")
ubyte LsnGreater(const(CLS_LSN)* plsn1, const(CLS_LSN)* plsn2);

@DllImport("clfsw32")
ubyte LsnNull(const(CLS_LSN)* plsn);

///Retrieves the logical container ID that is contained in a specified LSN.
///Params:
///    plsn = A pointer to a CLFS_LSN structure from which the container ID is to be retrieved.
///Returns:
///    This function returns the logical container ID that is contained in <i>plsn</i>. The logical container ID is not
///    necessarily the same as the ID of the physical container on stable storage.
///    
@DllImport("clfsw32")
uint LsnContainer(const(CLS_LSN)* plsn);

///Creates a log sequence number (LSN), given a container ID, a block offset, and a record sequence number.
///Params:
///    cidContainer = The container ID. This value must be an integer between 0x0 and 0xFFFFFFFF.
///    offBlock = The block offset. This value must be a multiple of 512.
///    cRecord = The record sequence number. This value must be an integer between 0 - 511.
///Returns:
///    Returns a CLFS_LSN structure that represents the container ID, block offset, and record sequence number that is
///    supplied by the caller.
///    
@DllImport("clfsw32")
CLS_LSN LsnCreate(uint cidContainer, uint offBlock, uint cRecord);

///Returns the sector-aligned block offset that is contained in the specified LSN.
///Params:
///    plsn = A pointer to a CLFS_LSN structure from which the block offset is to be retrieved.
///Returns:
///    <b>LsnBlockOffset</b> returns the block offset that is contained in <i>plsn</i>.
///    
@DllImport("clfsw32")
uint LsnBlockOffset(const(CLS_LSN)* plsn);

///Retrieves the record sequence number that is contained in a specified LSN.
///Params:
///    plsn = A pointer to a CLFS_LSN structure from which the record sequence number is to be retrieved.
///Returns:
///    The record sequence number that is contained in <i>plsn</i>.
///    
@DllImport("clfsw32")
uint LsnRecordSequence(const(CLS_LSN)* plsn);

@DllImport("clfsw32")
ubyte LsnInvalid(const(CLS_LSN)* plsn);

@DllImport("clfsw32")
CLS_LSN LsnIncrement(CLS_LSN* plsn);

///Creates or opens a log. The log can be dedicated or multiplexed, and that depends on the log name. Use the
///CloseHandle function to close the log.
///Params:
///    pszLogFileName = The name of the log. This name is specified when creating the log by using <b>CreateLogFile</b>. The following
///                     example identifies the format to use. <b>log
///                     :&lt;</b><i>LogName</i><b>&gt;[::&lt;</b><i>LogStreamName</i><b>&gt;]</b> For example: The path
///                     "LOG:c:\MyDirectory\MyLog" creates the file "c:\MyDirectory\MyLog.blf". The path
///                     "\??\LOG:\HarddiskVolume1\MyDirectory\MyLog" creates the file "\\.\HarddiskVolume1\MyDirectory\MyLog.blf", as
///                     does the path "\clfs\Device\HarddiskVolume1\MyDirectory\MyLog". &lt;<i>LogName</i>&gt; corresponds to a valid
///                     file path in the file system, and &lt;<i>LogStreamName</i>&gt; is the unique name of a log stream in the log. For
///                     more information, see Log Types.
///    fDesiredAccess = The type of access that the returned handle has to the log object. <table> <tr> <th>Value</th> <th>Meaning</th>
///                     </tr> <tr> <td width="40%"><a id="GENERIC_READ"></a><a id="generic_read"></a><dl> <dt><b>GENERIC_READ</b></dt>
///                     </dl> </td> <td width="60%"> Specifies read access to the object. </td> </tr> <tr> <td width="40%"><a
///                     id="GENERIC_WRITE"></a><a id="generic_write"></a><dl> <dt><b>GENERIC_WRITE</b></dt> </dl> </td> <td width="60%">
///                     Specifies write access to the object. </td> </tr> <tr> <td width="40%"><a id="DELETE"></a><a id="delete"></a><dl>
///                     <dt><b>DELETE</b></dt> </dl> </td> <td width="60%"> Specify log deletion access </td> </tr> </table> A bitwise
///                     <b>OR</b> of two or more of these flags allows combinations of read, write, and delete access to the object. <div
///                     class="alert"><b>Note</b> You must specify <b>DELETE</b> access to be able to delete the log.</div> <div> </div>
///                     <b>Windows Server 2003 R2: </b>This parameter must be set to <b>GENERIC_WRITE</b>.
///    dwShareMode = The sharing mode of a file. A client cannot request a sharing mode that conflicts with any mode that is specified
///                  in any previous open request that has an open handle. If this parameter is zero and the function succeeds, the
///                  object cannot be shared and cannot be opened again until the handle is closed. This parameter can be one or more
///                  of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="FILE_SHARE_DELETE"></a><a id="file_share_delete"></a><dl> <dt><b>FILE_SHARE_DELETE</b></dt> </dl> </td> <td
///                  width="60%"> Enables open operations on the object to request delete access. Without this value, other processes
///                  cannot open the object if delete access is requested. </td> </tr> <tr> <td width="40%"><a
///                  id="FILE_SHARE_READ"></a><a id="file_share_read"></a><dl> <dt><b>FILE_SHARE_READ</b></dt> </dl> </td> <td
///                  width="60%"> Enables open operations on the object to request read access. Without this value, other processes
///                  cannot open the object if read access is requested. </td> </tr> <tr> <td width="40%"><a
///                  id="FILE_SHARE_WRITE"></a><a id="file_share_write"></a><dl> <dt><b>FILE_SHARE_WRITE</b></dt> </dl> </td> <td
///                  width="60%"> Enables open operations on the object to request write access. Without this value, other processes
///                  cannot open the object if write access is requested. </td> </tr> </table>
///    psaLogFile = A pointer to a SECURITY_ATTRIBUTES structure that specifies the security attributes of a log. It determines
///                 whether the returned handle can be inherited by child processes. If this parameter is <b>NULL</b>, the handle
///                 cannot be inherited. The <b>lpSecurityDescriptor</b> member of SECURITY_ATTRIBUTES specifies a security
///                 descriptor for the new log handle. If <i>psaLogFile</i> is <b>NULL</b>, the object gets a default security
///                 descriptor. The access control lists (ACL) in the default security descriptor for a log come from the primary or
///                 impersonation token of the creator.
///    fCreateDisposition = An action to be taken. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                         <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CREATE_NEW"></a><a id="create_new"></a><dl>
///                         <dt><b>CREATE_NEW</b></dt> </dl> </td> <td width="60%"> Creates a new file and fails if the file already exists.
///                         </td> </tr> <tr> <td width="40%"><a id="OPEN_EXISTING"></a><a id="open_existing"></a><dl>
///                         <dt><b>OPEN_EXISTING</b></dt> </dl> </td> <td width="60%"> Opens an existing file and fails if the file does not
///                         exist. </td> </tr> <tr> <td width="40%"><a id="OPEN_ALWAYS"></a><a id="open_always"></a><dl>
///                         <dt><b>OPEN_ALWAYS</b></dt> </dl> </td> <td width="60%"> Opens an existing file or creates the file if it does
///                         not exist. </td> </tr> </table>
///    fFlagsAndAttributes = The file attributes and flags for the file. This parameter can take the following values. <table> <tr>
///                          <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a
///                          id="file_attribute_archive"></a><dl> <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt> </dl> </td> <td width="60%"> This
///                          non-ephemeral log should be archived. If this flag is not supplied, the log does not need to be archived, and an
///                          archival tail is not maintained for recycling log containers. </td> </tr> <tr> <td width="40%"><a
///                          id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl> <dt><b>FILE_FLAG_OVERLAPPED</b></dt> </dl>
///                          </td> <td width="60%"> If the <b>FILE_FLAG_OVERLAPPED</b> flag is set, all other flag values are ignored.
///                          Specifying <b>FILE_FLAG_OVERLAPPED</b> means that a file is opened for overlapped I/O, which enables more than
///                          one I/O operation to be performed on the log handle. If this flag is set when creating a log, all asynchronous
///                          I/O calls to that log must specify an overlapped structure and synchronize with the deferred completion of the
///                          call. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a handle to the log. If the function fails, the return value is
///    <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call GetLastError. The following list identifies
///    the possible error codes:
///    
@DllImport("clfsw32")
HANDLE CreateLogFile(const(wchar)* pszLogFileName, uint fDesiredAccess, uint dwShareMode, 
                     SECURITY_ATTRIBUTES* psaLogFile, uint fCreateDisposition, uint fFlagsAndAttributes);

///Marks the specified log for deletion. The log is actually deleted when all handles, marshaling areas, and read
///contexts to the log are closed. If the log is a physical log, its underlying containers are deleted. When a log is
///marked for deletion, requests to open new client log streams fail. <div class="alert"><b>Note</b> This function
///differs from DeleteLogFile, because it takes a valid open handle to the log object instead of the log
///name.</div><div> </div>
///Params:
///    hLog = A handle to an open log that is obtained by a successful call to CreateLogFile. The log must have been created
///           with DELETE access or you cannot delete the log.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL DeleteLogByHandle(HANDLE hLog);

///Marks a log for deletion. The log is actually deleted when all handles, marshaling areas, and read contexts to the
///log are closed. If the log is a physical log, its underlying containers are deleted. When a log is marked for
///deletion, requests to open new client log streams fail. <div class="alert"><b>Note</b> A closely related function is
///DeleteLogByHandle, which deletes a log when given the handle of the file.</div> <div> </div>
///Params:
///    pszLogFileName = The name of the log. This name is specified when creating the log by using CreateLogFile. The following example
///                     identifies the format to use: <b>log:&lt;</b><i>log name</i><b>&gt;[::&lt;</b><i>log stream name</i><b>&gt;]</b>
///                     &lt;<i>log name</i>&gt; corresponds to a valid file path in the file system. &lt;<i>log stream name</i>&gt; is
///                     the unique name of a log stream in the log. For more information, see Log Types.
///    pvReserved = This parameter is reserved and should be set to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL DeleteLogFile(const(wchar)* pszLogFileName, void* pvReserved);

///Adds a container to the physical log that is associated with the log handle—if the calling process has write access
///to the .blf file and the ability to create files in the target directory of the container. This function is different
///from AddLogContainerSet, because it adds only one container. To add multiple containers, it is more efficient to use
///<b>AddLogContainerSet</b>, which allows you to add more than one container. Adding containers allows a client to
///increase the size of a log.
///Params:
///    hLog = The handle to an open log. The handle must be obtained from CreateLogFile with write access to the log. The
///           client application must have write access to the .blf file, and the ability to create files in the target
///           directory of a container.
///    pcbContainer = The optional parameter that specifies the size of the container, in bytes. The minimum size is 512 KB for normal
///                   logs and 1024 KB for multiplexed logs. The maximum size is approximately 4 gigabytes. This parameter is required
///                   if the containers are being added to a newly created log. If a container is already created, this parameter can
///                   be <b>NULL</b>, or some value that is at least as large as the size of the first container. Log container sizes
///                   are multiples of the log region size (512 KB). When you add a container to a new file, the <b>AddLogContainer</b>
///                   function rounds the size of the container up to the next 512 KB boundary, and returns that size in the value
///                   pointed to by <i>pcbContainer</i>. Similarly, if the log already has at least one container and the value of
///                   <i>*pcbContainer</i> is at least as large as the current container size, the function creates all containers with
///                   the current internal size and returns that size in <i>*pcbContainer</i>.
///    pwszContainerPath = A pointer to a null-terminated string that contains a valid path for the new container on a log volume.
///    pReserved = Reserved. Set <i>pReserved</i> to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL AddLogContainer(HANDLE hLog, ulong* pcbContainer, const(wchar)* pwszContainerPath, void* pReserved);

///Adds multiple log containers to the physical log that is associated with the log handle—if the calling process has
///access to the log handle. Adding containers allows a client to increase the size of a log.
///Params:
///    hLog = The handle to an open log that is obtained from CreateLogFile with permissions to add a log container. The file
///           can be dedicated or multiplexed.
///    cContainer = The number of containers in the <i>rgwszContainerPath</i> array. This value must be nonzero. A log must have at
///                 least two containers before any I/O can be performed on it.
///    pcbContainer = The size of the container, in bytes. The minimum size is 512 KB for normal logs and 1024 KB for multiplexed logs.
///                   The maximum size is approximately 4 gigabytes (GB). This parameter is required if the containers are being added
///                   to a newly created log. If a container is already created, this parameter can be <b>NULL</b>, or some value that
///                   is at least as large as the size of the first container. Log container sizes are multiples of the log region size
///                   (512 KB). When you add a container to a new file, the AddLogContainer function rounds the size of the container
///                   up to the next 512 KB boundary, and returns that size in the value pointed to by <i>pcbContainer</i>. Similarly,
///                   if the log already has at least one container and the value of <i>*pcbContainer</i> is at least as large as the
///                   current container size, the function creates all containers with the current internal size and returns that size
///                   in <i>*pcbContainer</i>.
///    rgwszContainerPath = An array of <i>cContainer</i> path names for containers. Each element in the array is a wide-character string
///                         that contains a valid path for the new container in the log volume.
///    pReserved = Reserved. Set <i>Reserved</i> to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero, which indicates that all containers are added successfully
///    to the log. If the function fails, the return value is zero, which indicates that none of the containers are
///    added. To get extended error information, call GetLastError. The following list identifies the possible error
///    codes:
///    
@DllImport("clfsw32")
BOOL AddLogContainerSet(HANDLE hLog, ushort cContainer, ulong* pcbContainer, char* rgwszContainerPath, 
                        void* pReserved);

///Removes one container from a log that is associated with a dedicated or multiplexed log handle. A client must have
///administrative privileges on the log handle to remove a container. To remove multiple containers, use the
///RemoveLogContainerSet function.
///Params:
///    hLog = A handle to the log that is obtained from CreateLogFile.
///    pwszContainerPath = A pointer to a wide character string that contains a path for a log container that is created by either
///                        AddLogContainer or AddLogContainerSet.
///    fForce = The deletion flag that determines when and how a container is deleted. If <i>fForce</i> is <b>TRUE</b>, and the
///             container is part of the active log region, the container is not deleted and an error
///             <b>ERROR_LOG_CANT_DELETE</b> is returned. If <b>FALSE</b>, the container is deleted when the container is no
///             longer a part of the active log region.
///    pReserved = This parameter is reserved and should be set to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL RemoveLogContainer(HANDLE hLog, const(wchar)* pwszContainerPath, BOOL fForce, void* pReserved);

///Removes multiple containers from a log that is associated with a dedicated or multiplexed log handle. A client must
///have administrative privileges on the log handle to remove a container. The RemoveLogContainer function is a special
///case of this <b>RemoveLogContainerSet</b> function, because it removes only one container. To remove multiple
///containers, use the <b>RemoveLogContainerSet</b>.
///Params:
///    hLog = A handle to the log that is obtained from CreateLogFile. The log handle must have administrative permission to
///           add a log container, and can refer to either a dedicated or multiplexed log.
///    cContainer = The number of container path names in an array that is pointed to by <i>rgwszContainerPath</i>. This value must
///                 be nonzero.
///    rgwszContainerPath = An array of pointers to container path names that contain <i>cContainers</i> pointers. Each path name is a wide
///                         character string that identifies a container created by either AddLogContainer or AddLogContainerSet.
///    fForce = The deletion flag that determines when and how a container is deleted. If <i>fForce</i> is <b>TRUE</b>, and the
///             container is part of the active log region, the container is not deleted and an error
///             <b>ERROR_LOG_CANT_DELETE</b> is returned. If <b>FALSE</b>, the container is deleted when the container is no
///             longer a part of the active log region.
///    pReserved = Reserved. Set <i>pReserved</i> to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL RemoveLogContainerSet(HANDLE hLog, ushort cContainer, char* rgwszContainerPath, BOOL fForce, void* pReserved);

///Sets the last archived log sequence number (LSN) or <i>archive tail</i> of an archivable log.
///Params:
///    hLog = A handle to the log that is obtained from CreateLogFile. The log handle can refer to a dedicated or multiplexed
///           log.
///    plsnArchiveTail = A pointer to a CLFS_LSN structure that specifies a valid physical LSN in the log. <div class="alert"><b>Note</b>
///                      For handles to both a physical log or a log stream, <i>plsnArchiveTail</i> is a physical LSN, because it refers
///                      to a record address in the physical log.</div> <div> </div>
///    pReserved = This parameter is reserved and should be set to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL SetLogArchiveTail(HANDLE hLog, CLS_LSN* plsnArchiveTail, void* pReserved);

///This function has been deprecated. Use TruncateLog instead.
///Params:
///    hLog = A handle to the log that is obtained from CreateLogFile. The log handle must refer to a dedicated log.
///    plsnEnd = A pointer to a CLFS_LSN structure that specifies the new end of a log. The LSN must be between the base log
///              sequence number (LSN) of the log and the last LSN of the log.
///    lpOverlapped = Reserved. Set <i>lpOverlapped</i> to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL SetEndOfLog(HANDLE hLog, CLS_LSN* plsnEnd, OVERLAPPED* lpOverlapped);

///Truncates the log. The function sets the end of the log to the specified value.
///Params:
///    pvMarshal = A pointer to the opaque marshaling context that is allocated by calling the CreateLogMarshallingArea function.
///    plsnEnd = A pointer to a CLFS_LSN structure that specifies the new end of a log. The LSN must be between the base log
///              sequence number (LSN) of the log and the last LSN of the log.
///    lpOverlapped = Reserved. Set <i>Reserved</i> to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL TruncateLog(void* pvMarshal, CLS_LSN* plsnEnd, OVERLAPPED* lpOverlapped);

///Creates a scan context to use with ScanLogContainers to enumerate all log containers that are associated with a log,
///and performs the first scan.
///Params:
///    hLog = A handle to the log that is obtained from CreateLogFile with permissions to scan the log containers. The file can
///           be a dedicated or multiplexed log.
///    cFromContainer = The container where the scan is to be started. This parameter is an ordinal number relative to the number of
///                     containers in the log.
///    cContainers = The number of CLFS_CONTAINER_INFORMATION structures for <b>CreateLogContainerScanContext</b> to allocate. This
///                  number is the number of containers scanned with each scan call so the caller knows the scan is complete when the
///                  number of containers returned is less than this value. On exit, a pointer to the system-allocated array of
///                  CLFS_CONTAINER_INFORMATION structures is placed in the <b>pinfoContainer</b> member of the client-allocated
///                  CLFS_SCAN_CONTEXT structure. This member is pointed to by the <i>pcxScan</i> parameter (that is,
///                  "pcxScan-&gt;pinfoContainer[]"), and the actual number of structures in the array is placed in
///                  "pcxScan-&gt;cContainersReturned". The client must call ScanLogContainers with the <i>eScanMode</i> parameter set
///                  to <b>CLFS_SCAN_CLOSE</b> so that it can free this array; otherwise, memory leaks result.
///    eScanMode = The mode to scan containers. Containers can be scanned in any one of the following modes. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CLFS_SCAN_INIT__"></a><a
///                id="clfs_scan_init__"></a><dl> <dt><b>CLFS_SCAN_INIT </b></dt> </dl> </td> <td width="60%"> Initializes or
///                reinitializes a scan from the first container in the container list. This mode initializes the container context
///                and returns the first set of container descriptors that <i>cContainers</i> specifies. </td> </tr> <tr> <td
///                width="40%"><a id="CLFS_SCAN_FORWARD"></a><a id="clfs_scan_forward"></a><dl> <dt><b>CLFS_SCAN_FORWARD</b></dt>
///                </dl> </td> <td width="60%"> Returns the first set of containers that <i>cContainers</i> specifies. </td> </tr>
///                <tr> <td width="40%"><a id="CLFS_SCAN_BACKWARD"></a><a id="clfs_scan_backward"></a><dl>
///                <dt><b>CLFS_SCAN_BACKWARD</b></dt> </dl> </td> <td width="60%"> Returns the last set of containers that
///                <i>cContainers</i> specifies. </td> </tr> </table>
///    pcxScan = A pointer to a client-allocated CLFS_SCAN_CONTEXT structure that receives a scan context that can be passed to
///              the ScanLogContainers function when a client scans the log containers of a dedicated log.
///    pOverlapped = A pointer to an OVERLAPPED structure that is required for asynchronous operation. This parameter can be
///                  <b>NULL</b> if an asynchronous operation is not used.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL CreateLogContainerScanContext(HANDLE hLog, uint cFromContainer, uint cContainers, ubyte eScanMode, 
                                   CLS_SCAN_CONTEXT* pcxScan, OVERLAPPED* pOverlapped);

///Enumerates log containers. Call this function repeatedly to iterate over all log containers.
///Params:
///    pcxScan = A pointer to a client-allocated CLFS_SCAN_CONTEXT structure that the CreateLogContainerScanContext function
///              initializes.
///    eScanMode = The mode for containers to be scanned. Containers can be scanned in any of the following CLFS_SCAN_MODE modes.
///                <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CLFS_SCAN_INIT"></a><a
///                id="clfs_scan_init"></a><dl> <dt><b>CLFS_SCAN_INIT</b></dt> </dl> </td> <td width="60%"> Reinitializes the scan
///                context, but does not allocate associated storage. The initialization is destructive, because all data that is
///                stored in the current scan context is lost. </td> </tr> <tr> <td width="40%"><a id="CLFS_SCAN_CLOSE"></a><a
///                id="clfs_scan_close"></a><dl> <dt><b>CLFS_SCAN_CLOSE</b></dt> </dl> </td> <td width="60%"> Uninitializes the scan
///                context, and deallocates system storage that is associated with a scan context. </td> </tr> <tr> <td
///                width="40%"><a id="CLFS_SCAN_FORWARD"></a><a id="clfs_scan_forward"></a><dl> <dt><b>CLFS_SCAN_FORWARD</b></dt>
///                </dl> </td> <td width="60%"> Causes the next call to <b>ScanLogContainers</b> to proceed in a forward direction.
///                Cannot be used if <b>CLFS_SCAN_BACKWARD</b> is specified. </td> </tr> <tr> <td width="40%"><a
///                id="CLFS_SCAN_BACKWARD"></a><a id="clfs_scan_backward"></a><dl> <dt><b>CLFS_SCAN_BACKWARD</b></dt> </dl> </td>
///                <td width="60%"> Causes the next call to <b>ScanLogContainers</b> to proceed in a backward direction. Cannot be
///                used if <b>CLFS_SCAN_FORWARD</b> is specified. </td> </tr> </table>
///    pReserved = Reserved. Set <i>pReserved</i> to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL ScanLogContainers(CLS_SCAN_CONTEXT* pcxScan, ubyte eScanMode, void* pReserved);

///Calculates the sector-aligned reservation size for a set of reserved records. This value is then passed to
///AllocReservedLog to reserve a block of log space for a set of records.
///Params:
///    pvMarshal = A pointer to the opaque marshaling context that is allocated by calling the CreateLogMarshallingArea function.
///    cReservedRecords = The number of reserved records that are associated with the reservation adjustment.
///    rgcbReservation = An array of space allocations to reserve in the log that is associated with the current marshaling context, in
///                      bytes. The number of allocations corresponds to the number of records that <i>cReservedRecords</i> specifies.
///                      Each allocation must be greater than zero (0) or the function fails with <b>ERROR_INVALID_PARAMETER</b>.
///    pcbAlignReservation = A pointer to a variable in which the function returns the number of sector-aligned byte space to be reserved in
///                          the log—after being given the number of records that <i>cRecords</i> specifies and the size of reservations
///                          specified in the <i>rgcbReservation</i> array. The value returned in <i>*pcbAlignReservation</i> is used as input
///                          to AllocReservedLog. If <b>AllocReservedLog</b> succeeds, this value is always greater than zero (0). If
///                          <b>AllocReservedLog</b> fails, the value is zero (0).
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL AlignReservedLog(void* pvMarshal, uint cReservedRecords, long* rgcbReservation, long* pcbAlignReservation);

///Allocates sector-aligned space for a set of reserved records. The requested allocation must be the same size that
///AlignReservedLog returns.
///Params:
///    pvMarshal = A pointer to the marshaling context that is allocated by calling the CreateLogMarshallingArea function.
///    cReservedRecords = The number of reserved records that are associated with the reservation adjustment. This value must be greater
///                       than zero (0).
///    pcbAdjustment = The size of the sector-aligned space reservation that is associated with the number of records specified in
///                    <i>cReservedRecords</i>, in bytes. This parameter must be the aligned reservation size that AlignReservedLog
///                    returns in <i>*pcbAlignReservation</i>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL AllocReservedLog(void* pvMarshal, uint cReservedRecords, long* pcbAdjustment);

///Reduces the number of reserved log records in a marshaling area made by calling ReserveAndAppendLog,
///ReserveAndAppendLogAligned, or AllocReservedLog. By using this function, clients can free an aggregate set of records
///and bytes that are reserved in the marshaling area.
///Params:
///    pvMarshal = A pointer to the opaque marshaling context that is allocated by using the CreateLogMarshallingArea function.
///    cReservedRecords = The number of reserved records to be freed. If the byte count of the adjustment in <i>pcbAdjustment</i> is
///                       positive, <i>cReservedRecords</i> is the total number of reserved records that are remaining after the
///                       adjustment. Otherwise, this parameter specifies the number of records to be subtracted from the current number of
///                       reserved records, but can never exceed the reserved count.
///    pcbAdjustment = The number of bytes of reservation space affected by the adjustment. On input, if this number is positive, it
///                    specifies the total remaining size of the reserved space after the adjustment. If this parameter is negative, its
///                    absolute value is the number of bytes to be freed. This value is usually an aggregate of the actual reserved
///                    space that is returned in a previous call to the following: <ul> <li> ReserveAndAppendLog </li> <li>
///                    ReserveAndAppendLogAligned </li> <li> AllocReservedLog </li> </ul>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL FreeReservedLog(void* pvMarshal, uint cReservedRecords, long* pcbAdjustment);

///Returns a buffer that contains metadata about a specified log and its current state, which is defined by the
///CLFS_INFORMATION structure. Data that is obtained reflects the state of the log only at the time when the call is
///made. Typically, a client can continue to cache and use fields from this structure until the next time that it
///appends records or writes its restart area. At that time, some of the information becomes stale.
///Params:
///    hLog = A handle to an open log that is obtained from a successful call to CreateLogFile. The log handle can refer to a
///           dedicated or multiplexed log.
///    pinfoBuffer = A pointer to a user-allocated CLFS_INFORMATION structure that receives the log metadata.
///    cbBuffer = A pointer to a variable that on input specifies the size, in bytes, of the metadata buffer pointed to by
///               <i>pinfoBuffer</i>. On output, it specifies the number of bytes that are actually copied into <i>pinfoBuffer</i>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL GetLogFileInformation(HANDLE hLog, CLS_INFORMATION* pinfoBuffer, uint* cbBuffer);

///Enables or disables log archive support for a specified log.
///Params:
///    hLog = A handle to the log that is obtained from CreateLogFile.
///    eMode = Specifies whether to make the log ephemeral. This parameter can be one of the following values. <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ClfsLogArchiveEnabled"></a><a
///            id="clfslogarchiveenabled"></a><a id="CLFSLOGARCHIVEENABLED"></a><dl> <dt><b>ClfsLogArchiveEnabled</b></dt>
///            <dt></dt> </dl> </td> <td width="60%"> Enable log archive (ephemeral logs) support. </td> </tr> <tr> <td
///            width="40%"><a id="ClfsLogArchiveDisabled"></a><a id="clfslogarchivedisabled"></a><a
///            id="CLFSLOGARCHIVEDISABLED"></a><dl> <dt><b>ClfsLogArchiveDisabled</b></dt> <dt></dt> </dl> </td> <td
///            width="60%"> Disables ephemeral logs. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError.
///    
@DllImport("clfsw32")
BOOL SetLogArchiveMode(HANDLE hLog, CLFS_LOG_ARCHIVE_MODE eMode);

///Returns the last restart area that is written successfully to the log associated with the marshaling area of
///WriteLogRestartArea. The function also returns a read context that allows the caller to cursor backward or forward
///through a log from the restart record. This read context is useful when scanning through previous restart areas prior
///to the current one by invoking ReadPreviousLogRestartArea.
///Params:
///    pvMarshal = A pointer to a marshaling context that is allocated by using the CreateLogMarshallingArea function.
///    ppvRestartBuffer = A pointer to a variable that receives a pointer to the restart data in the log I/O block.
///    pcbRestartBuffer = A pointer to a variable that receives the amount of restart data.
///    plsn = A pointer to a CLFS_LSN structure that receives the log sequence number (LSN) of the restart area.
///    ppvContext = A pointer to a variable that receives a pointer to a system-allocated read context when a read is successful. If
///                 the function defers completion of an operation, it returns a valid read-context pointer and an error status of
///                 <b>ERROR_IO_PENDING</b>. On all other errors, the read-context pointer is <b>NULL</b>. For more information about
///                 handling deferred completion of the function, see the Remarks section of this topic. After obtaining all
///                 requested log records, the client must pass the read context to TerminateReadLog to free the associated memory.
///                 Failure to do so results in memory leakage. <div class="alert"><b>Note</b> Common Log File System (CLFS) read
///                 contexts are not thread-safe. They should not be used by more than one thread at a time, or passed into more than
///                 one asynchronous read at a time.</div> <div> </div>
///    pOverlapped = A pointer to an OVERLAPPED structure that is required for asynchronous operation. This parameter can be
///                  <b>NULL</b> if an asynchronous operation is not used.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL ReadLogRestartArea(void* pvMarshal, void** ppvRestartBuffer, uint* pcbRestartBuffer, CLS_LSN* plsn, 
                        void** ppvContext, OVERLAPPED* pOverlapped);

///Reads the previous log restart area that is relative to the current restart record specified in the read context,
///<i>pvReadContext</i>. This read context is the one previously created by a call to ReadLogRestartArea.
///Params:
///    pvReadContext = A pointer to a system-allocated read context that ReadLogRestartArea returns. Even when those functions return
///                    <b>ERROR_IO_PENDING</b>, they still return a pointer to a valid read context. For information about asynchronous
///                    completion, see the Remarks section of this topic.
///    ppvRestartBuffer = A pointer to a variable that receives a pointer to the restart data.
///    pcbRestartBuffer = A pointer to a variable that receives the size of the restart data at <i>*ppvRestartBuffer</i>, in bytes.
///    plsnRestart = A pointer to a CLFS_LSN structure that receives the log sequence number (LSN) of the restart area that this
///                  function returns.
///    pOverlapped = A pointer to an OVERLAPPED structure that is required for asynchronous operation. This parameter can be
///                  <b>NULL</b> if asynchronous operation is not used.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL ReadPreviousLogRestartArea(void* pvReadContext, void** ppvRestartBuffer, uint* pcbRestartBuffer, 
                                CLS_LSN* plsnRestart, OVERLAPPED* pOverlapped);

///Appends a new client restart area to a log, and optionally advances the base log sequence number (LSN) of the log.
///After it is successfully written to a disk, the last LSN of the log is changed to the LSN of the appended restart
///record. Typically, <b>WriteLogRestartArea</b> is used by applications that regularly save a known good state, and the
///restart area contains the LSNs for existing log record chains.
///Params:
///    pvMarshal = A pointer to the marshaling context that is allocated by using the CreateLogMarshallingArea function.
///    pvRestartBuffer = A pointer to a buffer that contains restart data.
///    cbRestartBuffer = The size of <i>pvRestartBuffer</i>, in bytes.
///    plsnBase = A pointer to a CLFS_LSN structure that specifies the new base LSN of the log after successfully writing the
///               restart area. This value cannot be outside the range of the active log. It must be at least the value of the
///               current base LSN, and not greater than the LSN that was returned in the <i>lastLSN</i> parameter from the latest
///               call to ReserveAndAppendLog. If you omit this optional parameter, the base LSN does not change.
///    fFlags = The flags that specify the behavior of this function. One or more of the following values can be combined.
///             <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CLFS_FLAG_NO_FLAGS"></a><a
///             id="clfs_flag_no_flags"></a><dl> <dt><b>CLFS_FLAG_NO_FLAGS</b></dt> </dl> </td> <td width="60%"> Assigns no
///             flags. </td> </tr> <tr> <td width="40%"><a id="CLFS_FLAG_USE_RESERVATION"></a><a
///             id="clfs_flag_use_reservation"></a><dl> <dt><b>CLFS_FLAG_USE_RESERVATION</b></dt> </dl> </td> <td width="60%">
///             Appends the current record by using the space that is reserved in the marshaling area. </td> </tr> </table>
///    pcbWritten = A pointer to a variable that receives the number of bytes that are written when an operation completes.
///    plsnNext = A pointer to a CLFS_LSN structure that specifies the LSN of the restart area that is written.
///    pOverlapped = A pointer to an OVERLAPPED structure. This parameter can be <b>NULL</b> if an asynchronous operation is not used.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL WriteLogRestartArea(void* pvMarshal, void* pvRestartBuffer, uint cbRestartBuffer, CLS_LSN* plsnBase, 
                         uint fFlags, uint* pcbWritten, CLS_LSN* plsnNext, OVERLAPPED* pOverlapped);

@DllImport("clfsw32")
BOOL GetLogReservationInfo(void* pvMarshal, uint* pcbRecordNumber, long* pcbUserReservation, 
                           long* pcbCommitReservation);

///Advances the base log sequence number (LSN) of a log stream to the specified LSN.
///Params:
///    pvMarshal = A pointer to the marshaling context that a successful call to CreateLogMarshallingArea returns.
///    plsnBase = The new base LSN for the log that is specified in <i>pvMarshal</i>. This LSN must be in the range between the
///               current base LSN and the last LSN of the log, inclusively.
///    fFlags = This parameter is not implemented at this time, and must be zero.
///    pOverlapped = A pointer to an OVERLAPPED structure that is required for asynchronous operation. If asynchronous operation is
///                  not used, this parameter can be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL AdvanceLogBase(void* pvMarshal, CLS_LSN* plsnBase, uint fFlags, OVERLAPPED* pOverlapped);

///Resets the log file and then shuts the log. This nullifies any client restart areas and resets the base log sequence
///number (LSN) for the log. You do not need to close a log stream handle after calling this function.
///Params:
///    hLog = A handle to a dedicated or multiplexed log. This handle is returned by a successful call to CreateLogFile. It is
///           invalidated on successful completion of the call. No other operations that use this handle, or a derivative of
///           this handle, can be called after this function has returned.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL CloseAndResetLogFile(HANDLE hLog);

///Creates a marshaling area for a log, and when successful it returns a marshaling context. Before creating a
///marshaling area, the log must have at least one container. The marshaling context is used to append records to or
///read records from a log. Because records are always stored in log blocks, they must pass through the marshaling
///context. Log records are written by calling ReserveAndAppendLog.
///Params:
///    hLog = A handle to the log that is obtained from CreateLogFile. The log handle can refer to a dedicated or multiplexed
///           log.
///    pfnAllocBuffer = The callback function that allocates memory for log blocks. If this parameter is <b>NULL</b>, the Common Log File
///                     System (CLFS) provides a default block allocation function. This parameter cannot be <b>NULL</b> if a
///                     block-freeing callback is specified by using the <i>pfnFreeBuffer</i> parameter. The following example identifies
///                     the syntax of the block allocation callback function: <code>typedef PVOID (* CLFS_BLOCK_ALLOCATION) (ULONG
///                     cbBufferSize, PVOID pvUserContext);</code>
///    pfnFreeBuffer = The callback function that frees log blocks allocated by <i>pfnAllocBuffer</i>. If this parameter is <b>NULL</b>,
///                    CLFS provides a default block deallocation function. This parameter cannot be <b>NULL</b> if a block allocation
///                    callback is specified by using the <i>pfnAllocBuffer</i> parameter. The following example identifies the syntax
///                    of the block-freeing callback function: <code>typedef void (* CLFS_BLOCK_DEALLOCATION) (PVOID pvBuffer, PVOID
///                    pvUserContext);</code> The <i>buffer</i> parameter of "ClfsBlockDeallocProc" must point to a block that is
///                    allocated by using the callback pointed to by <i>pfnAllocBuffer</i>.
///    pvBlockAllocContext = A pointer to a buffer that is passed back as a user context to the block allocation and deallocation routines, if
///                          a buffer is specified. If <i>pfnAllocBuffer</i> is <b>NULL</b>, this parameter is ignored.
///    cbMarshallingBuffer = The size, in bytes, of the individual log I/O blocks that will be used by the new marshaling area. This must be a
///                          multiple of the sector size on the stable storage medium. The sector size is the value returned in the
///                          <i>lpBytesPerSector</i> parameter of the GetDiskFreeSpace function. Records cannot be appended or read if they
///                          are longer than this value.
///    cMaxWriteBuffers = The maximum number of blocks that can be allocated at any time for write operations. This value can affect the
///                       frequency of data flushes. If you do not need to specify a limit to control the frequency of the data flush
///                       cycle, specify INFINITE.
///    cMaxReadBuffers = The maximum number of blocks that can be allocated at any time for read operations. Read contexts use at least
///                      one read block.
///    ppvMarshal = A pointer to the marshaling context that CLFS allocates when <b>CreateLogMarshallingArea</b> completes
///                 successfully. This context must be used with all read, append, write, and flush operations to log marshaling
///                 areas. All operations that access marshaling areas by using a marshaling context are thread-safe. This parameter
///                 is <b>NULL</b> if the operation is not successful.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL CreateLogMarshallingArea(HANDLE hLog, CLFS_BLOCK_ALLOCATION pfnAllocBuffer, 
                              CLFS_BLOCK_DEALLOCATION pfnFreeBuffer, void* pvBlockAllocContext, 
                              uint cbMarshallingBuffer, uint cMaxWriteBuffers, uint cMaxReadBuffers, 
                              void** ppvMarshal);

///Deletes a marshaling area that is created by a successful call to CreateLogMarshallingArea. When you delete a
///marshaling area it does the following:<ul> <li>Flushes the log to free pending log I/O blocks</li> <li>Deallocates
///all log I/O blocks and invalidates all read contexts</li> </ul> The memory allocated by Common Log File System (CLFS)
///to create the marshaling context is reclaimed when all read contexts are terminated. <div class="alert"><b>Note</b>
///Clients should not delete a marshaling area if there are pending operations on the marshaling area.</div><div> </div>
///Params:
///    pvMarshal = A pointer to the opaque marshaling context allocated by using the CreateLogMarshallingArea function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL DeleteLogMarshallingArea(void* pvMarshal);

///Reserves space for log buffers, or appends a log record to the log, or does both. The function is atomic.
///Params:
///    pvMarshal = A pointer to a marshaling context that is allocated by using the CreateLogMarshallingArea function.
///    rgWriteEntries = A pointer to an array of CLFS_WRITE_ENTRY buffers to be marshaled into one record. This parameter is ignored if
///                     the <i>cWriteEntries</i> parameter is zero.
///    cWriteEntries = The number of write entries in the <i>rgWriteEntries</i> array. If this value is nonzero, you must specify a
///                    buffer in the <i>rgWriteEntries</i> parameter.
///    plsnUndoNext = A pointer to a CLFS_LSN structure that specifies the log sequence number (LSN) of the next record in the
///                   undo-chain.
///    plsnPrevious = A pointer to a CLFS_LSN structure that specifies the LSN of the previous record in the previous-chain.
///    cReserveRecords = The number of record sizes in the <i>rgcbReservation</i> array.
///    rgcbReservation = A pointer to an array of reservation sizes for each record that the <i>cReserveRecords</i> parameter specifies.
///                      This parameter is ignored if the <i>cReserveRecords</i> parameter is zero. If a reservation size is negative, a
///                      reservation of that size is released. The actual space that is reserved for each record, including required
///                      overhead, is returned in the individual array elements on successful completion. These values can be passed to
///                      the FreeReservedLog function to adjust space that is reserved in the marshaling area.
///    fFlags = The flags that specify the behavior of this function. One or more of the following values can be combined.
///             <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CLFS_FLAG_FORCE_APPEND"></a><a
///             id="clfs_flag_force_append"></a><dl> <dt><b>CLFS_FLAG_FORCE_APPEND</b></dt> </dl> </td> <td width="60%"> Assigns
///             a physical location for all appended records in a log that have not been previously assigned a physical location.
///             All these records are made available for reading from other marshaling contexts. </td> </tr> <tr> <td
///             width="40%"><a id="CLFS_FLAG_FORCE_FLUSH"></a><a id="clfs_flag_force_flush"></a><dl>
///             <dt><b>CLFS_FLAG_FORCE_FLUSH</b></dt> </dl> </td> <td width="60%"> Assigns a physical location for all appended
///             records in a log that have not been previously assigned a physical location. All these records are made available
///             for reading from other marshaling contexts. Then, the records are flushed to disk. </td> </tr> <tr> <td
///             width="40%"><a id="CLFS_FLAG_NO_FLAGS"></a><a id="clfs_flag_no_flags"></a><dl> <dt><b>CLFS_FLAG_NO_FLAGS</b></dt>
///             </dl> </td> <td width="60%"> Assigns no flags. </td> </tr> <tr> <td width="40%"><a
///             id="CLFS_FLAG_USE_RESERVATION"></a><a id="clfs_flag_use_reservation"></a><dl>
///             <dt><b>CLFS_FLAG_USE_RESERVATION</b></dt> </dl> </td> <td width="60%"> Appends the current record by using the
///             space that is reserved in the marshaling area. </td> </tr> </table>
///    plsn = A pointer to a CLFS_LSN structure that receives the LSN of the appended record.
///    pOverlapped = A pointer to an OVERLAPPED structure. This parameter can be <b>NULL</b> if asynchronous operation is not used.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("clfsw32")
BOOL ReserveAndAppendLog(void* pvMarshal, CLS_WRITE_ENTRY* rgWriteEntries, uint cWriteEntries, 
                         CLS_LSN* plsnUndoNext, CLS_LSN* plsnPrevious, uint cReserveRecords, long* rgcbReservation, 
                         uint fFlags, CLS_LSN* plsn, OVERLAPPED* pOverlapped);

///Reserves space for log buffers, or appends a log record to the log, or both. This function is like the
///ReserveAndAppendLog function, but <b>ReserveAndAppendLogAligned</b> aligns the write entries of the record to the
///specified byte alignment.
///Params:
///    pvMarshal = A pointer to a marshaling context that is allocated by using the CreateLogMarshallingArea function.
///    rgWriteEntries = A pointer to an array of CLFS_WRITE_ENTRY buffers to be marshaled into one record. This parameter is ignored if
///                     the <i>cWriteEntries</i> parameter is zero.
///    cWriteEntries = The number of write entries in the <i>rgWriteEntries</i> array. If this value is nonzero, you must specify a
///                    buffer in the <i>rgWriteEntries</i> parameter.
///    cbEntryAlignment = The byte alignment for each write entry in the <i>rgWriteEntries</i> parameter. Specify 1 (one) for a simple
///                       concatenation. The <i>cbWriteEntryAlignment</i> parameter must be nonzero.
///    plsnUndoNext = A pointer to a CLFS_LSN structure that specifies the log sequence number (LSN) of the next record in the
///                   undo-chain.
///    plsnPrevious = A pointer to a CLFS_LSN structure that specifies the LSN of the previous record in the previous-chain.
///    cReserveRecords = The number of record sizes in the <i>rgcbReservation</i> array.
///    rgcbReservation = A pointer to an array of reservation sizes for each record that the <i>cReserveRecords</i> parameter specifies.
///                      This parameter is ignored if the <i>cReserveRecords</i> parameter is zero. If a reservation size is negative, a
///                      reservation of that size is released. The actual space that is reserved for each record, including required
///                      overhead, is returned in the individual array elements on successful completion. These values can be passed to
///                      the FreeReservedLog function to adjust space that is reserved in the marshaling area.
///    fFlags = The flags that specify the behavior of this function. One or more of the following values can be combined.
///             <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CLFS_FLAG_FORCE_APPEND"></a><a
///             id="clfs_flag_force_append"></a><dl> <dt><b>CLFS_FLAG_FORCE_APPEND</b></dt> </dl> </td> <td width="60%"> Assigns
///             a physical location for all appended records in the log that are not previously assigned a physical location. All
///             these records are made available for reading from other marshaling contexts. </td> </tr> <tr> <td width="40%"><a
///             id="CLFS_FLAG_FORCE_FLUSH"></a><a id="clfs_flag_force_flush"></a><dl> <dt><b>CLFS_FLAG_FORCE_FLUSH</b></dt> </dl>
///             </td> <td width="60%"> Assigns a physical location for all appended records in the log that are not previously
///             assigned a physical location. All these records are made available for reading from other marshaling contexts.
///             Then, the records are flushed to disk. </td> </tr> <tr> <td width="40%"><a id="CLFS_FLAG_NO_FLAGS"></a><a
///             id="clfs_flag_no_flags"></a><dl> <dt><b>CLFS_FLAG_NO_FLAGS</b></dt> </dl> </td> <td width="60%"> Assigns no
///             flags. </td> </tr> <tr> <td width="40%"><a id="CLFS_FLAG_USE_RESERVATION"></a><a
///             id="clfs_flag_use_reservation"></a><dl> <dt><b>CLFS_FLAG_USE_RESERVATION</b></dt> </dl> </td> <td width="60%">
///             Appends the current record by using the space that is reserved in the marshaling area. </td> </tr> </table>
///    plsn = A pointer to a CLFS_LSN structure that receives the LSN of the appended record.
///    pOverlapped = A pointer to an OVERLAPPED structure. This parameter can be <b>NULL</b> if asynchronous operation is not used.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("clfsw32")
BOOL ReserveAndAppendLogAligned(void* pvMarshal, CLS_WRITE_ENTRY* rgWriteEntries, uint cWriteEntries, 
                                uint cbEntryAlignment, CLS_LSN* plsnUndoNext, CLS_LSN* plsnPrevious, 
                                uint cReserveRecords, long* rgcbReservation, uint fFlags, CLS_LSN* plsn, 
                                OVERLAPPED* pOverlapped);

///Forces all records appended to this marshaling area to be flushed to disk. This service is a special case of
///FlushLogToLsn with the target log sequence number (LSN) set to <b>CLFS_LSN_NULL</b>.
///Params:
///    pvMarshal = A pointer to the marshaling context that is allocated by using the CreateLogMarshallingArea function.
///    pOverlapped = A pointer to an OVERLAPPED structure that is required for asynchronous operation. This parameter can be
///                  <b>NULL</b> if asynchronous operation is not used.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL FlushLogBuffers(void* pvMarshal, OVERLAPPED* pOverlapped);

///Forces all records appended to this marshaling area up to the record with the specified log sequence number (LSN) to
///be flushed to the disk. More records than specified may be flushed during this operation.
///Params:
///    pvMarshalContext = A pointer to the marshaling context that is allocated by using the CreateLogMarshallingArea function.
///    plsnFlush = A pointer to a CLFS_LSN structure that specifies the LSN that is used to determine which records to flush.
///                Specify CLFS_LSN_NULL to flush all records in the marshaling area.
///    plsnLastFlushed = A pointer to a CLFS_LSN structure. The LSN returned is greater than the LSN of any record flushed. If the
///                      function succeeds, the value of the LSN is never less than <i>plsnFlush</i>. This value is meaningful only when
///                      the function succeeds.
///    pOverlapped = A pointer to an OVERLAPPED structure that is required for asynchronous operation. This parameter can be
///                  <b>NULL</b> except for an asynchronous operation.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL FlushLogToLsn(void* pvMarshalContext, CLS_LSN* plsnFlush, CLS_LSN* plsnLastFlushed, OVERLAPPED* pOverlapped);

///Initiates a sequence of reads from a specified log sequence number (LSN) in one of three modes, and returns the first
///of the specified log records and a read context. A client can read subsequent records in the designated mode by
///passing the read context to ReadNextLogRecord.
///Params:
///    pvMarshal = A pointer to a marshaling context that is allocated by using the CreateLogMarshallingArea function.
///    plsnFirst = A pointer to a CLFS_LSN structure that specifies the log sequence number (LSN) of the record where the read
///                operation should start. This value must be an LSN of a valid record in the active range of the log.
///    eContextMode = The mode for the read context that is returned in <i>*ppvReadContext</i>. The following table identifies the
///                   three mutually exclusive read modes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                   id="ClfsContextPrevious"></a><a id="clfscontextprevious"></a><a id="CLFSCONTEXTPREVIOUS"></a><dl>
///                   <dt><b>ClfsContextPrevious</b></dt> </dl> </td> <td width="60%"> Reads the record linked to by
///                   <i>plsnPrevious</i>. </td> </tr> <tr> <td width="40%"><a id="ClfsContextUndoNext"></a><a
///                   id="clfscontextundonext"></a><a id="CLFSCONTEXTUNDONEXT"></a><dl> <dt><b>ClfsContextUndoNext</b></dt> </dl> </td>
///                   <td width="60%"> Reads the record chain linked to by <i>plsnUndoNext</i>. </td> </tr> <tr> <td width="40%"><a
///                   id="ClfsContextForward"></a><a id="clfscontextforward"></a><a id="CLFSCONTEXTFORWARD"></a><dl>
///                   <dt><b>ClfsContextForward</b></dt> </dl> </td> <td width="60%"> Reads the record with the LSN that immediately
///                   follows the current LSN in the read context. </td> </tr> </table>
///    ppvReadBuffer = A pointer to a variable that receives a pointer to the target record in the log I/O block.
///    pcbReadBuffer = A pointer to a variable that receives the size of the data that is returned in <i>*ppvReadBuffer</i>, in bytes.
///    peRecordType = A pointer to a variable that receives the type of record read. This parameter is one of the CLFS_RECORD_TYPE
///                   Constants.
///    plsnUndoNext = A pointer to a CLFS_LSN structure that receives the LSN of the next record in the undo record chain.
///    plsnPrevious = A pointer to a CLFS_LSN structure that receives the LSN of the next record in the previous record chain.
///    ppvReadContext = A pointer to a variable that receives a pointer to a system-allocated read context when a read is successful. If
///                     the function defers completion of an operation, it returns a valid read-context pointer and an error status of
///                     <b>ERROR_IO_PENDING</b>. On all other errors, the read-context pointer is <b>NULL</b>. For more information about
///                     handling deferred completion of the function, see the Remarks section of this topic. After obtaining all
///                     requested log records, the client must pass the read context to TerminateReadLog to free the associated memory.
///                     Failure to do so results in memory leakage. <div class="alert"><b>Note</b> Common Log File System (CLFS) read
///                     contexts are not thread-safe. They should not be used by more than one thread at a time, or passed into more than
///                     one asynchronous read at a time.</div> <div> </div>
///    pOverlapped = A pointer to an OVERLAPPED structure, which is required for asynchronous operation. This parameter can be
///                  <b>NULL</b> if asynchronous operation is not used.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes.
///    
@DllImport("clfsw32")
BOOL ReadLogRecord(void* pvMarshal, CLS_LSN* plsnFirst, CLFS_CONTEXT_MODE eContextMode, void** ppvReadBuffer, 
                   uint* pcbReadBuffer, ubyte* peRecordType, CLS_LSN* plsnUndoNext, CLS_LSN* plsnPrevious, 
                   void** ppvReadContext, OVERLAPPED* pOverlapped);

///Reads the next record in a sequence that is initiated by a call to ReadLogRecord or ReadLogRestartArea. By using
///<b>ReadNextLogRecord</b> iteratively, a client can read all records of a specified type in a log. The direction of
///enumeration is determined by specifying the context mode when beginning the read sequence.
///Params:
///    pvReadContext = A pointer to a read context that the system allocates and creates during a successful call to ReadLogRecord or
///                    ReadLogRestartArea. If the function defers completion of an operation, it returns a pointer to a valid read
///                    context and an error status of <b>ERROR_IO_PENDING</b>. For information about handling asynchronous completion,
///                    see the Remarks section of this topic.
///    ppvBuffer = A pointer to a variable that receives a pointer to the read data.
///    pcbBuffer = A pointer to a variable that receives the size of the read data that is returned in <i>ppvReadBuffer</i>, in
///                bytes.
///    peRecordType = A pointer that, on input, specifies the record type filter of the next record read, and on output specifies the
///                   record type that is returned. Clients can specify any of the following record types. <table> <tr> <th>Value</th>
///                   <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ClfsDataRecord"></a><a id="clfsdatarecord"></a><a
///                   id="CLFSDATARECORD"></a><dl> <dt><b>ClfsDataRecord</b></dt> </dl> </td> <td width="60%"> Only user-data records
///                   are read. </td> </tr> <tr> <td width="40%"><a id="ClfsRestartRecord"></a><a id="clfsrestartrecord"></a><a
///                   id="CLFSRESTARTRECORD"></a><dl> <dt><b>ClfsRestartRecord</b></dt> </dl> </td> <td width="60%"> Only restart
///                   records are read. </td> </tr> <tr> <td width="40%"><a id="ClfsClientRecord"></a><a id="clfsclientrecord"></a><a
///                   id="CLFSCLIENTRECORD"></a><dl> <dt><b>ClfsClientRecord</b></dt> </dl> </td> <td width="60%"> All restart and data
///                   records are read. </td> </tr> </table>
///    plsnUser = A pointer to a CLFS_LSN structure that specifies the log client to read this log sequence number (LSN) as the
///               next LSN instead of reading forward to the next record, reading the previous LSN, or reading the next undo LSN.
///               This parameter gives log clients the ability to cursor through user-defined LSN chains in client buffers. The
///               relationship of this parameter to the current LSN held by the read context must be consistent with the context
///               mode, <i>ecxMode</i>, that is specified in the ReadLogRecord entry points; otherwise, an error code of
///               <b>ERROR_INVALID_PARAMETER</b> is returned.
///    plsnUndoNext = A pointer to a CLFS_LSN structure that receives the LSN of the next record in an undo record chain.
///    plsnPrevious = A pointer to a CLFS_LSN structure that receives the LSN of the next record in the previous record chain.
///    plsnRecord = A pointer to a CLFS_LSN structure that receives the LSN of the current record read into the read context.
///    pOverlapped = A pointer to an OVERLAPPED structure that is required for asynchronous operation. This parameter can be
///                  <b>NULL</b> if asynchronous operation is not used.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL ReadNextLogRecord(void* pvReadContext, void** ppvBuffer, uint* pcbBuffer, ubyte* peRecordType, 
                       CLS_LSN* plsnUser, CLS_LSN* plsnUndoNext, CLS_LSN* plsnPrevious, CLS_LSN* plsnRecord, 
                       OVERLAPPED* pOverlapped);

///Terminates a read context. This function frees system-allocated resources associated with the specified read context.
///Do not attempt to read log records after calling this function; you will receive indeterminate results.
///Params:
///    pvCursorContext = A pointer to a read context that is returned by ReadLogRecord or ReadLogRestartArea.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL TerminateReadLog(void* pvCursorContext);

///Prepares a physical log for archival. The function takes a snapshot of the current active log, builds an ordered set
///of log archive descriptors for the active log extents, and returns a log archive context. By passing this log archive
///context to GetNextLogArchiveExtent, a client can iterate through the set of log archive extents to archive the log.
///You can also specify a range of records to archive.
///Params:
///    hLog = A handle to the log that is obtained by a successful call to CreateLogFile. This handle can be the handle to a
///           dedicated or multiplexed log.
///    pszBaseLogFileName = A pointer to a user-allocated buffer to receive the fully qualified path of the base log. If the buffer is not
///                         large enough, it contains a truncated file path on exit, and the function fails with an
///                         <i>ERROR_BUFFER_OVERFLOW</i> status code. The length of the file path is returned in the variable pointed to by
///                         <i>pcActualLength</i>. The client can re-attempt a failed call with a name buffer that is large enough.
///    cLen = The size of the <i>pszBaseLogFileName</i> buffer, in wide characters.
///    plsnLow = A pointer to a CLFS_LSN structure that specifies the log sequence number (LSN) of the low end of the range of the
///              active log where the log client needs log archival information. If this parameter is omitted, the low end of the
///              range defaults to the LSN of the log archive tail.
///    plsnHigh = A pointer to a CLFS_LSN structure that specifies the LSN of the high end of the range of the active log where the
///               log client needs log archival information. If this parameter is omitted, the high end of the range defaults to
///               the next LSN to be written to the log.
///    pcActualLength = A pointer to a variable that receives the actual length of the name of the base log path, in characters. If this
///                     value is greater than <i>cLen</i>, the function returns an ERROR_BUFFER_OVERFLOW status with a truncated path
///                     that is stored in the <i>pszBaseLogFileName</i> buffer and all other out parameters that are not set to
///                     meaningful values.
///    poffBaseLogFileData = A pointer to a variable that receives the offset where the metadata begins in the base log. The contiguous extent
///                          in the base log <i>pszBaseLogFileName</i> represents the full contents of the log metadata—that is, from
///                          <i>poffBaseLogFileData</i> to <i>pcbBaseLogFileLength</i>.
///    pcbBaseLogFileLength = A pointer to a variable that specifies the exact length of the base log, in bytes.
///    plsnBase = A pointer to a CLFS_LSN structure to receive the base log sequence number (LSN) of the active log.
///    plsnLast = A pointer to a CLFS_LSN structure to receive the highest valid LSN in the active log.
///    plsnCurrentArchiveTail = A pointer to a CLFS_LSN structure to receive the current LSN of the archive tail of the log.
///    ppvArchiveContext = A pointer to the variable that receives a pointer to an archive context that the system allocates. The archive
///                        context maintains the cursor state of the archival iterator and the log handle context. The archival client is
///                        responsible for releasing the context by calling TerminateLogArchive.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL PrepareLogArchive(HANDLE hLog, const(wchar)* pszBaseLogFileName, uint cLen, const(CLS_LSN)* plsnLow, 
                       const(CLS_LSN)* plsnHigh, uint* pcActualLength, ulong* poffBaseLogFileData, 
                       ulong* pcbBaseLogFileLength, CLS_LSN* plsnBase, CLS_LSN* plsnLast, 
                       CLS_LSN* plsnCurrentArchiveTail, void** ppvArchiveContext);

///Copies a range of the archive view of the metadata to the specified buffer.
///Params:
///    pvArchiveContext = A pointer to an archive context that is obtained by a call to PrepareLogArchive. The context maintains the cursor
///                       state, which allows iteration through the set of file extents in the archive. The archive client is responsible
///                       for deallocating the context by using the TerminateLogArchive function.
///    cbOffset = The offset in the metadata where data copying starts. On the first call to this function, specify zero (0). On
///               subsequent calls, specify the value that is returned in <i>pcbBytesRead</i>.
///    cbBytesToRead = The number of bytes of the metadata snapshot should be copied into <i>pbReadBuffer</i>. This parameter cannot be
///                    zero (0).
///    pbReadBuffer = A pointer to the buffer where the metadata snapshot is copied.
///    pcbBytesRead = A pointer to a variable that receives the number of bytes that are copied to <i>pbReadBuffer</i>. The number of
///                   bytes is always between zero (0) and <i>cbBytesToRead</i>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL ReadLogArchiveMetadata(void* pvArchiveContext, uint cbOffset, uint cbBytesToRead, ubyte* pbReadBuffer, 
                            uint* pcbBytesRead);

///Retrieves the next set of archive extents in a log archive context. The log archive context describes a contiguous
///set of file extents that span the snapshot of the active log captured by PrepareLogArchive captures.
///<b>GetNextLogArchiveExtent</b> maintains a cursor in the ordered set of log archive descriptors so that subsequent
///calls allow an application to iterate through the entire set.
///Params:
///    pvArchiveContext = A pointer to an archive context that is obtained by a call to PrepareLogArchive. The context maintains the cursor
///                       state, which allows iteration through the set of file extents in the archive. The archive client is responsible
///                       for deallocating the context by using the TerminateLogArchive function.
///    rgadExtent = A client-allocated array of CLFS_ARCHIVE_DESCRIPTOR structures to be filled in by this function.
///    cDescriptors = The number of elements in the <i>rgadExtent</i> array. This value is the maximum number of archive descriptors
///                   that can be retrieved by this function.
///    pcDescriptorsReturned = The number of descriptors in the <i>rgadExtent</i> array that are filled in by this function. If this value is
///                            less than <i>cDescriptors</i>, the set of descriptors is exhausted and the archive client can terminate iteration
///                            through the ordered descriptor set. Further calls to this function fail with ERROR_NO_MORE_ENTRIES.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL GetNextLogArchiveExtent(void* pvArchiveContext, CLS_ARCHIVE_DESCRIPTOR* rgadExtent, uint cDescriptors, 
                             uint* pcDescriptorsReturned);

///Deallocates system resources that are allocated originally for a log archive context by PrepareLogArchive.
///Params:
///    pvArchiveContext = The archive context that is obtained from PrepareLogArchive.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following error code is possible:
///    
@DllImport("clfsw32")
BOOL TerminateLogArchive(void* pvArchiveContext);

///Validates the consistency of the log metadata and data before log archive and after log restore.
///Params:
///    pszLogFileName = The name of the log. The name is specified when creating the log by using CreateLogFile. The following example
///                     identifies the format to use:
///                     <i>Log</i><b>:&lt;</b><i>LogName</i><b>&gt;[::&lt;</b><i>LogStreamName</i><b>&gt;]</b>
///                     <b>&lt;</b><i>LogName</i><b>&gt;</b> corresponds to a valid file path in the file system.
///                     <b>&lt;</b><i>LogStreamName</i><b>&gt;</b> is the unique name of a log stream in the dedicated log. For more
///                     information, see Log Types.
///    psaLogFile = A pointer to a SECURITY_ATTRIBUTES structure that specifies the security attributes of a log. This parameter can
///                 be <b>NULL</b>.
///    pinfoBuffer = A pointer to a CLFS_INFORMATION structure that receives log metadata.
///    pcbBuffer = A pointer to a variable that, on input, specifies the size of the <i>pinfoBuffer</i> metadata buffer, in bytes.
///                On output, it receives the amount of information that is copied to the buffer, in bytes.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL ValidateLog(const(wchar)* pszLogFileName, SECURITY_ATTRIBUTES* psaLogFile, CLS_INFORMATION* pinfoBuffer, 
                 uint* pcbBuffer);

///Retrieves the full path name of the specified container. This function is used mainly to obtain the full path name of
///a container referenced in the CLFS_CONTAINER_INFORMATION structure that is returned in calls to ScanLogContainers.
///Params:
///    hLog = A handle to the log that is obtained from a successful call to CreateLogFile. The log handle could refer to a log
///           stream or a physical log.
///    cidLogicalContainer = The unique identifier that is associated with a container.
///    pwstrContainerName = A pointer to a user-allocated buffer to receive the full path and name of the log container, in wide characters.
///    cLenContainerName = The size of the buffer pointed to by <i>pwstrContainerName</i>, in characters.
///    pcActualLenContainerName = A pointer to a variable to receive the actual character count of the full container path name that is retrieved.
///                               If the function succeeds, the value of this parameter is less than or equal to <i>cLenContainerName</i>. If the
///                               buffer is not large enough to store the whole container path name, the function fails with <b>ERROR_MORE_DATA</b>
///                               and sets this parameter to the size that is required for the full path name. For other failures the value is not
///                               defined.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL GetLogContainerName(HANDLE hLog, uint cidLogicalContainer, const(wchar)* pwstrContainerName, 
                         uint cLenContainerName, uint* pcActualLenContainerName);

///Retrieves log I/O statistics for a dedicated or multiplexed log that is associated with the specified handle. This
///function queries Common Log File System (CLFS) for specific types of log I/O statistics. Calling this function on a
///multiplexed log only associates the statistics with the underlying log.
///Params:
///    hLog = A handle to an open log file that CreateLogFile gets. The log handle can refer to either a dedicated or
///           multiplexed log file.
///    pvStatsBuffer = A pointer to a buffer to receive the I/O statistics. This buffer must be at least as large as an I/O statistics
///                    packet header. For more information, see CLFS_IO_STATISTICS_HEADER.
///    cbStatsBuffer = The size of the I/O statistics buffer <i>pvStatsBuffer</i>, in bytes. If the buffer is not large enough for the
///                    statistics packet, the function fails with <b>ERROR_MORE_DATA</b>.
///    eStatsClass = This parameter is not implemented at this time; it is reserved for future use.
///    pcbStatsWritten = A pointer to a variable to receive the size of the I/O statistics packet that is written to <i>pvStatsBuffer</i>.
///                      This value is less than or equal to <i>cbStatsBuffer</i>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The following list identifies the possible error codes:
///    
@DllImport("clfsw32")
BOOL GetLogIoStatistics(HANDLE hLog, void* pvStatsBuffer, uint cbStatsBuffer, CLFS_IOSTATS_CLASS eStatsClass, 
                        uint* pcbStatsWritten);

///The <b>RegisterManageableLogClient</b> function registers a client with the log manager. A client can specify whether
///to receive notifications by using callbacks, or have the notifications queued for retrieval by using
///ReadLogNotification.
///Params:
///    hLog = The handle to the log to register. Only one registration per unique opening of the log is allowed.
///    pCallbacks = Specifies the callbacks that the client is registering for. Valid callbacks are enumerated by
///                 LOG_MANAGEMENT_CALLBACKS. Specify zero to queue notifications instead.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("clfsw32")
BOOL RegisterManageableLogClient(HANDLE hLog, LOG_MANAGEMENT_CALLBACKS* pCallbacks);

///The <b>DeregisterManageableLogClient</b> function deregisters a client with the log manager.
///Params:
///    hLog = The handle to deregister.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. For
///    extended error information, call GetLastError.
///    
@DllImport("clfsw32")
BOOL DeregisterManageableLogClient(HANDLE hLog);

///The <b>ReadLogNotification</b> function retrieves notifications from the log manager. It retrieves a queued
///notification from the log manager immediately if a notification is available; otherwise the request remains pending
///until a notification is generated.
///Params:
///    hLog = The handle to the log.
///    pNotification = Receives the notification type, and if the type has parameters associated with it, the parameters.
///    lpOverlapped = A pointer to an OVERLAPPED structure that is required for asynchronous operation. If asynchronous operation is
///                   not used, this parameter can be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following is a possible error code:
///    
@DllImport("clfsw32")
BOOL ReadLogNotification(HANDLE hLog, CLFS_MGMT_NOTIFICATION* pNotification, OVERLAPPED* lpOverlapped);

///Installs (sets) a policy for a log.
///Params:
///    hLog = A handle to a log.
///    pPolicy = A pointer to a CLFS_MGMT_POLICY structure that represents the desired policy to install.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("clfsw32")
BOOL InstallLogPolicy(HANDLE hLog, CLFS_MGMT_POLICY* pPolicy);

///Resets the specified policy to its default behavior.
///Params:
///    hLog = Handle to the log to reset the policy for.
///    ePolicyType = Specifies the policy to reset. Policy types are enumerated in CLFS_MGMT_POLICY_TYPE.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError.
///    
@DllImport("clfsw32")
BOOL RemoveLogPolicy(HANDLE hLog, CLFS_MGMT_POLICY_TYPE ePolicyType);

///The <b>QueryLogPolicy</b> function allows you to obtain a policy that is installed for the specified log.
///Params:
///    hLog = The handle to the log to query.
///    ePolicyType = Specifies the type of policy to query for. Policy types are enumerated in CLFS_MGMT_POLICY_TYPE.
///    pPolicyBuffer = A pointer to a buffer to receive the returned policies.
///    pcbPolicyBuffer = A pointer to the size of <i>pPolicyBuffer</i>. If the buffer is not large enough, <i>pcbPolicyBuffer</i> receives
///                      the size buffer required to successfully retrieve the specified policies.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError.
///    
@DllImport("clfsw32")
BOOL QueryLogPolicy(HANDLE hLog, CLFS_MGMT_POLICY_TYPE ePolicyType, CLFS_MGMT_POLICY* pPolicyBuffer, 
                    uint* pcbPolicyBuffer);

///Adds or deletes containers from a log based on the state of the installed policies.
///Params:
///    hLog = A handle to a log.
///    pDesiredSize = A pointer to a value that specifies the requested log size, expressed as one of the following values. For the
///                   actual resultant size, refer to the <i>pResultingSize</i> parameter. <table> <tr> <th>Value</th> <th>Meaning</th>
///                   </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Enforce the minimum size policy. If a
///                   minimum size policy is not installed, one of the following occurs: <ul> <li>If the log has fewer than two
///                   containers, the log will be expanded to a size of two containers.</li> <li>If the log has two or more containers,
///                   no changes are made and the function call succeeds.</li> </ul> If a minimum size policy is installed, one of the
///                   following occurs:<ul> <li>If the log has fewer than the minimum number of containers specified by the minimum
///                   size policy, the log expands to the policy-specified minimum number of containers.</li> <li>If the log has a
///                   number of containers greater than or equal to the minimum number of containers specified by the minimum size
///                   policy, no changes are made and the function call succeeds with no error.</li> </ul> For more information, see
///                   InstallLogPolicy. </td> </tr> <tr> <td width="40%"> <dl> <dt>1</dt> </dl> </td> <td width="60%"> Not a valid
///                   value; the function call fails with <b>ERROR_INVALID_PARAMETER</b>. </td> </tr> <tr> <td width="40%"> <dl>
///                   <dt>2–1023</dt> </dl> </td> <td width="60%"> The desired size of the log, expressed as the number of
///                   containers. If this number is smaller than the minimum number of containers specified by the installed policy,
///                   the function call fails with <b>ERROR_COULD_NOT_RESIZE_LOG</b>. If this number is larger than the maximum number
///                   of containers specified by the installed policy, the log expands only as far as the policy-specified maximum
///                   number of containers, and the function succeeds with no error. </td> </tr> <tr> <td width="40%"> <dl>
///                   <dt>1024–MAXULONGLONG</dt> </dl> </td> <td width="60%"> If no maximum size policy is installed, the function
///                   call fails with <b>ERROR_LOG_POLICY_CONFLICT</b>. If a maximum size policy is installed, the log expands to the
///                   maximum number of containers specified by the maximum size policy and the function succeeds with no error. </td>
///                   </tr> </table>
///    pResultingSize = A pointer to a valid ULONGLONG data variable, receives the number of containers in the resized log upon success.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call the GetLastError function.
///    
@DllImport("clfsw32")
BOOL SetLogFileSizeWithPolicy(HANDLE hLog, ulong* pDesiredSize, ulong* pResultingSize);

///The <b>HandleLogFull</b> function is called by a managed log client when an attempt to reserve or append to a log
///fails with a log full error message. The log manager attempts to resolve the log full condition for the client, and
///notifies the client when the outcome is known. As a result of this call, the log may get larger in size.
///Params:
///    hLog = A handle to the log on which to resolve the log full condition. The handle must have been registered with
///           RegisterManageableLogClient.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Valid values include the following:
///    
@DllImport("clfsw32")
BOOL HandleLogFull(HANDLE hLog);

///The <b>LogTailAdvanceFailure</b> function is called by a log client to indicate that it cannot comply with a request
///from log management to advance its tail.
///Params:
///    hLog = A handle to the log on which to resolve the log full condition.
///    dwReason = Win32 error code with the reason for the failure For a list of possible values, see System Error Codes.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Valid values include the following:
///    
@DllImport("clfsw32")
BOOL LogTailAdvanceFailure(HANDLE hLog, uint dwReason);

///The <b>RegisterForLogWriteNotification</b> function is called by a managed log client to enable or disable log write
///notifications.
///Params:
///    hLog = A handle to the log on which to resolve the log full condition.
///    cbThreshold = Number of bytes to be written to the log file before the notification is sent.
///    fEnable = If <b>TRUE</b>, the notification is enabled. If <b>FALSE</b>, the notification is disabled.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Valid values include the following:
///    
@DllImport("clfsw32")
BOOL RegisterForLogWriteNotification(HANDLE hLog, uint cbThreshold, BOOL fEnable);

///Indicates whether compression should be used on a particular volume, and if so, which compression algorithm should be
///used.
///Params:
///    Volume = Specifies the path to the volume whose compression state is desired.
///    Algorithm = Points to a ULONG value. If the function returns TRUE, indicating compression is desired, this value will contain
///                the algorithm that should be used for this volume.
@DllImport("WOFUTIL")
BOOL WofShouldCompressBinaries(const(wchar)* Volume, uint* Algorithm);

///Used to query the version of the driver used to support a particular provider.
///Params:
///    FileOrVolumeHandle = A handle to a file or volume opened with CreateFile or a similar API.
///    Provider = Indicates which provider the version query is intended for. Multiple versions of Wof may exist on the same volume
///               at the same time for different providers.
///    WofVersion = Pointer to a ULONG which will contain the version upon successful completion of this function.
///Returns:
///    This function returns an HRESULT indicating success or the reason for failure. If no driver is attached on the
///    specified volume for the specified provider, the function will fail with
///    HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION).
///    
@DllImport("WOFUTIL")
HRESULT WofGetDriverVersion(HANDLE FileOrVolumeHandle, uint Provider, uint* WofVersion);

///Used to change a file from being backed by a physical file to one backed by a system data provider.
///Params:
///    FileHandle = A handle to a file opened with CreateFile or a similar API.
///    Provider = Indicates which provider is backing this file. Currently defined providers are: <table> <tr>
///               <td>WOF_PROVIDER_WIM</td> <td>Indicates that the data for the file should be obtained from a WIM file. On access,
///               data is transparently extracted from the WIM file and provided to applications. If the file contents are
///               modified, data is transparently decompressed and the file is restored to the same physical form it had if this
///               API were not used.</td> </tr> <tr> <td>WOF_PROVIDER_FILE</td> <td>Indicates that the data for the file should be
///               compressed and stored with the file itself. On access, data is transparently decompressed and provided to
///               applications. If the file contents are modified, data is transparently decompressed and the file is restored to
///               the same physical form it had if this API were not used. This provider requires Windows 10.</td> </tr> </table>
///    ExternalFileInfo = Provides data specific to the specified provider. Data structures for each defined provider are: <table> <tr>
///                       <td>WOF_PROVIDER_WIM</td> <td> WIM_EXTERNAL_FILE_INFO </td> </tr> <tr> <td>WOF_PROVIDER_FILE</td> <td>
///                       WOF_FILE_COMPRESSION_INFO </td> </tr> </table>
///    Length = Specifies the length of provider specific data, in bytes. This should correspond to the structures defined above:
///             <table> <tr> <td>WOF_PROVIDER_WIM</td> <td>sizeof(WIM_EXTERNAL_FILE_INFO)</td> </tr> <tr>
///             <td>WOF_PROVIDER_FILE</td> <td>sizeof(WOF_FILE_COMPRESSION_INFO)</td> </tr> </table>
///Returns:
///    This function returns an HRESULT indicating success or the reason for failure.
///    
@DllImport("WOFUTIL")
HRESULT WofSetFileDataLocation(HANDLE FileHandle, uint Provider, void* ExternalFileInfo, uint Length);

///Used to determine if a file is being backed by a physical file or is backed by a system data provider, and optionally
///indicates which provider or additional data about the file.
///Params:
///    FilePath = Specifies the path to the file for which the backing state is desired.
///    IsExternalFile = Optionally points to a BOOL value. On successful return, this value will be TRUE if the object is externally
///                     backed, FALSE if it is a physical file.
///    Provider = Optionally points to a ULONG value. On successful return, this value will be set to the provider that externally
///               backs this object. Currently defined providers are: <table> <tr> <td>WOF_PROVIDER_WIM</td> <td>Indicates that the
///               data for the file resides in a separate WIM file. On access, data is transparently extracted, decompressed and
///               provided to applications. If the file contents are modified, data is transparently decompressed and the file is
///               restored to a regular file. </td> </tr> <tr> <td>WOF_PROVIDER_FILE</td> <td>Indicates that the data for the file
///               should be compressed and stored with the file itself. On access, data is transparently decompressed and provided
///               to applications. If the file contents are modified, data is transparently decompressed and the file is restored
///               to a regular file. This provider requires Windows 10.</td> </tr> </table>
///    ExternalFileInfo = Optionally points to a caller allocated buffer. On successful return, this buffer will contain additional
///                       information about the state of the file. If this value is provided, <b>BufferLength</b> must also be specified.
///                       Data structures for each defined provider are: <table> <tr> <td>WOF_PROVIDER_WIM</td> <td> WIM_EXTERNAL_FILE_INFO
///                       </td> </tr> <tr> <td>WOF_PROVIDER_FILE</td> <td> WOF_FILE_COMPRESSION_INFO </td> </tr> </table>
///    BufferLength = Optionally points to a value that contains the length of the buffer specified in <b>ExternalFileInfo</b>. On
///                   return, this value will be set to the size of the buffer consumed, or the size of the buffer required. If the
///                   buffer is of insufficient length, this function will succeed indicating the required size and will not populate
///                   the buffer in <b>ExternalFileInfo</b>. This length should correspond to one of the structures defined above:
///                   <table> <tr> <td>WOF_PROVIDER_WIM</td> <td>sizeof(WIM_EXTERNAL_FILE_INFO)</td> </tr> <tr>
///                   <td>WOF_PROVIDER_FILE</td> <td>sizeof(WOF_FILE_COMPRESSION_INFO)</td> </tr> </table>
///Returns:
///    This function returns an HRESULT indicating success or the reason for failure. If the buffer specified in
///    <i>ExternalFileInfo</i> is not of the correct size, the function will return S_OK and indicate the required
///    buffer size in <i>BufferLength</i>.
///    
@DllImport("WOFUTIL")
HRESULT WofIsExternalFile(const(wchar)* FilePath, int* IsExternalFile, uint* Provider, void* ExternalFileInfo, 
                          uint* BufferLength);

///Enumerates all the data sources from a specified provider for a specified volume.
///Params:
///    VolumeName = The volume name hosting the files for which the backing data sources are requested.
///    Provider = Indicates which provider’s data sources are being requested. Supported providers for this operation are:
///               <table> <tr> <td>WOF_PROVIDER_WIM </td> <td>Indicates that the function should return the WIM files which are
///               providing data for placeholder files on the specified volume.</td> </tr> </table>
///    EnumProc = The callback function for each data source. The enumeration will stop if <i>EnumProc</i> returns <b>FALSE</b>.
///    UserData = User defined data passed to <i>EnumProc</i>.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("WOFUTIL")
HRESULT WofEnumEntries(const(wchar)* VolumeName, uint Provider, WofEnumEntryProc EnumProc, void* UserData);

///Adds a single WIM data source to a volume such that files can be created on the volume which are stored within the
///WIM.
///Params:
///    VolumeName = The path to the volume upon which files residing in the WIM should be created.
///    WimPath = The path to the WIM file which should be used to provide data to files.
///    WimType = The type of WIM. Can be <b>WIM_BOOT_OS_WIM</b> or <b>WIM_BOOT_NOT_OS_WIM</b>.
///    WimIndex = Index of the image in the WIM which is applied.
///    DataSourceId = On successful return, contains the data source used to identify the entry. This data source can be used to create
///                   new files with WofSetFileDataLocation.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("WOFUTIL")
HRESULT WofWimAddEntry(const(wchar)* VolumeName, const(wchar)* WimPath, uint WimType, uint WimIndex, 
                       LARGE_INTEGER* DataSourceId);

///Enumerates all of the files which are being backed by a specified WIM data source on a specified volume.
///Params:
///    VolumeName = The path to the volume which hosts WIM-backed files.
///    DataSourceId = Identifier used to identify the WIM entry.
///    EnumProc = The callback function for file provided by the WIM entry.
///    UserData = Optional user defined data passed to <i>EnumProc</i>.
@DllImport("WOFUTIL")
HRESULT WofWimEnumFiles(const(wchar)* VolumeName, LARGE_INTEGER DataSourceId, WofEnumFilesProc EnumProc, 
                        void* UserData);

///Temporarily removes a WIM data source from backing files on a volume until the volume is remounted or the data source
///is updated with WofWimUpdateEntry.
///Params:
///    VolumeName = The volume name which contained files whose data was provided by the WIM.
///    DataSourceId = Identifies the WIM entry.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("WOFUTIL")
HRESULT WofWimSuspendEntry(const(wchar)* VolumeName, LARGE_INTEGER DataSourceId);

///Removes a single WIM data source from backing files on a volume.
///Params:
///    VolumeName = The volume name which contained files whose data was provided by the WIM.
///    DataSourceId = Identifes the WIM entry.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("WOFUTIL")
HRESULT WofWimRemoveEntry(const(wchar)* VolumeName, LARGE_INTEGER DataSourceId);

///Updates a WIM entry to point to a different WIM file location.
///Params:
///    VolumeName = The volume name which contains files whose data is provided by the WIM.
///    DataSourceId = Identifies the WIM entry.
///    NewWimPath = The new location of the WIM file.
@DllImport("WOFUTIL")
HRESULT WofWimUpdateEntry(const(wchar)* VolumeName, LARGE_INTEGER DataSourceId, const(wchar)* NewWimPath);

///Enumerates all of the files which are compressed with a specified compression algorithm on a specified volume.
///Params:
///    VolumeName = A full path to the volume containing the files to enumerate.
///    Algorithm = The compression algorithm to enumerate. For a list of valid compression algorithms, see
///                WOF_FILE_COMPRESSION_INFO_V1. If this value is MAX_ULONG, files compressed with any supported compression
///                algorithm will be returned.
///    EnumProc = The callback function for each data source. The enumeration will stop if <i>EnumProc</i> returns FALSE.
///    UserData = User defined data passed to <i>EnumProc</i>.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("WOFUTIL")
HRESULT WofFileEnumFiles(const(wchar)* VolumeName, uint Algorithm, WofEnumFilesProc EnumProc, void* UserData);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Creates a context to be
///used to read replication records.
///Params:
///    LogPath = The path that identifies the Resource Manager's .blf file.
///    BeginningLsn = The first LSN in the range to be read.
///    EndingLsn = The last LSN in the range to be read.
///    TxfFileId = The TxF identifier to search for in the LSN range. For more information, see TXF_ID.
///    TxfLogContext = A pointer to the context created.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("txfw32")
BOOL TxfLogCreateFileReadContext(const(wchar)* LogPath, CLS_LSN BeginningLsn, CLS_LSN EndingLsn, TXF_ID* TxfFileId, 
                                 void** TxfLogContext);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Creates a context that is
///required to read any replication records. In order to recover resources, the context must later be closed by calling
///TxfLogDestroyReadContext. Since the resources are allocated by a user-mode process, if that routine is not called,
///the resources will be recovered automatically when the process hosting the DLL terminates.
///Params:
///    LogPath = Location of the RM's CLFS BLF.
///    BeginningLsn = Start of LSN range to search. (inclusive)
///    EndingLsn = End of LSN range to search. (inclusive)
///    BeginningVirtualClock = Start of the virtual clock.
///    EndingVirtualClock = End of the virtual clock.
///    RecordTypeMask = A mask value indicating the type of records.
///    TxfLogContext = The returned context object.
///Returns:
///    Returns S_OK on success.
///    
@DllImport("txfw32")
BOOL TxfLogCreateRangeReadContext(const(wchar)* LogPath, CLS_LSN BeginningLsn, CLS_LSN EndingLsn, 
                                  LARGE_INTEGER* BeginningVirtualClock, LARGE_INTEGER* EndingVirtualClock, 
                                  uint RecordTypeMask, void** TxfLogContext);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Closes a read context
///created by the TxfLogCreateFileReadContext function.
///Params:
///    TxfLogContext = A pointer to the context.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("txfw32")
BOOL TxfLogDestroyReadContext(void* TxfLogContext);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Reads the redo records
///from the log.
///Params:
///    TxfLogContext = A pointer to the context.
///    BufferLength = The size of the output buffer, in bytes.
///    Buffer = A pointer to the buffer that receives the records. For more information, see TXF_LOG_RECORD_BASE.
///    BytesUsed = The number of bytes written to the output buffer.
///    RecordCount = The number of records written to the output buffer.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Possible error codes include the following. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_HANDLE</b></dt>
///    </dl> </td> <td width="60%"> The replication context is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> Some of the available records were copied into the
///    buffer. Call this function again to retrieve the rest of the records. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt> </dl> </td> <td width="60%"> The buffer is not large enough to contain
///    even one record. If <i>BytesUsed</i> is nonzero, then there was enough space to copy the TXF_LOG_RECORD_BASE
///    structure, which indicates the required buffer size to read the next complete record. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_FILE_CORRUPT</b></dt> </dl> </td> <td width="60%"> The format of the log file
///    being processed is unrecognized. </td> </tr> </table>
///    
@DllImport("txfw32")
BOOL TxfLogReadRecords(void* TxfLogContext, uint BufferLength, char* Buffer, uint* BytesUsed, uint* RecordCount);

@DllImport("txfw32")
BOOL TxfReadMetadataInfo(HANDLE FileHandle, TXF_ID* TxfFileId, CLS_LSN* LastLsn, uint* TransactionState, 
                         GUID* LockingTransaction);

@DllImport("txfw32")
BOOL TxfLogRecordGetFileName(char* RecordBuffer, uint RecordBufferLengthInBytes, const(wchar)* NameBuffer, 
                             uint* NameBufferLengthInBytes, TXF_ID* TxfId);

@DllImport("txfw32")
BOOL TxfLogRecordGetGenericType(void* RecordBuffer, uint RecordBufferLengthInBytes, uint* GenericType, 
                                LARGE_INTEGER* VirtualClock);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Sets the MiniVersion that
///a subsequent create should open. It should be returned to its previous state after calling create. Therefore, prior
///to calling this routine, the caller should invoke
///[TxfGetThreadMiniVersionForCreate](nf-txfw32-txfgetthreadminiversionforcreate.md).
///Params:
///    MiniVersion = A USHORT identifying which version should be opened by create.
@DllImport("txfw32")
void TxfSetThreadMiniVersionForCreate(ushort MiniVersion);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Returns the MiniVersion a
///subsequent create is set to open.
///Params:
///    MiniVersion = Pointer to a USHORT which will receive the result.
@DllImport("txfw32")
void TxfGetThreadMiniVersionForCreate(ushort* MiniVersion);

///Creates a new transaction object.
///Params:
///    lpTransactionAttributes = A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by
///                              child processes. If this parameter is <b>NULL</b>, the handle cannot be inherited. The
///                              <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new event. If
///                              <i>lpTransactionAttributes</i> is <b>NULL</b>, the object gets a default security descriptor. The access control
///                              lists (ACL) in the default security descriptor for a transaction come from the primary or impersonation token of
///                              the creator.
///    UOW = Reserved. Must be zero (0).
///    CreateOptions = Any optional transaction instructions. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                    id="TRANSACTION_DO_NOT_PROMOTE"></a><a id="transaction_do_not_promote"></a><dl>
///                    <dt><b>TRANSACTION_DO_NOT_PROMOTE</b></dt> </dl> </td> <td width="60%"> The transaction cannot be distributed.
///                    </td> </tr> </table>
///    IsolationLevel = Reserved; specify zero (0).
///    IsolationFlags = Reserved; specify zero (0).
///    Timeout = The time-out interval, in milliseconds. If a nonzero value is specified, the transaction will be aborted when the
///              interval elapses if it has not already reached the prepared state. Specify zero (0) or INFINITE to provide an
///              infinite time-out.
///    Description = A user-readable description of the transaction.
///Returns:
///    If the function succeeds, the return value is a handle to the transaction. If the function fails, the return
///    value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call the GetLastError function. The
///    following list identifies the possible error codes:
///    
@DllImport("ktmw32")
HANDLE CreateTransaction(SECURITY_ATTRIBUTES* lpTransactionAttributes, GUID* UOW, uint CreateOptions, 
                         uint IsolationLevel, uint IsolationFlags, uint Timeout, const(wchar)* Description);

///Opens an existing transaction.
///Params:
///    dwDesiredAccess = The access to the transaction object. You must have read and write access to work with a transaction. See
///                      Transaction Access Masks for a list of valid values.
///    TransactionId = The GUID that identifies the transaction to be opened. This is commonly referred to as a unit of work for the
///                    transaction.
///Returns:
///    If the function succeeds, the return value is a handle to the transaction. If the function fails, the return
///    value is INVALID_HANDLE_VALUE. To get extended error information, call the GetLastError function. The following
///    list identifies the possible error codes:
///    
@DllImport("ktmw32")
HANDLE OpenTransaction(uint dwDesiredAccess, GUID* TransactionId);

///Requests that the specified transaction be committed.
///Params:
///    TransactionHandle = A handle to the transaction to be committed. This handle must have been opened with the TRANSACTION_COMMIT access
///                        right. For more information, see KTM Security and Access Rights.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL CommitTransaction(HANDLE TransactionHandle);

///Requests that the specified transaction be committed.
///Params:
///    TransactionHandle = A handle to the transaction to be committed. This handle must have been opened with the TRANSACTION_COMMIT access
///                        right. For more information, see KTM Security and Access Rights.
///Returns:
///    If the function succeeds, the return value is nonzero. Success means that the function completed synchronously,
///    and the calling application does not need to wait for pending results. If the function fails, the return value is
///    0 (zero). To get extended error information, call the GetLastError function. The following list identifies the
///    possible error codes:
///    
@DllImport("ktmw32")
BOOL CommitTransactionAsync(HANDLE TransactionHandle);

///Requests that the specified transaction be rolled back. This function is synchronous.
///Params:
///    TransactionHandle = A handle to the transaction.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL RollbackTransaction(HANDLE TransactionHandle);

///Requests that the specified transaction be rolled back. This function returns asynchronously.
///Params:
///    TransactionHandle = A handle to the transaction.
///Returns:
///    If the function succeeds, the return value is nonzero, and GetLastError returns ERROR_IO_PENDING. If the function
///    fails, the return value is zero. To get extended error information, call the GetLastError function. The following
///    list identifies the possible error codes:
///    
@DllImport("ktmw32")
BOOL RollbackTransactionAsync(HANDLE TransactionHandle);

///Obtains the identifier (ID) for the specified transaction.
///Params:
///    TransactionHandle = A handle to the transaction.
///    TransactionId = A pointer to a variable that receives the ID of the transaction.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL GetTransactionId(HANDLE TransactionHandle, GUID* TransactionId);

///Returns the requested information about the specified transaction.
///Params:
///    TransactionHandle = A handle to the transaction. The handle must have the TRANSACTION_QUERY_INFORMATION permission to retrieve the
///                        information.
///    Outcome = A pointer to a buffer that receives the current outcome of the transaction. If the call to the
///              <b>GetTransactionInformation</b> function is successful, this value will be one of the TRANSACTION_OUTCOME
///              enumeration values.
///    IsolationLevel = Reserved.
///    IsolationFlags = Reserved.
///    Timeout = A pointer to a variable that receives the timeout value, in milliseconds, for this transaction.
///    BufferLength = The size of the <i>Description</i> parameter, in bytes. The buffer length value cannot be longer than the value
///                   of MAX_TRANSACTION_DESCRIPTION_LENGTH.
///    Description = A pointer to a buffer that receives the user-defined description of the transaction.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL GetTransactionInformation(HANDLE TransactionHandle, uint* Outcome, uint* IsolationLevel, uint* IsolationFlags, 
                               uint* Timeout, uint BufferLength, const(wchar)* Description);

///Sets the transaction information for the specified transaction.
///Params:
///    TransactionHandle = A handle to the transaction. The handle must have the TRANSACTION_SET_INFORMATION permission to set the
///                        transaction information.
///    IsolationLevel = Reserved; specify zero.
///    IsolationFlags = Reserved.
///    Timeout = The timeout value, in milliseconds, for this transaction.
///    Description = The user-defined description of this transaction.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL SetTransactionInformation(HANDLE TransactionHandle, uint IsolationLevel, uint IsolationFlags, uint Timeout, 
                               const(wchar)* Description);

///Creates a new transaction manager (TM) object and returns a handle with the specified access.
///Params:
///    lpTransactionAttributes = The transaction SECURITY_ATTRIBUTES (ACLs) for the TM object.
///    LogFileName = The log file stream name. If the stream does not exist in the log, it is created. To create a volatile TM, this
///                  parameter must be <b>NULL</b> and <i>CreateOptions</i> must specify TRANSACTION_MANAGER_VOLATILE, this
///                  transaction manager is considered volatile.
///    CreateOptions = Any optional attributes for the new TM. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                    width="40%"><a id="TRANSACTION_MANAGER_VOLATILE"></a><a id="transaction_manager_volatile"></a><dl>
///                    <dt><b>TRANSACTION_MANAGER_VOLATILE</b></dt> </dl> </td> <td width="60%"> Indicates that the TM is volatile, and
///                    does not perform recovery. </td> </tr> </table>
///    CommitStrength = Reserved; specify zero.
///Returns:
///    If the function succeeds, the return value is a handle to the transaction manager. If the function fails, the
///    return value is INVALID_HANDLE_VALUE. To get extended error information, call the GetLastError function. The
///    following list identifies the possible error codes:
///    
@DllImport("ktmw32")
HANDLE CreateTransactionManager(SECURITY_ATTRIBUTES* lpTransactionAttributes, const(wchar)* LogFileName, 
                                uint CreateOptions, uint CommitStrength);

///Opens an existing transaction manager.
///Params:
///    LogFileName = The name of the log stream. This stream must exist within a CLFS log file.
///    DesiredAccess = The access requested. See Transaction Manager Access Masks for a list of valid values.
///    OpenOptions = Reserved; specify zero.
///Returns:
///    If the function succeeds, the return value is a handle to the transaction manager. If the function fails, the
///    return value is INVALID_HANDLE_VALUE. To get extended error information, call the GetLastError function. The
///    following list identifies the possible error codes:
///    
@DllImport("ktmw32")
HANDLE OpenTransactionManager(const(wchar)* LogFileName, uint DesiredAccess, uint OpenOptions);

///Opens an existing transaction manager.
///Params:
///    TransactionManagerId = The identifier of the transaction to open.
///    DesiredAccess = The access requested. See Transaction Manager Access Masks for a list of valid values.
///    OpenOptions = Reserved; specify zero.
///Returns:
///    If the function succeeds, the return value is a handle to the transaction manager. If the function fails, the
///    return value is INVALID_HANDLE_VALUE. To get extended error information, call the GetLastError function. The
///    following list identifies the possible error codes:
///    
@DllImport("ktmw32")
HANDLE OpenTransactionManagerById(GUID* TransactionManagerId, uint DesiredAccess, uint OpenOptions);

///Renames a transaction manager (TM) object. This function can only be used on named TM handles. A new <b>GUID</b> for
///the TM is selected and can be retrieved using the GetTransactionManagerID function.
///Params:
///    LogFileName = The name of the log stream. This stream must exist within a CLFS log file.
///    ExistingTransactionManagerGuid = A value that specifies the current name of the TM.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL RenameTransactionManager(const(wchar)* LogFileName, GUID* ExistingTransactionManagerGuid);

///Recovers information only to the specified virtual clock value.
///Params:
///    TransactionManagerHandle = A handle to the transaction manager.
///    TmVirtualClock = A pointer to the latest virtual clock value received for this transaction.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL RollforwardTransactionManager(HANDLE TransactionManagerHandle, LARGE_INTEGER* TmVirtualClock);

///Recovers a transaction manager's state from its log file.
///Params:
///    TransactionManagerHandle = A handle to the transaction manager.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL RecoverTransactionManager(HANDLE TransactionManagerHandle);

///Obtains a virtual clock value from a transaction manager.
///Params:
///    TransactionManagerHandle = A handle to the transaction manager to obtain a virtual clock value for.
///    TmVirtualClock = The latest virtual clock value for the transaction manager. See LARGE_INTEGER.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL GetCurrentClockTransactionManager(HANDLE TransactionManagerHandle, LARGE_INTEGER* TmVirtualClock);

///Obtains an identifier for the specified transaction manager.
///Params:
///    TransactionManagerHandle = A handle to the transaction manager.
///    TransactionManagerId = A pointer to a variable that receives the identifier for the transaction manager.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL GetTransactionManagerId(HANDLE TransactionManagerHandle, GUID* TransactionManagerId);

///Creates a new resource manager (RM) object, and associates the RM with a transaction manager (TM).
///Params:
///    lpResourceManagerAttributes = A pointer to a SECURITY_ATTRIBUTES structure that contains the security attributes for the resource manager.
///                                  Specify <b>NULL</b> to obtain the default attributes.
///    ResourceManagerId = A pointer the resource manager GUID. This parameter is required and must not be <b>NULL</b>.
///    CreateOptions = Any optional attributes for the new RM. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                    width="40%"><a id="RESOURCE_MANAGER_VOLATILE"></a><a id="resource_manager_volatile"></a><dl>
///                    <dt><b>RESOURCE_MANAGER_VOLATILE</b></dt> </dl> </td> <td width="60%"> Indicates that the RM is volatile, and
///                    does not perform recovery. </td> </tr> </table>
///    TmHandle = A handle to the TM that will manage the transactions for this RM.
///    Description = A description for this RM.
///Returns:
///    If the function succeeds, the return value is a handle to the RM. If the function fails, the return value is
///    INVALID_HANDLE_VALUE. To get extended error information, call the GetLastError function. The following list
///    identifies the possible error codes:
///    
@DllImport("ktmw32")
HANDLE CreateResourceManager(SECURITY_ATTRIBUTES* lpResourceManagerAttributes, GUID* ResourceManagerId, 
                             uint CreateOptions, HANDLE TmHandle, const(wchar)* Description);

///Opens an existing resource manager (RM).
///Params:
///    dwDesiredAccess = The access requested for the RM. See Resource Manager Access Masks for a list of valid values.
///    TmHandle = A handle to the transaction manager.
///    ResourceManagerId = The identifier for this resource manager.
///Returns:
///    If the function succeeds, the return value is a handle to the resource manager. If the function fails, the return
///    value is INVALID_HANDLE_VALUE. To get extended error information, call the GetLastError function. The following
///    list identifies the possible error codes:
///    
@DllImport("ktmw32")
HANDLE OpenResourceManager(uint dwDesiredAccess, HANDLE TmHandle, GUID* ResourceManagerId);

///Recovers a resource manager's state from its log file.
///Params:
///    ResourceManagerHandle = A handle to the resource manager.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL RecoverResourceManager(HANDLE ResourceManagerHandle);

///Requests and receives a notification for a resource manager (RM). This function is used by the RM register to receive
///notifications when a transaction changes state.
///Params:
///    ResourceManagerHandle = A handle to the resource manager.
///    TransactionNotification = A pointer to a TRANSACTION_NOTIFICATION structure that receives the first available notification.
///    NotificationLength = The size of the <i>TransactionNotification</i> buffer, in bytes.
///    dwMilliseconds = The time, in milliseconds, for which the calling application is blocking while waiting for the notification to
///                     become available. If no notifications are available when the timeout expires, <b>ERROR_TIMEOUT</b> is returned.
///    ReturnLength = A pointer to a variable that receives the actual size of the notification received by the
///                   <i>TransactionNotification</i> parameter.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL GetNotificationResourceManager(HANDLE ResourceManagerHandle, 
                                    TRANSACTION_NOTIFICATION* TransactionNotification, uint NotificationLength, 
                                    uint dwMilliseconds, uint* ReturnLength);

///Requests and receives asynchronous notification for a resource manager (RM). This function is used by the RM register
///to receive notifications when a transaction changes state.
///Params:
///    ResourceManagerHandle = A handle to the resource manager.
///    TransactionNotification = A pointer to a TRANSACTION_NOTIFICATION structure that receives the first available notification.
///    TransactionNotificationLength = The size of the <i>TransactionNotification</i> buffer, in bytes.
///    ReturnLength = A pointer to a variable that receives the actual size of the notification received by the
///                   <i>TransactionNotification</i> parameter.
///    lpOverlapped = A pointer to an OVERLAPPED structure that is required for asynchronous operation.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL GetNotificationResourceManagerAsync(HANDLE ResourceManagerHandle, 
                                         TRANSACTION_NOTIFICATION* TransactionNotification, 
                                         uint TransactionNotificationLength, uint* ReturnLength, 
                                         OVERLAPPED* lpOverlapped);

///Associates the specified I/O completion port with the specified resource manager (RM). This port receives all
///notifications for the RM.
///Params:
///    ResourceManagerHandle = A handle to the resource manager.
///    IoCompletionPortHandle = A handle to the I/O completion port.
///    CompletionKey = The user-defined identifier. Typically, it is used to associate the receive notification with a specific resource
///                    manager.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL SetResourceManagerCompletionPort(HANDLE ResourceManagerHandle, HANDLE IoCompletionPortHandle, 
                                      size_t CompletionKey);

///Creates an enlistment, sets its initial state, and opens a handle to the enlistment with the specified access.
///Params:
///    lpEnlistmentAttributes = A pointer to a SECURITY_ATTRIBUTES structure that contains the security attributes for the enlistment manager.
///                             Specify <b>NULL</b> to obtain the default attributes.
///    ResourceManagerHandle = A handle to the resource manager (RM) to enlist.
///    TransactionHandle = A handle to the transaction in which the RM is enlisting.
///    NotificationMask = The notifications this RM is requesting for the <i>TransactionHandle</i> parameter. For a list of valid values,
///                       see NOTIFICATION_MASK.
///    CreateOptions = Any optional enlistment instructions. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                    id="ENLISTMENT_SUPERIOR"></a><a id="enlistment_superior"></a><dl> <dt><b>ENLISTMENT_SUPERIOR</b></dt> <dt>1</dt>
///                    </dl> </td> <td width="60%"> Enlist as a superior transaction manager. </td> </tr> </table>
///    EnlistmentKey = A pointer to a user-defined structure used by the RM that is returned when a notification is sent in the
///                    TRANSACTION_NOTIFICATION structure. This is typically used to associate a private structure with this specific
///                    transaction.
///Returns:
///    If the function succeeds, the return value is a handle to the enlistment. If the function fails, the return value
///    is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call the GetLastError function. The following
///    list identifies the possible error codes:
///    
@DllImport("ktmw32")
HANDLE CreateEnlistment(SECURITY_ATTRIBUTES* lpEnlistmentAttributes, HANDLE ResourceManagerHandle, 
                        HANDLE TransactionHandle, uint NotificationMask, uint CreateOptions, void* EnlistmentKey);

///Opens an existing enlistment object, and returns a handle to the enlistment.
///Params:
///    dwDesiredAccess = The access requested for this enlistment. See Enlistment Access Masks for a list of valid values.
///    ResourceManagerHandle = A handle to the resource manager.
///    EnlistmentId = The enlistment identifier.
///Returns:
///    If the function succeeds, the return value is a handle to the enlistment. If the function fails, the return value
///    is INVALID_HANDLE_VALUE. To get extended error information, call the GetLastError function. The following list
///    identifies the possible error codes:
///    
@DllImport("ktmw32")
HANDLE OpenEnlistment(uint dwDesiredAccess, HANDLE ResourceManagerHandle, GUID* EnlistmentId);

///Recovers an enlistment's state.
///Params:
///    EnlistmentHandle = A handle to the enlistment.
///    EnlistmentKey = The key to the enlistment to be recovered.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL RecoverEnlistment(HANDLE EnlistmentHandle, void* EnlistmentKey);

///Retrieves an opaque structure of recovery data from KTM. Recovery information is stored in a log on behalf of a
///resource manager (RM) by calling the SetEnlistmentRecoveryInformation function. After a failure, the RM can use the
///<b>GetEnlistmentRecoveryInformation</b> function to retrieve the information.
///Params:
///    EnlistmentHandle = A handle to the enlistment.
///    BufferSize = The size of the <i>Buffer</i> parameter, in bytes.
///    Buffer = A pointer to a buffer that receives the enlistment recovery information.
///    BufferUsed = A pointer to a variable that receives the actual number of bytes returned in the <i>Buffer</i> parameter.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL GetEnlistmentRecoveryInformation(HANDLE EnlistmentHandle, uint BufferSize, void* Buffer, uint* BufferUsed);

///Obtains the identifier (ID) for the specified enlistment.
///Params:
///    EnlistmentHandle = A handle to the enlistment.
///    EnlistmentId = A pointer to a variables that receives the ID of the enlistment.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL GetEnlistmentId(HANDLE EnlistmentHandle, GUID* EnlistmentId);

///Sets an opaque, user-defined structure of recovery data from KTM. Recovery information is stored in a log on behalf
///of a resource manager (RM) by calling <b>SetEnlistmentRecoveryInformation</b>. After a failure, the RM can use
///GetEnlistmentRecoveryInformation to retrieve the information.
///Params:
///    EnlistmentHandle = A handle to the enlistment.
///    BufferSize = The size of <i>Buffer</i>, in bytes.
///    Buffer = The recovery information.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL SetEnlistmentRecoveryInformation(HANDLE EnlistmentHandle, uint BufferSize, void* Buffer);

///Prepares the transaction associated with this enlistment handle. This function is used by communication resource
///managers (sometimes called superior transaction managers).
///Params:
///    EnlistmentHandle = A handle to the enlistment for which the prepare operation has completed.
///    TmVirtualClock = A pointer to the latest virtual clock value received for this transaction.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL PrepareEnlistment(HANDLE EnlistmentHandle, LARGE_INTEGER* TmVirtualClock);

///Pre-prepares the transaction associated with this enlistment handle. This function is used by communication resource
///managers (sometimes called superior transaction managers).
///Params:
///    EnlistmentHandle = A handle to the enlistment for which the prepare operation has completed.
///    TmVirtualClock = A pointer to the latest virtual clock value received for this transaction.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL PrePrepareEnlistment(HANDLE EnlistmentHandle, LARGE_INTEGER* TmVirtualClock);

///Commits the transaction associated with this enlistment handle. This function is used by communication resource
///managers (sometimes called superior transaction managers).
///Params:
///    EnlistmentHandle = A handle to the enlistment to commit.
///    TmVirtualClock = A pointer to the latest virtual clock value received for this enlistment. If you specify <b>NULL</b>, the virtual
///                     clock value is not changed. To change the virtual clock value, this value must be greater than the current value
///                     returned by a subordinate TM.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL CommitEnlistment(HANDLE EnlistmentHandle, LARGE_INTEGER* TmVirtualClock);

///Rolls back the specified transaction that is associated with an enlistment. This function cannot be called for
///read-only enlistments.
///Params:
///    EnlistmentHandle = A handle to the enlistment.
///    TmVirtualClock = The latest virtual clock value received for this enlistment. See LARGE_INTEGER.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL RollbackEnlistment(HANDLE EnlistmentHandle, LARGE_INTEGER* TmVirtualClock);

///Signals that this resource manager has completed its preprepare work, so that other resource managers can now begin
///their prepare operations.
///Params:
///    EnlistmentHandle = A handle to the enlistment.
///    TmVirtualClock = The latest virtual clock value received for this preprepare operation. If you specify <b>NULL</b>, the virtual
///                     clock value is not changed. See LARGE_INTEGER. To change the virtual clock value, this value must be greater than
///                     the current value returned in the COMMIT notification.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL PrePrepareComplete(HANDLE EnlistmentHandle, LARGE_INTEGER* TmVirtualClock);

///Indicates that the resource manager (RM) has completed all processing necessary to guarantee that a commit or abort
///operation will succeed for the specified transaction.
///Params:
///    EnlistmentHandle = A handle to the enlistment.
///    TmVirtualClock = The latest virtual clock value received for this prepare complete notification. If you specify <b>NULL</b>, the
///                     virtual clock value is not changed. See LARGE_INTEGER. To change the virtual clock value, this value must be
///                     greater than the current value returned in the COMMIT notification.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL PrepareComplete(HANDLE EnlistmentHandle, LARGE_INTEGER* TmVirtualClock);

///Requests that the specified enlistment be converted to a read-only enlistment. A read-only enlistment cannot
///participate in the outcome of the transaction and is not durably recorded for recovery.
///Params:
///    EnlistmentHandle = A handle to the enlistment.
///    TmVirtualClock = The latest virtual clock value received for this enlistment. If you specify <b>NULL</b>, the virtual clock value
///                     is not changed. See LARGE_INTEGER. To change the virtual clock value, this value must be greater than the current
///                     value returned in the COMMIT notification.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL ReadOnlyEnlistment(HANDLE EnlistmentHandle, LARGE_INTEGER* TmVirtualClock);

///Indicates that a resource manager (RM) has finished committing a transaction that was requested by the transaction
///manager (TM).
///Params:
///    EnlistmentHandle = A handle to the enlistment for which the commit operation is completed.
///    TmVirtualClock = The latest virtual clock value received for this transaction. If you specify <b>NULL</b>, the virtual clock value
///                     is not changed. See LARGE_INTEGER. To change the virtual clock value, this value must be greater than the current
///                     value returned in the COMMIT notification.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL CommitComplete(HANDLE EnlistmentHandle, LARGE_INTEGER* TmVirtualClock);

///Indicates that the resource manager (RM) has successfully completed rolling back a transaction.
///Params:
///    EnlistmentHandle = A handle the enlistment.
///    TmVirtualClock = The latest virtual clock value received for this transaction. See LARGE_INTEGER.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL RollbackComplete(HANDLE EnlistmentHandle, LARGE_INTEGER* TmVirtualClock);

///Indicates that the resource manager (RM) is refusing a single-phase request. When a transaction manager (TM) receives
///this call, it initiates a two-phase commit and sends a prepare request to all enlisted RMs.
///Params:
///    EnlistmentHandle = A handle to the enlistment.
///    TmVirtualClock = The latest virtual clock value received from the single-phase request notification. If you specify <b>NULL</b>,
///                     the virtual clock value is not changed. See LARGE_INTEGER. To change the virtual clock value, this value must be
///                     greater than the current value returned in the COMMIT notification.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call the GetLastError function. The following list identifies the possible error
///    codes:
///    
@DllImport("ktmw32")
BOOL SinglePhaseReject(HANDLE EnlistmentHandle, LARGE_INTEGER* TmVirtualClock);

///Shares a server resource.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used.
///    level = Specifies the information level of the data. This parameter can be one of the following values. <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td
///            width="60%"> Specifies information about the shared resource, including the name of the resource, type and
///            permissions, and number of connections. The <i>buf</i> parameter points to a SHARE_INFO_2 structure. </td> </tr>
///            <tr> <td width="40%"><a id="502"></a><dl> <dt><b>502</b></dt> </dl> </td> <td width="60%"> Specifies information
///            about the shared resource, including the name of the resource, type and permissions, number of connections, and
///            other pertinent information. The <i>buf</i> parameter points to a SHARE_INFO_502 structure. </td> </tr> <tr> <td
///            width="40%"><a id="503"></a><dl> <dt><b>503</b></dt> </dl> </td> <td width="60%"> Specifies information about the
///            shared resource, including the name of the resource, type and permissions, number of connections, and other
///            pertinent information. The <i>buf</i> parameter points to a SHARE_INFO_503 structure. </td> </tr> </table>
///    buf = Pointer to the buffer that specifies the data. The format of this data depends on the value of the <i>level</i>
///          parameter. For more information, see Network Management Function Buffers.
///    parm_err = Pointer to a value that receives the index of the first member of the share information structure that causes the
///               <b>ERROR_INVALID_PARAMETER</b> error. If this parameter is <b>NULL</b>, the index is not returned on error. For
///               more information, see the NetShareSetInfo function.
///Returns:
///    If the function succeeds, the return value is <b>NERR_Success</b>. If the function fails, the return value can be
///    one of the following error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The user does not have access
///    to the requested information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_LEVEL</b></dt> </dl>
///    </td> <td width="60%"> The value specified for the <i>level</i> parameter is not valid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_NAME</b></dt> </dl> </td> <td width="60%"> The character or file system
///    name is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> The specified parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>NERR_DuplicateShare</b></dt> </dl> </td> <td width="60%"> The share name is already in use on this server.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>NERR_RedirectedPath</b></dt> </dl> </td> <td width="60%"> The
///    operation is not valid for a redirected resource. The specified device name is assigned to a shared resource.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>NERR_UnknownDevDir</b></dt> </dl> </td> <td width="60%"> The device
///    or directory does not exist. </td> </tr> </table>
///    
@DllImport("srvcli")
uint NetShareAdd(const(wchar)* servername, uint level, char* buf, uint* parm_err);

///Retrieves information about each shared resource on a server. You can also use the WNetEnumResource function to
///retrieve resource information. However, <b>WNetEnumResource</b> does not enumerate hidden shares or users connected
///to a share.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used.
///    level = Specifies the information level of the data. This parameter can be one of the following values. <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td
///            width="60%"> Return share names. The <i>bufptr</i> parameter points to an array of SHARE_INFO_0 structures. </td>
///            </tr> <tr> <td width="40%"><a id="1"></a><dl> <dt><b>1</b></dt> </dl> </td> <td width="60%"> Return information
///            about shared resources, including the name and type of the resource, and a comment associated with the resource.
///            The <i>bufptr</i> parameter points to an array of SHARE_INFO_1 structures. </td> </tr> <tr> <td width="40%"><a
///            id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> Return information about shared resources,
///            including name of the resource, type and permissions, password, and number of connections. The <i>bufptr</i>
///            parameter points to an array of SHARE_INFO_2 structures. </td> </tr> <tr> <td width="40%"><a id="502"></a><dl>
///            <dt><b>502</b></dt> </dl> </td> <td width="60%"> Return information about shared resources, including name of the
///            resource, type and permissions, number of connections, and other pertinent information. The <i>bufptr</i>
///            parameter points to an array of SHARE_INFO_502 structures. Shares from different scopes are not returned. For
///            more information about scoping, see the Remarks section of the documentation for the NetServerTransportAddEx
///            function. </td> </tr> <tr> <td width="40%"><a id="503"></a><dl> <dt><b>503</b></dt> </dl> </td> <td width="60%">
///            Return information about shared resources, including the name of the resource, type and permissions, number of
///            connections, and other pertinent information. The <i>bufptr</i> parameter points to an array of SHARE_INFO_503
///            structures. Shares from all scopes are returned. If the <b>shi503_servername</b> member of this structure is "*",
///            there is no configured server name and the <b>NetShareEnum</b> function enumerates shares for all the unscoped
///            names. <b>Windows Server 2003 and Windows XP: </b>This information level is not supported. </td> </tr> </table>
///    bufptr = Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i>
///             parameter. This buffer is allocated by the system and must be freed using the NetApiBufferFree function. Note
///             that you must free the buffer even if the function fails with <b>ERROR_MORE_DATA</b>.
///    prefmaxlen = Specifies the preferred maximum length of returned data, in bytes. If you specify <b>MAX_PREFERRED_LENGTH</b>,
///                 the function allocates the amount of memory required for the data. If you specify another value in this
///                 parameter, it can restrict the number of bytes that the function returns. If the buffer size is insufficient to
///                 hold all entries, the function returns <b>ERROR_MORE_DATA</b>. For more information, see Network Management
///                 Function Buffers and Network Management Function Buffer Lengths.
///    entriesread = Pointer to a value that receives the count of elements actually enumerated.
///    totalentries = Pointer to a value that receives the total number of entries that could have been enumerated. Note that
///                   applications should consider this value only as a hint.
///    resume_handle = Pointer to a value that contains a resume handle which is used to continue an existing share search. The handle
///                    should be zero on the first call and left unchanged for subsequent calls. If <i>resume_handle</i> is <b>NULL</b>,
///                    then no resume handle is stored.
///Returns:
///    If the function succeeds, the return value is <b>NERR_Success</b>. If the function fails, the return value is a
///    system error code. For a list of error codes, see System Error Codes.
///    
@DllImport("srvcli")
uint NetShareEnum(const(wchar)* servername, uint level, ubyte** bufptr, uint prefmaxlen, uint* entriesread, 
                  uint* totalentries, uint* resume_handle);

@DllImport("srvcli")
uint NetShareEnumSticky(const(wchar)* servername, uint level, ubyte** bufptr, uint prefmaxlen, uint* entriesread, 
                        uint* totalentries, uint* resume_handle);

///Retrieves information about a particular shared resource on a server.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used.
///    netname = Pointer to a string that specifies the name of the share for which to return information.
///    level = Specifies the information level of the data. This parameter can be one of the following values. <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td
///            width="60%"> Return the share name. The <i>bufptr</i> parameter points to a SHARE_INFO_0 structure. </td> </tr>
///            <tr> <td width="40%"><a id="1"></a><dl> <dt><b>1</b></dt> </dl> </td> <td width="60%"> Return information about
///            the shared resource, including the name and type of the resource, and a comment associated with the resource. The
///            <i>bufptr</i> parameter points to a SHARE_INFO_1 structure. </td> </tr> <tr> <td width="40%"><a id="2"></a><dl>
///            <dt><b>2</b></dt> </dl> </td> <td width="60%"> Return information about the shared resource, including name of
///            the resource, type and permissions, password, and number of connections. The <i>bufptr</i> parameter points to a
///            SHARE_INFO_2 structure. </td> </tr> <tr> <td width="40%"><a id="501"></a><dl> <dt><b>501</b></dt> </dl> </td> <td
///            width="60%"> Return the name and type of the resource, and a comment associated with the resource. The
///            <i>bufptr</i> parameter points to a SHARE_INFO_501 structure. </td> </tr> <tr> <td width="40%"><a
///            id="502"></a><dl> <dt><b>502</b></dt> </dl> </td> <td width="60%"> Return information about the shared resource,
///            including name of the resource, type and permissions, number of connections, and other pertinent information. The
///            <i>bufptr</i> parameter points to a SHARE_INFO_502 structure. </td> </tr> <tr> <td width="40%"><a
///            id="503"></a><dl> <dt><b>503</b></dt> </dl> </td> <td width="60%"> Specifies information about the shared
///            resource, including the name of the resource, type and permissions, number of connections, and other pertinent
///            information. The <i>buf</i> parameter points to a SHARE_INFO_503 structure. If the <b>shi503_servername</b>
///            member of this structure is "*", there is no configured server name. <b>Windows Server 2003 and Windows XP:
///            </b>This information level is not supported. </td> </tr> <tr> <td width="40%"><a id="1005"></a><dl>
///            <dt><b>1005</b></dt> </dl> </td> <td width="60%"> Return a value that indicates whether the share is the root
///            volume in a Dfs tree structure. The <i>bufptr</i> parameter points to a SHARE_INFO_1005 structure. </td> </tr>
///            </table>
///    bufptr = Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i>
///             parameter. For more information, see Network Management Function Buffers. This buffer is allocated by the system
///             and must be freed using the NetApiBufferFree function.
///Returns:
///    If the function succeeds, the return value is NERR_Success. If the function fails, the return value can be one of
///    the following error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The user does not have access to the
///    requested information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_LEVEL</b></dt> </dl> </td> <td
///    width="60%"> The value specified for the <i>level</i> parameter is not valid. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The specified parameter is not valid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%">
///    Insufficient memory is available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>NERR_NetNameNotFound</b></dt>
///    </dl> </td> <td width="60%"> The share name does not exist. </td> </tr> </table>
///    
@DllImport("srvcli")
uint NetShareGetInfo(const(wchar)* servername, const(wchar)* netname, uint level, ubyte** bufptr);

///Sets the parameters of a shared resource.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used.
///    netname = Pointer to a string that specifies the name of the share to set information on.
///    level = Specifies the information level of the data. This parameter can be one of the following values. <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="1"></a><dl> <dt><b>1</b></dt> </dl> </td> <td
///            width="60%"> Specifies information about the shared resource, including the name and type of the resource, and a
///            comment associated with the resource. The <i>buf</i> parameter points to a SHARE_INFO_1 structure. </td> </tr>
///            <tr> <td width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> Specifies information
///            about the shared resource, including the name of the resource, type and permissions, password, and number of
///            connections. The <i>buf</i> parameter points to a SHARE_INFO_2 structure. </td> </tr> <tr> <td width="40%"><a
///            id="502"></a><dl> <dt><b>502</b></dt> </dl> </td> <td width="60%"> Specifies information about the shared
///            resource, including the name and type of the resource, required permissions, number of connections, and other
///            pertinent information. The <i>buf</i> parameter points to a SHARE_INFO_502 structure. </td> </tr> <tr> <td
///            width="40%"><a id="503"></a><dl> <dt><b>503</b></dt> </dl> </td> <td width="60%"> Specifies the name of the
///            shared resource. The <i>buf</i> parameter points to a SHARE_INFO_503 structure. All members of this structure
///            except <b>shi503_servername</b> are ignored by the <b>NetShareSetInfo</b> function. <b>Windows Server 2003 and
///            Windows XP: </b>This information level is not supported. </td> </tr> <tr> <td width="40%"><a id="1004"></a><dl>
///            <dt><b>1004</b></dt> </dl> </td> <td width="60%"> Specifies a comment associated with the shared resource. The
///            <i>buf</i> parameter points to a SHARE_INFO_1004 structure. </td> </tr> <tr> <td width="40%"><a
///            id="1005"></a><dl> <dt><b>1005</b></dt> </dl> </td> <td width="60%"> Specifies a set of flags describing the
///            shared resource. The <i>buf</i> parameter points to a SHARE_INFO_1005 structure. </td> </tr> <tr> <td
///            width="40%"><a id="1006"></a><dl> <dt><b>1006</b></dt> </dl> </td> <td width="60%"> Specifies the maximum number
///            of concurrent connections that the shared resource can accommodate. The <i>buf</i> parameter points to a
///            SHARE_INFO_1006 structure. </td> </tr> <tr> <td width="40%"><a id="1501"></a><dl> <dt><b>1501</b></dt> </dl>
///            </td> <td width="60%"> Specifies the SECURITY_DESCRIPTOR associated with the specified share. The <i>buf</i>
///            parameter points to a SHARE_INFO_1501 structure. </td> </tr> </table>
///    buf = Pointer to the buffer that specifies the data. The format of this data depends on the value of the <i>level</i>
///          parameter. For more information, see Network Management Function Buffers.
///    parm_err = Pointer to a value that receives the index of the first member of the share information structure that causes the
///               <b>ERROR_INVALID_PARAMETER</b> error. If this parameter is <b>NULL</b>, the index is not returned on error. For
///               more information, see the following Remarks section.
///Returns:
///    If the function succeeds, the return value is <b>NERR_Success</b>. If the function fails, the return value can be
///    one of the following error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The user does not have access
///    to the requested information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_LEVEL</b></dt> </dl>
///    </td> <td width="60%"> The value specified for the <i>level</i> parameter is not valid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The specified parameter is
///    not valid. For more information, see the following Remarks section. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>NERR_NetNameNotFound</b></dt> </dl> </td> <td width="60%"> The share name does not exist. </td> </tr>
///    </table>
///    
@DllImport("srvcli")
uint NetShareSetInfo(const(wchar)* servername, const(wchar)* netname, uint level, char* buf, uint* parm_err);

///Deletes a share name from a server's list of shared resources, disconnecting all connections to the shared resource.
///The extended function NetShareDelEx allows the caller to specify a SHARE_INFO_0, SHARE_INFO_1, SHARE_INFO_2,
///SHARE_INFO_502, or SHARE_INFO_503 structure.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used. This string is Unicode if
///                 <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
///    netname = Pointer to a string that specifies the name of the share to delete. This string is Unicode if <b>_WIN32_WINNT</b>
///              or <b>FORCE_UNICODE</b> is defined.
///    reserved = Reserved, must be zero.
///Returns:
///    If the function succeeds, the return value is NERR_Success. If the function fails, the return value can be one of
///    the following error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The user does not have access to the
///    requested information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td>
///    <td width="60%"> The specified parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory is available. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>NERR_NetNameNotFound</b></dt> </dl> </td> <td width="60%"> The share name
///    does not exist. </td> </tr> </table>
///    
@DllImport("srvcli")
uint NetShareDel(const(wchar)* servername, const(wchar)* netname, uint reserved);

@DllImport("srvcli")
uint NetShareDelSticky(const(wchar)* servername, const(wchar)* netname, uint reserved);

///Checks whether or not a server is sharing a device.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used.
///    device = Pointer to a string that specifies the name of the device to check for shared access.
///    type = Pointer to a variable that receives a bitmask of flags that specify the type of the shared device. This parameter
///           is set only if the function returns successfully. One of the following flags may be specified. <table> <tr>
///           <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="STYPE_DISKTREE"></a><a
///           id="stype_disktree"></a><dl> <dt><b>STYPE_DISKTREE</b></dt> </dl> </td> <td width="60%"> Disk drive. </td> </tr>
///           <tr> <td width="40%"><a id="STYPE_PRINTQ"></a><a id="stype_printq"></a><dl> <dt><b>STYPE_PRINTQ</b></dt> </dl>
///           </td> <td width="60%"> Print queue. </td> </tr> <tr> <td width="40%"><a id="STYPE_DEVICE"></a><a
///           id="stype_device"></a><dl> <dt><b>STYPE_DEVICE</b></dt> </dl> </td> <td width="60%"> Communication device. </td>
///           </tr> <tr> <td width="40%"><a id="STYPE_IPC"></a><a id="stype_ipc"></a><dl> <dt><b>STYPE_IPC</b></dt> </dl> </td>
///           <td width="60%"> Interprocess communication (IPC). </td> </tr> </table> In addition, one or both of the following
///           flags may be specified. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///           id="STYPE_SPECIAL"></a><a id="stype_special"></a><dl> <dt><b>STYPE_SPECIAL</b></dt> </dl> </td> <td width="60%">
///           Special share reserved for interprocess communication (IPC$) or remote administration of the server (ADMIN$). Can
///           also refer to administrative shares such as C$, D$, E$, and so forth. For more information, see Network Share
///           Functions. </td> </tr> <tr> <td width="40%"><a id="STYPE_TEMPORARY"></a><a id="stype_temporary"></a><dl>
///           <dt><b>STYPE_TEMPORARY</b></dt> </dl> </td> <td width="60%"> A temporary share. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is <b>NERR_Success</b>. If the function fails, the return value can be
///    one of the following error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory is
///    available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>NERR_DeviceNotShared</b></dt> </dl> </td> <td
///    width="60%"> The device is not shared. </td> </tr> </table>
///    
@DllImport("srvcli")
uint NetShareCheck(const(wchar)* servername, const(wchar)* device, uint* type);

///Deletes a share name from a server's list of shared resources, which disconnects all connections to that share. This
///function, which is an extended version of the NetShareDel function, allows the caller to specify a SHARE_INFO_0,
///SHARE_INFO_1, SHARE_INFO_2, SHARE_INFO_502, or SHARE_INFO_503 structure.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used. This string is Unicode if
///                 <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
///    level = Specifies the information level of the data. This parameter can be one of the following values. <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="0__1__2__or_502"></a><a
///            id="0__1__2__OR_502"></a><dl> <dt><b>0, 1, 2, or 502</b></dt> </dl> </td> <td width="60%"> Specifies information
///            about the shared resource, including the name of the resource, type and permissions, and number of connections.
///            The <i>buf</i> parameter points to a SHARE_INFO_0, SHARE_INFO_1, SHARE_INFO_2, or SHARE_INFO_502 structure. </td>
///            </tr> <tr> <td width="40%"><a id="503"></a><dl> <dt><b>503</b></dt> </dl> </td> <td width="60%"> Specifies
///            information about the shared resource, including the name of the resource, type and permissions, number of
///            connections, and other pertinent information. The <i>buf</i> parameter points to a SHARE_INFO_503 structure.
///            </td> </tr> </table>
///    buf = Pointer to the buffer that specifies the data. The format of this data depends on the value of the <i>level</i>
///          parameter. For more information, see Network Management Function Buffers.
///Returns:
///    If the function succeeds, the return value is NERR_Success. If the function fails, the return value can be one of
///    the following error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An internal error occurred. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_LEVEL</b></dt> </dl> </td> <td width="60%"> The value specified
///    for the <i>level</i> parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_SUPPORTED</b></dt> </dl> </td> <td width="60%"> The request is not supported. </td> </tr>
///    </table>
///    
@DllImport("srvcli")
uint NetShareDelEx(const(wchar)* servername, uint level, char* buf);

@DllImport("srvcli")
uint NetServerAliasAdd(const(wchar)* servername, uint level, char* buf);

@DllImport("srvcli")
uint NetServerAliasDel(const(wchar)* servername, uint level, char* buf);

@DllImport("srvcli")
uint NetServerAliasEnum(const(wchar)* servername, uint level, ubyte** bufptr, uint prefmaxlen, uint* entriesread, 
                        uint* totalentries, uint* resumehandle);

///Provides information about sessions established on a server.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used.
///    UncClientName = Pointer to a string that specifies the name of the computer session for which information is to be returned. If
///                    this parameter is <b>NULL</b>, <b>NetSessionEnum</b> returns information for all computer sessions on the server.
///    username = Pointer to a string that specifies the name of the user for which information is to be returned. If this
///               parameter is <b>NULL</b>, <b>NetSessionEnum</b> returns information for all users.
///    level = Specifies the information level of the data. This parameter can be one of the following values. <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td
///            width="60%"> Return the name of the computer that established the session. The <i>bufptr</i> parameter points to
///            an array of SESSION_INFO_0 structures. </td> </tr> <tr> <td width="40%"><a id="1"></a><dl> <dt><b>1</b></dt>
///            </dl> </td> <td width="60%"> Return the name of the computer, name of the user, and open files, pipes, and
///            devices on the computer. The <i>bufptr</i> parameter points to an array of SESSION_INFO_1 structures. </td> </tr>
///            <tr> <td width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> In addition to the
///            information indicated for level 1, return the type of client and how the user established the session. The
///            <i>bufptr</i> parameter points to an array of SESSION_INFO_2 structures. </td> </tr> <tr> <td width="40%"><a
///            id="10"></a><dl> <dt><b>10</b></dt> </dl> </td> <td width="60%"> Return the name of the computer, name of the
///            user, and active and idle times for the session. The <i>bufptr</i> parameter points to an array of
///            SESSION_INFO_10 structures. </td> </tr> <tr> <td width="40%"><a id="502"></a><dl> <dt><b>502</b></dt> </dl> </td>
///            <td width="60%"> Return the name of the computer; name of the user; open files, pipes, and devices on the
///            computer; and the name of the transport the client is using. The <i>bufptr</i> parameter points to an array of
///            SESSION_INFO_502 structures. </td> </tr> </table>
///    bufptr = Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i>
///             parameter. This buffer is allocated by the system and must be freed using the NetApiBufferFree function. Note
///             that you must free the buffer even if the function fails with <b>ERROR_MORE_DATA</b>.
///    prefmaxlen = Specifies the preferred maximum length of returned data, in bytes. If you specify <b>MAX_PREFERRED_LENGTH</b>,
///                 the function allocates the amount of memory required for the data. If you specify another value in this
///                 parameter, it can restrict the number of bytes that the function returns. If the buffer size is insufficient to
///                 hold all entries, the function returns <b>ERROR_MORE_DATA</b>. For more information, see Network Management
///                 Function Buffers and Network Management Function Buffer Lengths.
///    entriesread = Pointer to a value that receives the count of elements actually enumerated.
///    totalentries = Pointer to a value that receives the total number of entries that could have been enumerated from the current
///                   resume position. Note that applications should consider this value only as a hint.
///    resume_handle = Pointer to a value that contains a resume handle which is used to continue an existing session search. The handle
///                    should be zero on the first call and left unchanged for subsequent calls. If <i>resume_handle</i> is <b>NULL</b>,
///                    no resume handle is stored.
///Returns:
///    If the function succeeds, the return value is <b>NERR_Success</b>. If the function fails, the return value can be
///    one of the following error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The user does not have access
///    to the requested information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_LEVEL</b></dt> </dl>
///    </td> <td width="60%"> The value specified for the <i>level</i> parameter is not valid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The specified parameter is
///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%">
///    More entries are available. Specify a large enough buffer to receive all entries. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory is
///    available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>NERR_ClientNameNotFound</b></dt> </dl> </td> <td
///    width="60%"> A session does not exist with the computer name. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>NERR_InvalidComputer</b></dt> </dl> </td> <td width="60%"> The computer name is not valid. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>NERR_UserNotFound</b></dt> </dl> </td> <td width="60%"> The user name could not
///    be found. </td> </tr> </table>
///    
@DllImport("srvcli")
uint NetSessionEnum(const(wchar)* servername, const(wchar)* UncClientName, const(wchar)* username, uint level, 
                    ubyte** bufptr, uint prefmaxlen, uint* entriesread, uint* totalentries, uint* resume_handle);

///Ends a network session between a server and a workstation.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used.
///    UncClientName = Pointer to a string that specifies the computer name of the client to disconnect. If the <i>UncClientName</i>
///                    parameter is <b>NULL</b>, then all the sessions of the user identified by the <i>username</i> parameter will be
///                    deleted on the server specified by the <i>servername</i> parameter. For more information, see NetSessionEnum.
///    username = Pointer to a string that specifies the name of the user whose session is to be terminated. If this parameter is
///               <b>NULL</b>, all users' sessions from the client specified by the <i>UncClientName</i> parameter are to be
///               terminated.
///Returns:
///    If the function succeeds, the return value is <b>NERR_Success</b>. If the function fails, the return value can be
///    one of the following error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The user does not have access
///    to the requested information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt>
///    </dl> </td> <td width="60%"> The specified parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory is available. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>NERR_ClientNameNotFound</b></dt> </dl> </td> <td width="60%"> A session
///    does not exist with that computer name. </td> </tr> </table>
///    
@DllImport("srvcli")
uint NetSessionDel(const(wchar)* servername, const(wchar)* UncClientName, const(wchar)* username);

///Retrieves information about a session established between a particular server and workstation.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used.
///    UncClientName = Pointer to a string that specifies the name of the computer session for which information is to be returned. This
///                    parameter is required and cannot be <b>NULL</b>. For more information, see NetSessionEnum.
///    username = Pointer to a string that specifies the name of the user whose session information is to be returned. This
///               parameter is required and cannot be <b>NULL</b>.
///    level = Specifies the information level of the data. This parameter can be one of the following values. <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td
///            width="60%"> Return the name of the computer that established the session. The <i>bufptr</i> parameter points to
///            a SESSION_INFO_0 structure. </td> </tr> <tr> <td width="40%"><a id="1"></a><dl> <dt><b>1</b></dt> </dl> </td> <td
///            width="60%"> Return the name of the computer, name of the user, and open files, pipes, and devices on the
///            computer. The <i>bufptr</i> parameter points to a SESSION_INFO_1 structure. </td> </tr> <tr> <td width="40%"><a
///            id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td width="60%"> In addition to the information indicated for level
///            1, return the type of client and how the user established the session. The <i>bufptr</i> parameter points to a
///            SESSION_INFO_2 structure. </td> </tr> <tr> <td width="40%"><a id="10"></a><dl> <dt><b>10</b></dt> </dl> </td> <td
///            width="60%"> Return the name of the computer; name of the user; and active and idle times for the session. The
///            <i>bufptr</i> parameter points to a SESSION_INFO_10 structure. </td> </tr> </table>
///    bufptr = Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i>
///             parameter. For more information, see Network Management Function Buffers and Network Management Function Buffer
///             Lengths. This buffer is allocated by the system and must be freed using the NetApiBufferFree function.
///Returns:
///    If the function succeeds, the return value is <b>NERR_Success</b>. If the function fails, the return value can be
///    one of the following error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The user does not have access
///    to the requested information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_LEVEL</b></dt> </dl>
///    </td> <td width="60%"> The value specified for the <i>level</i> parameter is not valid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The specified parameter is
///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td
///    width="60%"> Insufficient memory is available. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>NERR_ClientNameNotFound</b></dt> </dl> </td> <td width="60%"> A session does not exist with the computer
///    name. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>NERR_InvalidComputer</b></dt> </dl> </td> <td width="60%">
///    The computer name is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>NERR_UserNotFound</b></dt> </dl>
///    </td> <td width="60%"> The user name could not be found. </td> </tr> </table>
///    
@DllImport("srvcli")
uint NetSessionGetInfo(const(wchar)* servername, const(wchar)* UncClientName, const(wchar)* username, uint level, 
                       ubyte** bufptr);

///Lists all connections made to a shared resource on the server or all connections established from a particular
///computer. If there is more than one user using this connection, then it is possible to get more than one structure
///for the same connection, but with a different user name.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used. This string is Unicode if
///                 <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
///    qualifier = Pointer to a string that specifies a share name or computer name for the connections of interest. If it is a
///                share name, then all the connections made to that share name are listed. If it is a computer name (for example,
///                it starts with two backslash characters), then <b>NetConnectionEnum</b> lists all connections made from that
///                computer to the server specified. This string is Unicode if <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is
///                defined.
///    level = Specifies the information level of the data. This parameter can be one of the following values. <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td
///            width="60%"> Return connection identifiers. The <i>bufptr</i> parameter is a pointer to an array of
///            CONNECTION_INFO_0 structures. </td> </tr> <tr> <td width="40%"><a id="1"></a><dl> <dt><b>1</b></dt> </dl> </td>
///            <td width="60%"> Return connection identifiers and connection information. The <i>bufptr</i> parameter is a
///            pointer to an array of CONNECTION_INFO_1 structures. </td> </tr> </table>
///    bufptr = Pointer to the address of the buffer that receives the information. The format of this data depends on the value
///             of the <i>level</i> parameter. This buffer is allocated by the system and must be freed using the
///             NetApiBufferFree function. Note that you must free the buffer even if the function fails with
///             <b>ERROR_MORE_DATA</b>.
///    prefmaxlen = Specifies the preferred maximum length of returned data, in bytes. If you specify <b>MAX_PREFERRED_LENGTH</b>,
///                 the function allocates the amount of memory required for the data. If you specify another value in this
///                 parameter, it can restrict the number of bytes that the function returns. If the buffer size is insufficient to
///                 hold all entries, the function returns <b>ERROR_MORE_DATA</b>. For more information, see Network Management
///                 Function Buffers and Network Management Function Buffer Lengths.
///    entriesread = Pointer to a value that receives the count of elements actually enumerated.
///    totalentries = Pointer to a value that receives the total number of entries that could have been enumerated from the current
///                   resume position. Note that applications should consider this value only as a hint.
///    resume_handle = Pointer to a value that contains a resume handle which is used to continue an existing connection search. The
///                    handle should be zero on the first call and left unchanged for subsequent calls. If this parameter is
///                    <b>NULL</b>, then no resume handle is stored.
///Returns:
///    If the function succeeds, the return value is <b>NERR_Success</b>. If the function fails, the return value is a
///    system error code. For a list of error codes, see System Error Codes.
///    
@DllImport("srvcli")
uint NetConnectionEnum(const(wchar)* servername, const(wchar)* qualifier, uint level, ubyte** bufptr, 
                       uint prefmaxlen, uint* entriesread, uint* totalentries, uint* resume_handle);

///Forces a resource to close. This function can be used when an error prevents closure by any other means. You should
///use <b>NetFileClose</b> with caution because it does not write data cached on the client system to the file before
///closing the file.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used. This string is Unicode if
///                 <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
///    fileid = Specifies the file identifier of the opened resource instance to close.
///Returns:
///    If the function succeeds, the return value is <b>NERR_Success</b>. If the function fails, the return value can be
///    one of the following error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The user does not have access
///    to the requested information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl>
///    </td> <td width="60%"> The file was not found. </td> </tr> </table>
///    
@DllImport("srvcli")
uint NetFileClose(const(wchar)* servername, uint fileid);

///Returns information about some or all open files on a server, depending on the parameters specified.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used. This string is Unicode if
///                 <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
///    basepath = Pointer to a string that specifies a qualifier for the returned information. If this parameter is <b>NULL</b>,
///               all open resources are enumerated. If this parameter is not <b>NULL</b>, the function enumerates only resources
///               that have the value of the <i>basepath</i> parameter as a prefix. (A prefix is the portion of a path that comes
///               before a backslash.) This string is Unicode if <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
///    username = Pointer to a string that specifies the name of the user or the name of the connection. If the string begins with
///               two backslashes ("\\"), then it indicates the name of the connection, for example, "\\127.0.0.1" or
///               "\\ClientName". The part of the connection name after the backslashes is the same as the client name in the
///               session information structure returned by the NetSessionEnum function. If the string does not begin with two
///               backslashes, then it indicates the name of the user. If this parameter is not <b>NULL</b>, its value serves as a
///               qualifier for the enumeration. The files returned are limited to those that have user names or connection names
///               that match the qualifier. If this parameter is <b>NULL</b>, no user-name qualifier is used. <b>Windows Server
///               2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This parameter is a pointer to a string that
///               specifies the name of the user. If this parameter is not <b>NULL</b>, its value serves as a qualifier for the
///               enumeration. The files returned are limited to those that have user names matching the qualifier. If this
///               parameter is <b>NULL</b>, no user-name qualifier is used. This string is Unicode if <b>_WIN32_WINNT</b> or
///               <b>FORCE_UNICODE</b> is defined.
///    level = Specifies the information level of the data. This parameter can be one of the following values. <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td
///            width="60%"> Return the file identification number. The <i>bufptr</i> parameter points to an array of FILE_INFO_2
///            structures. </td> </tr> <tr> <td width="40%"><a id="3"></a><dl> <dt><b>3</b></dt> </dl> </td> <td width="60%">
///            Return information about the file. The <i>bufptr</i> parameter points to an array of FILE_INFO_3 structures.
///            </td> </tr> </table>
///    bufptr = Pointer to the address of the buffer that receives the information. The format of this data depends on the value
///             of the <i>level</i> parameter. This buffer is allocated by the system and must be freed using the
///             NetApiBufferFree function. Note that you must free the buffer even if the function fails with
///             <b>ERROR_MORE_DATA</b>.
///    prefmaxlen = Specifies the preferred maximum length of returned data, in bytes. If you specify <b>MAX_PREFERRED_LENGTH</b>,
///                 the function allocates the amount of memory required for the data. If you specify another value in this
///                 parameter, it can restrict the number of bytes that the function returns. If the buffer size is insufficient to
///                 hold all entries, the function returns <b>ERROR_MORE_DATA</b>. For more information, see Network Management
///                 Function Buffers and Network Management Function Buffer Lengths.
///    entriesread = Pointer to a value that receives the count of elements actually enumerated.
///    totalentries = Pointer to a value that receives the total number of entries that could have been enumerated from the current
///                   resume position. Note that applications should consider this value only as a hint.
///    resume_handle = Pointer to a value that contains a resume handle which is used to continue an existing file search. The handle
///                    should be zero on the first call and left unchanged for subsequent calls. If this parameter is <b>NULL</b>, no
///                    resume handle is stored.
///Returns:
///    If the function succeeds, the return value is <b>NERR_Success</b>. If the function fails, the return value can be
///    one of the following error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The user does not have access
///    to the requested information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_LEVEL</b></dt> </dl>
///    </td> <td width="60%"> The value specified for the <i>level</i> parameter is not valid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> More entries are available.
///    Specify a large enough buffer to receive all entries. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory is available. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>NERR_BufTooSmall</b></dt> </dl> </td> <td width="60%"> The supplied
///    buffer is too small. </td> </tr> </table>
///    
@DllImport("srvcli")
uint NetFileEnum(const(wchar)* servername, const(wchar)* basepath, const(wchar)* username, uint level, 
                 ubyte** bufptr, uint prefmaxlen, uint* entriesread, uint* totalentries, size_t* resume_handle);

///Retrieves information about a particular opening of a server resource.
///Params:
///    servername = Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to
///                 execute. If this parameter is <b>NULL</b>, the local computer is used. This string is Unicode if
///                 <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
///    fileid = Specifies the file identifier of the open resource for which to return information. The value of this parameter
///             must have been returned in a previous enumeration call. For more information, see the following Remarks section.
///    level = Specifies the information level of the data. This parameter can be one of the following values. <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="2"></a><dl> <dt><b>2</b></dt> </dl> </td> <td
///            width="60%"> Return the file identification number. The <i>bufptr</i> parameter is a pointer to a FILE_INFO_2
///            structure. </td> </tr> <tr> <td width="40%"><a id="3"></a><dl> <dt><b>3</b></dt> </dl> </td> <td width="60%">
///            Return the file identification number and other information about the file. The <i>bufptr</i> parameter is a
///            pointer to a FILE_INFO_3 structure. </td> </tr> </table>
///    bufptr = Pointer to the address of the buffer that receives the information. The format of this data depends on the value
///             of the <i>level</i> parameter. This buffer is allocated by the system and must be freed using the
///             NetApiBufferFree function. For more information, see Network Management Function Buffers and Network Management
///             Function Buffer Lengths.
///Returns:
///    If the function succeeds, the return value is <b>NERR_Success</b>. If the function fails, the return value can be
///    one of the following error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The user does not have access
///    to the requested information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl>
///    </td> <td width="60%"> The file was not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_LEVEL</b></dt> </dl> </td> <td width="60%"> The value specified for the <i>level</i>
///    parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl>
///    </td> <td width="60%"> Insufficient memory is available. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>NERR_BufTooSmall</b></dt> </dl> </td> <td width="60%"> The supplied buffer is too small. </td> </tr>
///    </table>
///    
@DllImport("srvcli")
uint NetFileGetInfo(const(wchar)* servername, uint fileid, uint level, ubyte** bufptr);

///Retrieves operating statistics for a service. Currently, only the workstation and server services are supported.
///Params:
///    ServerName = Pointer to a string that specifies the DNS or NetBIOS name of the server on which the function is to execute. If
///                 this parameter is <b>NULL</b>, the local computer is used.
///    Service = Pointer to a string that specifies the name of the service about which to get the statistics. Only the values
///              <b>SERVICE_SERVER</b> and <b>SERVICE_WORKSTATION</b> are currently allowed.
///    Level = Specifies the information level of the data. This parameter can be the following value. <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td
///            width="60%"> Return statistics about a workstation or a server. The <i>bufptr</i> parameter points to a
///            STAT_WORKSTATION_0 or a STAT_SERVER_0 structure. </td> </tr> </table>
///    Options = This parameter must be zero.
///    Buffer = Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i>
///             parameter. This buffer is allocated by the system and must be freed using the NetApiBufferFree function. For more
///             information, see Network Management Function Buffers and Network Management Function Buffer Lengths.
///Returns:
///    If the function succeeds, the return value is <b>NERR_Success</b>. If the function fails, the return value is a
///    system error code. For a list of error codes, see System Error Codes.
///    
@DllImport("NETAPI32")
uint NetStatisticsGet(byte* ServerName, byte* Service, uint Level, uint Options, ubyte** Buffer);

///Searches for a specified file in a specified path.
///Params:
///    lpPath = The path to be searched for the file. If this parameter is <b>NULL</b>, the function searches for a matching file
///             using a registry-dependent system search path. For more information, see the Remarks section.
///    lpFileName = The name of the file for which to search.
///    lpExtension = The extension to be added to the file name when searching for the file. The first character of the file name
///                  extension must be a period (.). The extension is added only if the specified file name does not end with an
///                  extension. If a file name extension is not required or if the file name contains an extension, this parameter can
///                  be <b>NULL</b>.
///    nBufferLength = The size of the buffer that receives the valid path and file name (including the terminating null character), in
///                    <b>TCHARs</b>.
///    lpBuffer = A pointer to the buffer to receive the path and file name of the file found. The string is a null-terminated
///               string.
///    lpFilePart = A pointer to the variable to receive the address (within <i>lpBuffer</i>) of the last component of the valid path
///                 and file name, which is the address of the character immediately following the final backslash (\\) in the path.
///Returns:
///    If the function succeeds, the value returned is the length, in <b>TCHARs</b>, of the string that is copied to the
///    buffer, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>,
///    the value returned is the size of the buffer that is required to hold the path, including the terminating null
///    character. If the function fails, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint SearchPathW(const(wchar)* lpPath, const(wchar)* lpFileName, const(wchar)* lpExtension, uint nBufferLength, 
                 const(wchar)* lpBuffer, ushort** lpFilePart);

///Searches for a specified file in a specified path.
///Params:
///    lpPath = The path to be searched for the file. If this parameter is <b>NULL</b>, the function searches for a matching file
///             using a registry-dependent system search path. For more information, see the Remarks section.
///    lpFileName = The name of the file for which to search.
///    lpExtension = The extension to be added to the file name when searching for the file. The first character of the file name
///                  extension must be a period (.). The extension is added only if the specified file name does not end with an
///                  extension. If a file name extension is not required or if the file name contains an extension, this parameter can
///                  be <b>NULL</b>.
///    nBufferLength = The size of the buffer that receives the valid path and file name (including the terminating null character), in
///                    <b>TCHARs</b>.
///    lpBuffer = A pointer to the buffer to receive the path and file name of the file found. The string is a null-terminated
///               string.
///    lpFilePart = A pointer to the variable to receive the address (within <i>lpBuffer</i>) of the last component of the valid path
///                 and file name, which is the address of the character immediately following the final backslash (\\) in the path.
///Returns:
///    If the function succeeds, the value returned is the length, in <b>TCHARs</b>, of the string that is copied to the
///    buffer, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>,
///    the value returned is the size of the buffer that is required to hold the path, including the terminating null
///    character. If the function fails, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint SearchPathA(const(char)* lpPath, const(char)* lpFileName, const(char)* lpExtension, uint nBufferLength, 
                 const(char)* lpBuffer, byte** lpFilePart);

///Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file.
///Params:
///    lpApplicationName = The full path of the file whose executable type is to be determined. In the ANSI version of this function, the
///                        name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode
///                        version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
///    lpBinaryType = A pointer to a variable to receive information about the executable type of the file specified by
///                   <i>lpApplicationName</i>. The following constants are defined. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                   <tr> <td width="40%"><a id="SCS_32BIT_BINARY"></a><a id="scs_32bit_binary"></a><dl>
///                   <dt><b>SCS_32BIT_BINARY</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> A 32-bit Windows-based application </td>
///                   </tr> <tr> <td width="40%"><a id="SCS_64BIT_BINARY"></a><a id="scs_64bit_binary"></a><dl>
///                   <dt><b>SCS_64BIT_BINARY</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> A 64-bit Windows-based application.
///                   </td> </tr> <tr> <td width="40%"><a id="SCS_DOS_BINARY"></a><a id="scs_dos_binary"></a><dl>
///                   <dt><b>SCS_DOS_BINARY</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> An MS-DOS – based application </td>
///                   </tr> <tr> <td width="40%"><a id="SCS_OS216_BINARY"></a><a id="scs_os216_binary"></a><dl>
///                   <dt><b>SCS_OS216_BINARY</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> A 16-bit OS/2-based application </td>
///                   </tr> <tr> <td width="40%"><a id="SCS_PIF_BINARY"></a><a id="scs_pif_binary"></a><dl>
///                   <dt><b>SCS_PIF_BINARY</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> A PIF file that executes an MS-DOS –
///                   based application </td> </tr> <tr> <td width="40%"><a id="SCS_POSIX_BINARY"></a><a id="scs_posix_binary"></a><dl>
///                   <dt><b>SCS_POSIX_BINARY</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> A POSIX – based application </td>
///                   </tr> <tr> <td width="40%"><a id="SCS_WOW_BINARY"></a><a id="scs_wow_binary"></a><dl>
///                   <dt><b>SCS_WOW_BINARY</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> A 16-bit Windows-based application </td>
///                   </tr> </table>
///Returns:
///    If the file is executable, the return value is nonzero. The function sets the variable pointed to by
///    <i>lpBinaryType</i> to indicate the file's executable type. If the file is not executable, or if the function
///    fails, the return value is zero. To get extended error information, call GetLastError. If the file is a DLL, the
///    last error code is <b>ERROR_BAD_EXE_FORMAT</b>.
///    
@DllImport("KERNEL32")
BOOL GetBinaryTypeA(const(char)* lpApplicationName, uint* lpBinaryType);

///Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file.
///Params:
///    lpApplicationName = The full path of the file whose executable type is to be determined. In the ANSI version of this function, the
///                        name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode
///                        version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
///    lpBinaryType = A pointer to a variable to receive information about the executable type of the file specified by
///                   <i>lpApplicationName</i>. The following constants are defined. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                   <tr> <td width="40%"><a id="SCS_32BIT_BINARY"></a><a id="scs_32bit_binary"></a><dl>
///                   <dt><b>SCS_32BIT_BINARY</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> A 32-bit Windows-based application </td>
///                   </tr> <tr> <td width="40%"><a id="SCS_64BIT_BINARY"></a><a id="scs_64bit_binary"></a><dl>
///                   <dt><b>SCS_64BIT_BINARY</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> A 64-bit Windows-based application.
///                   </td> </tr> <tr> <td width="40%"><a id="SCS_DOS_BINARY"></a><a id="scs_dos_binary"></a><dl>
///                   <dt><b>SCS_DOS_BINARY</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> An MS-DOS – based application </td>
///                   </tr> <tr> <td width="40%"><a id="SCS_OS216_BINARY"></a><a id="scs_os216_binary"></a><dl>
///                   <dt><b>SCS_OS216_BINARY</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> A 16-bit OS/2-based application </td>
///                   </tr> <tr> <td width="40%"><a id="SCS_PIF_BINARY"></a><a id="scs_pif_binary"></a><dl>
///                   <dt><b>SCS_PIF_BINARY</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> A PIF file that executes an MS-DOS –
///                   based application </td> </tr> <tr> <td width="40%"><a id="SCS_POSIX_BINARY"></a><a id="scs_posix_binary"></a><dl>
///                   <dt><b>SCS_POSIX_BINARY</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> A POSIX – based application </td>
///                   </tr> <tr> <td width="40%"><a id="SCS_WOW_BINARY"></a><a id="scs_wow_binary"></a><dl>
///                   <dt><b>SCS_WOW_BINARY</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> A 16-bit Windows-based application </td>
///                   </tr> </table>
///Returns:
///    If the file is executable, the return value is nonzero. The function sets the variable pointed to by
///    <i>lpBinaryType</i> to indicate the file's executable type. If the file is not executable, or if the function
///    fails, the return value is zero. To get extended error information, call GetLastError. If the file is a DLL, the
///    last error code is <b>ERROR_BAD_EXE_FORMAT</b>.
///    
@DllImport("KERNEL32")
BOOL GetBinaryTypeW(const(wchar)* lpApplicationName, uint* lpBinaryType);

///Retrieves the short path form of the specified path. For more information about file and path names, see Naming
///Files, Paths, and Namespaces.
///Params:
///    lpszLongPath = The path string. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To
///                   extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the
///                   path. For more information, see Naming Files, Paths, and Namespaces.
///    lpszShortPath = A pointer to a buffer to receive the null-terminated short form of the path that <i>lpszLongPath</i> specifies.
///                    Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i> will always return the required buffer size
///                    for a specified <i>lpszLongPath</i>.
///    cchBuffer = The size of the buffer that <i>lpszShortPath</i> points to, in <b>TCHARs</b>. Set this parameter to zero if
///                <i>lpszShortPath</i> is set to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string that is copied to
///    <i>lpszShortPath</i>, not including the terminating null character. If the <i>lpszShortPath</i> buffer is too
///    small to contain the path, the return value is the size of the buffer, in <b>TCHARs</b>, that is required to hold
///    the path and the terminating null character. If the function fails for any other reason, the return value is
///    zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetShortPathNameA(const(char)* lpszLongPath, const(char)* lpszShortPath, uint cchBuffer);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Converts the specified
///path to its long form as a transacted operation. To perform this operation without a transaction, use the
///GetLongPathName function. For more information about file and path names, see Naming Files, Paths, and Namespaces.
///Params:
///    lpszShortPath = The path to be converted. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> (260)
///                    characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                    "\\?\" to the path. For more information, see Naming Files, Paths, and Namespaces. The path must reside on the
///                    local computer; otherwise, the function fails and the last error code is set to
///                    <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    lpszLongPath = A pointer to the buffer to receive the long path. You can use the same buffer you used for the
///                   <i>lpszShortPath</i> parameter.
///    cchBuffer = The size of the buffer <i>lpszLongPath</i> points to, in <b>TCHAR</b>s.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is the length, in <b>TCHAR</b>s, of the string copied to
///    <i>lpszLongPath</i>, not including the terminating null character. If the <i>lpBuffer</i> buffer is too small to
///    contain the path, the return value is the size, in <b>TCHAR</b>s, of the buffer that is required to hold the path
///    and the terminating null character. If the function fails for any other reason, such as if the file does not
///    exist, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetLongPathNameTransactedA(const(char)* lpszShortPath, const(char)* lpszLongPath, uint cchBuffer, 
                                HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Converts the specified
///path to its long form as a transacted operation. To perform this operation without a transaction, use the
///GetLongPathName function. For more information about file and path names, see Naming Files, Paths, and Namespaces.
///Params:
///    lpszShortPath = The path to be converted. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> (260)
///                    characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                    "\\?\" to the path. For more information, see Naming Files, Paths, and Namespaces. The path must reside on the
///                    local computer; otherwise, the function fails and the last error code is set to
///                    <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    lpszLongPath = A pointer to the buffer to receive the long path. You can use the same buffer you used for the
///                   <i>lpszShortPath</i> parameter.
///    cchBuffer = The size of the buffer <i>lpszLongPath</i> points to, in <b>TCHAR</b>s.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is the length, in <b>TCHAR</b>s, of the string copied to
///    <i>lpszLongPath</i>, not including the terminating null character. If the <i>lpBuffer</i> buffer is too small to
///    contain the path, the return value is the size, in <b>TCHAR</b>s, of the buffer that is required to hold the path
///    and the terminating null character. If the function fails for any other reason, such as if the file does not
///    exist, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetLongPathNameTransactedW(const(wchar)* lpszShortPath, const(wchar)* lpszLongPath, uint cchBuffer, 
                                HANDLE hTransaction);

///Sets the notification modes for a file handle, allowing you to specify how completion notifications work for the
///specified file.
///Params:
///    FileHandle = A handle to the file.
///    Flags = The modes to be set. One or more modes can be set at the same time; however, after a mode has been set for a file
///            handle, it cannot be removed. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="FILE_SKIP_COMPLETION_PORT_ON_SUCCESS"></a><a id="file_skip_completion_port_on_success"></a><dl>
///            <dt><b>FILE_SKIP_COMPLETION_PORT_ON_SUCCESS</b></dt> <dt>0x1</dt> </dl> </td> <td width="60%"> If the following
///            three conditions are true, the I/O Manager does not queue a completion entry to the port, when it would
///            ordinarily do so. The conditions are: <ul> <li>A completion port is associated with the file handle.</li> <li>The
///            file is opened for asynchronous I/O.</li> <li>A request returns success immediately without returning
///            <b>ERROR_PENDING</b>.</li> </ul> When the <i>FileHandle</i> parameter is a socket, this mode is only compatible
///            with Layered Service Providers (LSP) that return Installable File Systems (IFS) handles. To detect whether a
///            non-IFS LSP is installed, use the WSAEnumProtocols function and examine the <b>dwServiceFlag1</b> member in each
///            returned WSAPROTOCOL_INFO structure. If the <b>XP1_IFS_HANDLES</b> (0x20000) bit is cleared then the specified
///            LSP is not an IFS LSP. Vendors that have non-IFS LSPs are encouraged to migrate to the Windows Filtering Platform
///            (WFP). </td> </tr> <tr> <td width="40%"><a id="FILE_SKIP_SET_EVENT_ON_HANDLE"></a><a
///            id="file_skip_set_event_on_handle"></a><dl> <dt><b>FILE_SKIP_SET_EVENT_ON_HANDLE</b></dt> <dt>0x2</dt> </dl>
///            </td> <td width="60%"> The I/O Manager does not set the event for the file object if a request returns with a
///            success code, or the error returned is <b>ERROR_PENDING</b> and the function that is called is not a synchronous
///            function. If an explicit event is provided for the request, it is still signaled. </td> </tr> </table>
///Returns:
///    Returns nonzero if successful or zero otherwise. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetFileCompletionNotificationModes(HANDLE FileHandle, ubyte Flags);

///Sets the short name for the specified file. The file must be on an NTFS file system volume.
///Params:
///    hFile = A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access right or
///            <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the <b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.
///    lpShortName = A pointer to a string that specifies the short name for the file. Specifying an empty (zero-length) string will
///                  remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If a short file
///                  name does not exist, the function will do nothing and return success. <b>Windows Server 2008, Windows Vista,
///                  Windows Server 2003 and Windows XP: </b>This behavior is not supported. The parameter must contain a valid string
///                  of one or more characters.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. <b>GetLastError</b> may return one of the following error codes
///    that are specific to this function. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td> <td width="60%"> The specified short name is
///    not unique. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> Either the specified file has been opened in case-sensitive mode or the specified short name is
///    invalid. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL SetFileShortNameA(HANDLE hFile, const(char)* lpShortName);

///Sets the short name for the specified file. The file must be on an NTFS file system volume.
///Params:
///    hFile = A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access right or
///            <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the <b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.
///    lpShortName = A pointer to a string that specifies the short name for the file. Specifying an empty (zero-length) string will
///                  remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If a short file
///                  name does not exist, the function will do nothing and return success. <b>Windows Server 2008, Windows Vista,
///                  Windows Server 2003 and Windows XP: </b>This behavior is not supported. The parameter must contain a valid string
///                  of one or more characters.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. <b>GetLastError</b> may return one of the following error codes
///    that are specific to this function. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td> <td width="60%"> The specified short name is
///    not unique. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> Either the specified file has been opened in case-sensitive mode or the specified short name is
///    invalid. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL SetFileShortNameW(HANDLE hFile, const(wchar)* lpShortName);

///Encrypts a file or directory. All data streams in a file are encrypted. All new files created in an encrypted
///directory are encrypted.
///Params:
///    lpFileName = The name of the file or directory to be encrypted. The caller must have the <b>FILE_READ_DATA</b>,
///                 <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access
///                 rights. For more information, see File Security and Access Rights.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL EncryptFileA(const(char)* lpFileName);

///Encrypts a file or directory. All data streams in a file are encrypted. All new files created in an encrypted
///directory are encrypted.
///Params:
///    lpFileName = The name of the file or directory to be encrypted. The caller must have the <b>FILE_READ_DATA</b>,
///                 <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access
///                 rights. For more information, see File Security and Access Rights.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL EncryptFileW(const(wchar)* lpFileName);

///Decrypts an encrypted file or directory.
///Params:
///    lpFileName = The name of the file or directory to be decrypted. The caller must have the <b>FILE_READ_DATA</b>,
///                 <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access
///                 rights. For more information, see File Security and Access Rights.
///    dwReserved = Reserved; must be zero.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL DecryptFileA(const(char)* lpFileName, uint dwReserved);

///Decrypts an encrypted file or directory.
///Params:
///    lpFileName = The name of the file or directory to be decrypted. The caller must have the <b>FILE_READ_DATA</b>,
///                 <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access
///                 rights. For more information, see File Security and Access Rights.
///    dwReserved = Reserved; must be zero.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL DecryptFileW(const(wchar)* lpFileName, uint dwReserved);

///Retrieves the encryption status of the specified file.
///Params:
///    lpFileName = The name of the file.
///    lpStatus = A pointer to a variable that receives the encryption status of the file. This parameter can be one of the
///               following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="FILE_ENCRYPTABLE"></a><a id="file_encryptable"></a><dl> <dt><b>FILE_ENCRYPTABLE</b></dt> <dt>0</dt> </dl>
///               </td> <td width="60%"> The file can be encrypted. <b>Home, Home Premium, Starter, and ARM Editions of Windows:
///               </b><b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on these editions of
///               Windows. </td> </tr> <tr> <td width="40%"><a id="FILE_IS_ENCRYPTED"></a><a id="file_is_encrypted"></a><dl>
///               <dt><b>FILE_IS_ENCRYPTED</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The file is encrypted. </td> </tr> <tr>
///               <td width="40%"><a id="FILE_READ_ONLY"></a><a id="file_read_only"></a><dl> <dt><b>FILE_READ_ONLY</b></dt>
///               <dt>8</dt> </dl> </td> <td width="60%"> The file is a read-only file. </td> </tr> <tr> <td width="40%"><a
///               id="FILE_ROOT_DIR"></a><a id="file_root_dir"></a><dl> <dt><b>FILE_ROOT_DIR</b></dt> <dt>3</dt> </dl> </td> <td
///               width="60%"> The file is a root directory. Root directories cannot be encrypted. </td> </tr> <tr> <td
///               width="40%"><a id="FILE_SYSTEM_ATTR"></a><a id="file_system_attr"></a><dl> <dt><b>FILE_SYSTEM_ATTR</b></dt>
///               <dt>2</dt> </dl> </td> <td width="60%"> The file is a system file. System files cannot be encrypted. </td> </tr>
///               <tr> <td width="40%"><a id="FILE_SYSTEM_DIR"></a><a id="file_system_dir"></a><dl> <dt><b>FILE_SYSTEM_DIR</b></dt>
///               <dt>4</dt> </dl> </td> <td width="60%"> The file is a system directory. System directories cannot be encrypted.
///               </td> </tr> <tr> <td width="40%"><a id="FILE_SYSTEM_NOT_SUPPORT"></a><a id="file_system_not_support"></a><dl>
///               <dt><b>FILE_SYSTEM_NOT_SUPPORT</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> The file system does not support
///               file encryption. </td> </tr> <tr> <td width="40%"><a id="FILE_UNKNOWN"></a><a id="file_unknown"></a><dl>
///               <dt><b>FILE_UNKNOWN</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> The encryption status is unknown. The file
///               may be encrypted. </td> </tr> <tr> <td width="40%"><a id="FILE_USER_DISALLOWED"></a><a
///               id="file_user_disallowed"></a><dl> <dt><b>FILE_USER_DISALLOWED</b></dt> <dt>7</dt> </dl> </td> <td width="60%">
///               Reserved for future use. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL FileEncryptionStatusA(const(char)* lpFileName, uint* lpStatus);

///Retrieves the encryption status of the specified file.
///Params:
///    lpFileName = The name of the file.
///    lpStatus = A pointer to a variable that receives the encryption status of the file. This parameter can be one of the
///               following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="FILE_ENCRYPTABLE"></a><a id="file_encryptable"></a><dl> <dt><b>FILE_ENCRYPTABLE</b></dt> <dt>0</dt> </dl>
///               </td> <td width="60%"> The file can be encrypted. <b>Home, Home Premium, Starter, and ARM Editions of Windows:
///               </b><b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on these editions of
///               Windows. </td> </tr> <tr> <td width="40%"><a id="FILE_IS_ENCRYPTED"></a><a id="file_is_encrypted"></a><dl>
///               <dt><b>FILE_IS_ENCRYPTED</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The file is encrypted. </td> </tr> <tr>
///               <td width="40%"><a id="FILE_READ_ONLY"></a><a id="file_read_only"></a><dl> <dt><b>FILE_READ_ONLY</b></dt>
///               <dt>8</dt> </dl> </td> <td width="60%"> The file is a read-only file. </td> </tr> <tr> <td width="40%"><a
///               id="FILE_ROOT_DIR"></a><a id="file_root_dir"></a><dl> <dt><b>FILE_ROOT_DIR</b></dt> <dt>3</dt> </dl> </td> <td
///               width="60%"> The file is a root directory. Root directories cannot be encrypted. </td> </tr> <tr> <td
///               width="40%"><a id="FILE_SYSTEM_ATTR"></a><a id="file_system_attr"></a><dl> <dt><b>FILE_SYSTEM_ATTR</b></dt>
///               <dt>2</dt> </dl> </td> <td width="60%"> The file is a system file. System files cannot be encrypted. </td> </tr>
///               <tr> <td width="40%"><a id="FILE_SYSTEM_DIR"></a><a id="file_system_dir"></a><dl> <dt><b>FILE_SYSTEM_DIR</b></dt>
///               <dt>4</dt> </dl> </td> <td width="60%"> The file is a system directory. System directories cannot be encrypted.
///               </td> </tr> <tr> <td width="40%"><a id="FILE_SYSTEM_NOT_SUPPORT"></a><a id="file_system_not_support"></a><dl>
///               <dt><b>FILE_SYSTEM_NOT_SUPPORT</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> The file system does not support
///               file encryption. </td> </tr> <tr> <td width="40%"><a id="FILE_UNKNOWN"></a><a id="file_unknown"></a><dl>
///               <dt><b>FILE_UNKNOWN</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> The encryption status is unknown. The file
///               may be encrypted. </td> </tr> <tr> <td width="40%"><a id="FILE_USER_DISALLOWED"></a><a
///               id="file_user_disallowed"></a><dl> <dt><b>FILE_USER_DISALLOWED</b></dt> <dt>7</dt> </dl> </td> <td width="60%">
///               Reserved for future use. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL FileEncryptionStatusW(const(wchar)* lpFileName, uint* lpStatus);

///Opens an encrypted file in order to backup (export) or restore (import) the file. This is one of a group of Encrypted
///File System (EFS) functions that is intended to implement backup and restore functionality, while maintaining files
///in their encrypted state.
///Params:
///    lpFileName = The name of the file to be opened. The string must consist of characters from the Windows character set.
///    ulFlags = The operation to be performed. This parameter may be one of the following values. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Open the file for
///              export (backup). </td> </tr> <tr> <td width="40%"><a id="CREATE_FOR_IMPORT"></a><a
///              id="create_for_import"></a><dl> <dt><b>CREATE_FOR_IMPORT</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The
///              file is being opened for import (restore). </td> </tr> <tr> <td width="40%"><a id="CREATE_FOR_DIR"></a><a
///              id="create_for_dir"></a><dl> <dt><b>CREATE_FOR_DIR</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Import
///              (restore) a directory containing encrypted files. This must be combined with one of the previous two flags to
///              indicate the operation. </td> </tr> <tr> <td width="40%"><a id="OVERWRITE_HIDDEN"></a><a
///              id="overwrite_hidden"></a><dl> <dt><b>OVERWRITE_HIDDEN</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Overwrite
///              a hidden file on import. </td> </tr> </table>
///    pvContext = The address of a context block that must be presented in subsequent calls to ReadEncryptedFileRaw,
///                WriteEncryptedFileRaw, or CloseEncryptedFileRaw. Do not modify it.
///Returns:
///    If the function succeeds, it returns <b>ERROR_SUCCESS</b>. If the function fails, it returns a nonzero error code
///    defined in WinError.h. You can use FormatMessage with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic
///    text description of the error.
///    
@DllImport("ADVAPI32")
uint OpenEncryptedFileRawA(const(char)* lpFileName, uint ulFlags, void** pvContext);

///Opens an encrypted file in order to backup (export) or restore (import) the file. This is one of a group of Encrypted
///File System (EFS) functions that is intended to implement backup and restore functionality, while maintaining files
///in their encrypted state.
///Params:
///    lpFileName = The name of the file to be opened. The string must consist of characters from the Windows character set.
///    ulFlags = The operation to be performed. This parameter may be one of the following values. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Open the file for
///              export (backup). </td> </tr> <tr> <td width="40%"><a id="CREATE_FOR_IMPORT"></a><a
///              id="create_for_import"></a><dl> <dt><b>CREATE_FOR_IMPORT</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The
///              file is being opened for import (restore). </td> </tr> <tr> <td width="40%"><a id="CREATE_FOR_DIR"></a><a
///              id="create_for_dir"></a><dl> <dt><b>CREATE_FOR_DIR</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Import
///              (restore) a directory containing encrypted files. This must be combined with one of the previous two flags to
///              indicate the operation. </td> </tr> <tr> <td width="40%"><a id="OVERWRITE_HIDDEN"></a><a
///              id="overwrite_hidden"></a><dl> <dt><b>OVERWRITE_HIDDEN</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Overwrite
///              a hidden file on import. </td> </tr> </table>
///    pvContext = The address of a context block that must be presented in subsequent calls to ReadEncryptedFileRaw,
///                WriteEncryptedFileRaw, or CloseEncryptedFileRaw. Do not modify it.
///Returns:
///    If the function succeeds, it returns <b>ERROR_SUCCESS</b>. If the function fails, it returns a nonzero error code
///    defined in WinError.h. You can use FormatMessage with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic
///    text description of the error.
///    
@DllImport("ADVAPI32")
uint OpenEncryptedFileRawW(const(wchar)* lpFileName, uint ulFlags, void** pvContext);

///Backs up (export) encrypted files. This is one of a group of Encrypted File System (EFS) functions that is intended
///to implement backup and restore functionality, while maintaining files in their encrypted state.
///Params:
///    pfExportCallback = A pointer to the export callback function. The system calls the callback function multiple times, each time
///                       passing a block of the file's data to the callback function until the entire file has been read. For more
///                       information, see ExportCallback.
///    pvCallbackContext = A pointer to an application-defined and allocated context block. The system passes this pointer to the callback
///                        function as a parameter so that the callback function can have access to application-specific data. This can be a
///                        structure and can contain any data the application needs, such as the handle to the file that will contain the
///                        backup copy of the encrypted file.
///    pvContext = A pointer to a system-defined context block. The context block is returned by the OpenEncryptedFileRaw function.
///                Do not modify it.
///Returns:
///    If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. If the function fails, it returns a nonzero
///    error code defined in WinError.h. You can use FormatMessage with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to
///    get a generic text description of the error.
///    
@DllImport("ADVAPI32")
uint ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, void* pvCallbackContext, void* pvContext);

///Restores (import) encrypted files. This is one of a group of Encrypted File System (EFS) functions that is intended
///to implement backup and restore functionality, while maintaining files in their encrypted state.
///Params:
///    pfImportCallback = A pointer to the import callback function. The system calls the callback function multiple times, each time
///                       passing a buffer that will be filled by the callback function with a portion of backed-up file's data. When the
///                       callback function signals that the entire file has been processed, it tells the system that the restore operation
///                       is finished. For more information, see ImportCallback.
///    pvCallbackContext = A pointer to an application-defined and allocated context block. The system passes this pointer to the callback
///                        function as a parameter so that the callback function can have access to application-specific data. This can be a
///                        structure and can contain any data the application needs, such as the handle to the file that will contain the
///                        backup copy of the encrypted file.
///    pvContext = A pointer to a system-defined context block. The context block is returned by the OpenEncryptedFileRaw function.
///                Do not modify it.
///Returns:
///    If the function succeeds, the return value is <b>ERROR_SUCCESS</b>. If the function fails, it returns a nonzero
///    error code defined in WinError.h. You can use FormatMessage with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to
///    get a generic text description of the error.
///    
@DllImport("ADVAPI32")
uint WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, void* pvCallbackContext, void* pvContext);

///Closes an encrypted file after a backup or restore operation, and frees associated system resources. This is one of a
///group of Encrypted File System (EFS) functions that is intended to implement backup and restore functionality, while
///maintaining files in their encrypted state.
///Params:
///    pvContext = A pointer to a system-defined context block. The OpenEncryptedFileRaw function returns the context block.
@DllImport("ADVAPI32")
void CloseEncryptedFileRaw(void* pvContext);

///Creates, opens, reopens, or deletes a file. <div class="alert"><b>Note</b> This function has limited capabilities and
///is not recommended. For new application development, use the CreateFile function.</div><div> </div>
///Params:
///    lpFileName = The name of the file. The string must consist of characters from the 8-bit Windows character set. The
///                 <b>OpenFile</b> function does not support Unicode file names or opening named pipes.
///    lpReOpenBuff = A pointer to the OFSTRUCT structure that receives information about a file when it is first opened. The structure
///                   can be used in subsequent calls to the <b>OpenFile</b> function to see an open file. The OFSTRUCT structure
///                   contains a path string member with a length that is limited to <b>OFS_MAXPATHNAME</b> characters, which is 128
///                   characters. Because of this, you cannot use the <b>OpenFile</b> function to open a file with a path length that
///                   exceeds 128 characters. The CreateFile function does not have this path length limitation.
///    uStyle = The action to be taken. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="OF_CANCEL"></a><a id="of_cancel"></a><dl>
///             <dt><b>OF_CANCEL</b></dt> <dt>0x00000800</dt> </dl> </td> <td width="60%"> Ignored. To produce a dialog box
///             containing a <b>Cancel</b> button, use <b>OF_PROMPT</b>. </td> </tr> <tr> <td width="40%"><a
///             id="OF_CREATE"></a><a id="of_create"></a><dl> <dt><b>OF_CREATE</b></dt> <dt>0x00001000</dt> </dl> </td> <td
///             width="60%"> Creates a new file. If the file exists, it is truncated to zero (0) length. </td> </tr> <tr> <td
///             width="40%"><a id="OF_DELETE"></a><a id="of_delete"></a><dl> <dt><b>OF_DELETE</b></dt> <dt>0x00000200</dt> </dl>
///             </td> <td width="60%"> Deletes a file. </td> </tr> <tr> <td width="40%"><a id="OF_EXIST"></a><a
///             id="of_exist"></a><dl> <dt><b>OF_EXIST</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> Opens a file and
///             then closes it. Use this to test for the existence of a file. </td> </tr> <tr> <td width="40%"><a
///             id="OF_PARSE"></a><a id="of_parse"></a><dl> <dt><b>OF_PARSE</b></dt> <dt>0x00000100</dt> </dl> </td> <td
///             width="60%"> Fills the OFSTRUCT structure, but does not do anything else. </td> </tr> <tr> <td width="40%"><a
///             id="OF_PROMPT"></a><a id="of_prompt"></a><dl> <dt><b>OF_PROMPT</b></dt> <dt>0x00002000</dt> </dl> </td> <td
///             width="60%"> Displays a dialog box if a requested file does not exist. A dialog box informs a user that the
///             system cannot find a file, and it contains <b>Retry</b> and <b>Cancel</b> buttons. The <b>Cancel</b> button
///             directs <b>OpenFile</b> to return a file-not-found error message. </td> </tr> <tr> <td width="40%"><a
///             id="OF_READ"></a><a id="of_read"></a><dl> <dt><b>OF_READ</b></dt> <dt>0x00000000</dt> </dl> </td> <td
///             width="60%"> Opens a file for reading only. </td> </tr> <tr> <td width="40%"><a id="OF_READWRITE"></a><a
///             id="of_readwrite"></a><dl> <dt><b>OF_READWRITE</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Opens a
///             file with read/write permissions. </td> </tr> <tr> <td width="40%"><a id="OF_REOPEN"></a><a
///             id="of_reopen"></a><dl> <dt><b>OF_REOPEN</b></dt> <dt>0x00008000</dt> </dl> </td> <td width="60%"> Opens a file
///             by using information in the reopen buffer. </td> </tr> <tr> <td width="40%"><a id="OF_SHARE_COMPAT"></a><a
///             id="of_share_compat"></a><dl> <dt><b>OF_SHARE_COMPAT</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%">
///             For MS-DOS–based file systems, opens a file with compatibility mode, allows any process on a specified computer
///             to open the file any number of times. Other efforts to open a file with other sharing modes fail. This flag is
///             mapped to the <b>FILE_SHARE_READ</b>|<b>FILE_SHARE_WRITE</b> flags of the CreateFile function. </td> </tr> <tr>
///             <td width="40%"><a id="OF_SHARE_DENY_NONE"></a><a id="of_share_deny_none"></a><dl>
///             <dt><b>OF_SHARE_DENY_NONE</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> Opens a file without denying
///             read or write access to other processes. On MS-DOS-based file systems, if the file has been opened in
///             compatibility mode by any other process, the function fails. This flag is mapped to the
///             <b>FILE_SHARE_READ</b>|<b>FILE_SHARE_WRITE</b> flags of the CreateFile function. </td> </tr> <tr> <td
///             width="40%"><a id="OF_SHARE_DENY_READ"></a><a id="of_share_deny_read"></a><dl> <dt><b>OF_SHARE_DENY_READ</b></dt>
///             <dt>0x00000030</dt> </dl> </td> <td width="60%"> Opens a file and denies read access to other processes. On
///             MS-DOS-based file systems, if the file has been opened in compatibility mode, or for read access by any other
///             process, the function fails. This flag is mapped to the <b>FILE_SHARE_WRITE</b> flag of the CreateFile function.
///             </td> </tr> <tr> <td width="40%"><a id="OF_SHARE_DENY_WRITE"></a><a id="of_share_deny_write"></a><dl>
///             <dt><b>OF_SHARE_DENY_WRITE</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> Opens a file and denies
///             write access to other processes. On MS-DOS-based file systems, if a file has been opened in compatibility mode,
///             or for write access by any other process, the function fails. This flag is mapped to the <b>FILE_SHARE_READ</b>
///             flag of the CreateFile function. </td> </tr> <tr> <td width="40%"><a id="OF_SHARE_EXCLUSIVE"></a><a
///             id="of_share_exclusive"></a><dl> <dt><b>OF_SHARE_EXCLUSIVE</b></dt> <dt>0x00000010</dt> </dl> </td> <td
///             width="60%"> Opens a file with exclusive mode, and denies both read/write access to other processes. If a file
///             has been opened in any other mode for read/write access, even by the current process, the function fails. </td>
///             </tr> <tr> <td width="40%"><a id="OF_VERIFY"></a><a id="of_verify"></a><dl> <dt><b>OF_VERIFY</b></dt> </dl> </td>
///             <td width="60%"> Verifies that the date and time of a file are the same as when it was opened previously. This is
///             useful as an extra check for read-only files. </td> </tr> <tr> <td width="40%"><a id="OF_WRITE"></a><a
///             id="of_write"></a><dl> <dt><b>OF_WRITE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Opens a file for
///             write access only. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value specifies a file handle to use when performing file I/O. To close the
///    file, call the CloseHandle function using this handle. If the function fails, the return value is
///    <b>HFILE_ERROR</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
int OpenFile(const(char)* lpFileName, OFSTRUCT* lpReOpenBuff, uint uStyle);

///Fills a buffer with strings that specify valid drives in the system.
///Params:
///    nBufferLength = The maximum size of the buffer pointed to by <i>lpBuffer</i>, in <b>TCHARs</b>. This size does not include the
///                    terminating null character. If this parameter is zero, <i>lpBuffer</i> is not used.
///    lpBuffer = A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the system,
///               plus with an additional null character. Each string is a device name.
///Returns:
///    If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not
///    including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode
///    (UTF-16) null character uses two bytes. If the buffer is not large enough, the return value is greater than
///    <i>nBufferLength</i>. It is the size of the buffer required to hold the drive strings. If the function fails, the
///    return value is zero. To get extended error information, use the GetLastError function.
///    
@DllImport("KERNEL32")
uint GetLogicalDriveStringsA(uint nBufferLength, const(char)* lpBuffer);

///Enables or disables file system redirection for the calling thread. This function may not work reliably when there
///are nested calls. Therefore, this function has been replaced by the Wow64DisableWow64FsRedirection and
///Wow64RevertWow64FsRedirection functions. <div class="alert"><b>Note</b> These two methods of controlling file system
///redirection cannot be combined in any way. Do not use the <b>Wow64EnableWow64FsRedirection</b> function with either
///the Wow64DisableWow64FsRedirection or the Wow64RevertWow64FsRedirection function.</div><div> </div>
///Params:
///    Wow64FsEnableRedirection = Indicates the type of request for WOW64 system folder redirection. If <b>TRUE</b>, requests redirection be
///                               enabled; if <b>FALSE</b>, requests redirection be disabled.
///Returns:
///    Boolean value indicating whether the function succeeded. If <b>TRUE</b>, the function succeeded; if <b>FALSE</b>,
///    the function failed.
///    
@DllImport("KERNEL32")
ubyte Wow64EnableWow64FsRedirection(ubyte Wow64FsEnableRedirection);

///Sets the per-process mode that the SearchPath function uses when locating files.
///Params:
///    Flags = The search mode to use. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE"></a><a id="base_search_path_enable_safe_searchmode"></a><dl>
///            <dt><b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Enable
///            safe process search mode for the process. </td> </tr> <tr> <td width="40%"><a
///            id="BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE"></a><a id="base_search_path_disable_safe_searchmode"></a><dl>
///            <dt><b>BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> Disable
///            safe process search mode for the process. </td> </tr> <tr> <td width="40%"><a
///            id="BASE_SEARCH_PATH_PERMANENT"></a><a id="base_search_path_permanent"></a><dl>
///            <dt><b>BASE_SEARCH_PATH_PERMANENT</b></dt> <dt>0x00008000</dt> </dl> </td> <td width="60%"> Optional flag to use
///            in combination with <b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b> to make this mode permanent for this process.
///            This is done by bitwise <b>OR</b> operation: <code>(BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE |
///            BASE_SEARCH_PATH_PERMANENT)</code> This flag cannot be combined with the
///            <b>BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE</b> flag. </td> </tr> </table>
///Returns:
///    If the operation completes successfully, the <b>SetSearchPathMode</b> function returns a nonzero value. If the
///    operation fails, the <b>SetSearchPathMode</b> function returns zero. To get extended error information, call the
///    GetLastError function. If the <b>SetSearchPathMode</b> function fails because a parameter value is not valid, the
///    value returned by the GetLastError function will be <b>ERROR_INVALID_PARAMETER</b>. If the
///    <b>SetSearchPathMode</b> function fails because the combination of current state and parameter value is not
///    valid, the value returned by the GetLastError function will be <b>ERROR_ACCESS_DENIED</b>. For more information,
///    see the Remarks section.
///    
@DllImport("KERNEL32")
BOOL SetSearchPathMode(uint Flags);

///Creates a new directory with the attributes of a specified template directory. If the underlying file system supports
///security on files and directories, the function applies a specified security descriptor to the new directory. The new
///directory retains the other attributes of the specified template directory. To perform this operation as a transacted
///operation, use the CreateDirectoryTransacted function.
///Params:
///    lpTemplateDirectory = The path of the directory to use as a template when creating the new directory. In the ANSI version of this
///                          function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call
///                          the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File. <div
///                          class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode version of this function
///                          (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending
///                          "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section
///                          of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    lpNewDirectory = The path of the directory to be created. In the ANSI version of this function, the name is limited to
///                     <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                     function and prepend "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b>
///                     Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you
///                     can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". The 255 character limit
///                     per path segment still applies. See the "Maximum Path Length Limitation" section of Naming Files, Paths, and
///                     Namespaces for details.</div> <div> </div>
///    lpSecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a
///                           security descriptor for the new directory. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a
///                           default security descriptor. The access control lists (ACL) in the default security descriptor for a directory
///                           are inherited from its parent directory. The target file system must support security on files and directories
///                           for this parameter to have an effect. This is indicated when GetVolumeInformation returns
///                           <b>FS_PERSISTENT_ACLS</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. Possible errors include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td>
///    <td width="60%"> The specified directory already exists. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> One or more intermediate directories do not
///    exist. This function only creates the final directory in the path. To create all intermediate directories on the
///    path, use the SHCreateDirectoryEx function. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL CreateDirectoryExA(const(char)* lpTemplateDirectory, const(char)* lpNewDirectory, 
                        SECURITY_ATTRIBUTES* lpSecurityAttributes);

///Creates a new directory with the attributes of a specified template directory. If the underlying file system supports
///security on files and directories, the function applies a specified security descriptor to the new directory. The new
///directory retains the other attributes of the specified template directory. To perform this operation as a transacted
///operation, use the CreateDirectoryTransacted function.
///Params:
///    lpTemplateDirectory = The path of the directory to use as a template when creating the new directory. In the ANSI version of this
///                          function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call
///                          the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File. <div
///                          class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode version of this function
///                          (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending
///                          "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section
///                          of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    lpNewDirectory = The path of the directory to be created. In the ANSI version of this function, the name is limited to
///                     <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                     function and prepend "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b>
///                     Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you
///                     can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". The 255 character limit
///                     per path segment still applies. See the "Maximum Path Length Limitation" section of Naming Files, Paths, and
///                     Namespaces for details.</div> <div> </div>
///    lpSecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a
///                           security descriptor for the new directory. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a
///                           default security descriptor. The access control lists (ACL) in the default security descriptor for a directory
///                           are inherited from its parent directory. The target file system must support security on files and directories
///                           for this parameter to have an effect. This is indicated when GetVolumeInformation returns
///                           <b>FS_PERSISTENT_ACLS</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. Possible errors include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td>
///    <td width="60%"> The specified directory already exists. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> One or more intermediate directories do not
///    exist. This function only creates the final directory in the path. To create all intermediate directories on the
///    path, use the SHCreateDirectoryEx function. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL CreateDirectoryExW(const(wchar)* lpTemplateDirectory, const(wchar)* lpNewDirectory, 
                        SECURITY_ATTRIBUTES* lpSecurityAttributes);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Creates a new directory
///as a transacted operation, with the attributes of a specified template directory. If the underlying file system
///supports security on files and directories, the function applies a specified security descriptor to the new
///directory. The new directory retains the other attributes of the specified template directory.
///Params:
///    lpTemplateDirectory = The path of the directory to use as a template when creating the new directory. This parameter can be
///                          <b>NULL</b>. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend
///                          this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path.
///                          For more information, see Naming a File. The directory must reside on the local computer; otherwise, the function
///                          fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    lpNewDirectory = The path of the directory to be created. In the ANSI version of this function, the name is limited to
///                     <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                     function and prepend "\\?\" to the path. For more information, see Naming a File.
///    lpSecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a
///                           security descriptor for the new directory. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a
///                           default security descriptor. The access control lists (ACL) in the default security descriptor for a directory
///                           are inherited from its parent directory. The target file system must support security on files and directories
///                           for this parameter to have an effect. This is indicated when GetVolumeInformation returns
///                           <b>FS_PERSISTENT_ACLS</b>.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. Possible errors include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td>
///    <td width="60%"> The specified directory already exists. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION</b></dt> </dl> </td> <td width="60%"> You cannot create a child
///    directory with a parent directory that has encryption disabled. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> One or more intermediate directories do not
///    exist. This function only creates the final directory in the path. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL CreateDirectoryTransactedA(const(char)* lpTemplateDirectory, const(char)* lpNewDirectory, 
                                SECURITY_ATTRIBUTES* lpSecurityAttributes, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Creates a new directory
///as a transacted operation, with the attributes of a specified template directory. If the underlying file system
///supports security on files and directories, the function applies a specified security descriptor to the new
///directory. The new directory retains the other attributes of the specified template directory.
///Params:
///    lpTemplateDirectory = The path of the directory to use as a template when creating the new directory. This parameter can be
///                          <b>NULL</b>. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend
///                          this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path.
///                          For more information, see Naming a File. The directory must reside on the local computer; otherwise, the function
///                          fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    lpNewDirectory = The path of the directory to be created. In the ANSI version of this function, the name is limited to
///                     <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                     function and prepend "\\?\" to the path. For more information, see Naming a File.
///    lpSecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a
///                           security descriptor for the new directory. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a
///                           default security descriptor. The access control lists (ACL) in the default security descriptor for a directory
///                           are inherited from its parent directory. The target file system must support security on files and directories
///                           for this parameter to have an effect. This is indicated when GetVolumeInformation returns
///                           <b>FS_PERSISTENT_ACLS</b>.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. Possible errors include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ALREADY_EXISTS</b></dt> </dl> </td>
///    <td width="60%"> The specified directory already exists. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION</b></dt> </dl> </td> <td width="60%"> You cannot create a child
///    directory with a parent directory that has encryption disabled. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> One or more intermediate directories do not
///    exist. This function only creates the final directory in the path. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL CreateDirectoryTransactedW(const(wchar)* lpTemplateDirectory, const(wchar)* lpNewDirectory, 
                                SECURITY_ATTRIBUTES* lpSecurityAttributes, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Deletes an existing empty
///directory as a transacted operation.
///Params:
///    lpPathName = The path of the directory to be removed. The path must specify an empty directory, and the calling process must
///                 have delete access to the directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\?\" to the path. For more information, see Naming a File. The directory must reside on the local computer;
///                 otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL RemoveDirectoryTransactedA(const(char)* lpPathName, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Deletes an existing empty
///directory as a transacted operation.
///Params:
///    lpPathName = The path of the directory to be removed. The path must specify an empty directory, and the calling process must
///                 have delete access to the directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\?\" to the path. For more information, see Naming a File. The directory must reside on the local computer;
///                 otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL RemoveDirectoryTransactedW(const(wchar)* lpPathName, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Retrieves the full path
///and file name of the specified file as a transacted operation. To perform this operation without transactions, use
///the GetFullPathName function. For more information about file and path names, see File Names, Paths, and Namespaces.
///Params:
///    lpFileName = The name of the file. This string can use short (the 8.3 form) or long file names. This string can be a share or
///                 volume name. The file must reside on the local computer; otherwise, the function fails and the last error code is
///                 set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    nBufferLength = The size of the buffer to receive the null-terminated string for the drive and path, in <b>TCHARs</b>.
///    lpBuffer = A pointer to a buffer that receives the null-terminated string for the drive and path.
///    lpFilePart = A pointer to a buffer that receives the address (in <i>lpBuffer</i>) of the final file name component in the
///                 path. Specify <b>NULL</b> if you do not need to receive this information. If <i>lpBuffer</i> points to a
///                 directory and not a file, <i>lpFilePart</i> receives 0 (zero).
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to
///    <i>lpBuffer</i>, not including the terminating null character. If the <i>lpBuffer</i> buffer is too small to
///    contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path
///    and the terminating null character. If the function fails for any other reason, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetFullPathNameTransactedA(const(char)* lpFileName, uint nBufferLength, const(char)* lpBuffer, 
                                byte** lpFilePart, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Retrieves the full path
///and file name of the specified file as a transacted operation. To perform this operation without transactions, use
///the GetFullPathName function. For more information about file and path names, see File Names, Paths, and Namespaces.
///Params:
///    lpFileName = The name of the file. This string can use short (the 8.3 form) or long file names. This string can be a share or
///                 volume name. The file must reside on the local computer; otherwise, the function fails and the last error code is
///                 set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    nBufferLength = The size of the buffer to receive the null-terminated string for the drive and path, in <b>TCHARs</b>.
///    lpBuffer = A pointer to a buffer that receives the null-terminated string for the drive and path.
///    lpFilePart = A pointer to a buffer that receives the address (in <i>lpBuffer</i>) of the final file name component in the
///                 path. Specify <b>NULL</b> if you do not need to receive this information. If <i>lpBuffer</i> points to a
///                 directory and not a file, <i>lpFilePart</i> receives 0 (zero).
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to
///    <i>lpBuffer</i>, not including the terminating null character. If the <i>lpBuffer</i> buffer is too small to
///    contain the path, the return value is the size, in <b>TCHARs</b>, of the buffer that is required to hold the path
///    and the terminating null character. If the function fails for any other reason, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetFullPathNameTransactedW(const(wchar)* lpFileName, uint nBufferLength, const(wchar)* lpBuffer, 
                                ushort** lpFilePart, HANDLE hTransaction);

///Defines, redefines, or deletes MS-DOS device names.
///Params:
///    dwFlags = The controllable aspects of the <b>DefineDosDevice</b> function. This parameter can be one or more of the
///              following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="DDD_EXACT_MATCH_ON_REMOVE"></a><a id="ddd_exact_match_on_remove"></a><dl>
///              <dt><b>DDD_EXACT_MATCH_ON_REMOVE</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> If this value is
///              specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will use an exact match to determine which
///              mapping to remove. Use this value to ensure that you do not delete something that you did not define. </td> </tr>
///              <tr> <td width="40%"><a id="DDD_NO_BROADCAST_SYSTEM"></a><a id="ddd_no_broadcast_system"></a><dl>
///              <dt><b>DDD_NO_BROADCAST_SYSTEM</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> Do not broadcast the
///              WM_SETTINGCHANGE message. By default, this message is broadcast to notify the shell and applications of the
///              change. </td> </tr> <tr> <td width="40%"><a id="DDD_RAW_TARGET_PATH"></a><a id="ddd_raw_target_path"></a><dl>
///              <dt><b>DDD_RAW_TARGET_PATH</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Uses the <i>lpTargetPath</i>
///              string as is. Otherwise, it is converted from an MS-DOS path to a path. </td> </tr> <tr> <td width="40%"><a
///              id="DDD_REMOVE_DEFINITION"></a><a id="ddd_remove_definition"></a><dl> <dt><b>DDD_REMOVE_DEFINITION</b></dt>
///              <dt>0x00000002</dt> </dl> </td> <td width="60%"> Removes the specified definition for the specified device. To
///              determine which definition to remove, the function walks the list of mappings for the device, looking for a match
///              of <i>lpTargetPath</i> against a prefix of each mapping associated with this device. The first mapping that
///              matches is the one removed, and then the function returns. If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to
///              a <b>NULL</b> string, the function will remove the first mapping associated with the device and pop the most
///              recent one pushed. If there is nothing left to pop, the device name will be removed. If this value is not
///              specified, the string pointed to by the <i>lpTargetPath</i> parameter will become the new mapping for this
///              device. </td> </tr> </table>
///    lpDeviceName = A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or
///                   deleting. The device name string must not have a colon as the last character, unless a drive letter is being
///                   defined, redefined, or deleted. For example, drive C would be the string "C:". In no case is a trailing backslash
///                   ("\") allowed.
///    lpTargetPath = A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the
///                   <b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path string.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DefineDosDeviceA(uint dwFlags, const(char)* lpDeviceName, const(char)* lpTargetPath);

///Retrieves information about MS-DOS device names. The function can obtain the current mapping for a particular MS-DOS
///device name. The function can also obtain a list of all existing MS-DOS device names. MS-DOS device names are stored
///as junctions in the object namespace. The code that converts an MS-DOS path into a corresponding path uses these
///junctions to map MS-DOS devices and drive letters. The <b>QueryDosDevice</b> function enables an application to query
///the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific
///junction.
///Params:
///    lpDeviceName = An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing
///                   backslash; for example, use "C:", not "C:\\". This parameter can be <b>NULL</b>. In that case, the
///                   <b>QueryDosDevice</b> function will store a list of all existing MS-DOS device names into the buffer pointed to
///                   by <i>lpTargetPath</i>.
///    lpTargetPath = A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or more
///                   null-terminated strings. The final null-terminated string is followed by an additional <b>NULL</b>. If
///                   <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves information about the particular MS-DOS device
///                   specified by <i>lpDeviceName</i>. The first null-terminated string stored into the buffer is the current mapping
///                   for the device. The other null-terminated strings represent undeleted prior mappings for the device. If
///                   <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of all existing MS-DOS device names. Each
///                   null-terminated string stored into the buffer is the name of an existing MS-DOS device, for example,
///                   \Device\HarddiskVolume1 or \Device\Floppy0.
///    ucchMax = The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by <i>lpTargetPath</i>.
///Returns:
///    If the function succeeds, the return value is the number of <b>TCHARs</b> stored into the buffer pointed to by
///    <i>lpTargetPath</i>. If the function fails, the return value is zero. To get extended error information, call
///    GetLastError. If the buffer is too small, the function fails and the last error code is
///    <b>ERROR_INSUFFICIENT_BUFFER</b>.
///    
@DllImport("KERNEL32")
uint QueryDosDeviceA(const(char)* lpDeviceName, const(char)* lpTargetPath, uint ucchMax);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Creates or opens a file,
///file stream, or directory as a transacted operation. The function returns a handle that can be used to access the
///object. To perform this operation as a nontransacted operation or to access objects other than files (for example,
///named pipes, physical devices, mailslots), use the CreateFile function. For more information about transactions, see
///the Remarks section of this topic.
///Params:
///    lpFileName = The name of an object to be created or opened. The object must reside on the local computer; otherwise, the
///                 function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>. In the ANSI
///                 version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide
///                 characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see
///                 Naming a File. For information on special device names, see Defining an MS-DOS Device Name. To create a file
///                 stream, specify the name of the file, a colon, and then the name of the stream. For more information, see File
///                 Streams.
///    dwDesiredAccess = The access to the object, which can be summarized as read, write, both or neither (zero). The most commonly used
///                      values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both (<b>GENERIC_READ</b> | <b>GENERIC_WRITE</b>). For
///                      more information, see Generic Access Rights and File Security and Access Rights. If this parameter is zero, the
///                      application can query file, directory, or device attributes without accessing that file or device. For more
///                      information, see the Remarks section of this topic. You cannot request an access mode that conflicts with the
///                      sharing mode that is specified in an open request that has an open handle. For more information, see Creating and
///                      Opening Files.
///    dwShareMode = The sharing mode of an object, which can be read, write, both, delete, all of these, or none (refer to the
///                  following table). If this parameter is zero and <b>CreateFileTransacted</b> succeeds, the object cannot be shared
///                  and cannot be opened again until the handle is closed. For more information, see the Remarks section of this
///                  topic. You cannot request a sharing mode that conflicts with the access mode that is specified in an open request
///                  that has an open handle, because that would result in the following sharing violation:
///                  <b>ERROR_SHARING_VIOLATION</b>. For more information, see Creating and Opening Files. To enable a process to
///                  share an object while another process has the object open, use a combination of one or more of the following
///                  values to specify the access mode they can request to open the object. <div class="alert"><b>Note</b> The sharing
///                  options for each open handle remain in effect until that handle is closed, regardless of process context.</div>
///                  <div> </div> <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl>
///                  <dt><b>0</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> Disables subsequent open operations on an
///                  object to request any type of access to that object. </td> </tr> <tr> <td width="40%"><a
///                  id="FILE_SHARE_DELETE"></a><a id="file_share_delete"></a><dl> <dt><b>FILE_SHARE_DELETE</b></dt>
///                  <dt>0x00000004</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on an object to request
///                  delete access. Otherwise, other processes cannot open the object if they request delete access. If this flag is
///                  not specified, but the object has been opened for delete access, the function fails. </td> </tr> <tr> <td
///                  width="40%"><a id="FILE_SHARE_READ"></a><a id="file_share_read"></a><dl> <dt><b>FILE_SHARE_READ</b></dt>
///                  <dt>0x00000001</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on an object to request read
///                  access. Otherwise, other processes cannot open the object if they request read access. If this flag is not
///                  specified, but the object has been opened for read access, the function fails. </td> </tr> <tr> <td
///                  width="40%"><a id="FILE_SHARE_WRITE"></a><a id="file_share_write"></a><dl> <dt><b>FILE_SHARE_WRITE</b></dt>
///                  <dt>0x00000002</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on an object to request write
///                  access. Otherwise, other processes cannot open the object if they request write access. If this flag is not
///                  specified, but the object has been opened for write access or has a file mapping with write access, the function
///                  fails. </td> </tr> </table>
///    lpSecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure that contains an optional security descriptor and also determines
///                           whether or not the returned handle can be inherited by child processes. The parameter can be <b>NULL</b>. If the
///                           <i>lpSecurityAttributes</i> parameter is <b>NULL</b>, the handle returned by <b>CreateFileTransacted</b> cannot
///                           be inherited by any child processes your application may create and the object associated with the returned
///                           handle gets a default security descriptor. The <b>bInheritHandle</b> member of the structure specifies whether
///                           the returned handle can be inherited. The <b>lpSecurityDescriptor</b> member of the structure specifies a
///                           security descriptor for an object, but may also be <b>NULL</b>. If <b>lpSecurityDescriptor</b> member is
///                           <b>NULL</b>, the object associated with the returned handle is assigned a default security descriptor.
///                           <b>CreateFileTransacted</b> ignores the <b>lpSecurityDescriptor</b> member when opening an existing file, but
///                           continues to use the <b>bInheritHandle</b> member. For more information, see the Remarks section of this topic.
///    dwCreationDisposition = An action to take on files that exist and do not exist. For more information, see the Remarks section of this
///                            topic. This parameter must be one of the following values, which cannot be combined. <table> <tr> <th>Value</th>
///                            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CREATE_ALWAYS"></a><a id="create_always"></a><dl>
///                            <dt><b>CREATE_ALWAYS</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Creates a new file, always. If the
///                            specified file exists and is writable, the function overwrites the file, the function succeeds, and last-error
///                            code is set to <b>ERROR_ALREADY_EXISTS</b> (183). If the specified file does not exist and is a valid path, a new
///                            file is created, the function succeeds, and the last-error code is set to zero. For more information, see the
///                            Remarks section of this topic. </td> </tr> <tr> <td width="40%"><a id="CREATE_NEW"></a><a
///                            id="create_new"></a><dl> <dt><b>CREATE_NEW</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Creates a new file,
///                            only if it does not already exist. If the specified file exists, the function fails and the last-error code is
///                            set to <b>ERROR_FILE_EXISTS</b> (80). If the specified file does not exist and is a valid path to a writable
///                            location, a new file is created. </td> </tr> <tr> <td width="40%"><a id="OPEN_ALWAYS"></a><a
///                            id="open_always"></a><dl> <dt><b>OPEN_ALWAYS</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Opens a file,
///                            always. If the specified file exists, the function succeeds and the last-error code is set to
///                            <b>ERROR_ALREADY_EXISTS</b> (183). If the specified file does not exist and is a valid path to a writable
///                            location, the function creates a file and the last-error code is set to zero. </td> </tr> <tr> <td width="40%"><a
///                            id="OPEN_EXISTING"></a><a id="open_existing"></a><dl> <dt><b>OPEN_EXISTING</b></dt> <dt>3</dt> </dl> </td> <td
///                            width="60%"> Opens a file or device, only if it exists. If the specified file does not exist, the function fails
///                            and the last-error code is set to <b>ERROR_FILE_NOT_FOUND</b> (2). For more information, see the Remarks section
///                            of this topic. </td> </tr> <tr> <td width="40%"><a id="TRUNCATE_EXISTING"></a><a id="truncate_existing"></a><dl>
///                            <dt><b>TRUNCATE_EXISTING</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Opens a file and truncates it so that
///                            its size is zero bytes, only if it exists. If the specified file does not exist, the function fails and the
///                            last-error code is set to <b>ERROR_FILE_NOT_FOUND</b> (2). The calling process must open the file with the
///                            <b>GENERIC_WRITE</b> bit set as part of the <i>dwDesiredAccess</i> parameter. </td> </tr> </table>
///    dwFlagsAndAttributes = The file attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default value. This parameter
///                           can include any combination of the available file attributes (<b>FILE_ATTRIBUTE_*</b>). All other file attributes
///                           override <b>FILE_ATTRIBUTE_NORMAL</b>. This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>)
///                           for control of buffering behavior, access modes, and other special-purpose flags. These combine with any
///                           <b>FILE_ATTRIBUTE_*</b> values. This parameter can also contain Security Quality of Service (SQOS) information by
///                           specifying the <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in the
///                           table following the attributes and flags tables. <div class="alert"><b>Note</b> <p class="note">When
///                           <b>CreateFileTransacted</b> opens an existing file, it generally combines the file flags with the file attributes
///                           of the existing file, and ignores any file attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special
///                           cases are detailed in Creating and Opening Files. </div> <div> </div> The following file attributes and flags are
///                           used only for file objects, not other types of objects that <b>CreateFileTransacted</b> opens (additional
///                           information can be found in the Remarks section of this topic). For more advanced access to file attributes, see
///                           SetFileAttributes. For a complete list of all file attributes with their values and descriptions, see File
///                           Attribute Constants. <table> <tr> <th>Attribute</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                           id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl> <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
///                           <dt>32 (0x20)</dt> </dl> </td> <td width="60%"> The file should be archived. Applications use this attribute to
///                           mark files for backup or removal. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_ENCRYPTED"></a><a
///                           id="file_attribute_encrypted"></a><dl> <dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt> <dt>16384 (0x4000)</dt> </dl>
///                           </td> <td width="60%"> The file or directory is encrypted. For a file, this means that all data in the file is
///                           encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories.
///                           For more information, see File Encryption. This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also
///                           specified. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a
///                           id="file_attribute_hidden"></a><dl> <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt> <dt>2 (0x2)</dt> </dl> </td> <td
///                           width="60%"> The file is hidden. Do not include it in an ordinary directory listing. </td> </tr> <tr> <td
///                           width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt> <dt>128 (0x80)</dt> </dl> </td> <td width="60%"> The file does not have
///                           other attributes set. This attribute is valid only if used alone. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl> <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
///                           <dt>4096 (0x1000)</dt> </dl> </td> <td width="60%"> The data of a file is not immediately available. This
///                           attribute indicates that file data is physically moved to offline storage. This attribute is used by Remote
///                           Storage, the hierarchical storage management software. Applications should not arbitrarily change this attribute.
///                           </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_READONLY</b></dt> <dt>1 (0x1)</dt> </dl> </td> <td width="60%"> The file is read only.
///                           Applications can read the file, but cannot write to or delete it. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl> <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt> <dt>4
///                           (0x4)</dt> </dl> </td> <td width="60%"> The file is part of or used exclusively by an operating system. </td>
///                           </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt> <dt>256 (0x100)</dt> </dl> </td> <td width="60%"> The file is being used
///                           for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is
///                           available, because an application deletes a temporary file after a handle is closed. In that case, the system can
///                           entirely avoid writing the data. Otherwise, the data is written after the handle is closed. </td> </tr> </table>
///                           <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a
///                           id="file_flag_backup_semantics"></a><dl> <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt> <dt>0x02000000</dt> </dl>
///                           </td> <td width="60%"> The file is being opened or created for a backup or restore operation. The system ensures
///                           that the calling process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and
///                           <b>SE_RESTORE_NAME</b> privileges. For more information, see Changing Privileges in a Token. You must set this
///                           flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of a file
///                           handle. For more information, see Directory Handles. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_DELETE_ON_CLOSE"></a><a id="file_flag_delete_on_close"></a><dl>
///                           <dt><b>FILE_FLAG_DELETE_ON_CLOSE</b></dt> <dt>0x04000000</dt> </dl> </td> <td width="60%"> The file is to be
///                           deleted immediately after the last transacted writer handle to the file is closed, provided that the transaction
///                           is still active. If a file has been marked for deletion and a transacted writer handle is still open after the
///                           transaction completes, the file will not be deleted. If there are existing open handles to a file, the call fails
///                           unless they were all opened with the <b>FILE_SHARE_DELETE</b> share mode. Subsequent open requests for the file
///                           fail, unless the <b>FILE_SHARE_DELETE</b> share mode is specified. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl> <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
///                           <dt>0x20000000</dt> </dl> </td> <td width="60%"> The file is being opened with no system caching. This flag does
///                           not affect hard disk caching or memory mapped files. When combined with <b>FILE_FLAG_OVERLAPPED</b>, the flag
///                           gives maximum asynchronous performance, because the I/O does not rely on the synchronous operations of the memory
///                           manager. However, some I/O operations take more time, because data is not being held in the cache. Also, the file
///                           metadata may still be cached. To flush the metadata to disk, use the FlushFileBuffers function. An application
///                           must meet certain requirements when working with files that are opened with <b>FILE_FLAG_NO_BUFFERING</b>: <ul>
///                           <li>File access must begin at byte offsets within a file that are integer multiples of the volume sector
///                           size.</li> <li>File access must be for numbers of bytes that are integer multiples of the volume sector size. For
///                           example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, or 2048
///                           bytes, but not of 335, 981, or 7171 bytes.</li> <li>Buffer addresses for read and write operations should be
///                           sector aligned, which means aligned on addresses in memory that are integer multiples of the volume sector size.
///                           Depending on the disk, this requirement may not be enforced.</li> </ul> One way to align buffers on integer
///                           multiples of the volume sector size is to use VirtualAlloc to allocate the buffers. It allocates memory that is
///                           aligned on addresses that are integer multiples of the operating system's memory page size. Because both memory
///                           page and volume sector sizes are powers of 2, this memory is also aligned on addresses that are integer multiples
///                           of a volume sector size. Memory pages are 4 or 8 KB in size; sectors are 512 bytes (hard disks), 2048 bytes (CD),
///                           or 4096 bytes (hard disks), and therefore, volume sectors can never be larger than memory pages. An application
///                           can determine a volume sector size by calling the GetDiskFreeSpace function. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_OPEN_NO_RECALL"></a><a id="file_flag_open_no_recall"></a><dl>
///                           <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The file data is
///                           requested, but it should continue to be located in remote storage. It should not be transported back to local
///                           storage. This flag is for use by remote storage systems. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
///                           <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> Normal reparse
///                           point processing will not occur; <b>CreateFileTransacted</b> will attempt to open the reparse point. When a file
///                           is opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.
///                           This flag cannot be used with the <b>CREATE_ALWAYS</b> flag. If the file is not a reparse point, then this flag
///                           is ignored. </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a
///                           id="file_flag_overlapped"></a><dl> <dt><b>FILE_FLAG_OVERLAPPED</b></dt> <dt>0x40000000</dt> </dl> </td> <td
///                           width="60%"> The file is being opened or created for asynchronous I/O. When the operation is complete, the event
///                           specified in the OVERLAPPED structure is set to the signaled state. Operations that take a significant amount of
///                           time to process return <b>ERROR_IO_PENDING</b>. If this flag is specified, the file can be used for simultaneous
///                           read and write operations. The system does not maintain the file pointer, therefore you must pass the file
///                           position to the read and write functions in the OVERLAPPED structure or update the file pointer. If this flag is
///                           not specified, then I/O operations are serialized, even if the calls to the read and write functions specify an
///                           OVERLAPPED structure. </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_POSIX_SEMANTICS"></a><a
///                           id="file_flag_posix_semantics"></a><dl> <dt><b>FILE_FLAG_POSIX_SEMANTICS</b></dt> <dt>0x01000000</dt> </dl> </td>
///                           <td width="60%"> The file is to be accessed according to POSIX rules. This includes allowing multiple files with
///                           names, differing only in case, for file systems that support that naming. Use care when using this option,
///                           because files created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit
///                           Windows. </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_RANDOM_ACCESS"></a><a
///                           id="file_flag_random_access"></a><dl> <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt> <dt>0x10000000</dt> </dl> </td> <td
///                           width="60%"> The file is to be accessed randomly. The system can use this as a hint to optimize file caching.
///                           </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_SESSION_AWARE"></a><a id="file_flag_session_aware"></a><dl>
///                           <dt><b>FILE_FLAG_SESSION_AWARE</b></dt> <dt>0x00800000</dt> </dl> </td> <td width="60%"> The file or device is
///                           being opened with session awareness. If this flag is not specified, then per-session devices (such as a device
///                           using RemoteFX USB Redirection) cannot be opened by processes running in session 0. This flag has no effect for
///                           callers not in session 0. This flag is supported only on server editions of Windows. <b>Windows Server 2008 R2
///                           and Windows Server 2008: </b>This flag is not supported before Windows Server 2012. </td> </tr> <tr> <td
///                           width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
///                           <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt> <dt>0x08000000</dt> </dl> </td> <td width="60%"> The file is to be
///                           accessed sequentially from beginning to end. The system can use this as a hint to optimize file caching. If an
///                           application moves the file pointer for random access, optimum caching may not occur. However, correct operation
///                           is still guaranteed. Specifying this flag can increase performance for applications that read large files using
///                           sequential access. Performance gains can be even more noticeable for applications that read large files mostly
///                           sequentially, but occasionally skip over small ranges of bytes. This flag has no effect if the file system does
///                           not support cached I/O and <b>FILE_FLAG_NO_BUFFERING</b>. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl> <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt>
///                           <dt>0x80000000</dt> </dl> </td> <td width="60%"> Write operations will not go through any intermediate cache,
///                           they will go directly to disk. If <b>FILE_FLAG_NO_BUFFERING</b> is not also specified, so that system caching is
///                           in effect, then the data is written to the system cache, but is flushed to disk without delay. If
///                           <b>FILE_FLAG_NO_BUFFERING</b> is also specified, so that system caching is not in effect, then the data is
///                           immediately flushed to disk without going through the system cache. The operating system also requests a
///                           write-through the hard disk cache to persistent media. However, not all hardware supports this write-through
///                           capability. </td> </tr> </table> The <i>dwFlagsAndAttributes</i> parameter can also specify Security Quality of
///                           Service information. For more information, see Impersonation Levels. When the calling application specifies the
///                           <b>SECURITY_SQOS_PRESENT</b> flag as part of <i>dwFlagsAndAttributes</i>, it can also contain one or more of the
///                           following values. <table> <tr> <th>Security flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                           id="SECURITY_ANONYMOUS"></a><a id="security_anonymous"></a><dl> <dt><b>SECURITY_ANONYMOUS</b></dt> </dl> </td>
///                           <td width="60%"> Impersonates a client at the Anonymous impersonation level. </td> </tr> <tr> <td width="40%"><a
///                           id="SECURITY_CONTEXT_TRACKING"></a><a id="security_context_tracking"></a><dl>
///                           <dt><b>SECURITY_CONTEXT_TRACKING</b></dt> </dl> </td> <td width="60%"> The security tracking mode is dynamic. If
///                           this flag is not specified, the security tracking mode is static. </td> </tr> <tr> <td width="40%"><a
///                           id="SECURITY_DELEGATION"></a><a id="security_delegation"></a><dl> <dt><b>SECURITY_DELEGATION</b></dt> </dl> </td>
///                           <td width="60%"> Impersonates a client at the Delegation impersonation level. </td> </tr> <tr> <td width="40%"><a
///                           id="SECURITY_EFFECTIVE_ONLY"></a><a id="security_effective_only"></a><dl> <dt><b>SECURITY_EFFECTIVE_ONLY</b></dt>
///                           </dl> </td> <td width="60%"> Only the enabled aspects of the client's security context are available to the
///                           server. If you do not specify this flag, all aspects of the client's security context are available. This allows
///                           the client to limit the groups and privileges that a server can use while impersonating the client. </td> </tr>
///                           <tr> <td width="40%"><a id="SECURITY_IDENTIFICATION"></a><a id="security_identification"></a><dl>
///                           <dt><b>SECURITY_IDENTIFICATION</b></dt> </dl> </td> <td width="60%"> Impersonates a client at the Identification
///                           impersonation level. </td> </tr> <tr> <td width="40%"><a id="SECURITY_IMPERSONATION"></a><a
///                           id="security_impersonation"></a><dl> <dt><b>SECURITY_IMPERSONATION</b></dt> </dl> </td> <td width="60%">
///                           Impersonate a client at the impersonation level. This is the default behavior if no other flags are specified
///                           along with the <b>SECURITY_SQOS_PRESENT</b> flag. </td> </tr> </table>
///    hTemplateFile = A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template file supplies file
///                    attributes and extended attributes for the file that is being created. This parameter can be <b>NULL</b>. When
///                    opening an existing file, <b>CreateFileTransacted</b> ignores the template file. When opening a new EFS-encrypted
///                    file, the file inherits the DACL from its parent directory.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///    pusMiniVersion = The miniversion to be opened. If the transaction specified in <i>hTransaction</i> is not the transaction that is
///                     modifying the file, this parameter should be <b>NULL</b>. Otherwise, this parameter can be a miniversion
///                     identifier returned by the FSCTL_TXFS_CREATE_MINIVERSION control code, or one of the following values. <table>
///                     <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TXFS_MINIVERSION_COMMITTED_VIEW"></a><a
///                     id="txfs_miniversion_committed_view"></a><dl> <dt><b>TXFS_MINIVERSION_COMMITTED_VIEW</b></dt> <dt>0x0000</dt>
///                     </dl> </td> <td width="60%"> The view of the file as of its last commit. </td> </tr> <tr> <td width="40%"><a
///                     id="TXFS_MINIVERSION_DIRTY_VIEW"></a><a id="txfs_miniversion_dirty_view"></a><dl>
///                     <dt><b>TXFS_MINIVERSION_DIRTY_VIEW</b></dt> <dt>0xFFFF</dt> </dl> </td> <td width="60%"> The view of the file as
///                     it is being modified by the transaction. </td> </tr> <tr> <td width="40%"><a
///                     id="TXFS_MINIVERSION_DEFAULT_VIEW"></a><a id="txfs_miniversion_default_view"></a><dl>
///                     <dt><b>TXFS_MINIVERSION_DEFAULT_VIEW</b></dt> <dt>0xFFFE</dt> </dl> </td> <td width="60%"> Either the committed
///                     or dirty view of the file, depending on the context. A transaction that is modifying the file gets the dirty
///                     view, while a transaction that is not modifying the file gets the committed view. </td> </tr> </table>
///    lpExtendedParameter = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail
///    slot. If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information,
///    call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateFileTransactedA(const(char)* lpFileName, uint dwDesiredAccess, uint dwShareMode, 
                             SECURITY_ATTRIBUTES* lpSecurityAttributes, uint dwCreationDisposition, 
                             uint dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, 
                             ushort* pusMiniVersion, void* lpExtendedParameter);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Creates or opens a file,
///file stream, or directory as a transacted operation. The function returns a handle that can be used to access the
///object. To perform this operation as a nontransacted operation or to access objects other than files (for example,
///named pipes, physical devices, mailslots), use the CreateFile function. For more information about transactions, see
///the Remarks section of this topic.
///Params:
///    lpFileName = The name of an object to be created or opened. The object must reside on the local computer; otherwise, the
///                 function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>. In the ANSI
///                 version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide
///                 characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see
///                 Naming a File. For information on special device names, see Defining an MS-DOS Device Name. To create a file
///                 stream, specify the name of the file, a colon, and then the name of the stream. For more information, see File
///                 Streams.
///    dwDesiredAccess = The access to the object, which can be summarized as read, write, both or neither (zero). The most commonly used
///                      values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both (<b>GENERIC_READ</b> | <b>GENERIC_WRITE</b>). For
///                      more information, see Generic Access Rights and File Security and Access Rights. If this parameter is zero, the
///                      application can query file, directory, or device attributes without accessing that file or device. For more
///                      information, see the Remarks section of this topic. You cannot request an access mode that conflicts with the
///                      sharing mode that is specified in an open request that has an open handle. For more information, see Creating and
///                      Opening Files.
///    dwShareMode = The sharing mode of an object, which can be read, write, both, delete, all of these, or none (refer to the
///                  following table). If this parameter is zero and <b>CreateFileTransacted</b> succeeds, the object cannot be shared
///                  and cannot be opened again until the handle is closed. For more information, see the Remarks section of this
///                  topic. You cannot request a sharing mode that conflicts with the access mode that is specified in an open request
///                  that has an open handle, because that would result in the following sharing violation:
///                  <b>ERROR_SHARING_VIOLATION</b>. For more information, see Creating and Opening Files. To enable a process to
///                  share an object while another process has the object open, use a combination of one or more of the following
///                  values to specify the access mode they can request to open the object. <div class="alert"><b>Note</b> The sharing
///                  options for each open handle remain in effect until that handle is closed, regardless of process context.</div>
///                  <div> </div> <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="0"></a><dl>
///                  <dt><b>0</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> Disables subsequent open operations on an
///                  object to request any type of access to that object. </td> </tr> <tr> <td width="40%"><a
///                  id="FILE_SHARE_DELETE"></a><a id="file_share_delete"></a><dl> <dt><b>FILE_SHARE_DELETE</b></dt>
///                  <dt>0x00000004</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on an object to request
///                  delete access. Otherwise, other processes cannot open the object if they request delete access. If this flag is
///                  not specified, but the object has been opened for delete access, the function fails. </td> </tr> <tr> <td
///                  width="40%"><a id="FILE_SHARE_READ"></a><a id="file_share_read"></a><dl> <dt><b>FILE_SHARE_READ</b></dt>
///                  <dt>0x00000001</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on an object to request read
///                  access. Otherwise, other processes cannot open the object if they request read access. If this flag is not
///                  specified, but the object has been opened for read access, the function fails. </td> </tr> <tr> <td
///                  width="40%"><a id="FILE_SHARE_WRITE"></a><a id="file_share_write"></a><dl> <dt><b>FILE_SHARE_WRITE</b></dt>
///                  <dt>0x00000002</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on an object to request write
///                  access. Otherwise, other processes cannot open the object if they request write access. If this flag is not
///                  specified, but the object has been opened for write access or has a file mapping with write access, the function
///                  fails. </td> </tr> </table>
///    lpSecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure that contains an optional security descriptor and also determines
///                           whether or not the returned handle can be inherited by child processes. The parameter can be <b>NULL</b>. If the
///                           <i>lpSecurityAttributes</i> parameter is <b>NULL</b>, the handle returned by <b>CreateFileTransacted</b> cannot
///                           be inherited by any child processes your application may create and the object associated with the returned
///                           handle gets a default security descriptor. The <b>bInheritHandle</b> member of the structure specifies whether
///                           the returned handle can be inherited. The <b>lpSecurityDescriptor</b> member of the structure specifies a
///                           security descriptor for an object, but may also be <b>NULL</b>. If <b>lpSecurityDescriptor</b> member is
///                           <b>NULL</b>, the object associated with the returned handle is assigned a default security descriptor.
///                           <b>CreateFileTransacted</b> ignores the <b>lpSecurityDescriptor</b> member when opening an existing file, but
///                           continues to use the <b>bInheritHandle</b> member. For more information, see the Remarks section of this topic.
///    dwCreationDisposition = An action to take on files that exist and do not exist. For more information, see the Remarks section of this
///                            topic. This parameter must be one of the following values, which cannot be combined. <table> <tr> <th>Value</th>
///                            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CREATE_ALWAYS"></a><a id="create_always"></a><dl>
///                            <dt><b>CREATE_ALWAYS</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Creates a new file, always. If the
///                            specified file exists and is writable, the function overwrites the file, the function succeeds, and last-error
///                            code is set to <b>ERROR_ALREADY_EXISTS</b> (183). If the specified file does not exist and is a valid path, a new
///                            file is created, the function succeeds, and the last-error code is set to zero. For more information, see the
///                            Remarks section of this topic. </td> </tr> <tr> <td width="40%"><a id="CREATE_NEW"></a><a
///                            id="create_new"></a><dl> <dt><b>CREATE_NEW</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Creates a new file,
///                            only if it does not already exist. If the specified file exists, the function fails and the last-error code is
///                            set to <b>ERROR_FILE_EXISTS</b> (80). If the specified file does not exist and is a valid path to a writable
///                            location, a new file is created. </td> </tr> <tr> <td width="40%"><a id="OPEN_ALWAYS"></a><a
///                            id="open_always"></a><dl> <dt><b>OPEN_ALWAYS</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Opens a file,
///                            always. If the specified file exists, the function succeeds and the last-error code is set to
///                            <b>ERROR_ALREADY_EXISTS</b> (183). If the specified file does not exist and is a valid path to a writable
///                            location, the function creates a file and the last-error code is set to zero. </td> </tr> <tr> <td width="40%"><a
///                            id="OPEN_EXISTING"></a><a id="open_existing"></a><dl> <dt><b>OPEN_EXISTING</b></dt> <dt>3</dt> </dl> </td> <td
///                            width="60%"> Opens a file or device, only if it exists. If the specified file does not exist, the function fails
///                            and the last-error code is set to <b>ERROR_FILE_NOT_FOUND</b> (2). For more information, see the Remarks section
///                            of this topic. </td> </tr> <tr> <td width="40%"><a id="TRUNCATE_EXISTING"></a><a id="truncate_existing"></a><dl>
///                            <dt><b>TRUNCATE_EXISTING</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Opens a file and truncates it so that
///                            its size is zero bytes, only if it exists. If the specified file does not exist, the function fails and the
///                            last-error code is set to <b>ERROR_FILE_NOT_FOUND</b> (2). The calling process must open the file with the
///                            <b>GENERIC_WRITE</b> bit set as part of the <i>dwDesiredAccess</i> parameter. </td> </tr> </table>
///    dwFlagsAndAttributes = The file attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default value. This parameter
///                           can include any combination of the available file attributes (<b>FILE_ATTRIBUTE_*</b>). All other file attributes
///                           override <b>FILE_ATTRIBUTE_NORMAL</b>. This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>)
///                           for control of buffering behavior, access modes, and other special-purpose flags. These combine with any
///                           <b>FILE_ATTRIBUTE_*</b> values. This parameter can also contain Security Quality of Service (SQOS) information by
///                           specifying the <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in the
///                           table following the attributes and flags tables. <div class="alert"><b>Note</b> <p class="note">When
///                           <b>CreateFileTransacted</b> opens an existing file, it generally combines the file flags with the file attributes
///                           of the existing file, and ignores any file attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special
///                           cases are detailed in Creating and Opening Files. </div> <div> </div> The following file attributes and flags are
///                           used only for file objects, not other types of objects that <b>CreateFileTransacted</b> opens (additional
///                           information can be found in the Remarks section of this topic). For more advanced access to file attributes, see
///                           SetFileAttributes. For a complete list of all file attributes with their values and descriptions, see File
///                           Attribute Constants. <table> <tr> <th>Attribute</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                           id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl> <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
///                           <dt>32 (0x20)</dt> </dl> </td> <td width="60%"> The file should be archived. Applications use this attribute to
///                           mark files for backup or removal. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_ENCRYPTED"></a><a
///                           id="file_attribute_encrypted"></a><dl> <dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt> <dt>16384 (0x4000)</dt> </dl>
///                           </td> <td width="60%"> The file or directory is encrypted. For a file, this means that all data in the file is
///                           encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories.
///                           For more information, see File Encryption. This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also
///                           specified. </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a
///                           id="file_attribute_hidden"></a><dl> <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt> <dt>2 (0x2)</dt> </dl> </td> <td
///                           width="60%"> The file is hidden. Do not include it in an ordinary directory listing. </td> </tr> <tr> <td
///                           width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt> <dt>128 (0x80)</dt> </dl> </td> <td width="60%"> The file does not have
///                           other attributes set. This attribute is valid only if used alone. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl> <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
///                           <dt>4096 (0x1000)</dt> </dl> </td> <td width="60%"> The data of a file is not immediately available. This
///                           attribute indicates that file data is physically moved to offline storage. This attribute is used by Remote
///                           Storage, the hierarchical storage management software. Applications should not arbitrarily change this attribute.
///                           </td> </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_READONLY</b></dt> <dt>1 (0x1)</dt> </dl> </td> <td width="60%"> The file is read only.
///                           Applications can read the file, but cannot write to or delete it. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl> <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt> <dt>4
///                           (0x4)</dt> </dl> </td> <td width="60%"> The file is part of or used exclusively by an operating system. </td>
///                           </tr> <tr> <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
///                           <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt> <dt>256 (0x100)</dt> </dl> </td> <td width="60%"> The file is being used
///                           for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is
///                           available, because an application deletes a temporary file after a handle is closed. In that case, the system can
///                           entirely avoid writing the data. Otherwise, the data is written after the handle is closed. </td> </tr> </table>
///                           <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a
///                           id="file_flag_backup_semantics"></a><dl> <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt> <dt>0x02000000</dt> </dl>
///                           </td> <td width="60%"> The file is being opened or created for a backup or restore operation. The system ensures
///                           that the calling process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and
///                           <b>SE_RESTORE_NAME</b> privileges. For more information, see Changing Privileges in a Token. You must set this
///                           flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of a file
///                           handle. For more information, see Directory Handles. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_DELETE_ON_CLOSE"></a><a id="file_flag_delete_on_close"></a><dl>
///                           <dt><b>FILE_FLAG_DELETE_ON_CLOSE</b></dt> <dt>0x04000000</dt> </dl> </td> <td width="60%"> The file is to be
///                           deleted immediately after the last transacted writer handle to the file is closed, provided that the transaction
///                           is still active. If a file has been marked for deletion and a transacted writer handle is still open after the
///                           transaction completes, the file will not be deleted. If there are existing open handles to a file, the call fails
///                           unless they were all opened with the <b>FILE_SHARE_DELETE</b> share mode. Subsequent open requests for the file
///                           fail, unless the <b>FILE_SHARE_DELETE</b> share mode is specified. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl> <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
///                           <dt>0x20000000</dt> </dl> </td> <td width="60%"> The file is being opened with no system caching. This flag does
///                           not affect hard disk caching or memory mapped files. When combined with <b>FILE_FLAG_OVERLAPPED</b>, the flag
///                           gives maximum asynchronous performance, because the I/O does not rely on the synchronous operations of the memory
///                           manager. However, some I/O operations take more time, because data is not being held in the cache. Also, the file
///                           metadata may still be cached. To flush the metadata to disk, use the FlushFileBuffers function. An application
///                           must meet certain requirements when working with files that are opened with <b>FILE_FLAG_NO_BUFFERING</b>: <ul>
///                           <li>File access must begin at byte offsets within a file that are integer multiples of the volume sector
///                           size.</li> <li>File access must be for numbers of bytes that are integer multiples of the volume sector size. For
///                           example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, or 2048
///                           bytes, but not of 335, 981, or 7171 bytes.</li> <li>Buffer addresses for read and write operations should be
///                           sector aligned, which means aligned on addresses in memory that are integer multiples of the volume sector size.
///                           Depending on the disk, this requirement may not be enforced.</li> </ul> One way to align buffers on integer
///                           multiples of the volume sector size is to use VirtualAlloc to allocate the buffers. It allocates memory that is
///                           aligned on addresses that are integer multiples of the operating system's memory page size. Because both memory
///                           page and volume sector sizes are powers of 2, this memory is also aligned on addresses that are integer multiples
///                           of a volume sector size. Memory pages are 4 or 8 KB in size; sectors are 512 bytes (hard disks), 2048 bytes (CD),
///                           or 4096 bytes (hard disks), and therefore, volume sectors can never be larger than memory pages. An application
///                           can determine a volume sector size by calling the GetDiskFreeSpace function. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_OPEN_NO_RECALL"></a><a id="file_flag_open_no_recall"></a><dl>
///                           <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The file data is
///                           requested, but it should continue to be located in remote storage. It should not be transported back to local
///                           storage. This flag is for use by remote storage systems. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
///                           <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> Normal reparse
///                           point processing will not occur; <b>CreateFileTransacted</b> will attempt to open the reparse point. When a file
///                           is opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.
///                           This flag cannot be used with the <b>CREATE_ALWAYS</b> flag. If the file is not a reparse point, then this flag
///                           is ignored. </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a
///                           id="file_flag_overlapped"></a><dl> <dt><b>FILE_FLAG_OVERLAPPED</b></dt> <dt>0x40000000</dt> </dl> </td> <td
///                           width="60%"> The file is being opened or created for asynchronous I/O. When the operation is complete, the event
///                           specified in the OVERLAPPED structure is set to the signaled state. Operations that take a significant amount of
///                           time to process return <b>ERROR_IO_PENDING</b>. If this flag is specified, the file can be used for simultaneous
///                           read and write operations. The system does not maintain the file pointer, therefore you must pass the file
///                           position to the read and write functions in the OVERLAPPED structure or update the file pointer. If this flag is
///                           not specified, then I/O operations are serialized, even if the calls to the read and write functions specify an
///                           OVERLAPPED structure. </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_POSIX_SEMANTICS"></a><a
///                           id="file_flag_posix_semantics"></a><dl> <dt><b>FILE_FLAG_POSIX_SEMANTICS</b></dt> <dt>0x01000000</dt> </dl> </td>
///                           <td width="60%"> The file is to be accessed according to POSIX rules. This includes allowing multiple files with
///                           names, differing only in case, for file systems that support that naming. Use care when using this option,
///                           because files created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit
///                           Windows. </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_RANDOM_ACCESS"></a><a
///                           id="file_flag_random_access"></a><dl> <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt> <dt>0x10000000</dt> </dl> </td> <td
///                           width="60%"> The file is to be accessed randomly. The system can use this as a hint to optimize file caching.
///                           </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_SESSION_AWARE"></a><a id="file_flag_session_aware"></a><dl>
///                           <dt><b>FILE_FLAG_SESSION_AWARE</b></dt> <dt>0x00800000</dt> </dl> </td> <td width="60%"> The file or device is
///                           being opened with session awareness. If this flag is not specified, then per-session devices (such as a device
///                           using RemoteFX USB Redirection) cannot be opened by processes running in session 0. This flag has no effect for
///                           callers not in session 0. This flag is supported only on server editions of Windows. <b>Windows Server 2008 R2
///                           and Windows Server 2008: </b>This flag is not supported before Windows Server 2012. </td> </tr> <tr> <td
///                           width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
///                           <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt> <dt>0x08000000</dt> </dl> </td> <td width="60%"> The file is to be
///                           accessed sequentially from beginning to end. The system can use this as a hint to optimize file caching. If an
///                           application moves the file pointer for random access, optimum caching may not occur. However, correct operation
///                           is still guaranteed. Specifying this flag can increase performance for applications that read large files using
///                           sequential access. Performance gains can be even more noticeable for applications that read large files mostly
///                           sequentially, but occasionally skip over small ranges of bytes. This flag has no effect if the file system does
///                           not support cached I/O and <b>FILE_FLAG_NO_BUFFERING</b>. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl> <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt>
///                           <dt>0x80000000</dt> </dl> </td> <td width="60%"> Write operations will not go through any intermediate cache,
///                           they will go directly to disk. If <b>FILE_FLAG_NO_BUFFERING</b> is not also specified, so that system caching is
///                           in effect, then the data is written to the system cache, but is flushed to disk without delay. If
///                           <b>FILE_FLAG_NO_BUFFERING</b> is also specified, so that system caching is not in effect, then the data is
///                           immediately flushed to disk without going through the system cache. The operating system also requests a
///                           write-through the hard disk cache to persistent media. However, not all hardware supports this write-through
///                           capability. </td> </tr> </table> The <i>dwFlagsAndAttributes</i> parameter can also specify Security Quality of
///                           Service information. For more information, see Impersonation Levels. When the calling application specifies the
///                           <b>SECURITY_SQOS_PRESENT</b> flag as part of <i>dwFlagsAndAttributes</i>, it can also contain one or more of the
///                           following values. <table> <tr> <th>Security flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                           id="SECURITY_ANONYMOUS"></a><a id="security_anonymous"></a><dl> <dt><b>SECURITY_ANONYMOUS</b></dt> </dl> </td>
///                           <td width="60%"> Impersonates a client at the Anonymous impersonation level. </td> </tr> <tr> <td width="40%"><a
///                           id="SECURITY_CONTEXT_TRACKING"></a><a id="security_context_tracking"></a><dl>
///                           <dt><b>SECURITY_CONTEXT_TRACKING</b></dt> </dl> </td> <td width="60%"> The security tracking mode is dynamic. If
///                           this flag is not specified, the security tracking mode is static. </td> </tr> <tr> <td width="40%"><a
///                           id="SECURITY_DELEGATION"></a><a id="security_delegation"></a><dl> <dt><b>SECURITY_DELEGATION</b></dt> </dl> </td>
///                           <td width="60%"> Impersonates a client at the Delegation impersonation level. </td> </tr> <tr> <td width="40%"><a
///                           id="SECURITY_EFFECTIVE_ONLY"></a><a id="security_effective_only"></a><dl> <dt><b>SECURITY_EFFECTIVE_ONLY</b></dt>
///                           </dl> </td> <td width="60%"> Only the enabled aspects of the client's security context are available to the
///                           server. If you do not specify this flag, all aspects of the client's security context are available. This allows
///                           the client to limit the groups and privileges that a server can use while impersonating the client. </td> </tr>
///                           <tr> <td width="40%"><a id="SECURITY_IDENTIFICATION"></a><a id="security_identification"></a><dl>
///                           <dt><b>SECURITY_IDENTIFICATION</b></dt> </dl> </td> <td width="60%"> Impersonates a client at the Identification
///                           impersonation level. </td> </tr> <tr> <td width="40%"><a id="SECURITY_IMPERSONATION"></a><a
///                           id="security_impersonation"></a><dl> <dt><b>SECURITY_IMPERSONATION</b></dt> </dl> </td> <td width="60%">
///                           Impersonate a client at the impersonation level. This is the default behavior if no other flags are specified
///                           along with the <b>SECURITY_SQOS_PRESENT</b> flag. </td> </tr> </table>
///    hTemplateFile = A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template file supplies file
///                    attributes and extended attributes for the file that is being created. This parameter can be <b>NULL</b>. When
///                    opening an existing file, <b>CreateFileTransacted</b> ignores the template file. When opening a new EFS-encrypted
///                    file, the file inherits the DACL from its parent directory.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///    pusMiniVersion = The miniversion to be opened. If the transaction specified in <i>hTransaction</i> is not the transaction that is
///                     modifying the file, this parameter should be <b>NULL</b>. Otherwise, this parameter can be a miniversion
///                     identifier returned by the FSCTL_TXFS_CREATE_MINIVERSION control code, or one of the following values. <table>
///                     <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TXFS_MINIVERSION_COMMITTED_VIEW"></a><a
///                     id="txfs_miniversion_committed_view"></a><dl> <dt><b>TXFS_MINIVERSION_COMMITTED_VIEW</b></dt> <dt>0x0000</dt>
///                     </dl> </td> <td width="60%"> The view of the file as of its last commit. </td> </tr> <tr> <td width="40%"><a
///                     id="TXFS_MINIVERSION_DIRTY_VIEW"></a><a id="txfs_miniversion_dirty_view"></a><dl>
///                     <dt><b>TXFS_MINIVERSION_DIRTY_VIEW</b></dt> <dt>0xFFFF</dt> </dl> </td> <td width="60%"> The view of the file as
///                     it is being modified by the transaction. </td> </tr> <tr> <td width="40%"><a
///                     id="TXFS_MINIVERSION_DEFAULT_VIEW"></a><a id="txfs_miniversion_default_view"></a><dl>
///                     <dt><b>TXFS_MINIVERSION_DEFAULT_VIEW</b></dt> <dt>0xFFFE</dt> </dl> </td> <td width="60%"> Either the committed
///                     or dirty view of the file, depending on the context. A transaction that is modifying the file gets the dirty
///                     view, while a transaction that is not modifying the file gets the committed view. </td> </tr> </table>
///    lpExtendedParameter = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail
///    slot. If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information,
///    call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateFileTransactedW(const(wchar)* lpFileName, uint dwDesiredAccess, uint dwShareMode, 
                             SECURITY_ATTRIBUTES* lpSecurityAttributes, uint dwCreationDisposition, 
                             uint dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, 
                             ushort* pusMiniVersion, void* lpExtendedParameter);

///Reopens the specified file system object with different access rights, sharing mode, and flags.
///Params:
///    hOriginalFile = A handle to the object to be reopened. The object must have been created by the CreateFile function.
///    dwDesiredAccess = The required access to the object. For a list of values, see File Security and Access Rights. You cannot request
///                      an access mode that conflicts with the sharing mode specified in a previous open request whose handle is still
///                      open. If this parameter is zero (0), the application can query device attributes without accessing the device.
///                      This is useful if an application wants to determine the size of a floppy disk drive and the formats it supports
///                      without requiring a floppy in the drive.
///    dwShareMode = The sharing mode of the object. You cannot request a sharing mode that conflicts with the access mode specified
///                  in a previous open request whose handle is still open. If this parameter is zero (0) and CreateFile succeeds, the
///                  object cannot be shared and cannot be opened again until the handle is closed. To enable other processes to share
///                  the object while your process has it open, use a combination of one or more of the following values to specify
///                  the type of access they can request when they open the object. These sharing options remain in effect until you
///                  close the handle to the object. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="FILE_SHARE_DELETE"></a><a id="file_share_delete"></a><dl> <dt><b>FILE_SHARE_DELETE</b></dt>
///                  <dt>0x00000004</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on the object to request
///                  delete access. Otherwise, other processes cannot open the object if they request delete access. If the object has
///                  already been opened with delete access, the sharing mode must include this flag. </td> </tr> <tr> <td
///                  width="40%"><a id="FILE_SHARE_READ"></a><a id="file_share_read"></a><dl> <dt><b>FILE_SHARE_READ</b></dt>
///                  <dt>0x00000001</dt> </dl> </td> <td width="60%"> Enables subsequent open operations on the object to request read
///                  access. Otherwise, other processes cannot open the object if they request read access. If the object has already
///                  been opened with read access, the sharing mode must include this flag. </td> </tr> <tr> <td width="40%"><a
///                  id="FILE_SHARE_WRITE"></a><a id="file_share_write"></a><dl> <dt><b>FILE_SHARE_WRITE</b></dt> <dt>0x00000002</dt>
///                  </dl> </td> <td width="60%"> Enables subsequent open operations on the object to request write access. Otherwise,
///                  other processes cannot open the object if they request write access. If the object has already been opened with
///                  write access, the sharing mode must include this flag. </td> </tr> </table>
///    dwFlagsAndAttributes = The file flags. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///                           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a
///                           id="file_flag_backup_semantics"></a><dl> <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt> <dt>0x02000000</dt> </dl>
///                           </td> <td width="60%"> Indicates that the file is being opened or created for a backup or restore operation. The
///                           system ensures that the calling process overrides file security checks, provided it has the <b>SE_BACKUP_NAME</b>
///                           and <b>SE_RESTORE_NAME</b> privileges. For more information, see Changing Privileges in a Token. You can also set
///                           this flag to obtain a handle to a directory. Where indicated, a directory handle can be passed to some functions
///                           in place of a file handle. </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_DELETE_ON_CLOSE"></a><a
///                           id="file_flag_delete_on_close"></a><dl> <dt><b>FILE_FLAG_DELETE_ON_CLOSE</b></dt> <dt>0x04000000</dt> </dl> </td>
///                           <td width="60%"> Indicates that the operating system is to delete the file immediately after all of its handles
///                           have been closed, not just the specified handle but also any other open or duplicated handles. Subsequent open
///                           requests for the file fail, unless <b>FILE_SHARE_DELETE</b> is used. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl> <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
///                           <dt>0x20000000</dt> </dl> </td> <td width="60%"> Instructs the system to open the file with no intermediate
///                           buffering or caching. When combined with <b>FILE_FLAG_OVERLAPPED</b>, the flag gives maximum asynchronous
///                           performance, because the I/O does not rely on the synchronous operations of the memory manager. However, some I/O
///                           operations take longer, because data is not being held in the cache. An application must meet specific
///                           requirements when working with files opened with <b>FILE_FLAG_NO_BUFFERING</b>: <ul> <li>File access must begin
///                           at byte offsets within the file that are integer multiples of the volume sector size.</li> <li>File access must
///                           be for numbers of bytes that are integer multiples of the volume sector size. For example, if the sector size is
///                           512 bytes, an application can request reads and writes of 512, 1024, 1536, or 2048 bytes, but not of 335, 981, or
///                           7171 bytes.</li> <li>Buffer addresses for read and write operations should be sector aligned (aligned on
///                           addresses in memory that are integer multiples of the volume sector size). Depending on the disk, this
///                           requirement may not be enforced.</li> </ul> One way to align buffers on integer multiples of the volume sector
///                           size is to use VirtualAlloc to allocate the buffers. It allocates memory that is aligned on addresses that are
///                           integer multiples of the operating system memory page size. Because both memory page and volume sector sizes are
///                           powers of 2, this memory is also aligned on addresses that are integer multiples of a volume sector size. Memory
///                           pages are 4-8 KB in size; sectors are 512 bytes (hard disks) or 2048 bytes (CD), and therefore, volume sectors
///                           can never be larger than memory pages. An application can determine a volume sector size by calling the
///                           GetDiskFreeSpace function. </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_OPEN_NO_RECALL"></a><a
///                           id="file_flag_open_no_recall"></a><dl> <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt> <dt>0x00100000</dt> </dl> </td>
///                           <td width="60%"> Indicates that the file data is requested, but it should continue to reside in remote storage.
///                           It should not be transported back to local storage. This flag is intended for use by remote storage systems.
///                           </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a
///                           id="file_flag_open_reparse_point"></a><dl> <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt> <dt>0x00200000</dt> </dl>
///                           </td> <td width="60%"> When this flag is used, normal reparse point processing does not occur, and
///                           <b>ReOpenFile</b> attempts to open the reparse point. When a file is opened, a file handle is returned, whether
///                           or not the filter that controls the reparse point is operational. This flag cannot be used with the
///                           <b>CREATE_ALWAYS</b> flag. If the file is not a reparse point, then this flag is ignored. </td> </tr> <tr> <td
///                           width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl>
///                           <dt><b>FILE_FLAG_OVERLAPPED</b></dt> <dt>0x40000000</dt> </dl> </td> <td width="60%"> Instructs the system to
///                           initialize the object, so that operations that take a significant amount of time to process return
///                           <b>ERROR_IO_PENDING</b>. When the operation is finished, the specified event is set to the signaled state. When
///                           you specify <b>FILE_FLAG_OVERLAPPED</b>, the file read and write functions <b>must</b> specify an OVERLAPPED
///                           structure. That is, when <b>FILE_FLAG_OVERLAPPED</b> is specified, an application <b>must</b> perform overlapped
///                           reading and writing. When <b>FILE_FLAG_OVERLAPPED</b> is specified, the system does not maintain the file
///                           pointer. The file position must be passed as part of the <i>lpOverlapped</i> parameter (pointing to an OVERLAPPED
///                           structure) to the file read and write functions. This flag also enables more than one operation to be performed
///                           simultaneously with the handle (a simultaneous read and write operation, for example). </td> </tr> <tr> <td
///                           width="40%"><a id="FILE_FLAG_POSIX_SEMANTICS"></a><a id="file_flag_posix_semantics"></a><dl>
///                           <dt><b>FILE_FLAG_POSIX_SEMANTICS</b></dt> <dt>0x01000000</dt> </dl> </td> <td width="60%"> Indicates that the
///                           file is to be accessed according to POSIX rules. This includes allowing multiple files with names, differing only
///                           in case, for file systems that support such naming. Use care when using this option because files created with
///                           this flag may not be accessible by applications written for MS-DOS or 16-bit Windows. </td> </tr> <tr> <td
///                           width="40%"><a id="FILE_FLAG_RANDOM_ACCESS"></a><a id="file_flag_random_access"></a><dl>
///                           <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt> <dt>0x10000000</dt> </dl> </td> <td width="60%"> Indicates that the file
///                           is accessed randomly. The system can use this as a hint to optimize file caching. </td> </tr> <tr> <td
///                           width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
///                           <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt> <dt>0x08000000</dt> </dl> </td> <td width="60%"> Indicates that the
///                           file is to be accessed sequentially from beginning to end. The system can use this as a hint to optimize file
///                           caching. If an application moves the file pointer for random access, optimum caching may not occur; however,
///                           correct operation is still guaranteed. Specifying this flag can increase performance for applications that read
///                           large files using sequential access. Performance gains can be even more noticeable for applications that read
///                           large files mostly sequentially, but occasionally skip over small ranges of bytes. </td> </tr> <tr> <td
///                           width="40%"><a id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl>
///                           <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt> <dt>0x80000000</dt> </dl> </td> <td width="60%"> Instructs the system to
///                           write through any intermediate cache and go directly to disk. The system can still cache write operations, but
///                           cannot lazily flush them. </td> </tr> </table> If the handle represents the client side of a named pipe, the
///                           <i>dwFlags</i> parameter can also contain Security Quality of Service information. For more information, see
///                           Impersonation Levels. When the calling application specifies the <b>SECURITY_SQOS_PRESENT</b> flag, the
///                           <i>dwFlags</i> parameter can contain one or more of the following values. <table> <tr> <th>Value</th>
///                           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SECURITY_ANONYMOUS"></a><a id="security_anonymous"></a><dl>
///                           <dt><b>SECURITY_ANONYMOUS</b></dt> </dl> </td> <td width="60%"> Impersonate the client at the Anonymous
///                           impersonation level. </td> </tr> <tr> <td width="40%"><a id="SECURITY_CONTEXT_TRACKING"></a><a
///                           id="security_context_tracking"></a><dl> <dt><b>SECURITY_CONTEXT_TRACKING</b></dt> </dl> </td> <td width="60%">
///                           The security tracking mode is dynamic. If this flag is not specified, the security tracking mode is static. </td>
///                           </tr> <tr> <td width="40%"><a id="SECURITY_DELEGATION"></a><a id="security_delegation"></a><dl>
///                           <dt><b>SECURITY_DELEGATION</b></dt> </dl> </td> <td width="60%"> Impersonate the client at the Delegation
///                           impersonation level. </td> </tr> <tr> <td width="40%"><a id="SECURITY_EFFECTIVE_ONLY"></a><a
///                           id="security_effective_only"></a><dl> <dt><b>SECURITY_EFFECTIVE_ONLY</b></dt> </dl> </td> <td width="60%"> Only
///                           the enabled aspects of the client security context are available to the server. If you do not specify this flag,
///                           all aspects of the client security context are available. This allows the client to limit the groups and
///                           privileges that a server can use while impersonating the client. </td> </tr> <tr> <td width="40%"><a
///                           id="SECURITY_IDENTIFICATION"></a><a id="security_identification"></a><dl> <dt><b>SECURITY_IDENTIFICATION</b></dt>
///                           </dl> </td> <td width="60%"> Impersonate the client at the Identification impersonation level. </td> </tr> <tr>
///                           <td width="40%"><a id="SECURITY_IMPERSONATION"></a><a id="security_impersonation"></a><dl>
///                           <dt><b>SECURITY_IMPERSONATION</b></dt> </dl> </td> <td width="60%"> Impersonate the client at the Impersonation
///                           impersonation level. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is an open handle to the specified file. If the function fails, the
///    return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE ReOpenFile(HANDLE hOriginalFile, uint dwDesiredAccess, uint dwShareMode, uint dwFlagsAndAttributes);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Sets the attributes for a
///file or directory as a transacted operation.
///Params:
///    lpFileName = The name of the file whose attributes are to be set. In the ANSI version of this function, the name is limited to
///                 <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                 function and prepend "\\?\" to the path. For more information, see File Names, Paths, and Namespaces. The file
///                 must reside on the local computer; otherwise, the function fails and the last error code is set to
///                 <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    dwFileAttributes = The file attributes to set for the file. For a list of file attribute value and their descriptions, see File
///                       Attribute Constants. This parameter can be one or more values, combined using the bitwise-OR operator. However,
///                       all other values override <b>FILE_ATTRIBUTE_NORMAL</b>. Not all attributes are supported by this function. For
///                       more information, see the Remarks section. The following is a list of supported attribute values.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetFileAttributesTransactedA(const(char)* lpFileName, uint dwFileAttributes, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Sets the attributes for a
///file or directory as a transacted operation.
///Params:
///    lpFileName = The name of the file whose attributes are to be set. In the ANSI version of this function, the name is limited to
///                 <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                 function and prepend "\\?\" to the path. For more information, see File Names, Paths, and Namespaces. The file
///                 must reside on the local computer; otherwise, the function fails and the last error code is set to
///                 <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    dwFileAttributes = The file attributes to set for the file. For a list of file attribute value and their descriptions, see File
///                       Attribute Constants. This parameter can be one or more values, combined using the bitwise-OR operator. However,
///                       all other values override <b>FILE_ATTRIBUTE_NORMAL</b>. Not all attributes are supported by this function. For
///                       more information, see the Remarks section. The following is a list of supported attribute values.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetFileAttributesTransactedW(const(wchar)* lpFileName, uint dwFileAttributes, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Retrieves file system
///attributes for a specified file or directory as a transacted operation.
///Params:
///    lpFileName = The name of the file or directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\?\" to the path. For more information, see Naming a File. The file or directory must reside on the local
///                 computer; otherwise, the function fails and the last error code is set to
///                 <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    fInfoLevelId = The level of attribute information to retrieve. This parameter can be the following value from the
///                   GET_FILEEX_INFO_LEVELS enumeration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                   id="GetFileExInfoStandard"></a><a id="getfileexinfostandard"></a><a id="GETFILEEXINFOSTANDARD"></a><dl>
///                   <dt><b>GetFileExInfoStandard</b></dt> </dl> </td> <td width="60%"> The <i>lpFileInformation</i> parameter is a
///                   WIN32_FILE_ATTRIBUTE_DATA structure. </td> </tr> </table>
///    lpFileInformation = A pointer to a buffer that receives the attribute information. The type of attribute information that is stored
///                        into this buffer is determined by the value of <i>fInfoLevelId</i>. If the <i>fInfoLevelId</i> parameter is
///                        <b>GetFileExInfoStandard</b> then this parameter points to a WIN32_FILE_ATTRIBUTE_DATA structure
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetFileAttributesTransactedA(const(char)* lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, 
                                  char* lpFileInformation, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Retrieves file system
///attributes for a specified file or directory as a transacted operation.
///Params:
///    lpFileName = The name of the file or directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\?\" to the path. For more information, see Naming a File. The file or directory must reside on the local
///                 computer; otherwise, the function fails and the last error code is set to
///                 <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    fInfoLevelId = The level of attribute information to retrieve. This parameter can be the following value from the
///                   GET_FILEEX_INFO_LEVELS enumeration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                   id="GetFileExInfoStandard"></a><a id="getfileexinfostandard"></a><a id="GETFILEEXINFOSTANDARD"></a><dl>
///                   <dt><b>GetFileExInfoStandard</b></dt> </dl> </td> <td width="60%"> The <i>lpFileInformation</i> parameter is a
///                   WIN32_FILE_ATTRIBUTE_DATA structure. </td> </tr> </table>
///    lpFileInformation = A pointer to a buffer that receives the attribute information. The type of attribute information that is stored
///                        into this buffer is determined by the value of <i>fInfoLevelId</i>. If the <i>fInfoLevelId</i> parameter is
///                        <b>GetFileExInfoStandard</b> then this parameter points to a WIN32_FILE_ATTRIBUTE_DATA structure
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetFileAttributesTransactedW(const(wchar)* lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, 
                                  char* lpFileInformation, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Retrieves the actual
///number of bytes of disk storage used to store a specified file as a transacted operation. If the file is located on a
///volume that supports compression and the file is compressed, the value obtained is the compressed size of the
///specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the
///value obtained is the sparse size of the specified file.
///Params:
///    lpFileName = The name of the file. Do not specify the name of a file on a nonseeking device, such as a pipe or a
///                 communications device, as its file size has no meaning. The file must reside on the local computer; otherwise,
///                 the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    lpFileSizeHigh = A pointer to a variable that receives the high-order <b>DWORD</b> of the compressed file size. The function's
///                     return value is the low-order <b>DWORD</b> of the compressed file size. This parameter can be <b>NULL</b> if the
///                     high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not
///                     need the high-order <b>DWORD</b>.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk
///    storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the
///    high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the
///    compressed file size for compressed files, the actual file size for noncompressed files. If the function fails,
///    and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error
///    information, call GetLastError. If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is
///    non-<b>NULL</b>, an application must call GetLastError to determine whether the function has succeeded (value is
///    <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).
///    
@DllImport("KERNEL32")
uint GetCompressedFileSizeTransactedA(const(char)* lpFileName, uint* lpFileSizeHigh, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Retrieves the actual
///number of bytes of disk storage used to store a specified file as a transacted operation. If the file is located on a
///volume that supports compression and the file is compressed, the value obtained is the compressed size of the
///specified file. If the file is located on a volume that supports sparse files and the file is a sparse file, the
///value obtained is the sparse size of the specified file.
///Params:
///    lpFileName = The name of the file. Do not specify the name of a file on a nonseeking device, such as a pipe or a
///                 communications device, as its file size has no meaning. The file must reside on the local computer; otherwise,
///                 the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    lpFileSizeHigh = A pointer to a variable that receives the high-order <b>DWORD</b> of the compressed file size. The function's
///                     return value is the low-order <b>DWORD</b> of the compressed file size. This parameter can be <b>NULL</b> if the
///                     high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not
///                     need the high-order <b>DWORD</b>.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk
///    storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the
///    high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the
///    compressed file size for compressed files, the actual file size for noncompressed files. If the function fails,
///    and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error
///    information, call GetLastError. If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is
///    non-<b>NULL</b>, an application must call GetLastError to determine whether the function has succeeded (value is
///    <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).
///    
@DllImport("KERNEL32")
uint GetCompressedFileSizeTransactedW(const(wchar)* lpFileName, uint* lpFileSizeHigh, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Deletes an existing file
///as a transacted operation.
///Params:
///    lpFileName = The name of the file to be deleted. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\?\" to the path. For more information, see Naming a File. The file must reside on the local computer;
///                 otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DeleteFileTransactedA(const(char)* lpFileName, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Deletes an existing file
///as a transacted operation.
///Params:
///    lpFileName = The name of the file to be deleted. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\?\" to the path. For more information, see Naming a File. The file must reside on the local computer;
///                 otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DeleteFileTransactedW(const(wchar)* lpFileName, HANDLE hTransaction);

///Determines whether the specified name can be used to create a file on a FAT file system.
///Params:
///    lpName = The file name, in 8.3 format.
///    lpOemName = A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This parameter can be
///                <b>NULL</b>.
///    OemNameSize = The size of the <i>lpOemName</i> buffer, in characters. If <i>lpOemName</i> is <b>NULL</b>, this parameter must
///                  be 0 (zero).
///    pbNameContainsSpaces = Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If the name is not a valid
///                           8.3 FAT file system name, this parameter is undefined.
///    pbNameLegal = If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when the
///                  current OEM code page is applied to the file name.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL CheckNameLegalDOS8Dot3A(const(char)* lpName, const(char)* lpOemName, uint OemNameSize, 
                             int* pbNameContainsSpaces, int* pbNameLegal);

///Determines whether the specified name can be used to create a file on a FAT file system.
///Params:
///    lpName = The file name, in 8.3 format.
///    lpOemName = A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This parameter can be
///                <b>NULL</b>.
///    OemNameSize = The size of the <i>lpOemName</i> buffer, in characters. If <i>lpOemName</i> is <b>NULL</b>, this parameter must
///                  be 0 (zero).
///    pbNameContainsSpaces = Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If the name is not a valid
///                           8.3 FAT file system name, this parameter is undefined.
///    pbNameLegal = If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when the
///                  current OEM code page is applied to the file name.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL CheckNameLegalDOS8Dot3W(const(wchar)* lpName, const(char)* lpOemName, uint OemNameSize, 
                             int* pbNameContainsSpaces, int* pbNameLegal);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Searches a directory for
///a file or subdirectory with a name that matches a specific name as a transacted operation. This function is the
///transacted form of the FindFirstFileEx function. For the most basic version of this function, see FindFirstFile.
///Params:
///    lpFileName = The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk
///                 (*) or a question mark (?). This parameter should not be <b>NULL</b>, an invalid string (for example, an empty
///                 string or a string that is missing the terminating null character), or end in a trailing backslash (\\). If the
///                 string ends with a wildcard, period (.), or directory name, the user must have access to the root and all
///                 subdirectories on the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\?\" to the path. For more information, see Naming a File. The file must reside on the local computer;
///                 otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    fInfoLevelId = The information level of the returned data. This parameter is one of the FINDEX_INFO_LEVELS enumeration values.
///    lpFindFileData = A pointer to the WIN32_FIND_DATA structure that receives information about a found file or subdirectory.
///    fSearchOp = The type of filtering to perform that is different from wildcard matching. This parameter is one of the
///                FINDEX_SEARCH_OPS enumeration values.
///    lpSearchFilter = A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured search information. At this
///                     time, none of the supported <i>fSearchOp</i> values require extended search information. Therefore, this pointer
///                     must be <b>NULL</b>.
///    dwAdditionalFlags = Specifies additional flags that control the search. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                        width="40%"><a id="FIND_FIRST_EX_CASE_SENSITIVE"></a><a id="find_first_ex_case_sensitive"></a><dl>
///                        <dt><b>FIND_FIRST_EX_CASE_SENSITIVE</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Searches are case-sensitive.
///                        </td> </tr> </table>
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or
///    FindClose, and the <i>lpFindFileData</i> parameter contains information about the first file or directory found.
///    If the function fails or fails to locate files from the search string in the <i>lpFileName</i> parameter, the
///    return value is <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get
///    extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
FindFileHandle FindFirstFileTransactedA(const(char)* lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, 
                                        char* lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, void* lpSearchFilter, 
                                        uint dwAdditionalFlags, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Searches a directory for
///a file or subdirectory with a name that matches a specific name as a transacted operation. This function is the
///transacted form of the FindFirstFileEx function. For the most basic version of this function, see FindFirstFile.
///Params:
///    lpFileName = The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk
///                 (*) or a question mark (?). This parameter should not be <b>NULL</b>, an invalid string (for example, an empty
///                 string or a string that is missing the terminating null character), or end in a trailing backslash (\\). If the
///                 string ends with a wildcard, period (.), or directory name, the user must have access to the root and all
///                 subdirectories on the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                 characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                 "\\?\" to the path. For more information, see Naming a File. The file must reside on the local computer;
///                 otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    fInfoLevelId = The information level of the returned data. This parameter is one of the FINDEX_INFO_LEVELS enumeration values.
///    lpFindFileData = A pointer to the WIN32_FIND_DATA structure that receives information about a found file or subdirectory.
///    fSearchOp = The type of filtering to perform that is different from wildcard matching. This parameter is one of the
///                FINDEX_SEARCH_OPS enumeration values.
///    lpSearchFilter = A pointer to the search criteria if the specified <i>fSearchOp</i> needs structured search information. At this
///                     time, none of the supported <i>fSearchOp</i> values require extended search information. Therefore, this pointer
///                     must be <b>NULL</b>.
///    dwAdditionalFlags = Specifies additional flags that control the search. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                        width="40%"><a id="FIND_FIRST_EX_CASE_SENSITIVE"></a><a id="find_first_ex_case_sensitive"></a><dl>
///                        <dt><b>FIND_FIRST_EX_CASE_SENSITIVE</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Searches are case-sensitive.
///                        </td> </tr> </table>
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or
///    FindClose, and the <i>lpFindFileData</i> parameter contains information about the first file or directory found.
///    If the function fails or fails to locate files from the search string in the <i>lpFileName</i> parameter, the
///    return value is <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get
///    extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
FindFileHandle FindFirstFileTransactedW(const(wchar)* lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, 
                                        char* lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, void* lpSearchFilter, 
                                        uint dwAdditionalFlags, HANDLE hTransaction);

///Copies an existing file to a new file. The CopyFileEx function provides two additional capabilities.
///<b>CopyFileEx</b> can call a specified callback function each time a portion of the copy operation is completed, and
///<b>CopyFileEx</b> can be canceled during the copy operation. To perform this operation as a transacted operation, use
///the CopyFileTransacted function.
///Params:
///    lpExistingFileName = The name of an existing file. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                         characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                         "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting with Windows
///                         10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the
///                         <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming
///                         Files, Paths, and Namespaces for details.</div> <div> </div> If <i>lpExistingFileName</i> does not exist,
///                         <b>CopyFile</b> fails, and GetLastError returns <b>ERROR_FILE_NOT_FOUND</b>.
///    lpNewFileName = The name of the new file. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                    characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                    "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting with Windows
///                    10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the
///                    <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming
///                    Files, Paths, and Namespaces for details.</div> <div> </div>
///    bFailIfExists = If this parameter is <b>TRUE</b> and the new file specified by <i>lpNewFileName</i> already exists, the function
///                    fails. If this parameter is <b>FALSE</b> and the new file already exists, the function overwrites the existing
///                    file and succeeds.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL CopyFileA(const(char)* lpExistingFileName, const(char)* lpNewFileName, BOOL bFailIfExists);

///Copies an existing file to a new file. The CopyFileEx function provides two additional capabilities.
///<b>CopyFileEx</b> can call a specified callback function each time a portion of the copy operation is completed, and
///<b>CopyFileEx</b> can be canceled during the copy operation. To perform this operation as a transacted operation, use
///the CopyFileTransacted function.
///Params:
///    lpExistingFileName = The name of an existing file. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                         characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                         "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting with Windows
///                         10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the
///                         <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming
///                         Files, Paths, and Namespaces for details.</div> <div> </div> If <i>lpExistingFileName</i> does not exist,
///                         <b>CopyFile</b> fails, and GetLastError returns <b>ERROR_FILE_NOT_FOUND</b>.
///    lpNewFileName = The name of the new file. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                    characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                    "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting with Windows
///                    10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the
///                    <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming
///                    Files, Paths, and Namespaces for details.</div> <div> </div>
///    bFailIfExists = If this parameter is <b>TRUE</b> and the new file specified by <i>lpNewFileName</i> already exists, the function
///                    fails. If this parameter is <b>FALSE</b> and the new file already exists, the function overwrites the existing
///                    file and succeeds.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL CopyFileW(const(wchar)* lpExistingFileName, const(wchar)* lpNewFileName, BOOL bFailIfExists);

///Copies an existing file to a new file, notifying the application of its progress through a callback function. To
///perform this operation as a transacted operation, use the CopyFileTransacted function.
///Params:
///    lpExistingFileName = The name of an existing file. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                         characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                         "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting in Windows
///                         10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the
///                         <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of
///                         Naming Files, Paths, and Namespaces for details. </div> <div> </div> If <i>lpExistingFileName</i> does not exist,
///                         the <b>CopyFileEx</b> function fails, and the GetLastError function returns <b>ERROR_FILE_NOT_FOUND</b>.
///    lpNewFileName = The name of the new file. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                    characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                    "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting inWindows 10,
///                    version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the
///                    <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of
///                    Naming Files, Paths, and Namespaces for details. </div> <div> </div>
///    lpProgressRoutine = The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called each time another portion of
///                        the file has been copied. This parameter can be <b>NULL</b>. For more information on the progress callback
///                        function, see the CopyProgressRoutine function.
///    lpData = The argument to be passed to the callback function. This parameter can be <b>NULL</b>.
///    pbCancel = If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. Otherwise, the copy
///               operation will continue to completion.
///    dwCopyFlags = Flags that specify how the file is to be copied. This parameter can be a combination of the following values.
///                  <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="COPY_FILE_ALLOW_DECRYPTED_DESTINATION"></a><a id="copy_file_allow_decrypted_destination"></a><dl>
///                  <dt><b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> An attempt
///                  to copy an encrypted file will succeed even if the destination copy cannot be encrypted. </td> </tr> <tr> <td
///                  width="40%"><a id="COPY_FILE_COPY_SYMLINK"></a><a id="copy_file_copy_symlink"></a><dl>
///                  <dt><b>COPY_FILE_COPY_SYMLINK</b></dt> <dt>0x00000800</dt> </dl> </td> <td width="60%"> If the source file is a
///                  symbolic link, the destination file is also a symbolic link pointing to the same file that the source symbolic
///                  link is pointing to. <b>Windows Server 2003 and Windows XP: </b>This value is not supported. </td> </tr> <tr> <td
///                  width="40%"><a id="COPY_FILE_FAIL_IF_EXISTS"></a><a id="copy_file_fail_if_exists"></a><dl>
///                  <dt><b>COPY_FILE_FAIL_IF_EXISTS</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The copy operation
///                  fails immediately if the target file already exists. </td> </tr> <tr> <td width="40%"><a
///                  id="COPY_FILE_NO_BUFFERING"></a><a id="copy_file_no_buffering"></a><dl> <dt><b>COPY_FILE_NO_BUFFERING</b></dt>
///                  <dt>0x00001000</dt> </dl> </td> <td width="60%"> The copy operation is performed using unbuffered I/O, bypassing
///                  system I/O cache resources. Recommended for very large file transfers. <b>Windows Server 2003 and Windows XP:
///                  </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a id="COPY_FILE_OPEN_SOURCE_FOR_WRITE"></a><a
///                  id="copy_file_open_source_for_write"></a><dl> <dt><b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b></dt> <dt>0x00000004</dt>
///                  </dl> </td> <td width="60%"> The file is copied and the original file is opened for write access. </td> </tr>
///                  <tr> <td width="40%"><a id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl>
///                  <dt><b>COPY_FILE_RESTARTABLE</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Progress of the copy is
///                  tracked in the target file in case the copy fails. The failed copy can be restarted at a later time by specifying
///                  the same values for <i>lpExistingFileName</i> and <i>lpNewFileName</i> as those used in the call that failed.
///                  This can significantly slow down the copy operation as the new file may be flushed multiple times during the copy
///                  operation. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information call GetLastError. If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to
///    the user canceling the operation, <b>CopyFileEx</b> will return zero and GetLastError will return
///    <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is deleted. If
///    <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation, <b>CopyFileEx</b>
///    will return zero and GetLastError will return <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied
///    destination file is left intact.
///    
@DllImport("KERNEL32")
BOOL CopyFileExA(const(char)* lpExistingFileName, const(char)* lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, 
                 void* lpData, int* pbCancel, uint dwCopyFlags);

///Copies an existing file to a new file, notifying the application of its progress through a callback function. To
///perform this operation as a transacted operation, use the CopyFileTransacted function.
///Params:
///    lpExistingFileName = The name of an existing file. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                         characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                         "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting in Windows
///                         10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the
///                         <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of
///                         Naming Files, Paths, and Namespaces for details. </div> <div> </div> If <i>lpExistingFileName</i> does not exist,
///                         the <b>CopyFileEx</b> function fails, and the GetLastError function returns <b>ERROR_FILE_NOT_FOUND</b>.
///    lpNewFileName = The name of the new file. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                    characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                    "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting inWindows 10,
///                    version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the
///                    <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of
///                    Naming Files, Paths, and Namespaces for details. </div> <div> </div>
///    lpProgressRoutine = The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called each time another portion of
///                        the file has been copied. This parameter can be <b>NULL</b>. For more information on the progress callback
///                        function, see the CopyProgressRoutine function.
///    lpData = The argument to be passed to the callback function. This parameter can be <b>NULL</b>.
///    pbCancel = If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. Otherwise, the copy
///               operation will continue to completion.
///    dwCopyFlags = Flags that specify how the file is to be copied. This parameter can be a combination of the following values.
///                  <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="COPY_FILE_ALLOW_DECRYPTED_DESTINATION"></a><a id="copy_file_allow_decrypted_destination"></a><dl>
///                  <dt><b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> An attempt
///                  to copy an encrypted file will succeed even if the destination copy cannot be encrypted. </td> </tr> <tr> <td
///                  width="40%"><a id="COPY_FILE_COPY_SYMLINK"></a><a id="copy_file_copy_symlink"></a><dl>
///                  <dt><b>COPY_FILE_COPY_SYMLINK</b></dt> <dt>0x00000800</dt> </dl> </td> <td width="60%"> If the source file is a
///                  symbolic link, the destination file is also a symbolic link pointing to the same file that the source symbolic
///                  link is pointing to. <b>Windows Server 2003 and Windows XP: </b>This value is not supported. </td> </tr> <tr> <td
///                  width="40%"><a id="COPY_FILE_FAIL_IF_EXISTS"></a><a id="copy_file_fail_if_exists"></a><dl>
///                  <dt><b>COPY_FILE_FAIL_IF_EXISTS</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The copy operation
///                  fails immediately if the target file already exists. </td> </tr> <tr> <td width="40%"><a
///                  id="COPY_FILE_NO_BUFFERING"></a><a id="copy_file_no_buffering"></a><dl> <dt><b>COPY_FILE_NO_BUFFERING</b></dt>
///                  <dt>0x00001000</dt> </dl> </td> <td width="60%"> The copy operation is performed using unbuffered I/O, bypassing
///                  system I/O cache resources. Recommended for very large file transfers. <b>Windows Server 2003 and Windows XP:
///                  </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a id="COPY_FILE_OPEN_SOURCE_FOR_WRITE"></a><a
///                  id="copy_file_open_source_for_write"></a><dl> <dt><b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b></dt> <dt>0x00000004</dt>
///                  </dl> </td> <td width="60%"> The file is copied and the original file is opened for write access. </td> </tr>
///                  <tr> <td width="40%"><a id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl>
///                  <dt><b>COPY_FILE_RESTARTABLE</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Progress of the copy is
///                  tracked in the target file in case the copy fails. The failed copy can be restarted at a later time by specifying
///                  the same values for <i>lpExistingFileName</i> and <i>lpNewFileName</i> as those used in the call that failed.
///                  This can significantly slow down the copy operation as the new file may be flushed multiple times during the copy
///                  operation. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information call GetLastError. If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to
///    the user canceling the operation, <b>CopyFileEx</b> will return zero and GetLastError will return
///    <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is deleted. If
///    <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation, <b>CopyFileEx</b>
///    will return zero and GetLastError will return <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied
///    destination file is left intact.
///    
@DllImport("KERNEL32")
BOOL CopyFileExW(const(wchar)* lpExistingFileName, const(wchar)* lpNewFileName, 
                 LPPROGRESS_ROUTINE lpProgressRoutine, void* lpData, int* pbCancel, uint dwCopyFlags);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Copies an existing file
///to a new file as a transacted operation, notifying the application of its progress through a callback function.
///Params:
///    lpExistingFileName = The name of an existing file. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                         characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                         "\\?\" to the path. For more information, see Naming a File. If <i>lpExistingFileName</i> does not exist, the
///                         <b>CopyFileTransacted</b> function fails, and the GetLastError function returns <b>ERROR_FILE_NOT_FOUND</b>. The
///                         file must reside on the local computer; otherwise, the function fails and the last error code is set to
///                         <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    lpNewFileName = The name of the new file. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                    characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                    "\\?\" to the path. For more information, see Naming a File.
///    lpProgressRoutine = The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called each time another portion of
///                        the file has been copied. This parameter can be <b>NULL</b>. For more information on the progress callback
///                        function, see the CopyProgressRoutine function.
///    lpData = The argument to be passed to the callback function. This parameter can be <b>NULL</b>.
///    pbCancel = If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. Otherwise, the copy
///               operation will continue to completion.
///    dwCopyFlags = Flags that specify how the file is to be copied. This parameter can be a combination of the following values.
///                  <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="COPY_FILE_COPY_SYMLINK"></a><a
///                  id="copy_file_copy_symlink"></a><dl> <dt><b>COPY_FILE_COPY_SYMLINK</b></dt> <dt>0x00000800</dt> </dl> </td> <td
///                  width="60%"> If the source file is a symbolic link, the destination file is also a symbolic link pointing to the
///                  same file that the source symbolic link is pointing to. </td> </tr> <tr> <td width="40%"><a
///                  id="COPY_FILE_FAIL_IF_EXISTS"></a><a id="copy_file_fail_if_exists"></a><dl>
///                  <dt><b>COPY_FILE_FAIL_IF_EXISTS</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The copy operation
///                  fails immediately if the target file already exists. </td> </tr> <tr> <td width="40%"><a
///                  id="COPY_FILE_OPEN_SOURCE_FOR_WRITE"></a><a id="copy_file_open_source_for_write"></a><dl>
///                  <dt><b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The file is
///                  copied and the original file is opened for write access. </td> </tr> <tr> <td width="40%"><a
///                  id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl> <dt><b>COPY_FILE_RESTARTABLE</b></dt>
///                  <dt>0x00000002</dt> </dl> </td> <td width="60%"> Progress of the copy is tracked in the target file in case the
///                  copy fails. The failed copy can be restarted at a later time by specifying the same values for
///                  <i>lpExistingFileName</i> and <i>lpNewFileName</i> as those used in the call that failed. This can significantly
///                  slow down the copy operation as the new file may be flushed multiple times during the copy operation. </td> </tr>
///                  </table>
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information call GetLastError. If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to
///    the user canceling the operation, <b>CopyFileTransacted</b> will return zero and GetLastError will return
///    <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is deleted. If
///    <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation,
///    <b>CopyFileTransacted</b> will return zero and GetLastError will return <b>ERROR_REQUEST_ABORTED</b>. In this
///    case, the partially copied destination file is left intact. If you attempt to call this function with a handle to
///    a transaction that has already been rolled back, <b>CopyFileTransacted</b> will return either
///    <b>ERROR_TRANSACTION_NOT_ACTIVE</b> or <b>ERROR_INVALID_TRANSACTION</b>.
///    
@DllImport("KERNEL32")
BOOL CopyFileTransactedA(const(char)* lpExistingFileName, const(char)* lpNewFileName, 
                         LPPROGRESS_ROUTINE lpProgressRoutine, void* lpData, int* pbCancel, uint dwCopyFlags, 
                         HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Copies an existing file
///to a new file as a transacted operation, notifying the application of its progress through a callback function.
///Params:
///    lpExistingFileName = The name of an existing file. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                         characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                         "\\?\" to the path. For more information, see Naming a File. If <i>lpExistingFileName</i> does not exist, the
///                         <b>CopyFileTransacted</b> function fails, and the GetLastError function returns <b>ERROR_FILE_NOT_FOUND</b>. The
///                         file must reside on the local computer; otherwise, the function fails and the last error code is set to
///                         <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    lpNewFileName = The name of the new file. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                    characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                    "\\?\" to the path. For more information, see Naming a File.
///    lpProgressRoutine = The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called each time another portion of
///                        the file has been copied. This parameter can be <b>NULL</b>. For more information on the progress callback
///                        function, see the CopyProgressRoutine function.
///    lpData = The argument to be passed to the callback function. This parameter can be <b>NULL</b>.
///    pbCancel = If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. Otherwise, the copy
///               operation will continue to completion.
///    dwCopyFlags = Flags that specify how the file is to be copied. This parameter can be a combination of the following values.
///                  <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="COPY_FILE_COPY_SYMLINK"></a><a
///                  id="copy_file_copy_symlink"></a><dl> <dt><b>COPY_FILE_COPY_SYMLINK</b></dt> <dt>0x00000800</dt> </dl> </td> <td
///                  width="60%"> If the source file is a symbolic link, the destination file is also a symbolic link pointing to the
///                  same file that the source symbolic link is pointing to. </td> </tr> <tr> <td width="40%"><a
///                  id="COPY_FILE_FAIL_IF_EXISTS"></a><a id="copy_file_fail_if_exists"></a><dl>
///                  <dt><b>COPY_FILE_FAIL_IF_EXISTS</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The copy operation
///                  fails immediately if the target file already exists. </td> </tr> <tr> <td width="40%"><a
///                  id="COPY_FILE_OPEN_SOURCE_FOR_WRITE"></a><a id="copy_file_open_source_for_write"></a><dl>
///                  <dt><b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The file is
///                  copied and the original file is opened for write access. </td> </tr> <tr> <td width="40%"><a
///                  id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl> <dt><b>COPY_FILE_RESTARTABLE</b></dt>
///                  <dt>0x00000002</dt> </dl> </td> <td width="60%"> Progress of the copy is tracked in the target file in case the
///                  copy fails. The failed copy can be restarted at a later time by specifying the same values for
///                  <i>lpExistingFileName</i> and <i>lpNewFileName</i> as those used in the call that failed. This can significantly
///                  slow down the copy operation as the new file may be flushed multiple times during the copy operation. </td> </tr>
///                  </table>
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information call GetLastError. If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to
///    the user canceling the operation, <b>CopyFileTransacted</b> will return zero and GetLastError will return
///    <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is deleted. If
///    <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation,
///    <b>CopyFileTransacted</b> will return zero and GetLastError will return <b>ERROR_REQUEST_ABORTED</b>. In this
///    case, the partially copied destination file is left intact. If you attempt to call this function with a handle to
///    a transaction that has already been rolled back, <b>CopyFileTransacted</b> will return either
///    <b>ERROR_TRANSACTION_NOT_ACTIVE</b> or <b>ERROR_INVALID_TRANSACTION</b>.
///    
@DllImport("KERNEL32")
BOOL CopyFileTransactedW(const(wchar)* lpExistingFileName, const(wchar)* lpNewFileName, 
                         LPPROGRESS_ROUTINE lpProgressRoutine, void* lpData, int* pbCancel, uint dwCopyFlags, 
                         HANDLE hTransaction);

///Copies an existing file to a new file, notifying the application of its progress through a callback function.
///Params:
///    pwszExistingFileName = The name of an existing file. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For
///                           more information, see Naming Files, Paths, and Namespaces. <div class="alert"><b>Tip</b> Starting in Windows 10,
///                           version 1607, you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See
///                           the "Maximum Path Limitation" section of Naming Files, Paths, and Namespaces for details. </div> <div> </div> If
///                           <i>lpExistingFileName</i> does not exist, the <b>CopyFile2</b> function fails returns
///                           <code>HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)</code>.
///    pwszNewFileName = The name of the new file. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more
///                      information, see Naming Files, Paths, and Namespaces. <div class="alert"><b>Tip</b> Starting in Windows 10,
///                      version 1607, you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See
///                      the "Maximum Path Limitation" section of Naming Files, Paths, and Namespaces for details. </div> <div> </div>
///    pExtendedParameters = Optional address of a COPYFILE2_EXTENDED_PARAMETERS structure.
///Returns:
///    If the function succeeds, the return value will return <b>TRUE</b> when passed to the SUCCEEDED macro. <table>
///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
///    <td width="60%"> The copy operation completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>HRESULT_FROM_WIN32(ERROR_REQUEST_PAUSED)</b></dt> </dl> </td> <td width="60%"> The copy operation was
///    paused by a <b>COPYFILE2_PROGRESS_PAUSE</b> return from the CopyFile2ProgressRoutine callback function. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_REQUEST_ABORTED)</b></dt> </dl> </td> <td
///    width="60%"> The copy operation was paused by a <b>COPYFILE2_PROGRESS_CANCEL</b> or
///    <b>COPYFILE2_PROGRESS_STOP</b> return from the CopyFile2ProgressRoutine callback function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)</b></dt> </dl> </td> <td width="60%"> The
///    <b>dwCopyFlags</b> member of the COPYFILE2_EXTENDED_PARAMETERS structure passed through the
///    <i>pExtendedParameters</i> parameter contains the <b>COPY_FILE_FAIL_IF_EXISTS</b> flag and a conflicting name
///    existed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>HRESULT_FROM_WIN32(ERROR_FILE_EXISTS)</b></dt> </dl> </td>
///    <td width="60%"> The <b>dwCopyFlags</b> member of the COPYFILE2_EXTENDED_PARAMETERS structure passed through the
///    <i>pExtendedParameters</i> parameter contains the <b>COPY_FILE_FAIL_IF_EXISTS</b> flag and a conflicting name
///    existed. </td> </tr> </table>
///    
@DllImport("KERNEL32")
HRESULT CopyFile2(const(wchar)* pwszExistingFileName, const(wchar)* pwszNewFileName, 
                  COPYFILE2_EXTENDED_PARAMETERS* pExtendedParameters);

///Moves an existing file or a directory, including its children. To specify how to move the file, use the MoveFileEx or
///MoveFileWithProgress function. To perform this operation as a transacted operation, use the MoveFileTransacted
///function.
///Params:
///    lpExistingFileName = The current name of the file or directory on the local computer. In the ANSI version of this function, the name
///                         is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode
///                         version of the function and prepend "\\?\" to the path. For more information, see Naming a File. <div
///                         class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode version of this function
///                         (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the
///                         "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    lpNewFileName = The new name for the file or directory. The new name must not already exist. A new file may be on a different
///                    file system or drive. A new directory must be on the same drive. In the ANSI version of this function, the name
///                    is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode
///                    version of the function and prepend "\\?\" to the path. For more information, see Naming a File. <div
///                    class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode version of this function
///                    (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the
///                    "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL MoveFileA(const(char)* lpExistingFileName, const(char)* lpNewFileName);

///Moves an existing file or a directory, including its children. To specify how to move the file, use the MoveFileEx or
///MoveFileWithProgress function. To perform this operation as a transacted operation, use the MoveFileTransacted
///function.
///Params:
///    lpExistingFileName = The current name of the file or directory on the local computer. In the ANSI version of this function, the name
///                         is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode
///                         version of the function and prepend "\\?\" to the path. For more information, see Naming a File. <div
///                         class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode version of this function
///                         (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the
///                         "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    lpNewFileName = The new name for the file or directory. The new name must not already exist. A new file may be on a different
///                    file system or drive. A new directory must be on the same drive. In the ANSI version of this function, the name
///                    is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode
///                    version of the function and prepend "\\?\" to the path. For more information, see Naming a File. <div
///                    class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode version of this function
///                    (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the
///                    "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL MoveFileW(const(wchar)* lpExistingFileName, const(wchar)* lpNewFileName);

///Moves an existing file or directory, including its children, with various move options. The MoveFileWithProgress
///function is equivalent to the <b>MoveFileEx</b> function, except that <b>MoveFileWithProgress</b> allows you to
///provide a callback function that receives progress notifications. To perform this operation as a transacted
///operation, use the MoveFileTransacted function.
///Params:
///    lpExistingFileName = The current name of the file or directory on the local computer. If <i>dwFlags</i> specifies
///                         <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share, because delayed operations are
///                         performed before the network is available. In the ANSI version of this function, the name is limited to
///                         <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                         function and prepend "\\?\" to the path. For more information, see Naming a File <div class="alert"><b>Tip</b>
///                         Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can
///                         opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length
///                         Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    lpNewFileName = The new name of the file or directory on the local computer. When moving a file, the destination can be on a
///                    different file system or volume. If the destination is on another drive, you must set the
///                    <b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>. When moving a directory, the destination must be on the same
///                    drive. If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and <i>lpNewFileName</i> is <b>NULL</b>,
///                    <b>MoveFileEx</b> registers the <i>lpExistingFileName</i> file to be deleted when the system restarts. If
///                    <i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the
///                    directory is empty. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To
///                    extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the
///                    path. For more information, see Naming a File <div class="alert"><b>Tip</b> Starting with Windows 10, version
///                    1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b>
///                    limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths,
///                    and Namespaces for details.</div> <div> </div>
///    dwFlags = This parameter can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///              <tr> <td width="40%"><a id="MOVEFILE_COPY_ALLOWED"></a><a id="movefile_copy_allowed"></a><dl>
///              <dt><b>MOVEFILE_COPY_ALLOWED</b></dt> <dt>2 (0x2)</dt> </dl> </td> <td width="60%"> If the file is to be moved to
///              a different volume, the function simulates the move by using the CopyFile and DeleteFile functions. If the file
///              is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds
///              leaving the source file intact. This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>. </td> </tr>
///              <tr> <td width="40%"><a id="MOVEFILE_CREATE_HARDLINK"></a><a id="movefile_create_hardlink"></a><dl>
///              <dt><b>MOVEFILE_CREATE_HARDLINK</b></dt> <dt>16 (0x10)</dt> </dl> </td> <td width="60%"> Reserved for future use.
///              </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_DELAY_UNTIL_REBOOT"></a><a
///              id="movefile_delay_until_reboot"></a><dl> <dt><b>MOVEFILE_DELAY_UNTIL_REBOOT</b></dt> <dt>4 (0x4)</dt> </dl>
///              </td> <td width="60%"> The system does not move the file until the operating system is restarted. The system
///              moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this
///              parameter enables the function to delete paging files from previous startups. This value can be used only if the
///              process is in the context of a user who belongs to the administrators group or the LocalSystem account. This
///              value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>. </td> </tr> <tr> <td width="40%"><a
///              id="MOVEFILE_FAIL_IF_NOT_TRACKABLE"></a><a id="movefile_fail_if_not_trackable"></a><dl>
///              <dt><b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b></dt> <dt>32 (0x20)</dt> </dl> </td> <td width="60%"> The function fails
///              if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if
///              the destination is a volume formatted with the FAT file system. </td> </tr> <tr> <td width="40%"><a
///              id="MOVEFILE_REPLACE_EXISTING"></a><a id="movefile_replace_existing"></a><dl>
///              <dt><b>MOVEFILE_REPLACE_EXISTING</b></dt> <dt>1 (0x1)</dt> </dl> </td> <td width="60%"> If a file named
///              <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the
///              <i>lpExistingFileName</i> file, provided that security requirements regarding access control lists (ACLs) are
///              met. For more information, see the Remarks section of this topic. If <i>lpNewFileName</i> or
///              <i>lpExistingFileName</i> name a directory and <i>lpExistingFileName</i> exists, an error is reported. </td>
///              </tr> <tr> <td width="40%"><a id="MOVEFILE_WRITE_THROUGH"></a><a id="movefile_write_through"></a><dl>
///              <dt><b>MOVEFILE_WRITE_THROUGH</b></dt> <dt>8 (0x8)</dt> </dl> </td> <td width="60%"> The function does not return
///              until the file is actually moved on the disk. Setting this value guarantees that a move performed as a copy and
///              delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy
///              operation. This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL MoveFileExA(const(char)* lpExistingFileName, const(char)* lpNewFileName, uint dwFlags);

///Moves an existing file or directory, including its children, with various move options. The MoveFileWithProgress
///function is equivalent to the <b>MoveFileEx</b> function, except that <b>MoveFileWithProgress</b> allows you to
///provide a callback function that receives progress notifications. To perform this operation as a transacted
///operation, use the MoveFileTransacted function.
///Params:
///    lpExistingFileName = The current name of the file or directory on the local computer. If <i>dwFlags</i> specifies
///                         <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share, because delayed operations are
///                         performed before the network is available. In the ANSI version of this function, the name is limited to
///                         <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                         function and prepend "\\?\" to the path. For more information, see Naming a File <div class="alert"><b>Tip</b>
///                         Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can
///                         opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length
///                         Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    lpNewFileName = The new name of the file or directory on the local computer. When moving a file, the destination can be on a
///                    different file system or volume. If the destination is on another drive, you must set the
///                    <b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>. When moving a directory, the destination must be on the same
///                    drive. If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and <i>lpNewFileName</i> is <b>NULL</b>,
///                    <b>MoveFileEx</b> registers the <i>lpExistingFileName</i> file to be deleted when the system restarts. If
///                    <i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the
///                    directory is empty. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To
///                    extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the
///                    path. For more information, see Naming a File <div class="alert"><b>Tip</b> Starting with Windows 10, version
///                    1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b>
///                    limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths,
///                    and Namespaces for details.</div> <div> </div>
///    dwFlags = This parameter can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///              <tr> <td width="40%"><a id="MOVEFILE_COPY_ALLOWED"></a><a id="movefile_copy_allowed"></a><dl>
///              <dt><b>MOVEFILE_COPY_ALLOWED</b></dt> <dt>2 (0x2)</dt> </dl> </td> <td width="60%"> If the file is to be moved to
///              a different volume, the function simulates the move by using the CopyFile and DeleteFile functions. If the file
///              is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds
///              leaving the source file intact. This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>. </td> </tr>
///              <tr> <td width="40%"><a id="MOVEFILE_CREATE_HARDLINK"></a><a id="movefile_create_hardlink"></a><dl>
///              <dt><b>MOVEFILE_CREATE_HARDLINK</b></dt> <dt>16 (0x10)</dt> </dl> </td> <td width="60%"> Reserved for future use.
///              </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_DELAY_UNTIL_REBOOT"></a><a
///              id="movefile_delay_until_reboot"></a><dl> <dt><b>MOVEFILE_DELAY_UNTIL_REBOOT</b></dt> <dt>4 (0x4)</dt> </dl>
///              </td> <td width="60%"> The system does not move the file until the operating system is restarted. The system
///              moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this
///              parameter enables the function to delete paging files from previous startups. This value can be used only if the
///              process is in the context of a user who belongs to the administrators group or the LocalSystem account. This
///              value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>. </td> </tr> <tr> <td width="40%"><a
///              id="MOVEFILE_FAIL_IF_NOT_TRACKABLE"></a><a id="movefile_fail_if_not_trackable"></a><dl>
///              <dt><b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b></dt> <dt>32 (0x20)</dt> </dl> </td> <td width="60%"> The function fails
///              if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if
///              the destination is a volume formatted with the FAT file system. </td> </tr> <tr> <td width="40%"><a
///              id="MOVEFILE_REPLACE_EXISTING"></a><a id="movefile_replace_existing"></a><dl>
///              <dt><b>MOVEFILE_REPLACE_EXISTING</b></dt> <dt>1 (0x1)</dt> </dl> </td> <td width="60%"> If a file named
///              <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the
///              <i>lpExistingFileName</i> file, provided that security requirements regarding access control lists (ACLs) are
///              met. For more information, see the Remarks section of this topic. This value cannot be used if
///              <i>lpNewFileName</i> or <i>lpExistingFileName</i> names a directory. </td> </tr> <tr> <td width="40%"><a
///              id="MOVEFILE_WRITE_THROUGH"></a><a id="movefile_write_through"></a><dl> <dt><b>MOVEFILE_WRITE_THROUGH</b></dt>
///              <dt>8 (0x8)</dt> </dl> </td> <td width="60%"> The function does not return until the file is actually moved on
///              the disk. Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk
///              before the function returns. The flush occurs at the end of the copy operation. This value has no effect if
///              <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL MoveFileExW(const(wchar)* lpExistingFileName, const(wchar)* lpNewFileName, uint dwFlags);

///Moves a file or directory, including its children. You can provide a callback function that receives progress
///notifications. To perform this operation as a transacted operation, use the MoveFileTransacted function.
///Params:
///    lpExistingFileName = The name of the existing file or directory on the local computer. If <i>dwFlags</i> specifies
///                         <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share because delayed operations are
///                         performed before the network is available. In the ANSI version of this function, the name is limited to
///                         <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                         function and prepend "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b>
///                         Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>),
///                         you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length
///                         Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    lpNewFileName = The new name of the file or directory on the local computer. When moving a file, <i>lpNewFileName</i> can be on a
///                    different file system or volume. If <i>lpNewFileName</i> is on another drive, you must set the
///                    <b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>. When moving a directory, <i>lpExistingFileName</i> and
///                    <i>lpNewFileName</i> must be on the same drive. If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
///                    and <i>lpNewFileName</i> is <b>NULL</b>, <b>MoveFileWithProgress</b> registers <i>lpExistingFileName</i> to be
///                    deleted when the system restarts. The function fails if it cannot access the registry to store the information
///                    about the delete operation. If <i>lpExistingFileName</i> refers to a directory, the system removes the directory
///                    at restart only if the directory is empty. In the ANSI version of this function, the name is limited to
///                    <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                    function and prepend "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b>
///                    Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>),
///                    you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length
///                    Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    lpProgressRoutine = A pointer to a CopyProgressRoutine callback function that is called each time another portion of the file has
///                        been moved. The callback function can be useful if you provide a user interface that displays the progress of the
///                        operation. This parameter can be <b>NULL</b>.
///    lpData = An argument to be passed to the CopyProgressRoutine callback function. This parameter can be <b>NULL</b>.
///    dwFlags = The move options. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MOVEFILE_COPY_ALLOWED"></a><a
///              id="movefile_copy_allowed"></a><dl> <dt><b>MOVEFILE_COPY_ALLOWED</b></dt> <dt>2 (0x2)</dt> </dl> </td> <td
///              width="60%"> If the file is to be moved to a different volume, the function simulates the move by using the
///              CopyFile and DeleteFile functions. If the file is successfully copied to a different volume and the original file
///              is unable to be deleted, the function succeeds leaving the source file intact. This value cannot be used with
///              <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>. </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_CREATE_HARDLINK"></a><a
///              id="movefile_create_hardlink"></a><dl> <dt><b>MOVEFILE_CREATE_HARDLINK</b></dt> <dt>16 (0x10)</dt> </dl> </td>
///              <td width="60%"> Reserved for future use. </td> </tr> <tr> <td width="40%"><a
///              id="MOVEFILE_DELAY_UNTIL_REBOOT"></a><a id="movefile_delay_until_reboot"></a><dl>
///              <dt><b>MOVEFILE_DELAY_UNTIL_REBOOT</b></dt> <dt>4 (0x4)</dt> </dl> </td> <td width="60%"> The system does not
///              move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is
///              executed, but before creating any paging files. Consequently, this parameter enables the function to delete
///              paging files from previous startups. This value can only be used if the process is in the context of a user who
///              belongs to the administrators group or the LocalSystem account. This value cannot be used with
///              <b>MOVEFILE_COPY_ALLOWED</b>. </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_FAIL_IF_NOT_TRACKABLE"></a><a
///              id="movefile_fail_if_not_trackable"></a><dl> <dt><b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b></dt> <dt>32 (0x20)</dt>
///              </dl> </td> <td width="60%"> The function fails if the source file is a link source, but the file cannot be
///              tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file
///              system. </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_REPLACE_EXISTING"></a><a
///              id="movefile_replace_existing"></a><dl> <dt><b>MOVEFILE_REPLACE_EXISTING</b></dt> <dt>1 (0x1)</dt> </dl> </td>
///              <td width="60%"> If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the
///              contents of the <i>lpExistingFileName</i> file. This value cannot be used if <i>lpNewFileName</i> or
///              <i>lpExistingFileName</i> names a directory. </td> </tr> <tr> <td width="40%"><a
///              id="MOVEFILE_WRITE_THROUGH"></a><a id="movefile_write_through"></a><dl> <dt><b>MOVEFILE_WRITE_THROUGH</b></dt>
///              <dt>8 (0x8)</dt> </dl> </td> <td width="60%"> The function does not return until the file has actually been moved
///              on the disk. Setting this value guarantees that a move performed as a copy and delete operation is flushed to
///              disk before the function returns. The flush occurs at the end of the copy operation. This value has no effect if
///              <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. When moving a file across volumes, if <i>lpProgressRoutine</i>
///    returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>MoveFileWithProgress</b> will return
///    zero and GetLastError will return <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact. When moving a
///    file across volumes, if <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the
///    operation, <b>MoveFileWithProgress</b> will return zero and GetLastError will return
///    <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
///    
@DllImport("KERNEL32")
BOOL MoveFileWithProgressA(const(char)* lpExistingFileName, const(char)* lpNewFileName, 
                           LPPROGRESS_ROUTINE lpProgressRoutine, void* lpData, uint dwFlags);

///Moves a file or directory, including its children. You can provide a callback function that receives progress
///notifications. To perform this operation as a transacted operation, use the MoveFileTransacted function.
///Params:
///    lpExistingFileName = The name of the existing file or directory on the local computer. If <i>dwFlags</i> specifies
///                         <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share because delayed operations are
///                         performed before the network is available. In the ANSI version of this function, the name is limited to
///                         <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                         function and prepend "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b>
///                         Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>),
///                         you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length
///                         Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    lpNewFileName = The new name of the file or directory on the local computer. When moving a file, <i>lpNewFileName</i> can be on a
///                    different file system or volume. If <i>lpNewFileName</i> is on another drive, you must set the
///                    <b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>. When moving a directory, <i>lpExistingFileName</i> and
///                    <i>lpNewFileName</i> must be on the same drive. If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
///                    and <i>lpNewFileName</i> is <b>NULL</b>, <b>MoveFileWithProgress</b> registers <i>lpExistingFileName</i> to be
///                    deleted when the system restarts. The function fails if it cannot access the registry to store the information
///                    about the delete operation. If <i>lpExistingFileName</i> refers to a directory, the system removes the directory
///                    at restart only if the directory is empty. In the ANSI version of this function, the name is limited to
///                    <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the
///                    function and prepend "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b>
///                    Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>),
///                    you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length
///                    Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    lpProgressRoutine = A pointer to a CopyProgressRoutine callback function that is called each time another portion of the file has
///                        been moved. The callback function can be useful if you provide a user interface that displays the progress of the
///                        operation. This parameter can be <b>NULL</b>.
///    lpData = An argument to be passed to the CopyProgressRoutine callback function. This parameter can be <b>NULL</b>.
///    dwFlags = The move options. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MOVEFILE_COPY_ALLOWED"></a><a
///              id="movefile_copy_allowed"></a><dl> <dt><b>MOVEFILE_COPY_ALLOWED</b></dt> <dt>2 (0x2)</dt> </dl> </td> <td
///              width="60%"> If the file is to be moved to a different volume, the function simulates the move by using the
///              CopyFile and DeleteFile functions. If the file is successfully copied to a different volume and the original file
///              is unable to be deleted, the function succeeds leaving the source file intact. This value cannot be used with
///              <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>. </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_CREATE_HARDLINK"></a><a
///              id="movefile_create_hardlink"></a><dl> <dt><b>MOVEFILE_CREATE_HARDLINK</b></dt> <dt>16 (0x10)</dt> </dl> </td>
///              <td width="60%"> Reserved for future use. </td> </tr> <tr> <td width="40%"><a
///              id="MOVEFILE_DELAY_UNTIL_REBOOT"></a><a id="movefile_delay_until_reboot"></a><dl>
///              <dt><b>MOVEFILE_DELAY_UNTIL_REBOOT</b></dt> <dt>4 (0x4)</dt> </dl> </td> <td width="60%"> The system does not
///              move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is
///              executed, but before creating any paging files. Consequently, this parameter enables the function to delete
///              paging files from previous startups. This value can only be used if the process is in the context of a user who
///              belongs to the administrators group or the LocalSystem account. This value cannot be used with
///              <b>MOVEFILE_COPY_ALLOWED</b>. </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_FAIL_IF_NOT_TRACKABLE"></a><a
///              id="movefile_fail_if_not_trackable"></a><dl> <dt><b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b></dt> <dt>32 (0x20)</dt>
///              </dl> </td> <td width="60%"> The function fails if the source file is a link source, but the file cannot be
///              tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file
///              system. </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_REPLACE_EXISTING"></a><a
///              id="movefile_replace_existing"></a><dl> <dt><b>MOVEFILE_REPLACE_EXISTING</b></dt> <dt>1 (0x1)</dt> </dl> </td>
///              <td width="60%"> If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the
///              contents of the <i>lpExistingFileName</i> file. This value cannot be used if <i>lpNewFileName</i> or
///              <i>lpExistingFileName</i> names a directory. </td> </tr> <tr> <td width="40%"><a
///              id="MOVEFILE_WRITE_THROUGH"></a><a id="movefile_write_through"></a><dl> <dt><b>MOVEFILE_WRITE_THROUGH</b></dt>
///              <dt>8 (0x8)</dt> </dl> </td> <td width="60%"> The function does not return until the file has actually been moved
///              on the disk. Setting this value guarantees that a move performed as a copy and delete operation is flushed to
///              disk before the function returns. The flush occurs at the end of the copy operation. This value has no effect if
///              <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. When moving a file across volumes, if <i>lpProgressRoutine</i>
///    returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>MoveFileWithProgress</b> will return
///    zero and GetLastError will return <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact. When moving a
///    file across volumes, if <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the
///    operation, <b>MoveFileWithProgress</b> will return zero and GetLastError will return
///    <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
///    
@DllImport("KERNEL32")
BOOL MoveFileWithProgressW(const(wchar)* lpExistingFileName, const(wchar)* lpNewFileName, 
                           LPPROGRESS_ROUTINE lpProgressRoutine, void* lpData, uint dwFlags);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Moves an existing file or
///a directory, including its children, as a transacted operation.
///Params:
///    lpExistingFileName = The current name of the existing file or directory on the local computer. In the ANSI version of this function,
///                         the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the
///                         Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
///    lpNewFileName = The new name for the file or directory. The new name must not already exist. A new file may be on a different
///                    file system or drive. A new directory must be on the same drive. In the ANSI version of this function, the name
///                    is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode
///                    version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
///    lpProgressRoutine = A pointer to a CopyProgressRoutine callback function that is called each time another portion of the file has
///                        been moved. The callback function can be useful if you provide a user interface that displays the progress of the
///                        operation. This parameter can be <b>NULL</b>.
///    lpData = An argument to be passed to the CopyProgressRoutine callback function. This parameter can be <b>NULL</b>.
///    dwFlags = The move options. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MOVEFILE_COPY_ALLOWED"></a><a
///              id="movefile_copy_allowed"></a><dl> <dt><b>MOVEFILE_COPY_ALLOWED</b></dt> <dt>2 (0x2)</dt> </dl> </td> <td
///              width="60%"> If the file is to be moved to a different volume, the function simulates the move by using the
///              CopyFile and DeleteFile functions. If the file is successfully copied to a different volume and the original file
///              is unable to be deleted, the function succeeds leaving the source file intact. This value cannot be used with
///              <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>. </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_CREATE_HARDLINK"></a><a
///              id="movefile_create_hardlink"></a><dl> <dt><b>MOVEFILE_CREATE_HARDLINK</b></dt> <dt>16 (0x10)</dt> </dl> </td>
///              <td width="60%"> Reserved for future use. </td> </tr> <tr> <td width="40%"><a
///              id="MOVEFILE_DELAY_UNTIL_REBOOT"></a><a id="movefile_delay_until_reboot"></a><dl>
///              <dt><b>MOVEFILE_DELAY_UNTIL_REBOOT</b></dt> <dt>4 (0x4)</dt> </dl> </td> <td width="60%"> The system does not
///              move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is
///              executed, but before creating any paging files. Consequently, this parameter enables the function to delete
///              paging files from previous startups. This value can only be used if the process is in the context of a user who
///              belongs to the administrators group or the LocalSystem account. This value cannot be used with
///              <b>MOVEFILE_COPY_ALLOWED</b>. The write operation to the registry value as detailed in the Remarks section is
///              what is transacted. The file move is finished when the computer restarts, after the transaction is complete.
///              </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_REPLACE_EXISTING"></a><a id="movefile_replace_existing"></a><dl>
///              <dt><b>MOVEFILE_REPLACE_EXISTING</b></dt> <dt>1 (0x1)</dt> </dl> </td> <td width="60%"> If a file named
///              <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the
///              <i>lpExistingFileName</i> file. This value cannot be used if <i>lpNewFileName</i> or <i>lpExistingFileName</i>
///              names a directory. </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_WRITE_THROUGH"></a><a
///              id="movefile_write_through"></a><dl> <dt><b>MOVEFILE_WRITE_THROUGH</b></dt> <dt>8 (0x8)</dt> </dl> </td> <td
///              width="60%"> A call to <b>MoveFileTransacted</b> means that the move file operation is complete when the commit
///              operation is completed. This flag is unnecessary; there are no negative affects if this flag is specified, other
///              than an operation slowdown. The function does not return until the file has actually been moved on the disk.
///              Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the
///              function returns. The flush occurs at the end of the copy operation. This value has no effect if
///              <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set. </td> </tr> </table>
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. When moving a file across volumes, if <i>lpProgressRoutine</i>
///    returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>MoveFileTransacted</b> will return
///    zero and GetLastError will return <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact. When moving a
///    file across volumes, if <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the
///    operation, <b>MoveFileTransacted</b> will return zero and GetLastError will return <b>ERROR_REQUEST_ABORTED</b>.
///    The existing file is left intact.
///    
@DllImport("KERNEL32")
BOOL MoveFileTransactedA(const(char)* lpExistingFileName, const(char)* lpNewFileName, 
                         LPPROGRESS_ROUTINE lpProgressRoutine, void* lpData, uint dwFlags, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Moves an existing file or
///a directory, including its children, as a transacted operation.
///Params:
///    lpExistingFileName = The current name of the existing file or directory on the local computer. In the ANSI version of this function,
///                         the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the
///                         Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
///    lpNewFileName = The new name for the file or directory. The new name must not already exist. A new file may be on a different
///                    file system or drive. A new directory must be on the same drive. In the ANSI version of this function, the name
///                    is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode
///                    version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
///    lpProgressRoutine = A pointer to a CopyProgressRoutine callback function that is called each time another portion of the file has
///                        been moved. The callback function can be useful if you provide a user interface that displays the progress of the
///                        operation. This parameter can be <b>NULL</b>.
///    lpData = An argument to be passed to the CopyProgressRoutine callback function. This parameter can be <b>NULL</b>.
///    dwFlags = The move options. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MOVEFILE_COPY_ALLOWED"></a><a
///              id="movefile_copy_allowed"></a><dl> <dt><b>MOVEFILE_COPY_ALLOWED</b></dt> <dt>2 (0x2)</dt> </dl> </td> <td
///              width="60%"> If the file is to be moved to a different volume, the function simulates the move by using the
///              CopyFile and DeleteFile functions. If the file is successfully copied to a different volume and the original file
///              is unable to be deleted, the function succeeds leaving the source file intact. This value cannot be used with
///              <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>. </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_CREATE_HARDLINK"></a><a
///              id="movefile_create_hardlink"></a><dl> <dt><b>MOVEFILE_CREATE_HARDLINK</b></dt> <dt>16 (0x10)</dt> </dl> </td>
///              <td width="60%"> Reserved for future use. </td> </tr> <tr> <td width="40%"><a
///              id="MOVEFILE_DELAY_UNTIL_REBOOT"></a><a id="movefile_delay_until_reboot"></a><dl>
///              <dt><b>MOVEFILE_DELAY_UNTIL_REBOOT</b></dt> <dt>4 (0x4)</dt> </dl> </td> <td width="60%"> The system does not
///              move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is
///              executed, but before creating any paging files. Consequently, this parameter enables the function to delete
///              paging files from previous startups. This value can only be used if the process is in the context of a user who
///              belongs to the administrators group or the LocalSystem account. This value cannot be used with
///              <b>MOVEFILE_COPY_ALLOWED</b>. The write operation to the registry value as detailed in the Remarks section is
///              what is transacted. The file move is finished when the computer restarts, after the transaction is complete.
///              </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_REPLACE_EXISTING"></a><a id="movefile_replace_existing"></a><dl>
///              <dt><b>MOVEFILE_REPLACE_EXISTING</b></dt> <dt>1 (0x1)</dt> </dl> </td> <td width="60%"> If a file named
///              <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the
///              <i>lpExistingFileName</i> file. This value cannot be used if <i>lpNewFileName</i> or <i>lpExistingFileName</i>
///              names a directory. </td> </tr> <tr> <td width="40%"><a id="MOVEFILE_WRITE_THROUGH"></a><a
///              id="movefile_write_through"></a><dl> <dt><b>MOVEFILE_WRITE_THROUGH</b></dt> <dt>8 (0x8)</dt> </dl> </td> <td
///              width="60%"> A call to <b>MoveFileTransacted</b> means that the move file operation is complete when the commit
///              operation is completed. This flag is unnecessary; there are no negative affects if this flag is specified, other
///              than an operation slowdown. The function does not return until the file has actually been moved on the disk.
///              Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the
///              function returns. The flush occurs at the end of the copy operation. This value has no effect if
///              <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set. </td> </tr> </table>
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. When moving a file across volumes, if <i>lpProgressRoutine</i>
///    returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>MoveFileTransacted</b> will return
///    zero and GetLastError will return <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact. When moving a
///    file across volumes, if <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the
///    operation, <b>MoveFileTransacted</b> will return zero and GetLastError will return <b>ERROR_REQUEST_ABORTED</b>.
///    The existing file is left intact.
///    
@DllImport("KERNEL32")
BOOL MoveFileTransactedW(const(wchar)* lpExistingFileName, const(wchar)* lpNewFileName, 
                         LPPROGRESS_ROUTINE lpProgressRoutine, void* lpData, uint dwFlags, HANDLE hTransaction);

///Replaces one file with another file, with the option of creating a backup copy of the original file. The replacement
///file assumes the name of the replaced file and its identity.
///Params:
///    lpReplacedFileName = The name of the file to be replaced. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                         characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                         "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting with Windows
///                         10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the
///                         <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming
///                         Files, Paths, and Namespaces for details.</div> <div> </div> This file is opened with the <b>GENERIC_READ</b>,
///                         <b>DELETE</b>, and <b>SYNCHRONIZE</b> access rights. The sharing mode is <b>FILE_SHARE_READ</b> |
///                         <b>FILE_SHARE_WRITE</b> | <b>FILE_SHARE_DELETE</b>. The caller must have write access to the file to be replaced.
///                         For more information, see File Security and Access Rights.
///    lpReplacementFileName = The name of the file that will replace the <i>lpReplacedFileName</i> file. In the ANSI version of this function,
///                            the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the
///                            Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File. <div
///                            class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode version of this function
///                            (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the
///                            "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///                            The function attempts to open this file with the <b>SYNCHRONIZE</b>, <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>,
///                            <b>DELETE</b>, and <b>WRITE_DAC</b> access rights so that it can preserve all attributes and ACLs. If this fails,
///                            the function attempts to open the file with the <b>SYNCHRONIZE</b>, <b>GENERIC_READ</b>, <b>DELETE</b>, and
///                            <b>WRITE_DAC</b> access rights. No sharing mode is specified.
///    lpBackupFileName = The name of the file that will serve as a backup copy of the <i>lpReplacedFileName</i> file. If this parameter is
///                       <b>NULL</b>, no backup file is created. See the Remarks section for implementation details on the backup file. In
///                       the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to
///                       32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more
///                       information, see Naming a File. <div class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the
///                       unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation
///                       without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths, and
///                       Namespaces for details.</div> <div> </div>
///    dwReplaceFlags = The replacement options. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///                     <th>Meaning</th> </tr> <tr> <td width="40%"><a id="REPLACEFILE_WRITE_THROUGH"></a><a
///                     id="replacefile_write_through"></a><dl> <dt><b>REPLACEFILE_WRITE_THROUGH</b></dt> <dt>0x00000001</dt> </dl> </td>
///                     <td width="60%"> This value is not supported. </td> </tr> <tr> <td width="40%"><a
///                     id="REPLACEFILE_IGNORE_MERGE_ERRORS"></a><a id="replacefile_ignore_merge_errors"></a><dl>
///                     <dt><b>REPLACEFILE_IGNORE_MERGE_ERRORS</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Ignores errors
///                     that occur while merging information (such as attributes and ACLs) from the replaced file to the replacement
///                     file. Therefore, if you specify this flag and do not have <b>WRITE_DAC</b> access, the function succeeds but the
///                     ACLs are not preserved. </td> </tr> <tr> <td width="40%"><a id="REPLACEFILE_IGNORE_ACL_ERRORS"></a><a
///                     id="replacefile_ignore_acl_errors"></a><dl> <dt><b>REPLACEFILE_IGNORE_ACL_ERRORS</b></dt> <dt>0x00000004</dt>
///                     </dl> </td> <td width="60%"> Ignores errors that occur while merging ACL information from the replaced file to
///                     the replacement file. Therefore, if you specify this flag and do not have <b>WRITE_DAC</b> access, the function
///                     succeeds but the ACLs are not preserved. To compile an application that uses this value, define the
///                     <b>_WIN32_WINNT</b> macro as 0x0600 or later. <b>Windows Server 2003 and Windows XP: </b>This value is not
///                     supported. </td> </tr> </table>
///    lpExclude = Reserved for future use.
///    lpReserved = Reserved for future use.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following are possible error codes for this function. <table>
///    <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNABLE_TO_MOVE_REPLACEMENT</b></dt> <dt>1176 (0x498)</dt> </dl> </td> <td width="60%"> The
///    replacement file could not be renamed. If <i>lpBackupFileName</i> was specified, the replaced and replacement
///    files retain their original file names. Otherwise, the replaced file no longer exists and the replacement file
///    exists under its original name. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNABLE_TO_MOVE_REPLACEMENT_2</b></dt> <dt>1177 (0x499)</dt> </dl> </td> <td width="60%"> The
///    replacement file could not be moved. The replacement file still exists under its original name; however, it has
///    inherited the file streams and attributes from the file it is replacing. The file to be replaced still exists
///    with a different name. If <i>lpBackupFileName</i> is specified, it will be the name of the replaced file. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_REMOVE_REPLACED</b></dt> <dt>1175 (0x497)</dt> </dl>
///    </td> <td width="60%"> The replaced file could not be deleted. The replaced and replacement files retain their
///    original file names. </td> </tr> </table> If any other error is returned, such as <b>ERROR_INVALID_PARAMETER</b>,
///    the replaced and replacement files will retain their original file names. In this scenario, a backup file does
///    not exist and it is not guaranteed that the replacement file will have inherited all of the attributes and
///    streams of the replaced file.
///    
@DllImport("KERNEL32")
BOOL ReplaceFileA(const(char)* lpReplacedFileName, const(char)* lpReplacementFileName, 
                  const(char)* lpBackupFileName, uint dwReplaceFlags, void* lpExclude, void* lpReserved);

///Replaces one file with another file, with the option of creating a backup copy of the original file. The replacement
///file assumes the name of the replaced file and its identity.
///Params:
///    lpReplacedFileName = The name of the file to be replaced. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                         characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                         "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting with Windows
///                         10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the
///                         <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming
///                         Files, Paths, and Namespaces for details.</div> <div> </div> This file is opened with the <b>GENERIC_READ</b>,
///                         <b>DELETE</b>, and <b>SYNCHRONIZE</b> access rights. The sharing mode is <b>FILE_SHARE_READ</b> |
///                         <b>FILE_SHARE_WRITE</b> | <b>FILE_SHARE_DELETE</b>. The caller must have write access to the file to be replaced.
///                         For more information, see File Security and Access Rights.
///    lpReplacementFileName = The name of the file that will replace the <i>lpReplacedFileName</i> file. In the ANSI version of this function,
///                            the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the
///                            Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File. <div
///                            class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode version of this function
///                            (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the
///                            "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///                            The function attempts to open this file with the <b>SYNCHRONIZE</b>, <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>,
///                            <b>DELETE</b>, and <b>WRITE_DAC</b> access rights so that it can preserve all attributes and ACLs. If this fails,
///                            the function attempts to open the file with the <b>SYNCHRONIZE</b>, <b>GENERIC_READ</b>, <b>DELETE</b>, and
///                            <b>WRITE_DAC</b> access rights. No sharing mode is specified.
///    lpBackupFileName = The name of the file that will serve as a backup copy of the <i>lpReplacedFileName</i> file. If this parameter is
///                       <b>NULL</b>, no backup file is created. See the Remarks section for implementation details on the backup file. In
///                       the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to
///                       32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more
///                       information, see Naming a File. <div class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the
///                       unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation
///                       without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths, and
///                       Namespaces for details.</div> <div> </div>
///    dwReplaceFlags = The replacement options. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///                     <th>Meaning</th> </tr> <tr> <td width="40%"><a id="REPLACEFILE_WRITE_THROUGH"></a><a
///                     id="replacefile_write_through"></a><dl> <dt><b>REPLACEFILE_WRITE_THROUGH</b></dt> <dt>0x00000001</dt> </dl> </td>
///                     <td width="60%"> This value is not supported. </td> </tr> <tr> <td width="40%"><a
///                     id="REPLACEFILE_IGNORE_MERGE_ERRORS"></a><a id="replacefile_ignore_merge_errors"></a><dl>
///                     <dt><b>REPLACEFILE_IGNORE_MERGE_ERRORS</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Ignores errors
///                     that occur while merging information (such as attributes and ACLs) from the replaced file to the replacement
///                     file. Therefore, if you specify this flag and do not have <b>WRITE_DAC</b> access, the function succeeds but the
///                     ACLs are not preserved. </td> </tr> <tr> <td width="40%"><a id="REPLACEFILE_IGNORE_ACL_ERRORS"></a><a
///                     id="replacefile_ignore_acl_errors"></a><dl> <dt><b>REPLACEFILE_IGNORE_ACL_ERRORS</b></dt> <dt>0x00000004</dt>
///                     </dl> </td> <td width="60%"> Ignores errors that occur while merging ACL information from the replaced file to
///                     the replacement file. Therefore, if you specify this flag and do not have <b>WRITE_DAC</b> access, the function
///                     succeeds but the ACLs are not preserved. To compile an application that uses this value, define the
///                     <b>_WIN32_WINNT</b> macro as 0x0600 or later. <b>Windows Server 2003 and Windows XP: </b>This value is not
///                     supported. </td> </tr> </table>
///    lpExclude = Reserved for future use.
///    lpReserved = Reserved for future use.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following are possible error codes for this function. <table>
///    <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNABLE_TO_MOVE_REPLACEMENT</b></dt> <dt>1176 (0x498)</dt> </dl> </td> <td width="60%"> The
///    replacement file could not be renamed. If <i>lpBackupFileName</i> was specified, the replaced and replacement
///    files retain their original file names. Otherwise, the replaced file no longer exists and the replacement file
///    exists under its original name. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNABLE_TO_MOVE_REPLACEMENT_2</b></dt> <dt>1177 (0x499)</dt> </dl> </td> <td width="60%"> The
///    replacement file could not be moved. The replacement file still exists under its original name; however, it has
///    inherited the file streams and attributes from the file it is replacing. The file to be replaced still exists
///    with a different name. If <i>lpBackupFileName</i> is specified, it will be the name of the replaced file. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_REMOVE_REPLACED</b></dt> <dt>1175 (0x497)</dt> </dl>
///    </td> <td width="60%"> The replaced file could not be deleted. The replaced and replacement files retain their
///    original file names. </td> </tr> </table> If any other error is returned, such as <b>ERROR_INVALID_PARAMETER</b>,
///    the replaced and replacement files will retain their original file names. In this scenario, a backup file does
///    not exist and it is not guaranteed that the replacement file will have inherited all of the attributes and
///    streams of the replaced file.
///    
@DllImport("KERNEL32")
BOOL ReplaceFileW(const(wchar)* lpReplacedFileName, const(wchar)* lpReplacementFileName, 
                  const(wchar)* lpBackupFileName, uint dwReplaceFlags, void* lpExclude, void* lpReserved);

///Establishes a hard link between an existing file and a new file. This function is only supported on the NTFS file
///system, and only for files, not directories. To perform this operation as a transacted operation, use the
///CreateHardLinkTransacted function.
///Params:
///    lpFileName = The name of the new file. This parameter may include the path but cannot specify the name of a directory. In the
///                 ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767
///                 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more
///                 information, see Naming a File. If you pass a name longer than MAX_PATH characters to the ANSI version of this
///                 function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function
///                 returns ERROR_PATH_NOT_FOUND. <div class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the
///                 unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b>
///                 limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths,
///                 and Namespaces for details.</div> <div> </div>
///    lpExistingFileName = The name of the existing file. This parameter may include the path cannot specify the name of a directory. In the
///                         ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767
///                         wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more
///                         information, see Naming a File. If you pass a name longer than MAX_PATH characters to the ANSI version of this
///                         function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function
///                         returns ERROR_PATH_NOT_FOUND. <div class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the
///                         unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b>
///                         limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths,
///                         and Namespaces for details.</div> <div> </div>
///    lpSecurityAttributes = Reserved; must be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The maximum number of hard links that can be created with this
///    function is 1023 per file. If more than 1023 links are created for a file, an error results. If you pass a name
///    longer than MAX_PATH characters to the *lpFileName* or *lpExistingFileName* parameter of the ANSI version of this
///    function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function
///    returns ERROR_PATH_NOT_FOUND.
///    
@DllImport("KERNEL32")
BOOL CreateHardLinkA(const(char)* lpFileName, const(char)* lpExistingFileName, 
                     SECURITY_ATTRIBUTES* lpSecurityAttributes);

///Establishes a hard link between an existing file and a new file. This function is only supported on the NTFS file
///system, and only for files, not directories. To perform this operation as a transacted operation, use the
///CreateHardLinkTransacted function.
///Params:
///    lpFileName = The name of the new file. This parameter may include the path but cannot specify the name of a directory. In the
///                 ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767
///                 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more
///                 information, see Naming a File. If you pass a name longer than MAX_PATH characters to the ANSI version of this
///                 function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function
///                 returns ERROR_PATH_NOT_FOUND. <div class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the
///                 unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b>
///                 limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths,
///                 and Namespaces for details.</div> <div> </div>
///    lpExistingFileName = The name of the existing file. This parameter may include the path cannot specify the name of a directory. In the
///                         ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767
///                         wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more
///                         information, see Naming a File. If you pass a name longer than MAX_PATH characters to the ANSI version of this
///                         function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function
///                         returns ERROR_PATH_NOT_FOUND. <div class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the
///                         unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b>
///                         limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of Naming Files, Paths,
///                         and Namespaces for details.</div> <div> </div>
///    lpSecurityAttributes = Reserved; must be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The maximum number of hard links that can be created with this
///    function is 1023 per file. If more than 1023 links are created for a file, an error results. If you pass a name
///    longer than MAX_PATH characters to the *lpFileName* or *lpExistingFileName* parameter of the ANSI version of this
///    function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function
///    returns ERROR_PATH_NOT_FOUND.
///    
@DllImport("KERNEL32")
BOOL CreateHardLinkW(const(wchar)* lpFileName, const(wchar)* lpExistingFileName, 
                     SECURITY_ATTRIBUTES* lpSecurityAttributes);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Establishes a hard link
///between an existing file and a new file as a transacted operation. This function is only supported on the NTFS file
///system, and only for files, not directories.
///Params:
///    lpFileName = The name of the new file. This parameter cannot specify the name of a directory.
///    lpExistingFileName = The name of the existing file. This parameter cannot specify the name of a directory.
///    lpSecurityAttributes = Reserved; must be <b>NULL</b>.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The maximum number of hard links that can be created with this
///    function is 1023 per file. If more than 1023 links are created for a file, an error results. The files must
///    reside on the local computer; otherwise, the function fails and the last error code is set to
///    <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    
@DllImport("KERNEL32")
BOOL CreateHardLinkTransactedA(const(char)* lpFileName, const(char)* lpExistingFileName, 
                               SECURITY_ATTRIBUTES* lpSecurityAttributes, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Establishes a hard link
///between an existing file and a new file as a transacted operation. This function is only supported on the NTFS file
///system, and only for files, not directories.
///Params:
///    lpFileName = The name of the new file. This parameter cannot specify the name of a directory.
///    lpExistingFileName = The name of the existing file. This parameter cannot specify the name of a directory.
///    lpSecurityAttributes = Reserved; must be <b>NULL</b>.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError. The maximum number of hard links that can be created with this
///    function is 1023 per file. If more than 1023 links are created for a file, an error results. The files must
///    reside on the local computer; otherwise, the function fails and the last error code is set to
///    <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
///    
@DllImport("KERNEL32")
BOOL CreateHardLinkTransactedW(const(wchar)* lpFileName, const(wchar)* lpExistingFileName, 
                               SECURITY_ATTRIBUTES* lpSecurityAttributes, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Enumerates the first
///stream in the specified file or directory as a transacted operation.
///Params:
///    lpFileName = The fully qualified file name. The file must reside on the local computer; otherwise, the function fails and the
///                 last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b> (6805).
///    InfoLevel = The information level of the returned data. This parameter is one of the values in the STREAM_INFO_LEVELS
///                enumeration type. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="FindStreamInfoStandard"></a><a id="findstreaminfostandard"></a><a id="FINDSTREAMINFOSTANDARD"></a><dl>
///                <dt><b>FindStreamInfoStandard</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> The data is returned in a
///                WIN32_FIND_STREAM_DATA structure. </td> </tr> </table>
///    lpFindStreamData = A pointer to a buffer that receives the file data. The format of this data depends on the value of the
///                       <i>InfoLevel</i> parameter.
///    dwFlags = Reserved for future use. This parameter must be zero.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is a search handle that can be used in subsequent calls to the
///    FindNextStreamWfunction. If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended
///    error information, call GetLastError.
///    
@DllImport("KERNEL32")
FindStreamHandle FindFirstStreamTransactedW(const(wchar)* lpFileName, STREAM_INFO_LEVELS InfoLevel, 
                                            char* lpFindStreamData, uint dwFlags, HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Creates an enumeration of
///all the hard links to the specified file as a transacted operation. The function returns a handle to the enumeration
///that can be used on subsequent calls to the FindNextFileNameW function.
///Params:
///    lpFileName = The name of the file. The file must reside on the local computer; otherwise, the function fails and the last
///                 error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b> (6805).
///    dwFlags = Reserved; specify zero (0).
///    StringLength = The size of the buffer pointed to by the <i>LinkName</i> parameter, in characters. If this call fails and the
///                   error is <b>ERROR_MORE_DATA</b> (234), the value that is returned by this parameter is the size that the buffer
///                   pointed to by <i>LinkName</i> must be to contain all the data.
///    LinkName = A pointer to a buffer to store the first link name found for <i>lpFileName</i>.
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is a search handle that can be used with the FindNextFileNameW
///    function or closed with the FindClose function. If the function fails, the return value is
///    <b>INVALID_HANDLE_VALUE</b> (0xffffffff). To get extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
FindFileNameHandle FindFirstFileNameTransactedW(const(wchar)* lpFileName, uint dwFlags, uint* StringLength, 
                                                const(wchar)* LinkName, HANDLE hTransaction);

///Sets the label of a file system volume.
///Params:
///    lpRootPathName = A pointer to a string that contains the volume's drive letter (for example, X:\) or the path of a mounted folder
///                     that is associated with the volume (for example, Y:\MountX\). The string must end with a trailing backslash
///                     ('\'). If this parameter is <b>NULL</b>, the root of the current directory is used.
///    lpVolumeName = A pointer to a string that contains the new label for the volume. If this parameter is <b>NULL</b>, the function
///                   deletes any existing label from the specified volume and does not assign a new label.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetVolumeLabelA(const(char)* lpRootPathName, const(char)* lpVolumeName);

///Sets the label of a file system volume.
///Params:
///    lpRootPathName = A pointer to a string that contains the volume's drive letter (for example, X:\) or the path of a mounted folder
///                     that is associated with the volume (for example, Y:\MountX\). The string must end with a trailing backslash
///                     ('\'). If this parameter is <b>NULL</b>, the root of the current directory is used.
///    lpVolumeName = A pointer to a string that contains the new label for the volume. If this parameter is <b>NULL</b>, the function
///                   deletes any existing label from the specified volume and does not assign a new label.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetVolumeLabelW(const(wchar)* lpRootPathName, const(wchar)* lpVolumeName);

///Requests that bandwidth for the specified file stream be reserved. The reservation is specified as a number of bytes
///in a period of milliseconds for I/O requests on the specified file handle.
///Params:
///    hFile = A handle to the file.
///    nPeriodMilliseconds = The period of the reservation, in milliseconds. The period is the time from which the I/O is issued to the kernel
///                          until the time the I/O should be completed. The minimum supported value for the file stream can be determined by
///                          looking at the value returned through the <i>lpPeriodMilliseconds</i> parameter to the
///                          GetFileBandwidthReservation function, on a handle that has not had a bandwidth reservation set.
///    nBytesPerPeriod = The bandwidth to reserve, in bytes per period. The maximum supported value for the file stream can be determined
///                      by looking at the value returned through the <i>lpBytesPerPeriod</i> parameter to the GetFileBandwidthReservation
///                      function, on a handle that has not had a bandwidth reservation set.
///    bDiscardable = Indicates whether I/O should be completed with an error if a driver is unable to satisfy an I/O operation before
///                   the period expires. If one of the drivers for the specified file stream does not support this functionality, this
///                   function may return success and ignore the flag. To verify whether the setting will be honored, call the
///                   GetFileBandwidthReservation function using the same <i>hFile</i> handle and examine the <i>*pDiscardable</i>
///                   return value.
///    lpTransferSize = A pointer to a variable that receives the minimum size of any individual I/O request that may be issued by the
///                     application. All I/O requests should be multiples of <i>TransferSize</i>.
///    lpNumOutstandingRequests = A pointer to a variable that receives the number of <i>TransferSize</i> chunks the application should allow to be
///                               outstanding with the operating system. This allows the storage stack to keep the device busy and allows maximum
///                               throughput.
///Returns:
///    Returns nonzero if successful or zero otherwise. A reservation can fail if there is not enough bandwidth
///    available on the volume because of existing reservations; in this case <b>ERROR_NO_SYSTEM_RESOURCES</b> is
///    returned. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetFileBandwidthReservation(HANDLE hFile, uint nPeriodMilliseconds, uint nBytesPerPeriod, BOOL bDiscardable, 
                                 uint* lpTransferSize, uint* lpNumOutstandingRequests);

///Retrieves the bandwidth reservation properties of the volume on which the specified file resides.
///Params:
///    hFile = A handle to the file.
///    lpPeriodMilliseconds = A pointer to a variable that receives the period of the reservation, in milliseconds. The period is the time from
///                           which the I/O is issued to the kernel until the time the I/O should be completed. If no bandwidth has been
///                           reserved for this handle, then the value returned is the minimum reservation period supported for this volume.
///    lpBytesPerPeriod = A pointer to a variable that receives the maximum number of bytes per period that can be reserved on the volume.
///                       If no bandwidth has been reserved for this handle, then the value returned is the maximum number of bytes per
///                       period supported for the volume.
///    pDiscardable = <b>TRUE</b> if I/O should be completed with an error if a driver is unable to satisfy an I/O operation before the
///                   period expires. <b>FALSE</b> if the underlying subsystem does not support failing in this manner.
///    lpTransferSize = The minimum size of any individual I/O request that may be issued by the application. All I/O requests should be
///                     multiples of <i>TransferSize</i>. If no bandwidth has been reserved for this handle, then the value returned is
///                     the minimum transfer size supported for this volume.
///    lpNumOutstandingRequests = The number of <i>TransferSize</i> chunks allowed to be outstanding with the operating system.
///Returns:
///    Returns nonzero if successful or zero otherwise. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetFileBandwidthReservation(HANDLE hFile, uint* lpPeriodMilliseconds, uint* lpBytesPerPeriod, 
                                 int* pDiscardable, uint* lpTransferSize, uint* lpNumOutstandingRequests);

///Retrieves information that describes the changes within the specified directory. The function does not report changes
///to the specified directory itself. To track changes on a volume, see change journals.
///Params:
///    hDirectory = A handle to the directory to be monitored. This directory must be opened with the <b>FILE_LIST_DIRECTORY</b>
///                 access right, or an access right such as <b>GENERIC_READ</b> that includes the <b>FILE_LIST_DIRECTORY</b> access
///                 right.
///    lpBuffer = A pointer to the <b>DWORD</b>-aligned formatted buffer in which the read results are to be returned. The
///               structure of this buffer is defined by the FILE_NOTIFY_INFORMATION structure. This buffer is filled either
///               synchronously or asynchronously, depending on how the directory is opened and what value is given to the
///               <i>lpOverlapped</i> parameter. For more information, see the Remarks section.
///    nBufferLength = The size of the buffer that is pointed to by the <i>lpBuffer</i> parameter, in bytes.
///    bWatchSubtree = If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory. If
///                    this parameter is <b>FALSE</b>, the function monitors only the directory specified by the <i>hDirectory</i>
///                    parameter.
///    dwNotifyFilter = The filter criteria that the function checks to determine if the wait operation has completed. This parameter can
///                     be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                     width="40%"><a id="FILE_NOTIFY_CHANGE_FILE_NAME"></a><a id="file_notify_change_file_name"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_FILE_NAME</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Any file name
///                     change in the watched directory or subtree causes a change notification wait operation to return. Changes include
///                     renaming, creating, or deleting a file. </td> </tr> <tr> <td width="40%"><a
///                     id="FILE_NOTIFY_CHANGE_DIR_NAME"></a><a id="file_notify_change_dir_name"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_DIR_NAME</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Any directory-name
///                     change in the watched directory or subtree causes a change notification wait operation to return. Changes include
///                     creating or deleting a directory. </td> </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_ATTRIBUTES"></a><a
///                     id="file_notify_change_attributes"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b></dt> <dt>0x00000004</dt>
///                     </dl> </td> <td width="60%"> Any attribute change in the watched directory or subtree causes a change
///                     notification wait operation to return. </td> </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_SIZE"></a><a
///                     id="file_notify_change_size"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_SIZE</b></dt> <dt>0x00000008</dt> </dl> </td> <td
///                     width="60%"> Any file-size change in the watched directory or subtree causes a change notification wait operation
///                     to return. The operating system detects a change in file size only when the file is written to the disk. For
///                     operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed. </td>
///                     </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_LAST_WRITE"></a><a
///                     id="file_notify_change_last_write"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_LAST_WRITE</b></dt> <dt>0x00000010</dt>
///                     </dl> </td> <td width="60%"> Any change to the last write-time of files in the watched directory or subtree
///                     causes a change notification wait operation to return. The operating system detects a change to the last
///                     write-time only when the file is written to the disk. For operating systems that use extensive caching, detection
///                     occurs only when the cache is sufficiently flushed. </td> </tr> <tr> <td width="40%"><a
///                     id="FILE_NOTIFY_CHANGE_LAST_ACCESS"></a><a id="file_notify_change_last_access"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_LAST_ACCESS</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> Any change to the
///                     last access time of files in the watched directory or subtree causes a change notification wait operation to
///                     return. </td> </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_CREATION"></a><a
///                     id="file_notify_change_creation"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_CREATION</b></dt> <dt>0x00000040</dt> </dl>
///                     </td> <td width="60%"> Any change to the creation time of files in the watched directory or subtree causes a
///                     change notification wait operation to return. </td> </tr> <tr> <td width="40%"><a
///                     id="FILE_NOTIFY_CHANGE_SECURITY"></a><a id="file_notify_change_security"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_SECURITY</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> Any
///                     security-descriptor change in the watched directory or subtree causes a change notification wait operation to
///                     return. </td> </tr> </table>
///    lpBytesReturned = For synchronous calls, this parameter receives the number of bytes transferred into the <i>lpBuffer</i>
///                      parameter. For asynchronous calls, this parameter is undefined. You must use an asynchronous notification
///                      technique to retrieve the number of bytes transferred.
///    lpOverlapped = A pointer to an OVERLAPPED structure that supplies data to be used during asynchronous operation. Otherwise, this
///                   value is <b>NULL</b>. The <b>Offset</b> and <b>OffsetHigh</b> members of this structure are not used.
///    lpCompletionRoutine = A pointer to a completion routine to be called when the operation has been completed or canceled and the calling
///                          thread is in an alertable wait state. For more information about this completion routine, see
///                          FileIOCompletionRoutine.
///Returns:
///    If the function succeeds, the return value is nonzero. For synchronous calls, this means that the operation
///    succeeded. For asynchronous calls, this indicates that the operation was successfully queued. If the function
///    fails, the return value is zero. To get extended error information, call GetLastError. If the network redirector
///    or the target file system does not support this operation, the function fails with <b>ERROR_INVALID_FUNCTION</b>.
///    
@DllImport("KERNEL32")
BOOL ReadDirectoryChangesW(HANDLE hDirectory, char* lpBuffer, uint nBufferLength, BOOL bWatchSubtree, 
                           uint dwNotifyFilter, uint* lpBytesReturned, OVERLAPPED* lpOverlapped, 
                           LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

///Retrieves information that describes the changes within the specified directory, which can include extended
///information if that information type is specified. The function does not report changes to the specified directory
///itself. To track changes on a volume, see change journals.
///Params:
///    hDirectory = A handle to the directory to be monitored. This directory must be opened with the <b>FILE_LIST_DIRECTORY</b>
///                 access right, or an access right such as <b>GENERIC_READ</b> that includes the <b>FILE_LIST_DIRECTORY</b> access
///                 right.
///    lpBuffer = A pointer to the <b>DWORD</b>-aligned formatted buffer in which <b>ReadDirectoryChangesExW</b> should return the
///               read results. The structure of this buffer is defined by the FILE_NOTIFY_EXTENDED_INFORMATION structure if the
///               value of the <i>ReadDirectoryNotifyInformationClass</i> parameter is
///               <b>ReadDirectoryNotifyExtendedInformation</b>, or by the FILE_NOTIFY_INFORMATION structure if
///               <i>ReadDirectoryNotifyInformationClass</i> is <b>ReadDirectoryNotifyInformation</b>. This buffer is filled either
///               synchronously or asynchronously, depending on how the directory is opened and what value is given to the
///               <i>lpOverlapped</i> parameter. For more information, see the Remarks section.
///    nBufferLength = The size of the buffer to which the <i>lpBuffer</i> parameter points, in bytes.
///    bWatchSubtree = If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory. If
///                    this parameter is <b>FALSE</b>, the function monitors only the directory specified by the <i>hDirectory</i>
///                    parameter.
///    dwNotifyFilter = The filter criteria that the function checks to determine if the wait operation has completed. This parameter can
///                     be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                     width="40%"><a id="FILE_NOTIFY_CHANGE_FILE_NAME"></a><a id="file_notify_change_file_name"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_FILE_NAME</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Any file name
///                     change in the watched directory or subtree causes a change notification wait operation to return. Changes include
///                     renaming, creating, or deleting a file. </td> </tr> <tr> <td width="40%"><a
///                     id="FILE_NOTIFY_CHANGE_DIR_NAME"></a><a id="file_notify_change_dir_name"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_DIR_NAME</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Any directory-name
///                     change in the watched directory or subtree causes a change notification wait operation to return. Changes include
///                     creating or deleting a directory. </td> </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_ATTRIBUTES"></a><a
///                     id="file_notify_change_attributes"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b></dt> <dt>0x00000004</dt>
///                     </dl> </td> <td width="60%"> Any attribute change in the watched directory or subtree causes a change
///                     notification wait operation to return. </td> </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_SIZE"></a><a
///                     id="file_notify_change_size"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_SIZE</b></dt> <dt>0x00000008</dt> </dl> </td> <td
///                     width="60%"> Any file-size change in the watched directory or subtree causes a change notification wait operation
///                     to return. The operating system detects a change in file size only when the file is written to the disk. For
///                     operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed. </td>
///                     </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_LAST_WRITE"></a><a
///                     id="file_notify_change_last_write"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_LAST_WRITE</b></dt> <dt>0x00000010</dt>
///                     </dl> </td> <td width="60%"> Any change to the last write-time of files in the watched directory or subtree
///                     causes a change notification wait operation to return. The operating system detects a change to the last
///                     write-time only when the file is written to the disk. For operating systems that use extensive caching, detection
///                     occurs only when the cache is sufficiently flushed. </td> </tr> <tr> <td width="40%"><a
///                     id="FILE_NOTIFY_CHANGE_LAST_ACCESS"></a><a id="file_notify_change_last_access"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_LAST_ACCESS</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> Any change to the
///                     last access time of files in the watched directory or subtree causes a change notification wait operation to
///                     return. </td> </tr> <tr> <td width="40%"><a id="FILE_NOTIFY_CHANGE_CREATION"></a><a
///                     id="file_notify_change_creation"></a><dl> <dt><b>FILE_NOTIFY_CHANGE_CREATION</b></dt> <dt>0x00000040</dt> </dl>
///                     </td> <td width="60%"> Any change to the creation time of files in the watched directory or subtree causes a
///                     change notification wait operation to return. </td> </tr> <tr> <td width="40%"><a
///                     id="FILE_NOTIFY_CHANGE_SECURITY"></a><a id="file_notify_change_security"></a><dl>
///                     <dt><b>FILE_NOTIFY_CHANGE_SECURITY</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> Any
///                     security-descriptor change in the watched directory or subtree causes a change notification wait operation to
///                     return. </td> </tr> </table>
///    lpBytesReturned = For synchronous calls, this parameter receives the number of bytes transferred into the <i>lpBuffer</i>
///                      parameter. For asynchronous calls, this parameter is undefined. You must use an asynchronous notification
///                      technique to retrieve the number of bytes transferred.
///    lpOverlapped = A pointer to an OVERLAPPED structure that supplies data to be used during asynchronous operation. Otherwise, this
///                   value is <b>NULL</b>. The <b>Offset</b> and <b>OffsetHigh</b> members of this structure are not used.
///    lpCompletionRoutine = A pointer to a completion routine to be called when the operation has been completed or canceled and the calling
///                          thread is in an alertable wait state. For more information about this completion routine, see
///                          FileIOCompletionRoutine.
///    ReadDirectoryNotifyInformationClass = The type of information that <b>ReadDirectoryChangesExW</b> should write to the buffer to which the
///                                          <i>lpBuffer</i> parameter points. Specify <b>ReadDirectoryNotifyInformation</b> to indicate that the information
///                                          should consist of FILE_NOTIFY_INFORMATION structures, or <b>ReadDirectoryNotifyExtendedInformation</b>to indicate
///                                          that the information should consist of FILE_NOTIFY_EXTENDED_INFORMATION structures.
///Returns:
///    If the function succeeds, the return value is nonzero. For synchronous calls, this means that the operation
///    succeeded. For asynchronous calls, this indicates that the operation was successfully queued. If the function
///    fails, the return value is zero. To get extended error information, call GetLastError. If the network redirector
///    or the target file system does not support this operation, the function fails with <b>ERROR_INVALID_FUNCTION</b>.
///    
@DllImport("KERNEL32")
BOOL ReadDirectoryChangesExW(HANDLE hDirectory, char* lpBuffer, uint nBufferLength, BOOL bWatchSubtree, 
                             uint dwNotifyFilter, uint* lpBytesReturned, OVERLAPPED* lpOverlapped, 
                             LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, 
                             READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass);

///Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a
///computer.
///Params:
///    lpszVolumeName = A pointer to a buffer that receives a null-terminated string that specifies a volume <b>GUID</b> path for the
///                     first volume that is found.
///    cchBufferLength = The length of the buffer to receive the volume <b>GUID</b> path, in <b>TCHARs</b>.
///Returns:
///    If the function succeeds, the return value is a search handle used in a subsequent call to the FindNextVolume and
///    FindVolumeClose functions. If the function fails to find any volumes, the return value is the
///    <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
FindVolumeHandle FindFirstVolumeA(const(char)* lpszVolumeName, uint cchBufferLength);

///Continues a volume search started by a call to the FindFirstVolume function. <b>FindNextVolume</b> finds one volume
///per call.
///Params:
///    hFindVolume = The volume search handle returned by a previous call to the FindFirstVolume function.
///    lpszVolumeName = A pointer to a string that receives the volume <b>GUID</b> path that is found.
///    cchBufferLength = The length of the buffer that receives the volume <b>GUID</b> path, in <b>TCHARs</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If no matching files can be found, the <b>GetLastError</b>
///    function returns the <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
///    FindVolumeClose function.
///    
@DllImport("KERNEL32")
BOOL FindNextVolumeA(FindVolumeHandle hFindVolume, const(char)* lpszVolumeName, uint cchBufferLength);

///Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin
///scanning the mounted folders on a volume.
///Params:
///    lpszRootPathName = A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.
///    lpszVolumeMountPoint = A pointer to a buffer that receives the name of the first mounted folder that is found.
///    cchBufferLength = The length of the buffer that receives the path to the mounted folder, in <b>TCHAR</b>s.
///Returns:
///    If the function succeeds, the return value is a search handle used in a subsequent call to the
///    FindNextVolumeMountPoint and FindVolumeMountPointClose functions. If the function fails to find a mounted folder
///    on the volume, the return value is the <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information,
///    call GetLastError.
///    
@DllImport("KERNEL32")
FindVolumeMointPointHandle FindFirstVolumeMountPointA(const(char)* lpszRootPathName, 
                                                      const(char)* lpszVolumeMountPoint, uint cchBufferLength);

///Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin
///scanning the mounted folders on a volume.
///Params:
///    lpszRootPathName = A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.
///    lpszVolumeMountPoint = A pointer to a buffer that receives the name of the first mounted folder that is found.
///    cchBufferLength = The length of the buffer that receives the path to the mounted folder, in <b>TCHAR</b>s.
///Returns:
///    If the function succeeds, the return value is a search handle used in a subsequent call to the
///    FindNextVolumeMountPoint and FindVolumeMountPointClose functions. If the function fails to find a mounted folder
///    on the volume, the return value is the <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information,
///    call GetLastError.
///    
@DllImport("KERNEL32")
FindVolumeMointPointHandle FindFirstVolumeMountPointW(const(wchar)* lpszRootPathName, 
                                                      const(wchar)* lpszVolumeMountPoint, uint cchBufferLength);

///Continues a mounted folder search started by a call to the FindFirstVolumeMountPoint function.
///<b>FindNextVolumeMountPoint</b> finds one mounted folder per call.
///Params:
///    hFindVolumeMountPoint = A mounted folder search handle returned by a previous call to the FindFirstVolumeMountPoint function.
///    lpszVolumeMountPoint = A pointer to a buffer that receives the name of the mounted folder that is found.
///    cchBufferLength = The length of the buffer that receives the mounted folder name, in <b>TCHARs</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If no more mounted folders can be found, the <b>GetLastError</b>
///    function returns the <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
///    FindVolumeMountPointClose function.
///    
@DllImport("KERNEL32")
BOOL FindNextVolumeMountPointA(FindVolumeMointPointHandle hFindVolumeMountPoint, const(char)* lpszVolumeMountPoint, 
                               uint cchBufferLength);

///Continues a mounted folder search started by a call to the FindFirstVolumeMountPoint function.
///<b>FindNextVolumeMountPoint</b> finds one mounted folder per call.
///Params:
///    hFindVolumeMountPoint = A mounted folder search handle returned by a previous call to the FindFirstVolumeMountPoint function.
///    lpszVolumeMountPoint = A pointer to a buffer that receives the name of the mounted folder that is found.
///    cchBufferLength = The length of the buffer that receives the mounted folder name, in <b>TCHARs</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If no more mounted folders can be found, the <b>GetLastError</b>
///    function returns the <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
///    FindVolumeMountPointClose function.
///    
@DllImport("KERNEL32")
BOOL FindNextVolumeMountPointW(FindVolumeMointPointHandle hFindVolumeMountPoint, 
                               const(wchar)* lpszVolumeMountPoint, uint cchBufferLength);

///Closes the specified mounted folder search handle. The FindFirstVolumeMountPoint and
///FindNextVolumeMountPointfunctions use this search handle to locate mounted folders on a specified volume.
///Params:
///    hFindVolumeMountPoint = The mounted folder search handle to be closed. This handle must have been previously opened by the
///                            FindFirstVolumeMountPoint function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL FindVolumeMountPointClose(FindVolumeMointPointHandle hFindVolumeMountPoint);

///Associates a volume with a drive letter or a directory on another volume.
///Params:
///    lpszVolumeMountPoint = The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:\") or a
///                           directory on another volume (for example, "Y:\MountX\"). The string must end with a trailing backslash ('\').
///    lpszVolumeName = A volume <b>GUID</b> path for the volume. This string must be of the form "\\\\?\Volume{<i>GUID</i>}\" where
///                     <i>GUID</i> is a <b>GUID</b> that identifies the volume. The "\\\\?\" turns off path parsing and is ignored as
///                     part of the path, as discussed in Naming a Volume.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the <i>lpszVolumeMountPoint</i> parameter contains a path to a
///    mounted folder, GetLastError returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.
///    
@DllImport("KERNEL32")
BOOL SetVolumeMountPointA(const(char)* lpszVolumeMountPoint, const(char)* lpszVolumeName);

///Associates a volume with a drive letter or a directory on another volume.
///Params:
///    lpszVolumeMountPoint = The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:\") or a
///                           directory on another volume (for example, "Y:\MountX\"). The string must end with a trailing backslash ('\').
///    lpszVolumeName = A volume <b>GUID</b> path for the volume. This string must be of the form "\\\\?\\Volume{<i>GUID</i>}\\" where
///                     <i>GUID</i> is a <b>GUID</b> that identifies the volume. The "\\\\?\\" turns off path parsing and is ignored as
///                     part of the path, as discussed in Naming a Volume.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the <i>lpszVolumeMountPoint</i> parameter contains a path to a
///    mounted folder, GetLastError returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.
///    
@DllImport("KERNEL32")
BOOL SetVolumeMountPointW(const(wchar)* lpszVolumeMountPoint, const(wchar)* lpszVolumeName);

///Deletes a drive letter or mounted folder.
///Params:
///    lpszVolumeMountPoint = The drive letter or mounted folder to be deleted. A trailing backslash is required, for example, "X:\" or
///                           "Y:\MountX\".
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DeleteVolumeMountPointA(const(char)* lpszVolumeMountPoint);

///Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point ( drive
///letter, volume <b>GUID</b> path, or mounted folder).
///Params:
///    lpszVolumeMountPoint = A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX\") or a drive letter
///                           (for example, "X:\"). The string must end with a trailing backslash ('\').
///    lpszVolumeName = A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form
///                     "\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than
///                     one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.
///    cchBufferLength = The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest
///                      possible volume <b>GUID</b> path is 50 characters.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetVolumeNameForVolumeMountPointA(const(char)* lpszVolumeMountPoint, const(char)* lpszVolumeName, 
                                       uint cchBufferLength);

///Retrieves the volume mount point where the specified path is mounted.
///Params:
///    lpszFileName = A pointer to the input path string. Both absolute and relative file and directory names, for example "..", are
///                   acceptable in this path. If you specify a relative directory or file name without a volume qualifier,
///                   <b>GetVolumePathName</b> returns the drive letter of the boot volume. If this parameter is an empty string, "",
///                   the function fails but the last error is set to <b>ERROR_SUCCESS</b>.
///    lpszVolumePathName = A pointer to a string that receives the volume mount point for the input path.
///    cchBufferLength = The length of the output buffer, in <b>TCHARs</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetVolumePathNameA(const(char)* lpszFileName, const(char)* lpszVolumePathName, uint cchBufferLength);

///Retrieves a list of drive letters and mounted folder paths for the specified volume.
///Params:
///    lpszVolumeName = A volume <b>GUID</b> path for the volume. A volume <b>GUID</b> path is of the form
///                     "\\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}\".
///    lpszVolumePathNames = A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an array of
///                          null-terminated strings terminated by an additional <b>NULL</b> character. If the buffer is not large enough to
///                          hold the complete list, the buffer holds as much of the list as possible.
///    cchBufferLength = The length of the <i>lpszVolumePathNames</i> buffer, in <b>TCHARs</b>, including all <b>NULL</b> characters.
///    lpcchReturnLength = If the call is successful, this parameter is the number of <b>TCHARs</b> copied to the <i>lpszVolumePathNames</i>
///                        buffer. Otherwise, this parameter is the size of the buffer required to hold the complete list, in <b>TCHARs</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the buffer is not large enough to hold the complete list, the
///    error code is <b>ERROR_MORE_DATA</b> and the <i>lpcchReturnLength</i> parameter receives the required buffer
///    size.
///    
@DllImport("KERNEL32")
BOOL GetVolumePathNamesForVolumeNameA(const(char)* lpszVolumeName, const(char)* lpszVolumePathNames, 
                                      uint cchBufferLength, uint* lpcchReturnLength);

///Retrieves file information for the specified file. For a more basic version of this function for desktop apps, see
///GetFileInformationByHandle. To set file information using a file handle, see SetFileInformationByHandle.
///Params:
///    hFile = A handle to the file that contains the information to be retrieved. This handle should not be a pipe handle.
///    FileInformationClass = A FILE_INFO_BY_HANDLE_CLASS enumeration value that specifies the type of information to be retrieved. For a table
///                           of valid values, see the Remarks section.
///    lpFileInformation = A pointer to the buffer that receives the requested file information. The structure that is returned corresponds
///                        to the class that is specified by <i>FileInformationClass</i>. For a table of valid structure types, see the
///                        Remarks section.
///    dwBufferSize = The size of the <i>lpFileInformation</i> buffer, in bytes.
///Returns:
///    If the function succeeds, the return value is nonzero and file information data is contained in the buffer
///    pointed to by the <i>lpFileInformation</i> parameter. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, 
                                  char* lpFileInformation, uint dwBufferSize);

///Opens the file that matches the specified identifier.
///Params:
///    hVolumeHint = A handle to any file on a volume or share on which the file to be opened is stored.
///    lpFileId = A pointer to a FILE_ID_DESCRIPTOR that identifies the file to open.
///    dwDesiredAccess = The access to the object. Access can be read, write, or both. For more information, see <a
///                      href="/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>. You cannot
///                      request an access mode that conflicts with the sharing mode that is specified in an open request that has an open
///                      handle. If this parameter is zero (0), the application can query file and device attributes without accessing a
///                      device. This is useful for an application to determine the size of a floppy disk drive and the formats it
///                      supports without requiring a floppy in a drive. It can also be used to test for the existence of a file or
///                      directory without opening them for read or write access.
///    dwShareMode = The sharing mode of an object, which can be read, write, both, or none. You cannot request a sharing mode that
///                  conflicts with the access mode that is specified in an open request that has an open handle, because that would
///                  result in the following sharing violation: (<b>ERROR_SHARING_VIOLATION</b>). For more information, see Creating
///                  and Opening Files. If this parameter is zero (0) and <b>OpenFileById</b> succeeds, the object cannot be shared
///                  and cannot be opened again until the handle is closed. For more information, see the Remarks section of this
///                  topic. The sharing options remain in effect until you close the handle to an object. To enable a processes to
///                  share an object while another process has the object open, use a combination of one or more of the following
///                  values to specify the access mode they can request to open the object. <table> <tr> <th>Value</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_SHARE_DELETE"></a><a id="file_share_delete"></a><dl>
///                  <dt><b>FILE_SHARE_DELETE</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Enables subsequent open
///                  operations on an object to request delete access. Otherwise, other processes cannot open the object if they
///                  request delete access. If this flag is not specified, but the object has been opened for delete access, the
///                  function fails. </td> </tr> <tr> <td width="40%"><a id="FILE_SHARE_READ"></a><a id="file_share_read"></a><dl>
///                  <dt><b>FILE_SHARE_READ</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Enables subsequent open
///                  operations on an object to request read access. Otherwise, other processes cannot open the object if they request
///                  read access. If this flag is not specified, but the object has been opened for read access, the function fails.
///                  </td> </tr> <tr> <td width="40%"><a id="FILE_SHARE_WRITE"></a><a id="file_share_write"></a><dl>
///                  <dt><b>FILE_SHARE_WRITE</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Enables subsequent open
///                  operations on an object to request write access. Otherwise, other processes cannot open the object if they
///                  request write access. If this flag is not specified, but the object has been opened for write access or has a
///                  file mapping with write access, the function fails. </td> </tr> </table>
///    lpSecurityAttributes = Reserved.
///    dwFlagsAndAttributes = The file flags. When <b>OpenFileById</b> opens a file, it combines the file flags with existing file attributes,
///                           and ignores any supplied file attributes. This parameter can include any combination of the following flags.
///                           <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a
///                           id="file_flag_backup_semantics"></a><dl> <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt> <dt>0x02000000</dt> </dl>
///                           </td> <td width="60%"> A file is being opened for a backup or restore operation. The system ensures that the
///                           calling process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and
///                           <b>SE_RESTORE_NAME</b> privileges. For more information, see Changing Privileges in a Token. You must set this
///                           flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of a file
///                           handle. For more information, see Directory Handles. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl> <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
///                           <dt>0x20000000</dt> </dl> </td> <td width="60%"> The system opens a file with no system caching. This flag does
///                           not affect hard disk caching. When combined with <b>FILE_FLAG_OVERLAPPED</b>, the flag gives maximum asynchronous
///                           performance, because the I/O does not rely on the synchronous operations of the memory manager. However, some I/O
///                           operations take more time, because data is not being held in the cache. Also, the file metadata may still be
///                           cached. To flush the metadata to disk, use the FlushFileBuffers function. An application must meet certain
///                           requirements when working with files that are opened with <b>FILE_FLAG_NO_BUFFERING</b>: <ul> <li>File access
///                           must begin at byte offsets within a file that are integer multiples of the volume sector size.</li> <li>File
///                           access must be for numbers of bytes that are integer multiples of the volume sector size. For example, if the
///                           sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, or 2048 bytes, but not
///                           of 335, 981, or 7171 bytes.</li> <li>Buffer addresses for read and write operations should be sector aligned,
///                           which means aligned on addresses in memory that are integer multiples of the volume sector size. Depending on the
///                           disk, this requirement may not be enforced.</li> </ul> One way to align buffers on integer multiples of the
///                           volume sector size is to use VirtualAlloc to allocate the buffers. It allocates memory that is aligned on
///                           addresses that are integer multiples of the operating system's memory page size. Because both memory page and
///                           volume sector sizes are powers of 2, this memory is also aligned on addresses that are integer multiples of a
///                           volume sector size. Memory pages are 4-8 KB in size; sectors are 512 bytes (hard disks) or 2048 bytes (CD), and
///                           therefore, volume sectors can never be larger than memory pages. An application can determine a volume sector
///                           size by calling the GetDiskFreeSpace function. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_OPEN_NO_RECALL"></a><a id="file_flag_open_no_recall"></a><dl>
///                           <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The file data is
///                           requested, but it should continue to be located in remote storage. It should not be transported back to local
///                           storage. This flag is for use by remote storage systems. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
///                           <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> When this flag is
///                           used, normal reparse point processing does not occur, and <b>OpenFileById</b> attempts to open the reparse point.
///                           When a file is opened, a file handle is returned, whether or not the filter that controls the reparse point is
///                           operational. This flag cannot be used with the <b>CREATE_ALWAYS</b> flag. If the file is not a reparse point,
///                           then this flag is ignored. </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a
///                           id="file_flag_overlapped"></a><dl> <dt><b>FILE_FLAG_OVERLAPPED</b></dt> <dt>0x40000000</dt> </dl> </td> <td
///                           width="60%"> The file is being opened or created for asynchronous I/O. When the operation is complete, the event
///                           specified to the call in the OVERLAPPED structure is set to the signaled state. Operations that take a
///                           significant amount of time to process return <b>ERROR_IO_PENDING</b>. If this flag is specified, the file can be
///                           used for simultaneous read and write operations. The system does not maintain the file pointer, therefore you
///                           must pass the file position to the read and write functions in the OVERLAPPED structure or update the file
///                           pointer. If this flag is not specified, then I/O operations are serialized, even if the calls to the read and
///                           write functions specify an OVERLAPPED structure. </td> </tr> <tr> <td width="40%"><a
///                           id="FILE_FLAG_RANDOM_ACCESS"></a><a id="file_flag_random_access"></a><dl> <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt>
///                           <dt>0x10000000</dt> </dl> </td> <td width="60%"> A file is accessed randomly. The system can use this as a hint
///                           to optimize file caching. </td> </tr> <tr> <td width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a
///                           id="file_flag_sequential_scan"></a><dl> <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt> <dt>0x08000000</dt> </dl> </td>
///                           <td width="60%"> A file is accessed sequentially from beginning to end. The system can use this as a hint to
///                           optimize file caching. If an application moves the file pointer for random access, optimum caching may not occur.
///                           However, correct operation is still guaranteed. Specifying this flag can increase performance for applications
///                           that read large files using sequential access. Performance gains can be even more noticeable for applications
///                           that read large files mostly sequentially, but occasionally skip over small ranges of bytes. </td> </tr> <tr> <td
///                           width="40%"><a id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl>
///                           <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt> <dt>0x80000000</dt> </dl> </td> <td width="60%"> The system writes
///                           through any intermediate cache and goes directly to disk. If <b>FILE_FLAG_NO_BUFFERING</b> is not also specified,
///                           so that system caching is in effect, then the data is written to the system cache, but is flushed to disk without
///                           delay. If <b>FILE_FLAG_NO_BUFFERING</b> is also specified, so that system caching is not in effect, then the data
///                           is immediately flushed to disk without going through the system cache. The operating system also requests a
///                           write-through the hard disk cache to persistent media. However, not all hardware supports this write-through
///                           capability. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is an open handle to a specified file. If the function fails, the
///    return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE OpenFileById(HANDLE hVolumeHint, FILE_ID_DESCRIPTOR* lpFileId, uint dwDesiredAccess, uint dwShareMode, 
                    SECURITY_ATTRIBUTES* lpSecurityAttributes, uint dwFlagsAndAttributes);

///Creates a symbolic link. To perform this operation as a transacted operation, use the CreateSymbolicLinkTransacted
///function.
///Params:
///    lpSymlinkFileName = The symbolic link to be created. This parameter may include the path. In the ANSI version of this function, the
///                        name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode
///                        version of the function and prepend "\\?\" to the path. For more information, see Naming a File. <div
///                        class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode version of this function
///                        (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\".
///                        See the "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div>
///                        </div>
///    lpTargetFileName = The name of the target for the symbolic link to be created. If <i>lpTargetFileName</i> has a device name
///                       associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.
///                       This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                       characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                       "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting with Windows
///                       10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove
///                       the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of
///                       Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    dwFlags = Indicates whether the link target, <i>lpTargetFileName</i>, is a directory. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x0</dt> </dl> </td> <td width="60%"> The link target is a
///              file. </td> </tr> <tr> <td width="40%"><a id="SYMBOLIC_LINK_FLAG_DIRECTORY"></a><a
///              id="symbolic_link_flag_directory"></a><dl> <dt><b>SYMBOLIC_LINK_FLAG_DIRECTORY</b></dt> <dt>0x1</dt> </dl> </td>
///              <td width="60%"> The link target is a directory. </td> </tr> <tr> <td width="40%"><a
///              id="SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE"></a><a
///              id="symbolic_link_flag_allow_unprivileged_create"></a><dl>
///              <dt><b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b></dt> <dt>0x2</dt> </dl> </td> <td width="60%"> Specify
///              this flag to allow creation of symbolic links when the process is not elevated. Developer Mode must first be
///              enabled on the machine before this option will function. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ubyte CreateSymbolicLinkA(const(char)* lpSymlinkFileName, const(char)* lpTargetFileName, uint dwFlags);

///Creates a symbolic link. To perform this operation as a transacted operation, use the CreateSymbolicLinkTransacted
///function.
///Params:
///    lpSymlinkFileName = The symbolic link to be created. This parameter may include the path. In the ANSI version of this function, the
///                        name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode
///                        version of the function and prepend "\\?\" to the path. For more information, see Naming a File. <div
///                        class="alert"><b>Tip</b> Starting with Windows 10, version 1607, for the unicode version of this function
///                        (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\".
///                        See the "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.</div> <div>
///                        </div>
///    lpTargetFileName = The name of the target for the symbolic link to be created. If <i>lpTargetFileName</i> has a device name
///                       associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.
///                       This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b>
///                       characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
///                       "\\?\" to the path. For more information, see Naming a File. <div class="alert"><b>Tip</b> Starting with Windows
///                       10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove
///                       the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of
///                       Naming Files, Paths, and Namespaces for details.</div> <div> </div>
///    dwFlags = Indicates whether the link target, <i>lpTargetFileName</i>, is a directory. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x0</dt> </dl> </td> <td width="60%"> The link target is a
///              file. </td> </tr> <tr> <td width="40%"><a id="SYMBOLIC_LINK_FLAG_DIRECTORY"></a><a
///              id="symbolic_link_flag_directory"></a><dl> <dt><b>SYMBOLIC_LINK_FLAG_DIRECTORY</b></dt> <dt>0x1</dt> </dl> </td>
///              <td width="60%"> The link target is a directory. </td> </tr> <tr> <td width="40%"><a
///              id="SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE"></a><a
///              id="symbolic_link_flag_allow_unprivileged_create"></a><dl>
///              <dt><b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b></dt> <dt>0x2</dt> </dl> </td> <td width="60%"> Specify
///              this flag to allow creation of symbolic links when the process is not elevated. Developer Mode must first be
///              enabled on the machine before this option will function. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ubyte CreateSymbolicLinkW(const(wchar)* lpSymlinkFileName, const(wchar)* lpTargetFileName, uint dwFlags);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Creates a symbolic link
///as a transacted operation.
///Params:
///    lpSymlinkFileName = The symbolic link to be created.
///    lpTargetFileName = The name of the target for the symbolic link to be created. If <i>lpTargetFileName</i> has a device name
///                       associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.
///    dwFlags = Indicates whether the link target, <i>lpTargetFileName</i>, is a directory. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x0</dt> </dl> </td> <td width="60%"> The link target is a
///              file. </td> </tr> <tr> <td width="40%"><a id="SYMBOLIC_LINK_FLAG_DIRECTORY"></a><a
///              id="symbolic_link_flag_directory"></a><dl> <dt><b>SYMBOLIC_LINK_FLAG_DIRECTORY</b></dt> <dt>0x1</dt> </dl> </td>
///              <td width="60%"> The link target is a directory. </td> </tr> </table>
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ubyte CreateSymbolicLinkTransactedA(const(char)* lpSymlinkFileName, const(char)* lpTargetFileName, uint dwFlags, 
                                    HANDLE hTransaction);

///<p class="CCE_Message">[Microsoft strongly recommends developers utilize alternative means to achieve your
///application’s needs. Many scenarios that TxF was developed for can be achieved through simpler and more readily
///available techniques. Furthermore, TxF may not be available in future versions of Microsoft Windows. For more
///information, and alternatives to TxF, please see Alternatives to using Transactional NTFS.] Creates a symbolic link
///as a transacted operation.
///Params:
///    lpSymlinkFileName = The symbolic link to be created.
///    lpTargetFileName = The name of the target for the symbolic link to be created. If <i>lpTargetFileName</i> has a device name
///                       associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.
///    dwFlags = Indicates whether the link target, <i>lpTargetFileName</i>, is a directory. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x0</dt> </dl> </td> <td width="60%"> The link target is a
///              file. </td> </tr> <tr> <td width="40%"><a id="SYMBOLIC_LINK_FLAG_DIRECTORY"></a><a
///              id="symbolic_link_flag_directory"></a><dl> <dt><b>SYMBOLIC_LINK_FLAG_DIRECTORY</b></dt> <dt>0x1</dt> </dl> </td>
///              <td width="60%"> The link target is a directory. </td> </tr> </table>
///    hTransaction = A handle to the transaction. This handle is returned by the CreateTransaction function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ubyte CreateSymbolicLinkTransactedW(const(wchar)* lpSymlinkFileName, const(wchar)* lpTargetFileName, uint dwFlags, 
                                    HANDLE hTransaction);


// Interfaces

///Represents a single user quota entry in the volume quota information file. Through this interface, you can query and
///modify user-specific quota information on an NTFS file system volume. This interface is instantiated by using
///IEnumDiskQuotaUsers, IDiskQuotaControl::FindUserSid, IDiskQuotaControl::FindUserName, IDiskQuotaControl::AddUserSid,
///or IDiskQuotaControl::AddUserName.
@GUID("7988B574-EC89-11CF-9C00-00AA00A14F56")
interface IDiskQuotaUser : IUnknown
{
    ///Retrieves a unique identifier (ID) number for the DiskQuotaUser object. This ID is unique only within the
    ///process. It can be used to identify a user object in a set of user objects if the programming language you are
    ///using does not support pointers.
    ///Params:
    ///    pulID = The name strings associated with the disk quota user.
    ///Returns:
    ///    This method returns <b>S_OK</b>.
    ///    
    HRESULT GetID(uint* pulID);
    ///Retrieves the name strings associated with a disk quota user.
    ///Params:
    ///    pszAccountContainer = The name of the user's account container. This value can be <b>NULL</b>. For accounts without directory
    ///                          service information, this string is simply the domain name. For accounts with directory service information
    ///                          available, this string is a canonical name with the terminating object name removed.
    ///    cchAccountContainer = The size of the account container buffer, in characters. Ignored if <i>pszAccountContainer</i> is
    ///                          <b>NULL</b>.
    ///    pszLogonName = A pointer to the buffer to receive the name the user specified to log on the computer. This value can be
    ///                   <b>NULL</b>. The format of the name returned depends on whether directory service information is available.
    ///    cchLogonName = The size of the logon name buffer, in characters. Ignored if <i>pszLogonName</i> is <b>NULL</b>.
    ///    pszDisplayName = A pointer to the buffer to receive the display name for the quota user. This value can be <b>NULL</b>. If the
    ///                     information is not available, the string returned is of zero length.
    ///    cchDisplayName = The size of the display-name buffer, in characters. Ignored if <i>pszDisplayName</i> is <b>NULL</b>.
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>ERROR_LOCK_FAILED</b></dt> </dl> </td> <td width="60%"> Failure to obtain an
    ///    exclusive lock. </td> </tr> </table>
    ///    
    HRESULT GetName(const(wchar)* pszAccountContainer, uint cchAccountContainer, const(wchar)* pszLogonName, 
                    uint cchLogonName, const(wchar)* pszDisplayName, uint cchDisplayName);
    ///Retrieves the length of the user's security identifier (SID), in bytes. Use the return value to determine the
    ///size of the destination buffer you pass to IDiskQuotaUser::GetSid.
    ///Params:
    ///    pdwLength = The SID length, in bytes.
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pdwLength</i> parameter is
    ///    <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_SID</b></dt> </dl> </td> <td
    ///    width="60%"> The SID for the user is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_LOCK_FAILED</b></dt> </dl> </td> <td width="60%"> Failure to obtain an exclusive lock. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetSidLength(uint* pdwLength);
    ///Retrieves the user's security identifier (SID).
    ///Params:
    ///    pbSidBuffer = The SID.
    ///    cbSidBuffer = The size of the buffer, in bytes. Use the IDiskQuotaUser::GetSidLength method to obtain the required size for
    ///                  the buffer.
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pbSidBuffer</i> parameter
    ///    is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_SID</b></dt> </dl> </td> <td
    ///    width="60%"> The SID for the user is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt> </dl> </td> <td width="60%"> Insufficient destination buffer size.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_LOCK_FAILED</b></dt> </dl> </td> <td width="60%"> Failure
    ///    to obtain an exclusive lock. </td> </tr> </table>
    ///    
    HRESULT GetSid(ubyte* pbSidBuffer, uint cbSidBuffer);
    ///Retrieves the user's warning threshold value on the volume. The threshold is an arbitrary value set by the
    ///volume's quota administrator. You can use it to identify users who are approaching their hard quota limit.
    ///Params:
    ///    pllThreshold = The warning threshold value.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_LOCK_FAILED</b></dt> </dl> </td> <td width="60%"> Failure to obtain an exclusive lock. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>pllThreshold</i> parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An unexpected file system error
    ///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT GetQuotaThreshold(long* pllThreshold);
    ///Retrieves the user's warning threshold for the volume. This threshold is expressed as a text string, for example
    ///"10.5 MB". If the user's threshold is unlimited, the string returned is "No Limit" (localized). If the
    ///destination buffer is too small, the string is truncated to fit the buffer.
    ///Params:
    ///    pszText = The text string.
    ///    cchText = The size of the destination buffer, in characters.
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The caller has
    ///    insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_LOCK_FAILED</b></dt> </dl>
    ///    </td> <td width="60%"> Failure to obtain an exclusive lock. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pszText</i> parameter is <b>NULL</b>. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient
    ///    memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected file system error occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt>
    ///    </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT GetQuotaThresholdText(const(wchar)* pszText, uint cchText);
    ///Retrieves the user's quota limit value on the volume. The limit is set as the maximum amount of disk space
    ///available to the volume user.
    ///Params:
    ///    pllLimit = The limit value. If this value is –1, the user has an unlimited quota.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_LOCK_FAILED</b></dt> </dl> </td> <td width="60%"> Failure to obtain an exclusive lock. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>pllLimit</i> parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An unexpected file system error
    ///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT GetQuotaLimit(long* pllLimit);
    ///Retrieves the user's quota limit for the volume. This limit is expressed as a text string, for example "10.5 MB".
    ///If the user has no quota limit, the string returned is "No Limit" (localized). If the destination buffer is too
    ///small, the string is truncated to fit the buffer.
    ///Params:
    ///    pszText = The text string.
    ///    cchText = The size of the buffer, in characters.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_LOCK_FAILED</b></dt> </dl> </td> <td width="60%"> Failure to obtain an exclusive lock. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pszText</i>
    ///    parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td>
    ///    <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected file system error occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetQuotaLimitText(const(wchar)* pszText, uint cchText);
    ///Retrieves the user's quota used value on the volume. This is the amount of information stored on the volume by
    ///the user. This is the amount of uncompressed information. Therefore, the use of NTFS file system compression does
    ///not affect this value.
    ///Params:
    ///    pllUsed = The quota used value.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_LOCK_FAILED</b></dt> </dl> </td> <td width="60%"> Failure to obtain an exclusive lock. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pllUsed</i>
    ///    parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td>
    ///    <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected file system error occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetQuotaUsed(long* pllUsed);
    ///Retrieves the user's quota used value for the volume. This value is expressed as a text string, for example "10.5
    ///MB". If the destination buffer is too small, the string is truncated to fit the buffer.
    ///Params:
    ///    pszText = The text string.
    ///    cchText = The size of the buffer, in bytes.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_LOCK_FAILED</b></dt> </dl> </td> <td width="60%"> Failure to obtain an exclusive lock. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pszText</i>
    ///    parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td>
    ///    <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected file system error occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetQuotaUsedText(const(wchar)* pszText, uint cchText);
    ///Retrieves the values for the user's warning threshold, hard quota limit, and quota used.
    ///Params:
    ///    pbQuotaInfo = A pointer to the [DISKQUOTA_USER_INFORMATION](./ns-dskquota-diskquota_user_information.md) structure to
    ///                  receive the quota information.
    ///    cbQuotaInfo = The size of the quota information structure, in bytes.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_LOCK_FAILED</b></dt> </dl> </td> <td width="60%"> Failure to obtain an exclusive lock. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>pQuotaInfo</i> parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An unexpected file system error
    ///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT GetQuotaInformation(void* pbQuotaInfo, uint cbQuotaInfo);
    ///Sets the user's warning threshold value on the volume. The threshold is an arbitrary value set by the volume's
    ///quota administrator. You can use it to identify users who are approaching their hard quota limit.
    ///Params:
    ///    llThreshold = The warning threshold value.
    ///    fWriteThrough = If this value is <b>TRUE</b>, the value is written immediately to the volume's quota file. Otherwise, the
    ///                    value is written only to the quota user object's local memory. This value should typically be set to
    ///                    <b>TRUE</b>. Set it to <b>FALSE</b> when using the IDiskQuotaUserBatch interface to modify multiple user
    ///                    quota entries at the same time.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_LOCK_FAILED</b></dt> </dl> </td> <td width="60%"> Failure to obtain an exclusive lock. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An unexpected file
    ///    system error occurred. </td> </tr> </table>
    ///    
    HRESULT SetQuotaThreshold(long llThreshold, BOOL fWriteThrough);
    ///Sets the user's quota limit value on the volume. The limit is set as the maximum amount of disk space available
    ///to the volume user.
    ///Params:
    ///    llLimit = The default quota limit, in bytes. If this value is -1, the user has an unlimited quota.
    ///    fWriteThrough = If this value is <b>TRUE</b>, the value is written immediately to the volume's quota file. Otherwise, the
    ///                    value is written only to the quota user object's local memory. This value should typically be set to
    ///                    <b>TRUE</b>. Set it to <b>FALSE</b> when using the IDiskQuotaUserBatch interface to modify multiple user
    ///                    quota entries at once.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_LOCK_FAILED</b></dt> </dl> </td> <td width="60%"> Failure to obtain an exclusive lock. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An unexpected file
    ///    system error occurred. </td> </tr> </table>
    ///    
    HRESULT SetQuotaLimit(long llLimit, BOOL fWriteThrough);
    ///Invalidates the quota information stored in the quota user object. The next time information is requested, it is
    ///refreshed from disk.
    ///Returns:
    ///    This method returns <b>S_OK</b>.
    ///    
    HRESULT Invalidate();
    ///Retrieves the status of the user object's account. User information is identified in the quota system by user
    ///security identifier (SID). This SID must resolve to a user account for the user's account name information to be
    ///retrieved.
    ///Params:
    ///    pdwStatus = The user's account status. The status value can be one of the following. <table> <tr> <th>Value</th>
    ///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DISKQUOTA_USER_ACCOUNT_RESOLVED"></a><a
    ///                id="diskquota_user_account_resolved"></a><dl> <dt><b>DISKQUOTA_USER_ACCOUNT_RESOLVED</b></dt> <dt>0</dt>
    ///                </dl> </td> <td width="60%"> The SID was resolved to a user account. Names are available through
    ///                IDiskQuotaUser::GetName. </td> </tr> <tr> <td width="40%"><a id="DISKQUOTA_USER_ABLE"></a><a
    ///                id="diskquota_user_able"></a><dl> <dt><b>DISKQUOTA_USER_ABLE</b></dt> <dt>1</dt> </dl> </td> <td width="60%">
    ///                The user account is unavailable at this time. The network domain controller may not be available. Name
    ///                information is not available. </td> </tr> <tr> <td width="40%"><a id="DISKQUOTA_USER_ACCOUNT_DELETED"></a><a
    ///                id="diskquota_user_account_deleted"></a><dl> <dt><b>DISKQUOTA_USER_ACCOUNT_DELETED</b></dt> <dt>2</dt> </dl>
    ///                </td> <td width="60%"> The user account was deleted from the domain. Name information is not available. </td>
    ///                </tr> <tr> <td width="40%"><a id="DISKQUOTA_USER_ACCOUNT_INVALID"></a><a
    ///                id="diskquota_user_account_invalid"></a><dl> <dt><b>DISKQUOTA_USER_ACCOUNT_INVALID</b></dt> <dt>3</dt> </dl>
    ///                </td> <td width="60%"> The user account is invalid. Name information is not available. </td> </tr> <tr> <td
    ///                width="40%"><a id="DISKQUOTA_USER_ACCOUNT_UNKNOWN"></a><a id="diskquota_user_account_unknown"></a><dl>
    ///                <dt><b>DISKQUOTA_USER_ACCOUNT_UNKNOWN</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> The user account is
    ///                unknown. Name information is not available. </td> </tr> <tr> <td width="40%"><a
    ///                id="DISKQUOTA_USER_ACCOUNT_UNRESOLVED"></a><a id="diskquota_user_account_unresolved"></a><dl>
    ///                <dt><b>DISKQUOTA_USER_ACCOUNT_UNRESOLVED</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> The SID has not
    ///                been resolved to a user account. </td> </tr> </table>
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pdwStatus</i> parameter is
    ///    <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT GetAccountStatus(uint* pdwStatus);
}

///Enumerates user quota entries on the volume. This interface is instantiated by using the
///IDiskQuotaControl::CreateEnumUsers method.
@GUID("7988B577-EC89-11CF-9C00-00AA00A14F56")
interface IEnumDiskQuotaUsers : IUnknown
{
    ///Retrieves the specified number of user quota entries that are next in the enumeration sequence. If there are
    ///fewer than the requested number of elements left in the sequence, it retrieves the remaining elements.
    ///Params:
    ///    cUsers = The number of elements being requested.
    ///    rgUsers = An array of size <i>cUsers</i> or larger.
    ///    pcUsersFetched = On input, the number of elements in <i>rgUsers</i>, on input. On output, the number of elements actually
    ///                     retrieved. The caller can pass in <b>NULL</b> if <i>cUsers</i> is one and the number of elements retrieved is
    ///                     of no interest.
    ///Returns:
    ///    The return value is <b>S_OK</b> if the number of elements supplied is <i>cUsers</i>; otherwise, the return
    ///    value is <b>S_FALSE</b>.
    ///    
    HRESULT Next(uint cUsers, IDiskQuotaUser* rgUsers, uint* pcUsersFetched);
    ///Skips over the specified number of user quota entries that are next in the enumeration sequence.
    ///Params:
    ///    cUsers = The number of elements to be skipped.
    ///Returns:
    ///    The return value is <b>S_OK</b> if the number of elements skipped is <i>cUsers</i>; otherwise, the return
    ///    value is <b>S_FALSE</b>.
    ///    
    HRESULT Skip(uint cUsers);
    ///Resets the enumeration sequence to the beginning of the set of user quota entries.
    ///Returns:
    ///    The return value is <b>S_OK</b>.
    ///    
    HRESULT Reset();
    ///Creates another enumerator of user quota entries that contains the same enumeration state as the current one.
    ///Using this method, a client can record a particular point in the enumeration sequence, and then return to that
    ///point at a later time. The new enumerator supports the same interface as the original one.
    ///Params:
    ///    ppEnum = A pointer to the IEnumDiskQuotaUsers interface pointer. If the method is unsuccessful, the value of this
    ///             variable is undefined.
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i>
    ///    parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td>
    ///    <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt>
    ///    </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumDiskQuotaUsers* ppEnum);
}

///Adds multiple quota user objects to a container that is then submitted for update in a single call. This reduces the
///number of calls to the underlying file system, improving update efficiency when a large number of user objects must
///be updated. This interface is instantiated by using the IDiskQuotaControl::CreateUserBatch method.
@GUID("7988B576-EC89-11CF-9C00-00AA00A14F56")
interface IDiskQuotaUserBatch : IUnknown
{
    ///Adds an IDiskQuotaUser pointer to the batch list. This method calls <b>AddRef</b> on the <i>pUser</i> interface
    ///pointer. Release is automatically called on each contained IDiskQuotaUser interface pointer when the batch object
    ///is destroyed. When setting values on a quota user object in preparation for batch processing, specify
    ///<b>FALSE</b> for the <i>fWriteThrough</i> parameter in the IDiskQuotaUser::SetQuotaLimit and
    ///IDiskQuotaUser::SetQuotaThreshold methods. This stores the values in memory without writing to disk. To write the
    ///changes to disk, call the IDiskQuotaUserBatch::FlushToDisk method.
    ///Params:
    ///    pUser = A pointer to the quota user object's IDiskQuotaUser interface.
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pUser</i> parameter is
    ///    <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT Add(IDiskQuotaUser pUser);
    ///Removes an IDiskQuotaUser pointer from the batch list.
    ///Params:
    ///    pUser = A pointer to the quota user object's IDiskQuotaUser interface.
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Quota user object not found in batch.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>pUser</i> parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt>
    ///    </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT Remove(IDiskQuotaUser pUser);
    ///Removes all IDiskQuotaUser pointers from the batch list.
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected exception occurred.
    ///    </td> </tr> </table>
    ///    
    HRESULT RemoveAll();
    ///Writes user object changes to disk in a single call to the underlying file system.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An unexpected file system error
    ///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT FlushToDisk();
}

///Controls the disk quota facilities of a single NTFS file system volume. The client can query and set volume-specific
///quota attributes through <b>IDiskQuotaControl</b>. The client can also enumerate all per-user quota entries on the
///volume. A client instantiates this interface by calling the CoCreateInstance function using the class identifier
///CLSID_DiskQuotaControl.
@GUID("7988B572-EC89-11CF-9C00-00AA00A14F56")
interface IDiskQuotaControl : IConnectionPointContainer
{
    ///Initializes a new <b>DiskQuotaControl</b> object by opening the NTFS file system volume with the requested access
    ///rights. The return value indicates whether the volume supports NTFS file system disk quotas and whether the
    ///caller has sufficient access rights.
    ///Params:
    ///    pszPath = The path to the volume root, such as C:\ or &
    ///    bReadWrite = If this value is <b>TRUE</b>, the volume is opened in read/write mode. If this value is <b>FALSE</b>, the
    ///                 volume is opened in read-only mode. To write data to the quota file, you must specify <b>TRUE</b>, and the
    ///                 call to this method must return successfully.
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The caller has
    ///    insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_PATHNAME</b></dt> </dl>
    ///    </td> <td width="60%"> The requested path name is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The requested file or object is not found.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The
    ///    controller object has already been initialized. Multiple initialization is not allowed. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>ERROR_INVALID_NAME</b></dt> </dl> </td> <td width="60%"> The requested file path is
    ///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOTSUPPORTED</b></dt> </dl> </td> <td
    ///    width="60%"> The file system does not support quotas. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The requested file path is not found. </td>
    ///    </tr> </table>
    ///    
    HRESULT Initialize(const(wchar)* pszPath, BOOL bReadWrite);
    ///Sets the state of the quota system.
    ///Params:
    ///    dwState = State to be applied to the volume. Use the following macros to set the proper bits. <table> <tr>
    ///              <th>Macro</th> <th>Enable</th> <th>Track</th> <th>Enforce</th> </tr> <tr> <td>DISKQUOTA_SET_DISABLED</td>
    ///              <td>No</td> <td>No</td> <td>No</td> </tr> <tr> <td>DISKQUOTA_SET_TRACKED</td> <td>Yes</td> <td>Yes</td>
    ///              <td>No</td> </tr> <tr> <td>DISKQUOTA_SET_ENFORCED</td> <td>Yes</td> <td>Yes</td> <td>Yes</td> </tr> </table>
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The <b>DiskQuotaControl</b> object is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    The <i>dwState</i> parameter is incorrect. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An unexpected file system error
    ///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT SetQuotaState(uint dwState);
    ///Retrieves a set of flags describing the state of the quota system.
    ///Params:
    ///    pdwState = The quota state flags. This parameter can include one or more of the following flags. <table> <tr>
    ///               <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DISKQUOTA_FILESTATE_INCOMPLETE"></a><a
    ///               id="diskquota_filestate_incomplete"></a><dl> <dt><b>DISKQUOTA_FILESTATE_INCOMPLETE</b></dt>
    ///               <dt>0x00000100</dt> </dl> </td> <td width="60%"> The volume's quota information is out of date. Quotas are
    ///               probably disabled. </td> </tr> <tr> <td width="40%"><a id="DISKQUOTA_FILESTATE_REBUILDING"></a><a
    ///               id="diskquota_filestate_rebuilding"></a><dl> <dt><b>DISKQUOTA_FILESTATE_REBUILDING</b></dt>
    ///               <dt>0x00000200</dt> </dl> </td> <td width="60%"> The volume is rebuilding its quota information. </td> </tr>
    ///               <tr> <td width="40%"><a id="DISKQUOTA_STATE_DISABLED"></a><a id="diskquota_state_disabled"></a><dl>
    ///               <dt><b>DISKQUOTA_STATE_DISABLED</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> Quotas are not
    ///               enabled on the volume. </td> </tr> <tr> <td width="40%"><a id="DISKQUOTA_STATE_ENFORCE"></a><a
    ///               id="diskquota_state_enforce"></a><dl> <dt><b>DISKQUOTA_STATE_ENFORCE</b></dt> <dt>0x00000002</dt> </dl> </td>
    ///               <td width="60%"> Quotas are enabled and the limit value is enforced. Users cannot exceed their quota limit.
    ///               </td> </tr> <tr> <td width="40%"><a id="DISKQUOTA_STATE_TRACK"></a><a id="diskquota_state_track"></a><dl>
    ///               <dt><b>DISKQUOTA_STATE_TRACK</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Quotas are enabled but
    ///               the limit value is not being enforced. Users may exceed their quota limit. </td> </tr> </table>
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The <b>DiskQuotaControl</b> object is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    The <i>pdwState</i> parameter is incorrect. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An unexpected file system error
    ///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT GetQuotaState(uint* pdwState);
    ///Controls the logging of user-related quota events on the volume. Logging makes an entry in the volume server
    ///system's event log.
    ///Params:
    ///    dwFlags = The log flags to be applied to the volume. Use the following macros to set the proper bits in the
    ///              <i>dwFlags</i> parameter. <table> <tr> <th>Macro</th> <th>Description</th> </tr> <tr>
    ///              <td>DISKQUOTA_SET_LOG_USER_LIMIT</td> <td>Turn on/off logging of user quota limit violations. If set, an
    ///              event log entry will be created when the user exceeds his assigned hard quota limit.</td> </tr> <tr>
    ///              <td>DISKQUOTA_SET_LOG_USER_THRESHOLD</td> <td>Turn on/off logging of user warning threshold violations. If
    ///              set, an event log entry will be created when the user exceeds his assigned warning threshold.</td> </tr>
    ///              </table>
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The <b>DiskQuotaControl</b> object is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> An unexpected file system error occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetQuotaLogFlags(uint dwFlags);
    ///Retrieves the flags that control the logging of user-related quota events on the volume. Logging makes an entry
    ///in the volume server's event log.
    ///Params:
    ///    pdwFlags = The volume's quota logging flags. Use the following macros to retrieve the contents of the flag value.
    ///               <table> <tr> <th>Macro</th> <th>Description</th> </tr> <tr> <td>DISKQUOTA_IS_LOGGED_USER_LIMIT</td> <td>If
    ///               set, an event log entry will be created when the user exceeds his assigned hard quota limit.</td> </tr> <tr>
    ///               <td>DISKQUOTA_IS_LOGGED_USER_THRESHOLD</td> <td>If set, an event log entry will be created when the user
    ///               exceeds his assigned warning threshold.</td> </tr> </table>
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The <b>DiskQuotaControl</b> object is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    The <i>pdwFlags</i> parameter is incorrect. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An unexpected file system error
    ///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT GetQuotaLogFlags(uint* pdwFlags);
    ///Modifies the default warning threshold. This threshold is applied automatically to new users of the volume.
    ///Params:
    ///    llThreshold = The default warning threshold value, in bytes.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The <b>DiskQuotaControl</b> object is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> An unexpected file system error occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetDefaultQuotaThreshold(long llThreshold);
    ///Retrieves the default quota warning threshold for the volume. This threshold is applied automatically to new
    ///users of the volume.
    ///Params:
    ///    pllThreshold = The default warning threshold value, in bytes.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The <b>DiskQuotaControl</b> object is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    The <i>pllThreshold</i> parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An unexpected file system error
    ///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT GetDefaultQuotaThreshold(long* pllThreshold);
    ///Retrieves the default warning threshold for the volume. This threshold is expressed as a text string, for example
    ///"10.5 MB". If the volume does not have a threshold, the string returned is "No Limit" (localized). If the buffer
    ///is too small, the string is truncated to fit the buffer.
    ///Params:
    ///    pszText = The text string.
    ///    cchText = The size of the buffer, in characters.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The <b>DiskQuotaControl</b> object is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    The <i>pszText</i> parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An unexpected file system error
    ///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT GetDefaultQuotaThresholdText(const(wchar)* pszText, uint cchText);
    ///Modifies the default quota limit. This limit is applied automatically to new users of the volume.
    ///Params:
    ///    llLimit = The default quota limit, in bytes. If this value is -1, the user has an unlimited quota.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The <b>DiskQuotaControl</b> object is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> An unexpected file system error occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetDefaultQuotaLimit(long llLimit);
    ///Retrieves the default quota limit for the volume. This limit is applied automatically to new users of the volume.
    ///Params:
    ///    pllLimit = A pointer to the variable to receive the quota limit. If this value is -1, the user has an unlimited quota.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The <b>DiskQuotaControl</b> object is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    The <i>pllLimit</i> parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An unexpected file system error
    ///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT GetDefaultQuotaLimit(long* pllLimit);
    ///Retrieves the default quota limit for the volume. The limit is expressed as a text string; for example, 10.5 MB.
    ///This limit is applied automatically to new users of the volume.
    ///Params:
    ///    pszText = The text string. If the volume has no limit, the string returned is "No Limit" (localized). If the buffer is
    ///              too small, the string is truncated to fit the buffer.
    ///    cchText = The size of the buffer, in characters.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The <b>DiskQuotaControl</b> object is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    The <i>pszText</i> parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An unexpected file system error
    ///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT GetDefaultQuotaLimitText(const(wchar)* pszText, uint cchText);
    ///Adds a new quota entry on the volume for the specified user. The user is identified by security identifier (SID).
    ///Params:
    ///    pUserSid = The user's SID.
    ///    fNameResolution = Indicates how the user account information is to be obtained. The volume's quota information identifies users
    ///                      by SID. The user account information (such as domain name, account name, and full name) must be obtained from
    ///                      the network domain controller, or the local computer if it is not on a network. This parameter can be one of
    ///                      the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                      id="DISKQUOTA_USERNAME_RESOLVE_ASYNC"></a><a id="diskquota_username_resolve_async"></a><dl>
    ///                      <dt><b>DISKQUOTA_USERNAME_RESOLVE_ASYNC</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Resolve user account
    ///                      information asynchronously. <b>AddUserSid</b> returns immediately. The caller must implement the
    ///                      IDiskQuotaEvents interface to receive notification when the information is available. If the information was
    ///                      cached during a previous request, notification occurs as soon as the object is serviced. Otherwise, the
    ///                      method obtains the information from the network domain controller, then notifies <b>IDiskQuotaEvents</b>.
    ///                      </td> </tr> <tr> <td width="40%"><a id="DISKQUOTA_USERNAME_RESOLVE_NONE"></a><a
    ///                      id="diskquota_username_resolve_none"></a><dl> <dt><b>DISKQUOTA_USERNAME_RESOLVE_NONE</b></dt> <dt>0</dt>
    ///                      </dl> </td> <td width="60%"> Do not resolve user account information. </td> </tr> <tr> <td width="40%"><a
    ///                      id="DISKQUOTA_USERNAME_RESOLVE_SYNC"></a><a id="diskquota_username_resolve_sync"></a><dl>
    ///                      <dt><b>DISKQUOTA_USERNAME_RESOLVE_SYNC</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Resolve user account
    ///                      information synchronously. <b>AddUserSid</b> returns when the information is resolved. If the information
    ///                      exists in the disk quota SID cache, it is returned immediately. Otherwise, the method must locate the
    ///                      information. This can take several seconds. </td> </tr> </table>
    ///    ppUser = A pointer to the IDiskQuotaUser interface pointer to the newly created quota user object.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_INVALID_SID</b></dt> </dl> </td> <td width="60%"> The specified SDI is unknown. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The
    ///    <b>DiskQuotaControl</b> object is not initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pUserSid</i> or <i>ppUser</i> parameter is
    ///    <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> An unexpected file system error occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT AddUserSid(void* pUserSid, uint fNameResolution, IDiskQuotaUser* ppUser);
    ///Adds a new quota entry on the volume for the specified user. The user is identified by domain and account name.
    ///Params:
    ///    pszLogonName = The user's account logon name string.
    ///    fNameResolution = Indicates how the user account information is to be obtained. The volume's quota information identifies users
    ///                      by SID. The user account information (such as container, logon name, and display name) must be obtained from
    ///                      the network domain controller, or the local computer if it is not on a network. This parameter can be one of
    ///                      the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                      id="DISKQUOTA_USERNAME_RESOLVE_ASYNC"></a><a id="diskquota_username_resolve_async"></a><dl>
    ///                      <dt><b>DISKQUOTA_USERNAME_RESOLVE_ASYNC</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Resolve user account
    ///                      information asynchronously. <b>AddUserName</b> returns immediately. The caller must implement the
    ///                      IDiskQuotaEvents interface to receive notification when the information is available. If the information was
    ///                      cached during a previous request, notification occurs as soon as the object is serviced. Otherwise, the
    ///                      method obtains the information from the network domain controller, then notifies <b>IDiskQuotaEvents</b>.
    ///                      </td> </tr> <tr> <td width="40%"><a id="DISKQUOTA_USERNAME_RESOLVE_NONE"></a><a
    ///                      id="diskquota_username_resolve_none"></a><dl> <dt><b>DISKQUOTA_USERNAME_RESOLVE_NONE</b></dt> <dt>0</dt>
    ///                      </dl> </td> <td width="60%"> Do not resolve user account information. </td> </tr> <tr> <td width="40%"><a
    ///                      id="DISKQUOTA_USERNAME_RESOLVE_SYNC"></a><a id="diskquota_username_resolve_sync"></a><dl>
    ///                      <dt><b>DISKQUOTA_USERNAME_RESOLVE_SYNC</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Resolve user account
    ///                      information synchronously. <b>AddUserName</b> returns when the information is resolved. If the information
    ///                      exists in the disk quota SID cache, it is returned immediately. Otherwise, the method must locate the
    ///                      information. This can take several seconds. </td> </tr> </table>
    ///    ppUser = A pointer to the IDiskQuotaUser interface pointer to the newly created quota user object.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> User
    ///    already exists. Not added. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_READY</b></dt> </dl> </td>
    ///    <td width="60%"> The <b>DiskQuotaControl</b> object is not initialized. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>ERROR_USER_UNKNOWN</b></dt> </dl> </td> <td width="60%"> The specified user name is unknown.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> A pointer
    ///    parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td>
    ///    <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected file system error occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT AddUserName(const(wchar)* pszLogonName, uint fNameResolution, IDiskQuotaUser* ppUser);
    ///Removes a user entry from the volume quota information file, if the user's charged quota amount is zero (0)
    ///bytes.
    ///Params:
    ///    pUser = A pointer to the IDiskQuotaUser interface of the user whose quota record is marked for deletion.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_FILE_EXISTS</b></dt> </dl> </td> <td width="60%"> The user owns files on the volume. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The
    ///    <b>DiskQuotaControl</b> object is not initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pUser</i> parameter is <b>NULL</b>. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient
    ///    memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected file system error occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt>
    ///    </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT DeleteUser(IDiskQuotaUser pUser);
    ///Locates a specific user entry in the volume quota information. The user's security identifier (SID) is used as
    ///the search key.
    ///Params:
    ///    pUserSid = A pointer to the user's SID.
    ///    fNameResolution = Indicates how the user account information is to be obtained. The volume's quota information identifies users
    ///                      by SID. The user account information (such as domain name, account name, and full name) must be obtained from
    ///                      the network domain controller, or the local computer if it is not on a network. This parameter can be one of
    ///                      the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                      id="DISKQUOTA_USERNAME_RESOLVE_ASYNC"></a><a id="diskquota_username_resolve_async"></a><dl>
    ///                      <dt><b>DISKQUOTA_USERNAME_RESOLVE_ASYNC</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Resolve user account
    ///                      information asynchronously. <b>FindUserSid</b> returns immediately. The caller must implement the
    ///                      IDiskQuotaEvents interface to receive notification when the information is available. If the information was
    ///                      cached during a previous request, notification occurs as soon as the object is serviced. Otherwise, the
    ///                      method obtains the information from the network domain controller, then notifies <b>IDiskQuotaEvents</b>.
    ///                      </td> </tr> <tr> <td width="40%"><a id="DISKQUOTA_USERNAME_RESOLVE_NONE"></a><a
    ///                      id="diskquota_username_resolve_none"></a><dl> <dt><b>DISKQUOTA_USERNAME_RESOLVE_NONE</b></dt> <dt>0</dt>
    ///                      </dl> </td> <td width="60%"> Do not resolve user account information. </td> </tr> <tr> <td width="40%"><a
    ///                      id="DISKQUOTA_USERNAME_RESOLVE_SYNC"></a><a id="diskquota_username_resolve_sync"></a><dl>
    ///                      <dt><b>DISKQUOTA_USERNAME_RESOLVE_SYNC</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Resolve user account
    ///                      information synchronously. <b>FindUserSid</b> returns when the information has been resolved. If the
    ///                      information exists in the disk quota SID cache, it is returned immediately. Otherwise, the method must locate
    ///                      the information. This can take several seconds. </td> </tr> </table>
    ///    ppUser = Pointer to receive the IDiskQuotaUser interface pointer to the quota user object.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The <b>DiskQuotaControl</b> object is not
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_SID</b></dt> </dl> </td> <td
    ///    width="60%"> The SID for the user is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pUserSid</i> or <i>ppUser</i> parameter is
    ///    <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> An unexpected file system error occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT FindUserSid(void* pUserSid, uint fNameResolution, IDiskQuotaUser* ppUser);
    ///Locates a specific entry in the volume quota information. The user's account logon name is used as the search
    ///key.
    ///Params:
    ///    pszLogonName = A pointer to the user's account logon name.
    ///    ppUser = A pointer to the IDiskQuotaUser interface pointer to the quota user object.
    ///Returns:
    ///    This method returns a file system error or one of the following values. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller has insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_INVALID_SID</b></dt> </dl> </td> <td width="60%"> The SID for the user is invalid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>ERROR_NONE_MAPPED</b></dt> </dl> </td> <td width="60%"> There is no mapping
    ///    available for the SID. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td
    ///    width="60%"> The <b>DiskQuotaControl</b> object is not initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pUserSid</i> or <i>ppUser</i> parameter is
    ///    <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> An unexpected file system error occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT FindUserName(const(wchar)* pszLogonName, IDiskQuotaUser* ppUser);
    ///Creates an enumerator object for enumerating quota users on the volume. The newly created object implements the
    ///IEnumDiskQuotaUsers interface.
    ///Params:
    ///    rgpUserSids = An array of security identifier (SID) pointers representing the user objects to be included in the
    ///                  enumeration. If this value is <b>NULL</b>, all user entries are enumerated.
    ///    cpSids = The number of items in the <i>rgpUserSids</i> array. Ignored if <i>rgpUserSids</i> is <b>NULL</b>.
    ///    fNameResolution = Indicates how the user account information is to be obtained. The volume's quota information identifies users
    ///                      by SID. The user account information (such as domain name, account name, and full name) must be obtained from
    ///                      the network domain controller, or the local computer if it is not on a network. This parameter can be one of
    ///                      the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                      id="DISKQUOTA_USERNAME_RESOLVE_ASYNC"></a><a id="diskquota_username_resolve_async"></a><dl>
    ///                      <dt><b>DISKQUOTA_USERNAME_RESOLVE_ASYNC</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Resolve user account
    ///                      information asynchronously. The IEnumDiskQuotaUsers::Next method returns immediately. The caller must
    ///                      implement the IDiskQuotaEvents interface to receive notification when the information is available. If the
    ///                      information was cached during a previous request, notification occurs as soon as the object is serviced.
    ///                      Otherwise, the method obtains the information from the network domain controller, then notifies
    ///                      <b>IDiskQuotaEvents</b>. </td> </tr> <tr> <td width="40%"><a id="DISKQUOTA_USERNAME_RESOLVE_NONE"></a><a
    ///                      id="diskquota_username_resolve_none"></a><dl> <dt><b>DISKQUOTA_USERNAME_RESOLVE_NONE</b></dt> <dt>0</dt>
    ///                      </dl> </td> <td width="60%"> Do not resolve user account information. </td> </tr> <tr> <td width="40%"><a
    ///                      id="DISKQUOTA_USERNAME_RESOLVE_SYNC"></a><a id="diskquota_username_resolve_sync"></a><dl>
    ///                      <dt><b>DISKQUOTA_USERNAME_RESOLVE_SYNC</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Resolve user account
    ///                      information synchronously. The IEnumDiskQuotaUsers::Next method returns when the information is resolved. If
    ///                      the information exists in the disk quota SID cache, it is returned immediately. Otherwise, the method must
    ///                      locate the information. This can take several seconds. </td> </tr> </table>
    ///    ppEnum = A pointer to a pointer to the IEnumDiskQuotaUsers enumerator.
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The caller has
    ///    insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_READY</b></dt> </dl>
    ///    </td> <td width="60%"> The DiskQuotaControl object is not initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is <b>NULL</b>. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient
    ///    memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT CreateEnumUsers(void** rgpUserSids, uint cpSids, uint fNameResolution, IEnumDiskQuotaUsers* ppEnum);
    ///Creates a batching object for optimizing updates to the quota settings of multiple users simultaneously.
    ///Params:
    ///    ppBatch = A pointer to the IDiskQuotaUserBatch interface pointer.
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The caller has
    ///    insufficient access rights. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_READY</b></dt> </dl>
    ///    </td> <td width="60%"> The <b>DiskQuotaControl</b> object is not initialized. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ppBatch</i> parameter is
    ///    <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected exception occurred. </td> </tr> </table>
    ///    
    HRESULT CreateUserBatch(IDiskQuotaUserBatch* ppBatch);
    ///Invalidates the contents of the system's SID-to-name cache so subsequent requests for new user objects
    ///(IEnumDiskQuotaUsers::Next, IDiskQuotaControl::FindUserSid, and IDiskQuotaControl::FindUserName) must obtain user
    ///names from the domain controller. As names are obtained, they are cached.
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The <b>DiskQuotaControl</b>
    ///    object is not initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td>
    ///    <td width="60%"> Insufficient memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt>
    ///    </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The SID-to-name cache is not available or could not be
    ///    exclusively locked. </td> </tr> </table>
    ///    
    HRESULT InvalidateSidNameCache();
    ///Promotes the specified user object to the head of the queue so that it is next in line for resolution. By
    ///default, quota user objects are serviced in the order in which they were placed in the queue. This method is
    ///applicable only when asynchronous name resolution is used.
    ///Params:
    ///    pUser = A pointer to the IDiskQuotaUser interface.
    ///Returns:
    ///    This method returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>ERROR_NOT_READY</b></dt> </dl> </td> <td width="60%"> The <b>DiskQuotaControl</b>
    ///    object is not initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> Quota user object not in the resolver queue. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected exception occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT GiveUserNameResolutionPriority(IDiskQuotaUser pUser);
    ///The SID-to-name resolver translates user security identifiers (SID) to user names. It runs as a background
    ///thread. When a quota control object is destroyed, this thread automatically terminates. The final call to the
    ///IUnknown::Release method terminates the thread. This is normally all that is required. If you finish with the
    ///quota control object, but it is not ready to be destroyed (there are other open reference counts), call this
    ///method to terminate the background thread before the object is destroyed.
    ///Returns:
    ///    This method returns <b>S_OK</b>.
    ///    
    HRESULT ShutdownNameResolution();
}

///A client must implement the <b>IDiskQuotaEvents</b> interface as an event sink that receives the quota-related event
///notifications. Its methods are called by the system whenever significant quota events have occurred. Currently, the
///only event supported is the asynchronous resolution of user account name information.
@GUID("7988B579-EC89-11CF-9C00-00AA00A14F56")
interface IDiskQuotaEvents : IUnknown
{
    ///Notifies the client's connection sink whenever a user's SID has been asynchronously resolved. If
    ///IDiskQuotaUser::GetAccountStatus returns DISKQUOTA_USER_ACCOUNT_RESOLVED, the user's account container name,
    ///logon name, and display name strings are available in the quota user object.
    ///Params:
    ///    pUser = A pointer to the IDiskQuotaUser interface for the quota user object. Do not call Release on this pointer. The
    ///            <b>DiskQuotaControl</b> object controls the lifetime of the user object.
    ///Returns:
    ///    The return value is ignored.
    ///    
    HRESULT OnUserNameChanged(IDiskQuotaUser pUser);
}


// GUIDs


const GUID IID_IDiskQuotaControl   = GUIDOF!IDiskQuotaControl;
const GUID IID_IDiskQuotaEvents    = GUIDOF!IDiskQuotaEvents;
const GUID IID_IDiskQuotaUser      = GUIDOF!IDiskQuotaUser;
const GUID IID_IDiskQuotaUserBatch = GUIDOF!IDiskQuotaUserBatch;
const GUID IID_IEnumDiskQuotaUsers = GUIDOF!IEnumDiskQuotaUsers;
