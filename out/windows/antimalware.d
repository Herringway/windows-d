// Written in the D programming language.

module windows.antimalware;

public import windows.core;
public import windows.com : HRESULT, IUnknown;
public import windows.systemservices : BOOL, PWSTR;

extern(Windows) @nogc nothrow:


// Enums


///The <b>AMSI_RESULT</b> enumeration specifies the types of results returned by scans.
alias AMSI_RESULT = int;
enum : int
{
    ///Known good. No detection found, and the result is likely not going to change after a future definition update.
    AMSI_RESULT_CLEAN                  = 0x00000000,
    ///No detection found, but the result might change after a future definition update.
    AMSI_RESULT_NOT_DETECTED           = 0x00000001,
    ///Administrator policy blocked this content on this machine (beginning of range).
    AMSI_RESULT_BLOCKED_BY_ADMIN_START = 0x00004000,
    ///Administrator policy blocked this content on this machine (end of range).
    AMSI_RESULT_BLOCKED_BY_ADMIN_END   = 0x00004fff,
    ///Detection found. The content is considered malware and should be blocked.
    AMSI_RESULT_DETECTED               = 0x00008000,
}

///The <b>AMSI_ATTRIBUTE</b> enumeration specifies the types of attributes that can be requested by
///IAmsiStream::GetAttribute.
alias AMSI_ATTRIBUTE = int;
enum : int
{
    ///Return the name, version, or GUID string of the calling application, copied from a <b>LPWSTR</b>.
    AMSI_ATTRIBUTE_APP_NAME               = 0x00000000,
    ///Return the filename, URL, unique script ID, or similar of the content, copied from a <b>LPWSTR</b>.
    AMSI_ATTRIBUTE_CONTENT_NAME           = 0x00000001,
    ///Return the size of the input, as a <b>ULONGLONG</b>.
    AMSI_ATTRIBUTE_CONTENT_SIZE           = 0x00000002,
    ///Return the memory address if the content is fully loaded into memory.
    AMSI_ATTRIBUTE_CONTENT_ADDRESS        = 0x00000003,
    ///Session is used to associate different scan calls, such as if the contents to be scanned belong to the sample
    ///original script. Return a <b>PVOID</b> to the next portion of the content to be scanned. Return <b>nullptr</b> if
    ///the content is self-contained.
    AMSI_ATTRIBUTE_SESSION                = 0x00000004,
    AMSI_ATTRIBUTE_REDIRECT_CHAIN_SIZE    = 0x00000005,
    AMSI_ATTRIBUTE_REDIRECT_CHAIN_ADDRESS = 0x00000006,
    AMSI_ATTRIBUTE_ALL_SIZE               = 0x00000007,
    AMSI_ATTRIBUTE_ALL_ADDRESS            = 0x00000008,
    AMSI_ATTRIBUTE_QUIET                  = 0x00000009,
}

alias AMSI_UAC_REQUEST_TYPE = int;
enum : int
{
    AMSI_UAC_REQUEST_TYPE_EXE          = 0x00000000,
    AMSI_UAC_REQUEST_TYPE_COM          = 0x00000001,
    AMSI_UAC_REQUEST_TYPE_MSI          = 0x00000002,
    AMSI_UAC_REQUEST_TYPE_AX           = 0x00000003,
    AMSI_UAC_REQUEST_TYPE_PACKAGED_APP = 0x00000004,
    AMSI_UAC_REQUEST_TYPE_MAX          = 0x00000005,
}

alias AMSI_UAC_TRUST_STATE = int;
enum : int
{
    AMSI_UAC_TRUST_STATE_TRUSTED   = 0x00000000,
    AMSI_UAC_TRUST_STATE_UNTRUSTED = 0x00000001,
    AMSI_UAC_TRUST_STATE_BLOCKED   = 0x00000002,
    AMSI_UAC_TRUST_STATE_MAX       = 0x00000003,
}

alias AMSI_UAC_MSI_ACTION = int;
enum : int
{
    AMSI_UAC_MSI_ACTION_INSTALL     = 0x00000000,
    AMSI_UAC_MSI_ACTION_UNINSTALL   = 0x00000001,
    AMSI_UAC_MSI_ACTION_UPDATE      = 0x00000002,
    AMSI_UAC_MSI_ACTION_MAINTENANCE = 0x00000003,
    AMSI_UAC_MSI_ACTION_MAX         = 0x00000004,
}

// Structs


struct AMSI_UAC_REQUEST_EXE_INFO
{
    uint  ulLength;
    PWSTR lpwszApplicationName;
    PWSTR lpwszCommandLine;
    PWSTR lpwszDLLParameter;
}

struct AMSI_UAC_REQUEST_COM_INFO
{
    uint  ulLength;
    PWSTR lpwszServerBinary;
    PWSTR lpwszRequestor;
    GUID  Clsid;
}

struct AMSI_UAC_REQUEST_MSI_INFO
{
    uint                ulLength;
    AMSI_UAC_MSI_ACTION MsiAction;
    PWSTR               lpwszProductName;
    PWSTR               lpwszVersion;
    PWSTR               lpwszLanguage;
    PWSTR               lpwszManufacturer;
    PWSTR               lpwszPackagePath;
    PWSTR               lpwszPackageSource;
    uint                ulUpdates;
    PWSTR*              ppwszUpdates;
    PWSTR*              ppwszUpdateSources;
}

struct AMSI_UAC_REQUEST_AX_INFO
{
    uint  ulLength;
    PWSTR lpwszLocalInstallPath;
    PWSTR lpwszSourceURL;
}

struct AMSI_UAC_REQUEST_PACKAGED_APP_INFO
{
    uint  ulLength;
    PWSTR lpwszApplicationName;
    PWSTR lpwszCommandLine;
    PWSTR lpPackageFamilyName;
    PWSTR lpApplicationId;
}

struct AMSI_UAC_REQUEST_CONTEXT
{
    uint                 ulLength;
    uint                 ulRequestorProcessId;
    AMSI_UAC_TRUST_STATE UACTrustState;
    AMSI_UAC_REQUEST_TYPE Type;
union RequestType
    {
        AMSI_UAC_REQUEST_EXE_INFO ExeInfo;
        AMSI_UAC_REQUEST_COM_INFO ComInfo;
        AMSI_UAC_REQUEST_MSI_INFO MsiInfo;
        AMSI_UAC_REQUEST_AX_INFO ActiveXInfo;
        AMSI_UAC_REQUEST_PACKAGED_APP_INFO PackagedAppInfo;
    }
    BOOL                 bAutoElevateRequest;
}

struct HAMSICONTEXT__
{
    int unused;
}

struct HAMSISESSION__
{
    int unused;
}

// Functions

///Initialize the AMSI API.
///Params:
///    appName = The name, version, or GUID string of the app calling the AMSI API.
///    amsiContext = A handle of type HAMSICONTEXT that must be passed to all subsequent calls to the AMSI API.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("Amsi")
HRESULT AmsiInitialize(const(PWSTR) appName, ptrdiff_t* amsiContext);

///Remove the instance of the AMSI API that was originally opened by AmsiInitialize.
///Params:
///    amsiContext = The handle of type HAMSICONTEXT that was initially received from AmsiInitialize.
@DllImport("Amsi")
void AmsiUninitialize(ptrdiff_t amsiContext);

///Opens a session within which multiple scan requests can be correlated.
///Params:
///    amsiContext = The handle of type HAMSICONTEXT that was initially received from AmsiInitialize.
///    amsiSession = A handle of type HAMSISESSION that must be passed to all subsequent calls to the AMSI API within the session.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("Amsi")
HRESULT AmsiOpenSession(ptrdiff_t amsiContext, ptrdiff_t* amsiSession);

///Close a session that was opened by AmsiOpenSession.
///Params:
///    amsiContext = The handle of type HAMSICONTEXT that was initially received from AmsiInitialize.
///    amsiSession = The handle of type HAMSISESSION that was initially received from AmsiOpenSession.
@DllImport("Amsi")
void AmsiCloseSession(ptrdiff_t amsiContext, ptrdiff_t amsiSession);

///Scans a buffer-full of content for malware.
///Params:
///    amsiContext = The handle of type HAMSICONTEXT that was initially received from AmsiInitialize.
///    buffer = The buffer from which to read the data to be scanned.
///    length = The length, in bytes, of the data to be read from <i>buffer</i>.
///    contentName = The filename, URL, unique script ID, or similar of the content being scanned.
///    amsiSession = If multiple scan requests are to be correlated within a session, set <i>session</i> to the handle of type
///                  HAMSISESSION that was initially received from AmsiOpenSession. Otherwise, set <i>session</i> to <b>nullptr</b>.
///    result = The result of the scan. See AMSI_RESULT. An app should use AmsiResultIsMalware to determine whether the content
///             should be blocked.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("Amsi")
HRESULT AmsiScanBuffer(ptrdiff_t amsiContext, void* buffer, uint length, const(PWSTR) contentName, 
                       ptrdiff_t amsiSession, AMSI_RESULT* result);

///Scans a string for malware.
///Params:
///    amsiContext = The handle of type HAMSICONTEXT that was initially received from AmsiInitialize.
///    string = The string to be scanned.
///    contentName = The filename, URL, unique script ID, or similar of the content being scanned.
///    amsiSession = If multiple scan requests are to be correlated within a session, set <i>session</i> to the handle of type
///                  HAMSISESSION that was initially received from AmsiOpenSession. Otherwise, set <i>session</i> to <b>nullptr</b>.
///    result = The result of the scan. See AMSI_RESULT. An app should use AmsiResultIsMalware to determine whether the content
///             should be blocked.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("Amsi")
HRESULT AmsiScanString(ptrdiff_t amsiContext, const(PWSTR) string, const(PWSTR) contentName, ptrdiff_t amsiSession, 
                       AMSI_RESULT* result);


// Interfaces

@GUID("FDB00E52-A214-4AA1-8FBA-4357BB0072EC")
struct CAntimalware;

///Represents a stream to be scanned. For a code example, see the [IAmsiStream interface
///sample](https://github.com/Microsoft/Windows-classic-samples/tree/master/Samples/AmsiStream).
@GUID("3E47F2E5-81D4-4D3B-897F-545096770373")
interface IAmsiStream : IUnknown
{
    ///Returns a requested attribute from the stream.
    ///Params:
    ///    attribute = Specifies the type of attribute to be returned. See Remarks.
    ///    dataSize = The size of the output buffer, <i>data</i>, in bytes.
    ///    data = Buffer to receive the requested attribute. <i>data</i> must be set to its size in bytes.
    ///    retData = The number of bytes returned in <i>data</i>. If this method returns <b>E_NOT_SUFFICIENT_BUFFER</b>,
    ///              <i>retData</i> contains the number of bytes required.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The attribute is not supported.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOT_SUFFICIENT_BUFFER</b></dt> </dl> </td> <td width="60%">
    ///    The size of the output buffer, as indicated by <i>data</i>, is not large enough. <i>retData</i> contains the
    ///    number of bytes required. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more argument is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOT_VALID_STATE</b></dt> </dl> </td> <td width="60%"> The object is not initialized. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAttribute(AMSI_ATTRIBUTE attribute, uint dataSize, ubyte* data, uint* retData);
    ///Requests a buffer-full of content to be read.
    ///Params:
    ///    position = The zero-based index into the content at which the read is to begin.
    ///    size = The number of bytes to read from the content.
    ///    buffer = Buffer into which the content is to be read.
    ///    readSize = The number of bytes read into <i>buffer</i>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more argument is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOT_VALID_STATE</b></dt> </dl> </td> <td width="60%"> The
    ///    object is not initialized. </td> </tr> </table>
    ///    
    HRESULT Read(ulong position, uint size, ubyte* buffer, uint* readSize);
}

///Represents the provider of the antimalware product. For a code example, see the [IAntimalwareProvider interface
///sample](https://github.com/Microsoft/Windows-classic-samples/tree/master/Samples/AmsiProvider). The
///**IAntimalwareProvider** interface inherits from the [IUnknown
///interface](/windows/desktop/api/unknwn/nn-unknwn-iunknown).
@GUID("B2CABFE3-FE04-42B1-A5DF-08D483D4D125")
interface IAntimalwareProvider : IUnknown
{
    ///Scan a stream of content.
    ///Params:
    ///    stream = The IAmsiStream stream to be scanned.
    ///    result = The result of the scan. See AMSI_RESULT.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more argument is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOT_VALID_STATE</b></dt> </dl> </td> <td width="60%"> The
    ///    object is not initialized. </td> </tr> </table>
    ///    
    HRESULT Scan(IAmsiStream stream, AMSI_RESULT* result);
    ///Closes the session.
    ///Params:
    ///    session = Type: [ULONGLONG](/windows/desktop/winprog/windows-data-types
    void    CloseSession(ulong session);
    ///The name of the antimalware provider to be displayed.
    ///Params:
    ///    displayName = A pointer to a <b>LPWSTR</b> that contains the display name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The argument is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOT_VALID_STATE</b></dt> </dl> </td> <td width="60%"> The object is
    ///    not initialized. </td> </tr> </table>
    ///    
    HRESULT DisplayName(PWSTR* displayName);
}

@GUID("B2CABFE4-FE04-42B1-A5DF-08D483D4D125")
interface IAntimalwareUacProvider : IUnknown
{
    HRESULT UacScan(AMSI_UAC_REQUEST_CONTEXT* context, AMSI_RESULT* result);
    HRESULT DisplayName(PWSTR* displayName);
}

///Represents the antimalware product.
@GUID("82D29C2E-F062-44E6-B5C9-3D9A2F24A2DF")
interface IAntimalware : IUnknown
{
    ///Scan a stream of content.
    ///Params:
    ///    stream = The IAmsiStream stream to be scanned.
    ///    result = The result of the scan. See AMSI_RESULT.
    ///    provider = The IAntimalwareProvider provider of the antimalware product.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more argument is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOT_VALID_STATE</b></dt> </dl> </td> <td width="60%"> The
    ///    object is not initialized. </td> </tr> </table>
    ///    
    HRESULT Scan(IAmsiStream stream, AMSI_RESULT* result, IAntimalwareProvider* provider);
    ///Closes the session.
    ///Params:
    ///    session = Type: [ULONGLONG](/windows/desktop/winprog/windows-data-types
    void    CloseSession(ulong session);
}


// GUIDs

const GUID CLSID_CAntimalware = GUIDOF!CAntimalware;

const GUID IID_IAmsiStream             = GUIDOF!IAmsiStream;
const GUID IID_IAntimalware            = GUIDOF!IAntimalware;
const GUID IID_IAntimalwareProvider    = GUIDOF!IAntimalwareProvider;
const GUID IID_IAntimalwareUacProvider = GUIDOF!IAntimalwareUacProvider;
